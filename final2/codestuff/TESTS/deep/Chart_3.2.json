{
  "bug_id": "3",
  "failed_tests": {
    "org.jfree.data.time.junit.TimeSeriesTests": [
      {
        "methodName": "testCreateCopy3",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<101.0> but was:<102.0>",
        "fail_line": "        assertEquals(101.0, s2.getMaxY(), EPSILON);",
        "test_source": "  public void testCreateCopy3() throws CloneNotSupportedException {\n  TimeSeries s1 = new TimeSeries(\"S1\");\n  s1.add(new Year(2009), 100.0);\n  s1.add(new Year(2010), 101.0);\n  s1.add(new Year(2011), 102.0);\n  assertEquals(100.0, s1.getMinY(), EPSILON);\n  assertEquals(102.0, s1.getMaxY(), EPSILON);\n\n  TimeSeries s2 = s1.createCopy(0, 1);\n  assertEquals(100.0, s2.getMinY(), EPSILON);\n  assertEquals(101.0, s2.getMaxY(), EPSILON);\n\n  TimeSeries s3 = s1.createCopy(1, 2);\n  assertEquals(101.0, s3.getMinY(), EPSILON);\n  assertEquals(102.0, s3.getMaxY(), EPSILON);\n  }",
        "stack": [
          "TimeSeriesTests.testCreateCopy3 line 607"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jfree/data/time/TimeSeries.java",
      "buggy_full_code": "\n\npackage org.jfree.data.time;\n\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.TimeZone;\n\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.data.general.Series;\nimport org.jfree.data.event.SeriesChangeEvent;\nimport org.jfree.data.general.SeriesException;\n\n\npublic class TimeSeries extends Series implements Cloneable, Serializable {\n\n    \n    private static final long serialVersionUID = -5032960206869675528L;\n\n    \n    protected static final String DEFAULT_DOMAIN_DESCRIPTION = \"Time\";\n\n    \n    protected static final String DEFAULT_RANGE_DESCRIPTION = \"Value\";\n\n    \n    private String domain;\n\n    \n    private String range;\n\n    \n    protected Class timePeriodClass;\n\n    \n    protected List data;\n\n    \n    private int maximumItemCount;\n\n    \n    private long maximumItemAge;\n\n    \n    private double minY;\n\n    \n    private double maxY;\n\n    \n    public TimeSeries(Comparable name) {\n        this(name, DEFAULT_DOMAIN_DESCRIPTION, DEFAULT_RANGE_DESCRIPTION);\n    }\n\n    \n    public TimeSeries(Comparable name, String domain, String range) {\n        super(name);\n        this.domain = domain;\n        this.range = range;\n        this.timePeriodClass = null;\n        this.data = new java.util.ArrayList();\n        this.maximumItemCount = Integer.MAX_VALUE;\n        this.maximumItemAge = Long.MAX_VALUE;\n        this.minY = Double.NaN;\n        this.maxY = Double.NaN;\n    }\n\n    \n    public String getDomainDescription() {\n        return this.domain;\n    }\n\n    \n    public void setDomainDescription(String description) {\n        String old = this.domain;\n        this.domain = description;\n        firePropertyChange(\"Domain\", old, description);\n    }\n\n    \n    public String getRangeDescription() {\n        return this.range;\n    }\n\n    \n    public void setRangeDescription(String description) {\n        String old = this.range;\n        this.range = description;\n        firePropertyChange(\"Range\", old, description);\n    }\n\n    \n    public int getItemCount() {\n        return this.data.size();\n    }\n\n    \n    public List getItems() {\n        \n        return Collections.unmodifiableList(this.data);\n    }\n\n    \n    public int getMaximumItemCount() {\n        return this.maximumItemCount;\n    }\n\n    \n    public void setMaximumItemCount(int maximum) {\n        if (maximum < 0) {\n            throw new IllegalArgumentException(\"Negative 'maximum' argument.\");\n        }\n        this.maximumItemCount = maximum;\n        int count = this.data.size();\n        if (count > maximum) {\n            delete(0, count - maximum - 1);\n        }\n    }\n\n    \n    public long getMaximumItemAge() {\n        return this.maximumItemAge;\n    }\n\n    \n    public void setMaximumItemAge(long periods) {\n        if (periods < 0) {\n            throw new IllegalArgumentException(\"Negative 'periods' argument.\");\n        }\n        this.maximumItemAge = periods;\n        removeAgedItems(true);  \n    }\n\n    \n    public double getMinY() {\n        return this.minY;\n    }\n\n    \n    public double getMaxY() {\n        return this.maxY;\n    }\n\n    \n    public Class getTimePeriodClass() {\n        return this.timePeriodClass;\n    }\n\n    \n    public TimeSeriesDataItem getDataItem(int index) {\n        TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index);\n        return (TimeSeriesDataItem) item.clone();\n    }\n\n    \n    public TimeSeriesDataItem getDataItem(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            return getDataItem(index);\n        }\n        else {\n            return null;\n        }\n    }\n\n    \n    TimeSeriesDataItem getRawDataItem(int index) {\n        return (TimeSeriesDataItem) this.data.get(index);\n    }\n\n    \n    TimeSeriesDataItem getRawDataItem(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            return (TimeSeriesDataItem) this.data.get(index);\n        }\n        else {\n            return null;\n        }\n    }\n\n    \n    public RegularTimePeriod getTimePeriod(int index) {\n        return getRawDataItem(index).getPeriod();\n    }\n\n    \n    public RegularTimePeriod getNextTimePeriod() {\n        RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\n        return last.next();\n    }\n\n    \n    public Collection getTimePeriods() {\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < getItemCount(); i++) {\n            result.add(getTimePeriod(i));\n        }\n        return result;\n    }\n\n    \n    public Collection getTimePeriodsUniqueToOtherSeries(TimeSeries series) {\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < series.getItemCount(); i++) {\n            RegularTimePeriod period = series.getTimePeriod(i);\n            int index = getIndex(period);\n            if (index < 0) {\n                result.add(period);\n            }\n        }\n        return result;\n    }\n\n    \n    public int getIndex(RegularTimePeriod period) {\n        if (period == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");\n        }\n        TimeSeriesDataItem dummy = new TimeSeriesDataItem(\n              period, Integer.MIN_VALUE);\n        return Collections.binarySearch(this.data, dummy);\n    }\n\n    \n    public Number getValue(int index) {\n        return getRawDataItem(index).getValue();\n    }\n\n    \n    public Number getValue(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            return getValue(index);\n        }\n        else {\n            return null;\n        }\n    }\n\n    \n    public void add(TimeSeriesDataItem item) {\n        add(item, true);\n    }\n\n    \n    public void add(TimeSeriesDataItem item, boolean notify) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        item = (TimeSeriesDataItem) item.clone();\n        Class c = item.getPeriod().getClass();\n        if (this.timePeriodClass == null) {\n            this.timePeriodClass = c;\n        }\n        else if (!this.timePeriodClass.equals(c)) {\n            StringBuffer b = new StringBuffer();\n            b.append(\"You are trying to add data where the time period class \");\n            b.append(\"is \");\n            b.append(item.getPeriod().getClass().getName());\n            b.append(\", but the TimeSeries is expecting an instance of \");\n            b.append(this.timePeriodClass.getName());\n            b.append(\".\");\n            throw new SeriesException(b.toString());\n        }\n\n        \n        boolean added = false;\n        int count = getItemCount();\n        if (count == 0) {\n            this.data.add(item);\n            added = true;\n        }\n        else {\n            RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\n            if (item.getPeriod().compareTo(last) > 0) {\n                this.data.add(item);\n                added = true;\n            }\n            else {\n                int index = Collections.binarySearch(this.data, item);\n                if (index < 0) {\n                    this.data.add(-index - 1, item);\n                    added = true;\n                }\n                else {\n                    StringBuffer b = new StringBuffer();\n                    b.append(\"You are attempting to add an observation for \");\n                    b.append(\"the time period \");\n                    b.append(item.getPeriod().toString());\n                    b.append(\" but the series already contains an observation\");\n                    b.append(\" for that time period. Duplicates are not \");\n                    b.append(\"permitted.  Try using the addOrUpdate() method.\");\n                    throw new SeriesException(b.toString());\n                }\n            }\n        }\n        if (added) {\n            updateBoundsForAddedItem(item);\n            \n            if (getItemCount() > this.maximumItemCount) {\n                TimeSeriesDataItem d = (TimeSeriesDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(d);\n            }\n\n            removeAgedItems(false);  \n                                     \n                                     \n            if (notify) {\n                fireSeriesChanged();\n            }\n        }\n\n    }\n\n    \n    public void add(RegularTimePeriod period, double value) {\n        \n        add(period, value, true);\n    }\n\n    \n    public void add(RegularTimePeriod period, double value, boolean notify) {\n        \n        TimeSeriesDataItem item = new TimeSeriesDataItem(period, value);\n        add(item, notify);\n    }\n\n    \n    public void add(RegularTimePeriod period, Number value) {\n        \n        add(period, value, true);\n    }\n\n    \n    public void add(RegularTimePeriod period, Number value, boolean notify) {\n        \n        TimeSeriesDataItem item = new TimeSeriesDataItem(period, value);\n        add(item, notify);\n    }\n\n    \n    public void update(RegularTimePeriod period, Number value) {\n        TimeSeriesDataItem temp = new TimeSeriesDataItem(period, value);\n        int index = Collections.binarySearch(this.data, temp);\n        if (index < 0) {\n            throw new SeriesException(\"There is no existing value for the \"\n                    + \"specified 'period'.\");\n        }\n        update(index, value);\n    }\n\n    \n    public void update(int index, Number value) {\n        TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index);\n        boolean iterate = false;\n        Number oldYN = item.getValue();\n        if (oldYN != null) {\n            double oldY = oldYN.doubleValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n        }\n        item.setValue(value);\n        if (iterate) {\n            findBoundsByIteration();\n        }\n        else if (value != null) {\n            double yy = value.doubleValue();\n            this.minY = minIgnoreNaN(this.minY, yy);\n            this.maxY = maxIgnoreNaN(this.maxY, yy);\n        }\n        fireSeriesChanged();\n    }\n\n    \n    public TimeSeries addAndOrUpdate(TimeSeries series) {\n        TimeSeries overwritten = new TimeSeries(\"Overwritten values from: \"\n                + getKey());\n        for (int i = 0; i < series.getItemCount(); i++) {\n            TimeSeriesDataItem item = series.getRawDataItem(i);\n            TimeSeriesDataItem oldItem = addOrUpdate(item.getPeriod(),\n                    item.getValue());\n            if (oldItem != null) {\n                overwritten.add(oldItem);\n            }\n        }\n        return overwritten;\n    }\n\n    \n    public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period,\n                                          double value) {\n        return addOrUpdate(period, new Double(value));\n    }\n\n    \n    public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period,\n                                          Number value) {\n        return addOrUpdate(new TimeSeriesDataItem(period, value));\n    }\n\n    \n    public TimeSeriesDataItem addOrUpdate(TimeSeriesDataItem item) {\n\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");\n        }\n        Class periodClass = item.getPeriod().getClass();\n        if (this.timePeriodClass == null) {\n            this.timePeriodClass = periodClass;\n        }\n        else if (!this.timePeriodClass.equals(periodClass)) {\n            String msg = \"You are trying to add data where the time \"\n                    + \"period class is \" + periodClass.getName()\n                    + \", but the TimeSeries is expecting an instance of \"\n                    + this.timePeriodClass.getName() + \".\";\n            throw new SeriesException(msg);\n        }\n        TimeSeriesDataItem overwritten = null;\n        int index = Collections.binarySearch(this.data, item);\n        if (index >= 0) {\n            TimeSeriesDataItem existing\n                    = (TimeSeriesDataItem) this.data.get(index);\n            overwritten = (TimeSeriesDataItem) existing.clone();\n            \n            \n            boolean iterate = false;\n            Number oldYN = existing.getValue();\n            double oldY = oldYN != null ? oldYN.doubleValue() : Double.NaN;\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setValue(item.getValue());\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getValue() != null) {\n                double yy = item.getValue().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            item = (TimeSeriesDataItem) item.clone();\n            this.data.add(-index - 1, item);\n            updateBoundsForAddedItem(item);\n\n            \n            if (getItemCount() > this.maximumItemCount) {\n                TimeSeriesDataItem d = (TimeSeriesDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(d);\n            }\n        }\n        removeAgedItems(false);  \n                                 \n                                 \n        fireSeriesChanged();\n        return overwritten;\n\n    }\n\n    \n    public void removeAgedItems(boolean notify) {\n        \n        \n        if (getItemCount() > 1) {\n            long latest = getTimePeriod(getItemCount() - 1).getSerialIndex();\n            boolean removed = false;\n            while ((latest - getTimePeriod(0).getSerialIndex())\n                    > this.maximumItemAge) {\n                this.data.remove(0);\n                removed = true;\n            }\n            if (removed) {\n                findBoundsByIteration();\n                if (notify) {\n                    fireSeriesChanged();\n                }\n            }\n        }\n    }\n\n    \n    public void removeAgedItems(long latest, boolean notify) {\n        if (this.data.isEmpty()) {\n            return;  \n        }\n        \n        long index = Long.MAX_VALUE;\n        try {\n            Method m = RegularTimePeriod.class.getDeclaredMethod(\n                    \"createInstance\", new Class[] {Class.class, Date.class,\n                    TimeZone.class});\n            RegularTimePeriod newest = (RegularTimePeriod) m.invoke(\n                    this.timePeriodClass, new Object[] {this.timePeriodClass,\n                            new Date(latest), TimeZone.getDefault()});\n            index = newest.getSerialIndex();\n        }\n        catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        }\n        catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n        catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n\n        \n        \n        boolean removed = false;\n        while (getItemCount() > 0 && (index\n                - getTimePeriod(0).getSerialIndex()) > this.maximumItemAge) {\n            this.data.remove(0);\n            removed = true;\n        }\n        if (removed) {\n            findBoundsByIteration();\n            if (notify) {\n                fireSeriesChanged();\n            }\n        }\n    }\n\n    \n    public void clear() {\n        if (this.data.size() > 0) {\n            this.data.clear();\n            this.timePeriodClass = null;\n            this.minY = Double.NaN;\n            this.maxY = Double.NaN;\n            fireSeriesChanged();\n        }\n    }\n\n    \n    public void delete(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.remove(\n                    index);\n            updateBoundsForRemovedItem(item);\n            if (this.data.isEmpty()) {\n                this.timePeriodClass = null;\n            }\n            fireSeriesChanged();\n        }\n    }\n\n    \n    public void delete(int start, int end) {\n        delete(start, end, true);\n    }\n\n    \n    public void delete(int start, int end, boolean notify) {\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        for (int i = 0; i <= (end - start); i++) {\n            this.data.remove(start);\n        }\n        findBoundsByIteration();\n        if (this.data.isEmpty()) {\n            this.timePeriodClass = null;\n        }\n        if (notify) {\n            fireSeriesChanged();\n        }\n    }\n\n    \n    public Object clone() throws CloneNotSupportedException {\n        TimeSeries clone = (TimeSeries) super.clone();\n        clone.data = (List) ObjectUtilities.deepClone(this.data);\n        return clone;\n    }\n\n    \n    public TimeSeries createCopy(int start, int end)\n            throws CloneNotSupportedException {\n        if (start < 0) {\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\n        }\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        TimeSeries copy = (TimeSeries) super.clone();\n        copy.data = new java.util.ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                TimeSeriesDataItem item\n                        = (TimeSeriesDataItem) this.data.get(index);\n                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return copy;\n    }\n\n    \n    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  \n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             \n            endIndex = -(endIndex + 1); \n            endIndex = endIndex - 1;    \n        }\n        if ((endIndex < 0)  || (endIndex < startIndex)) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n\n    }\n\n    \n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof TimeSeries)) {\n            return false;\n        }\n        TimeSeries that = (TimeSeries) obj;\n        if (!ObjectUtilities.equal(getDomainDescription(),\n                that.getDomainDescription())) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(getRangeDescription(),\n                that.getRangeDescription())) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.timePeriodClass,\n                that.timePeriodClass)) {\n            return false;\n        }\n        if (getMaximumItemAge() != that.getMaximumItemAge()) {\n            return false;\n        }\n        if (getMaximumItemCount() != that.getMaximumItemCount()) {\n            return false;\n        }\n        int count = getItemCount();\n        if (count != that.getItemCount()) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.data, that.data)) {\n            return false;\n        }\n        return super.equals(obj);\n    }\n\n    \n    public int hashCode() {\n        int result = super.hashCode();\n        result = 29 * result + (this.domain != null ? this.domain.hashCode()\n                : 0);\n        result = 29 * result + (this.range != null ? this.range.hashCode() : 0);\n        result = 29 * result + (this.timePeriodClass != null\n                ? this.timePeriodClass.hashCode() : 0);\n        \n        \n        int count = getItemCount();\n        if (count > 0) {\n            TimeSeriesDataItem item = getRawDataItem(0);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 1) {\n            TimeSeriesDataItem item = getRawDataItem(count - 1);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 2) {\n            TimeSeriesDataItem item = getRawDataItem(count / 2);\n            result = 29 * result + item.hashCode();\n        }\n        result = 29 * result + this.maximumItemCount;\n        result = 29 * result + (int) this.maximumItemAge;\n        return result;\n    }\n\n    \n    private void updateBoundsForAddedItem(TimeSeriesDataItem item) {\n        Number yN = item.getValue();\n        if (item.getValue() != null) {\n            double y = yN.doubleValue();\n            this.minY = minIgnoreNaN(this.minY, y);\n            this.maxY = maxIgnoreNaN(this.maxY, y);\n        }\n    }\n\n    \n    private void updateBoundsForRemovedItem(TimeSeriesDataItem item) {\n        Number yN = item.getValue();\n        if (yN != null) {\n            double y = yN.doubleValue();\n            if (!Double.isNaN(y)) {\n                if (y <= this.minY || y >= this.maxY) {\n                    findBoundsByIteration();\n                }\n            }\n        }\n    }\n\n    \n    private void findBoundsByIteration() {\n        this.minY = Double.NaN;\n        this.maxY = Double.NaN;\n        Iterator iterator = this.data.iterator();\n        while (iterator.hasNext()) {\n            TimeSeriesDataItem item = (TimeSeriesDataItem) iterator.next();\n            updateBoundsForAddedItem(item);\n        }\n    }\n\n    \n    private double minIgnoreNaN(double a, double b) {\n        if (Double.isNaN(a)) {\n            return b;\n        }\n        else {\n            if (Double.isNaN(b)) {\n                return a;\n            }\n            else {\n                return Math.min(a, b);\n            }\n        }\n    }\n\n    \n    private double maxIgnoreNaN(double a, double b) {\n        if (Double.isNaN(a)) {\n            return b;\n        }\n        else {\n            if (Double.isNaN(b)) {\n                return a;\n            }\n            else {\n                return Math.max(a, b);\n            }\n        }\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.jfree.data.time;\n\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.TimeZone;\n\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.data.general.Series;\nimport org.jfree.data.event.SeriesChangeEvent;\nimport org.jfree.data.general.SeriesException;\n\n\npublic class TimeSeries extends Series implements Cloneable, Serializable {\n\n    \n    private static final long serialVersionUID = -5032960206869675528L;\n\n    \n    protected static final String DEFAULT_DOMAIN_DESCRIPTION = \"Time\";\n\n    \n    protected static final String DEFAULT_RANGE_DESCRIPTION = \"Value\";\n\n    \n    private String domain;\n\n    \n    private String range;\n\n    \n    protected Class timePeriodClass;\n\n    \n    protected List data;\n\n    \n    private int maximumItemCount;\n\n    \n    private long maximumItemAge;\n\n    \n    private double minY;\n\n    \n    private double maxY;\n\n    \n    public TimeSeries(Comparable name) {\n        this(name, DEFAULT_DOMAIN_DESCRIPTION, DEFAULT_RANGE_DESCRIPTION);\n    }\n\n    \n    public TimeSeries(Comparable name, String domain, String range) {\n        super(name);\n        this.domain = domain;\n        this.range = range;\n        this.timePeriodClass = null;\n        this.data = new java.util.ArrayList();\n        this.maximumItemCount = Integer.MAX_VALUE;\n        this.maximumItemAge = Long.MAX_VALUE;\n        this.minY = Double.NaN;\n        this.maxY = Double.NaN;\n    }\n\n    \n    public String getDomainDescription() {\n        return this.domain;\n    }\n\n    \n    public void setDomainDescription(String description) {\n        String old = this.domain;\n        this.domain = description;\n        firePropertyChange(\"Domain\", old, description);\n    }\n\n    \n    public String getRangeDescription() {\n        return this.range;\n    }\n\n    \n    public void setRangeDescription(String description) {\n        String old = this.range;\n        this.range = description;\n        firePropertyChange(\"Range\", old, description);\n    }\n\n    \n    public int getItemCount() {\n        return this.data.size();\n    }\n\n    \n    public List getItems() {\n        \n        return Collections.unmodifiableList(this.data);\n    }\n\n    \n    public int getMaximumItemCount() {\n        return this.maximumItemCount;\n    }\n\n    \n    public void setMaximumItemCount(int maximum) {\n        if (maximum < 0) {\n            throw new IllegalArgumentException(\"Negative 'maximum' argument.\");\n        }\n        this.maximumItemCount = maximum;\n        int count = this.data.size();\n        if (count > maximum) {\n            delete(0, count - maximum - 1);\n        }\n    }\n\n    \n    public long getMaximumItemAge() {\n        return this.maximumItemAge;\n    }\n\n    \n    public void setMaximumItemAge(long periods) {\n        if (periods < 0) {\n            throw new IllegalArgumentException(\"Negative 'periods' argument.\");\n        }\n        this.maximumItemAge = periods;\n        removeAgedItems(true);  \n    }\n\n    \n    public double getMinY() {\n        return this.minY;\n    }\n\n    \n    public double getMaxY() {\n        return this.maxY;\n    }\n\n    \n    public Class getTimePeriodClass() {\n        return this.timePeriodClass;\n    }\n\n    \n    public TimeSeriesDataItem getDataItem(int index) {\n        TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index);\n        return (TimeSeriesDataItem) item.clone();\n    }\n\n    \n    public TimeSeriesDataItem getDataItem(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            return getDataItem(index);\n        }\n        else {\n            return null;\n        }\n    }\n\n    \n    TimeSeriesDataItem getRawDataItem(int index) {\n        return (TimeSeriesDataItem) this.data.get(index);\n    }\n\n    \n    TimeSeriesDataItem getRawDataItem(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            return (TimeSeriesDataItem) this.data.get(index);\n        }\n        else {\n            return null;\n        }\n    }\n\n    \n    public RegularTimePeriod getTimePeriod(int index) {\n        return getRawDataItem(index).getPeriod();\n    }\n\n    \n    public RegularTimePeriod getNextTimePeriod() {\n        RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\n        return last.next();\n    }\n\n    \n    public Collection getTimePeriods() {\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < getItemCount(); i++) {\n            result.add(getTimePeriod(i));\n        }\n        return result;\n    }\n\n    \n    public Collection getTimePeriodsUniqueToOtherSeries(TimeSeries series) {\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < series.getItemCount(); i++) {\n            RegularTimePeriod period = series.getTimePeriod(i);\n            int index = getIndex(period);\n            if (index < 0) {\n                result.add(period);\n            }\n        }\n        return result;\n    }\n\n    \n    public int getIndex(RegularTimePeriod period) {\n        if (period == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");\n        }\n        TimeSeriesDataItem dummy = new TimeSeriesDataItem(\n              period, Integer.MIN_VALUE);\n        return Collections.binarySearch(this.data, dummy);\n    }\n\n    \n    public Number getValue(int index) {\n        return getRawDataItem(index).getValue();\n    }\n\n    \n    public Number getValue(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            return getValue(index);\n        }\n        else {\n            return null;\n        }\n    }\n\n    \n    public void add(TimeSeriesDataItem item) {\n        add(item, true);\n    }\n\n    \n    public void add(TimeSeriesDataItem item, boolean notify) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        item = (TimeSeriesDataItem) item.clone();\n        Class c = item.getPeriod().getClass();\n        if (this.timePeriodClass == null) {\n            this.timePeriodClass = c;\n        }\n        else if (!this.timePeriodClass.equals(c)) {\n            StringBuffer b = new StringBuffer();\n            b.append(\"You are trying to add data where the time period class \");\n            b.append(\"is \");\n            b.append(item.getPeriod().getClass().getName());\n            b.append(\", but the TimeSeries is expecting an instance of \");\n            b.append(this.timePeriodClass.getName());\n            b.append(\".\");\n            throw new SeriesException(b.toString());\n        }\n\n        \n        boolean added = false;\n        int count = getItemCount();\n        if (count == 0) {\n            this.data.add(item);\n            added = true;\n        }\n        else {\n            RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\n            if (item.getPeriod().compareTo(last) > 0) {\n                this.data.add(item);\n                added = true;\n            }\n            else {\n                int index = Collections.binarySearch(this.data, item);\n                if (index < 0) {\n                    this.data.add(-index - 1, item);\n                    added = true;\n                }\n                else {\n                    StringBuffer b = new StringBuffer();\n                    b.append(\"You are attempting to add an observation for \");\n                    b.append(\"the time period \");\n                    b.append(item.getPeriod().toString());\n                    b.append(\" but the series already contains an observation\");\n                    b.append(\" for that time period. Duplicates are not \");\n                    b.append(\"permitted.  Try using the addOrUpdate() method.\");\n                    throw new SeriesException(b.toString());\n                }\n            }\n        }\n        if (added) {\n            updateBoundsForAddedItem(item);\n            \n            if (getItemCount() > this.maximumItemCount) {\n                TimeSeriesDataItem d = (TimeSeriesDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(d);\n            }\n\n            removeAgedItems(false);  \n                                     \n                                     \n            if (notify) {\n                fireSeriesChanged();\n            }\n        }\n\n    }\n\n    \n    public void add(RegularTimePeriod period, double value) {\n        \n        add(period, value, true);\n    }\n\n    \n    public void add(RegularTimePeriod period, double value, boolean notify) {\n        \n        TimeSeriesDataItem item = new TimeSeriesDataItem(period, value);\n        add(item, notify);\n    }\n\n    \n    public void add(RegularTimePeriod period, Number value) {\n        \n        add(period, value, true);\n    }\n\n    \n    public void add(RegularTimePeriod period, Number value, boolean notify) {\n        \n        TimeSeriesDataItem item = new TimeSeriesDataItem(period, value);\n        add(item, notify);\n    }\n\n    \n    public void update(RegularTimePeriod period, Number value) {\n        TimeSeriesDataItem temp = new TimeSeriesDataItem(period, value);\n        int index = Collections.binarySearch(this.data, temp);\n        if (index < 0) {\n            throw new SeriesException(\"There is no existing value for the \"\n                    + \"specified 'period'.\");\n        }\n        update(index, value);\n    }\n\n    \n    public void update(int index, Number value) {\n        TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index);\n        boolean iterate = false;\n        Number oldYN = item.getValue();\n        if (oldYN != null) {\n            double oldY = oldYN.doubleValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n        }\n        item.setValue(value);\n        if (iterate) {\n            findBoundsByIteration();\n        }\n        else if (value != null) {\n            double yy = value.doubleValue();\n            this.minY = minIgnoreNaN(this.minY, yy);\n            this.maxY = maxIgnoreNaN(this.maxY, yy);\n        }\n        fireSeriesChanged();\n    }\n\n    \n    public TimeSeries addAndOrUpdate(TimeSeries series) {\n        TimeSeries overwritten = new TimeSeries(\"Overwritten values from: \"\n                + getKey());\n        for (int i = 0; i < series.getItemCount(); i++) {\n            TimeSeriesDataItem item = series.getRawDataItem(i);\n            TimeSeriesDataItem oldItem = addOrUpdate(item.getPeriod(),\n                    item.getValue());\n            if (oldItem != null) {\n                overwritten.add(oldItem);\n            }\n        }\n        return overwritten;\n    }\n\n    \n    public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period,\n                                          double value) {\n        return addOrUpdate(period, new Double(value));\n    }\n\n    \n    public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period,\n                                          Number value) {\n        return addOrUpdate(new TimeSeriesDataItem(period, value));\n    }\n\n    \n    public TimeSeriesDataItem addOrUpdate(TimeSeriesDataItem item) {\n\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");\n        }\n        Class periodClass = item.getPeriod().getClass();\n        if (this.timePeriodClass == null) {\n            this.timePeriodClass = periodClass;\n        }\n        else if (!this.timePeriodClass.equals(periodClass)) {\n            String msg = \"You are trying to add data where the time \"\n                    + \"period class is \" + periodClass.getName()\n                    + \", but the TimeSeries is expecting an instance of \"\n                    + this.timePeriodClass.getName() + \".\";\n            throw new SeriesException(msg);\n        }\n        TimeSeriesDataItem overwritten = null;\n        int index = Collections.binarySearch(this.data, item);\n        if (index >= 0) {\n            TimeSeriesDataItem existing\n                    = (TimeSeriesDataItem) this.data.get(index);\n            overwritten = (TimeSeriesDataItem) existing.clone();\n            \n            \n            boolean iterate = false;\n            Number oldYN = existing.getValue();\n            double oldY = oldYN != null ? oldYN.doubleValue() : Double.NaN;\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setValue(item.getValue());\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getValue() != null) {\n                double yy = item.getValue().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            item = (TimeSeriesDataItem) item.clone();\n            this.data.add(-index - 1, item);\n            updateBoundsForAddedItem(item);\n\n            \n            if (getItemCount() > this.maximumItemCount) {\n                TimeSeriesDataItem d = (TimeSeriesDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(d);\n            }\n        }\n        removeAgedItems(false);  \n                                 \n                                 \n        fireSeriesChanged();\n        return overwritten;\n\n    }\n\n    \n    public void removeAgedItems(boolean notify) {\n        \n        \n        if (getItemCount() > 1) {\n            long latest = getTimePeriod(getItemCount() - 1).getSerialIndex();\n            boolean removed = false;\n            while ((latest - getTimePeriod(0).getSerialIndex())\n                    > this.maximumItemAge) {\n                this.data.remove(0);\n                removed = true;\n            }\n            if (removed) {\n                findBoundsByIteration();\n                if (notify) {\n                    fireSeriesChanged();\n                }\n            }\n        }\n    }\n\n    \n    public void removeAgedItems(long latest, boolean notify) {\n        if (this.data.isEmpty()) {\n            return;  \n        }\n        \n        long index = Long.MAX_VALUE;\n        try {\n            Method m = RegularTimePeriod.class.getDeclaredMethod(\n                    \"createInstance\", new Class[] {Class.class, Date.class,\n                    TimeZone.class});\n            RegularTimePeriod newest = (RegularTimePeriod) m.invoke(\n                    this.timePeriodClass, new Object[] {this.timePeriodClass,\n                            new Date(latest), TimeZone.getDefault()});\n            index = newest.getSerialIndex();\n        }\n        catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        }\n        catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n        catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n\n        \n        \n        boolean removed = false;\n        while (getItemCount() > 0 && (index\n                - getTimePeriod(0).getSerialIndex()) > this.maximumItemAge) {\n            this.data.remove(0);\n            removed = true;\n        }\n        if (removed) {\n            findBoundsByIteration();\n            if (notify) {\n                fireSeriesChanged();\n            }\n        }\n    }\n\n    \n    public void clear() {\n        if (this.data.size() > 0) {\n            this.data.clear();\n            this.timePeriodClass = null;\n            this.minY = Double.NaN;\n            this.maxY = Double.NaN;\n            fireSeriesChanged();\n        }\n    }\n\n    \n    public void delete(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.remove(\n                    index);\n            updateBoundsForRemovedItem(item);\n            if (this.data.isEmpty()) {\n                this.timePeriodClass = null;\n            }\n            fireSeriesChanged();\n        }\n    }\n\n    \n    public void delete(int start, int end) {\n        delete(start, end, true);\n    }\n\n    \n    public void delete(int start, int end, boolean notify) {\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        for (int i = 0; i <= (end - start); i++) {\n            this.data.remove(start);\n        }\n        findBoundsByIteration();\n        if (this.data.isEmpty()) {\n            this.timePeriodClass = null;\n        }\n        if (notify) {\n            fireSeriesChanged();\n        }\n    }\n\n    \n    public Object clone() throws CloneNotSupportedException {\n        TimeSeries clone = (TimeSeries) super.clone();\n        clone.data = (List) ObjectUtilities.deepClone(this.data);\n        return clone;\n    }\n\n    \n    public TimeSeries createCopy(int start, int end)\n            throws CloneNotSupportedException {\n        if (start < 0) {\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\n        }\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        TimeSeries copy = (TimeSeries) super.clone();\n        copy.minY = Double.NaN;\n        copy.maxY = Double.NaN;\n        copy.data = new java.util.ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                TimeSeriesDataItem item\n                        = (TimeSeriesDataItem) this.data.get(index);\n                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return copy;\n    }\n\n    \n    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  \n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             \n            endIndex = -(endIndex + 1); \n            endIndex = endIndex - 1;    \n        }\n        if ((endIndex < 0)  || (endIndex < startIndex)) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n\n    }\n\n    \n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof TimeSeries)) {\n            return false;\n        }\n        TimeSeries that = (TimeSeries) obj;\n        if (!ObjectUtilities.equal(getDomainDescription(),\n                that.getDomainDescription())) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(getRangeDescription(),\n                that.getRangeDescription())) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.timePeriodClass,\n                that.timePeriodClass)) {\n            return false;\n        }\n        if (getMaximumItemAge() != that.getMaximumItemAge()) {\n            return false;\n        }\n        if (getMaximumItemCount() != that.getMaximumItemCount()) {\n            return false;\n        }\n        int count = getItemCount();\n        if (count != that.getItemCount()) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.data, that.data)) {\n            return false;\n        }\n        return super.equals(obj);\n    }\n\n    \n    public int hashCode() {\n        int result = super.hashCode();\n        result = 29 * result + (this.domain != null ? this.domain.hashCode()\n                : 0);\n        result = 29 * result + (this.range != null ? this.range.hashCode() : 0);\n        result = 29 * result + (this.timePeriodClass != null\n                ? this.timePeriodClass.hashCode() : 0);\n        \n        \n        int count = getItemCount();\n        if (count > 0) {\n            TimeSeriesDataItem item = getRawDataItem(0);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 1) {\n            TimeSeriesDataItem item = getRawDataItem(count - 1);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 2) {\n            TimeSeriesDataItem item = getRawDataItem(count / 2);\n            result = 29 * result + item.hashCode();\n        }\n        result = 29 * result + this.maximumItemCount;\n        result = 29 * result + (int) this.maximumItemAge;\n        return result;\n    }\n\n    \n    private void updateBoundsForAddedItem(TimeSeriesDataItem item) {\n        Number yN = item.getValue();\n        if (item.getValue() != null) {\n            double y = yN.doubleValue();\n            this.minY = minIgnoreNaN(this.minY, y);\n            this.maxY = maxIgnoreNaN(this.maxY, y);\n        }\n    }\n\n    \n    private void updateBoundsForRemovedItem(TimeSeriesDataItem item) {\n        Number yN = item.getValue();\n        if (yN != null) {\n            double y = yN.doubleValue();\n            if (!Double.isNaN(y)) {\n                if (y <= this.minY || y >= this.maxY) {\n                    findBoundsByIteration();\n                }\n            }\n        }\n    }\n\n    \n    private void findBoundsByIteration() {\n        this.minY = Double.NaN;\n        this.maxY = Double.NaN;\n        Iterator iterator = this.data.iterator();\n        while (iterator.hasNext()) {\n            TimeSeriesDataItem item = (TimeSeriesDataItem) iterator.next();\n            updateBoundsForAddedItem(item);\n        }\n    }\n\n    \n    private double minIgnoreNaN(double a, double b) {\n        if (Double.isNaN(a)) {\n            return b;\n        }\n        else {\n            if (Double.isNaN(b)) {\n                return a;\n            }\n            else {\n                return Math.min(a, b);\n            }\n        }\n    }\n\n    \n    private double maxIgnoreNaN(double a, double b) {\n        if (Double.isNaN(a)) {\n            return b;\n        }\n        else {\n            if (Double.isNaN(b)) {\n                return a;\n            }\n            else {\n                return Math.max(a, b);\n            }\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public TimeSeries(Comparable name)",
        "public TimeSeries(Comparable name, String domain, String range)",
        "public String getDomainDescription()",
        "public void setDomainDescription(String description)",
        "public String getRangeDescription()",
        "public void setRangeDescription(String description)",
        "public int getItemCount()",
        "public List getItems()",
        "public int getMaximumItemCount()",
        "public void setMaximumItemCount(int maximum)",
        "public long getMaximumItemAge()",
        "public void setMaximumItemAge(long periods)",
        "public double getMinY()",
        "public double getMaxY()",
        "public Class getTimePeriodClass()",
        "public TimeSeriesDataItem getDataItem(int index)",
        "public TimeSeriesDataItem getDataItem(RegularTimePeriod period)",
        "public RegularTimePeriod getTimePeriod(int index)",
        "public RegularTimePeriod getNextTimePeriod()",
        "public Collection getTimePeriods()",
        "public Collection getTimePeriodsUniqueToOtherSeries(TimeSeries series)",
        "public int getIndex(RegularTimePeriod period)",
        "public Number getValue(int index)",
        "public Number getValue(RegularTimePeriod period)",
        "public void add(TimeSeriesDataItem item)",
        "public void add(TimeSeriesDataItem item, boolean notify)",
        "public void add(RegularTimePeriod period, double value)",
        "public void add(RegularTimePeriod period, double value, boolean notify)",
        "public void add(RegularTimePeriod period, Number value)",
        "public void add(RegularTimePeriod period, Number value, boolean notify)",
        "public void update(RegularTimePeriod period, Number value)",
        "public void update(int index, Number value)",
        "public TimeSeries addAndOrUpdate(TimeSeries series)",
        "public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period, double value)",
        "public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period, Number value)",
        "public TimeSeriesDataItem addOrUpdate(TimeSeriesDataItem item)",
        "public void removeAgedItems(boolean notify)",
        "public void removeAgedItems(long latest, boolean notify)",
        "public void clear()",
        "public void delete(RegularTimePeriod period)",
        "public void delete(int start, int end)",
        "public void delete(int start, int end, boolean notify)",
        "public Object clone() throws CloneNotSupportedException",
        "public TimeSeries createCopy(int start, int end)",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)",
        "public boolean equals(Object obj)",
        "public int hashCode()",
        "private void updateBoundsForAddedItem(TimeSeriesDataItem item)",
        "private void updateBoundsForRemovedItem(TimeSeriesDataItem item)",
        "private void findBoundsByIteration()",
        "private double minIgnoreNaN(double a, double b)",
        "private double maxIgnoreNaN(double a, double b)"
      ],
      "fixed_signatures": [
        "public TimeSeries(Comparable name)",
        "public TimeSeries(Comparable name, String domain, String range)",
        "public String getDomainDescription()",
        "public void setDomainDescription(String description)",
        "public String getRangeDescription()",
        "public void setRangeDescription(String description)",
        "public int getItemCount()",
        "public List getItems()",
        "public int getMaximumItemCount()",
        "public void setMaximumItemCount(int maximum)",
        "public long getMaximumItemAge()",
        "public void setMaximumItemAge(long periods)",
        "public double getMinY()",
        "public double getMaxY()",
        "public Class getTimePeriodClass()",
        "public TimeSeriesDataItem getDataItem(int index)",
        "public TimeSeriesDataItem getDataItem(RegularTimePeriod period)",
        "public RegularTimePeriod getTimePeriod(int index)",
        "public RegularTimePeriod getNextTimePeriod()",
        "public Collection getTimePeriods()",
        "public Collection getTimePeriodsUniqueToOtherSeries(TimeSeries series)",
        "public int getIndex(RegularTimePeriod period)",
        "public Number getValue(int index)",
        "public Number getValue(RegularTimePeriod period)",
        "public void add(TimeSeriesDataItem item)",
        "public void add(TimeSeriesDataItem item, boolean notify)",
        "public void add(RegularTimePeriod period, double value)",
        "public void add(RegularTimePeriod period, double value, boolean notify)",
        "public void add(RegularTimePeriod period, Number value)",
        "public void add(RegularTimePeriod period, Number value, boolean notify)",
        "public void update(RegularTimePeriod period, Number value)",
        "public void update(int index, Number value)",
        "public TimeSeries addAndOrUpdate(TimeSeries series)",
        "public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period, double value)",
        "public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period, Number value)",
        "public TimeSeriesDataItem addOrUpdate(TimeSeriesDataItem item)",
        "public void removeAgedItems(boolean notify)",
        "public void removeAgedItems(long latest, boolean notify)",
        "public void clear()",
        "public void delete(RegularTimePeriod period)",
        "public void delete(int start, int end)",
        "public void delete(int start, int end, boolean notify)",
        "public Object clone() throws CloneNotSupportedException",
        "public TimeSeries createCopy(int start, int end)",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)",
        "public boolean equals(Object obj)",
        "public int hashCode()",
        "private void updateBoundsForAddedItem(TimeSeriesDataItem item)",
        "private void updateBoundsForRemovedItem(TimeSeriesDataItem item)",
        "private void findBoundsByIteration()",
        "private double minIgnoreNaN(double a, double b)",
        "private double maxIgnoreNaN(double a, double b)"
      ],
      "methods": [
        {
          "buggy_method": "  public TimeSeries createCopy(int start, int end)\n  throws CloneNotSupportedException {\n  if (start < 0) {\n  throw new IllegalArgumentException(\"Requires start >= 0.\");\n  }\n  if (end < start) {\n  throw new IllegalArgumentException(\"Requires start <= end.\");\n  }\n  TimeSeries copy = (TimeSeries) super.clone();\n  copy.data = new java.util.ArrayList();\n  if (this.data.size() > 0) {\n  for (int index = start; index <= end; index++) {\n  TimeSeriesDataItem item\n  = (TimeSeriesDataItem) this.data.get(index);\n  TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n  try {\n  copy.add(clone);\n  }\n  catch (SeriesException e) {\n  e.printStackTrace();\n  }\n  }\n  }\n  return copy;\n  }",
          "fixed_method": "  public TimeSeries createCopy(int start, int end)\n  throws CloneNotSupportedException {\n  if (start < 0) {\n  throw new IllegalArgumentException(\"Requires start >= 0.\");\n  }\n  if (end < start) {\n  throw new IllegalArgumentException(\"Requires start <= end.\");\n  }\n  TimeSeries copy = (TimeSeries) super.clone();\n  copy.minY = Double.NaN;\n  copy.maxY = Double.NaN;\n  copy.data = new java.util.ArrayList();\n  if (this.data.size() > 0) {\n  for (int index = start; index <= end; index++) {\n  TimeSeriesDataItem item\n  = (TimeSeriesDataItem) this.data.get(index);\n  TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n  try {\n  copy.add(clone);\n  }\n  catch (SeriesException e) {\n  e.printStackTrace();\n  }\n  }\n  }\n  return copy;\n  }",
          "diff": [
            "@@ -1054,6 +1054,8 @@",
            "             throw new IllegalArgumentException(\"Requires start <= end.\");\n",
            "         }\n",
            "         TimeSeries copy = (TimeSeries) super.clone();\n",
            "+        copy.minY = Double.NaN;\n",
            "+        copy.maxY = Double.NaN;\n",
            "         copy.data = new java.util.ArrayList();\n",
            "         if (this.data.size() > 0) {\n",
            "             for (int index = start; index <= end; index++) {\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}