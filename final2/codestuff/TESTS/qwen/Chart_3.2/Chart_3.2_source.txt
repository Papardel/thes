### Failing Test
Test Source:
```java
public void testCreateCopy3() throws CloneNotSupportedException {
  TimeSeries s1 = new TimeSeries("S1");
  s1.add(new Year(2009), 100.0);
  s1.add(new Year(2010), 101.0);
  s1.add(new Year(2011), 102.0);
  assertEquals(100.0, s1.getMinY(), EPSILON);
  assertEquals(102.0, s1.getMaxY(), EPSILON);

  TimeSeries s2 = s1.createCopy(0, 1);
  assertEquals(100.0, s2.getMinY(), EPSILON);
  assertEquals(101.0, s2.getMaxY(), EPSILON);

  TimeSeries s3 = s1.createCopy(1, 2);
  assertEquals(101.0, s3.getMinY(), EPSILON);
  assertEquals(102.0, s3.getMaxY(), EPSILON);
  }
```
Stack Trace:
TimeSeriesTests.testCreateCopy3 line 607

### Candidate Method 1
```java
// â€¼ signature public TimeSeries createCopy(int start, int end) not found
```

### Candidate Method 2
```java
public long getMaximumItemAge() {
        return this.maximumItemAge;
    }
```

### Candidate Method 3
```java
public void add(TimeSeriesDataItem item, boolean notify) {
        if (item == null) {
            throw new IllegalArgumentException("Null 'item' argument.");
        }
        item = (TimeSeriesDataItem) item.clone();
        Class c = item.getPeriod().getClass();
        if (this.timePeriodClass == null) {
            this.timePeriodClass = c;
        }
        else if (!this.timePeriodClass.equals(c)) {
            StringBuffer b = new StringBuffer();
            b.append("You are trying to add data where the time period class ");
            b.append("is ");
            b.append(item.getPeriod().getClass().getName());
            b.append(", but the TimeSeries is expecting an instance of ");
            b.append(this.timePeriodClass.getName());
            b.append(".");
            throw new SeriesException(b.toString());
        }

        
        boolean added = false;
        int count = getItemCount();
        if (count == 0) {
            this.data.add(item);
            added = true;
        }
        else {
            RegularTimePeriod last = getTimePeriod(getItemCount() - 1);
            if (item.getPeriod().compareTo(last) > 0) {
                this.data.add(item);
                added = true;
            }
            else {
                int index = Collections.binarySearch(this.data, item);
                if (index < 0) {
                    this.data.add(-index - 1, item);
                    added = true;
                }
                else {
                    StringBuffer b = new StringBuffer();
                    b.append("You are attempting to add an observation for ");
                    b.append("the time period ");
                    b.append(item.getPeriod().toString());
                    b.append(" but the series already contains an observation");
                    b.append(" for that time period. Duplicates are not ");
                    b.append("permitted.  Try using the addOrUpdate() method.");
                    throw new SeriesException(b.toString());
                }
            }
        }
        if (added) {
            updateBoundsForAddedItem(item);
            
            if (getItemCount() > this.maximumItemCount) {
                TimeSeriesDataItem d = (TimeSeriesDataItem) this.data.remove(0);
                updateBoundsForRemovedItem(d);
            }

            removeAgedItems(false);  
                                     
                                     
            if (notify) {
                fireSeriesChanged();
            }
        }

    }
```

### Candidate Method 4
```java
public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period,
                                          double value) {
        return addOrUpdate(period, new Double(value));
    }
```

### Candidate Method 5
```java
public int getMaximumItemCount() {
        return this.maximumItemCount;
    }
```
Analyse the failing test(s) above along with these candidate methods, these methods contain the causes of the test failures.
Your task is to identify the most likely lines of code in these methods that could cause the failure of the test cases above.
Look at the test cases, their stack traces, and the error messages to determine which lines in these methods are most likely responsible for the failure.
Return the signature of the method and the lines of code that are most likely responsible for the failure.

IMPORTANT: You must reply _exactly_ in this form:
RESPONSE:
<signature-1>: line of code
 line of code
<signature-2>: line of code
 line of code
<signature-3>: line of code
 line of code
