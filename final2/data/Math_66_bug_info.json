{
  "bug_id": "66",
  "failed_tests": {
    "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest": [
      {
        "methodName": "testQuinticMin",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<-0.2719561270319131> but was:<-0.2719561299044896>",
        "fail_line": "        assertEquals(-0.2719561270319131, result, 1.0e-13);",
        "test_source": "  public void testQuinticMin() throws MathException {\n  // The quintic function has zeros at 0, +-0.5 and +-1.\n  // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n  UnivariateRealFunction f = new QuinticFunction();\n  UnivariateRealOptimizer underlying = new BrentOptimizer();\n  underlying.setRelativeAccuracy(1e-15);\n  JDKRandomGenerator g = new JDKRandomGenerator();\n  g.setSeed(4312000053L);\n  MultiStartUnivariateRealOptimizer minimizer =\n  new MultiStartUnivariateRealOptimizer(underlying, 5, g);\n  minimizer.setAbsoluteAccuracy(10 * minimizer.getAbsoluteAccuracy());\n  minimizer.setRelativeAccuracy(10 * minimizer.getRelativeAccuracy());\n\n  try {\n  minimizer.getOptima();\n  fail(\"an exception should have been thrown\");\n  } catch (IllegalStateException ise) {\n  // expected\n  } catch (Exception e) {\n  fail(\"wrong exception caught\");\n  }\n  try {\n  minimizer.getOptimaValues();\n  fail(\"an exception should have been thrown\");\n  } catch (IllegalStateException ise) {\n  // expected\n  } catch (Exception e) {\n  fail(\"wrong exception caught\");\n  }\n\n  double result = minimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2);\n  assertEquals(-0.2719561270319131, result, 1.0e-13);\n  assertEquals(-0.2719561270319131, minimizer.getResult(), 1.0e-13);\n  assertEquals(-0.04433426954946637, minimizer.getFunctionValue(), 1.0e-13);\n\n  double[] optima = minimizer.getOptima();\n  double[] optimaValues = minimizer.getOptimaValues();\n  for (int i = 0; i < optima.length; ++i) {\n  assertEquals(f.value(optima[i]), optimaValues[i], 1.0e-10);\n  }\n  assertTrue(minimizer.getEvaluations()  >= 120);\n  assertTrue(minimizer.getEvaluations()  <= 170);\n  assertTrue(minimizer.getIterationCount() >= 120);\n  assertTrue(minimizer.getIterationCount() <= 170);\n  }",
        "stack": [
          "MultiStartUnivariateRealOptimizerTest.testQuinticMin line 87"
        ]
      },
      {
        "methodName": "testSinMin",
        "error": "junit.framework.AssertionFailedError",
        "message": "",
        "fail_line": "        assertTrue(minimizer.getEvaluations() < 250);",
        "test_source": "  public void testSinMin() throws MathException {\n  UnivariateRealFunction f = new SinFunction();\n  UnivariateRealOptimizer underlying = new BrentOptimizer();\n  JDKRandomGenerator g = new JDKRandomGenerator();\n  g.setSeed(44428400075l);\n  MultiStartUnivariateRealOptimizer minimizer =\n  new MultiStartUnivariateRealOptimizer(underlying, 10, g);\n  minimizer.optimize(f, GoalType.MINIMIZE, -100.0, 100.0);\n  double[] optima = minimizer.getOptima();\n  double[] optimaValues = minimizer.getOptimaValues();\n  for (int i = 1; i < optima.length; ++i) {\n  double d = (optima[i] - optima[i-1]) / (2 * Math.PI);\n  assertTrue (Math.abs(d - Math.rint(d)) < 1.0e-8);\n  assertEquals(-1.0, f.value(optima[i]), 1.0e-10);\n  assertEquals(f.value(optima[i]), optimaValues[i], 1.0e-10);\n  }\n  assertTrue(minimizer.getEvaluations() > 150);\n  assertTrue(minimizer.getEvaluations() < 250);\n  }",
        "stack": [
          "MultiStartUnivariateRealOptimizerTest.testSinMin line 52"
        ]
      }
    ],
    "org.apache.commons.math.optimization.univariate.BrentOptimizerTest": [
      {
        "methodName": "testQuinticMinStatistics",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<1880.5> but was:<18.0>",
        "fail_line": "        assertEquals(medianEval, 18, Math.ulp(1d));",
        "test_source": "  public void testQuinticMinStatistics() throws MathException {\n  // The function has local minima at -0.27195613 and 0.82221643.\n  UnivariateRealFunction f = new QuinticFunction();\n  UnivariateRealOptimizer minimizer = new BrentOptimizer();\n  minimizer.setRelativeAccuracy(1e-10);\n  minimizer.setAbsoluteAccuracy(1e-11);\n\n  final DescriptiveStatistics[] stat = new DescriptiveStatistics[3];\n  for (int i = 0; i < stat.length; i++) {\n  stat[i] = new DescriptiveStatistics();\n  }\n\n  final double min = -0.75;\n  final double max = 0.25;\n  final int nSamples = 200;\n  final double delta = (max - min) / nSamples;\n  for (int i = 0; i < nSamples; i++) {\n  final double start = min + i * delta;\n  stat[0].addValue(minimizer.optimize(f, GoalType.MINIMIZE, min, max, start));\n  stat[1].addValue(minimizer.getIterationCount());\n  stat[2].addValue(minimizer.getEvaluations());\n  }\n\n  final double meanOptValue = stat[0].getMean();\n  final double medianIter = stat[1].getPercentile(50);\n  final double medianEval = stat[2].getPercentile(50);\n  assertTrue(meanOptValue > -0.27195612812 && meanOptValue < -0.27195612811);\n  assertEquals(medianIter, 17, Math.ulp(1d));\n  assertEquals(medianEval, 18, Math.ulp(1d));\n  }",
        "stack": [
          "BrentOptimizerTest.testQuinticMinStatistics line 114"
        ]
      },
      {
        "methodName": "testSinMin",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<4.71238898038469> but was:<4.71238897901431>",
        "fail_line": "        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 4, 5), 10 * minimizer.getRelativeAccuracy());",
        "test_source": "  public void testSinMin() throws MathException {\n  UnivariateRealFunction f = new SinFunction();\n  UnivariateRealOptimizer minimizer = new BrentOptimizer();\n  minimizer.setMaxEvaluations(200);\n  assertEquals(200, minimizer.getMaxEvaluations());\n  try {\n  minimizer.getResult();\n  fail(\"an exception should have been thrown\");\n  } catch (NoDataException ise) {\n  // expected\n  } catch (Exception e) {\n  fail(\"wrong exception caught\");\n  }\n  assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 4, 5), 10 * minimizer.getRelativeAccuracy());\n  assertTrue(minimizer.getIterationCount() <= 50);\n  assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 1, 5), 10 * minimizer.getRelativeAccuracy());\n  assertTrue(minimizer.getIterationCount() <= 50);\n  assertTrue(minimizer.getEvaluations()  <= 100);\n  assertTrue(minimizer.getEvaluations()  >=  15);\n  minimizer.setMaxEvaluations(10);\n  try {\n  minimizer.optimize(f, GoalType.MINIMIZE, 4, 5);\n  fail(\"an exception should have been thrown\");\n  } catch (FunctionEvaluationException fee) {\n  // expected\n  } catch (Exception e) {\n  fail(\"wrong exception caught\");\n  }\n  }",
        "stack": [
          "BrentOptimizerTest.testSinMin line 54"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
      "buggy_full_code": "\npackage org.apache.commons.math.optimization.univariate;\n\nimport org.apache.commons.math.FunctionEvaluationException;\nimport org.apache.commons.math.MaxIterationsExceededException;\nimport org.apache.commons.math.exception.NotStrictlyPositiveException;\nimport org.apache.commons.math.analysis.UnivariateRealFunction;\nimport org.apache.commons.math.optimization.GoalType;\n\n\npublic class BrentOptimizer extends AbstractUnivariateRealOptimizer { private static final double GOLDEN_SECTION = 0.5 * (3 - Math.sqrt(5)); public BrentOptimizer() {\n        setMaxEvaluations(Integer.MAX_VALUE);\n        setMaximalIterationCount(100);\n        setAbsoluteAccuracy(1E-10);\n        setRelativeAccuracy(1.0e-14);\n    }\n\n    \n    protected double doOptimize() throws MaxIterationsExceededException, FunctionEvaluationException {\n        throw new UnsupportedOperationException();\n    }\n    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n        clearResult();\n        return localMin(getGoalType() == GoalType.MINIMIZE,\n                        f, goalType, min, startValue, max,\n                        getRelativeAccuracy(), getAbsoluteAccuracy());\n    }\n    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n    }\n\n    \n    private double localMin(boolean isMinim, UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\n        if (eps <= 0) {\n            throw new NotStrictlyPositiveException(eps);\n        }\n        if (t <= 0) {\n            throw new NotStrictlyPositiveException(t);\n        }\n        double a, b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(f, x);\n        if (goalType == GoalType.MAXIMIZE) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        int count = 0;\n        while (count < maximalIterationCount) {\n            double m = 0.5 * (a + b);\n            final double tol1 = eps * Math.abs(x) + t;\n            final double tol2 = 2 * tol1;\n\n            \n            if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (Math.abs(e) > tol1) { \n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x)\n                        && p < q * (b - x)\n                        && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                        \n                        d = p / q;\n                        u = x + d;\n\n                        \n                        if (u - a < tol2\n                            || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        \n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    \n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                \n                if (Math.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                double fu = computeObjectiveValue(f, u);\n                if (goalType == GoalType.MAXIMIZE) {\n                    fu = -fu;\n                }\n\n                \n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw\n                        || w == x) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv\n                               || v == x\n                               || v == w) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { \n                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n                return x;\n            }\n            ++count;\n        }\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.math.optimization.univariate;\n\nimport org.apache.commons.math.FunctionEvaluationException;\nimport org.apache.commons.math.MaxIterationsExceededException;\nimport org.apache.commons.math.exception.NotStrictlyPositiveException;\nimport org.apache.commons.math.analysis.UnivariateRealFunction;\nimport org.apache.commons.math.optimization.GoalType;\n\n\npublic class BrentOptimizer extends AbstractUnivariateRealOptimizer { private static final double GOLDEN_SECTION = 0.5 * (3 - Math.sqrt(5)); public BrentOptimizer() {\n        setMaxEvaluations(1000);\n        setMaximalIterationCount(100);\n        setAbsoluteAccuracy(1e-11);\n        setRelativeAccuracy(1e-9);\n    }\n\n    \n    protected double doOptimize() throws MaxIterationsExceededException, FunctionEvaluationException {\n        return localMin(getGoalType() == GoalType.MINIMIZE,\n                        getMin(), getStartValue(), getMax(),\n                        getRelativeAccuracy(), getAbsoluteAccuracy());\n    }\n\n    \n    private double localMin(boolean isMinim, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\n        if (eps <= 0) {\n            throw new NotStrictlyPositiveException(eps);\n        }\n        if (t <= 0) {\n            throw new NotStrictlyPositiveException(t);\n        }\n        double a, b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        while (true) {\n            double m = 0.5 * (a + b);\n            final double tol1 = eps * Math.abs(x) + t;\n            final double tol2 = 2 * tol1;\n\n            \n            if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (Math.abs(e) > tol1) { \n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x)\n                        && p < q * (b - x)\n                        && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                        \n                        d = p / q;\n                        u = x + d;\n\n                        \n                        if (u - a < tol2\n                            || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        \n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    \n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                \n                if (Math.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                double fu = computeObjectiveValue(u);\n                if (!isMinim) {\n                    fu = -fu;\n                }\n\n                \n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw\n                        || w == x) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv\n                               || v == x\n                               || v == w) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { \n                setFunctionValue(isMinim ? fx : -fx);\n                return x;\n            }\n            incrementIterationsCounter();\n        }\n    }\n}\n",
      "buggy_signatures": [
        "protected double doOptimize() throws MaxIterationsExceededException, FunctionEvaluationException",
        "public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException",
        "public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException",
        "private double localMin(boolean isMinim, UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException"
      ],
      "fixed_signatures": [
        "protected double doOptimize() throws MaxIterationsExceededException, FunctionEvaluationException",
        "private double localMin(boolean isMinim, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException"
      ],
      "methods": [
        {
          "buggy_method": "  public BrentOptimizer() {\n  setMaxEvaluations(Integer.MAX_VALUE);\n  setMaximalIterationCount(100);\n  setAbsoluteAccuracy(1E-10);\n  setRelativeAccuracy(1.0e-14);\n  }",
          "fixed_method": "  public BrentOptimizer() {\n  setMaxEvaluations(1000);\n  setMaximalIterationCount(100);\n  setAbsoluteAccuracy(1e-11);\n  setRelativeAccuracy(1e-9);\n  }",
          "diff": [
            "@@ -41,10 +41,10 @@",
            "      * Construct a solver.\n",
            "      */\n",
            "     public BrentOptimizer() {\n",
            "-        setMaxEvaluations(Integer.MAX_VALUE);\n",
            "+        setMaxEvaluations(1000);\n",
            "         setMaximalIterationCount(100);\n",
            "-        setAbsoluteAccuracy(1E-10);\n",
            "-        setRelativeAccuracy(1.0e-14);\n",
            "+        setAbsoluteAccuracy(1e-11);\n",
            "+        setRelativeAccuracy(1e-9);\n",
            "     }\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 6
        },
        {
          "buggy_method": "  public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n  clearResult();\n  return localMin(getGoalType() == GoalType.MINIMIZE,\n  f, goalType, min, startValue, max,\n  getRelativeAccuracy(), getAbsoluteAccuracy());\n  }",
          "fixed_method": "  protected double doOptimize() throws MaxIterationsExceededException, FunctionEvaluationException {\n  return localMin(getGoalType() == GoalType.MINIMIZE,\n  getMin(), getStartValue(), getMax(),\n  getRelativeAccuracy(), getAbsoluteAccuracy());\n  }",
          "diff": [
            "@@ -54,16 +54,9 @@",
            "      */\n",
            "     protected double doOptimize()\n",
            "         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
            "-        throw new UnsupportedOperationException();\n",
            "-    }\n",
            "-    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n",
            "-        clearResult();\n",
            "         return localMin(getGoalType() == GoalType.MINIMIZE,\n",
            "-                        f, goalType, min, startValue, max,\n",
            "+                        getMin(), getStartValue(), getMax(),\n",
            "                         getRelativeAccuracy(), getAbsoluteAccuracy());\n",
            "-    }\n",
            "-    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n",
            "-        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n",
            "     }\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 9
        },
        {
          "buggy_method": "  private double localMin(boolean isMinim, UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\n  if (eps <= 0) {\n  throw new NotStrictlyPositiveException(eps);\n  }\n  if (t <= 0) {\n  throw new NotStrictlyPositiveException(t);\n  }\n  double a, b;\n  if (lo < hi) {\n  a = lo;\n  b = hi;\n  } else {\n  a = hi;\n  b = lo;\n  }\n\n  double x = mid;\n  double v = x;\n  double w = x;\n  double d = 0;\n  double e = 0;\n  double fx = computeObjectiveValue(f, x);\n  if (goalType == GoalType.MAXIMIZE) {\n  fx = -fx;\n  }\n  double fv = fx;\n  double fw = fx;\n\n  int count = 0;\n  while (count < maximalIterationCount) {\n  double m = 0.5 * (a + b);\n  final double tol1 = eps * Math.abs(x) + t;\n  final double tol2 = 2 * tol1;\n\n  \n  if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n  double p = 0;\n  double q = 0;\n  double r = 0;\n  double u = 0;\n\n  if (Math.abs(e) > tol1) { \n  r = (x - w) * (fx - fv);\n  q = (x - v) * (fx - fw);\n  p = (x - v) * q - (x - w) * r;\n  q = 2 * (q - r);\n\n  if (q > 0) {\n  p = -p;\n  } else {\n  q = -q;\n  }\n\n  r = e;\n  e = d;\n\n  if (p > q * (a - x)\n  && p < q * (b - x)\n  && Math.abs(p) < Math.abs(0.5 * q * r)) {\n  \n  d = p / q;\n  u = x + d;\n\n  \n  if (u - a < tol2\n  || b - u < tol2) {\n  if (x <= m) {\n  d = tol1;\n  } else {\n  d = -tol1;\n  }\n  }\n  } else {\n  \n  if (x < m) {\n  e = b - x;\n  } else {\n  e = a - x;\n  }\n  d = GOLDEN_SECTION * e;\n  }\n  } else {\n  \n  if (x < m) {\n  e = b - x;\n  } else {\n  e = a - x;\n  }\n  d = GOLDEN_SECTION * e;\n  }\n\n  \n  if (Math.abs(d) < tol1) {\n  if (d >= 0) {\n  u = x + tol1;\n  } else {\n  u = x - tol1;\n  }\n  } else {\n  u = x + d;\n  }\n\n  double fu = computeObjectiveValue(f, u);\n  if (goalType == GoalType.MAXIMIZE) {\n  fu = -fu;\n  }\n\n  \n  if (fu <= fx) {\n  if (u < x) {\n  b = x;\n  } else {\n  a = x;\n  }\n  v = w;\n  fv = fw;\n  w = x;\n  fw = fx;\n  x = u;\n  fx = fu;\n  } else {\n  if (u < x) {\n  a = u;\n  } else {\n  b = u;\n  }\n  if (fu <= fw\n  || w == x) {\n  v = w;\n  fv = fw;\n  w = u;\n  fw = fu;\n  } else if (fu <= fv\n  || v == x\n  || v == w) {\n  v = u;\n  fv = fu;\n  }\n  }\n  } else { \n  setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n  return x;\n  }\n  ++count;\n  }\n  throw new MaxIterationsExceededException(maximalIterationCount);\n  }",
          "fixed_method": "  private double localMin(boolean isMinim, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\n  if (eps <= 0) {\n  throw new NotStrictlyPositiveException(eps);\n  }\n  if (t <= 0) {\n  throw new NotStrictlyPositiveException(t);\n  }\n  double a, b;\n  if (lo < hi) {\n  a = lo;\n  b = hi;\n  } else {\n  a = hi;\n  b = lo;\n  }\n\n  double x = mid;\n  double v = x;\n  double w = x;\n  double d = 0;\n  double e = 0;\n  double fx = computeObjectiveValue(x);\n  if (!isMinim) {\n  fx = -fx;\n  }\n  double fv = fx;\n  double fw = fx;\n\n  while (true) {\n  double m = 0.5 * (a + b);\n  final double tol1 = eps * Math.abs(x) + t;\n  final double tol2 = 2 * tol1;\n\n  \n  if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n  double p = 0;\n  double q = 0;\n  double r = 0;\n  double u = 0;\n\n  if (Math.abs(e) > tol1) { \n  r = (x - w) * (fx - fv);\n  q = (x - v) * (fx - fw);\n  p = (x - v) * q - (x - w) * r;\n  q = 2 * (q - r);\n\n  if (q > 0) {\n  p = -p;\n  } else {\n  q = -q;\n  }\n\n  r = e;\n  e = d;\n\n  if (p > q * (a - x)\n  && p < q * (b - x)\n  && Math.abs(p) < Math.abs(0.5 * q * r)) {\n  \n  d = p / q;\n  u = x + d;\n\n  \n  if (u - a < tol2\n  || b - u < tol2) {\n  if (x <= m) {\n  d = tol1;\n  } else {\n  d = -tol1;\n  }\n  }\n  } else {\n  \n  if (x < m) {\n  e = b - x;\n  } else {\n  e = a - x;\n  }\n  d = GOLDEN_SECTION * e;\n  }\n  } else {\n  \n  if (x < m) {\n  e = b - x;\n  } else {\n  e = a - x;\n  }\n  d = GOLDEN_SECTION * e;\n  }\n\n  \n  if (Math.abs(d) < tol1) {\n  if (d >= 0) {\n  u = x + tol1;\n  } else {\n  u = x - tol1;\n  }\n  } else {\n  u = x + d;\n  }\n\n  double fu = computeObjectiveValue(u);\n  if (!isMinim) {\n  fu = -fu;\n  }\n\n  \n  if (fu <= fx) {\n  if (u < x) {\n  b = x;\n  } else {\n  a = x;\n  }\n  v = w;\n  fv = fw;\n  w = x;\n  fw = fx;\n  x = u;\n  fx = fu;\n  } else {\n  if (u < x) {\n  a = u;\n  } else {\n  b = u;\n  }\n  if (fu <= fw\n  || w == x) {\n  v = w;\n  fv = fw;\n  w = u;\n  fw = fu;\n  } else if (fu <= fv\n  || v == x\n  || v == w) {\n  v = u;\n  fv = fu;\n  }\n  }\n  } else { \n  setFunctionValue(isMinim ? fx : -fx);\n  return x;\n  }\n  incrementIterationsCounter();\n  }\n  }",
          "diff": [
            "@@ -91,8 +84,6 @@",
            "      * the function.\n",
            "      */\n",
            "     private double localMin(boolean isMinim,\n",
            "-                            UnivariateRealFunction f,\n",
            "-                            GoalType goalType,\n",
            "                             double lo, double mid, double hi,\n",
            "                             double eps, double t)\n",
            "         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
            "@@ -116,15 +107,14 @@",
            "         double w = x;\n",
            "         double d = 0;\n",
            "         double e = 0;\n",
            "-        double fx = computeObjectiveValue(f, x);\n",
            "-        if (goalType == GoalType.MAXIMIZE) {\n",
            "+        double fx = computeObjectiveValue(x);\n",
            "+        if (!isMinim) {\n",
            "             fx = -fx;\n",
            "         }\n",
            "         double fv = fx;\n",
            "         double fw = fx;\n",
            " \n",
            "-        int count = 0;\n",
            "-        while (count < maximalIterationCount) {\n",
            "+        while (true) {\n",
            "             double m = 0.5 * (a + b);\n",
            "             final double tol1 = eps * Math.abs(x) + t;\n",
            "             final double tol2 = 2 * tol1;\n",
            "@@ -197,8 +187,8 @@",
            "                     u = x + d;\n",
            "                 }\n",
            " \n",
            "-                double fu = computeObjectiveValue(f, u);\n",
            "-                if (goalType == GoalType.MAXIMIZE) {\n",
            "+                double fu = computeObjectiveValue(u);\n",
            "+                if (!isMinim) {\n",
            "                     fu = -fu;\n",
            "                 }\n",
            " \n",
            "@@ -235,11 +225,10 @@",
            "                     }\n",
            "                 }\n",
            "             } else { // termination\n",
            "-                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n",
            "+                setFunctionValue(isMinim ? fx : -fx);\n",
            "                 return x;\n",
            "             }\n",
            "-            ++count;\n",
            "-        }\n",
            "-        throw new MaxIterationsExceededException(maximalIterationCount);\n",
            "+            incrementIterationsCounter();\n",
            "+        }\n",
            "     }\n",
            " }\n"
          ],
          "changed_lines": 20
        }
      ]
    }
  ]
}
