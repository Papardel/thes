{
  "bug_id": "22",
  "failed_tests": {
    "org.apache.commons.math3.distribution.FDistributionTest": [
      {
        "methodName": "testIsSupportLowerBoundInclusive",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<false> but was:<true>",
        "fail_line": "",
        "test_source": "",
        "stack": [
          "RealDistributionAbstractTest.testIsSupportLowerBoundInclusive line 351"
        ]
      }
    ],
    "org.apache.commons.math3.distribution.UniformRealDistributionTest": [
      {
        "methodName": "testIsSupportUpperBoundInclusive",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<true> but was:<false>",
        "fail_line": "",
        "test_source": "",
        "stack": [
          "RealDistributionAbstractTest.testIsSupportUpperBoundInclusive line 367"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math3/distribution/FDistribution.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math3.distribution;\n\nimport org.apache.commons.math3.exception.NotStrictlyPositiveException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.special.Beta;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.random.RandomGenerator;\nimport org.apache.commons.math3.random.Well19937c;\n\n\npublic class FDistribution extends AbstractRealDistribution { public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9; private static final long serialVersionUID = -8516354193418641566L; private final double numeratorDegreesOfFreedom; private final double denominatorDegreesOfFreedom; private final double solverAbsoluteAccuracy; private double numericalVariance = Double.NaN; private boolean numericalVarianceIsCalculated = false; public FDistribution(double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom) throws NotStrictlyPositiveException {\n        this(numeratorDegreesOfFreedom, denominatorDegreesOfFreedom,\n             DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n    }\n\n    \n    public FDistribution(double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom, double inverseCumAccuracy) throws NotStrictlyPositiveException {\n        this(new Well19937c(), numeratorDegreesOfFreedom,\n             denominatorDegreesOfFreedom, inverseCumAccuracy);\n    }\n\n    \n    public FDistribution(RandomGenerator rng, double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom, double inverseCumAccuracy) throws NotStrictlyPositiveException {\n        super(rng);\n\n        if (numeratorDegreesOfFreedom <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,\n                                                   numeratorDegreesOfFreedom);\n        }\n        if (denominatorDegreesOfFreedom <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,\n                                                   denominatorDegreesOfFreedom);\n        }\n        this.numeratorDegreesOfFreedom = numeratorDegreesOfFreedom;\n        this.denominatorDegreesOfFreedom = denominatorDegreesOfFreedom;\n        solverAbsoluteAccuracy = inverseCumAccuracy;\n    }\n\n    \n    public double density(double x) {\n        final double nhalf = numeratorDegreesOfFreedom / 2;\n        final double mhalf = denominatorDegreesOfFreedom / 2;\n        final double logx = FastMath.log(x);\n        final double logn = FastMath.log(numeratorDegreesOfFreedom);\n        final double logm = FastMath.log(denominatorDegreesOfFreedom);\n        final double lognxm = FastMath.log(numeratorDegreesOfFreedom * x +\n                                           denominatorDegreesOfFreedom);\n        return FastMath.exp(nhalf * logn + nhalf * logx - logx +\n                            mhalf * logm - nhalf * lognxm - mhalf * lognxm -\n                            Beta.logBeta(nhalf, mhalf));\n    }\n\n    \n    public double cumulativeProbability(double x) {\n        double ret;\n        if (x <= 0) {\n            ret = 0;\n        } else {\n            double n = numeratorDegreesOfFreedom;\n            double m = denominatorDegreesOfFreedom;\n\n            ret = Beta.regularizedBeta((n * x) / (m + n * x),\n                0.5 * n,\n                0.5 * m);\n        }\n        return ret;\n    }\n\n    \n    public double getNumeratorDegreesOfFreedom() {\n        return numeratorDegreesOfFreedom;\n    }\n\n    \n    public double getDenominatorDegreesOfFreedom() {\n        return denominatorDegreesOfFreedom;\n    }\n\n    \n    @Override\n    protected double getSolverAbsoluteAccuracy() {\n        return solverAbsoluteAccuracy;\n    }\n\n    \n    public double getNumericalMean() {\n        final double denominatorDF = getDenominatorDegreesOfFreedom();\n\n        if (denominatorDF > 2) {\n            return denominatorDF / (denominatorDF - 2);\n        }\n\n        return Double.NaN;\n    }\n\n    \n    public double getNumericalVariance() {\n        if (!numericalVarianceIsCalculated) {\n            numericalVariance = calculateNumericalVariance();\n            numericalVarianceIsCalculated = true;\n        }\n        return numericalVariance;\n    }\n\n    \n    protected double calculateNumericalVariance() {\n        final double denominatorDF = getDenominatorDegreesOfFreedom();\n\n        if (denominatorDF > 4) {\n            final double numeratorDF = getNumeratorDegreesOfFreedom();\n            final double denomDFMinusTwo = denominatorDF - 2;\n\n            return ( 2 * (denominatorDF * denominatorDF) * (numeratorDF + denominatorDF - 2) ) /\n                   ( (numeratorDF * (denomDFMinusTwo * denomDFMinusTwo) * (denominatorDF - 4)) );\n        }\n\n        return Double.NaN;\n    }\n\n    \n    public double getSupportLowerBound() {\n        return 0;\n    }\n\n    \n    public double getSupportUpperBound() {\n        return Double.POSITIVE_INFINITY;\n    }\n\n    \n    public boolean isSupportLowerBoundInclusive() {\n        return true;\n    }\n\n    \n    public boolean isSupportUpperBoundInclusive() {\n        return false;\n    }\n\n    \n    public boolean isSupportConnected() {\n        return true;\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math3.distribution;\n\nimport org.apache.commons.math3.exception.NotStrictlyPositiveException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.special.Beta;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.random.RandomGenerator;\nimport org.apache.commons.math3.random.Well19937c;\n\n\npublic class FDistribution extends AbstractRealDistribution { public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9; private static final long serialVersionUID = -8516354193418641566L; private final double numeratorDegreesOfFreedom; private final double denominatorDegreesOfFreedom; private final double solverAbsoluteAccuracy; private double numericalVariance = Double.NaN; private boolean numericalVarianceIsCalculated = false; public FDistribution(double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom) throws NotStrictlyPositiveException {\n        this(numeratorDegreesOfFreedom, denominatorDegreesOfFreedom,\n             DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n    }\n\n    \n    public FDistribution(double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom, double inverseCumAccuracy) throws NotStrictlyPositiveException {\n        this(new Well19937c(), numeratorDegreesOfFreedom,\n             denominatorDegreesOfFreedom, inverseCumAccuracy);\n    }\n\n    \n    public FDistribution(RandomGenerator rng, double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom, double inverseCumAccuracy) throws NotStrictlyPositiveException {\n        super(rng);\n\n        if (numeratorDegreesOfFreedom <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,\n                                                   numeratorDegreesOfFreedom);\n        }\n        if (denominatorDegreesOfFreedom <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,\n                                                   denominatorDegreesOfFreedom);\n        }\n        this.numeratorDegreesOfFreedom = numeratorDegreesOfFreedom;\n        this.denominatorDegreesOfFreedom = denominatorDegreesOfFreedom;\n        solverAbsoluteAccuracy = inverseCumAccuracy;\n    }\n\n    \n    public double density(double x) {\n        final double nhalf = numeratorDegreesOfFreedom / 2;\n        final double mhalf = denominatorDegreesOfFreedom / 2;\n        final double logx = FastMath.log(x);\n        final double logn = FastMath.log(numeratorDegreesOfFreedom);\n        final double logm = FastMath.log(denominatorDegreesOfFreedom);\n        final double lognxm = FastMath.log(numeratorDegreesOfFreedom * x +\n                                           denominatorDegreesOfFreedom);\n        return FastMath.exp(nhalf * logn + nhalf * logx - logx +\n                            mhalf * logm - nhalf * lognxm - mhalf * lognxm -\n                            Beta.logBeta(nhalf, mhalf));\n    }\n\n    \n    public double cumulativeProbability(double x) {\n        double ret;\n        if (x <= 0) {\n            ret = 0;\n        } else {\n            double n = numeratorDegreesOfFreedom;\n            double m = denominatorDegreesOfFreedom;\n\n            ret = Beta.regularizedBeta((n * x) / (m + n * x),\n                0.5 * n,\n                0.5 * m);\n        }\n        return ret;\n    }\n\n    \n    public double getNumeratorDegreesOfFreedom() {\n        return numeratorDegreesOfFreedom;\n    }\n\n    \n    public double getDenominatorDegreesOfFreedom() {\n        return denominatorDegreesOfFreedom;\n    }\n\n    \n    @Override\n    protected double getSolverAbsoluteAccuracy() {\n        return solverAbsoluteAccuracy;\n    }\n\n    \n    public double getNumericalMean() {\n        final double denominatorDF = getDenominatorDegreesOfFreedom();\n\n        if (denominatorDF > 2) {\n            return denominatorDF / (denominatorDF - 2);\n        }\n\n        return Double.NaN;\n    }\n\n    \n    public double getNumericalVariance() {\n        if (!numericalVarianceIsCalculated) {\n            numericalVariance = calculateNumericalVariance();\n            numericalVarianceIsCalculated = true;\n        }\n        return numericalVariance;\n    }\n\n    \n    protected double calculateNumericalVariance() {\n        final double denominatorDF = getDenominatorDegreesOfFreedom();\n\n        if (denominatorDF > 4) {\n            final double numeratorDF = getNumeratorDegreesOfFreedom();\n            final double denomDFMinusTwo = denominatorDF - 2;\n\n            return ( 2 * (denominatorDF * denominatorDF) * (numeratorDF + denominatorDF - 2) ) /\n                   ( (numeratorDF * (denomDFMinusTwo * denomDFMinusTwo) * (denominatorDF - 4)) );\n        }\n\n        return Double.NaN;\n    }\n\n    \n    public double getSupportLowerBound() {\n        return 0;\n    }\n\n    \n    public double getSupportUpperBound() {\n        return Double.POSITIVE_INFINITY;\n    }\n\n    \n    public boolean isSupportLowerBoundInclusive() {\n        return false;\n    }\n\n    \n    public boolean isSupportUpperBoundInclusive() {\n        return false;\n    }\n\n    \n    public boolean isSupportConnected() {\n        return true;\n    }\n}\n",
      "buggy_signatures": [
        "public FDistribution(double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom, double inverseCumAccuracy) throws NotStrictlyPositiveException",
        "public FDistribution(RandomGenerator rng, double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom, double inverseCumAccuracy) throws NotStrictlyPositiveException",
        "public double density(double x)",
        "public double cumulativeProbability(double x)",
        "public double getNumeratorDegreesOfFreedom()",
        "public double getDenominatorDegreesOfFreedom()",
        "protected double getSolverAbsoluteAccuracy()",
        "public double getNumericalMean()",
        "public double getNumericalVariance()",
        "protected double calculateNumericalVariance()",
        "public double getSupportLowerBound()",
        "public double getSupportUpperBound()",
        "public boolean isSupportLowerBoundInclusive()",
        "public boolean isSupportUpperBoundInclusive()",
        "public boolean isSupportConnected()"
      ],
      "fixed_signatures": [
        "public FDistribution(double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom, double inverseCumAccuracy) throws NotStrictlyPositiveException",
        "public FDistribution(RandomGenerator rng, double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom, double inverseCumAccuracy) throws NotStrictlyPositiveException",
        "public double density(double x)",
        "public double cumulativeProbability(double x)",
        "public double getNumeratorDegreesOfFreedom()",
        "public double getDenominatorDegreesOfFreedom()",
        "protected double getSolverAbsoluteAccuracy()",
        "public double getNumericalMean()",
        "public double getNumericalVariance()",
        "protected double calculateNumericalVariance()",
        "public double getSupportLowerBound()",
        "public double getSupportUpperBound()",
        "public boolean isSupportLowerBoundInclusive()",
        "public boolean isSupportUpperBoundInclusive()",
        "public boolean isSupportConnected()"
      ],
      "methods": [
        {
          "buggy_method": "  public boolean isSupportLowerBoundInclusive() {\n  return true;\n  }",
          "fixed_method": "  public boolean isSupportLowerBoundInclusive() {\n  return false;\n  }",
          "diff": [
            "@@ -272,7 +272,7 @@",
            " \n",
            "     /** {@inheritDoc} */\n",
            "     public boolean isSupportLowerBoundInclusive() {\n",
            "-        return true;\n",
            "+        return false;\n",
            "     }\n",
            " \n",
            "     /** {@inheritDoc} */\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "org/apache/commons/math3/distribution/UniformRealDistribution.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math3.distribution;\n\nimport org.apache.commons.math3.exception.NumberIsTooLargeException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.random.RandomGenerator;\nimport org.apache.commons.math3.random.Well19937c;\n\n\npublic class UniformRealDistribution extends AbstractRealDistribution { public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9; private static final long serialVersionUID = 20120109L; private final double lower; private final double upper; private final double solverAbsoluteAccuracy; public UniformRealDistribution() {\n        this(0, 1);\n    }\n\n    \n    public UniformRealDistribution(double lower, double upper) throws NumberIsTooLargeException {\n        this(lower, upper, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n    }\n\n    \n    public UniformRealDistribution(double lower, double upper, double inverseCumAccuracy) throws NumberIsTooLargeException {\n        this(new  Well19937c(), lower, upper, inverseCumAccuracy);\n    }\n\n    \n    public UniformRealDistribution(RandomGenerator rng, double lower, double upper, double inverseCumAccuracy) throws NumberIsTooLargeException {\n        super(rng);\n        if (lower >= upper) {\n            throw new NumberIsTooLargeException(\n                            LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n                            lower, upper, false);\n        }\n\n        this.lower = lower;\n        this.upper = upper;\n        solverAbsoluteAccuracy = inverseCumAccuracy;\n    }\n\n    \n    public double density(double x) {\n        if (x < lower || x > upper) {\n            return 0.0;\n        }\n        return 1 / (upper - lower);\n    }\n\n    \n    public double cumulativeProbability(double x) {\n        if (x <= lower) {\n            return 0;\n        }\n        if (x >= upper) {\n            return 1;\n        }\n        return (x - lower) / (upper - lower);\n    }\n\n    \n    @Override\n    protected double getSolverAbsoluteAccuracy() {\n        return solverAbsoluteAccuracy;\n    }\n\n    \n    public double getNumericalMean() {\n        return 0.5 * (lower + upper);\n    }\n\n    \n    public double getNumericalVariance() {\n        double ul = upper - lower;\n        return ul * ul / 12;\n    }\n\n    \n    public double getSupportLowerBound() {\n        return lower;\n    }\n\n    \n    public double getSupportUpperBound() {\n        return upper;\n    }\n\n    \n    public boolean isSupportLowerBoundInclusive() {\n        return true;\n    }\n\n    \n    public boolean isSupportUpperBoundInclusive() {\n        return false;\n    }\n\n    \n    public boolean isSupportConnected() {\n        return true;\n    }\n\n    \n    @Override\n    public double sample() {\n        final double u = random.nextDouble();\n        return u * upper + (1 - u) * lower;\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math3.distribution;\n\nimport org.apache.commons.math3.exception.NumberIsTooLargeException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.random.RandomGenerator;\nimport org.apache.commons.math3.random.Well19937c;\n\n\npublic class UniformRealDistribution extends AbstractRealDistribution { public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9; private static final long serialVersionUID = 20120109L; private final double lower; private final double upper; private final double solverAbsoluteAccuracy; public UniformRealDistribution() {\n        this(0, 1);\n    }\n\n    \n    public UniformRealDistribution(double lower, double upper) throws NumberIsTooLargeException {\n        this(lower, upper, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n    }\n\n    \n    public UniformRealDistribution(double lower, double upper, double inverseCumAccuracy) throws NumberIsTooLargeException {\n        this(new  Well19937c(), lower, upper, inverseCumAccuracy);\n    }\n\n    \n    public UniformRealDistribution(RandomGenerator rng, double lower, double upper, double inverseCumAccuracy) throws NumberIsTooLargeException {\n        super(rng);\n        if (lower >= upper) {\n            throw new NumberIsTooLargeException(\n                            LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n                            lower, upper, false);\n        }\n\n        this.lower = lower;\n        this.upper = upper;\n        solverAbsoluteAccuracy = inverseCumAccuracy;\n    }\n\n    \n    public double density(double x) {\n        if (x < lower || x > upper) {\n            return 0.0;\n        }\n        return 1 / (upper - lower);\n    }\n\n    \n    public double cumulativeProbability(double x) {\n        if (x <= lower) {\n            return 0;\n        }\n        if (x >= upper) {\n            return 1;\n        }\n        return (x - lower) / (upper - lower);\n    }\n\n    \n    @Override\n    protected double getSolverAbsoluteAccuracy() {\n        return solverAbsoluteAccuracy;\n    }\n\n    \n    public double getNumericalMean() {\n        return 0.5 * (lower + upper);\n    }\n\n    \n    public double getNumericalVariance() {\n        double ul = upper - lower;\n        return ul * ul / 12;\n    }\n\n    \n    public double getSupportLowerBound() {\n        return lower;\n    }\n\n    \n    public double getSupportUpperBound() {\n        return upper;\n    }\n\n    \n    public boolean isSupportLowerBoundInclusive() {\n        return true;\n    }\n\n    \n    public boolean isSupportUpperBoundInclusive() {\n        return true;\n    }\n\n    \n    public boolean isSupportConnected() {\n        return true;\n    }\n\n    \n    @Override\n    public double sample() {\n        final double u = random.nextDouble();\n        return u * upper + (1 - u) * lower;\n    }\n}\n",
      "buggy_signatures": [
        "public UniformRealDistribution(double lower, double upper) throws NumberIsTooLargeException",
        "public UniformRealDistribution(double lower, double upper, double inverseCumAccuracy) throws NumberIsTooLargeException",
        "public UniformRealDistribution(RandomGenerator rng, double lower, double upper, double inverseCumAccuracy) throws NumberIsTooLargeException",
        "public double density(double x)",
        "public double cumulativeProbability(double x)",
        "protected double getSolverAbsoluteAccuracy()",
        "public double getNumericalMean()",
        "public double getNumericalVariance()",
        "public double getSupportLowerBound()",
        "public double getSupportUpperBound()",
        "public boolean isSupportLowerBoundInclusive()",
        "public boolean isSupportUpperBoundInclusive()",
        "public boolean isSupportConnected()",
        "public double sample()"
      ],
      "fixed_signatures": [
        "public UniformRealDistribution(double lower, double upper) throws NumberIsTooLargeException",
        "public UniformRealDistribution(double lower, double upper, double inverseCumAccuracy) throws NumberIsTooLargeException",
        "public UniformRealDistribution(RandomGenerator rng, double lower, double upper, double inverseCumAccuracy) throws NumberIsTooLargeException",
        "public double density(double x)",
        "public double cumulativeProbability(double x)",
        "protected double getSolverAbsoluteAccuracy()",
        "public double getNumericalMean()",
        "public double getNumericalVariance()",
        "public double getSupportLowerBound()",
        "public double getSupportUpperBound()",
        "public boolean isSupportLowerBoundInclusive()",
        "public boolean isSupportUpperBoundInclusive()",
        "public boolean isSupportConnected()",
        "public double sample()"
      ],
      "methods": [
        {
          "buggy_method": "  public boolean isSupportUpperBoundInclusive() {\n  return false;\n  }",
          "fixed_method": "  public boolean isSupportUpperBoundInclusive() {\n  return true;\n  }",
          "diff": [
            "@@ -181,7 +181,7 @@",
            " \n",
            "     /** {@inheritDoc} */\n",
            "     public boolean isSupportUpperBoundInclusive() {\n",
            "-        return false;\n",
            "+        return true;\n",
            "     }\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
