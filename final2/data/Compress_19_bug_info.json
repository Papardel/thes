{
  "bug_id": "19",
  "failed_tests": {
    "org.apache.commons.compress.archivers.zip.ZipFileTest": [
      {
        "methodName": "testExcessDataInZip64ExtraField",
        "error": "java.util.zip.ZipException",
        "message": "central directory zip64 extended information extra field's length doesn't match central directory data.  Expected length 16 but is 28",
        "fail_line": "        zf = new ZipFile(archive);",
        "test_source": "  public void testExcessDataInZip64ExtraField() throws Exception {\n  File archive = getFile(\"COMPRESS-228.zip\");\n  zf = new ZipFile(archive);\n  // actually, if we get here, the test already has passed\n\n  ZipArchiveEntry ze = zf.getEntry(\"src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\");\n  assertEquals(26101, ze.getSize());\n  }",
        "stack": [
          "Zip64ExtendedInformationExtraField.reparseCentralDirectoryData line 260, ZipFile.setSizesAndOffsetFromZip64Extra line 619, ZipFile.readCentralDirectoryEntry line 584, ZipFile.populateFromCentralDirectory line 499, ZipFile.<init> line 218, ZipFile.<init> line 193, ZipFile.<init> line 154, ZipFileTest.testExcessDataInZip64ExtraField line 234"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.zip;\n\nimport java.util.zip.ZipException;\n\nimport static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD; import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD; public class Zip64ExtendedInformationExtraField implements ZipExtraField { static final ZipShort HEADER_ID = new ZipShort(0x0001); private static final String LFH_MUST_HAVE_BOTH_SIZES_MSG = \"Zip64 extended information must contain\" + \" both size values in the local file header.\"; private static final byte[] EMPTY = new byte[0]; private ZipEightByteInteger size, compressedSize, relativeHeaderOffset; private ZipLong diskStart; private byte[] rawCentralDirectoryData; public Zip64ExtendedInformationExtraField() { }\n\n    \n    public Zip64ExtendedInformationExtraField(ZipEightByteInteger size, ZipEightByteInteger compressedSize) {\n        this(size, compressedSize, null, null);\n    }\n\n    \n    public Zip64ExtendedInformationExtraField(ZipEightByteInteger size, ZipEightByteInteger compressedSize, ZipEightByteInteger relativeHeaderOffset, ZipLong diskStart) {\n        this.size = size;\n        this.compressedSize = compressedSize;\n        this.relativeHeaderOffset = relativeHeaderOffset;\n        this.diskStart = diskStart;\n    }\n\n    \n    public ZipShort getHeaderId() {\n        return HEADER_ID;\n    }\n\n    \n    public ZipShort getLocalFileDataLength() {\n        return new ZipShort(size != null ? 2 * DWORD : 0);\n    }\n\n    \n    public ZipShort getCentralDirectoryLength() {\n        return new ZipShort((size != null ? DWORD : 0)\n                            + (compressedSize != null ? DWORD : 0)\n                            + (relativeHeaderOffset != null ? DWORD : 0)\n                            + (diskStart != null ? WORD : 0));\n    }\n\n    \n    public byte[] getLocalFileDataData() {\n        if (size != null || compressedSize != null) {\n            if (size == null || compressedSize == null) {\n                throw new IllegalArgumentException(LFH_MUST_HAVE_BOTH_SIZES_MSG);\n            }\n            byte[] data = new byte[2 * DWORD];\n            addSizes(data);\n            return data;\n        }\n        return EMPTY;\n    }\n\n    \n    public byte[] getCentralDirectoryData() {\n        byte[] data = new byte[getCentralDirectoryLength().getValue()];\n        int off = addSizes(data);\n        if (relativeHeaderOffset != null) {\n            System.arraycopy(relativeHeaderOffset.getBytes(), 0, data, off, DWORD);\n            off += DWORD;\n        }\n        if (diskStart != null) {\n            System.arraycopy(diskStart.getBytes(), 0, data, off, WORD);\n            off += WORD;\n        }\n        return data;\n    }\n\n    \n    public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException {\n        if (length == 0) {\n            \n            \n            \n            \n            return;\n        }\n        if (length < 2 * DWORD) {\n            throw new ZipException(LFH_MUST_HAVE_BOTH_SIZES_MSG);\n        }\n        size = new ZipEightByteInteger(buffer, offset);\n        offset += DWORD;\n        compressedSize = new ZipEightByteInteger(buffer, offset);\n        offset += DWORD;\n        int remaining = length - 2 * DWORD;\n        if (remaining >= DWORD) {\n            relativeHeaderOffset = new ZipEightByteInteger(buffer, offset);\n            offset += DWORD;\n            remaining -= DWORD;\n        }\n        if (remaining >= WORD) {\n            diskStart = new ZipLong(buffer, offset);\n            offset += WORD;\n            remaining -= WORD;\n        }\n    }\n\n    \n    public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException {\n        \n        rawCentralDirectoryData = new byte[length];\n        System.arraycopy(buffer, offset, rawCentralDirectoryData, 0, length);\n\n        \n        \n        \n        \n        \n        \n        if (length >= 3 * DWORD + WORD) {\n            parseFromLocalFileData(buffer, offset, length);\n        } else if (length == 3 * DWORD) {\n            size = new ZipEightByteInteger(buffer, offset);\n            offset += DWORD;\n            compressedSize = new ZipEightByteInteger(buffer, offset);\n            offset += DWORD;\n            relativeHeaderOffset = new ZipEightByteInteger(buffer, offset);\n        } else if (length % DWORD == WORD) {\n            diskStart = new ZipLong(buffer, offset + length - WORD);\n        }\n    }\n\n    \n    public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException {\n        if (rawCentralDirectoryData != null) {\n            int expectedLength = (hasUncompressedSize ? DWORD : 0)\n                + (hasCompressedSize ? DWORD : 0)\n                + (hasRelativeHeaderOffset ? DWORD : 0)\n                + (hasDiskStart ? WORD : 0);\n            if (rawCentralDirectoryData.length != expectedLength) {\n                throw new ZipException(\"central directory zip64 extended\"\n                                       + \" information extra field's length\"\n                                       + \" doesn't match central directory\"\n                                       + \" data.  Expected length \"\n                                       + expectedLength + \" but is \"\n                                       + rawCentralDirectoryData.length);\n            }\n            int offset = 0;\n            if (hasUncompressedSize) {\n                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasCompressedSize) {\n                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                         offset);\n                offset += DWORD;\n            }\n            if (hasRelativeHeaderOffset) {\n                relativeHeaderOffset =\n                    new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasDiskStart) {\n                diskStart = new ZipLong(rawCentralDirectoryData, offset);\n                offset += WORD;\n            }\n        }\n    }\n\n    \n    public ZipEightByteInteger getSize() {\n        return size;\n    }\n\n    \n    public void setSize(ZipEightByteInteger size) {\n        this.size = size;\n    }\n\n    \n    public ZipEightByteInteger getCompressedSize() {\n        return compressedSize;\n    }\n\n    \n    public void setCompressedSize(ZipEightByteInteger compressedSize) {\n        this.compressedSize = compressedSize;\n    }\n\n    \n    public ZipEightByteInteger getRelativeHeaderOffset() {\n        return relativeHeaderOffset;\n    }\n\n    \n    public void setRelativeHeaderOffset(ZipEightByteInteger rho) {\n        relativeHeaderOffset = rho;\n    }\n\n    \n    public ZipLong getDiskStartNumber() {\n        return diskStart;\n    }\n\n    \n    public void setDiskStartNumber(ZipLong ds) {\n        diskStart = ds;\n    }\n\n    private int addSizes(byte[] data) {\n        int off = 0;\n        if (size != null) {\n            System.arraycopy(size.getBytes(), 0, data, 0, DWORD);\n            off += DWORD;\n        }\n        if (compressedSize != null) {\n            System.arraycopy(compressedSize.getBytes(), 0, data, off, DWORD);\n            off += DWORD;\n        }\n        return off;\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.zip;\n\nimport java.util.zip.ZipException;\n\nimport static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD; import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD; public class Zip64ExtendedInformationExtraField implements ZipExtraField { static final ZipShort HEADER_ID = new ZipShort(0x0001); private static final String LFH_MUST_HAVE_BOTH_SIZES_MSG = \"Zip64 extended information must contain\" + \" both size values in the local file header.\"; private static final byte[] EMPTY = new byte[0]; private ZipEightByteInteger size, compressedSize, relativeHeaderOffset; private ZipLong diskStart; private byte[] rawCentralDirectoryData; public Zip64ExtendedInformationExtraField() { }\n\n    \n    public Zip64ExtendedInformationExtraField(ZipEightByteInteger size, ZipEightByteInteger compressedSize) {\n        this(size, compressedSize, null, null);\n    }\n\n    \n    public Zip64ExtendedInformationExtraField(ZipEightByteInteger size, ZipEightByteInteger compressedSize, ZipEightByteInteger relativeHeaderOffset, ZipLong diskStart) {\n        this.size = size;\n        this.compressedSize = compressedSize;\n        this.relativeHeaderOffset = relativeHeaderOffset;\n        this.diskStart = diskStart;\n    }\n\n    \n    public ZipShort getHeaderId() {\n        return HEADER_ID;\n    }\n\n    \n    public ZipShort getLocalFileDataLength() {\n        return new ZipShort(size != null ? 2 * DWORD : 0);\n    }\n\n    \n    public ZipShort getCentralDirectoryLength() {\n        return new ZipShort((size != null ? DWORD : 0)\n                            + (compressedSize != null ? DWORD : 0)\n                            + (relativeHeaderOffset != null ? DWORD : 0)\n                            + (diskStart != null ? WORD : 0));\n    }\n\n    \n    public byte[] getLocalFileDataData() {\n        if (size != null || compressedSize != null) {\n            if (size == null || compressedSize == null) {\n                throw new IllegalArgumentException(LFH_MUST_HAVE_BOTH_SIZES_MSG);\n            }\n            byte[] data = new byte[2 * DWORD];\n            addSizes(data);\n            return data;\n        }\n        return EMPTY;\n    }\n\n    \n    public byte[] getCentralDirectoryData() {\n        byte[] data = new byte[getCentralDirectoryLength().getValue()];\n        int off = addSizes(data);\n        if (relativeHeaderOffset != null) {\n            System.arraycopy(relativeHeaderOffset.getBytes(), 0, data, off, DWORD);\n            off += DWORD;\n        }\n        if (diskStart != null) {\n            System.arraycopy(diskStart.getBytes(), 0, data, off, WORD);\n            off += WORD;\n        }\n        return data;\n    }\n\n    \n    public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException {\n        if (length == 0) {\n            \n            \n            \n            \n            return;\n        }\n        if (length < 2 * DWORD) {\n            throw new ZipException(LFH_MUST_HAVE_BOTH_SIZES_MSG);\n        }\n        size = new ZipEightByteInteger(buffer, offset);\n        offset += DWORD;\n        compressedSize = new ZipEightByteInteger(buffer, offset);\n        offset += DWORD;\n        int remaining = length - 2 * DWORD;\n        if (remaining >= DWORD) {\n            relativeHeaderOffset = new ZipEightByteInteger(buffer, offset);\n            offset += DWORD;\n            remaining -= DWORD;\n        }\n        if (remaining >= WORD) {\n            diskStart = new ZipLong(buffer, offset);\n            offset += WORD;\n            remaining -= WORD;\n        }\n    }\n\n    \n    public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException {\n        \n        rawCentralDirectoryData = new byte[length];\n        System.arraycopy(buffer, offset, rawCentralDirectoryData, 0, length);\n\n        \n        \n        \n        \n        \n        \n        if (length >= 3 * DWORD + WORD) {\n            parseFromLocalFileData(buffer, offset, length);\n        } else if (length == 3 * DWORD) {\n            size = new ZipEightByteInteger(buffer, offset);\n            offset += DWORD;\n            compressedSize = new ZipEightByteInteger(buffer, offset);\n            offset += DWORD;\n            relativeHeaderOffset = new ZipEightByteInteger(buffer, offset);\n        } else if (length % DWORD == WORD) {\n            diskStart = new ZipLong(buffer, offset + length - WORD);\n        }\n    }\n\n    \n    public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException {\n        if (rawCentralDirectoryData != null) {\n            int expectedLength = (hasUncompressedSize ? DWORD : 0)\n                + (hasCompressedSize ? DWORD : 0)\n                + (hasRelativeHeaderOffset ? DWORD : 0)\n                + (hasDiskStart ? WORD : 0);\n            if (rawCentralDirectoryData.length < expectedLength) {\n                throw new ZipException(\"central directory zip64 extended\"\n                                       + \" information extra field's length\"\n                                       + \" doesn't match central directory\"\n                                       + \" data.  Expected length \"\n                                       + expectedLength + \" but is \"\n                                       + rawCentralDirectoryData.length);\n            }\n            int offset = 0;\n            if (hasUncompressedSize) {\n                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasCompressedSize) {\n                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                         offset);\n                offset += DWORD;\n            }\n            if (hasRelativeHeaderOffset) {\n                relativeHeaderOffset =\n                    new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasDiskStart) {\n                diskStart = new ZipLong(rawCentralDirectoryData, offset);\n                offset += WORD;\n            }\n        }\n    }\n\n    \n    public ZipEightByteInteger getSize() {\n        return size;\n    }\n\n    \n    public void setSize(ZipEightByteInteger size) {\n        this.size = size;\n    }\n\n    \n    public ZipEightByteInteger getCompressedSize() {\n        return compressedSize;\n    }\n\n    \n    public void setCompressedSize(ZipEightByteInteger compressedSize) {\n        this.compressedSize = compressedSize;\n    }\n\n    \n    public ZipEightByteInteger getRelativeHeaderOffset() {\n        return relativeHeaderOffset;\n    }\n\n    \n    public void setRelativeHeaderOffset(ZipEightByteInteger rho) {\n        relativeHeaderOffset = rho;\n    }\n\n    \n    public ZipLong getDiskStartNumber() {\n        return diskStart;\n    }\n\n    \n    public void setDiskStartNumber(ZipLong ds) {\n        diskStart = ds;\n    }\n\n    private int addSizes(byte[] data) {\n        int off = 0;\n        if (size != null) {\n            System.arraycopy(size.getBytes(), 0, data, 0, DWORD);\n            off += DWORD;\n        }\n        if (compressedSize != null) {\n            System.arraycopy(compressedSize.getBytes(), 0, data, off, DWORD);\n            off += DWORD;\n        }\n        return off;\n    }\n}\n",
      "buggy_signatures": [
        "public Zip64ExtendedInformationExtraField(ZipEightByteInteger size, ZipEightByteInteger compressedSize)",
        "public Zip64ExtendedInformationExtraField(ZipEightByteInteger size, ZipEightByteInteger compressedSize, ZipEightByteInteger relativeHeaderOffset, ZipLong diskStart)",
        "public ZipShort getHeaderId()",
        "public ZipShort getLocalFileDataLength()",
        "public ZipShort getCentralDirectoryLength()",
        "public byte[] getLocalFileDataData()",
        "public byte[] getCentralDirectoryData()",
        "public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException",
        "public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException",
        "public ZipEightByteInteger getSize()",
        "public void setSize(ZipEightByteInteger size)",
        "public ZipEightByteInteger getCompressedSize()",
        "public void setCompressedSize(ZipEightByteInteger compressedSize)",
        "public ZipEightByteInteger getRelativeHeaderOffset()",
        "public void setRelativeHeaderOffset(ZipEightByteInteger rho)",
        "public ZipLong getDiskStartNumber()",
        "public void setDiskStartNumber(ZipLong ds)",
        "private int addSizes(byte[] data)"
      ],
      "fixed_signatures": [
        "public Zip64ExtendedInformationExtraField(ZipEightByteInteger size, ZipEightByteInteger compressedSize)",
        "public Zip64ExtendedInformationExtraField(ZipEightByteInteger size, ZipEightByteInteger compressedSize, ZipEightByteInteger relativeHeaderOffset, ZipLong diskStart)",
        "public ZipShort getHeaderId()",
        "public ZipShort getLocalFileDataLength()",
        "public ZipShort getCentralDirectoryLength()",
        "public byte[] getLocalFileDataData()",
        "public byte[] getCentralDirectoryData()",
        "public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException",
        "public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException",
        "public ZipEightByteInteger getSize()",
        "public void setSize(ZipEightByteInteger size)",
        "public ZipEightByteInteger getCompressedSize()",
        "public void setCompressedSize(ZipEightByteInteger compressedSize)",
        "public ZipEightByteInteger getRelativeHeaderOffset()",
        "public void setRelativeHeaderOffset(ZipEightByteInteger rho)",
        "public ZipLong getDiskStartNumber()",
        "public void setDiskStartNumber(ZipLong ds)",
        "private int addSizes(byte[] data)"
      ],
      "methods": [
        {
          "buggy_method": "  public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException {\n  if (rawCentralDirectoryData != null) {\n  int expectedLength = (hasUncompressedSize ? DWORD : 0)\n  + (hasCompressedSize ? DWORD : 0)\n  + (hasRelativeHeaderOffset ? DWORD : 0)\n  + (hasDiskStart ? WORD : 0);\n  if (rawCentralDirectoryData.length != expectedLength) {\n  throw new ZipException(\"central directory zip64 extended\"\n  + \" information extra field's length\"\n  + \" doesn't match central directory\"\n  + \" data.  Expected length \"\n  + expectedLength + \" but is \"\n  + rawCentralDirectoryData.length);\n  }\n  int offset = 0;\n  if (hasUncompressedSize) {\n  size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n  offset += DWORD;\n  }\n  if (hasCompressedSize) {\n  compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n  offset);\n  offset += DWORD;\n  }\n  if (hasRelativeHeaderOffset) {\n  relativeHeaderOffset =\n  new ZipEightByteInteger(rawCentralDirectoryData, offset);\n  offset += DWORD;\n  }\n  if (hasDiskStart) {\n  diskStart = new ZipLong(rawCentralDirectoryData, offset);\n  offset += WORD;\n  }\n  }\n  }",
          "fixed_method": "  public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException {\n  if (rawCentralDirectoryData != null) {\n  int expectedLength = (hasUncompressedSize ? DWORD : 0)\n  + (hasCompressedSize ? DWORD : 0)\n  + (hasRelativeHeaderOffset ? DWORD : 0)\n  + (hasDiskStart ? WORD : 0);\n  if (rawCentralDirectoryData.length < expectedLength) {\n  throw new ZipException(\"central directory zip64 extended\"\n  + \" information extra field's length\"\n  + \" doesn't match central directory\"\n  + \" data.  Expected length \"\n  + expectedLength + \" but is \"\n  + rawCentralDirectoryData.length);\n  }\n  int offset = 0;\n  if (hasUncompressedSize) {\n  size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n  offset += DWORD;\n  }\n  if (hasCompressedSize) {\n  compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n  offset);\n  offset += DWORD;\n  }\n  if (hasRelativeHeaderOffset) {\n  relativeHeaderOffset =\n  new ZipEightByteInteger(rawCentralDirectoryData, offset);\n  offset += DWORD;\n  }\n  if (hasDiskStart) {\n  diskStart = new ZipLong(rawCentralDirectoryData, offset);\n  offset += WORD;\n  }\n  }\n  }",
          "diff": [
            "@@ -256,7 +256,7 @@",
            "                 + (hasCompressedSize ? DWORD : 0)\n",
            "                 + (hasRelativeHeaderOffset ? DWORD : 0)\n",
            "                 + (hasDiskStart ? WORD : 0);\n",
            "-            if (rawCentralDirectoryData.length != expectedLength) {\n",
            "+            if (rawCentralDirectoryData.length < expectedLength) {\n",
            "                 throw new ZipException(\"central directory zip64 extended\"\n",
            "                                        + \" information extra field's length\"\n",
            "                                        + \" doesn't match central directory\"\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
