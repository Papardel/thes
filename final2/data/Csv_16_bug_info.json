{
  "bug_id": "16",
  "failed_tests": {
    "org.apache.commons.csv.CSVParserTest": [
      {
        "methodName": "testIteratorSequenceBreaking",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<[3]> but was:<[4]>",
        "fail_line": "            assertEquals(String.valueOf(recordNumber), record.get(0));",
        "test_source": "  public void testIteratorSequenceBreaking() throws IOException {\n  final String fiveRows = \"1\\n2\\n3\\n4\\n5\\n\";\n\n  // Iterator hasNext() shouldn't break sequence\n  CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\n  int recordNumber = 0;\n  Iterator<CSVRecord> iter = parser.iterator();\n  recordNumber = 0;\n  while (iter.hasNext()) {\n  CSVRecord record = iter.next();\n  recordNumber++;\n  assertEquals(String.valueOf(recordNumber), record.get(0));\n  if (recordNumber >= 2) {\n  break;\n  }\n  }\n  iter.hasNext();\n  while (iter.hasNext()) {\n  CSVRecord record = iter.next();\n  recordNumber++;\n  assertEquals(String.valueOf(recordNumber), record.get(0));\n  }\n\n  // Consecutive enhanced for loops shouldn't break sequence\n  parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\n  recordNumber = 0;\n  for (CSVRecord record : parser) {\n  recordNumber++;\n  assertEquals(String.valueOf(recordNumber), record.get(0));\n  if (recordNumber >= 2) {\n  break;\n  }\n  }\n  for (CSVRecord record : parser) {\n  recordNumber++;\n  assertEquals(String.valueOf(recordNumber), record.get(0));\n  }\n\n  // Consecutive enhanced for loops with hasNext() peeking shouldn't break sequence\n  parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\n  recordNumber = 0;\n  for (CSVRecord record : parser) {\n  recordNumber++;\n  assertEquals(String.valueOf(recordNumber), record.get(0));\n  if (recordNumber >= 2) {\n  break;\n  }\n  }\n  parser.iterator().hasNext();\n  for (CSVRecord record : parser) {\n  recordNumber++;\n  assertEquals(String.valueOf(recordNumber), record.get(0));\n  }\n  }",
        "stack": [
          "CSVParserTest.testIteratorSequenceBreaking line 1053"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/csv/CSVParser.java",
      "buggy_full_code": "\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN; import java.io.Closeable; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.Reader; import java.io.StringReader; import java.net.URL; import java.nio.charset.Charset; import java.nio.file.Files; import java.nio.file.Path; import java.util.ArrayList; import java.util.Arrays; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.List; import java.util.Map; import java.util.NoSuchElementException; import java.util.TreeMap; public final class CSVParser implements Iterable<CSVRecord>, Closeable { @SuppressWarnings(\"resource\") public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    \n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(inputStream, \"inputStream\");\n        Assertions.notNull(format, \"format\");\n        return parse(new InputStreamReader(inputStream, charset), format);\n    }\n\n    \n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(path, \"path\");\n        Assertions.notNull(format, \"format\");\n        return parse(Files.newBufferedReader(path, charset), format);\n    }\n\n    \n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n        return new CSVParser(reader, format);\n    }\n\n    \n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    \n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    \n\n    private final CSVFormat format; private final Map<String, Integer> headerMap; private final Lexer lexer; private final List<String> recordList = new ArrayList<>(); private long recordNumber; private final long characterOffset; private final Token reusableToken = new Token(); public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        this(reader, format, 0, 1);\n    }\n\n    \n    @SuppressWarnings(\"resource\")\n    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber) throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.headerMap = this.initializeHeader();\n        this.characterOffset = characterOffset;\n        this.recordNumber = recordNumber - 1;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final String input = this.reusableToken.content.toString();\n        final String inputClean = this.format.getTrim() ? input.trim() : input;\n        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {\n            return;\n        }\n        final String nullString = this.format.getNullString();\n        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    \n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    \n    public String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    \n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<>(this.headerMap);\n    }\n\n    \n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    \n    public List<CSVRecord> getRecords() throws IOException {\n        CSVRecord rec;\n        final List<CSVRecord> records = new ArrayList<>();\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    \n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = this.format.getIgnoreHeaderCase() ?\n                    new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER) :\n                    new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                \n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            \n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || !this.format.getAllowMissingColumnNames())) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    \n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    \n    @Override\n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n        private CSVRecord current; private CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final IOException e) {\n                throw new IllegalStateException(\n                        e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n            }\n        }\n  \n        @Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n  \n            return this.current != null;\n        }\n  \n        @Override\n        public CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new NoSuchElementException(\"CSVParser has been closed\");\n            }\n            CSVRecord next = this.current;\n            this.current = null;\n  \n            if (next == null) {\n                \n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n  \n            return next;\n        }\n  \n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    };\n    }\n\n    \n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.recordList.clear();\n        StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue(false);\n                break;\n            case EORECORD:\n                this.addRecordValue(true);\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue(true);\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: \n                if (sb == null) { \n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; \n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.recordList.toArray(new String[this.recordList.size()]), this.headerMap, comment,\n                    this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN; import java.io.Closeable; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.Reader; import java.io.StringReader; import java.net.URL; import java.nio.charset.Charset; import java.nio.file.Files; import java.nio.file.Path; import java.util.ArrayList; import java.util.Arrays; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.List; import java.util.Map; import java.util.NoSuchElementException; import java.util.TreeMap; public final class CSVParser implements Iterable<CSVRecord>, Closeable { @SuppressWarnings(\"resource\") public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    \n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(inputStream, \"inputStream\");\n        Assertions.notNull(format, \"format\");\n        return parse(new InputStreamReader(inputStream, charset), format);\n    }\n\n    \n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(path, \"path\");\n        Assertions.notNull(format, \"format\");\n        return parse(Files.newBufferedReader(path, charset), format);\n    }\n\n    \n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n        return new CSVParser(reader, format);\n    }\n\n    \n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    \n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    \n\n    private final CSVFormat format; private final Map<String, Integer> headerMap; private final Lexer lexer; private final CSVRecordIterator csvRecordIterator; private final List<String> recordList = new ArrayList<>(); private long recordNumber; private final long characterOffset; private final Token reusableToken = new Token(); public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        this(reader, format, 0, 1);\n    }\n\n    \n    @SuppressWarnings(\"resource\")\n    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber) throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.csvRecordIterator = new CSVRecordIterator();\n        this.headerMap = this.initializeHeader();\n        this.characterOffset = characterOffset;\n        this.recordNumber = recordNumber - 1;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final String input = this.reusableToken.content.toString();\n        final String inputClean = this.format.getTrim() ? input.trim() : input;\n        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {\n            return;\n        }\n        final String nullString = this.format.getNullString();\n        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    \n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    \n    public String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    \n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<>(this.headerMap);\n    }\n\n    \n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    \n    public List<CSVRecord> getRecords() throws IOException {\n        CSVRecord rec;\n        final List<CSVRecord> records = new ArrayList<>();\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    \n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = this.format.getIgnoreHeaderCase() ?\n                    new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER) :\n                    new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                \n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            \n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || !this.format.getAllowMissingColumnNames())) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    \n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    \n    @Override\n    public Iterator<CSVRecord> iterator() {\n        return csvRecordIterator;\n    }\n    \n    class CSVRecordIterator implements Iterator<CSVRecord> {\n        private CSVRecord current; private CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final IOException e) {\n                throw new IllegalStateException(\n                        e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n            }\n        }\n  \n        @Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n  \n            return this.current != null;\n        }\n  \n        @Override\n        public CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new NoSuchElementException(\"CSVParser has been closed\");\n            }\n            CSVRecord next = this.current;\n            this.current = null;\n  \n            if (next == null) {\n                \n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n  \n            return next;\n        }\n  \n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    };\n\n    \n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.recordList.clear();\n        StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue(false);\n                break;\n            case EORECORD:\n                this.addRecordValue(true);\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue(true);\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: \n                if (sb == null) { \n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; \n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.recordList.toArray(new String[this.recordList.size()]), this.headerMap, comment,\n                    this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n\n}\n",
      "buggy_signatures": [
        "static org.apache.commons.csv.Token.Type.TOKEN; import java.io.Closeable; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.Reader; import java.io.StringReader; import java.net.URL; import java.nio.charset.Charset; import java.nio.file.Files; import java.nio.file.Path; import java.util.ArrayList; import java.util.Arrays; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.List; import java.util.Map; import java.util.NoSuchElementException; import java.util.TreeMap; public final class CSVParser implements Iterable<CSVRecord>, Closeable { @SuppressWarnings(\"resource\") public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException",
        "public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format) throws IOException",
        "public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException",
        "public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException",
        "public static CSVParser parse(final String string, final CSVFormat format) throws IOException",
        "public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException",
        "public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber) throws IOException",
        "private void addRecordValue(final boolean lastRecord)",
        "public void close() throws IOException",
        "public long getCurrentLineNumber()",
        "public String getFirstEndOfLine()",
        "public Map<String, Integer> getHeaderMap()",
        "public long getRecordNumber()",
        "public List<CSVRecord> getRecords() throws IOException",
        "private Map<String, Integer> initializeHeader() throws IOException",
        "public boolean isClosed()",
        "public Iterator<CSVRecord> iterator()",
        "private CSVRecord current; private CSVRecord getNextRecord()",
        "public boolean hasNext()",
        "public CSVRecord next()",
        "public void remove()"
      ],
      "fixed_signatures": [
        "static org.apache.commons.csv.Token.Type.TOKEN; import java.io.Closeable; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.Reader; import java.io.StringReader; import java.net.URL; import java.nio.charset.Charset; import java.nio.file.Files; import java.nio.file.Path; import java.util.ArrayList; import java.util.Arrays; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.List; import java.util.Map; import java.util.NoSuchElementException; import java.util.TreeMap; public final class CSVParser implements Iterable<CSVRecord>, Closeable { @SuppressWarnings(\"resource\") public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException",
        "public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format) throws IOException",
        "public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException",
        "public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException",
        "public static CSVParser parse(final String string, final CSVFormat format) throws IOException",
        "public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException",
        "public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber) throws IOException",
        "private void addRecordValue(final boolean lastRecord)",
        "public void close() throws IOException",
        "public long getCurrentLineNumber()",
        "public String getFirstEndOfLine()",
        "public Map<String, Integer> getHeaderMap()",
        "public long getRecordNumber()",
        "public List<CSVRecord> getRecords() throws IOException",
        "private Map<String, Integer> initializeHeader() throws IOException",
        "public boolean isClosed()",
        "public Iterator<CSVRecord> iterator()",
        "private CSVRecord current; private CSVRecord getNextRecord()",
        "public boolean hasNext()",
        "public CSVRecord next()",
        "public void remove()"
      ],
      "methods": [
        {
          "buggy_method": "  private final List<String> recordList = new ArrayList<>(); private long recordNumber; /** * Lexer offset when the parser does not start parsing at the beginning of the source. Usually used in combination * with {@link #recordNumber}.",
          "fixed_method": "  private final List<String> recordList = new ArrayList<>(); private long recordNumber; /** * Lexer offset when the parser does not start parsing at the beginning of the source. Usually used in combination * with {@link #recordNumber}.",
          "diff": [
            "@@ -286,6 +286,7 @@",
            " \n",
            "     private final Lexer lexer;\n",
            " \n",
            "+    private final CSVRecordIterator csvRecordIterator;\n",
            "     \n",
            "     /** A record buffer for getRecord(). Grows as necessary and is reused. */\n",
            "     private final List<String> recordList = new ArrayList<>();\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber) throws IOException {\n  Assertions.notNull(reader, \"reader\");\n  Assertions.notNull(format, \"format\");\n\n  this.format = format;\n  this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n  this.headerMap = this.initializeHeader();\n  this.characterOffset = characterOffset;\n  this.recordNumber = recordNumber - 1;\n  }",
          "fixed_method": "  public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber) throws IOException {\n  Assertions.notNull(reader, \"reader\");\n  Assertions.notNull(format, \"format\");\n\n  this.format = format;\n  this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n  this.csvRecordIterator = new CSVRecordIterator();\n  this.headerMap = this.initializeHeader();\n  this.characterOffset = characterOffset;\n  this.recordNumber = recordNumber - 1;\n  }",
          "diff": [
            "@@ -354,6 +355,7 @@",
            " \n",
            "         this.format = format;\n",
            "         this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n",
            "+        this.csvRecordIterator = new CSVRecordIterator();\n",
            "         this.headerMap = this.initializeHeader();\n",
            "         this.characterOffset = characterOffset;\n",
            "         this.recordNumber = recordNumber - 1;\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  private CSVRecord getNextRecord() {\n  try {\n  return CSVParser.this.nextRecord();\n  } catch (final IOException e) {\n  throw new IllegalStateException(\n  e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n  }\n  }",
          "fixed_method": "  public Iterator<CSVRecord> iterator() {\n  return csvRecordIterator;\n  }",
          "diff": [
            "@@ -520,7 +522,10 @@",
            "      */\n",
            "     @Override\n",
            "     public Iterator<CSVRecord> iterator() {\n",
            "-        return new Iterator<CSVRecord>() {\n",
            "+        return csvRecordIterator;\n",
            "+    }\n",
            "+    \n",
            "+    class CSVRecordIterator implements Iterator<CSVRecord> {\n",
            "         private CSVRecord current;\n",
            "   \n",
            "         private CSVRecord getNextRecord() {\n"
          ],
          "changed_lines": 5
        },
        {
          "buggy_method": "  public void remove() {\n  throw new UnsupportedOperationException();\n  }",
          "fixed_method": "  public void remove() {\n  throw new UnsupportedOperationException();\n  }",
          "diff": [
            "@@ -568,7 +573,6 @@",
            "             throw new UnsupportedOperationException();\n",
            "         }\n",
            "     };\n",
            "-    }\n",
            " \n",
            "     /**\n",
            "      * Parses the next record from the current point in the stream.\n"
          ],
          "changed_lines": 1
        }
      ]
    }
  ]
}
