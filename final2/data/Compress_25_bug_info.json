{
  "bug_id": "25",
  "failed_tests": {
    "org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest": [
      {
        "methodName": "testReadingOfFirstStoredEntry",
        "error": "junit.framework.AssertionFailedError",
        "message": "arrays first differed at element [0]; expected:<100> but was:<0>",
        "fail_line": "            assertArrayEquals(new byte[] {'d', 'a', 't', 'a', '\\n'},",
        "test_source": "  public void testReadingOfFirstStoredEntry() throws Exception {\n  ZipArchiveInputStream in = new ZipArchiveInputStream(new FileInputStream(getFile(\"COMPRESS-264.zip\")));\n  \n  try {\n  ZipArchiveEntry ze = in.getNextZipEntry();\n  assertEquals(5, ze.getSize());\n  assertArrayEquals(new byte[] {'d', 'a', 't', 'a', '\\n'},\n  IOUtils.toByteArray(in));\n  } finally {\n  in.close();\n  }\n  }",
        "stack": [
          "ZipArchiveInputStreamTest.testReadingOfFirstStoredEntry line 166"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.zip;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PushbackInputStream;\nimport java.nio.ByteBuffer;\nimport java.util.zip.CRC32;\nimport java.util.zip.DataFormatException;\nimport java.util.zip.Inflater;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipException;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.utils.IOUtils;\n\nimport static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD; import static org.apache.commons.compress.archivers.zip.ZipConstants.SHORT; import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD; import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC; public class ZipArchiveInputStream extends ArchiveInputStream { private final ZipEncoding zipEncoding; private final boolean useUnicodeExtraFields; private final InputStream in; private final Inflater inf = new Inflater(true); private final ByteBuffer buf = ByteBuffer.allocate(ZipArchiveOutputStream.BUFFER_SIZE); private CurrentEntry current = null; private boolean closed = false; private boolean hitCentralDirectory = false; private ByteArrayInputStream lastStoredEntry = null; private boolean allowStoredEntriesWithDataDescriptor = false; private static final int LFH_LEN = 30; private static final int CFH_LEN = 46; private static final long TWO_EXP_32 = ZIP64_MAGIC + 1; private final byte[] LFH_BUF = new byte[LFH_LEN]; private final byte[] SKIP_BUF = new byte[1024]; private final byte[] SHORT_BUF = new byte[SHORT]; private final byte[] WORD_BUF = new byte[WORD]; private final byte[] TWO_DWORD_BUF = new byte[2 * DWORD]; private int entriesRead = 0; public ZipArchiveInputStream(InputStream inputStream) {\n        this(inputStream, ZipEncodingHelper.UTF8);\n    }\n\n    \n    public ZipArchiveInputStream(InputStream inputStream, String encoding) {\n        this(inputStream, encoding, true);\n    }\n\n    \n    public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields) {\n        this(inputStream, encoding, useUnicodeExtraFields, false);\n    }\n\n    \n    public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        in = new PushbackInputStream(inputStream, buf.capacity());\n        this.allowStoredEntriesWithDataDescriptor =\n            allowStoredEntriesWithDataDescriptor;\n        \n    }\n\n    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        boolean firstEntry = true;\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n            firstEntry = false;\n        }\n\n        try {\n            if (firstEntry) {\n                \n                \n                \n                \n                readFirstLocalFileHeader(LFH_BUF);\n            } else {\n                readFully(LFH_BUF);\n            }\n        } catch (EOFException e) {\n            return null;\n        }\n\n        ZipLong sig = new ZipLong(LFH_BUF);\n        if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n            hitCentralDirectory = true;\n            skipRemainderOfArchive();\n        }\n        if (!sig.equals(ZipLong.LFH_SIG)) {\n            return null;\n        }\n\n        int off = WORD;\n        current = new CurrentEntry();\n\n        int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n        current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n\n        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n        current.entry.setGeneralPurposeBit(gpFlag);\n\n        off += SHORT;\n\n        current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\n        off += SHORT;\n\n        long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\n        current.entry.setTime(time);\n        off += WORD;\n\n        ZipLong size = null, cSize = null;\n        if (!current.hasDataDescriptor) {\n            current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\n            off += WORD;\n\n            cSize = new ZipLong(LFH_BUF, off);\n            off += WORD;\n\n            size = new ZipLong(LFH_BUF, off);\n            off += WORD;\n        } else {\n            off += 3 * WORD;\n        }\n\n        int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n\n        off += SHORT;\n\n        int extraLen = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n\n        byte[] fileName = new byte[fileNameLen];\n        readFully(fileName);\n        current.entry.setName(entryEncoding.decode(fileName), fileName);\n\n        byte[] extraData = new byte[extraLen];\n        readFully(extraData);\n        current.entry.setExtra(extraData);\n\n        if (!hasUTF8Flag && useUnicodeExtraFields) {\n            ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n        }\n\n        processZip64Extra(size, cSize);\n\n        if (current.entry.getCompressedSize() != -1) {\n            if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n                current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n            } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n                current.in = new ExplodingInputStream(\n                        current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n                        current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n                        new BoundedInputStream(in, current.entry.getCompressedSize()));\n            }\n        }\n        \n        entriesRead++;\n        return current.entry;\n    }\n\n    \n    private void readFirstLocalFileHeader(byte[] lfh) throws IOException {\n        readFully(lfh);\n        ZipLong sig = new ZipLong(lfh);\n        if (sig.equals(ZipLong.DD_SIG)) {\n            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.SPLITTING);\n        }\n\n        if (sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER)) {\n            \n            \n            byte[] missedLfhBytes = new byte[4];\n            readFully(missedLfhBytes);\n            System.arraycopy(lfh, 4, lfh, 0, LFH_LEN - 4);\n            System.arraycopy(missedLfhBytes, 0, lfh, LFH_LEN - 4, 4);\n        }\n    }\n\n    \n    private void processZip64Extra(ZipLong size, ZipLong cSize) {\n        Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField) \n            current.entry.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        current.usesZip64 = z64 != null;\n        if (!current.hasDataDescriptor) {\n            if (z64 != null \n                    && (cSize.equals(ZipLong.ZIP64_MAGIC) || size.equals(ZipLong.ZIP64_MAGIC)) ) {\n                current.entry.setCompressedSize(z64.getCompressedSize().getLongValue());\n                current.entry.setSize(z64.getSize().getLongValue());\n            } else {\n                current.entry.setCompressedSize(cSize.getValue());\n                current.entry.setSize(size.getValue());\n            }\n        }\n    }\n\n    @Override\n    public ArchiveEntry getNextEntry() throws IOException {\n        return getNextZipEntry();\n    }\n\n    \n    @Override\n    public boolean canReadEntryData(ArchiveEntry ae) {\n        if (ae instanceof ZipArchiveEntry) {\n            ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n            return ZipUtil.canHandleEntryData(ze)\n                && supportsDataDescriptorFor(ze);\n\n        }\n        return false;\n    }\n\n    @Override\n    public int read(byte[] buffer, int offset, int length) throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n\n        if (current == null) {\n            return -1;\n        }\n\n        \n        if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n        \n        ZipUtil.checkRequestedFeatures(current.entry);\n        if (!supportsDataDescriptorFor(current.entry)) {\n            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR,\n                    current.entry);\n        }\n\n        int read;\n        if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n            read = readStored(buffer, offset, length);\n        } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n            read = readDeflated(buffer, offset, length);\n        } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()\n                || current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n            read = current.in.read(buffer, offset, length);\n        } else {\n            throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()),\n                    current.entry);\n        }\n        \n        if (read >= 0) {\n            current.crc.update(buffer, offset, read);\n        }\n        \n        return read;\n    }\n\n    \n    private int readStored(byte[] buffer, int offset, int length) throws IOException {\n\n        if (current.hasDataDescriptor) {\n            if (lastStoredEntry == null) {\n                readStoredEntry();\n            }\n            return lastStoredEntry.read(buffer, offset, length);\n        }\n\n        long csize = current.entry.getSize();\n        if (current.bytesRead >= csize) {\n            return -1;\n        }\n\n        if (buf.position() >= buf.limit()) {\n            buf.position(0);\n            int l = in.read(buf.array());\n            if (l == -1) {\n                return -1;\n            }\n            buf.limit(l);\n\n            count(buf.limit());\n            current.bytesReadFromStream += buf.limit();\n        }\n\n        int toRead = Math.min(buf.remaining(), length);\n        if ((csize - current.bytesRead) < toRead) {\n            \n            toRead = (int) (csize - current.bytesRead);\n        }\n        buf.get(buffer, offset, toRead);\n        current.bytesRead += toRead;\n        return toRead;\n    }\n\n    \n    private int readDeflated(byte[] buffer, int offset, int length) throws IOException {\n        int read = readFromInflater(buffer, offset, length);\n        if (read <= 0) {\n            if (inf.finished()) {\n                return -1;\n            } else if (inf.needsDictionary()) {\n                throw new ZipException(\"This archive needs a preset dictionary\"\n                                       + \" which is not supported by Commons\"\n                                       + \" Compress.\");\n            } else if (read == -1) {\n                throw new IOException(\"Truncated ZIP file\");\n            }\n        }\n        return read;\n    }\n\n    \n    private int readFromInflater(byte[] buffer, int offset, int length) throws IOException {\n        int read = 0;\n        do {\n            if (inf.needsInput()) {\n                int l = fill();\n                if (l > 0) {\n                    current.bytesReadFromStream += buf.limit();\n                } else if (l == -1) {\n                    return -1;\n                } else {\n                    break;\n                }\n            }\n            try {\n                read = inf.inflate(buffer, offset, length);\n            } catch (DataFormatException e) {\n                throw (IOException) new ZipException(e.getMessage()).initCause(e);\n            }\n        } while (read == 0 && inf.needsInput());\n        return read;\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (!closed) {\n            closed = true;\n            in.close();\n            inf.end();\n        }\n    }\n\n    \n    @Override\n    public long skip(long value) throws IOException {\n        if (value >= 0) {\n            long skipped = 0;\n            while (skipped < value) {\n                long rem = value - skipped;\n                int x = read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));\n                if (x == -1) {\n                    return skipped;\n                }\n                skipped += x;\n            }\n            return skipped;\n        }\n        throw new IllegalArgumentException();\n    }\n\n    \n    public static boolean matches(byte[] signature, int length) {\n        if (length < ZipArchiveOutputStream.LFH_SIG.length) {\n            return false;\n        }\n\n        return checksig(signature, ZipArchiveOutputStream.LFH_SIG) \n            || checksig(signature, ZipArchiveOutputStream.EOCD_SIG) \n            || checksig(signature, ZipArchiveOutputStream.DD_SIG) \n            || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());\n    }\n\n    private static boolean checksig(byte[] signature, byte[] expected) {\n        for (int i = 0; i < expected.length; i++) {\n            if (signature[i] != expected[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    private void closeEntry() throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        if (current == null) {\n            return;\n        }\n\n        \n        if (current.bytesReadFromStream <= current.entry.getCompressedSize()\n                && !current.hasDataDescriptor) {\n            drainCurrentEntryData();\n        } else {\n            skip(Long.MAX_VALUE);\n\n            long inB = current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED\n                       ? getBytesInflated() : current.bytesRead;\n\n            \n            \n            int diff = (int) (current.bytesReadFromStream - inB);\n\n            \n            if (diff > 0) {\n                pushback(buf.array(), buf.limit() - diff, diff);\n            }\n        }\n\n        if (lastStoredEntry == null && current.hasDataDescriptor) {\n            readDataDescriptor();\n        }\n\n        inf.reset();\n        buf.clear().flip();\n        current = null;\n        lastStoredEntry = null;\n    }\n\n    \n    private void drainCurrentEntryData() throws IOException {\n        long remaining = current.entry.getCompressedSize() - current.bytesReadFromStream;\n        while (remaining > 0) {\n            long n = in.read(buf.array(), 0, (int) Math.min(buf.capacity(), remaining));\n            if (n < 0) {\n                throw new EOFException(\"Truncated ZIP entry: \" + current.entry.getName());\n            } else {\n                count(n);\n                remaining -= n;\n            }\n        }\n    }\n\n    \n    private long getBytesInflated() {\n        long inB = inf.getBytesRead();\n        if (current.bytesReadFromStream >= TWO_EXP_32) {\n            while (inB + TWO_EXP_32 <= current.bytesReadFromStream) {\n                inB += TWO_EXP_32;\n            }\n        }\n        return inB;\n    }\n\n    private int fill() throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        int length = in.read(buf.array());\n        if (length > 0) {\n            buf.limit(length);\n            count(buf.limit());\n            inf.setInput(buf.array(), 0, buf.limit());\n        }\n        return length;\n    }\n\n    private void readFully(byte[] b) throws IOException {\n        int count = IOUtils.readFully(in, b);\n        count(count);\n        if (count < b.length) {\n            throw new EOFException();\n        }\n    }\n\n    private void readDataDescriptor() throws IOException {\n        readFully(WORD_BUF);\n        ZipLong val = new ZipLong(WORD_BUF);\n        if (ZipLong.DD_SIG.equals(val)) {\n            \n            readFully(WORD_BUF);\n            val = new ZipLong(WORD_BUF);\n        }\n        current.entry.setCrc(val.getValue());\n\n        \n        \n        \n        \n        \n\n        \n        \n        \n        \n        \n        readFully(TWO_DWORD_BUF);\n        ZipLong potentialSig = new ZipLong(TWO_DWORD_BUF, DWORD);\n        if (potentialSig.equals(ZipLong.CFH_SIG) || potentialSig.equals(ZipLong.LFH_SIG)) {\n            pushback(TWO_DWORD_BUF, DWORD, DWORD);\n            current.entry.setCompressedSize(ZipLong.getValue(TWO_DWORD_BUF));\n            current.entry.setSize(ZipLong.getValue(TWO_DWORD_BUF, WORD));\n        } else {\n            current.entry.setCompressedSize(ZipEightByteInteger.getLongValue(TWO_DWORD_BUF));\n            current.entry.setSize(ZipEightByteInteger.getLongValue(TWO_DWORD_BUF, DWORD));\n        }\n    }\n\n    \n    private boolean supportsDataDescriptorFor(ZipArchiveEntry entry) {\n        return !entry.getGeneralPurposeBit().usesDataDescriptor()\n\n                || (allowStoredEntriesWithDataDescriptor && entry.getMethod() == ZipEntry.STORED)\n                || entry.getMethod() == ZipEntry.DEFLATED;\n    }\n\n    \n    private void readStoredEntry() throws IOException {\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        int off = 0;\n        boolean done = false;\n\n        \n        int ddLen = current.usesZip64 ? WORD + 2 * DWORD : 3 * WORD;\n\n        while (!done) {\n            int r = in.read(buf.array(), off, ZipArchiveOutputStream.BUFFER_SIZE - off);\n            if (r <= 0) {\n                \n                \n                throw new IOException(\"Truncated ZIP file\");\n            }\n            if (r + off < 4) {\n                \n                off += r;\n                continue;\n            }\n\n            done = bufferContainsSignature(bos, off, r, ddLen);\n            if (!done) {\n                off = cacheBytesRead(bos, off, r, ddLen);\n            }\n        }\n\n        byte[] b = bos.toByteArray();\n        lastStoredEntry = new ByteArrayInputStream(b);\n    }\n\n    private static final byte[] LFH = ZipLong.LFH_SIG.getBytes(); private static final byte[] CFH = ZipLong.CFH_SIG.getBytes(); private static final byte[] DD = ZipLong.DD_SIG.getBytes(); private boolean bufferContainsSignature(ByteArrayOutputStream bos, int offset, int lastRead, int expectedDDLen) throws IOException {\n\n        boolean done = false;\n        int readTooMuch = 0;\n        for (int i = 0; !done && i < lastRead - 4; i++) {\n            if (buf.array()[i] == LFH[0] && buf.array()[i + 1] == LFH[1]) {\n                if ((buf.array()[i + 2] == LFH[2] && buf.array()[i + 3] == LFH[3])\n                    || (buf.array()[i] == CFH[2] && buf.array()[i + 3] == CFH[3])) {\n                    \n                    readTooMuch = offset + lastRead - i - expectedDDLen;\n                    done = true;\n                }\n                else if (buf.array()[i + 2] == DD[2] && buf.array()[i + 3] == DD[3]) {\n                    \n                    readTooMuch = offset + lastRead - i;\n                    done = true;\n                }\n                if (done) {\n                    \n                    \n                    \n                    \n                    pushback(buf.array(), offset + lastRead - readTooMuch, readTooMuch);\n                    bos.write(buf.array(), 0, i);\n                    readDataDescriptor();\n                }\n            }\n        }\n        return done;\n    }\n\n    \n    private int cacheBytesRead(ByteArrayOutputStream bos, int offset, int lastRead, int expecteDDLen) {\n        final int cacheable = offset + lastRead - expecteDDLen - 3;\n        if (cacheable > 0) {\n            bos.write(buf.array(), 0, cacheable);\n            System.arraycopy(buf.array(), cacheable, buf.array(), 0, expecteDDLen + 3);\n            offset = expecteDDLen + 3;\n        } else {\n            offset += lastRead;\n        }\n        return offset;\n    }\n\n    private void pushback(byte[] buf, int offset, int length) throws IOException {\n        ((PushbackInputStream) in).unread(buf, offset, length);\n        pushedBackBytes(length);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    private void skipRemainderOfArchive() throws IOException {\n        \n        \n        \n        realSkip(entriesRead * CFH_LEN - LFH_LEN);\n        findEocdRecord();\n        realSkip(ZipFile.MIN_EOCD_SIZE - WORD  - SHORT );\n        readFully(SHORT_BUF);\n        \n        realSkip(ZipShort.getValue(SHORT_BUF));\n    }\n\n    \n    private void findEocdRecord() throws IOException {\n        int currentByte = -1;\n        boolean skipReadCall = false;\n        while (skipReadCall || (currentByte = readOneByte()) > -1) {\n            skipReadCall = false;\n            if (!isFirstByteOfEocdSig(currentByte)) {\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[1]) {\n                if (currentByte == -1) {\n                    break;\n                }\n                skipReadCall = isFirstByteOfEocdSig(currentByte);\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[2]) {\n                if (currentByte == -1) {\n                    break;\n                }\n                skipReadCall = isFirstByteOfEocdSig(currentByte);\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte == -1\n                || currentByte == ZipArchiveOutputStream.EOCD_SIG[3]) {\n                break;\n            }\n            skipReadCall = isFirstByteOfEocdSig(currentByte);\n        }\n    }\n\n    \n    private void realSkip(long value) throws IOException {\n        if (value >= 0) {\n            long skipped = 0;\n            while (skipped < value) {\n                long rem = value - skipped;\n                int x = in.read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));\n                if (x == -1) {\n                    return;\n                }\n                count(x);\n                skipped += x;\n            }\n            return;\n        }\n        throw new IllegalArgumentException();\n    }\n\n    \n    private int readOneByte() throws IOException {\n        int b = in.read();\n        if (b != -1) {\n            count(1);\n        }\n        return b;\n    }\n\n    private boolean isFirstByteOfEocdSig(int b) {\n        return b == ZipArchiveOutputStream.EOCD_SIG[0];\n    }\n\n    \n    private static final class CurrentEntry { private final ZipArchiveEntry entry = new ZipArchiveEntry(); private boolean hasDataDescriptor; private boolean usesZip64; private long bytesRead; private long bytesReadFromStream; private final CRC32 crc = new CRC32(); private InputStream in; } private class BoundedInputStream extends InputStream {\n\n        \n        private final InputStream in; private final long max; private long pos = 0; public BoundedInputStream(final InputStream in, final long size) {\n            this.max = size;\n            this.in = in;\n        }\n\n        @Override\n        public int read() throws IOException {\n            if (max >= 0 && pos >= max) {\n                return -1;\n            }\n            final int result = in.read();\n            pos++;\n            count(1);\n            current.bytesReadFromStream++;\n            return result;\n        }\n\n        @Override\n        public int read(final byte[] b) throws IOException {\n            return this.read(b, 0, b.length);\n        }\n\n        @Override\n        public int read(final byte[] b, final int off, final int len) throws IOException {\n            if (max >= 0 && pos >= max) {\n                return -1;\n            }\n            final long maxRead = max >= 0 ? Math.min(len, max - pos) : len;\n            final int bytesRead = in.read(b, off, (int) maxRead);\n\n            if (bytesRead == -1) {\n                return -1;\n            }\n\n            pos += bytesRead;\n            count(bytesRead);\n            current.bytesReadFromStream += bytesRead;\n            return bytesRead;\n        }\n\n        @Override\n        public long skip(final long n) throws IOException {\n            final long toSkip = max >= 0 ? Math.min(n, max - pos) : n;\n            final long skippedBytes = in.skip(toSkip);\n            pos += skippedBytes;\n            return skippedBytes;\n        }\n    \n        @Override\n        public int available() throws IOException {\n            if (max >= 0 && pos >= max) {\n                return 0;\n            }\n            return in.available();\n        }\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.zip;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PushbackInputStream;\nimport java.nio.ByteBuffer;\nimport java.util.zip.CRC32;\nimport java.util.zip.DataFormatException;\nimport java.util.zip.Inflater;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipException;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.utils.IOUtils;\n\nimport static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD; import static org.apache.commons.compress.archivers.zip.ZipConstants.SHORT; import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD; import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC; public class ZipArchiveInputStream extends ArchiveInputStream { private final ZipEncoding zipEncoding; private final boolean useUnicodeExtraFields; private final InputStream in; private final Inflater inf = new Inflater(true); private final ByteBuffer buf = ByteBuffer.allocate(ZipArchiveOutputStream.BUFFER_SIZE); private CurrentEntry current = null; private boolean closed = false; private boolean hitCentralDirectory = false; private ByteArrayInputStream lastStoredEntry = null; private boolean allowStoredEntriesWithDataDescriptor = false; private static final int LFH_LEN = 30; private static final int CFH_LEN = 46; private static final long TWO_EXP_32 = ZIP64_MAGIC + 1; private final byte[] LFH_BUF = new byte[LFH_LEN]; private final byte[] SKIP_BUF = new byte[1024]; private final byte[] SHORT_BUF = new byte[SHORT]; private final byte[] WORD_BUF = new byte[WORD]; private final byte[] TWO_DWORD_BUF = new byte[2 * DWORD]; private int entriesRead = 0; public ZipArchiveInputStream(InputStream inputStream) {\n        this(inputStream, ZipEncodingHelper.UTF8);\n    }\n\n    \n    public ZipArchiveInputStream(InputStream inputStream, String encoding) {\n        this(inputStream, encoding, true);\n    }\n\n    \n    public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields) {\n        this(inputStream, encoding, useUnicodeExtraFields, false);\n    }\n\n    \n    public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        in = new PushbackInputStream(inputStream, buf.capacity());\n        this.allowStoredEntriesWithDataDescriptor =\n            allowStoredEntriesWithDataDescriptor;\n        \n        buf.limit(0);\n    }\n\n    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        boolean firstEntry = true;\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n            firstEntry = false;\n        }\n\n        try {\n            if (firstEntry) {\n                \n                \n                \n                \n                readFirstLocalFileHeader(LFH_BUF);\n            } else {\n                readFully(LFH_BUF);\n            }\n        } catch (EOFException e) {\n            return null;\n        }\n\n        ZipLong sig = new ZipLong(LFH_BUF);\n        if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n            hitCentralDirectory = true;\n            skipRemainderOfArchive();\n        }\n        if (!sig.equals(ZipLong.LFH_SIG)) {\n            return null;\n        }\n\n        int off = WORD;\n        current = new CurrentEntry();\n\n        int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n        current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n\n        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n        current.entry.setGeneralPurposeBit(gpFlag);\n\n        off += SHORT;\n\n        current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\n        off += SHORT;\n\n        long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\n        current.entry.setTime(time);\n        off += WORD;\n\n        ZipLong size = null, cSize = null;\n        if (!current.hasDataDescriptor) {\n            current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\n            off += WORD;\n\n            cSize = new ZipLong(LFH_BUF, off);\n            off += WORD;\n\n            size = new ZipLong(LFH_BUF, off);\n            off += WORD;\n        } else {\n            off += 3 * WORD;\n        }\n\n        int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n\n        off += SHORT;\n\n        int extraLen = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n\n        byte[] fileName = new byte[fileNameLen];\n        readFully(fileName);\n        current.entry.setName(entryEncoding.decode(fileName), fileName);\n\n        byte[] extraData = new byte[extraLen];\n        readFully(extraData);\n        current.entry.setExtra(extraData);\n\n        if (!hasUTF8Flag && useUnicodeExtraFields) {\n            ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n        }\n\n        processZip64Extra(size, cSize);\n\n        if (current.entry.getCompressedSize() != -1) {\n            if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n                current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n            } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n                current.in = new ExplodingInputStream(\n                        current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n                        current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n                        new BoundedInputStream(in, current.entry.getCompressedSize()));\n            }\n        }\n        \n        entriesRead++;\n        return current.entry;\n    }\n\n    \n    private void readFirstLocalFileHeader(byte[] lfh) throws IOException {\n        readFully(lfh);\n        ZipLong sig = new ZipLong(lfh);\n        if (sig.equals(ZipLong.DD_SIG)) {\n            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.SPLITTING);\n        }\n\n        if (sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER)) {\n            \n            \n            byte[] missedLfhBytes = new byte[4];\n            readFully(missedLfhBytes);\n            System.arraycopy(lfh, 4, lfh, 0, LFH_LEN - 4);\n            System.arraycopy(missedLfhBytes, 0, lfh, LFH_LEN - 4, 4);\n        }\n    }\n\n    \n    private void processZip64Extra(ZipLong size, ZipLong cSize) {\n        Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField) \n            current.entry.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        current.usesZip64 = z64 != null;\n        if (!current.hasDataDescriptor) {\n            if (z64 != null \n                    && (cSize.equals(ZipLong.ZIP64_MAGIC) || size.equals(ZipLong.ZIP64_MAGIC)) ) {\n                current.entry.setCompressedSize(z64.getCompressedSize().getLongValue());\n                current.entry.setSize(z64.getSize().getLongValue());\n            } else {\n                current.entry.setCompressedSize(cSize.getValue());\n                current.entry.setSize(size.getValue());\n            }\n        }\n    }\n\n    @Override\n    public ArchiveEntry getNextEntry() throws IOException {\n        return getNextZipEntry();\n    }\n\n    \n    @Override\n    public boolean canReadEntryData(ArchiveEntry ae) {\n        if (ae instanceof ZipArchiveEntry) {\n            ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n            return ZipUtil.canHandleEntryData(ze)\n                && supportsDataDescriptorFor(ze);\n\n        }\n        return false;\n    }\n\n    @Override\n    public int read(byte[] buffer, int offset, int length) throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n\n        if (current == null) {\n            return -1;\n        }\n\n        \n        if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n        \n        ZipUtil.checkRequestedFeatures(current.entry);\n        if (!supportsDataDescriptorFor(current.entry)) {\n            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR,\n                    current.entry);\n        }\n\n        int read;\n        if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n            read = readStored(buffer, offset, length);\n        } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n            read = readDeflated(buffer, offset, length);\n        } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()\n                || current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n            read = current.in.read(buffer, offset, length);\n        } else {\n            throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()),\n                    current.entry);\n        }\n        \n        if (read >= 0) {\n            current.crc.update(buffer, offset, read);\n        }\n        \n        return read;\n    }\n\n    \n    private int readStored(byte[] buffer, int offset, int length) throws IOException {\n\n        if (current.hasDataDescriptor) {\n            if (lastStoredEntry == null) {\n                readStoredEntry();\n            }\n            return lastStoredEntry.read(buffer, offset, length);\n        }\n\n        long csize = current.entry.getSize();\n        if (current.bytesRead >= csize) {\n            return -1;\n        }\n\n        if (buf.position() >= buf.limit()) {\n            buf.position(0);\n            int l = in.read(buf.array());\n            if (l == -1) {\n                return -1;\n            }\n            buf.limit(l);\n\n            count(buf.limit());\n            current.bytesReadFromStream += buf.limit();\n        }\n\n        int toRead = Math.min(buf.remaining(), length);\n        if ((csize - current.bytesRead) < toRead) {\n            \n            toRead = (int) (csize - current.bytesRead);\n        }\n        buf.get(buffer, offset, toRead);\n        current.bytesRead += toRead;\n        return toRead;\n    }\n\n    \n    private int readDeflated(byte[] buffer, int offset, int length) throws IOException {\n        int read = readFromInflater(buffer, offset, length);\n        if (read <= 0) {\n            if (inf.finished()) {\n                return -1;\n            } else if (inf.needsDictionary()) {\n                throw new ZipException(\"This archive needs a preset dictionary\"\n                                       + \" which is not supported by Commons\"\n                                       + \" Compress.\");\n            } else if (read == -1) {\n                throw new IOException(\"Truncated ZIP file\");\n            }\n        }\n        return read;\n    }\n\n    \n    private int readFromInflater(byte[] buffer, int offset, int length) throws IOException {\n        int read = 0;\n        do {\n            if (inf.needsInput()) {\n                int l = fill();\n                if (l > 0) {\n                    current.bytesReadFromStream += buf.limit();\n                } else if (l == -1) {\n                    return -1;\n                } else {\n                    break;\n                }\n            }\n            try {\n                read = inf.inflate(buffer, offset, length);\n            } catch (DataFormatException e) {\n                throw (IOException) new ZipException(e.getMessage()).initCause(e);\n            }\n        } while (read == 0 && inf.needsInput());\n        return read;\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (!closed) {\n            closed = true;\n            in.close();\n            inf.end();\n        }\n    }\n\n    \n    @Override\n    public long skip(long value) throws IOException {\n        if (value >= 0) {\n            long skipped = 0;\n            while (skipped < value) {\n                long rem = value - skipped;\n                int x = read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));\n                if (x == -1) {\n                    return skipped;\n                }\n                skipped += x;\n            }\n            return skipped;\n        }\n        throw new IllegalArgumentException();\n    }\n\n    \n    public static boolean matches(byte[] signature, int length) {\n        if (length < ZipArchiveOutputStream.LFH_SIG.length) {\n            return false;\n        }\n\n        return checksig(signature, ZipArchiveOutputStream.LFH_SIG) \n            || checksig(signature, ZipArchiveOutputStream.EOCD_SIG) \n            || checksig(signature, ZipArchiveOutputStream.DD_SIG) \n            || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());\n    }\n\n    private static boolean checksig(byte[] signature, byte[] expected) {\n        for (int i = 0; i < expected.length; i++) {\n            if (signature[i] != expected[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    private void closeEntry() throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        if (current == null) {\n            return;\n        }\n\n        \n        if (current.bytesReadFromStream <= current.entry.getCompressedSize()\n                && !current.hasDataDescriptor) {\n            drainCurrentEntryData();\n        } else {\n            skip(Long.MAX_VALUE);\n\n            long inB = current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED\n                       ? getBytesInflated() : current.bytesRead;\n\n            \n            \n            int diff = (int) (current.bytesReadFromStream - inB);\n\n            \n            if (diff > 0) {\n                pushback(buf.array(), buf.limit() - diff, diff);\n            }\n        }\n\n        if (lastStoredEntry == null && current.hasDataDescriptor) {\n            readDataDescriptor();\n        }\n\n        inf.reset();\n        buf.clear().flip();\n        current = null;\n        lastStoredEntry = null;\n    }\n\n    \n    private void drainCurrentEntryData() throws IOException {\n        long remaining = current.entry.getCompressedSize() - current.bytesReadFromStream;\n        while (remaining > 0) {\n            long n = in.read(buf.array(), 0, (int) Math.min(buf.capacity(), remaining));\n            if (n < 0) {\n                throw new EOFException(\"Truncated ZIP entry: \" + current.entry.getName());\n            } else {\n                count(n);\n                remaining -= n;\n            }\n        }\n    }\n\n    \n    private long getBytesInflated() {\n        long inB = inf.getBytesRead();\n        if (current.bytesReadFromStream >= TWO_EXP_32) {\n            while (inB + TWO_EXP_32 <= current.bytesReadFromStream) {\n                inB += TWO_EXP_32;\n            }\n        }\n        return inB;\n    }\n\n    private int fill() throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        int length = in.read(buf.array());\n        if (length > 0) {\n            buf.limit(length);\n            count(buf.limit());\n            inf.setInput(buf.array(), 0, buf.limit());\n        }\n        return length;\n    }\n\n    private void readFully(byte[] b) throws IOException {\n        int count = IOUtils.readFully(in, b);\n        count(count);\n        if (count < b.length) {\n            throw new EOFException();\n        }\n    }\n\n    private void readDataDescriptor() throws IOException {\n        readFully(WORD_BUF);\n        ZipLong val = new ZipLong(WORD_BUF);\n        if (ZipLong.DD_SIG.equals(val)) {\n            \n            readFully(WORD_BUF);\n            val = new ZipLong(WORD_BUF);\n        }\n        current.entry.setCrc(val.getValue());\n\n        \n        \n        \n        \n        \n\n        \n        \n        \n        \n        \n        readFully(TWO_DWORD_BUF);\n        ZipLong potentialSig = new ZipLong(TWO_DWORD_BUF, DWORD);\n        if (potentialSig.equals(ZipLong.CFH_SIG) || potentialSig.equals(ZipLong.LFH_SIG)) {\n            pushback(TWO_DWORD_BUF, DWORD, DWORD);\n            current.entry.setCompressedSize(ZipLong.getValue(TWO_DWORD_BUF));\n            current.entry.setSize(ZipLong.getValue(TWO_DWORD_BUF, WORD));\n        } else {\n            current.entry.setCompressedSize(ZipEightByteInteger.getLongValue(TWO_DWORD_BUF));\n            current.entry.setSize(ZipEightByteInteger.getLongValue(TWO_DWORD_BUF, DWORD));\n        }\n    }\n\n    \n    private boolean supportsDataDescriptorFor(ZipArchiveEntry entry) {\n        return !entry.getGeneralPurposeBit().usesDataDescriptor()\n\n                || (allowStoredEntriesWithDataDescriptor && entry.getMethod() == ZipEntry.STORED)\n                || entry.getMethod() == ZipEntry.DEFLATED;\n    }\n\n    \n    private void readStoredEntry() throws IOException {\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        int off = 0;\n        boolean done = false;\n\n        \n        int ddLen = current.usesZip64 ? WORD + 2 * DWORD : 3 * WORD;\n\n        while (!done) {\n            int r = in.read(buf.array(), off, ZipArchiveOutputStream.BUFFER_SIZE - off);\n            if (r <= 0) {\n                \n                \n                throw new IOException(\"Truncated ZIP file\");\n            }\n            if (r + off < 4) {\n                \n                off += r;\n                continue;\n            }\n\n            done = bufferContainsSignature(bos, off, r, ddLen);\n            if (!done) {\n                off = cacheBytesRead(bos, off, r, ddLen);\n            }\n        }\n\n        byte[] b = bos.toByteArray();\n        lastStoredEntry = new ByteArrayInputStream(b);\n    }\n\n    private static final byte[] LFH = ZipLong.LFH_SIG.getBytes(); private static final byte[] CFH = ZipLong.CFH_SIG.getBytes(); private static final byte[] DD = ZipLong.DD_SIG.getBytes(); private boolean bufferContainsSignature(ByteArrayOutputStream bos, int offset, int lastRead, int expectedDDLen) throws IOException {\n\n        boolean done = false;\n        int readTooMuch = 0;\n        for (int i = 0; !done && i < lastRead - 4; i++) {\n            if (buf.array()[i] == LFH[0] && buf.array()[i + 1] == LFH[1]) {\n                if ((buf.array()[i + 2] == LFH[2] && buf.array()[i + 3] == LFH[3])\n                    || (buf.array()[i] == CFH[2] && buf.array()[i + 3] == CFH[3])) {\n                    \n                    readTooMuch = offset + lastRead - i - expectedDDLen;\n                    done = true;\n                }\n                else if (buf.array()[i + 2] == DD[2] && buf.array()[i + 3] == DD[3]) {\n                    \n                    readTooMuch = offset + lastRead - i;\n                    done = true;\n                }\n                if (done) {\n                    \n                    \n                    \n                    \n                    pushback(buf.array(), offset + lastRead - readTooMuch, readTooMuch);\n                    bos.write(buf.array(), 0, i);\n                    readDataDescriptor();\n                }\n            }\n        }\n        return done;\n    }\n\n    \n    private int cacheBytesRead(ByteArrayOutputStream bos, int offset, int lastRead, int expecteDDLen) {\n        final int cacheable = offset + lastRead - expecteDDLen - 3;\n        if (cacheable > 0) {\n            bos.write(buf.array(), 0, cacheable);\n            System.arraycopy(buf.array(), cacheable, buf.array(), 0, expecteDDLen + 3);\n            offset = expecteDDLen + 3;\n        } else {\n            offset += lastRead;\n        }\n        return offset;\n    }\n\n    private void pushback(byte[] buf, int offset, int length) throws IOException {\n        ((PushbackInputStream) in).unread(buf, offset, length);\n        pushedBackBytes(length);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    private void skipRemainderOfArchive() throws IOException {\n        \n        \n        \n        realSkip(entriesRead * CFH_LEN - LFH_LEN);\n        findEocdRecord();\n        realSkip(ZipFile.MIN_EOCD_SIZE - WORD  - SHORT );\n        readFully(SHORT_BUF);\n        \n        realSkip(ZipShort.getValue(SHORT_BUF));\n    }\n\n    \n    private void findEocdRecord() throws IOException {\n        int currentByte = -1;\n        boolean skipReadCall = false;\n        while (skipReadCall || (currentByte = readOneByte()) > -1) {\n            skipReadCall = false;\n            if (!isFirstByteOfEocdSig(currentByte)) {\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[1]) {\n                if (currentByte == -1) {\n                    break;\n                }\n                skipReadCall = isFirstByteOfEocdSig(currentByte);\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[2]) {\n                if (currentByte == -1) {\n                    break;\n                }\n                skipReadCall = isFirstByteOfEocdSig(currentByte);\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte == -1\n                || currentByte == ZipArchiveOutputStream.EOCD_SIG[3]) {\n                break;\n            }\n            skipReadCall = isFirstByteOfEocdSig(currentByte);\n        }\n    }\n\n    \n    private void realSkip(long value) throws IOException {\n        if (value >= 0) {\n            long skipped = 0;\n            while (skipped < value) {\n                long rem = value - skipped;\n                int x = in.read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));\n                if (x == -1) {\n                    return;\n                }\n                count(x);\n                skipped += x;\n            }\n            return;\n        }\n        throw new IllegalArgumentException();\n    }\n\n    \n    private int readOneByte() throws IOException {\n        int b = in.read();\n        if (b != -1) {\n            count(1);\n        }\n        return b;\n    }\n\n    private boolean isFirstByteOfEocdSig(int b) {\n        return b == ZipArchiveOutputStream.EOCD_SIG[0];\n    }\n\n    \n    private static final class CurrentEntry { private final ZipArchiveEntry entry = new ZipArchiveEntry(); private boolean hasDataDescriptor; private boolean usesZip64; private long bytesRead; private long bytesReadFromStream; private final CRC32 crc = new CRC32(); private InputStream in; } private class BoundedInputStream extends InputStream {\n\n        \n        private final InputStream in; private final long max; private long pos = 0; public BoundedInputStream(final InputStream in, final long size) {\n            this.max = size;\n            this.in = in;\n        }\n\n        @Override\n        public int read() throws IOException {\n            if (max >= 0 && pos >= max) {\n                return -1;\n            }\n            final int result = in.read();\n            pos++;\n            count(1);\n            current.bytesReadFromStream++;\n            return result;\n        }\n\n        @Override\n        public int read(final byte[] b) throws IOException {\n            return this.read(b, 0, b.length);\n        }\n\n        @Override\n        public int read(final byte[] b, final int off, final int len) throws IOException {\n            if (max >= 0 && pos >= max) {\n                return -1;\n            }\n            final long maxRead = max >= 0 ? Math.min(len, max - pos) : len;\n            final int bytesRead = in.read(b, off, (int) maxRead);\n\n            if (bytesRead == -1) {\n                return -1;\n            }\n\n            pos += bytesRead;\n            count(bytesRead);\n            current.bytesReadFromStream += bytesRead;\n            return bytesRead;\n        }\n\n        @Override\n        public long skip(final long n) throws IOException {\n            final long toSkip = max >= 0 ? Math.min(n, max - pos) : n;\n            final long skippedBytes = in.skip(toSkip);\n            pos += skippedBytes;\n            return skippedBytes;\n        }\n    \n        @Override\n        public int available() throws IOException {\n            if (max >= 0 && pos >= max) {\n                return 0;\n            }\n            return in.available();\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public ZipArchiveInputStream(InputStream inputStream, String encoding)",
        "public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields)",
        "public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor)",
        "public ZipArchiveEntry getNextZipEntry() throws IOException",
        "private void readFirstLocalFileHeader(byte[] lfh) throws IOException",
        "private void processZip64Extra(ZipLong size, ZipLong cSize)",
        "public ArchiveEntry getNextEntry() throws IOException",
        "public boolean canReadEntryData(ArchiveEntry ae)",
        "public int read(byte[] buffer, int offset, int length) throws IOException",
        "private int readStored(byte[] buffer, int offset, int length) throws IOException",
        "private int readDeflated(byte[] buffer, int offset, int length) throws IOException",
        "private int readFromInflater(byte[] buffer, int offset, int length) throws IOException",
        "public void close() throws IOException",
        "public long skip(long value) throws IOException",
        "public static boolean matches(byte[] signature, int length)",
        "private static boolean checksig(byte[] signature, byte[] expected)",
        "private void closeEntry() throws IOException",
        "private void drainCurrentEntryData() throws IOException",
        "private long getBytesInflated()",
        "private int fill() throws IOException",
        "private void readFully(byte[] b) throws IOException",
        "private void readDataDescriptor() throws IOException",
        "private boolean supportsDataDescriptorFor(ZipArchiveEntry entry)",
        "private void readStoredEntry() throws IOException",
        "private int cacheBytesRead(ByteArrayOutputStream bos, int offset, int lastRead, int expecteDDLen)",
        "private void pushback(byte[] buf, int offset, int length) throws IOException",
        "private void skipRemainderOfArchive() throws IOException",
        "private void findEocdRecord() throws IOException",
        "private void realSkip(long value) throws IOException",
        "private int readOneByte() throws IOException",
        "private boolean isFirstByteOfEocdSig(int b)",
        "public int read() throws IOException",
        "public int read(final byte[] b) throws IOException",
        "public int read(final byte[] b, final int off, final int len) throws IOException",
        "public long skip(final long n) throws IOException",
        "public int available() throws IOException"
      ],
      "fixed_signatures": [
        "public ZipArchiveInputStream(InputStream inputStream, String encoding)",
        "public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields)",
        "public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor)",
        "public ZipArchiveEntry getNextZipEntry() throws IOException",
        "private void readFirstLocalFileHeader(byte[] lfh) throws IOException",
        "private void processZip64Extra(ZipLong size, ZipLong cSize)",
        "public ArchiveEntry getNextEntry() throws IOException",
        "public boolean canReadEntryData(ArchiveEntry ae)",
        "public int read(byte[] buffer, int offset, int length) throws IOException",
        "private int readStored(byte[] buffer, int offset, int length) throws IOException",
        "private int readDeflated(byte[] buffer, int offset, int length) throws IOException",
        "private int readFromInflater(byte[] buffer, int offset, int length) throws IOException",
        "public void close() throws IOException",
        "public long skip(long value) throws IOException",
        "public static boolean matches(byte[] signature, int length)",
        "private static boolean checksig(byte[] signature, byte[] expected)",
        "private void closeEntry() throws IOException",
        "private void drainCurrentEntryData() throws IOException",
        "private long getBytesInflated()",
        "private int fill() throws IOException",
        "private void readFully(byte[] b) throws IOException",
        "private void readDataDescriptor() throws IOException",
        "private boolean supportsDataDescriptorFor(ZipArchiveEntry entry)",
        "private void readStoredEntry() throws IOException",
        "private int cacheBytesRead(ByteArrayOutputStream bos, int offset, int lastRead, int expecteDDLen)",
        "private void pushback(byte[] buf, int offset, int length) throws IOException",
        "private void skipRemainderOfArchive() throws IOException",
        "private void findEocdRecord() throws IOException",
        "private void realSkip(long value) throws IOException",
        "private int readOneByte() throws IOException",
        "private boolean isFirstByteOfEocdSig(int b)",
        "public int read() throws IOException",
        "public int read(final byte[] b) throws IOException",
        "public int read(final byte[] b, final int off, final int len) throws IOException",
        "public long skip(final long n) throws IOException",
        "public int available() throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  public ZipArchiveEntry getNextZipEntry() throws IOException {\n  boolean firstEntry = true;\n  if (closed || hitCentralDirectory) {\n  return null;\n  }\n  if (current != null) {\n  closeEntry();\n  firstEntry = false;\n  }\n\n  try {\n  if (firstEntry) {\n  \n  \n  \n  \n  readFirstLocalFileHeader(LFH_BUF);\n  } else {\n  readFully(LFH_BUF);\n  }\n  } catch (EOFException e) {\n  return null;\n  }\n\n  ZipLong sig = new ZipLong(LFH_BUF);\n  if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n  hitCentralDirectory = true;\n  skipRemainderOfArchive();\n  }\n  if (!sig.equals(ZipLong.LFH_SIG)) {\n  return null;\n  }\n\n  int off = WORD;\n  current = new CurrentEntry();\n\n  int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\n  off += SHORT;\n  current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n\n  final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\n  final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n  final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n  current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n  current.entry.setGeneralPurposeBit(gpFlag);\n\n  off += SHORT;\n\n  current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\n  off += SHORT;\n\n  long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\n  current.entry.setTime(time);\n  off += WORD;\n\n  ZipLong size = null, cSize = null;\n  if (!current.hasDataDescriptor) {\n  current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\n  off += WORD;\n\n  cSize = new ZipLong(LFH_BUF, off);\n  off += WORD;\n\n  size = new ZipLong(LFH_BUF, off);\n  off += WORD;\n  } else {\n  off += 3 * WORD;\n  }\n\n  int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n\n  off += SHORT;\n\n  int extraLen = ZipShort.getValue(LFH_BUF, off);\n  off += SHORT;\n\n  byte[] fileName = new byte[fileNameLen];\n  readFully(fileName);\n  current.entry.setName(entryEncoding.decode(fileName), fileName);\n\n  byte[] extraData = new byte[extraLen];\n  readFully(extraData);\n  current.entry.setExtra(extraData);\n\n  if (!hasUTF8Flag && useUnicodeExtraFields) {\n  ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n  }\n\n  processZip64Extra(size, cSize);\n\n  if (current.entry.getCompressedSize() != -1) {\n  if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n  current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n  } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n  current.in = new ExplodingInputStream(\n  current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n  current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n  new BoundedInputStream(in, current.entry.getCompressedSize()));\n  }\n  }\n  \n  entriesRead++;\n  return current.entry;\n  }",
          "fixed_method": "  public ZipArchiveEntry getNextZipEntry() throws IOException {\n  boolean firstEntry = true;\n  if (closed || hitCentralDirectory) {\n  return null;\n  }\n  if (current != null) {\n  closeEntry();\n  firstEntry = false;\n  }\n\n  try {\n  if (firstEntry) {\n  \n  \n  \n  \n  readFirstLocalFileHeader(LFH_BUF);\n  } else {\n  readFully(LFH_BUF);\n  }\n  } catch (EOFException e) {\n  return null;\n  }\n\n  ZipLong sig = new ZipLong(LFH_BUF);\n  if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n  hitCentralDirectory = true;\n  skipRemainderOfArchive();\n  }\n  if (!sig.equals(ZipLong.LFH_SIG)) {\n  return null;\n  }\n\n  int off = WORD;\n  current = new CurrentEntry();\n\n  int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\n  off += SHORT;\n  current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n\n  final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\n  final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n  final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n  current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n  current.entry.setGeneralPurposeBit(gpFlag);\n\n  off += SHORT;\n\n  current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\n  off += SHORT;\n\n  long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\n  current.entry.setTime(time);\n  off += WORD;\n\n  ZipLong size = null, cSize = null;\n  if (!current.hasDataDescriptor) {\n  current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\n  off += WORD;\n\n  cSize = new ZipLong(LFH_BUF, off);\n  off += WORD;\n\n  size = new ZipLong(LFH_BUF, off);\n  off += WORD;\n  } else {\n  off += 3 * WORD;\n  }\n\n  int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n\n  off += SHORT;\n\n  int extraLen = ZipShort.getValue(LFH_BUF, off);\n  off += SHORT;\n\n  byte[] fileName = new byte[fileNameLen];\n  readFully(fileName);\n  current.entry.setName(entryEncoding.decode(fileName), fileName);\n\n  byte[] extraData = new byte[extraLen];\n  readFully(extraData);\n  current.entry.setExtra(extraData);\n\n  if (!hasUTF8Flag && useUnicodeExtraFields) {\n  ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n  }\n\n  processZip64Extra(size, cSize);\n\n  if (current.entry.getCompressedSize() != -1) {\n  if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n  current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n  } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n  current.in = new ExplodingInputStream(\n  current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n  current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n  new BoundedInputStream(in, current.entry.getCompressedSize()));\n  }\n  }\n  \n  entriesRead++;\n  return current.entry;\n  }",
          "diff": [
            "@@ -181,6 +181,7 @@",
            "         this.allowStoredEntriesWithDataDescriptor =\n",
            "             allowStoredEntriesWithDataDescriptor;\n",
            "         // haven't read anything so far\n",
            "+        buf.limit(0);\n",
            "     }\n",
            " \n",
            "     public ZipArchiveEntry getNextZipEntry() throws IOException {\n"
          ],
          "changed_lines": 1
        }
      ]
    }
  ]
}
