{
  "bug_id": "86",
  "failed_tests": {
    "org.apache.commons.math.linear.CholeskyDecompositionImplTest": [
      {
        "methodName": "testMath274",
        "error": "junit.framework.AssertionFailedError",
        "message": "Expected exception: org.apache.commons.math.linear.NotPositiveDefiniteMatrixException",
        "fail_line": "",
        "test_source": "  public void testMath274() throws MathException {\n  new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(new double[][] {\n  { 0.40434286, -0.09376327, 0.30328980, 0.04909388 },\n  {-0.09376327,  0.10400408, 0.07137959, 0.04762857 },\n  { 0.30328980,  0.07137959, 0.30458776, 0.04882449 },\n  { 0.04909388,  0.04762857, 0.04882449, 0.07543265 }\n  \n  }));\n  }",
        "stack": [
          ""
        ]
      },
      {
        "methodName": "testNotPositiveDefinite",
        "error": "junit.framework.AssertionFailedError",
        "message": "Expected exception: org.apache.commons.math.linear.NotPositiveDefiniteMatrixException",
        "fail_line": "",
        "test_source": "  public void testNotPositiveDefinite() throws MathException {\n  CholeskyDecomposition cd = new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(new double[][] {\n  { 14, 11, 13, 15, 24 },\n  { 11, 34, 13, 8,  25 },\n  { 13, 13, 14, 15, 21 },\n  { 15, 8,  15, 18, 23 },\n  { 24, 25, 21, 23, 45 }\n  }));\n  System.out.println(cd.getL().multiply(cd.getLT()));\n  }",
        "stack": [
          ""
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/linear/CholeskyDecompositionImpl.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.linear;\n\nimport org.apache.commons.math.MathRuntimeException;\n\n\n\npublic class CholeskyDecompositionImpl implements CholeskyDecomposition { public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0e-15; public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0e-10; private double[][] lTData; private RealMatrix cachedL; private RealMatrix cachedLT; public CholeskyDecompositionImpl(final RealMatrix matrix) throws NonSquareMatrixException, NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n        this(matrix, DEFAULT_RELATIVE_SYMMETRY_THRESHOLD,\n             DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);\n    }\n\n    \n    public CholeskyDecompositionImpl(final RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws NonSquareMatrixException, NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                               matrix.getColumnDimension());\n        }\n\n        final int order = matrix.getRowDimension();\n        lTData   = matrix.getData();\n        cachedL  = null;\n        cachedLT = null;\n\n        \n        for (int i = 0; i < order; ++i) {\n\n            final double[] lI = lTData[i];\n\n            if (lTData[i][i] < absolutePositivityThreshold) {\n                throw new NotPositiveDefiniteMatrixException();\n            }\n            \n            for (int j = i + 1; j < order; ++j) {\n                final double[] lJ = lTData[j];\n                final double lIJ = lI[j];\n                final double lJI = lJ[i];\n                final double maxDelta =\n                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n                if (Math.abs(lIJ - lJI) > maxDelta) {\n                    throw new NotSymmetricMatrixException();\n                }\n                lJ[i] = 0;\n           }\n        }\n\n        \n        for (int i = 0; i < order; ++i) {\n\n            final double[] ltI = lTData[i];\n\n            \n\n            ltI[i] = Math.sqrt(ltI[i]);\n            final double inverse = 1.0 / ltI[i];\n\n            for (int q = order - 1; q > i; --q) {\n                ltI[q] *= inverse;\n                final double[] ltQ = lTData[q];\n                for (int p = q; p < order; ++p) {\n                    ltQ[p] -= ltI[q] * ltI[p];\n                }\n            }\n\n        }\n\n    }\n\n    \n    public RealMatrix getL() {\n        if (cachedL == null) {\n            cachedL = getLT().transpose();\n        }\n        return cachedL;\n    }\n\n    \n    public RealMatrix getLT() {\n\n        if (cachedLT == null) {\n            cachedLT = MatrixUtils.createRealMatrix(lTData);\n        }\n\n        \n        return cachedLT;\n\n    }\n\n    \n    public double getDeterminant() {\n        double determinant = 1.0;\n        for (int i = 0; i < lTData.length; ++i) {\n            double lTii = lTData[i][i];\n            determinant *= lTii * lTii;\n        }\n        return determinant;\n    }\n\n    \n    public DecompositionSolver getSolver() {\n        return new Solver(lTData);\n    }\n\n    \n    private static class Solver implements DecompositionSolver { private final double[][] lTData; private Solver(final double[][] lTData) {\n            this.lTData = lTData;\n        }\n\n        \n        public boolean isNonSingular() {\n            \n            return true;\n        }\n\n        \n        public double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {\n\n            final int m = lTData.length;\n            if (b.length != m) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"vector length mismatch: got {0} but expected {1}\",\n                        b.length, m);\n            }\n\n            final double[] x = b.clone();\n\n            \n            for (int j = 0; j < m; j++) {\n                final double[] lJ = lTData[j];\n                x[j] /= lJ[j];\n                final double xJ = x[j];\n                for (int i = j + 1; i < m; i++) {\n                    x[i] -= xJ * lJ[i];\n                }\n            }\n\n            \n            for (int j = m - 1; j >= 0; j--) {\n                x[j] /= lTData[j][j];\n                final double xJ = x[j];\n                for (int i = 0; i < j; i++) {\n                    x[i] -= xJ * lTData[i][j];\n                }\n            }\n\n            return x;\n\n        }\n\n        \n        public RealVector solve(RealVector b) throws IllegalArgumentException, InvalidMatrixException {\n            try {\n                return solve((RealVectorImpl) b);\n            } catch (ClassCastException cce) {\n\n                final int m = lTData.length;\n                if (b.getDimension() != m) {\n                    throw MathRuntimeException.createIllegalArgumentException(\n                            \"vector length mismatch: got {0} but expected {1}\",\n                            b.getDimension(), m);\n                }\n\n                final double[] x = b.getData();\n\n                \n                for (int j = 0; j < m; j++) {\n                    final double[] lJ = lTData[j];\n                    x[j] /= lJ[j];\n                    final double xJ = x[j];\n                    for (int i = j + 1; i < m; i++) {\n                        x[i] -= xJ * lJ[i];\n                    }\n                }\n\n                \n                for (int j = m - 1; j >= 0; j--) {\n                    x[j] /= lTData[j][j];\n                    final double xJ = x[j];\n                    for (int i = 0; i < j; i++) {\n                        x[i] -= xJ * lTData[i][j];\n                    }\n                }\n\n                return new RealVectorImpl(x, false);\n\n            }\n        }\n\n        \n        public RealVectorImpl solve(RealVectorImpl b) throws IllegalArgumentException, InvalidMatrixException {\n            return new RealVectorImpl(solve(b.getDataRef()), false);\n        }\n\n        \n        public RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException {\n\n            final int m = lTData.length;\n            if (b.getRowDimension() != m) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n                        b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n            }\n\n            final int nColB = b.getColumnDimension();\n            double[][] x = b.getData();\n\n            \n            for (int j = 0; j < m; j++) {\n                final double[] lJ = lTData[j];\n                final double lJJ = lJ[j];\n                final double[] xJ = x[j];\n                for (int k = 0; k < nColB; ++k) {\n                    xJ[k] /= lJJ;\n                }\n                for (int i = j + 1; i < m; i++) {\n                    final double[] xI = x[i];\n                    final double lJI = lJ[i];\n                    for (int k = 0; k < nColB; ++k) {\n                        xI[k] -= xJ[k] * lJI;\n                    }\n                }\n            }\n\n            \n            for (int j = m - 1; j >= 0; j--) {\n                final double lJJ = lTData[j][j];\n                final double[] xJ = x[j];\n                for (int k = 0; k < nColB; ++k) {\n                    xJ[k] /= lJJ;\n                }\n                for (int i = 0; i < j; i++) {\n                    final double[] xI = x[i];\n                    final double lIJ = lTData[i][j];\n                    for (int k = 0; k < nColB; ++k) {\n                        xI[k] -= xJ[k] * lIJ;\n                    }\n                }\n            }\n\n            return new RealMatrixImpl(x, false);\n\n        }\n\n        \n        public RealMatrix getInverse() throws InvalidMatrixException {\n            return solve(MatrixUtils.createRealIdentityMatrix(lTData.length));\n        }\n\n    }\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.linear;\n\nimport org.apache.commons.math.MathRuntimeException;\n\n\n\npublic class CholeskyDecompositionImpl implements CholeskyDecomposition { public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0e-15; public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0e-10; private double[][] lTData; private RealMatrix cachedL; private RealMatrix cachedLT; public CholeskyDecompositionImpl(final RealMatrix matrix) throws NonSquareMatrixException, NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n        this(matrix, DEFAULT_RELATIVE_SYMMETRY_THRESHOLD,\n             DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);\n    }\n\n    \n    public CholeskyDecompositionImpl(final RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws NonSquareMatrixException, NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                               matrix.getColumnDimension());\n        }\n\n        final int order = matrix.getRowDimension();\n        lTData   = matrix.getData();\n        cachedL  = null;\n        cachedLT = null;\n\n        \n        for (int i = 0; i < order; ++i) {\n\n            final double[] lI = lTData[i];\n\n            \n            for (int j = i + 1; j < order; ++j) {\n                final double[] lJ = lTData[j];\n                final double lIJ = lI[j];\n                final double lJI = lJ[i];\n                final double maxDelta =\n                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n                if (Math.abs(lIJ - lJI) > maxDelta) {\n                    throw new NotSymmetricMatrixException();\n                }\n                lJ[i] = 0;\n           }\n        }\n\n        \n        for (int i = 0; i < order; ++i) {\n\n            final double[] ltI = lTData[i];\n\n            \n            if (ltI[i] < absolutePositivityThreshold) {\n                throw new NotPositiveDefiniteMatrixException();\n            }\n\n            ltI[i] = Math.sqrt(ltI[i]);\n            final double inverse = 1.0 / ltI[i];\n\n            for (int q = order - 1; q > i; --q) {\n                ltI[q] *= inverse;\n                final double[] ltQ = lTData[q];\n                for (int p = q; p < order; ++p) {\n                    ltQ[p] -= ltI[q] * ltI[p];\n                }\n            }\n\n        }\n\n    }\n\n    \n    public RealMatrix getL() {\n        if (cachedL == null) {\n            cachedL = getLT().transpose();\n        }\n        return cachedL;\n    }\n\n    \n    public RealMatrix getLT() {\n\n        if (cachedLT == null) {\n            cachedLT = MatrixUtils.createRealMatrix(lTData);\n        }\n\n        \n        return cachedLT;\n\n    }\n\n    \n    public double getDeterminant() {\n        double determinant = 1.0;\n        for (int i = 0; i < lTData.length; ++i) {\n            double lTii = lTData[i][i];\n            determinant *= lTii * lTii;\n        }\n        return determinant;\n    }\n\n    \n    public DecompositionSolver getSolver() {\n        return new Solver(lTData);\n    }\n\n    \n    private static class Solver implements DecompositionSolver { private final double[][] lTData; private Solver(final double[][] lTData) {\n            this.lTData = lTData;\n        }\n\n        \n        public boolean isNonSingular() {\n            \n            return true;\n        }\n\n        \n        public double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {\n\n            final int m = lTData.length;\n            if (b.length != m) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"vector length mismatch: got {0} but expected {1}\",\n                        b.length, m);\n            }\n\n            final double[] x = b.clone();\n\n            \n            for (int j = 0; j < m; j++) {\n                final double[] lJ = lTData[j];\n                x[j] /= lJ[j];\n                final double xJ = x[j];\n                for (int i = j + 1; i < m; i++) {\n                    x[i] -= xJ * lJ[i];\n                }\n            }\n\n            \n            for (int j = m - 1; j >= 0; j--) {\n                x[j] /= lTData[j][j];\n                final double xJ = x[j];\n                for (int i = 0; i < j; i++) {\n                    x[i] -= xJ * lTData[i][j];\n                }\n            }\n\n            return x;\n\n        }\n\n        \n        public RealVector solve(RealVector b) throws IllegalArgumentException, InvalidMatrixException {\n            try {\n                return solve((RealVectorImpl) b);\n            } catch (ClassCastException cce) {\n\n                final int m = lTData.length;\n                if (b.getDimension() != m) {\n                    throw MathRuntimeException.createIllegalArgumentException(\n                            \"vector length mismatch: got {0} but expected {1}\",\n                            b.getDimension(), m);\n                }\n\n                final double[] x = b.getData();\n\n                \n                for (int j = 0; j < m; j++) {\n                    final double[] lJ = lTData[j];\n                    x[j] /= lJ[j];\n                    final double xJ = x[j];\n                    for (int i = j + 1; i < m; i++) {\n                        x[i] -= xJ * lJ[i];\n                    }\n                }\n\n                \n                for (int j = m - 1; j >= 0; j--) {\n                    x[j] /= lTData[j][j];\n                    final double xJ = x[j];\n                    for (int i = 0; i < j; i++) {\n                        x[i] -= xJ * lTData[i][j];\n                    }\n                }\n\n                return new RealVectorImpl(x, false);\n\n            }\n        }\n\n        \n        public RealVectorImpl solve(RealVectorImpl b) throws IllegalArgumentException, InvalidMatrixException {\n            return new RealVectorImpl(solve(b.getDataRef()), false);\n        }\n\n        \n        public RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException {\n\n            final int m = lTData.length;\n            if (b.getRowDimension() != m) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n                        b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n            }\n\n            final int nColB = b.getColumnDimension();\n            double[][] x = b.getData();\n\n            \n            for (int j = 0; j < m; j++) {\n                final double[] lJ = lTData[j];\n                final double lJJ = lJ[j];\n                final double[] xJ = x[j];\n                for (int k = 0; k < nColB; ++k) {\n                    xJ[k] /= lJJ;\n                }\n                for (int i = j + 1; i < m; i++) {\n                    final double[] xI = x[i];\n                    final double lJI = lJ[i];\n                    for (int k = 0; k < nColB; ++k) {\n                        xI[k] -= xJ[k] * lJI;\n                    }\n                }\n            }\n\n            \n            for (int j = m - 1; j >= 0; j--) {\n                final double lJJ = lTData[j][j];\n                final double[] xJ = x[j];\n                for (int k = 0; k < nColB; ++k) {\n                    xJ[k] /= lJJ;\n                }\n                for (int i = 0; i < j; i++) {\n                    final double[] xI = x[i];\n                    final double lIJ = lTData[i][j];\n                    for (int k = 0; k < nColB; ++k) {\n                        xI[k] -= xJ[k] * lIJ;\n                    }\n                }\n            }\n\n            return new RealMatrixImpl(x, false);\n\n        }\n\n        \n        public RealMatrix getInverse() throws InvalidMatrixException {\n            return solve(MatrixUtils.createRealIdentityMatrix(lTData.length));\n        }\n\n    }\n\n}\n",
      "buggy_signatures": [
        "public CholeskyDecompositionImpl(final RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws NonSquareMatrixException, NotSymmetricMatrixException, NotPositiveDefiniteMatrixException",
        "public RealMatrix getL()",
        "public RealMatrix getLT()",
        "public double getDeterminant()",
        "public DecompositionSolver getSolver()",
        "private static class Solver implements DecompositionSolver { private final double[][] lTData; private Solver(final double[][] lTData)",
        "public boolean isNonSingular()",
        "public double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException",
        "public RealVector solve(RealVector b) throws IllegalArgumentException, InvalidMatrixException",
        "public RealVectorImpl solve(RealVectorImpl b) throws IllegalArgumentException, InvalidMatrixException",
        "public RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException",
        "public RealMatrix getInverse() throws InvalidMatrixException"
      ],
      "fixed_signatures": [
        "public CholeskyDecompositionImpl(final RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws NonSquareMatrixException, NotSymmetricMatrixException, NotPositiveDefiniteMatrixException",
        "public RealMatrix getL()",
        "public RealMatrix getLT()",
        "public double getDeterminant()",
        "public DecompositionSolver getSolver()",
        "private static class Solver implements DecompositionSolver { private final double[][] lTData; private Solver(final double[][] lTData)",
        "public boolean isNonSingular()",
        "public double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException",
        "public RealVector solve(RealVector b) throws IllegalArgumentException, InvalidMatrixException",
        "public RealVectorImpl solve(RealVectorImpl b) throws IllegalArgumentException, InvalidMatrixException",
        "public RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException",
        "public RealMatrix getInverse() throws InvalidMatrixException"
      ],
      "methods": [
        {
          "buggy_method": "  public CholeskyDecompositionImpl(final RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws NonSquareMatrixException, NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n\n  if (!matrix.isSquare()) {\n  throw new NonSquareMatrixException(matrix.getRowDimension(),\n  matrix.getColumnDimension());\n  }\n\n  final int order = matrix.getRowDimension();\n  lTData  = matrix.getData();\n  cachedL  = null;\n  cachedLT = null;\n\n  \n  for (int i = 0; i < order; ++i) {\n\n  final double[] lI = lTData[i];\n\n  if (lTData[i][i] < absolutePositivityThreshold) {\n  throw new NotPositiveDefiniteMatrixException();\n  }\n  \n  for (int j = i + 1; j < order; ++j) {\n  final double[] lJ = lTData[j];\n  final double lIJ = lI[j];\n  final double lJI = lJ[i];\n  final double maxDelta =\n  relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n  if (Math.abs(lIJ - lJI) > maxDelta) {\n  throw new NotSymmetricMatrixException();\n  }\n  lJ[i] = 0;\n  }\n  }\n\n  \n  for (int i = 0; i < order; ++i) {\n\n  final double[] ltI = lTData[i];\n\n  \n\n  ltI[i] = Math.sqrt(ltI[i]);\n  final double inverse = 1.0 / ltI[i];\n\n  for (int q = order - 1; q > i; --q) {\n  ltI[q] *= inverse;\n  final double[] ltQ = lTData[q];\n  for (int p = q; p < order; ++p) {\n  ltQ[p] -= ltI[q] * ltI[p];\n  }\n  }\n\n  }\n\n  }",
          "fixed_method": "  public CholeskyDecompositionImpl(final RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws NonSquareMatrixException, NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n\n  if (!matrix.isSquare()) {\n  throw new NonSquareMatrixException(matrix.getRowDimension(),\n  matrix.getColumnDimension());\n  }\n\n  final int order = matrix.getRowDimension();\n  lTData  = matrix.getData();\n  cachedL  = null;\n  cachedLT = null;\n\n  \n  for (int i = 0; i < order; ++i) {\n\n  final double[] lI = lTData[i];\n\n  \n  for (int j = i + 1; j < order; ++j) {\n  final double[] lJ = lTData[j];\n  final double lIJ = lI[j];\n  final double lJI = lJ[i];\n  final double maxDelta =\n  relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n  if (Math.abs(lIJ - lJI) > maxDelta) {\n  throw new NotSymmetricMatrixException();\n  }\n  lJ[i] = 0;\n  }\n  }\n\n  \n  for (int i = 0; i < order; ++i) {\n\n  final double[] ltI = lTData[i];\n\n  \n  if (ltI[i] < absolutePositivityThreshold) {\n  throw new NotPositiveDefiniteMatrixException();\n  }\n\n  ltI[i] = Math.sqrt(ltI[i]);\n  final double inverse = 1.0 / ltI[i];\n\n  for (int q = order - 1; q > i; --q) {\n  ltI[q] *= inverse;\n  final double[] ltQ = lTData[q];\n  for (int p = q; p < order; ++p) {\n  ltQ[p] -= ltI[q] * ltI[p];\n  }\n  }\n\n  }\n\n  }",
          "diff": [
            "@@ -111,9 +111,6 @@",
            " \n",
            "             final double[] lI = lTData[i];\n",
            " \n",
            "-            if (lTData[i][i] < absolutePositivityThreshold) {\n",
            "-                throw new NotPositiveDefiniteMatrixException();\n",
            "-            }\n",
            "             // check off-diagonal elements (and reset them to 0)\n",
            "             for (int j = i + 1; j < order; ++j) {\n",
            "                 final double[] lJ = lTData[j];\n",
            "@@ -134,6 +131,9 @@",
            "             final double[] ltI = lTData[i];\n",
            " \n",
            "             // check diagonal element\n",
            "+            if (ltI[i] < absolutePositivityThreshold) {\n",
            "+                throw new NotPositiveDefiniteMatrixException();\n",
            "+            }\n",
            " \n",
            "             ltI[i] = Math.sqrt(ltI[i]);\n",
            "             final double inverse = 1.0 / ltI[i];\n"
          ],
          "changed_lines": 6
        }
      ]
    }
  ]
}
