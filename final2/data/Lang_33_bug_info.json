{
  "bug_id": "33",
  "failed_tests": {
    "org.apache.commons.lang3.ClassUtilsTest": [
      {
        "methodName": "testToClass_object",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "                ClassUtils.toClass(new Object[] { \"Test\", null, 99d })));",
        "test_source": "  public void testToClass_object() {\n  assertNull(ClassUtils.toClass(null));\n\n  assertSame(ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.toClass(ArrayUtils.EMPTY_OBJECT_ARRAY));\n\n  assertTrue(Arrays.equals(new Class[] { String.class, Integer.class, Double.class },\n  ClassUtils.toClass(new Object[] { \"Test\", 1, 99d })));\n\n  assertTrue(Arrays.equals(new Class[] { String.class, null, Double.class },\n  ClassUtils.toClass(new Object[] { \"Test\", null, 99d })));\n  }",
        "stack": [
          "ClassUtils.toClass line 910, ClassUtilsTest.testToClass_object line 913"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/lang3/ClassUtils.java",
      "buggy_full_code": "\npackage org.apache.commons.lang3;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\n\n\n\npublic class ClassUtils { public static final char PACKAGE_SEPARATOR_CHAR = '.'; public static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR); public static final char INNER_CLASS_SEPARATOR_CHAR = '$'; public static final String INNER_CLASS_SEPARATOR = String.valueOf(INNER_CLASS_SEPARATOR_CHAR); private static final Map<Class<?>, Class<?>> primitiveWrapperMap = new HashMap<Class<?>, Class<?>>(); static {\n         primitiveWrapperMap.put(Boolean.TYPE, Boolean.class);\n         primitiveWrapperMap.put(Byte.TYPE, Byte.class);\n         primitiveWrapperMap.put(Character.TYPE, Character.class);\n         primitiveWrapperMap.put(Short.TYPE, Short.class);\n         primitiveWrapperMap.put(Integer.TYPE, Integer.class);\n         primitiveWrapperMap.put(Long.TYPE, Long.class);\n         primitiveWrapperMap.put(Double.TYPE, Double.class);\n         primitiveWrapperMap.put(Float.TYPE, Float.class);\n         primitiveWrapperMap.put(Void.TYPE, Void.TYPE);\n    }\n\n    \n    private static final Map<Class<?>, Class<?>> wrapperPrimitiveMap = new HashMap<Class<?>, Class<?>>(); static {\n        for (Class<?> primitiveClass : primitiveWrapperMap.keySet()) {\n            Class<?> wrapperClass = primitiveWrapperMap.get(primitiveClass);\n            if (!primitiveClass.equals(wrapperClass)) {\n                wrapperPrimitiveMap.put(wrapperClass, primitiveClass);\n            }\n        }\n    }\n\n    \n    private static final Map<String, String> abbreviationMap = new HashMap<String, String>(); private static final Map<String, String> reverseAbbreviationMap = new HashMap<String, String>(); private static void addAbbreviation(String primitive, String abbreviation) {\n        abbreviationMap.put(primitive, abbreviation);\n        reverseAbbreviationMap.put(abbreviation, primitive);\n    }\n\n    \n    static { addAbbreviation(\"int\", \"I\"); addAbbreviation(\"boolean\", \"Z\"); addAbbreviation(\"float\", \"F\"); addAbbreviation(\"long\", \"J\"); addAbbreviation(\"short\", \"S\"); addAbbreviation(\"byte\", \"B\"); addAbbreviation(\"double\", \"D\"); addAbbreviation(\"char\", \"C\"); } public ClassUtils() {\n      super();\n    }\n\n    \n    \n    \n    public static String getShortClassName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getShortClassName(object.getClass());\n    }\n\n    \n    public static String getShortClassName(Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getShortClassName(cls.getName());\n    }\n\n    \n    public static String getShortClassName(String className) {\n        if (className == null) {\n            return StringUtils.EMPTY;\n        }\n        if (className.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n\n        StringBuilder arrayPrefix = new StringBuilder();\n\n        \n        if (className.startsWith(\"[\")) {\n            while (className.charAt(0) == '[') {\n                className = className.substring(1);\n                arrayPrefix.append(\"[]\");\n            }\n            \n            if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n                className = className.substring(1, className.length() - 1);\n            }\n        }\n\n        if (reverseAbbreviationMap.containsKey(className)) {\n            className = reverseAbbreviationMap.get(className);\n        }\n\n        int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n        int innerIdx = className.indexOf(\n                INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);\n        String out = className.substring(lastDotIdx + 1);\n        if (innerIdx != -1) {\n            out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n        }\n        return out + arrayPrefix;\n    }\n\n    \n    \n    \n    public static String getPackageName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getPackageName(object.getClass());\n    }\n\n    \n    public static String getPackageName(Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getPackageName(cls.getName());\n    }\n\n    \n    public static String getPackageName(String className) {\n        if (className == null || className.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n\n        \n        while (className.charAt(0) == '[') {\n            className = className.substring(1);\n        }\n        \n        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n            className = className.substring(1);\n        }\n\n        int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n        if (i == -1) {\n            return StringUtils.EMPTY;\n        }\n        return className.substring(0, i);\n    }\n\n    \n    \n    \n    public static List<Class<?>> getAllSuperclasses(Class<?> cls) {\n        if (cls == null) {\n            return null;\n        }\n        List<Class<?>> classes = new ArrayList<Class<?>>();\n        Class<?> superclass = cls.getSuperclass();\n        while (superclass != null) {\n            classes.add(superclass);\n            superclass = superclass.getSuperclass();\n        }\n        return classes;\n    }\n\n    \n    public static List<Class<?>> getAllInterfaces(Class<?> cls) {\n        if (cls == null) {\n            return null;\n        }\n\n        LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<Class<?>>();\n        getAllInterfaces(cls, interfacesFound);\n\n        return new ArrayList<Class<?>>(interfacesFound);\n    }\n\n    \n    private static void getAllInterfaces(Class<?> cls, HashSet<Class<?>> interfacesFound) {\n        while (cls != null) {\n            Class<?>[] interfaces = cls.getInterfaces();\n\n            for (Class<?> i : interfaces) {\n                if (interfacesFound.add(i)) {\n                    getAllInterfaces(i, interfacesFound);\n                }\n            }\n\n            cls = cls.getSuperclass();\n         }\n     }\n\n    \n    \n    \n    public static List<Class<?>> convertClassNamesToClasses(List<String> classNames) {\n        if (classNames == null) {\n            return null;\n        }\n        List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size());\n        for (String className : classNames) {\n            try {\n                classes.add(Class.forName(className));\n            } catch (Exception ex) {\n                classes.add(null);\n            }\n        }\n        return classes;\n    }\n\n    \n    public static List<String> convertClassesToClassNames(List<Class<?>> classes) {\n        if (classes == null) {\n            return null;\n        }\n        List<String> classNames = new ArrayList<String>(classes.size());\n        for (Class<?> cls : classes) {\n            if (cls == null) {\n                classNames.add(null);\n            } else {\n                classNames.add(cls.getName());\n            }\n        }\n        return classNames;\n    }\n\n    \n    \n    \n    public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray) {\n        return isAssignable(classArray, toClassArray, SystemUtils.isJavaVersionAtLeast(1.5f));\n    }\n\n    \n    public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) {\n        if (ArrayUtils.isSameLength(classArray, toClassArray) == false) {\n            return false;\n        }\n        if (classArray == null) {\n            classArray = ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        if (toClassArray == null) {\n            toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        for (int i = 0; i < classArray.length; i++) {\n            if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAssignable(Class<?> cls, Class<?> toClass) {\n        return isAssignable(cls, toClass, SystemUtils.isJavaVersionAtLeast(1.5f));\n    }\n\n    \n    public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {\n        if (toClass == null) {\n            return false;\n        }\n        \n        if (cls == null) {\n            return !(toClass.isPrimitive());\n        }\n        \n        if (autoboxing) {\n            if (cls.isPrimitive() && !toClass.isPrimitive()) {\n                cls = primitiveToWrapper(cls);\n                if (cls == null) {\n                    return false;\n                }\n            }\n            if (toClass.isPrimitive() && !cls.isPrimitive()) {\n                cls = wrapperToPrimitive(cls);\n                if (cls == null) {\n                    return false;\n                }\n            }\n        }\n        if (cls.equals(toClass)) {\n            return true;\n        }\n        if (cls.isPrimitive()) {\n            if (toClass.isPrimitive() == false) {\n                return false;\n            }\n            if (Integer.TYPE.equals(cls)) {\n                return Long.TYPE.equals(toClass)\n                    || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            if (Long.TYPE.equals(cls)) {\n                return Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            if (Boolean.TYPE.equals(cls)) {\n                return false;\n            }\n            if (Double.TYPE.equals(cls)) {\n                return false;\n            }\n            if (Float.TYPE.equals(cls)) {\n                return Double.TYPE.equals(toClass);\n            }\n            if (Character.TYPE.equals(cls)) {\n                return Integer.TYPE.equals(toClass)\n                    || Long.TYPE.equals(toClass)\n                    || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            if (Short.TYPE.equals(cls)) {\n                return Integer.TYPE.equals(toClass)\n                    || Long.TYPE.equals(toClass)\n                    || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            if (Byte.TYPE.equals(cls)) {\n                return Short.TYPE.equals(toClass)\n                    || Integer.TYPE.equals(toClass)\n                    || Long.TYPE.equals(toClass)\n                    || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            \n            return false;\n        }\n        return toClass.isAssignableFrom(cls);\n    }\n\n    \n    public static Class<?> primitiveToWrapper(Class<?> cls) {\n        Class<?> convertedClass = cls;\n        if (cls != null && cls.isPrimitive()) {\n            convertedClass = primitiveWrapperMap.get(cls);\n        }\n        return convertedClass;\n    }\n\n    \n    public static Class<?>[] primitivesToWrappers(Class<?>[] classes) {\n        if (classes == null) {\n            return null;\n        }\n\n        if (classes.length == 0) {\n            return classes;\n        }\n\n        Class<?>[] convertedClasses = new Class[classes.length];\n        for (int i = 0; i < classes.length; i++) {\n            convertedClasses[i] = primitiveToWrapper(classes[i]);\n        }\n        return convertedClasses;\n    }\n\n    \n    public static Class<?> wrapperToPrimitive(Class<?> cls) {\n        return wrapperPrimitiveMap.get(cls);\n    }\n\n    \n    public static Class<?>[] wrappersToPrimitives(Class<?>[] classes) {\n        if (classes == null) {\n            return null;\n        }\n\n        if (classes.length == 0) {\n            return classes;\n        }\n\n        Class<?>[] convertedClasses = new Class[classes.length];\n        for (int i = 0; i < classes.length; i++) {\n            convertedClasses[i] = wrapperToPrimitive(classes[i]);\n        }\n        return convertedClasses;\n    }\n\n    \n    \n    \n    public static boolean isInnerClass(Class<?> cls) {\n        if (cls == null) {\n            return false;\n        }\n        return cls.getName().indexOf(INNER_CLASS_SEPARATOR_CHAR) >= 0;\n    }\n\n    \n    \n    \n    public static Class<?> getClass( ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException {\n        Class<?> clazz;\n        if (abbreviationMap.containsKey(className)) {\n            String clsName = \"[\" + abbreviationMap.get(className);\n            clazz = Class.forName(clsName, initialize, classLoader).getComponentType();\n        } else {\n            clazz = Class.forName(toCanonicalName(className), initialize, classLoader);\n        }\n        return clazz;\n    }\n\n    \n    public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException {\n        return getClass(classLoader, className, true);\n    }\n\n    \n    public static Class<?> getClass(String className) throws ClassNotFoundException {\n        return getClass(className, true);\n    }\n\n    \n    public static Class<?> getClass(String className, boolean initialize) throws ClassNotFoundException {\n        ClassLoader contextCL = Thread.currentThread().getContextClassLoader();\n        ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;\n        return getClass(loader, className, initialize );\n    }\n\n    \n    \n    \n    public static Method getPublicMethod(Class<?> cls, String methodName, Class<?> parameterTypes[]) throws SecurityException, NoSuchMethodException {\n\n        Method declaredMethod = cls.getMethod(methodName, parameterTypes);\n        if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) {\n            return declaredMethod;\n        }\n\n        List<Class<?>> candidateClasses = new ArrayList<Class<?>>();\n        candidateClasses.addAll(getAllInterfaces(cls));\n        candidateClasses.addAll(getAllSuperclasses(cls));\n\n        for (Class<?> candidateClass : candidateClasses) {\n            if (!Modifier.isPublic(candidateClass.getModifiers())) {\n                continue;\n            }\n            Method candidateMethod;\n            try {\n                candidateMethod = candidateClass.getMethod(methodName, parameterTypes);\n            } catch (NoSuchMethodException ex) {\n                continue;\n            }\n            if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) {\n                return candidateMethod;\n            }\n        }\n\n        throw new NoSuchMethodException(\"Can't find a public method for \" + methodName + \" \" + ArrayUtils.toString(parameterTypes)); } private static String toCanonicalName(String className) {\n        className = StringUtils.deleteWhitespace(className);\n        if (className == null) {\n            throw new NullPointerException(\"className must not be null.\");\n        } else if (className.endsWith(\"[]\")) {\n            StringBuilder classNameBuffer = new StringBuilder();\n            while (className.endsWith(\"[]\")) {\n                className = className.substring(0, className.length() - 2);\n                classNameBuffer.append(\"[\");\n            }\n            String abbreviation = abbreviationMap.get(className);\n            if (abbreviation != null) {\n                classNameBuffer.append(abbreviation);\n            } else {\n                classNameBuffer.append(\"L\").append(className).append(\";\");\n            }\n            className = classNameBuffer.toString();\n        }\n        return className;\n    }\n\n    \n    public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n            classes[i] = array[i].getClass();\n        }\n        return classes;\n    }\n\n    \n    \n    \n    public static String getShortCanonicalName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getShortCanonicalName(object.getClass().getName());\n    }\n\n    \n    public static String getShortCanonicalName(Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getShortCanonicalName(cls.getName());\n    }\n\n    \n    public static String getShortCanonicalName(String canonicalName) {\n        return ClassUtils.getShortClassName(getCanonicalName(canonicalName));\n    }\n\n    \n    \n    \n    public static String getPackageCanonicalName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getPackageCanonicalName(object.getClass().getName());\n    }\n\n    \n    public static String getPackageCanonicalName(Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getPackageCanonicalName(cls.getName());\n    }\n\n    \n    public static String getPackageCanonicalName(String canonicalName) {\n        return ClassUtils.getPackageName(getCanonicalName(canonicalName));\n    }\n\n    \n    private static String getCanonicalName(String className) {\n        className = StringUtils.deleteWhitespace(className);\n        if (className == null) {\n            return null;\n        } else {\n            int dim = 0;\n            while (className.startsWith(\"[\")) {\n                dim++;\n                className = className.substring(1);\n            }\n            if (dim < 1) {\n                return className;\n            } else {\n                if (className.startsWith(\"L\")) {\n                    className = className.substring(\n                        1,\n                        className.endsWith(\";\")\n                            ? className.length() - 1\n                            : className.length());\n                } else {\n                    if (className.length() > 0) {\n                        className = reverseAbbreviationMap.get(className.substring(0, 1));\n                    }\n                }\n                StringBuilder canonicalClassNameBuffer = new StringBuilder(className);\n                for (int i = 0; i < dim; i++) {\n                    canonicalClassNameBuffer.append(\"[]\");\n                }\n                return canonicalClassNameBuffer.toString();\n            }\n        }\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.lang3;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\n\n\n\npublic class ClassUtils { public static final char PACKAGE_SEPARATOR_CHAR = '.'; public static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR); public static final char INNER_CLASS_SEPARATOR_CHAR = '$'; public static final String INNER_CLASS_SEPARATOR = String.valueOf(INNER_CLASS_SEPARATOR_CHAR); private static final Map<Class<?>, Class<?>> primitiveWrapperMap = new HashMap<Class<?>, Class<?>>(); static {\n         primitiveWrapperMap.put(Boolean.TYPE, Boolean.class);\n         primitiveWrapperMap.put(Byte.TYPE, Byte.class);\n         primitiveWrapperMap.put(Character.TYPE, Character.class);\n         primitiveWrapperMap.put(Short.TYPE, Short.class);\n         primitiveWrapperMap.put(Integer.TYPE, Integer.class);\n         primitiveWrapperMap.put(Long.TYPE, Long.class);\n         primitiveWrapperMap.put(Double.TYPE, Double.class);\n         primitiveWrapperMap.put(Float.TYPE, Float.class);\n         primitiveWrapperMap.put(Void.TYPE, Void.TYPE);\n    }\n\n    \n    private static final Map<Class<?>, Class<?>> wrapperPrimitiveMap = new HashMap<Class<?>, Class<?>>(); static {\n        for (Class<?> primitiveClass : primitiveWrapperMap.keySet()) {\n            Class<?> wrapperClass = primitiveWrapperMap.get(primitiveClass);\n            if (!primitiveClass.equals(wrapperClass)) {\n                wrapperPrimitiveMap.put(wrapperClass, primitiveClass);\n            }\n        }\n    }\n\n    \n    private static final Map<String, String> abbreviationMap = new HashMap<String, String>(); private static final Map<String, String> reverseAbbreviationMap = new HashMap<String, String>(); private static void addAbbreviation(String primitive, String abbreviation) {\n        abbreviationMap.put(primitive, abbreviation);\n        reverseAbbreviationMap.put(abbreviation, primitive);\n    }\n\n    \n    static { addAbbreviation(\"int\", \"I\"); addAbbreviation(\"boolean\", \"Z\"); addAbbreviation(\"float\", \"F\"); addAbbreviation(\"long\", \"J\"); addAbbreviation(\"short\", \"S\"); addAbbreviation(\"byte\", \"B\"); addAbbreviation(\"double\", \"D\"); addAbbreviation(\"char\", \"C\"); } public ClassUtils() {\n      super();\n    }\n\n    \n    \n    \n    public static String getShortClassName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getShortClassName(object.getClass());\n    }\n\n    \n    public static String getShortClassName(Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getShortClassName(cls.getName());\n    }\n\n    \n    public static String getShortClassName(String className) {\n        if (className == null) {\n            return StringUtils.EMPTY;\n        }\n        if (className.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n\n        StringBuilder arrayPrefix = new StringBuilder();\n\n        \n        if (className.startsWith(\"[\")) {\n            while (className.charAt(0) == '[') {\n                className = className.substring(1);\n                arrayPrefix.append(\"[]\");\n            }\n            \n            if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n                className = className.substring(1, className.length() - 1);\n            }\n        }\n\n        if (reverseAbbreviationMap.containsKey(className)) {\n            className = reverseAbbreviationMap.get(className);\n        }\n\n        int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n        int innerIdx = className.indexOf(\n                INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);\n        String out = className.substring(lastDotIdx + 1);\n        if (innerIdx != -1) {\n            out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n        }\n        return out + arrayPrefix;\n    }\n\n    \n    \n    \n    public static String getPackageName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getPackageName(object.getClass());\n    }\n\n    \n    public static String getPackageName(Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getPackageName(cls.getName());\n    }\n\n    \n    public static String getPackageName(String className) {\n        if (className == null || className.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n\n        \n        while (className.charAt(0) == '[') {\n            className = className.substring(1);\n        }\n        \n        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n            className = className.substring(1);\n        }\n\n        int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n        if (i == -1) {\n            return StringUtils.EMPTY;\n        }\n        return className.substring(0, i);\n    }\n\n    \n    \n    \n    public static List<Class<?>> getAllSuperclasses(Class<?> cls) {\n        if (cls == null) {\n            return null;\n        }\n        List<Class<?>> classes = new ArrayList<Class<?>>();\n        Class<?> superclass = cls.getSuperclass();\n        while (superclass != null) {\n            classes.add(superclass);\n            superclass = superclass.getSuperclass();\n        }\n        return classes;\n    }\n\n    \n    public static List<Class<?>> getAllInterfaces(Class<?> cls) {\n        if (cls == null) {\n            return null;\n        }\n\n        LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<Class<?>>();\n        getAllInterfaces(cls, interfacesFound);\n\n        return new ArrayList<Class<?>>(interfacesFound);\n    }\n\n    \n    private static void getAllInterfaces(Class<?> cls, HashSet<Class<?>> interfacesFound) {\n        while (cls != null) {\n            Class<?>[] interfaces = cls.getInterfaces();\n\n            for (Class<?> i : interfaces) {\n                if (interfacesFound.add(i)) {\n                    getAllInterfaces(i, interfacesFound);\n                }\n            }\n\n            cls = cls.getSuperclass();\n         }\n     }\n\n    \n    \n    \n    public static List<Class<?>> convertClassNamesToClasses(List<String> classNames) {\n        if (classNames == null) {\n            return null;\n        }\n        List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size());\n        for (String className : classNames) {\n            try {\n                classes.add(Class.forName(className));\n            } catch (Exception ex) {\n                classes.add(null);\n            }\n        }\n        return classes;\n    }\n\n    \n    public static List<String> convertClassesToClassNames(List<Class<?>> classes) {\n        if (classes == null) {\n            return null;\n        }\n        List<String> classNames = new ArrayList<String>(classes.size());\n        for (Class<?> cls : classes) {\n            if (cls == null) {\n                classNames.add(null);\n            } else {\n                classNames.add(cls.getName());\n            }\n        }\n        return classNames;\n    }\n\n    \n    \n    \n    public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray) {\n        return isAssignable(classArray, toClassArray, SystemUtils.isJavaVersionAtLeast(1.5f));\n    }\n\n    \n    public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) {\n        if (ArrayUtils.isSameLength(classArray, toClassArray) == false) {\n            return false;\n        }\n        if (classArray == null) {\n            classArray = ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        if (toClassArray == null) {\n            toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        for (int i = 0; i < classArray.length; i++) {\n            if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAssignable(Class<?> cls, Class<?> toClass) {\n        return isAssignable(cls, toClass, SystemUtils.isJavaVersionAtLeast(1.5f));\n    }\n\n    \n    public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {\n        if (toClass == null) {\n            return false;\n        }\n        \n        if (cls == null) {\n            return !(toClass.isPrimitive());\n        }\n        \n        if (autoboxing) {\n            if (cls.isPrimitive() && !toClass.isPrimitive()) {\n                cls = primitiveToWrapper(cls);\n                if (cls == null) {\n                    return false;\n                }\n            }\n            if (toClass.isPrimitive() && !cls.isPrimitive()) {\n                cls = wrapperToPrimitive(cls);\n                if (cls == null) {\n                    return false;\n                }\n            }\n        }\n        if (cls.equals(toClass)) {\n            return true;\n        }\n        if (cls.isPrimitive()) {\n            if (toClass.isPrimitive() == false) {\n                return false;\n            }\n            if (Integer.TYPE.equals(cls)) {\n                return Long.TYPE.equals(toClass)\n                    || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            if (Long.TYPE.equals(cls)) {\n                return Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            if (Boolean.TYPE.equals(cls)) {\n                return false;\n            }\n            if (Double.TYPE.equals(cls)) {\n                return false;\n            }\n            if (Float.TYPE.equals(cls)) {\n                return Double.TYPE.equals(toClass);\n            }\n            if (Character.TYPE.equals(cls)) {\n                return Integer.TYPE.equals(toClass)\n                    || Long.TYPE.equals(toClass)\n                    || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            if (Short.TYPE.equals(cls)) {\n                return Integer.TYPE.equals(toClass)\n                    || Long.TYPE.equals(toClass)\n                    || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            if (Byte.TYPE.equals(cls)) {\n                return Short.TYPE.equals(toClass)\n                    || Integer.TYPE.equals(toClass)\n                    || Long.TYPE.equals(toClass)\n                    || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            \n            return false;\n        }\n        return toClass.isAssignableFrom(cls);\n    }\n\n    \n    public static Class<?> primitiveToWrapper(Class<?> cls) {\n        Class<?> convertedClass = cls;\n        if (cls != null && cls.isPrimitive()) {\n            convertedClass = primitiveWrapperMap.get(cls);\n        }\n        return convertedClass;\n    }\n\n    \n    public static Class<?>[] primitivesToWrappers(Class<?>[] classes) {\n        if (classes == null) {\n            return null;\n        }\n\n        if (classes.length == 0) {\n            return classes;\n        }\n\n        Class<?>[] convertedClasses = new Class[classes.length];\n        for (int i = 0; i < classes.length; i++) {\n            convertedClasses[i] = primitiveToWrapper(classes[i]);\n        }\n        return convertedClasses;\n    }\n\n    \n    public static Class<?> wrapperToPrimitive(Class<?> cls) {\n        return wrapperPrimitiveMap.get(cls);\n    }\n\n    \n    public static Class<?>[] wrappersToPrimitives(Class<?>[] classes) {\n        if (classes == null) {\n            return null;\n        }\n\n        if (classes.length == 0) {\n            return classes;\n        }\n\n        Class<?>[] convertedClasses = new Class[classes.length];\n        for (int i = 0; i < classes.length; i++) {\n            convertedClasses[i] = wrapperToPrimitive(classes[i]);\n        }\n        return convertedClasses;\n    }\n\n    \n    \n    \n    public static boolean isInnerClass(Class<?> cls) {\n        if (cls == null) {\n            return false;\n        }\n        return cls.getName().indexOf(INNER_CLASS_SEPARATOR_CHAR) >= 0;\n    }\n\n    \n    \n    \n    public static Class<?> getClass( ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException {\n        Class<?> clazz;\n        if (abbreviationMap.containsKey(className)) {\n            String clsName = \"[\" + abbreviationMap.get(className);\n            clazz = Class.forName(clsName, initialize, classLoader).getComponentType();\n        } else {\n            clazz = Class.forName(toCanonicalName(className), initialize, classLoader);\n        }\n        return clazz;\n    }\n\n    \n    public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException {\n        return getClass(classLoader, className, true);\n    }\n\n    \n    public static Class<?> getClass(String className) throws ClassNotFoundException {\n        return getClass(className, true);\n    }\n\n    \n    public static Class<?> getClass(String className, boolean initialize) throws ClassNotFoundException {\n        ClassLoader contextCL = Thread.currentThread().getContextClassLoader();\n        ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;\n        return getClass(loader, className, initialize );\n    }\n\n    \n    \n    \n    public static Method getPublicMethod(Class<?> cls, String methodName, Class<?> parameterTypes[]) throws SecurityException, NoSuchMethodException {\n\n        Method declaredMethod = cls.getMethod(methodName, parameterTypes);\n        if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) {\n            return declaredMethod;\n        }\n\n        List<Class<?>> candidateClasses = new ArrayList<Class<?>>();\n        candidateClasses.addAll(getAllInterfaces(cls));\n        candidateClasses.addAll(getAllSuperclasses(cls));\n\n        for (Class<?> candidateClass : candidateClasses) {\n            if (!Modifier.isPublic(candidateClass.getModifiers())) {\n                continue;\n            }\n            Method candidateMethod;\n            try {\n                candidateMethod = candidateClass.getMethod(methodName, parameterTypes);\n            } catch (NoSuchMethodException ex) {\n                continue;\n            }\n            if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) {\n                return candidateMethod;\n            }\n        }\n\n        throw new NoSuchMethodException(\"Can't find a public method for \" + methodName + \" \" + ArrayUtils.toString(parameterTypes)); } private static String toCanonicalName(String className) {\n        className = StringUtils.deleteWhitespace(className);\n        if (className == null) {\n            throw new NullPointerException(\"className must not be null.\");\n        } else if (className.endsWith(\"[]\")) {\n            StringBuilder classNameBuffer = new StringBuilder();\n            while (className.endsWith(\"[]\")) {\n                className = className.substring(0, className.length() - 2);\n                classNameBuffer.append(\"[\");\n            }\n            String abbreviation = abbreviationMap.get(className);\n            if (abbreviation != null) {\n                classNameBuffer.append(abbreviation);\n            } else {\n                classNameBuffer.append(\"L\").append(className).append(\";\");\n            }\n            className = classNameBuffer.toString();\n        }\n        return className;\n    }\n\n    \n    public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n            classes[i] = array[i] == null ? null : array[i].getClass();\n        }\n        return classes;\n    }\n\n    \n    \n    \n    public static String getShortCanonicalName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getShortCanonicalName(object.getClass().getName());\n    }\n\n    \n    public static String getShortCanonicalName(Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getShortCanonicalName(cls.getName());\n    }\n\n    \n    public static String getShortCanonicalName(String canonicalName) {\n        return ClassUtils.getShortClassName(getCanonicalName(canonicalName));\n    }\n\n    \n    \n    \n    public static String getPackageCanonicalName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getPackageCanonicalName(object.getClass().getName());\n    }\n\n    \n    public static String getPackageCanonicalName(Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getPackageCanonicalName(cls.getName());\n    }\n\n    \n    public static String getPackageCanonicalName(String canonicalName) {\n        return ClassUtils.getPackageName(getCanonicalName(canonicalName));\n    }\n\n    \n    private static String getCanonicalName(String className) {\n        className = StringUtils.deleteWhitespace(className);\n        if (className == null) {\n            return null;\n        } else {\n            int dim = 0;\n            while (className.startsWith(\"[\")) {\n                dim++;\n                className = className.substring(1);\n            }\n            if (dim < 1) {\n                return className;\n            } else {\n                if (className.startsWith(\"L\")) {\n                    className = className.substring(\n                        1,\n                        className.endsWith(\";\")\n                            ? className.length() - 1\n                            : className.length());\n                } else {\n                    if (className.length() > 0) {\n                        className = reverseAbbreviationMap.get(className.substring(0, 1));\n                    }\n                }\n                StringBuilder canonicalClassNameBuffer = new StringBuilder(className);\n                for (int i = 0; i < dim; i++) {\n                    canonicalClassNameBuffer.append(\"[]\");\n                }\n                return canonicalClassNameBuffer.toString();\n            }\n        }\n    }\n}\n",
      "buggy_signatures": [
        "static { addAbbreviation(\"int\", \"I\"); addAbbreviation(\"boolean\", \"Z\"); addAbbreviation(\"float\", \"F\"); addAbbreviation(\"long\", \"J\"); addAbbreviation(\"short\", \"S\"); addAbbreviation(\"byte\", \"B\"); addAbbreviation(\"double\", \"D\"); addAbbreviation(\"char\", \"C\"); } public ClassUtils()",
        "public static String getShortClassName(Object object, String valueIfNull)",
        "public static String getShortClassName(Class<?> cls)",
        "public static String getShortClassName(String className)",
        "public static String getPackageName(Object object, String valueIfNull)",
        "public static String getPackageName(Class<?> cls)",
        "public static String getPackageName(String className)",
        "public static List<Class<?>> getAllSuperclasses(Class<?> cls)",
        "public static List<Class<?>> getAllInterfaces(Class<?> cls)",
        "private static void getAllInterfaces(Class<?> cls, HashSet<Class<?>> interfacesFound)",
        "public static List<Class<?>> convertClassNamesToClasses(List<String> classNames)",
        "public static List<String> convertClassesToClassNames(List<Class<?>> classes)",
        "public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray)",
        "public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing)",
        "public static boolean isAssignable(Class<?> cls, Class<?> toClass)",
        "public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing)",
        "public static Class<?> primitiveToWrapper(Class<?> cls)",
        "public static Class<?>[] primitivesToWrappers(Class<?>[] classes)",
        "public static Class<?> wrapperToPrimitive(Class<?> cls)",
        "public static Class<?>[] wrappersToPrimitives(Class<?>[] classes)",
        "public static boolean isInnerClass(Class<?> cls)",
        "public static Class<?> getClass( ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException",
        "public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException",
        "public static Class<?> getClass(String className) throws ClassNotFoundException",
        "public static Class<?> getClass(String className, boolean initialize) throws ClassNotFoundException",
        "public static Method getPublicMethod(Class<?> cls, String methodName, Class<?> parameterTypes[]) throws SecurityException, NoSuchMethodException",
        "public method for \" + methodName + \" \" + ArrayUtils.toString(parameterTypes)); } private static String toCanonicalName(String className)",
        "public static Class<?>[] toClass(Object[] array)",
        "public static String getShortCanonicalName(Object object, String valueIfNull)",
        "public static String getShortCanonicalName(Class<?> cls)",
        "public static String getShortCanonicalName(String canonicalName)",
        "public static String getPackageCanonicalName(Object object, String valueIfNull)",
        "public static String getPackageCanonicalName(Class<?> cls)",
        "public static String getPackageCanonicalName(String canonicalName)",
        "private static String getCanonicalName(String className)"
      ],
      "fixed_signatures": [
        "static { addAbbreviation(\"int\", \"I\"); addAbbreviation(\"boolean\", \"Z\"); addAbbreviation(\"float\", \"F\"); addAbbreviation(\"long\", \"J\"); addAbbreviation(\"short\", \"S\"); addAbbreviation(\"byte\", \"B\"); addAbbreviation(\"double\", \"D\"); addAbbreviation(\"char\", \"C\"); } public ClassUtils()",
        "public static String getShortClassName(Object object, String valueIfNull)",
        "public static String getShortClassName(Class<?> cls)",
        "public static String getShortClassName(String className)",
        "public static String getPackageName(Object object, String valueIfNull)",
        "public static String getPackageName(Class<?> cls)",
        "public static String getPackageName(String className)",
        "public static List<Class<?>> getAllSuperclasses(Class<?> cls)",
        "public static List<Class<?>> getAllInterfaces(Class<?> cls)",
        "private static void getAllInterfaces(Class<?> cls, HashSet<Class<?>> interfacesFound)",
        "public static List<Class<?>> convertClassNamesToClasses(List<String> classNames)",
        "public static List<String> convertClassesToClassNames(List<Class<?>> classes)",
        "public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray)",
        "public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing)",
        "public static boolean isAssignable(Class<?> cls, Class<?> toClass)",
        "public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing)",
        "public static Class<?> primitiveToWrapper(Class<?> cls)",
        "public static Class<?>[] primitivesToWrappers(Class<?>[] classes)",
        "public static Class<?> wrapperToPrimitive(Class<?> cls)",
        "public static Class<?>[] wrappersToPrimitives(Class<?>[] classes)",
        "public static boolean isInnerClass(Class<?> cls)",
        "public static Class<?> getClass( ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException",
        "public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException",
        "public static Class<?> getClass(String className) throws ClassNotFoundException",
        "public static Class<?> getClass(String className, boolean initialize) throws ClassNotFoundException",
        "public static Method getPublicMethod(Class<?> cls, String methodName, Class<?> parameterTypes[]) throws SecurityException, NoSuchMethodException",
        "public method for \" + methodName + \" \" + ArrayUtils.toString(parameterTypes)); } private static String toCanonicalName(String className)",
        "public static Class<?>[] toClass(Object[] array)",
        "public static String getShortCanonicalName(Object object, String valueIfNull)",
        "public static String getShortCanonicalName(Class<?> cls)",
        "public static String getShortCanonicalName(String canonicalName)",
        "public static String getPackageCanonicalName(Object object, String valueIfNull)",
        "public static String getPackageCanonicalName(Class<?> cls)",
        "public static String getPackageCanonicalName(String canonicalName)",
        "private static String getCanonicalName(String className)"
      ],
      "methods": [
        {
          "buggy_method": "  public static Class<?>[] toClass(Object[] array) {\n  if (array == null) {\n  return null;\n  } else if (array.length == 0) {\n  return ArrayUtils.EMPTY_CLASS_ARRAY;\n  }\n  Class<?>[] classes = new Class[array.length];\n  for (int i = 0; i < array.length; i++) {\n  classes[i] = array[i].getClass();\n  }\n  return classes;\n  }",
          "fixed_method": "  public static Class<?>[] toClass(Object[] array) {\n  if (array == null) {\n  return null;\n  } else if (array.length == 0) {\n  return ArrayUtils.EMPTY_CLASS_ARRAY;\n  }\n  Class<?>[] classes = new Class[array.length];\n  for (int i = 0; i < array.length; i++) {\n  classes[i] = array[i] == null ? null : array[i].getClass();\n  }\n  return classes;\n  }",
          "diff": [
            "@@ -907,7 +907,7 @@",
            "         }\n",
            "         Class<?>[] classes = new Class[array.length];\n",
            "         for (int i = 0; i < array.length; i++) {\n",
            "-            classes[i] = array[i].getClass();\n",
            "+            classes[i] = array[i] == null ? null : array[i].getClass();\n",
            "         }\n",
            "         return classes;\n",
            "     }\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
