{
  "bug_id": "17",
  "failed_tests": {
    "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest": [
      {
        "methodName": "testCompress197",
        "error": "junit.framework.AssertionFailedError",
        "message": "COMPRESS-197: Error detected parsing the header",
        "fail_line": "            fail(\"COMPRESS-197: \" + e.getMessage());",
        "test_source": "  public void testCompress197() throws Exception {\n  TarArchiveInputStream tar = getTestStream(\"/COMPRESS-197.tar\");\n  try {\n  TarArchiveEntry entry = tar.getNextTarEntry();\n  while (entry != null) {\n  entry = tar.getNextTarEntry();\n  }\n  } catch (IOException e) {\n  fail(\"COMPRESS-197: \" + e.getMessage());\n  } finally {\n  tar.close();\n  }\n  }",
        "stack": [
          "TarArchiveInputStreamTest.testCompress197 line 134"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/compress/archivers/tar/TarUtils.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.tar;\n\nimport static org.apache.commons.compress.archivers.tar.TarConstants.CHKSUMLEN; import static org.apache.commons.compress.archivers.tar.TarConstants.CHKSUM_OFFSET; import java.io.IOException; import java.math.BigInteger; import java.nio.ByteBuffer; import org.apache.commons.compress.archivers.zip.ZipEncoding; import org.apache.commons.compress.archivers.zip.ZipEncodingHelper; public class TarUtils { private static final int BYTE_MASK = 255; static final ZipEncoding DEFAULT_ENCODING = ZipEncodingHelper.getZipEncoding(null); static final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\n            public boolean canEncode(String name) { return true; }\n\n            public ByteBuffer encode(String name) {\n                final int length = name.length();\n                byte[] buf = new byte[length];\n\n                \n                for (int i = 0; i < length; ++i) {\n                    buf[i] = (byte) name.charAt(i);\n                }\n                return ByteBuffer.wrap(buf);\n            }\n\n            public String decode(byte[] buffer) {\n                final int length = buffer.length;\n                StringBuffer result = new StringBuffer(length);\n\n                for (int i = 0; i < length; ++i) {\n                    byte b = buffer[i];\n                    if (b == 0) { \n                        break;\n                    }\n                    result.append((char) (b & 0xFF)); \n                }\n\n                return result.toString();\n            }\n        };\n\n    \n    private TarUtils() {\n    }\n\n    \n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        \n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        \n        byte trailer;\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        } else {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, end-1, trailer));\n        }\n        \n        trailer = buffer[end - 1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            \n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); \n            \n        }\n\n        return result;\n    }\n\n    \n    public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length) {\n\n        if ((buffer[offset] & 0x80) == 0) {\n            return parseOctal(buffer, offset, length);\n        }\n        final boolean negative = buffer[offset] == (byte) 0xff;\n        if (length < 9) {\n            return parseBinaryLong(buffer, offset, length, negative);\n        }\n        return parseBinaryBigInteger(buffer, offset, length, negative);\n    }\n\n    private static long parseBinaryLong(final byte[] buffer, final int offset, final int length, final boolean negative) {\n        if (length >= 9) {\n            throw new IllegalArgumentException(\"At offset \" + offset + \", \"\n                                               + length + \" byte binary number\"\n                                               + \" exceeds maximum signed long\"\n                                               + \" value\");\n        }\n        long val = 0;\n        for (int i = 1; i < length; i++) {\n            val = (val << 8) + (buffer[offset + i] & 0xff);\n        }\n        if (negative) {\n            \n            val--;\n            val ^= ((long) Math.pow(2, (length - 1) * 8) - 1);\n        }\n        return negative ? -val : val;\n    }\n\n    private static long parseBinaryBigInteger(final byte[] buffer, final int offset, final int length, final boolean negative) {\n        byte[] remainder = new byte[length - 1];\n        System.arraycopy(buffer, offset + 1, remainder, 0, length - 1);\n        BigInteger val = new BigInteger(remainder);\n        if (negative) {\n            \n            val = val.add(BigInteger.valueOf(-1)).not();\n        }\n        if (val.bitLength() > 63) {\n            throw new IllegalArgumentException(\"At offset \" + offset + \", \"\n                                               + length + \" byte binary number\"\n                                               + \" exceeds maximum signed long\"\n                                               + \" value\");\n        }\n        return negative ? -val.longValue() : val.longValue();\n    }\n\n    \n    public static boolean parseBoolean(final byte[] buffer, final int offset) {\n        return buffer[offset] == 1;\n    }\n\n    \n    private static String exceptionMessage(byte[] buffer, final int offset, final int length, int current, final byte currentByte) {\n        String string = new String(buffer, offset, length); \n        string=string.replaceAll(\"\\0\", \"{NUL}\"); \n        final String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;\n        return s;\n    }\n\n    \n    public static String parseName(byte[] buffer, final int offset, final int length) {\n        try {\n            return parseName(buffer, offset, length, DEFAULT_ENCODING);\n        } catch (IOException ex) {\n            try {\n                return parseName(buffer, offset, length, FALLBACK_ENCODING);\n            } catch (IOException ex2) {\n                \n                throw new RuntimeException(ex2);\n            }\n        }\n    }\n\n    \n    public static String parseName(byte[] buffer, final int offset, final int length, final ZipEncoding encoding) throws IOException {\n\n        int len = length;\n        for (; len > 0; len--) {\n            if (buffer[offset + len - 1] != 0) {\n                break;\n            }\n        }\n        if (len > 0) {\n            byte[] b = new byte[len];\n            System.arraycopy(buffer, offset, b, 0, len);\n            return encoding.decode(b);\n        }\n        return \"\";\n    }\n\n    \n    public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {\n        try {\n            return formatNameBytes(name, buf, offset, length, DEFAULT_ENCODING);\n        } catch (IOException ex) {\n            try {\n                return formatNameBytes(name, buf, offset, length,\n                                       FALLBACK_ENCODING);\n            } catch (IOException ex2) {\n                \n                throw new RuntimeException(ex2);\n            }\n        }\n    }\n\n    \n    public static int formatNameBytes(String name, byte[] buf, final int offset, final int length, final ZipEncoding encoding) throws IOException {\n        int len = name.length();\n        ByteBuffer b = encoding.encode(name);\n        while (b.limit() > length && len > 0) {\n            b = encoding.encode(name.substring(0, --len));\n        }\n        final int limit = b.limit();\n        System.arraycopy(b.array(), b.arrayOffset(), buf, offset, limit);\n\n        \n        for (int i = limit; i < length; ++i) {\n            buf[offset + i] = 0;\n        }\n\n        return offset + length;\n    }\n\n    \n    public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) {\n        int remaining = length;\n        remaining--;\n        if (value == 0) {\n            buffer[offset + remaining--] = (byte) '0';\n        } else {\n            long val = value;\n            for (; remaining >= 0 && val != 0; --remaining) {\n                \n                buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));\n                val = val >>> 3;\n                \n            }\n            if (val != 0){\n                throw new IllegalArgumentException\n                (value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length);\n            }\n        }\n\n        for (; remaining >= 0; --remaining) { \n            buffer[offset + remaining] = (byte) '0';\n        }\n    }\n\n    \n    public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-2; \n        formatUnsignedOctalString(value, buf, offset, idx);\n\n        buf[offset + idx++] = (byte) ' '; \n        buf[offset + idx]   = 0; \n\n        return offset + length;\n    }\n\n    \n    public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-1; \n\n        formatUnsignedOctalString(value, buf, offset, idx);\n        buf[offset + idx] = (byte) ' '; \n\n        return offset + length;\n    }\n\n    \n    public static int formatLongOctalOrBinaryBytes( final long value, byte[] buf, final int offset, final int length) {\n\n        \n        final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\n        final boolean negative = value < 0;\n        if (!negative && value <= maxAsOctalChar) { \n            return formatLongOctalBytes(value, buf, offset, length);\n        }\n\n        if (length < 9) {\n            formatLongBinary(value, buf, offset, length, negative);\n        }\n        formatBigIntegerBinary(value, buf, offset, length, negative);\n\n        buf[offset] = (byte) (negative ? 0xff : 0x80);\n        return offset + length;\n    }\n\n    private static void formatLongBinary(final long value, byte[] buf, final int offset, final int length, final boolean negative) {\n        final int bits = (length - 1) * 8;\n        final long max = 1l << bits;\n        long val = Math.abs(value);\n        if (val >= max) {\n            throw new IllegalArgumentException(\"Value \" + value +\n                \" is too large for \" + length + \" byte field.\");\n        }\n        if (negative) {\n            val ^= max - 1;\n            val |= 0xff << bits;\n            val++;\n        }\n        for (int i = offset + length - 1; i >= offset; i--) {\n            buf[i] = (byte) val;\n            val >>= 8;\n        }\n    }\n\n    private static void formatBigIntegerBinary(final long value, byte[] buf, final int offset, final int length, final boolean negative) {\n        BigInteger val = BigInteger.valueOf(value);\n        final byte[] b = val.toByteArray();\n        final int len = b.length;\n        final int off = offset + length - len;\n        System.arraycopy(b, 0, buf, off, len);\n        final byte fill = (byte) (negative ? 0xff : 0);\n        for (int i = offset + 1; i < off; i++) {\n            buf[i] = fill;\n        }\n    }\n\n    \n    public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-2; \n        formatUnsignedOctalString(value, buf, offset, idx);\n\n        buf[offset + idx++]   = 0; \n        buf[offset + idx]     = (byte) ' '; \n\n        return offset + length;\n    }\n\n    \n    public static long computeCheckSum(final byte[] buf) {\n        long sum = 0;\n\n        for (int i = 0; i < buf.length; ++i) {\n            sum += BYTE_MASK & buf[i];\n        }\n\n        return sum;\n    }\n\n    \n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits++ < 6) {\n                    storedSum = storedSum * 8 + b - '0';\n                } else if (digits > 0) {\n                    digits = 6; \n                }\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b;\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum\n                || storedSum > unsignedSum; \n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.tar;\n\nimport static org.apache.commons.compress.archivers.tar.TarConstants.CHKSUMLEN; import static org.apache.commons.compress.archivers.tar.TarConstants.CHKSUM_OFFSET; import java.io.IOException; import java.math.BigInteger; import java.nio.ByteBuffer; import org.apache.commons.compress.archivers.zip.ZipEncoding; import org.apache.commons.compress.archivers.zip.ZipEncodingHelper; public class TarUtils { private static final int BYTE_MASK = 255; static final ZipEncoding DEFAULT_ENCODING = ZipEncodingHelper.getZipEncoding(null); static final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\n            public boolean canEncode(String name) { return true; }\n\n            public ByteBuffer encode(String name) {\n                final int length = name.length();\n                byte[] buf = new byte[length];\n\n                \n                for (int i = 0; i < length; ++i) {\n                    buf[i] = (byte) name.charAt(i);\n                }\n                return ByteBuffer.wrap(buf);\n            }\n\n            public String decode(byte[] buffer) {\n                final int length = buffer.length;\n                StringBuffer result = new StringBuffer(length);\n\n                for (int i = 0; i < length; ++i) {\n                    byte b = buffer[i];\n                    if (b == 0) { \n                        break;\n                    }\n                    result.append((char) (b & 0xFF)); \n                }\n\n                return result.toString();\n            }\n        };\n\n    \n    private TarUtils() {\n    }\n\n    \n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        \n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        \n        byte trailer;\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        } else {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, end-1, trailer));\n        }\n        \n        trailer = buffer[end - 1];\n        while (start < end - 1 && (trailer == 0 || trailer == ' ')) {\n            end--;\n            trailer = buffer[end - 1];\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            \n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); \n            \n        }\n\n        return result;\n    }\n\n    \n    public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length) {\n\n        if ((buffer[offset] & 0x80) == 0) {\n            return parseOctal(buffer, offset, length);\n        }\n        final boolean negative = buffer[offset] == (byte) 0xff;\n        if (length < 9) {\n            return parseBinaryLong(buffer, offset, length, negative);\n        }\n        return parseBinaryBigInteger(buffer, offset, length, negative);\n    }\n\n    private static long parseBinaryLong(final byte[] buffer, final int offset, final int length, final boolean negative) {\n        if (length >= 9) {\n            throw new IllegalArgumentException(\"At offset \" + offset + \", \"\n                                               + length + \" byte binary number\"\n                                               + \" exceeds maximum signed long\"\n                                               + \" value\");\n        }\n        long val = 0;\n        for (int i = 1; i < length; i++) {\n            val = (val << 8) + (buffer[offset + i] & 0xff);\n        }\n        if (negative) {\n            \n            val--;\n            val ^= ((long) Math.pow(2, (length - 1) * 8) - 1);\n        }\n        return negative ? -val : val;\n    }\n\n    private static long parseBinaryBigInteger(final byte[] buffer, final int offset, final int length, final boolean negative) {\n        byte[] remainder = new byte[length - 1];\n        System.arraycopy(buffer, offset + 1, remainder, 0, length - 1);\n        BigInteger val = new BigInteger(remainder);\n        if (negative) {\n            \n            val = val.add(BigInteger.valueOf(-1)).not();\n        }\n        if (val.bitLength() > 63) {\n            throw new IllegalArgumentException(\"At offset \" + offset + \", \"\n                                               + length + \" byte binary number\"\n                                               + \" exceeds maximum signed long\"\n                                               + \" value\");\n        }\n        return negative ? -val.longValue() : val.longValue();\n    }\n\n    \n    public static boolean parseBoolean(final byte[] buffer, final int offset) {\n        return buffer[offset] == 1;\n    }\n\n    \n    private static String exceptionMessage(byte[] buffer, final int offset, final int length, int current, final byte currentByte) {\n        String string = new String(buffer, offset, length); \n        string=string.replaceAll(\"\\0\", \"{NUL}\"); \n        final String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;\n        return s;\n    }\n\n    \n    public static String parseName(byte[] buffer, final int offset, final int length) {\n        try {\n            return parseName(buffer, offset, length, DEFAULT_ENCODING);\n        } catch (IOException ex) {\n            try {\n                return parseName(buffer, offset, length, FALLBACK_ENCODING);\n            } catch (IOException ex2) {\n                \n                throw new RuntimeException(ex2);\n            }\n        }\n    }\n\n    \n    public static String parseName(byte[] buffer, final int offset, final int length, final ZipEncoding encoding) throws IOException {\n\n        int len = length;\n        for (; len > 0; len--) {\n            if (buffer[offset + len - 1] != 0) {\n                break;\n            }\n        }\n        if (len > 0) {\n            byte[] b = new byte[len];\n            System.arraycopy(buffer, offset, b, 0, len);\n            return encoding.decode(b);\n        }\n        return \"\";\n    }\n\n    \n    public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {\n        try {\n            return formatNameBytes(name, buf, offset, length, DEFAULT_ENCODING);\n        } catch (IOException ex) {\n            try {\n                return formatNameBytes(name, buf, offset, length,\n                                       FALLBACK_ENCODING);\n            } catch (IOException ex2) {\n                \n                throw new RuntimeException(ex2);\n            }\n        }\n    }\n\n    \n    public static int formatNameBytes(String name, byte[] buf, final int offset, final int length, final ZipEncoding encoding) throws IOException {\n        int len = name.length();\n        ByteBuffer b = encoding.encode(name);\n        while (b.limit() > length && len > 0) {\n            b = encoding.encode(name.substring(0, --len));\n        }\n        final int limit = b.limit();\n        System.arraycopy(b.array(), b.arrayOffset(), buf, offset, limit);\n\n        \n        for (int i = limit; i < length; ++i) {\n            buf[offset + i] = 0;\n        }\n\n        return offset + length;\n    }\n\n    \n    public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) {\n        int remaining = length;\n        remaining--;\n        if (value == 0) {\n            buffer[offset + remaining--] = (byte) '0';\n        } else {\n            long val = value;\n            for (; remaining >= 0 && val != 0; --remaining) {\n                \n                buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));\n                val = val >>> 3;\n                \n            }\n            if (val != 0){\n                throw new IllegalArgumentException\n                (value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length);\n            }\n        }\n\n        for (; remaining >= 0; --remaining) { \n            buffer[offset + remaining] = (byte) '0';\n        }\n    }\n\n    \n    public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-2; \n        formatUnsignedOctalString(value, buf, offset, idx);\n\n        buf[offset + idx++] = (byte) ' '; \n        buf[offset + idx]   = 0; \n\n        return offset + length;\n    }\n\n    \n    public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-1; \n\n        formatUnsignedOctalString(value, buf, offset, idx);\n        buf[offset + idx] = (byte) ' '; \n\n        return offset + length;\n    }\n\n    \n    public static int formatLongOctalOrBinaryBytes( final long value, byte[] buf, final int offset, final int length) {\n\n        \n        final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\n        final boolean negative = value < 0;\n        if (!negative && value <= maxAsOctalChar) { \n            return formatLongOctalBytes(value, buf, offset, length);\n        }\n\n        if (length < 9) {\n            formatLongBinary(value, buf, offset, length, negative);\n        }\n        formatBigIntegerBinary(value, buf, offset, length, negative);\n\n        buf[offset] = (byte) (negative ? 0xff : 0x80);\n        return offset + length;\n    }\n\n    private static void formatLongBinary(final long value, byte[] buf, final int offset, final int length, final boolean negative) {\n        final int bits = (length - 1) * 8;\n        final long max = 1l << bits;\n        long val = Math.abs(value);\n        if (val >= max) {\n            throw new IllegalArgumentException(\"Value \" + value +\n                \" is too large for \" + length + \" byte field.\");\n        }\n        if (negative) {\n            val ^= max - 1;\n            val |= 0xff << bits;\n            val++;\n        }\n        for (int i = offset + length - 1; i >= offset; i--) {\n            buf[i] = (byte) val;\n            val >>= 8;\n        }\n    }\n\n    private static void formatBigIntegerBinary(final long value, byte[] buf, final int offset, final int length, final boolean negative) {\n        BigInteger val = BigInteger.valueOf(value);\n        final byte[] b = val.toByteArray();\n        final int len = b.length;\n        final int off = offset + length - len;\n        System.arraycopy(b, 0, buf, off, len);\n        final byte fill = (byte) (negative ? 0xff : 0);\n        for (int i = offset + 1; i < off; i++) {\n            buf[i] = fill;\n        }\n    }\n\n    \n    public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-2; \n        formatUnsignedOctalString(value, buf, offset, idx);\n\n        buf[offset + idx++]   = 0; \n        buf[offset + idx]     = (byte) ' '; \n\n        return offset + length;\n    }\n\n    \n    public static long computeCheckSum(final byte[] buf) {\n        long sum = 0;\n\n        for (int i = 0; i < buf.length; ++i) {\n            sum += BYTE_MASK & buf[i];\n        }\n\n        return sum;\n    }\n\n    \n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits++ < 6) {\n                    storedSum = storedSum * 8 + b - '0';\n                } else if (digits > 0) {\n                    digits = 6; \n                }\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b;\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum\n                || storedSum > unsignedSum; \n    }\n\n}\n",
      "buggy_signatures": [
        "public boolean canEncode(String name)",
        "public ByteBuffer encode(String name)",
        "public String decode(byte[] buffer)",
        "private TarUtils()",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length)",
        "public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length)",
        "private static long parseBinaryLong(final byte[] buffer, final int offset, final int length, final boolean negative)",
        "private static long parseBinaryBigInteger(final byte[] buffer, final int offset, final int length, final boolean negative)",
        "public static boolean parseBoolean(final byte[] buffer, final int offset)",
        "private static String exceptionMessage(byte[] buffer, final int offset, final int length, int current, final byte currentByte)",
        "public static String parseName(byte[] buffer, final int offset, final int length)",
        "public static String parseName(byte[] buffer, final int offset, final int length, final ZipEncoding encoding) throws IOException",
        "public static int formatNameBytes(String name, byte[] buf, final int offset, final int length)",
        "public static int formatNameBytes(String name, byte[] buf, final int offset, final int length, final ZipEncoding encoding) throws IOException",
        "public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length)",
        "public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length)",
        "public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length)",
        "public static int formatLongOctalOrBinaryBytes( final long value, byte[] buf, final int offset, final int length)",
        "private static void formatLongBinary(final long value, byte[] buf, final int offset, final int length, final boolean negative)",
        "private static void formatBigIntegerBinary(final long value, byte[] buf, final int offset, final int length, final boolean negative)",
        "public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length)",
        "public static long computeCheckSum(final byte[] buf)",
        "public static boolean verifyCheckSum(byte[] header)"
      ],
      "fixed_signatures": [
        "public boolean canEncode(String name)",
        "public ByteBuffer encode(String name)",
        "public String decode(byte[] buffer)",
        "private TarUtils()",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length)",
        "public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length)",
        "private static long parseBinaryLong(final byte[] buffer, final int offset, final int length, final boolean negative)",
        "private static long parseBinaryBigInteger(final byte[] buffer, final int offset, final int length, final boolean negative)",
        "public static boolean parseBoolean(final byte[] buffer, final int offset)",
        "private static String exceptionMessage(byte[] buffer, final int offset, final int length, int current, final byte currentByte)",
        "public static String parseName(byte[] buffer, final int offset, final int length)",
        "public static String parseName(byte[] buffer, final int offset, final int length, final ZipEncoding encoding) throws IOException",
        "public static int formatNameBytes(String name, byte[] buf, final int offset, final int length)",
        "public static int formatNameBytes(String name, byte[] buf, final int offset, final int length, final ZipEncoding encoding) throws IOException",
        "public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length)",
        "public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length)",
        "public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length)",
        "public static int formatLongOctalOrBinaryBytes( final long value, byte[] buf, final int offset, final int length)",
        "private static void formatLongBinary(final long value, byte[] buf, final int offset, final int length, final boolean negative)",
        "private static void formatBigIntegerBinary(final long value, byte[] buf, final int offset, final int length, final boolean negative)",
        "public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length)",
        "public static long computeCheckSum(final byte[] buf)",
        "public static boolean verifyCheckSum(byte[] header)"
      ],
      "methods": [
        {
          "buggy_method": "  public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n  long  result = 0;\n  int  end = offset + length;\n  int  start = offset;\n\n  if (length < 2){\n  throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n  }\n\n  if (buffer[start] == 0) {\n  return 0L;\n  }\n\n  \n  while (start < end){\n  if (buffer[start] == ' '){\n  start++;\n  } else {\n  break;\n  }\n  }\n\n  \n  byte trailer;\n  trailer = buffer[end-1];\n  if (trailer == 0 || trailer == ' '){\n  end--;\n  } else {\n  throw new IllegalArgumentException(\n  exceptionMessage(buffer, offset, length, end-1, trailer));\n  }\n  \n  trailer = buffer[end - 1];\n  if (trailer == 0 || trailer == ' '){\n  end--;\n  }\n\n  for ( ;start < end; start++) {\n  final byte currentByte = buffer[start];\n  \n  if (currentByte < '0' || currentByte > '7'){\n  throw new IllegalArgumentException(\n  exceptionMessage(buffer, offset, length, start, currentByte));\n  }\n  result = (result << 3) + (currentByte - '0'); \n  \n  }\n\n  return result;\n  }",
          "fixed_method": "  public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n  long  result = 0;\n  int  end = offset + length;\n  int  start = offset;\n\n  if (length < 2){\n  throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n  }\n\n  if (buffer[start] == 0) {\n  return 0L;\n  }\n\n  \n  while (start < end){\n  if (buffer[start] == ' '){\n  start++;\n  } else {\n  break;\n  }\n  }\n\n  \n  byte trailer;\n  trailer = buffer[end-1];\n  if (trailer == 0 || trailer == ' '){\n  end--;\n  } else {\n  throw new IllegalArgumentException(\n  exceptionMessage(buffer, offset, length, end-1, trailer));\n  }\n  \n  trailer = buffer[end - 1];\n  while (start < end - 1 && (trailer == 0 || trailer == ' ')) {\n  end--;\n  trailer = buffer[end - 1];\n  }\n\n  for ( ;start < end; start++) {\n  final byte currentByte = buffer[start];\n  \n  if (currentByte < '0' || currentByte > '7'){\n  throw new IllegalArgumentException(\n  exceptionMessage(buffer, offset, length, start, currentByte));\n  }\n  result = (result << 3) + (currentByte - '0'); \n  \n  }\n\n  return result;\n  }",
          "diff": [
            "@@ -132,8 +132,9 @@",
            "         }\n",
            "         // May have additional NULs or spaces\n",
            "         trailer = buffer[end - 1];\n",
            "-        if (trailer == 0 || trailer == ' '){\n",
            "+        while (start < end - 1 && (trailer == 0 || trailer == ' ')) {\n",
            "             end--;\n",
            "+            trailer = buffer[end - 1];\n",
            "         }\n",
            " \n",
            "         for ( ;start < end; start++) {\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
