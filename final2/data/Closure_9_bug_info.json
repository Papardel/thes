{
  "bug_id": "9",
  "failed_tests": {
    "com.google.javascript.jscomp.ProcessCommonJSModulesTest": [
      {
        "methodName": "testGuessModuleName",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<module$[]baz> but was:<module$[foo\\]baz>",
        "fail_line": "    assertEquals(\"module$baz\",",
        "test_source": "  public void testGuessModuleName() {\n  ProcessCommonJSModules pass = new ProcessCommonJSModules(null, \"foo\");\n  assertEquals(\"module$baz\",\n  pass.guessCJSModuleName(\"foo/baz.js\"));\n  assertEquals(\"module$baz\",\n  pass.guessCJSModuleName(\"foo\\\\baz.js\"));\n  assertEquals(\"module$bar$baz\",\n  pass.guessCJSModuleName(\"foo\\\\bar\\\\baz.js\"));\n  }",
        "stack": [
          "ProcessCommonJSModulesTest.testGuessModuleName line 132"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/google/javascript/jscomp/ProcessCommonJSModules.java",
      "buggy_full_code": "\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.Node;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\n\npublic class ProcessCommonJSModules implements CompilerPass { private static final String MODULE_SLASH = \"/\"; public static final String DEFAULT_FILENAME_PREFIX = \".\" + MODULE_SLASH; private static final String MODULE_NAME_SEPARATOR = \"\\\\$\"; private static final String MODULE_NAME_PREFIX = \"module$\"; private final AbstractCompiler compiler; private final String filenamePrefix; private final boolean reportDependencies; private JSModule module; ProcessCommonJSModules(AbstractCompiler compiler, String filenamePrefix) {\n    this(compiler, filenamePrefix, true);\n  }\n\n  ProcessCommonJSModules(AbstractCompiler compiler, String filenamePrefix,\n      boolean reportDependencies) {\n    this.compiler = compiler;\n    this.filenamePrefix = filenamePrefix.endsWith(MODULE_SLASH) ?\n        filenamePrefix : filenamePrefix + MODULE_SLASH;\n    this.reportDependencies = reportDependencies;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal\n        .traverse(compiler, root, new ProcessCommonJsModulesCallback());\n  }\n\n  String guessCJSModuleName(String filename) {\n    return toModuleName(normalizeSourceName(filename));\n  }\n\n  \n  JSModule getModule() {\n    return module;\n  }\n\n  \n  public static String toModuleName(String filename) {\n    return MODULE_NAME_PREFIX +\n        filename.replaceAll(\"^\\\\.\" + Pattern.quote(MODULE_SLASH), \"\")\n            .replaceAll(Pattern.quote(MODULE_SLASH), MODULE_NAME_SEPARATOR)\n            .replaceAll(\"\\\\.js$\", \"\").replaceAll(\"-\", \"_\");\n  }\n\n  \n  public static String toModuleName(String requiredFilename, String currentFilename) {\n    requiredFilename = requiredFilename.replaceAll(\"\\\\.js$\", \"\");\n    currentFilename = currentFilename.replaceAll(\"\\\\.js$\", \"\");\n\n    if (requiredFilename.startsWith(\".\" + MODULE_SLASH) ||\n        requiredFilename.startsWith(\"..\" + MODULE_SLASH)) {\n      try {\n        requiredFilename = (new URI(currentFilename)).resolve(new URI(requiredFilename))\n            .toString();\n      } catch (URISyntaxException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return toModuleName(requiredFilename);\n  }\n\n  private String normalizeSourceName(String filename) {\n    \n    \n\n    if (filename.indexOf(filenamePrefix) == 0) {\n      filename = filename.substring(filenamePrefix.length());\n    }\n\n    return filename;\n  }\n\n  \n  private class ProcessCommonJsModulesCallback extends AbstractPostOrderCallback { private int scriptNodeCount = 0; private Set<String> modulesWithExports = Sets.newHashSet(); @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.isCall() && n.getChildCount() == 2 &&\n          \"require\".equals(n.getFirstChild().getQualifiedName()) &&\n          n.getChildAtIndex(1).isString()) {\n        visitRequireCall(t, n, parent);\n      }\n\n      if (n.isScript()) {\n        scriptNodeCount++;\n        visitScript(t, n);\n      }\n\n      if (n.isGetProp() &&\n          \"module.exports\".equals(n.getQualifiedName())) {\n        visitModuleExports(n);\n      }\n    }\n\n    \n    private void visitRequireCall(NodeTraversal t, Node require, Node parent) {\n      String moduleName = toModuleName(require.getChildAtIndex(1).getString(),\n          normalizeSourceName(t.getSourceName()));\n      Node moduleRef = IR.name(moduleName).srcref(require);\n      parent.replaceChild(require, moduleRef);\n      Node script = getCurrentScriptNode(parent);\n      if (reportDependencies) {\n        t.getInput().addRequire(moduleName);\n      }\n      \n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"require\")),\n              IR.string(moduleName))).copyInformationFromForTree(require));\n      compiler.reportCodeChange();\n    }\n\n    \n    private void visitScript(NodeTraversal t, Node script) {\n      Preconditions.checkArgument(scriptNodeCount == 1,\n          \"ProcessCommonJSModules supports only one invocation per \" +\n          \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n      script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n          .copyInformationFromForTree(script));\n      if (reportDependencies) {\n        CompilerInput ci = t.getInput();\n        ci.addProvide(moduleName);\n        JSModule m = new JSModule(moduleName);\n        m.addAndOverrideModule(ci);\n        module = m;\n      }\n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n              IR.string(moduleName))).copyInformationFromForTree(script));\n\n      emitOptionalModuleExportsOverride(script, moduleName);\n\n      \n      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n          moduleName));\n\n      compiler.reportCodeChange();\n    }\n\n    \n    private void emitOptionalModuleExportsOverride(Node script, String moduleName) {\n      if (!modulesWithExports.contains(moduleName)) {\n        return;\n      }\n\n      Node moduleExportsProp = IR.getprop(IR.name(moduleName),\n          IR.string(\"module$exports\"));\n      script.addChildToBack(IR.ifNode(\n          moduleExportsProp,\n          IR.block(IR.exprResult(IR.assign(IR.name(moduleName),\n              moduleExportsProp.cloneTree())))).copyInformationFromForTree(\n          script));\n    }\n\n    \n    private void visitModuleExports(Node prop) {\n      String moduleName = guessCJSModuleName(prop.getSourceFileName());\n      Node module = prop.getChildAtIndex(0);\n      module.putProp(Node.ORIGINALNAME_PROP, \"module\");\n      module.setString(moduleName);\n      Node exports = prop.getChildAtIndex(1);\n      exports.putProp(Node.ORIGINALNAME_PROP, \"exports\");\n      exports.setString(\"module$exports\");\n      modulesWithExports.add(moduleName);\n    }\n\n    \n    private Node getCurrentScriptNode(Node n) {\n      while (true) {\n        if (n.isScript()) {\n          return n;\n        }\n        n = n.getParent();\n      }\n    }\n  }\n\n  \n  private class SuffixVarsCallback extends AbstractPostOrderCallback { private static final String EXPORTS = \"exports\"; private final String suffix; SuffixVarsCallback(String suffix) {\n      this.suffix = suffix;\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.isName()) {\n        String name = n.getString();\n        if (suffix.equals(name)) {\n          return;\n        }\n        if (EXPORTS.equals(name)) {\n          n.setString(suffix);\n          n.putProp(Node.ORIGINALNAME_PROP, EXPORTS);\n        } else {\n          Scope.Var var = t.getScope().getVar(name);\n          if (var != null && var.isGlobal()) {\n            n.setString(name + \"$$\" + suffix);\n            n.putProp(Node.ORIGINALNAME_PROP, name);\n          }\n        }\n      }\n    }\n  }\n}\n",
      "fixed_full_code": "\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.Node;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\n\npublic class ProcessCommonJSModules implements CompilerPass { private static final String MODULE_SLASH = \"/\"; public static final String DEFAULT_FILENAME_PREFIX = \".\" + MODULE_SLASH; private static final String MODULE_NAME_SEPARATOR = \"\\\\$\"; private static final String MODULE_NAME_PREFIX = \"module$\"; private final AbstractCompiler compiler; private final String filenamePrefix; private final boolean reportDependencies; private JSModule module; ProcessCommonJSModules(AbstractCompiler compiler, String filenamePrefix) {\n    this(compiler, filenamePrefix, true);\n  }\n\n  ProcessCommonJSModules(AbstractCompiler compiler, String filenamePrefix,\n      boolean reportDependencies) {\n    this.compiler = compiler;\n    this.filenamePrefix = filenamePrefix.endsWith(MODULE_SLASH) ?\n        filenamePrefix : filenamePrefix + MODULE_SLASH;\n    this.reportDependencies = reportDependencies;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal\n        .traverse(compiler, root, new ProcessCommonJsModulesCallback());\n  }\n\n  String guessCJSModuleName(String filename) {\n    return toModuleName(normalizeSourceName(filename));\n  }\n\n  \n  JSModule getModule() {\n    return module;\n  }\n\n  \n  public static String toModuleName(String filename) {\n    return MODULE_NAME_PREFIX +\n        filename.replaceAll(\"^\\\\.\" + Pattern.quote(MODULE_SLASH), \"\")\n            .replaceAll(Pattern.quote(MODULE_SLASH), MODULE_NAME_SEPARATOR)\n            .replaceAll(\"\\\\.js$\", \"\").replaceAll(\"-\", \"_\");\n  }\n\n  \n  public static String toModuleName(String requiredFilename, String currentFilename) {\n    requiredFilename = requiredFilename.replaceAll(\"\\\\.js$\", \"\");\n    currentFilename = currentFilename.replaceAll(\"\\\\.js$\", \"\");\n\n    if (requiredFilename.startsWith(\".\" + MODULE_SLASH) ||\n        requiredFilename.startsWith(\"..\" + MODULE_SLASH)) {\n      try {\n        requiredFilename = (new URI(currentFilename)).resolve(new URI(requiredFilename))\n            .toString();\n      } catch (URISyntaxException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return toModuleName(requiredFilename);\n  }\n\n  private String normalizeSourceName(String filename) {\n    \n    \n    filename = filename.replace(\"\\\\\", \"/\");\n\n    if (filename.indexOf(filenamePrefix) == 0) {\n      filename = filename.substring(filenamePrefix.length());\n    }\n\n    return filename;\n  }\n\n  \n  private class ProcessCommonJsModulesCallback extends AbstractPostOrderCallback { private int scriptNodeCount = 0; private Set<String> modulesWithExports = Sets.newHashSet(); @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.isCall() && n.getChildCount() == 2 &&\n          \"require\".equals(n.getFirstChild().getQualifiedName()) &&\n          n.getChildAtIndex(1).isString()) {\n        visitRequireCall(t, n, parent);\n      }\n\n      if (n.isScript()) {\n        scriptNodeCount++;\n        visitScript(t, n);\n      }\n\n      if (n.isGetProp() &&\n          \"module.exports\".equals(n.getQualifiedName())) {\n        visitModuleExports(n);\n      }\n    }\n\n    \n    private void visitRequireCall(NodeTraversal t, Node require, Node parent) {\n      String moduleName = toModuleName(require.getChildAtIndex(1).getString(),\n          normalizeSourceName(t.getSourceName()));\n      Node moduleRef = IR.name(moduleName).srcref(require);\n      parent.replaceChild(require, moduleRef);\n      Node script = getCurrentScriptNode(parent);\n      if (reportDependencies) {\n        t.getInput().addRequire(moduleName);\n      }\n      \n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"require\")),\n              IR.string(moduleName))).copyInformationFromForTree(require));\n      compiler.reportCodeChange();\n    }\n\n    \n    private void visitScript(NodeTraversal t, Node script) {\n      Preconditions.checkArgument(scriptNodeCount == 1,\n          \"ProcessCommonJSModules supports only one invocation per \" +\n          \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(script.getSourceFileName());\n      script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n          .copyInformationFromForTree(script));\n      if (reportDependencies) {\n        CompilerInput ci = t.getInput();\n        ci.addProvide(moduleName);\n        JSModule m = new JSModule(moduleName);\n        m.addAndOverrideModule(ci);\n        module = m;\n      }\n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n              IR.string(moduleName))).copyInformationFromForTree(script));\n\n      emitOptionalModuleExportsOverride(script, moduleName);\n\n      \n      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n          moduleName));\n\n      compiler.reportCodeChange();\n    }\n\n    \n    private void emitOptionalModuleExportsOverride(Node script, String moduleName) {\n      if (!modulesWithExports.contains(moduleName)) {\n        return;\n      }\n\n      Node moduleExportsProp = IR.getprop(IR.name(moduleName),\n          IR.string(\"module$exports\"));\n      script.addChildToBack(IR.ifNode(\n          moduleExportsProp,\n          IR.block(IR.exprResult(IR.assign(IR.name(moduleName),\n              moduleExportsProp.cloneTree())))).copyInformationFromForTree(\n          script));\n    }\n\n    \n    private void visitModuleExports(Node prop) {\n      String moduleName = guessCJSModuleName(prop.getSourceFileName());\n      Node module = prop.getChildAtIndex(0);\n      module.putProp(Node.ORIGINALNAME_PROP, \"module\");\n      module.setString(moduleName);\n      Node exports = prop.getChildAtIndex(1);\n      exports.putProp(Node.ORIGINALNAME_PROP, \"exports\");\n      exports.setString(\"module$exports\");\n      modulesWithExports.add(moduleName);\n    }\n\n    \n    private Node getCurrentScriptNode(Node n) {\n      while (true) {\n        if (n.isScript()) {\n          return n;\n        }\n        n = n.getParent();\n      }\n    }\n  }\n\n  \n  private class SuffixVarsCallback extends AbstractPostOrderCallback { private static final String EXPORTS = \"exports\"; private final String suffix; SuffixVarsCallback(String suffix) {\n      this.suffix = suffix;\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.isName()) {\n        String name = n.getString();\n        if (suffix.equals(name)) {\n          return;\n        }\n        if (EXPORTS.equals(name)) {\n          n.setString(suffix);\n          n.putProp(Node.ORIGINALNAME_PROP, EXPORTS);\n        } else {\n          Scope.Var var = t.getScope().getVar(name);\n          if (var != null && var.isGlobal()) {\n            n.setString(name + \"$$\" + suffix);\n            n.putProp(Node.ORIGINALNAME_PROP, name);\n          }\n        }\n      }\n    }\n  }\n}\n",
      "buggy_signatures": [
        "public void process(Node externs, Node root)",
        "public static String toModuleName(String filename)",
        "public static String toModuleName(String requiredFilename, String currentFilename)",
        "private String normalizeSourceName(String filename)",
        "private void visitRequireCall(NodeTraversal t, Node require, Node parent)",
        "private void visitScript(NodeTraversal t, Node script)",
        "private void emitOptionalModuleExportsOverride(Node script, String moduleName)",
        "private void visitModuleExports(Node prop)",
        "private Node getCurrentScriptNode(Node n)",
        "public void visit(NodeTraversal t, Node n, Node parent)"
      ],
      "fixed_signatures": [
        "public void process(Node externs, Node root)",
        "public static String toModuleName(String filename)",
        "public static String toModuleName(String requiredFilename, String currentFilename)",
        "private String normalizeSourceName(String filename)",
        "private void visitRequireCall(NodeTraversal t, Node require, Node parent)",
        "private void visitScript(NodeTraversal t, Node script)",
        "private void emitOptionalModuleExportsOverride(Node script, String moduleName)",
        "private void visitModuleExports(Node prop)",
        "private Node getCurrentScriptNode(Node n)",
        "public void visit(NodeTraversal t, Node n, Node parent)"
      ],
      "methods": [
        {
          "buggy_method": "  private String normalizeSourceName(String filename) {\n  \n  \n\n  if (filename.indexOf(filenamePrefix) == 0) {\n  filename = filename.substring(filenamePrefix.length());\n  }\n\n  return filename;\n  }",
          "fixed_method": "  private String normalizeSourceName(String filename) {\n  \n  \n  filename = filename.replace(\"\\\\\", \"/\");\n\n  if (filename.indexOf(filenamePrefix) == 0) {\n  filename = filename.substring(filenamePrefix.length());\n  }\n\n  return filename;\n  }",
          "diff": [
            "@@ -116,6 +116,7 @@",
            "   private String normalizeSourceName(String filename) {\n",
            "     // The DOS command shell will normalize \"/\" to \"\\\", so we have to\n",
            "     // wrestle it back.\n",
            "+    filename = filename.replace(\"\\\\\", \"/\");\n",
            " \n",
            "     if (filename.indexOf(filenamePrefix) == 0) {\n",
            "       filename = filename.substring(filenamePrefix.length());\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  private void visitScript(NodeTraversal t, Node script) {\n  Preconditions.checkArgument(scriptNodeCount == 1,\n  \"ProcessCommonJSModules supports only one invocation per \" +\n  \"CompilerInput / script node\");\n  String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n  script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n  .copyInformationFromForTree(script));\n  if (reportDependencies) {\n  CompilerInput ci = t.getInput();\n  ci.addProvide(moduleName);\n  JSModule m = new JSModule(moduleName);\n  m.addAndOverrideModule(ci);\n  module = m;\n  }\n  script.addChildToFront(IR.exprResult(\n  IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n  IR.string(moduleName))).copyInformationFromForTree(script));\n\n  emitOptionalModuleExportsOverride(script, moduleName);\n\n  \n  NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n  moduleName));\n\n  compiler.reportCodeChange();\n  }",
          "fixed_method": "  private void visitScript(NodeTraversal t, Node script) {\n  Preconditions.checkArgument(scriptNodeCount == 1,\n  \"ProcessCommonJSModules supports only one invocation per \" +\n  \"CompilerInput / script node\");\n  String moduleName = guessCJSModuleName(script.getSourceFileName());\n  script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n  .copyInformationFromForTree(script));\n  if (reportDependencies) {\n  CompilerInput ci = t.getInput();\n  ci.addProvide(moduleName);\n  JSModule m = new JSModule(moduleName);\n  m.addAndOverrideModule(ci);\n  module = m;\n  }\n  script.addChildToFront(IR.exprResult(\n  IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n  IR.string(moduleName))).copyInformationFromForTree(script));\n\n  emitOptionalModuleExportsOverride(script, moduleName);\n\n  \n  NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n  moduleName));\n\n  compiler.reportCodeChange();\n  }",
          "diff": [
            "@@ -180,7 +181,7 @@",
            "       Preconditions.checkArgument(scriptNodeCount == 1,\n",
            "           \"ProcessCommonJSModules supports only one invocation per \" +\n",
            "           \"CompilerInput / script node\");\n",
            "-      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n",
            "+      String moduleName = guessCJSModuleName(script.getSourceFileName());\n",
            "       script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n",
            "           .copyInformationFromForTree(script));\n",
            "       if (reportDependencies) {\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
