{
  "bug_id": "8",
  "failed_tests": {
    "com.fasterxml.jackson.core.util.TestTextBuffer": [
      {
        "methodName": "testEmpty",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "        assertTrue(tb.getTextBuffer().length == 0);",
        "test_source": "  public void testEmpty() {\n  TextBuffer tb = new TextBuffer(new BufferRecycler());\n  tb.resetWithEmpty();\n\n  assertTrue(tb.getTextBuffer().length == 0);\n  tb.contentsAsString();\n  assertTrue(tb.getTextBuffer().length == 0);\n  }",
        "stack": [
          "TestTextBuffer.testEmpty line 83"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/core/util/TextBuffer.java",
      "buggy_full_code": "package com.fasterxml.jackson.core.util;\n\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n\npublic final class TextBuffer { final static char[] NO_CHARS = new char[0]; final static int MIN_SEGMENT_LEN = 1000; final static int MAX_SEGMENT_LEN = 0x40000; private final BufferRecycler _allocator; private char[] _inputBuffer; private int _inputStart; private int _inputLen; private ArrayList<char[]> _segments; private boolean _hasSegments = false; private int _segmentSize; private char[] _currentSegment; private int _currentSize; private String _resultString; private char[] _resultArray; public TextBuffer(BufferRecycler allocator) {\n        _allocator = allocator;\n    }\n\n    \n    public void releaseBuffers() {\n        if (_allocator == null) {\n            resetWithEmpty();\n        } else {\n            if (_currentSegment != null) {\n                \n                resetWithEmpty();\n                \n                char[] buf = _currentSegment;\n                _currentSegment = null;\n                _allocator.releaseCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, buf);\n            }\n        }\n    }\n\n    \n    public void resetWithEmpty() {\n        _inputStart = -1; \n        _currentSize = 0;\n        _inputLen = 0;\n\n        _inputBuffer = null;\n        _resultString = null;\n        _resultArray = null;\n\n        \n        if (_hasSegments) {\n            clearSegments();\n        }\n    }\n\n    \n    public void resetWithShared(char[] buf, int start, int len) {\n        \n        _resultString = null;\n        _resultArray = null;\n\n        \n        _inputBuffer = buf;\n        _inputStart = start;\n        _inputLen = len;\n\n        \n        if (_hasSegments) {\n            clearSegments();\n        }\n    }\n\n    public void resetWithCopy(char[] buf, int start, int len) {\n        _inputBuffer = null;\n        _inputStart = -1; \n        _inputLen = 0;\n\n        _resultString = null;\n        _resultArray = null;\n\n        \n        if (_hasSegments) {\n            clearSegments();\n        } else if (_currentSegment == null) {\n            _currentSegment = buf(len);\n        }\n        _currentSize = _segmentSize = 0;\n        append(buf, start, len);\n    }\n\n    public void resetWithString(String value) {\n        _inputBuffer = null;\n        _inputStart = -1;\n        _inputLen = 0;\n\n        _resultString = value;\n        _resultArray = null;\n\n        if (_hasSegments) {\n            clearSegments();\n        }\n        _currentSize = 0;\n        \n    }\n    \n    \n    private char[] buf(int needed) {\n        if (_allocator != null) {\n            return _allocator.allocCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, needed);\n        }\n        return new char[Math.max(needed, MIN_SEGMENT_LEN)];\n    }\n\n    private void clearSegments() {\n        _hasSegments = false;\n        \n        \n        \n        _segments.clear();\n        _currentSize = _segmentSize = 0;\n    }\n\n    \n\n    \n    public int size() {\n        if (_inputStart >= 0) { \n            return _inputLen;\n        }\n        if (_resultArray != null) {\n            return _resultArray.length;\n        }\n        if (_resultString != null) {\n            return _resultString.length();\n        }\n        \n        return _segmentSize + _currentSize;\n    }\n\n    public int getTextOffset() {\n        \n        return (_inputStart >= 0) ? _inputStart : 0;\n    }\n\n    \n    public boolean hasTextAsCharacters() {\n        \n        if (_inputStart >= 0 || _resultArray != null)  return true;\n        \n        if (_resultString != null) return false;\n        return true;\n    }\n    \n    public char[] getTextBuffer() {\n        \n        if (_inputStart >= 0) return _inputBuffer;\n        if (_resultArray != null)  return _resultArray;\n        if (_resultString != null) {\n            return (_resultArray = _resultString.toCharArray());\n        }\n        \n        if (!_hasSegments)  return _currentSegment;\n        \n        return contentsAsArray();\n    }\n\n    \n\n    public String contentsAsString() {\n        if (_resultString == null) {\n            \n            if (_resultArray != null) {\n                _resultString = new String(_resultArray);\n            } else {\n                \n                if (_inputStart >= 0) {\n                    if (_inputLen < 1) {\n                        return (_resultString = \"\");\n                    }\n                    _resultString = new String(_inputBuffer, _inputStart, _inputLen);\n                } else { \n                    \n                    int segLen = _segmentSize;\n                    int currLen = _currentSize;\n                    \n                    if (segLen == 0) { \n                        _resultString = (currLen == 0) ? \"\" : new String(_currentSegment, 0, currLen);\n                    } else { \n                        StringBuilder sb = new StringBuilder(segLen + currLen);\n                        \n                        if (_segments != null) {\n                            for (int i = 0, len = _segments.size(); i < len; ++i) {\n                                char[] curr = _segments.get(i);\n                                sb.append(curr, 0, curr.length);\n                            }\n                        }\n                        \n                        sb.append(_currentSegment, 0, _currentSize);\n                        _resultString = sb.toString();\n                    }\n                }\n            }\n        }\n        return _resultString;\n    }\n \n    public char[] contentsAsArray() {\n        char[] result = _resultArray;\n        if (result == null) {\n            _resultArray = result = resultArray();\n        }\n        return result;\n    }\n\n    \n    public BigDecimal contentsAsDecimal() throws NumberFormatException {\n        \n        if (_resultArray != null) {\n            return NumberInput.parseBigDecimal(_resultArray);\n        }\n        \n        if ((_inputStart >= 0) && (_inputBuffer != null)) {\n            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);\n        }\n        \n        if ((_segmentSize == 0) && (_currentSegment != null)) {\n            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);\n        }\n        \n        return NumberInput.parseBigDecimal(contentsAsArray());\n    }\n\n    \n    public double contentsAsDouble() throws NumberFormatException {\n        return NumberInput.parseDouble(contentsAsString());\n    }\n\n    \n\n    \n    public void ensureNotShared() {\n        if (_inputStart >= 0) {\n            unshare(16);\n        }\n    }\n\n    public void append(char c) {\n        \n        if (_inputStart >= 0) {\n            unshare(16);\n        }\n        _resultString = null;\n        _resultArray = null;\n        \n        char[] curr = _currentSegment;\n        if (_currentSize >= curr.length) {\n            expand(1);\n            curr = _currentSegment;\n        }\n        curr[_currentSize++] = c;\n    }\n\n    public void append(char[] c, int start, int len) {\n        \n        if (_inputStart >= 0) {\n            unshare(len);\n        }\n        _resultString = null;\n        _resultArray = null;\n\n        \n        char[] curr = _currentSegment;\n        int max = curr.length - _currentSize;\n            \n        if (max >= len) {\n            System.arraycopy(c, start, curr, _currentSize, len);\n            _currentSize += len;\n            return;\n        }\n        \n        if (max > 0) {\n            System.arraycopy(c, start, curr, _currentSize, max);\n            start += max;\n            len -= max;\n        }\n        \n        \n        do {\n            expand(len);\n            int amount = Math.min(_currentSegment.length, len);\n            System.arraycopy(c, start, _currentSegment, 0, amount);\n            _currentSize += amount;\n            start += amount;\n            len -= amount;\n        } while (len > 0);\n    }\n\n    public void append(String str, int offset, int len) {\n        \n        if (_inputStart >= 0) {\n            unshare(len);\n        }\n        _resultString = null;\n        _resultArray = null;\n\n        \n        char[] curr = _currentSegment;\n        int max = curr.length - _currentSize;\n        if (max >= len) {\n            str.getChars(offset, offset+len, curr, _currentSize);\n            _currentSize += len;\n            return;\n        }\n        \n        if (max > 0) {\n            str.getChars(offset, offset+max, curr, _currentSize);\n            len -= max;\n            offset += max;\n        }\n        \n        \n        do {\n            expand(len);\n            int amount = Math.min(_currentSegment.length, len);\n            str.getChars(offset, offset+amount, _currentSegment, 0);\n            _currentSize += amount;\n            offset += amount;\n            len -= amount;\n        } while (len > 0);\n    }\n\n    \n\n    public char[] getCurrentSegment() {\n        \n        if (_inputStart >= 0) {\n            unshare(1);\n        } else {\n            char[] curr = _currentSegment;\n            if (curr == null) {\n                _currentSegment = buf(0);\n            } else if (_currentSize >= curr.length) {\n                \n                expand(1);\n            }\n        }\n        return _currentSegment;\n    }\n\n    public char[] emptyAndGetCurrentSegment() {\n        \n        _inputStart = -1; \n        _currentSize = 0;\n        _inputLen = 0;\n\n        _inputBuffer = null;\n        _resultString = null;\n        _resultArray = null;\n\n        \n        if (_hasSegments) {\n            clearSegments();\n        }\n        char[] curr = _currentSegment;\n        if (curr == null) {\n            _currentSegment = curr = buf(0);\n        }\n        return curr;\n    }\n\n    public int getCurrentSegmentSize() { return _currentSize; }\n    public void setCurrentLength(int len) { _currentSize = len; }\n\n    \n    public String setCurrentAndReturn(int len) {\n        _currentSize = len;\n        \n        if (_segmentSize > 0) { \n            return contentsAsString();\n        }\n        \n        int currLen = _currentSize;\n        String str = (currLen == 0) ? \"\" : new String(_currentSegment, 0, currLen);\n        _resultString = str;\n        return str;\n    }\n    \n    public char[] finishCurrentSegment() {\n        if (_segments == null) {\n            _segments = new ArrayList<char[]>();\n        }\n        _hasSegments = true;\n        _segments.add(_currentSegment);\n        int oldLen = _currentSegment.length;\n        _segmentSize += oldLen;\n        _currentSize = 0;\n\n        \n        int newLen = oldLen + (oldLen >> 1);\n        if (newLen < MIN_SEGMENT_LEN) {\n            newLen = MIN_SEGMENT_LEN;\n        } else if (newLen > MAX_SEGMENT_LEN) {\n            newLen = MAX_SEGMENT_LEN;\n        }\n        char[] curr = carr(newLen);\n        _currentSegment = curr;\n        return curr;\n    }\n\n    \n    public char[] expandCurrentSegment() {\n        final char[] curr = _currentSegment;\n        \n        final int len = curr.length;\n        int newLen = len + (len >> 1);\n        \n        if (newLen > MAX_SEGMENT_LEN) {\n            newLen = len + (len >> 2);\n        }\n        return (_currentSegment = Arrays.copyOf(curr, newLen));\n    }\n\n    \n    public char[] expandCurrentSegment(int minSize) {\n        char[] curr = _currentSegment;\n        if (curr.length >= minSize) return curr;\n        _currentSegment = curr = Arrays.copyOf(curr, minSize);\n        return curr;\n    }\n\n    \n\n    \n    @Override public String toString() { return contentsAsString(); }\n\n    \n\n    \n    private void unshare(int needExtra) {\n        int sharedLen = _inputLen;\n        _inputLen = 0;\n        char[] inputBuf = _inputBuffer;\n        _inputBuffer = null;\n        int start = _inputStart;\n        _inputStart = -1;\n\n        \n        int needed = sharedLen+needExtra;\n        if (_currentSegment == null || needed > _currentSegment.length) {\n            _currentSegment = buf(needed);\n        }\n        if (sharedLen > 0) {\n            System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen);\n        }\n        _segmentSize = 0;\n        _currentSize = sharedLen;\n    }\n\n    \n    private void expand(int minNewSegmentSize) {\n        \n        if (_segments == null) {\n            _segments = new ArrayList<char[]>();\n        }\n        char[] curr = _currentSegment;\n        _hasSegments = true;\n        _segments.add(curr);\n        _segmentSize += curr.length;\n        _currentSize = 0;\n        int oldLen = curr.length;\n        \n        \n        int newLen = oldLen + (oldLen >> 1);\n        if (newLen < MIN_SEGMENT_LEN) {\n            newLen = MIN_SEGMENT_LEN;\n        } else if (newLen > MAX_SEGMENT_LEN) {\n            newLen = MAX_SEGMENT_LEN;\n        }\n        _currentSegment = carr(newLen);\n    }\n\n    private char[] resultArray() {\n        if (_resultString != null) { \n            return _resultString.toCharArray();\n        }\n        \n        if (_inputStart >= 0) {\n            final int len = _inputLen;\n            if (len < 1) {\n                return NO_CHARS;\n            }\n            final int start = _inputStart;\n            if (start == 0) {\n                return Arrays.copyOf(_inputBuffer, len);\n            }\n            return Arrays.copyOfRange(_inputBuffer, start, start+len);\n        }\n        \n        int size = size();\n        if (size < 1) {\n            return NO_CHARS;\n        }\n        int offset = 0;\n        final char[] result = carr(size);\n        if (_segments != null) {\n            for (int i = 0, len = _segments.size(); i < len; ++i) {\n                char[] curr = _segments.get(i);\n                int currLen = curr.length;\n                System.arraycopy(curr, 0, result, offset, currLen);\n                offset += currLen;\n            }\n        }\n        System.arraycopy(_currentSegment, 0, result, offset, _currentSize);\n        return result;\n    }\n\n    private char[] carr(int len) { return new char[len]; }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.core.util;\n\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n\npublic final class TextBuffer { final static char[] NO_CHARS = new char[0]; final static int MIN_SEGMENT_LEN = 1000; final static int MAX_SEGMENT_LEN = 0x40000; private final BufferRecycler _allocator; private char[] _inputBuffer; private int _inputStart; private int _inputLen; private ArrayList<char[]> _segments; private boolean _hasSegments = false; private int _segmentSize; private char[] _currentSegment; private int _currentSize; private String _resultString; private char[] _resultArray; public TextBuffer(BufferRecycler allocator) {\n        _allocator = allocator;\n    }\n\n    \n    public void releaseBuffers() {\n        if (_allocator == null) {\n            resetWithEmpty();\n        } else {\n            if (_currentSegment != null) {\n                \n                resetWithEmpty();\n                \n                char[] buf = _currentSegment;\n                _currentSegment = null;\n                _allocator.releaseCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, buf);\n            }\n        }\n    }\n\n    \n    public void resetWithEmpty() {\n        _inputStart = -1; \n        _currentSize = 0;\n        _inputLen = 0;\n\n        _inputBuffer = null;\n        _resultString = null;\n        _resultArray = null;\n\n        \n        if (_hasSegments) {\n            clearSegments();\n        }\n    }\n\n    \n    public void resetWithShared(char[] buf, int start, int len) {\n        \n        _resultString = null;\n        _resultArray = null;\n\n        \n        _inputBuffer = buf;\n        _inputStart = start;\n        _inputLen = len;\n\n        \n        if (_hasSegments) {\n            clearSegments();\n        }\n    }\n\n    public void resetWithCopy(char[] buf, int start, int len) {\n        _inputBuffer = null;\n        _inputStart = -1; \n        _inputLen = 0;\n\n        _resultString = null;\n        _resultArray = null;\n\n        \n        if (_hasSegments) {\n            clearSegments();\n        } else if (_currentSegment == null) {\n            _currentSegment = buf(len);\n        }\n        _currentSize = _segmentSize = 0;\n        append(buf, start, len);\n    }\n\n    public void resetWithString(String value) {\n        _inputBuffer = null;\n        _inputStart = -1;\n        _inputLen = 0;\n\n        _resultString = value;\n        _resultArray = null;\n\n        if (_hasSegments) {\n            clearSegments();\n        }\n        _currentSize = 0;\n        \n    }\n    \n    \n    private char[] buf(int needed) {\n        if (_allocator != null) {\n            return _allocator.allocCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, needed);\n        }\n        return new char[Math.max(needed, MIN_SEGMENT_LEN)];\n    }\n\n    private void clearSegments() {\n        _hasSegments = false;\n        \n        \n        \n        _segments.clear();\n        _currentSize = _segmentSize = 0;\n    }\n\n    \n\n    \n    public int size() {\n        if (_inputStart >= 0) { \n            return _inputLen;\n        }\n        if (_resultArray != null) {\n            return _resultArray.length;\n        }\n        if (_resultString != null) {\n            return _resultString.length();\n        }\n        \n        return _segmentSize + _currentSize;\n    }\n\n    public int getTextOffset() {\n        \n        return (_inputStart >= 0) ? _inputStart : 0;\n    }\n\n    \n    public boolean hasTextAsCharacters() {\n        \n        if (_inputStart >= 0 || _resultArray != null)  return true;\n        \n        if (_resultString != null) return false;\n        return true;\n    }\n    \n    public char[] getTextBuffer() {\n        \n        if (_inputStart >= 0) return _inputBuffer;\n        if (_resultArray != null)  return _resultArray;\n        if (_resultString != null) {\n            return (_resultArray = _resultString.toCharArray());\n        }\n        \n        if (!_hasSegments && _currentSegment != null)  return _currentSegment;\n        \n        return contentsAsArray();\n    }\n\n    \n\n    public String contentsAsString() {\n        if (_resultString == null) {\n            \n            if (_resultArray != null) {\n                _resultString = new String(_resultArray);\n            } else {\n                \n                if (_inputStart >= 0) {\n                    if (_inputLen < 1) {\n                        return (_resultString = \"\");\n                    }\n                    _resultString = new String(_inputBuffer, _inputStart, _inputLen);\n                } else { \n                    \n                    int segLen = _segmentSize;\n                    int currLen = _currentSize;\n                    \n                    if (segLen == 0) { \n                        _resultString = (currLen == 0) ? \"\" : new String(_currentSegment, 0, currLen);\n                    } else { \n                        StringBuilder sb = new StringBuilder(segLen + currLen);\n                        \n                        if (_segments != null) {\n                            for (int i = 0, len = _segments.size(); i < len; ++i) {\n                                char[] curr = _segments.get(i);\n                                sb.append(curr, 0, curr.length);\n                            }\n                        }\n                        \n                        sb.append(_currentSegment, 0, _currentSize);\n                        _resultString = sb.toString();\n                    }\n                }\n            }\n        }\n        return _resultString;\n    }\n \n    public char[] contentsAsArray() {\n        char[] result = _resultArray;\n        if (result == null) {\n            _resultArray = result = resultArray();\n        }\n        return result;\n    }\n\n    \n    public BigDecimal contentsAsDecimal() throws NumberFormatException {\n        \n        if (_resultArray != null) {\n            return NumberInput.parseBigDecimal(_resultArray);\n        }\n        \n        if ((_inputStart >= 0) && (_inputBuffer != null)) {\n            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);\n        }\n        \n        if ((_segmentSize == 0) && (_currentSegment != null)) {\n            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);\n        }\n        \n        return NumberInput.parseBigDecimal(contentsAsArray());\n    }\n\n    \n    public double contentsAsDouble() throws NumberFormatException {\n        return NumberInput.parseDouble(contentsAsString());\n    }\n\n    \n\n    \n    public void ensureNotShared() {\n        if (_inputStart >= 0) {\n            unshare(16);\n        }\n    }\n\n    public void append(char c) {\n        \n        if (_inputStart >= 0) {\n            unshare(16);\n        }\n        _resultString = null;\n        _resultArray = null;\n        \n        char[] curr = _currentSegment;\n        if (_currentSize >= curr.length) {\n            expand(1);\n            curr = _currentSegment;\n        }\n        curr[_currentSize++] = c;\n    }\n\n    public void append(char[] c, int start, int len) {\n        \n        if (_inputStart >= 0) {\n            unshare(len);\n        }\n        _resultString = null;\n        _resultArray = null;\n\n        \n        char[] curr = _currentSegment;\n        int max = curr.length - _currentSize;\n            \n        if (max >= len) {\n            System.arraycopy(c, start, curr, _currentSize, len);\n            _currentSize += len;\n            return;\n        }\n        \n        if (max > 0) {\n            System.arraycopy(c, start, curr, _currentSize, max);\n            start += max;\n            len -= max;\n        }\n        \n        \n        do {\n            expand(len);\n            int amount = Math.min(_currentSegment.length, len);\n            System.arraycopy(c, start, _currentSegment, 0, amount);\n            _currentSize += amount;\n            start += amount;\n            len -= amount;\n        } while (len > 0);\n    }\n\n    public void append(String str, int offset, int len) {\n        \n        if (_inputStart >= 0) {\n            unshare(len);\n        }\n        _resultString = null;\n        _resultArray = null;\n\n        \n        char[] curr = _currentSegment;\n        int max = curr.length - _currentSize;\n        if (max >= len) {\n            str.getChars(offset, offset+len, curr, _currentSize);\n            _currentSize += len;\n            return;\n        }\n        \n        if (max > 0) {\n            str.getChars(offset, offset+max, curr, _currentSize);\n            len -= max;\n            offset += max;\n        }\n        \n        \n        do {\n            expand(len);\n            int amount = Math.min(_currentSegment.length, len);\n            str.getChars(offset, offset+amount, _currentSegment, 0);\n            _currentSize += amount;\n            offset += amount;\n            len -= amount;\n        } while (len > 0);\n    }\n\n    \n\n    public char[] getCurrentSegment() {\n        \n        if (_inputStart >= 0) {\n            unshare(1);\n        } else {\n            char[] curr = _currentSegment;\n            if (curr == null) {\n                _currentSegment = buf(0);\n            } else if (_currentSize >= curr.length) {\n                \n                expand(1);\n            }\n        }\n        return _currentSegment;\n    }\n\n    public char[] emptyAndGetCurrentSegment() {\n        \n        _inputStart = -1; \n        _currentSize = 0;\n        _inputLen = 0;\n\n        _inputBuffer = null;\n        _resultString = null;\n        _resultArray = null;\n\n        \n        if (_hasSegments) {\n            clearSegments();\n        }\n        char[] curr = _currentSegment;\n        if (curr == null) {\n            _currentSegment = curr = buf(0);\n        }\n        return curr;\n    }\n\n    public int getCurrentSegmentSize() { return _currentSize; }\n    public void setCurrentLength(int len) { _currentSize = len; }\n\n    \n    public String setCurrentAndReturn(int len) {\n        _currentSize = len;\n        \n        if (_segmentSize > 0) { \n            return contentsAsString();\n        }\n        \n        int currLen = _currentSize;\n        String str = (currLen == 0) ? \"\" : new String(_currentSegment, 0, currLen);\n        _resultString = str;\n        return str;\n    }\n    \n    public char[] finishCurrentSegment() {\n        if (_segments == null) {\n            _segments = new ArrayList<char[]>();\n        }\n        _hasSegments = true;\n        _segments.add(_currentSegment);\n        int oldLen = _currentSegment.length;\n        _segmentSize += oldLen;\n        _currentSize = 0;\n\n        \n        int newLen = oldLen + (oldLen >> 1);\n        if (newLen < MIN_SEGMENT_LEN) {\n            newLen = MIN_SEGMENT_LEN;\n        } else if (newLen > MAX_SEGMENT_LEN) {\n            newLen = MAX_SEGMENT_LEN;\n        }\n        char[] curr = carr(newLen);\n        _currentSegment = curr;\n        return curr;\n    }\n\n    \n    public char[] expandCurrentSegment() {\n        final char[] curr = _currentSegment;\n        \n        final int len = curr.length;\n        int newLen = len + (len >> 1);\n        \n        if (newLen > MAX_SEGMENT_LEN) {\n            newLen = len + (len >> 2);\n        }\n        return (_currentSegment = Arrays.copyOf(curr, newLen));\n    }\n\n    \n    public char[] expandCurrentSegment(int minSize) {\n        char[] curr = _currentSegment;\n        if (curr.length >= minSize) return curr;\n        _currentSegment = curr = Arrays.copyOf(curr, minSize);\n        return curr;\n    }\n\n    \n\n    \n    @Override public String toString() { return contentsAsString(); }\n\n    \n\n    \n    private void unshare(int needExtra) {\n        int sharedLen = _inputLen;\n        _inputLen = 0;\n        char[] inputBuf = _inputBuffer;\n        _inputBuffer = null;\n        int start = _inputStart;\n        _inputStart = -1;\n\n        \n        int needed = sharedLen+needExtra;\n        if (_currentSegment == null || needed > _currentSegment.length) {\n            _currentSegment = buf(needed);\n        }\n        if (sharedLen > 0) {\n            System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen);\n        }\n        _segmentSize = 0;\n        _currentSize = sharedLen;\n    }\n\n    \n    private void expand(int minNewSegmentSize) {\n        \n        if (_segments == null) {\n            _segments = new ArrayList<char[]>();\n        }\n        char[] curr = _currentSegment;\n        _hasSegments = true;\n        _segments.add(curr);\n        _segmentSize += curr.length;\n        _currentSize = 0;\n        int oldLen = curr.length;\n        \n        \n        int newLen = oldLen + (oldLen >> 1);\n        if (newLen < MIN_SEGMENT_LEN) {\n            newLen = MIN_SEGMENT_LEN;\n        } else if (newLen > MAX_SEGMENT_LEN) {\n            newLen = MAX_SEGMENT_LEN;\n        }\n        _currentSegment = carr(newLen);\n    }\n\n    private char[] resultArray() {\n        if (_resultString != null) { \n            return _resultString.toCharArray();\n        }\n        \n        if (_inputStart >= 0) {\n            final int len = _inputLen;\n            if (len < 1) {\n                return NO_CHARS;\n            }\n            final int start = _inputStart;\n            if (start == 0) {\n                return Arrays.copyOf(_inputBuffer, len);\n            }\n            return Arrays.copyOfRange(_inputBuffer, start, start+len);\n        }\n        \n        int size = size();\n        if (size < 1) {\n            return NO_CHARS;\n        }\n        int offset = 0;\n        final char[] result = carr(size);\n        if (_segments != null) {\n            for (int i = 0, len = _segments.size(); i < len; ++i) {\n                char[] curr = _segments.get(i);\n                int currLen = curr.length;\n                System.arraycopy(curr, 0, result, offset, currLen);\n                offset += currLen;\n            }\n        }\n        System.arraycopy(_currentSegment, 0, result, offset, _currentSize);\n        return result;\n    }\n\n    private char[] carr(int len) { return new char[len]; }\n}\n",
      "buggy_signatures": [
        "public void releaseBuffers()",
        "public void resetWithEmpty()",
        "public void resetWithShared(char[] buf, int start, int len)",
        "public void resetWithCopy(char[] buf, int start, int len)",
        "public void resetWithString(String value)",
        "private char[] buf(int needed)",
        "private void clearSegments()",
        "public int size()",
        "public int getTextOffset()",
        "public boolean hasTextAsCharacters()",
        "public char[] getTextBuffer()",
        "public String contentsAsString()",
        "public char[] contentsAsArray()",
        "public BigDecimal contentsAsDecimal() throws NumberFormatException",
        "public double contentsAsDouble() throws NumberFormatException",
        "public void ensureNotShared()",
        "public void append(char c)",
        "public void append(char[] c, int start, int len)",
        "public void append(String str, int offset, int len)",
        "public char[] getCurrentSegment()",
        "public char[] emptyAndGetCurrentSegment()",
        "public int getCurrentSegmentSize()",
        "public void setCurrentLength(int len)",
        "public String setCurrentAndReturn(int len)",
        "public char[] finishCurrentSegment()",
        "public char[] expandCurrentSegment()",
        "public char[] expandCurrentSegment(int minSize)",
        "public String toString()",
        "private void unshare(int needExtra)",
        "private void expand(int minNewSegmentSize)",
        "private char[] resultArray()",
        "private char[] carr(int len)"
      ],
      "fixed_signatures": [
        "public void releaseBuffers()",
        "public void resetWithEmpty()",
        "public void resetWithShared(char[] buf, int start, int len)",
        "public void resetWithCopy(char[] buf, int start, int len)",
        "public void resetWithString(String value)",
        "private char[] buf(int needed)",
        "private void clearSegments()",
        "public int size()",
        "public int getTextOffset()",
        "public boolean hasTextAsCharacters()",
        "public char[] getTextBuffer()",
        "public String contentsAsString()",
        "public char[] contentsAsArray()",
        "public BigDecimal contentsAsDecimal() throws NumberFormatException",
        "public double contentsAsDouble() throws NumberFormatException",
        "public void ensureNotShared()",
        "public void append(char c)",
        "public void append(char[] c, int start, int len)",
        "public void append(String str, int offset, int len)",
        "public char[] getCurrentSegment()",
        "public char[] emptyAndGetCurrentSegment()",
        "public int getCurrentSegmentSize()",
        "public void setCurrentLength(int len)",
        "public String setCurrentAndReturn(int len)",
        "public char[] finishCurrentSegment()",
        "public char[] expandCurrentSegment()",
        "public char[] expandCurrentSegment(int minSize)",
        "public String toString()",
        "private void unshare(int needExtra)",
        "private void expand(int minNewSegmentSize)",
        "private char[] resultArray()",
        "private char[] carr(int len)"
      ],
      "methods": [
        {
          "buggy_method": "  public char[] getTextBuffer() {\n  \n  if (_inputStart >= 0) return _inputBuffer;\n  if (_resultArray != null)  return _resultArray;\n  if (_resultString != null) {\n  return (_resultArray = _resultString.toCharArray());\n  }\n  \n  if (!_hasSegments)  return _currentSegment;\n  \n  return contentsAsArray();\n  }",
          "fixed_method": "  public char[] getTextBuffer() {\n  \n  if (_inputStart >= 0) return _inputBuffer;\n  if (_resultArray != null)  return _resultArray;\n  if (_resultString != null) {\n  return (_resultArray = _resultString.toCharArray());\n  }\n  \n  if (!_hasSegments && _currentSegment != null)  return _currentSegment;\n  \n  return contentsAsArray();\n  }",
          "diff": [
            "@@ -304,7 +304,7 @@",
            "             return (_resultArray = _resultString.toCharArray());\n",
            "         }\n",
            "         // Nope; but does it fit in just one segment?\n",
            "-        if (!_hasSegments)  return _currentSegment;\n",
            "+        if (!_hasSegments && _currentSegment != null)  return _currentSegment;\n",
            "         // Nope, need to have/create a non-segmented array and return it\n",
            "         return contentsAsArray();\n",
            "     }\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
