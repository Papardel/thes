{
  "bug_id": "7",
  "failed_tests": {
    "org.apache.commons.compress.archivers.tar.TarUtilsTest": [
      {
        "methodName": "testRoundTripNames",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<0302-0601-3[±±±F06±W220±ZB±LALALA±±±±±±±±±±CAN±±DC±±±04±060302±]MOE.model> but was:<0302-0601-3[ﾱﾱﾱF06ﾱW220ﾱZBﾱLALALAﾱﾱﾱﾱﾱﾱﾱﾱﾱﾱCANﾱﾱDCﾱﾱﾱ04ﾱ060302ﾱ]MOE.model>",
        "fail_line": "        checkName(\"0302-0601-3���F06�W220�ZB�LALALA����������CAN��DC���04�060302�MOE.model\");",
        "test_source": "  public void testRoundTripNames() {\n  checkName(\"\");\n  checkName(\"The quick brown fox\\n\");\n  checkName(\"\\177\");\n  // checkName(\"\\0\"); // does not work, because NUL is ignored\n  // COMPRESS-114\n  checkName(\"0302-0601-3���F06�W220�ZB�LALALA����������CAN��DC���04�060302�MOE.model\");\n  }",
        "stack": [
          "TarUtilsTest.checkName line 132, TarUtilsTest.testRoundTripNames line 126"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/compress/archivers/tar/TarUtils.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.tar;\n\n\n\npublic class TarUtils { private static final int BYTE_MASK = 255; private TarUtils() {    \n    }\n\n    \n    public static long parseOctal(byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        boolean stillPadding = true;\n        int     end = offset + length;\n\n        for (int i = offset; i < end; ++i) {\n            final byte currentByte = buffer[i];\n            if (currentByte == 0) { \n                break;\n            }\n\n            \n            if (currentByte == (byte) ' ' || currentByte == '0') {\n                if (stillPadding) {\n                    continue;\n                }\n\n                if (currentByte == (byte) ' ') { \n                    break;\n                }\n            }\n\n            stillPadding = false;\n            \n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        \"Invalid octal digit at position \"+i+\" in '\"+new String(buffer, offset, length)+\"'\");\n            }\n            result = (result << 3) + (currentByte - '0');\n            \n        }\n\n        return result;\n    }\n\n    \n    public static String parseName(byte[] buffer, final int offset, final int length) {\n        StringBuffer result = new StringBuffer(length);\n        int          end = offset + length;\n\n        for (int i = offset; i < end; ++i) {\n            if (buffer[i] == 0) {\n                break;\n            }\n            result.append((char) buffer[i]);\n        }\n\n        return result.toString();\n    }\n\n    \n    public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {\n        int i;\n\n        \n        for (i = 0; i < length && i < name.length(); ++i) {\n            buf[offset + i] = (byte) name.charAt(i);\n        }\n\n        \n        for (; i < length; ++i) {\n            buf[offset + i] = 0;\n        }\n\n        return offset + length;\n    }\n\n    \n    public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) {\n        int remaining = length;\n        remaining--;\n        if (value == 0) {\n            buffer[offset + remaining--] = (byte) '0';\n        } else {\n            long val = value;\n            for (; remaining >= 0 && val != 0; --remaining) {\n                \n                buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));\n                val = val >>> 3;\n                \n            }\n            if (val != 0){\n                throw new IllegalArgumentException\n                (value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length);\n            }\n        }\n\n        for (; remaining >= 0; --remaining) { \n            buffer[offset + remaining] = (byte) '0';\n        }\n    }\n\n    \n    public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-2; \n        formatUnsignedOctalString(value, buf, offset, idx);\n\n        buf[offset + idx++] = (byte) ' '; \n        buf[offset + idx]   = 0; \n\n        return offset + length;\n    }\n\n    \n    public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-1; \n        \n        formatUnsignedOctalString(value, buf, offset, idx);\n        buf[offset + idx] = (byte) ' '; \n\n        return offset + length;\n    }\n\n    \n    public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-2; \n        formatUnsignedOctalString(value, buf, offset, idx);\n\n        buf[offset + idx++]   = 0; \n        buf[offset + idx]     = (byte) ' '; \n\n        return offset + length;\n    }\n\n    \n    public static long computeCheckSum(final byte[] buf) {\n        long sum = 0;\n\n        for (int i = 0; i < buf.length; ++i) {\n            sum += BYTE_MASK & buf[i];\n        }\n\n        return sum;\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.tar;\n\n\n\npublic class TarUtils { private static final int BYTE_MASK = 255; private TarUtils() {    \n    }\n\n    \n    public static long parseOctal(byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        boolean stillPadding = true;\n        int     end = offset + length;\n\n        for (int i = offset; i < end; ++i) {\n            final byte currentByte = buffer[i];\n            if (currentByte == 0) { \n                break;\n            }\n\n            \n            if (currentByte == (byte) ' ' || currentByte == '0') {\n                if (stillPadding) {\n                    continue;\n                }\n\n                if (currentByte == (byte) ' ') { \n                    break;\n                }\n            }\n\n            stillPadding = false;\n            \n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        \"Invalid octal digit at position \"+i+\" in '\"+new String(buffer, offset, length)+\"'\");\n            }\n            result = (result << 3) + (currentByte - '0');\n            \n        }\n\n        return result;\n    }\n\n    \n    public static String parseName(byte[] buffer, final int offset, final int length) {\n        StringBuffer result = new StringBuffer(length);\n        int          end = offset + length;\n\n        for (int i = offset; i < end; ++i) {\n            byte b = buffer[i];\n            if (b == 0) { \n                break;\n            }\n            result.append((char) (b & 0xFF)); \n        }\n\n        return result.toString();\n    }\n\n    \n    public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {\n        int i;\n\n        \n        for (i = 0; i < length && i < name.length(); ++i) {\n            buf[offset + i] = (byte) name.charAt(i);\n        }\n\n        \n        for (; i < length; ++i) {\n            buf[offset + i] = 0;\n        }\n\n        return offset + length;\n    }\n\n    \n    public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) {\n        int remaining = length;\n        remaining--;\n        if (value == 0) {\n            buffer[offset + remaining--] = (byte) '0';\n        } else {\n            long val = value;\n            for (; remaining >= 0 && val != 0; --remaining) {\n                \n                buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));\n                val = val >>> 3;\n                \n            }\n            if (val != 0){\n                throw new IllegalArgumentException\n                (value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length);\n            }\n        }\n\n        for (; remaining >= 0; --remaining) { \n            buffer[offset + remaining] = (byte) '0';\n        }\n    }\n\n    \n    public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-2; \n        formatUnsignedOctalString(value, buf, offset, idx);\n\n        buf[offset + idx++] = (byte) ' '; \n        buf[offset + idx]   = 0; \n\n        return offset + length;\n    }\n\n    \n    public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-1; \n        \n        formatUnsignedOctalString(value, buf, offset, idx);\n        buf[offset + idx] = (byte) ' '; \n\n        return offset + length;\n    }\n\n    \n    public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-2; \n        formatUnsignedOctalString(value, buf, offset, idx);\n\n        buf[offset + idx++]   = 0; \n        buf[offset + idx]     = (byte) ' '; \n\n        return offset + length;\n    }\n\n    \n    public static long computeCheckSum(final byte[] buf) {\n        long sum = 0;\n\n        for (int i = 0; i < buf.length; ++i) {\n            sum += BYTE_MASK & buf[i];\n        }\n\n        return sum;\n    }\n}\n",
      "buggy_signatures": [
        "public static long parseOctal(byte[] buffer, final int offset, final int length)",
        "public static String parseName(byte[] buffer, final int offset, final int length)",
        "public static int formatNameBytes(String name, byte[] buf, final int offset, final int length)",
        "public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length)",
        "public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length)",
        "public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length)",
        "public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length)",
        "public static long computeCheckSum(final byte[] buf)"
      ],
      "fixed_signatures": [
        "public static long parseOctal(byte[] buffer, final int offset, final int length)",
        "public static String parseName(byte[] buffer, final int offset, final int length)",
        "public static int formatNameBytes(String name, byte[] buf, final int offset, final int length)",
        "public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length)",
        "public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length)",
        "public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length)",
        "public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length)",
        "public static long computeCheckSum(final byte[] buf)"
      ],
      "methods": [
        {
          "buggy_method": "  public static String parseName(byte[] buffer, final int offset, final int length) {\n  StringBuffer result = new StringBuffer(length);\n  int  end = offset + length;\n\n  for (int i = offset; i < end; ++i) {\n  if (buffer[i] == 0) {\n  break;\n  }\n  result.append((char) buffer[i]);\n  }\n\n  return result.toString();\n  }",
          "fixed_method": "  public static String parseName(byte[] buffer, final int offset, final int length) {\n  StringBuffer result = new StringBuffer(length);\n  int  end = offset + length;\n\n  for (int i = offset; i < end; ++i) {\n  byte b = buffer[i];\n  if (b == 0) { \n  break;\n  }\n  result.append((char) (b & 0xFF)); \n  }\n\n  return result.toString();\n  }",
          "diff": [
            "@@ -95,10 +95,11 @@",
            "         int          end = offset + length;\n",
            " \n",
            "         for (int i = offset; i < end; ++i) {\n",
            "-            if (buffer[i] == 0) {\n",
            "+            byte b = buffer[i];\n",
            "+            if (b == 0) { // Trailing null\n",
            "                 break;\n",
            "             }\n",
            "-            result.append((char) buffer[i]);\n",
            "+            result.append((char) (b & 0xFF)); // Allow for sign-extension\n",
            "         }\n",
            " \n",
            "         return result.toString();\n"
          ],
          "changed_lines": 5
        }
      ]
    }
  ]
}
