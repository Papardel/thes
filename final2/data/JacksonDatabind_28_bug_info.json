{
  "bug_id": "28",
  "failed_tests": {
    "com.fasterxml.jackson.databind.node.TestObjectNode": [
      {
        "methodName": "testIssue941",
        "error": "com.fasterxml.jackson.databind.JsonMappingException",
        "message": "Can not deserialize instance of com.fasterxml.jackson.databind.node.ObjectNode out of END_OBJECT token",
        "fail_line": "        MyValue de2 = MAPPER.readValue(json, MyValue.class);  // but this throws exception",
        "test_source": "  public void testIssue941() throws Exception {\n  ObjectNode object = MAPPER.createObjectNode();\n\n  String json = MAPPER.writeValueAsString(object);\n  System.out.println(\"json: \"+json);\n\n  ObjectNode de1 = MAPPER.readValue(json, ObjectNode.class);  // this works\n  System.out.println(\"Deserialized to ObjectNode: \"+de1);\n\n  MyValue de2 = MAPPER.readValue(json, MyValue.class);  // but this throws exception\n  System.out.println(\"Deserialized to MyValue: \"+de2);\n  }",
        "stack": [
          "JsonMappingException.from line 148, DeserializationContext.mappingException line 854, DeserializationContext.mappingException line 850, JsonNodeDeserializer$ObjectDeserializer.deserialize line 106, JsonNodeDeserializer$ObjectDeserializer.deserialize line 83, BeanDeserializerBase.deserializeFromObjectUsingNonDefault line 1096, BeanDeserializer.deserializeFromObject line 296, BeanDeserializer.deserialize line 133, ObjectMapper._readMapAndClose line 3731, ObjectMapper.readValue line 2724, TestObjectNode.testIssue941 line 411"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.node.*;\nimport com.fasterxml.jackson.databind.util.RawValue;\n\n\n@SuppressWarnings(\"serial\")\npublic class JsonNodeDeserializer extends BaseNodeDeserializer<JsonNode> { private final static JsonNodeDeserializer instance = new JsonNodeDeserializer(); protected JsonNodeDeserializer() { super(JsonNode.class); }\n\n    \n    public static JsonDeserializer<? extends JsonNode> getDeserializer(Class<?> nodeClass) {\n        if (nodeClass == ObjectNode.class) {\n            return ObjectDeserializer.getInstance();\n        }\n        if (nodeClass == ArrayNode.class) {\n            return ArrayDeserializer.getInstance();\n        }\n        \n        return instance;\n    }\n    \n    \n\n    @Override\n    public JsonNode getNullValue(DeserializationContext ctxt) {\n        return NullNode.getInstance();\n    }\n\n    @Override\n    @Deprecated \n    public JsonNode getNullValue() {\n        return NullNode.getInstance();\n    }\n\n    \n    @Override\n    public JsonNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n            return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n        case JsonTokenId.ID_START_ARRAY:\n            return deserializeArray(p, ctxt, ctxt.getNodeFactory());\n        default:\n            return deserializeAny(p, ctxt, ctxt.getNodeFactory());\n        }\n    }\n\n    \n\n    final static class ObjectDeserializer extends BaseNodeDeserializer<ObjectNode> { private static final long serialVersionUID = 1L; protected final static ObjectDeserializer _instance = new ObjectDeserializer(); protected ObjectDeserializer() { super(ObjectNode.class); }\n\n        public static ObjectDeserializer getInstance() { return _instance; }\n        \n        @Override\n        public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n                p.nextToken();\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            \n            \n            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            throw ctxt.mappingException(ObjectNode.class);\n         }\n    }\n        \n    final static class ArrayDeserializer extends BaseNodeDeserializer<ArrayNode> { private static final long serialVersionUID = 1L; protected final static ArrayDeserializer _instance = new ArrayDeserializer(); protected ArrayDeserializer() { super(ArrayNode.class); }\n\n        public static ArrayDeserializer getInstance() { return _instance; }\n        \n        @Override\n        public ArrayNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n            if (p.isExpectedStartArrayToken()) {\n                return deserializeArray(p, ctxt, ctxt.getNodeFactory());\n            }\n            throw ctxt.mappingException(ArrayNode.class);\n        }\n    }\n}\n\n\n@SuppressWarnings(\"serial\")\nabstract class BaseNodeDeserializer<T extends JsonNode> extends StdDeserializer<T> { public BaseNodeDeserializer(Class<T> vc) {\n        super(vc);\n    }\n\n    @Override\n    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n        \n        return typeDeserializer.deserializeTypedFromAny(p, ctxt);\n    }\n\n    \n    @Override\n    public boolean isCachable() { return true; }\n\n    \n\n    protected void _reportProblem(JsonParser p, String msg) throws JsonMappingException {\n        throw new JsonMappingException(msg, p.getTokenLocation());\n    }\n\n    \n    protected void _handleDuplicateField(JsonParser p, DeserializationContext ctxt, JsonNodeFactory nodeFactory, String fieldName, ObjectNode objectNode, JsonNode oldValue, JsonNode newValue) throws JsonProcessingException {\n        \n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_READING_DUP_TREE_KEY)) {\n            _reportProblem(p, \"Duplicate field '\"+fieldName+\"' for ObjectNode: not allowed when FAIL_ON_READING_DUP_TREE_KEY enabled\");\n        }\n    }\n\n    \n\n    protected final ObjectNode deserializeObject(JsonParser p, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException {\n        ObjectNode node = nodeFactory.objectNode();\n        String key;\n        if (p.isExpectedStartObjectToken()) {\n            key = p.nextFieldName();\n        } else {\n            JsonToken t = p.getCurrentToken();\n            if (t == JsonToken.END_OBJECT) {\n                return node;\n            }\n            if (t != JsonToken.FIELD_NAME) {\n                throw ctxt.mappingException(handledType(), p.getCurrentToken());\n            }\n            key = p.getCurrentName();\n        }\n        for (; key != null; key = p.nextFieldName()) {\n            JsonNode value;\n            JsonToken t = p.nextToken();\n            switch (t.id()) {\n            case JsonTokenId.ID_START_OBJECT:\n                value = deserializeObject(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_START_ARRAY:\n                value = deserializeArray(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_EMBEDDED_OBJECT:\n                value = _fromEmbedded(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_STRING:\n                value = nodeFactory.textNode(p.getText());\n                break;\n            case JsonTokenId.ID_NUMBER_INT:\n                value = _fromInt(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_TRUE:\n                value = nodeFactory.booleanNode(true);\n                break;\n            case JsonTokenId.ID_FALSE:\n                value = nodeFactory.booleanNode(false);\n                break;\n            case JsonTokenId.ID_NULL:\n                value = nodeFactory.nullNode();\n                break;\n            default:\n                value = deserializeAny(p, ctxt, nodeFactory);\n            }\n            JsonNode old = node.replace(key, value);\n            if (old != null) {\n                _handleDuplicateField(p, ctxt, nodeFactory,\n                        key, node, old, value);\n            }\n        }\n        return node;\n    }\n\n    protected final ArrayNode deserializeArray(JsonParser p, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException {\n        ArrayNode node = nodeFactory.arrayNode();\n        while (true) {\n            JsonToken t = p.nextToken();\n            if (t == null) {\n                throw ctxt.mappingException(\"Unexpected end-of-input when binding data into ArrayNode\");\n            }\n            switch (t.id()) {\n            case JsonTokenId.ID_START_OBJECT:\n                node.add(deserializeObject(p, ctxt, nodeFactory));\n                break;\n            case JsonTokenId.ID_START_ARRAY:\n                node.add(deserializeArray(p, ctxt, nodeFactory));\n                break;\n            case JsonTokenId.ID_END_ARRAY:\n                return node;\n            case JsonTokenId.ID_EMBEDDED_OBJECT:\n                node.add(_fromEmbedded(p, ctxt, nodeFactory));\n            case JsonTokenId.ID_STRING:\n                node.add(nodeFactory.textNode(p.getText()));\n                break;\n            case JsonTokenId.ID_NUMBER_INT:\n                node.add(_fromInt(p, ctxt, nodeFactory));\n                break;\n            case JsonTokenId.ID_TRUE:\n                node.add(nodeFactory.booleanNode(true));\n                break;\n            case JsonTokenId.ID_FALSE:\n                node.add(nodeFactory.booleanNode(false));\n                break;\n            case JsonTokenId.ID_NULL:\n                node.add(nodeFactory.nullNode());\n                break;\n            default:\n                node.add(deserializeAny(p, ctxt, nodeFactory));\n                break;\n            }\n        }\n    }\n\n    protected final JsonNode deserializeAny(JsonParser p, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException {\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_END_OBJECT: \n            return deserializeObject(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_START_ARRAY:\n            return deserializeArray(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_FIELD_NAME:\n            return deserializeObject(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return _fromEmbedded(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_STRING:\n            return nodeFactory.textNode(p.getText());\n        case JsonTokenId.ID_NUMBER_INT:\n            return _fromInt(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            return _fromFloat(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_TRUE:\n            return nodeFactory.booleanNode(true);\n        case JsonTokenId.ID_FALSE:\n            return nodeFactory.booleanNode(false);\n        case JsonTokenId.ID_NULL:\n            return nodeFactory.nullNode();\n            \n            \n            \n\n        \n        \n        default:\n            throw ctxt.mappingException(handledType());\n        }\n    }\n\n    protected final JsonNode _fromInt(JsonParser p, DeserializationContext ctxt, JsonNodeFactory nodeFactory) throws IOException {\n        JsonParser.NumberType nt;\n        int feats = ctxt.getDeserializationFeatures();\n        if ((feats & F_MASK_INT_COERCIONS) != 0) {\n            if (DeserializationFeature.USE_BIG_INTEGER_FOR_INTS.enabledIn(feats)) {\n                nt = JsonParser.NumberType.BIG_INTEGER;\n            } else if (DeserializationFeature.USE_LONG_FOR_INTS.enabledIn(feats)) {\n                nt = JsonParser.NumberType.LONG;\n            } else {\n                nt = p.getNumberType();\n            }\n        } else {\n            nt = p.getNumberType();\n        }\n        if (nt == JsonParser.NumberType.INT) {\n            return nodeFactory.numberNode(p.getIntValue());\n        }\n        if (nt == JsonParser.NumberType.LONG) {\n            return nodeFactory.numberNode(p.getLongValue());\n        }\n        return nodeFactory.numberNode(p.getBigIntegerValue());\n    }\n\n    protected final JsonNode _fromFloat(JsonParser p, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException {\n        JsonParser.NumberType nt = p.getNumberType();\n        if (nt == JsonParser.NumberType.BIG_DECIMAL\n            || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n            return nodeFactory.numberNode(p.getDecimalValue());\n        }\n        return nodeFactory.numberNode(p.getDoubleValue());\n    }\n\n    protected final JsonNode _fromEmbedded(JsonParser p, DeserializationContext ctxt, JsonNodeFactory nodeFactory) throws IOException {\n        \n        Object ob = p.getEmbeddedObject();\n        if (ob == null) { \n            return nodeFactory.nullNode();\n        }\n        Class<?> type = ob.getClass();\n        if (type == byte[].class) { \n            return nodeFactory.binaryNode((byte[]) ob);\n        }\n        \n        if (ob instanceof RawValue) {\n            return nodeFactory.rawValueNode((RawValue) ob);\n        }\n        if (ob instanceof JsonNode) {\n            \n            return (JsonNode) ob;\n        }\n        \n        return nodeFactory.pojoNode(ob);\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.node.*;\nimport com.fasterxml.jackson.databind.util.RawValue;\n\n\n@SuppressWarnings(\"serial\")\npublic class JsonNodeDeserializer extends BaseNodeDeserializer<JsonNode> { private final static JsonNodeDeserializer instance = new JsonNodeDeserializer(); protected JsonNodeDeserializer() { super(JsonNode.class); }\n\n    \n    public static JsonDeserializer<? extends JsonNode> getDeserializer(Class<?> nodeClass) {\n        if (nodeClass == ObjectNode.class) {\n            return ObjectDeserializer.getInstance();\n        }\n        if (nodeClass == ArrayNode.class) {\n            return ArrayDeserializer.getInstance();\n        }\n        \n        return instance;\n    }\n    \n    \n\n    @Override\n    public JsonNode getNullValue(DeserializationContext ctxt) {\n        return NullNode.getInstance();\n    }\n\n    @Override\n    @Deprecated \n    public JsonNode getNullValue() {\n        return NullNode.getInstance();\n    }\n\n    \n    @Override\n    public JsonNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n            return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n        case JsonTokenId.ID_START_ARRAY:\n            return deserializeArray(p, ctxt, ctxt.getNodeFactory());\n        default:\n            return deserializeAny(p, ctxt, ctxt.getNodeFactory());\n        }\n    }\n\n    \n\n    final static class ObjectDeserializer extends BaseNodeDeserializer<ObjectNode> { private static final long serialVersionUID = 1L; protected final static ObjectDeserializer _instance = new ObjectDeserializer(); protected ObjectDeserializer() { super(ObjectNode.class); }\n\n        public static ObjectDeserializer getInstance() { return _instance; }\n        \n        @Override\n        public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n            if (p.isExpectedStartObjectToken() || p.hasToken(JsonToken.FIELD_NAME)) {\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            \n            \n            if (p.hasToken(JsonToken.END_OBJECT)) {\n                return ctxt.getNodeFactory().objectNode();\n            }\n            throw ctxt.mappingException(ObjectNode.class);\n         }\n    }\n        \n    final static class ArrayDeserializer extends BaseNodeDeserializer<ArrayNode> { private static final long serialVersionUID = 1L; protected final static ArrayDeserializer _instance = new ArrayDeserializer(); protected ArrayDeserializer() { super(ArrayNode.class); }\n\n        public static ArrayDeserializer getInstance() { return _instance; }\n        \n        @Override\n        public ArrayNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n            if (p.isExpectedStartArrayToken()) {\n                return deserializeArray(p, ctxt, ctxt.getNodeFactory());\n            }\n            throw ctxt.mappingException(ArrayNode.class);\n        }\n    }\n}\n\n\n@SuppressWarnings(\"serial\")\nabstract class BaseNodeDeserializer<T extends JsonNode> extends StdDeserializer<T> { public BaseNodeDeserializer(Class<T> vc) {\n        super(vc);\n    }\n\n    @Override\n    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n        \n        return typeDeserializer.deserializeTypedFromAny(p, ctxt);\n    }\n\n    \n    @Override\n    public boolean isCachable() { return true; }\n\n    \n\n    protected void _reportProblem(JsonParser p, String msg) throws JsonMappingException {\n        throw new JsonMappingException(msg, p.getTokenLocation());\n    }\n\n    \n    protected void _handleDuplicateField(JsonParser p, DeserializationContext ctxt, JsonNodeFactory nodeFactory, String fieldName, ObjectNode objectNode, JsonNode oldValue, JsonNode newValue) throws JsonProcessingException {\n        \n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_READING_DUP_TREE_KEY)) {\n            _reportProblem(p, \"Duplicate field '\"+fieldName+\"' for ObjectNode: not allowed when FAIL_ON_READING_DUP_TREE_KEY enabled\");\n        }\n    }\n\n    \n\n    protected final ObjectNode deserializeObject(JsonParser p, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException {\n        ObjectNode node = nodeFactory.objectNode();\n        String key;\n        if (p.isExpectedStartObjectToken()) {\n            key = p.nextFieldName();\n        } else {\n            JsonToken t = p.getCurrentToken();\n            if (t == JsonToken.END_OBJECT) {\n                return node;\n            }\n            if (t != JsonToken.FIELD_NAME) {\n                throw ctxt.mappingException(handledType(), p.getCurrentToken());\n            }\n            key = p.getCurrentName();\n        }\n        for (; key != null; key = p.nextFieldName()) {\n            JsonNode value;\n            JsonToken t = p.nextToken();\n            switch (t.id()) {\n            case JsonTokenId.ID_START_OBJECT:\n                value = deserializeObject(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_START_ARRAY:\n                value = deserializeArray(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_EMBEDDED_OBJECT:\n                value = _fromEmbedded(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_STRING:\n                value = nodeFactory.textNode(p.getText());\n                break;\n            case JsonTokenId.ID_NUMBER_INT:\n                value = _fromInt(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_TRUE:\n                value = nodeFactory.booleanNode(true);\n                break;\n            case JsonTokenId.ID_FALSE:\n                value = nodeFactory.booleanNode(false);\n                break;\n            case JsonTokenId.ID_NULL:\n                value = nodeFactory.nullNode();\n                break;\n            default:\n                value = deserializeAny(p, ctxt, nodeFactory);\n            }\n            JsonNode old = node.replace(key, value);\n            if (old != null) {\n                _handleDuplicateField(p, ctxt, nodeFactory,\n                        key, node, old, value);\n            }\n        }\n        return node;\n    }\n\n    protected final ArrayNode deserializeArray(JsonParser p, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException {\n        ArrayNode node = nodeFactory.arrayNode();\n        while (true) {\n            JsonToken t = p.nextToken();\n            if (t == null) {\n                throw ctxt.mappingException(\"Unexpected end-of-input when binding data into ArrayNode\");\n            }\n            switch (t.id()) {\n            case JsonTokenId.ID_START_OBJECT:\n                node.add(deserializeObject(p, ctxt, nodeFactory));\n                break;\n            case JsonTokenId.ID_START_ARRAY:\n                node.add(deserializeArray(p, ctxt, nodeFactory));\n                break;\n            case JsonTokenId.ID_END_ARRAY:\n                return node;\n            case JsonTokenId.ID_EMBEDDED_OBJECT:\n                node.add(_fromEmbedded(p, ctxt, nodeFactory));\n            case JsonTokenId.ID_STRING:\n                node.add(nodeFactory.textNode(p.getText()));\n                break;\n            case JsonTokenId.ID_NUMBER_INT:\n                node.add(_fromInt(p, ctxt, nodeFactory));\n                break;\n            case JsonTokenId.ID_TRUE:\n                node.add(nodeFactory.booleanNode(true));\n                break;\n            case JsonTokenId.ID_FALSE:\n                node.add(nodeFactory.booleanNode(false));\n                break;\n            case JsonTokenId.ID_NULL:\n                node.add(nodeFactory.nullNode());\n                break;\n            default:\n                node.add(deserializeAny(p, ctxt, nodeFactory));\n                break;\n            }\n        }\n    }\n\n    protected final JsonNode deserializeAny(JsonParser p, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException {\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_END_OBJECT: \n            return deserializeObject(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_START_ARRAY:\n            return deserializeArray(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_FIELD_NAME:\n            return deserializeObject(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return _fromEmbedded(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_STRING:\n            return nodeFactory.textNode(p.getText());\n        case JsonTokenId.ID_NUMBER_INT:\n            return _fromInt(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            return _fromFloat(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_TRUE:\n            return nodeFactory.booleanNode(true);\n        case JsonTokenId.ID_FALSE:\n            return nodeFactory.booleanNode(false);\n        case JsonTokenId.ID_NULL:\n            return nodeFactory.nullNode();\n            \n            \n            \n\n        \n        \n        default:\n            throw ctxt.mappingException(handledType());\n        }\n    }\n\n    protected final JsonNode _fromInt(JsonParser p, DeserializationContext ctxt, JsonNodeFactory nodeFactory) throws IOException {\n        JsonParser.NumberType nt;\n        int feats = ctxt.getDeserializationFeatures();\n        if ((feats & F_MASK_INT_COERCIONS) != 0) {\n            if (DeserializationFeature.USE_BIG_INTEGER_FOR_INTS.enabledIn(feats)) {\n                nt = JsonParser.NumberType.BIG_INTEGER;\n            } else if (DeserializationFeature.USE_LONG_FOR_INTS.enabledIn(feats)) {\n                nt = JsonParser.NumberType.LONG;\n            } else {\n                nt = p.getNumberType();\n            }\n        } else {\n            nt = p.getNumberType();\n        }\n        if (nt == JsonParser.NumberType.INT) {\n            return nodeFactory.numberNode(p.getIntValue());\n        }\n        if (nt == JsonParser.NumberType.LONG) {\n            return nodeFactory.numberNode(p.getLongValue());\n        }\n        return nodeFactory.numberNode(p.getBigIntegerValue());\n    }\n\n    protected final JsonNode _fromFloat(JsonParser p, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException {\n        JsonParser.NumberType nt = p.getNumberType();\n        if (nt == JsonParser.NumberType.BIG_DECIMAL\n            || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n            return nodeFactory.numberNode(p.getDecimalValue());\n        }\n        return nodeFactory.numberNode(p.getDoubleValue());\n    }\n\n    protected final JsonNode _fromEmbedded(JsonParser p, DeserializationContext ctxt, JsonNodeFactory nodeFactory) throws IOException {\n        \n        Object ob = p.getEmbeddedObject();\n        if (ob == null) { \n            return nodeFactory.nullNode();\n        }\n        Class<?> type = ob.getClass();\n        if (type == byte[].class) { \n            return nodeFactory.binaryNode((byte[]) ob);\n        }\n        \n        if (ob instanceof RawValue) {\n            return nodeFactory.rawValueNode((RawValue) ob);\n        }\n        if (ob instanceof JsonNode) {\n            \n            return (JsonNode) ob;\n        }\n        \n        return nodeFactory.pojoNode(ob);\n    }\n}\n",
      "buggy_signatures": [
        "public static JsonDeserializer<? extends JsonNode> getDeserializer(Class<?> nodeClass)",
        "public JsonNode getNullValue(DeserializationContext ctxt)",
        "public JsonNode getNullValue()",
        "public JsonNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public static ObjectDeserializer getInstance()",
        "public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public static ArrayDeserializer getInstance()",
        "public ArrayNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "abstract class BaseNodeDeserializer<T extends JsonNode> extends StdDeserializer<T> { public BaseNodeDeserializer(Class<T> vc)",
        "public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException",
        "public boolean isCachable()",
        "protected void _reportProblem(JsonParser p, String msg) throws JsonMappingException",
        "protected void _handleDuplicateField(JsonParser p, DeserializationContext ctxt, JsonNodeFactory nodeFactory, String fieldName, ObjectNode objectNode, JsonNode oldValue, JsonNode newValue) throws JsonProcessingException",
        "protected final ObjectNode deserializeObject(JsonParser p, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException",
        "protected final ArrayNode deserializeArray(JsonParser p, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException",
        "protected final JsonNode deserializeAny(JsonParser p, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException",
        "protected final JsonNode _fromInt(JsonParser p, DeserializationContext ctxt, JsonNodeFactory nodeFactory) throws IOException",
        "protected final JsonNode _fromFloat(JsonParser p, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException",
        "protected final JsonNode _fromEmbedded(JsonParser p, DeserializationContext ctxt, JsonNodeFactory nodeFactory) throws IOException"
      ],
      "fixed_signatures": [
        "public static JsonDeserializer<? extends JsonNode> getDeserializer(Class<?> nodeClass)",
        "public JsonNode getNullValue(DeserializationContext ctxt)",
        "public JsonNode getNullValue()",
        "public JsonNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public static ObjectDeserializer getInstance()",
        "public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public static ArrayDeserializer getInstance()",
        "public ArrayNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "abstract class BaseNodeDeserializer<T extends JsonNode> extends StdDeserializer<T> { public BaseNodeDeserializer(Class<T> vc)",
        "public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException",
        "public boolean isCachable()",
        "protected void _reportProblem(JsonParser p, String msg) throws JsonMappingException",
        "protected void _handleDuplicateField(JsonParser p, DeserializationContext ctxt, JsonNodeFactory nodeFactory, String fieldName, ObjectNode objectNode, JsonNode oldValue, JsonNode newValue) throws JsonProcessingException",
        "protected final ObjectNode deserializeObject(JsonParser p, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException",
        "protected final ArrayNode deserializeArray(JsonParser p, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException",
        "protected final JsonNode deserializeAny(JsonParser p, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException",
        "protected final JsonNode _fromInt(JsonParser p, DeserializationContext ctxt, JsonNodeFactory nodeFactory) throws IOException",
        "protected final JsonNode _fromFloat(JsonParser p, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException",
        "protected final JsonNode _fromEmbedded(JsonParser p, DeserializationContext ctxt, JsonNodeFactory nodeFactory) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n  if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n  p.nextToken();\n  return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n  }\n  \n  \n  if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n  return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n  }\n  throw ctxt.mappingException(ObjectNode.class);\n  }",
          "fixed_method": "  public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n  if (p.isExpectedStartObjectToken() || p.hasToken(JsonToken.FIELD_NAME)) {\n  return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n  }\n  \n  \n  if (p.hasToken(JsonToken.END_OBJECT)) {\n  return ctxt.getNodeFactory().objectNode();\n  }\n  throw ctxt.mappingException(ObjectNode.class);\n  }",
          "diff": [
            "@@ -94,14 +94,13 @@",
            "         @Override\n",
            "         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n",
            "         {\n",
            "-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n",
            "-                p.nextToken();\n",
            "+            if (p.isExpectedStartObjectToken() || p.hasToken(JsonToken.FIELD_NAME)) {\n",
            "                 return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n",
            "             }\n",
            "             // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n",
            "             //    if caller has advanced to the first token of Object, but for empty Object\n",
            "-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n",
            "-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n",
            "+            if (p.hasToken(JsonToken.END_OBJECT)) {\n",
            "+                return ctxt.getNodeFactory().objectNode();\n",
            "             }\n",
            "             throw ctxt.mappingException(ObjectNode.class);\n",
            "          }\n"
          ],
          "changed_lines": 7
        }
      ]
    }
  ]
}
