{
  "bug_id": "22",
  "failed_tests": {
    "org.jsoup.nodes.ElementTest": [
      {
        "methodName": "elementIsNotASiblingOfItself",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<2> but was:<3>",
        "fail_line": "        assertEquals(2, els.size());",
        "test_source": "",
        "stack": [
          "ElementTest.elementIsNotASiblingOfItself line 538"
        ]
      }
    ],
    "org.jsoup.nodes.NodeTest": [
      {
        "methodName": "nodeIsNotASiblingOfItself",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<2> but was:<3>",
        "fail_line": "        assertEquals(2, nodes.size());",
        "test_source": "",
        "stack": [
          "NodeTest.nodeIsNotASiblingOfItself line 206"
        ]
      },
      {
        "methodName": "orphanNodeReturnsNullForSiblingElements",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "        assertEquals(0, node.siblingNodes().size());",
        "test_source": "",
        "stack": [
          "Node.siblingNodes line 445, NodeTest.orphanNodeReturnsNullForSiblingElements line 190"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/nodes/Element.java",
      "buggy_full_code": "package org.jsoup.nodes;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.parser.Tag;\nimport org.jsoup.select.Collector;\nimport org.jsoup.select.Elements;\nimport org.jsoup.select.Evaluator;\nimport org.jsoup.select.Selector;\n\nimport java.util.*;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\n\n\npublic class Element extends Node { private Tag tag; private Set<String> classNames; public Element(Tag tag, String baseUri, Attributes attributes) {\n        super(baseUri, attributes);\n        \n        Validate.notNull(tag);    \n        this.tag = tag;\n    }\n    \n    \n    public Element(Tag tag, String baseUri) {\n        this(tag, baseUri, new Attributes());\n    }\n\n    @Override\n    public String nodeName() {\n        return tag.getName();\n    }\n\n    \n    public String tagName() {\n        return tag.getName();\n    }\n\n    \n    public Element tagName(String tagName) {\n        Validate.notEmpty(tagName, \"Tag name must not be empty.\");\n        tag = Tag.valueOf(tagName);\n        return this;\n    }\n\n    \n    public Tag tag() {\n        return tag;\n    }\n    \n    \n    public boolean isBlock() {\n        return tag.isBlock();\n    }\n\n    \n    public String id() {\n        String id = attr(\"id\");\n        return id == null ? \"\" : id;\n    }\n\n    \n    public Element attr(String attributeKey, String attributeValue) {\n        super.attr(attributeKey, attributeValue);\n        return this;\n    }\n\n    \n    public Map<String, String> dataset() {\n        return attributes.dataset();\n    }\n\n    @Override\n    public final Element parent() {\n        return (Element) parentNode;\n    }\n\n    \n    public Elements parents() {\n        Elements parents = new Elements();\n        accumulateParents(this, parents);\n        return parents;\n    }\n\n    private static void accumulateParents(Element el, Elements parents) {\n        Element parent = el.parent();\n        if (parent != null && !parent.tagName().equals(\"#root\")) {\n            parents.add(parent);\n            accumulateParents(parent, parents);\n        }\n    }\n\n    \n    public Element child(int index) {\n        return children().get(index);\n    }\n\n    \n    public Elements children() {\n        \n        List<Element> elements = new ArrayList<Element>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                elements.add((Element) node);\n        }\n        return new Elements(elements);\n    }\n\n    \n    public List<TextNode> textNodes() {\n        List<TextNode> textNodes = new ArrayList<TextNode>();\n        for (Node node : childNodes) {\n            if (node instanceof TextNode)\n                textNodes.add((TextNode) node);\n        }\n        return Collections.unmodifiableList(textNodes);\n    }\n\n    \n    public List<DataNode> dataNodes() {\n        List<DataNode> dataNodes = new ArrayList<DataNode>();\n        for (Node node : childNodes) {\n            if (node instanceof DataNode)\n                dataNodes.add((DataNode) node);\n        }\n        return Collections.unmodifiableList(dataNodes);\n    }\n\n    \n    public Elements select(String cssQuery) {\n        return Selector.select(cssQuery, this);\n    }\n    \n    \n    public Element appendChild(Node child) {\n        Validate.notNull(child);\n        \n        addChildren(child);\n        return this;\n    }\n    \n    \n    public Element prependChild(Node child) {\n        Validate.notNull(child);\n        \n        addChildren(0, child);\n        return this;\n    }\n    \n    \n    public Element appendElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName), baseUri());\n        appendChild(child);\n        return child;\n    }\n    \n    \n    public Element prependElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName), baseUri());\n        prependChild(child);\n        return child;\n    }\n    \n    \n    public Element appendText(String text) {\n        TextNode node = new TextNode(text, baseUri());\n        appendChild(node);\n        return this;\n    }\n    \n    \n    public Element prependText(String text) {\n        TextNode node = new TextNode(text, baseUri());\n        prependChild(node);\n        return this;\n    }\n    \n    \n    public Element append(String html) {\n        Validate.notNull(html);\n\n        List<Node> nodes = Parser.parseFragment(html, this, baseUri());\n        addChildren(nodes.toArray(new Node[nodes.size()]));\n        return this;\n    }\n    \n    \n    public Element prepend(String html) {\n        Validate.notNull(html);\n        \n        List<Node> nodes = Parser.parseFragment(html, this, baseUri());\n        addChildren(0, nodes.toArray(new Node[nodes.size()]));\n        return this;\n    }\n\n    \n    @Override\n    public Element before(String html) {\n        return (Element) super.before(html);\n    }\n\n    \n    @Override\n    public Element before(Node node) {\n        return (Element) super.before(node);\n    }\n\n    \n    @Override\n    public Element after(String html) {\n        return (Element) super.after(html);\n    }\n\n    \n    @Override\n    public Element after(Node node) {\n        return (Element) super.after(node);\n    }\n\n    \n    public Element empty() {\n        childNodes.clear();\n        return this;\n    }\n\n    \n    @Override\n    public Element wrap(String html) {\n        return (Element) super.wrap(html);\n    }\n\n    \n    public Elements siblingElements() {\n\n        return parent().children();\n    }\n\n    \n    public Element nextElementSibling() {\n        List<Element> siblings = parent().children();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }\n\n    \n    public Element previousElementSibling() {\n        List<Element> siblings = parent().children();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }\n\n    \n    public Element firstElementSibling() {\n        \n        List<Element> siblings = parent().children();\n        return siblings.size() > 1 ? siblings.get(0) : null;\n    }\n    \n    \n    public Integer elementSiblingIndex() {\n       if (parent() == null) return 0;\n       return indexInList(this, parent().children()); \n    }\n\n    \n    public Element lastElementSibling() {\n        List<Element> siblings = parent().children();\n        return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;\n    }\n    \n    private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n        Validate.notNull(search);\n        Validate.notNull(elements);\n\n        for (int i = 0; i < elements.size(); i++) {\n            E element = elements.get(i);\n            if (element.equals(search))\n                return i;\n        }\n        return null;\n    }\n\n    \n\n    \n    public Elements getElementsByTag(String tagName) {\n        Validate.notEmpty(tagName);\n        tagName = tagName.toLowerCase().trim();\n\n        return Collector.collect(new Evaluator.Tag(tagName), this);\n    }\n\n    \n    public Element getElementById(String id) {\n        Validate.notEmpty(id);\n        \n        Elements elements = Collector.collect(new Evaluator.Id(id), this);\n        if (elements.size() > 0)\n            return elements.get(0);\n        else\n            return null;\n    }\n\n    \n    public Elements getElementsByClass(String className) {\n        Validate.notEmpty(className);\n\n        return Collector.collect(new Evaluator.Class(className), this);\n    }\n\n    \n    public Elements getElementsByAttribute(String key) {\n        Validate.notEmpty(key);\n        key = key.trim().toLowerCase();\n\n        return Collector.collect(new Evaluator.Attribute(key), this);\n    }\n\n    \n    public Elements getElementsByAttributeStarting(String keyPrefix) {\n        Validate.notEmpty(keyPrefix);\n        keyPrefix = keyPrefix.trim().toLowerCase();\n\n        return Collector.collect(new Evaluator.AttributeStarting(keyPrefix), this);\n    }\n\n    \n    public Elements getElementsByAttributeValue(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValue(key, value), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueNot(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) {\n        return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) {\n        return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueContaining(String key, String match) {\n        return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this);\n    }\n    \n    \n    public Elements getElementsByAttributeValueMatching(String key, Pattern pattern) {\n        return Collector.collect(new Evaluator.AttributeWithValueMatching(key, pattern), this);\n        \n    }\n    \n    \n    public Elements getElementsByAttributeValueMatching(String key, String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsByAttributeValueMatching(key, pattern);\n    }\n    \n    \n    public Elements getElementsByIndexLessThan(int index) {\n        return Collector.collect(new Evaluator.IndexLessThan(index), this);\n    }\n    \n    \n    public Elements getElementsByIndexGreaterThan(int index) {\n        return Collector.collect(new Evaluator.IndexGreaterThan(index), this);\n    }\n    \n    \n    public Elements getElementsByIndexEquals(int index) {\n        return Collector.collect(new Evaluator.IndexEquals(index), this);\n    }\n    \n    \n    public Elements getElementsContainingText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsText(searchText), this);\n    }\n    \n    \n    public Elements getElementsContainingOwnText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsOwnText(searchText), this);\n    }\n    \n    \n    public Elements getElementsMatchingText(Pattern pattern) {\n        return Collector.collect(new Evaluator.Matches(pattern), this);\n    }\n    \n    \n    public Elements getElementsMatchingText(String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsMatchingText(pattern);\n    }\n    \n    \n    public Elements getElementsMatchingOwnText(Pattern pattern) {\n        return Collector.collect(new Evaluator.MatchesOwn(pattern), this);\n    }\n    \n    \n    public Elements getElementsMatchingOwnText(String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsMatchingOwnText(pattern);\n    }\n    \n    \n    public Elements getAllElements() {\n        return Collector.collect(new Evaluator.AllElements(), this);\n    }\n\n    \n    public String text() {\n        StringBuilder sb = new StringBuilder();\n        text(sb);\n        return sb.toString().trim();\n    }\n\n    private void text(StringBuilder accum) {\n        appendWhitespaceIfBr(this, accum);\n        \n        for (Node child : childNodes) {\n            if (child instanceof TextNode) {\n                TextNode textNode = (TextNode) child;\n                appendNormalisedText(accum, textNode);\n            } else if (child instanceof Element) {\n                Element element = (Element) child;\n                if (accum.length() > 0 && element.isBlock() && !TextNode.lastCharIsWhitespace(accum))\n                    accum.append(\" \");\n                element.text(accum);\n            }\n        }\n    }\n\n    \n    public String ownText() {\n        StringBuilder sb = new StringBuilder();\n        ownText(sb);\n        return sb.toString().trim();\n    }\n\n    private void ownText(StringBuilder accum) {\n        for (Node child : childNodes) {\n            if (child instanceof TextNode) {\n                TextNode textNode = (TextNode) child;\n                appendNormalisedText(accum, textNode);\n            } else if (child instanceof Element) {\n                appendWhitespaceIfBr((Element) child, accum);\n            }\n        }\n    }\n\n    private void appendNormalisedText(StringBuilder accum, TextNode textNode) {\n        String text = textNode.getWholeText();\n\n        if (!preserveWhitespace()) {\n            text = TextNode.normaliseWhitespace(text);\n            if (TextNode.lastCharIsWhitespace(accum))\n                text = TextNode.stripLeadingWhitespace(text);\n        }\n        accum.append(text);\n    }\n\n    private static void appendWhitespaceIfBr(Element element, StringBuilder accum) {\n        if (element.tag.getName().equals(\"br\") && !TextNode.lastCharIsWhitespace(accum))\n            accum.append(\" \");\n    }\n\n    boolean preserveWhitespace() {\n        return tag.preserveWhitespace() || parent() != null && parent().preserveWhitespace();\n    }\n\n    \n    public Element text(String text) {\n        Validate.notNull(text);\n\n        empty();\n        TextNode textNode = new TextNode(text, baseUri);\n        appendChild(textNode);\n\n        return this;\n    }\n\n    \n    public boolean hasText() {\n        for (Node child: childNodes) {\n            if (child instanceof TextNode) {\n                TextNode textNode = (TextNode) child;\n                if (!textNode.isBlank())\n                    return true;\n            } else if (child instanceof Element) {\n                Element el = (Element) child;\n                if (el.hasText())\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    \n    public String data() {\n        StringBuilder sb = new StringBuilder();\n\n        for (Node childNode : childNodes) {\n            if (childNode instanceof DataNode) {\n                DataNode data = (DataNode) childNode;\n                sb.append(data.getWholeData());\n            } else if (childNode instanceof Element) {\n                Element element = (Element) childNode;\n                String elementData = element.data();\n                sb.append(elementData);\n            }\n        }\n        return sb.toString();\n    }   \n\n    \n    public String className() {\n        return attr(\"class\");\n    }\n\n    \n    public Set<String> classNames() {\n        if (classNames == null) {\n            String[] names = className().split(\"\\\\s+\");\n            classNames = new LinkedHashSet<String>(Arrays.asList(names));\n        }\n        return classNames;\n    }\n\n    \n    public Element classNames(Set<String> classNames) {\n        Validate.notNull(classNames);\n        attributes.put(\"class\", StringUtil.join(classNames, \" \"));\n        return this;\n    }\n\n    \n    public boolean hasClass(String className) {\n        Set<String> classNames = classNames();\n        for (String name : classNames) {\n            if (className.equalsIgnoreCase(name))\n                return true;\n        }\n        return false;\n    }\n\n    \n    public Element addClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        classes.add(className);\n        classNames(classes);\n\n        return this;\n    }\n\n    \n    public Element removeClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        classes.remove(className);\n        classNames(classes);\n\n        return this;\n    }\n\n    \n    public Element toggleClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        if (classes.contains(className))\n            classes.remove(className);\n        else\n            classes.add(className);\n        classNames(classes);\n\n        return this;\n    }\n    \n    \n    public String val() {\n        if (tagName().equals(\"textarea\"))\n            return text();\n        else\n            return attr(\"value\");\n    }\n    \n    \n    public Element val(String value) {\n        if (tagName().equals(\"textarea\"))\n            text(value);\n        else\n            attr(\"value\", value);\n        return this;\n    }\n\n    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n        if (accum.length() > 0 && out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock())))\n            indent(accum, depth, out);\n        accum\n                .append(\"<\")\n                .append(tagName());\n        attributes.html(accum, out);\n\n        if (childNodes.isEmpty() && tag.isSelfClosing())\n            accum.append(\" />\");\n        else\n            accum.append(\">\");\n    }\n\n    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {\n        if (!(childNodes.isEmpty() && tag.isSelfClosing())) {\n            if (out.prettyPrint() && !childNodes.isEmpty() && tag.formatAsBlock())\n                indent(accum, depth, out);\n            accum.append(\"</\").append(tagName()).append(\">\");\n        }\n    }\n\n    \n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        html(accum); \n        return accum.toString().trim();\n    }\n\n    private void html(StringBuilder accum) {\n        for (Node node : childNodes)\n            node.outerHtml(accum);\n    }\n    \n    \n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n    public String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        return this == o;\n    }\n\n    @Override\n    public int hashCode() {\n        \n        int result = super.hashCode();\n        result = 31 * result + (tag != null ? tag.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public Element clone() {\n        Element clone = (Element) super.clone();\n        clone.classNames(); \n        return clone;\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.nodes;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.parser.Tag;\nimport org.jsoup.select.Collector;\nimport org.jsoup.select.Elements;\nimport org.jsoup.select.Evaluator;\nimport org.jsoup.select.Selector;\n\nimport java.util.*;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\n\n\npublic class Element extends Node { private Tag tag; private Set<String> classNames; public Element(Tag tag, String baseUri, Attributes attributes) {\n        super(baseUri, attributes);\n        \n        Validate.notNull(tag);    \n        this.tag = tag;\n    }\n    \n    \n    public Element(Tag tag, String baseUri) {\n        this(tag, baseUri, new Attributes());\n    }\n\n    @Override\n    public String nodeName() {\n        return tag.getName();\n    }\n\n    \n    public String tagName() {\n        return tag.getName();\n    }\n\n    \n    public Element tagName(String tagName) {\n        Validate.notEmpty(tagName, \"Tag name must not be empty.\");\n        tag = Tag.valueOf(tagName);\n        return this;\n    }\n\n    \n    public Tag tag() {\n        return tag;\n    }\n    \n    \n    public boolean isBlock() {\n        return tag.isBlock();\n    }\n\n    \n    public String id() {\n        String id = attr(\"id\");\n        return id == null ? \"\" : id;\n    }\n\n    \n    public Element attr(String attributeKey, String attributeValue) {\n        super.attr(attributeKey, attributeValue);\n        return this;\n    }\n\n    \n    public Map<String, String> dataset() {\n        return attributes.dataset();\n    }\n\n    @Override\n    public final Element parent() {\n        return (Element) parentNode;\n    }\n\n    \n    public Elements parents() {\n        Elements parents = new Elements();\n        accumulateParents(this, parents);\n        return parents;\n    }\n\n    private static void accumulateParents(Element el, Elements parents) {\n        Element parent = el.parent();\n        if (parent != null && !parent.tagName().equals(\"#root\")) {\n            parents.add(parent);\n            accumulateParents(parent, parents);\n        }\n    }\n\n    \n    public Element child(int index) {\n        return children().get(index);\n    }\n\n    \n    public Elements children() {\n        \n        List<Element> elements = new ArrayList<Element>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                elements.add((Element) node);\n        }\n        return new Elements(elements);\n    }\n\n    \n    public List<TextNode> textNodes() {\n        List<TextNode> textNodes = new ArrayList<TextNode>();\n        for (Node node : childNodes) {\n            if (node instanceof TextNode)\n                textNodes.add((TextNode) node);\n        }\n        return Collections.unmodifiableList(textNodes);\n    }\n\n    \n    public List<DataNode> dataNodes() {\n        List<DataNode> dataNodes = new ArrayList<DataNode>();\n        for (Node node : childNodes) {\n            if (node instanceof DataNode)\n                dataNodes.add((DataNode) node);\n        }\n        return Collections.unmodifiableList(dataNodes);\n    }\n\n    \n    public Elements select(String cssQuery) {\n        return Selector.select(cssQuery, this);\n    }\n    \n    \n    public Element appendChild(Node child) {\n        Validate.notNull(child);\n        \n        addChildren(child);\n        return this;\n    }\n    \n    \n    public Element prependChild(Node child) {\n        Validate.notNull(child);\n        \n        addChildren(0, child);\n        return this;\n    }\n    \n    \n    public Element appendElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName), baseUri());\n        appendChild(child);\n        return child;\n    }\n    \n    \n    public Element prependElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName), baseUri());\n        prependChild(child);\n        return child;\n    }\n    \n    \n    public Element appendText(String text) {\n        TextNode node = new TextNode(text, baseUri());\n        appendChild(node);\n        return this;\n    }\n    \n    \n    public Element prependText(String text) {\n        TextNode node = new TextNode(text, baseUri());\n        prependChild(node);\n        return this;\n    }\n    \n    \n    public Element append(String html) {\n        Validate.notNull(html);\n\n        List<Node> nodes = Parser.parseFragment(html, this, baseUri());\n        addChildren(nodes.toArray(new Node[nodes.size()]));\n        return this;\n    }\n    \n    \n    public Element prepend(String html) {\n        Validate.notNull(html);\n        \n        List<Node> nodes = Parser.parseFragment(html, this, baseUri());\n        addChildren(0, nodes.toArray(new Node[nodes.size()]));\n        return this;\n    }\n\n    \n    @Override\n    public Element before(String html) {\n        return (Element) super.before(html);\n    }\n\n    \n    @Override\n    public Element before(Node node) {\n        return (Element) super.before(node);\n    }\n\n    \n    @Override\n    public Element after(String html) {\n        return (Element) super.after(html);\n    }\n\n    \n    @Override\n    public Element after(Node node) {\n        return (Element) super.after(node);\n    }\n\n    \n    public Element empty() {\n        childNodes.clear();\n        return this;\n    }\n\n    \n    @Override\n    public Element wrap(String html) {\n        return (Element) super.wrap(html);\n    }\n\n    \n    public Elements siblingElements() {\n        if (parentNode == null)\n            return new Elements(0);\n\n        List<Element> elements = parent().children();\n        Elements siblings = new Elements(elements.size() - 1);\n        for (Element el: elements)\n            if (el != this)\n                siblings.add(el);\n        return siblings;\n    }\n\n    \n    public Element nextElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().children();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }\n\n    \n    public Element previousElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().children();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }\n\n    \n    public Element firstElementSibling() {\n        \n        List<Element> siblings = parent().children();\n        return siblings.size() > 1 ? siblings.get(0) : null;\n    }\n    \n    \n    public Integer elementSiblingIndex() {\n       if (parent() == null) return 0;\n       return indexInList(this, parent().children()); \n    }\n\n    \n    public Element lastElementSibling() {\n        List<Element> siblings = parent().children();\n        return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;\n    }\n    \n    private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n        Validate.notNull(search);\n        Validate.notNull(elements);\n\n        for (int i = 0; i < elements.size(); i++) {\n            E element = elements.get(i);\n            if (element.equals(search))\n                return i;\n        }\n        return null;\n    }\n\n    \n\n    \n    public Elements getElementsByTag(String tagName) {\n        Validate.notEmpty(tagName);\n        tagName = tagName.toLowerCase().trim();\n\n        return Collector.collect(new Evaluator.Tag(tagName), this);\n    }\n\n    \n    public Element getElementById(String id) {\n        Validate.notEmpty(id);\n        \n        Elements elements = Collector.collect(new Evaluator.Id(id), this);\n        if (elements.size() > 0)\n            return elements.get(0);\n        else\n            return null;\n    }\n\n    \n    public Elements getElementsByClass(String className) {\n        Validate.notEmpty(className);\n\n        return Collector.collect(new Evaluator.Class(className), this);\n    }\n\n    \n    public Elements getElementsByAttribute(String key) {\n        Validate.notEmpty(key);\n        key = key.trim().toLowerCase();\n\n        return Collector.collect(new Evaluator.Attribute(key), this);\n    }\n\n    \n    public Elements getElementsByAttributeStarting(String keyPrefix) {\n        Validate.notEmpty(keyPrefix);\n        keyPrefix = keyPrefix.trim().toLowerCase();\n\n        return Collector.collect(new Evaluator.AttributeStarting(keyPrefix), this);\n    }\n\n    \n    public Elements getElementsByAttributeValue(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValue(key, value), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueNot(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) {\n        return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) {\n        return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueContaining(String key, String match) {\n        return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this);\n    }\n    \n    \n    public Elements getElementsByAttributeValueMatching(String key, Pattern pattern) {\n        return Collector.collect(new Evaluator.AttributeWithValueMatching(key, pattern), this);\n        \n    }\n    \n    \n    public Elements getElementsByAttributeValueMatching(String key, String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsByAttributeValueMatching(key, pattern);\n    }\n    \n    \n    public Elements getElementsByIndexLessThan(int index) {\n        return Collector.collect(new Evaluator.IndexLessThan(index), this);\n    }\n    \n    \n    public Elements getElementsByIndexGreaterThan(int index) {\n        return Collector.collect(new Evaluator.IndexGreaterThan(index), this);\n    }\n    \n    \n    public Elements getElementsByIndexEquals(int index) {\n        return Collector.collect(new Evaluator.IndexEquals(index), this);\n    }\n    \n    \n    public Elements getElementsContainingText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsText(searchText), this);\n    }\n    \n    \n    public Elements getElementsContainingOwnText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsOwnText(searchText), this);\n    }\n    \n    \n    public Elements getElementsMatchingText(Pattern pattern) {\n        return Collector.collect(new Evaluator.Matches(pattern), this);\n    }\n    \n    \n    public Elements getElementsMatchingText(String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsMatchingText(pattern);\n    }\n    \n    \n    public Elements getElementsMatchingOwnText(Pattern pattern) {\n        return Collector.collect(new Evaluator.MatchesOwn(pattern), this);\n    }\n    \n    \n    public Elements getElementsMatchingOwnText(String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsMatchingOwnText(pattern);\n    }\n    \n    \n    public Elements getAllElements() {\n        return Collector.collect(new Evaluator.AllElements(), this);\n    }\n\n    \n    public String text() {\n        StringBuilder sb = new StringBuilder();\n        text(sb);\n        return sb.toString().trim();\n    }\n\n    private void text(StringBuilder accum) {\n        appendWhitespaceIfBr(this, accum);\n        \n        for (Node child : childNodes) {\n            if (child instanceof TextNode) {\n                TextNode textNode = (TextNode) child;\n                appendNormalisedText(accum, textNode);\n            } else if (child instanceof Element) {\n                Element element = (Element) child;\n                if (accum.length() > 0 && element.isBlock() && !TextNode.lastCharIsWhitespace(accum))\n                    accum.append(\" \");\n                element.text(accum);\n            }\n        }\n    }\n\n    \n    public String ownText() {\n        StringBuilder sb = new StringBuilder();\n        ownText(sb);\n        return sb.toString().trim();\n    }\n\n    private void ownText(StringBuilder accum) {\n        for (Node child : childNodes) {\n            if (child instanceof TextNode) {\n                TextNode textNode = (TextNode) child;\n                appendNormalisedText(accum, textNode);\n            } else if (child instanceof Element) {\n                appendWhitespaceIfBr((Element) child, accum);\n            }\n        }\n    }\n\n    private void appendNormalisedText(StringBuilder accum, TextNode textNode) {\n        String text = textNode.getWholeText();\n\n        if (!preserveWhitespace()) {\n            text = TextNode.normaliseWhitespace(text);\n            if (TextNode.lastCharIsWhitespace(accum))\n                text = TextNode.stripLeadingWhitespace(text);\n        }\n        accum.append(text);\n    }\n\n    private static void appendWhitespaceIfBr(Element element, StringBuilder accum) {\n        if (element.tag.getName().equals(\"br\") && !TextNode.lastCharIsWhitespace(accum))\n            accum.append(\" \");\n    }\n\n    boolean preserveWhitespace() {\n        return tag.preserveWhitespace() || parent() != null && parent().preserveWhitespace();\n    }\n\n    \n    public Element text(String text) {\n        Validate.notNull(text);\n\n        empty();\n        TextNode textNode = new TextNode(text, baseUri);\n        appendChild(textNode);\n\n        return this;\n    }\n\n    \n    public boolean hasText() {\n        for (Node child: childNodes) {\n            if (child instanceof TextNode) {\n                TextNode textNode = (TextNode) child;\n                if (!textNode.isBlank())\n                    return true;\n            } else if (child instanceof Element) {\n                Element el = (Element) child;\n                if (el.hasText())\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    \n    public String data() {\n        StringBuilder sb = new StringBuilder();\n\n        for (Node childNode : childNodes) {\n            if (childNode instanceof DataNode) {\n                DataNode data = (DataNode) childNode;\n                sb.append(data.getWholeData());\n            } else if (childNode instanceof Element) {\n                Element element = (Element) childNode;\n                String elementData = element.data();\n                sb.append(elementData);\n            }\n        }\n        return sb.toString();\n    }   \n\n    \n    public String className() {\n        return attr(\"class\");\n    }\n\n    \n    public Set<String> classNames() {\n        if (classNames == null) {\n            String[] names = className().split(\"\\\\s+\");\n            classNames = new LinkedHashSet<String>(Arrays.asList(names));\n        }\n        return classNames;\n    }\n\n    \n    public Element classNames(Set<String> classNames) {\n        Validate.notNull(classNames);\n        attributes.put(\"class\", StringUtil.join(classNames, \" \"));\n        return this;\n    }\n\n    \n    public boolean hasClass(String className) {\n        Set<String> classNames = classNames();\n        for (String name : classNames) {\n            if (className.equalsIgnoreCase(name))\n                return true;\n        }\n        return false;\n    }\n\n    \n    public Element addClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        classes.add(className);\n        classNames(classes);\n\n        return this;\n    }\n\n    \n    public Element removeClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        classes.remove(className);\n        classNames(classes);\n\n        return this;\n    }\n\n    \n    public Element toggleClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        if (classes.contains(className))\n            classes.remove(className);\n        else\n            classes.add(className);\n        classNames(classes);\n\n        return this;\n    }\n    \n    \n    public String val() {\n        if (tagName().equals(\"textarea\"))\n            return text();\n        else\n            return attr(\"value\");\n    }\n    \n    \n    public Element val(String value) {\n        if (tagName().equals(\"textarea\"))\n            text(value);\n        else\n            attr(\"value\", value);\n        return this;\n    }\n\n    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n        if (accum.length() > 0 && out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock())))\n            indent(accum, depth, out);\n        accum\n                .append(\"<\")\n                .append(tagName());\n        attributes.html(accum, out);\n\n        if (childNodes.isEmpty() && tag.isSelfClosing())\n            accum.append(\" />\");\n        else\n            accum.append(\">\");\n    }\n\n    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {\n        if (!(childNodes.isEmpty() && tag.isSelfClosing())) {\n            if (out.prettyPrint() && !childNodes.isEmpty() && tag.formatAsBlock())\n                indent(accum, depth, out);\n            accum.append(\"</\").append(tagName()).append(\">\");\n        }\n    }\n\n    \n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        html(accum); \n        return accum.toString().trim();\n    }\n\n    private void html(StringBuilder accum) {\n        for (Node node : childNodes)\n            node.outerHtml(accum);\n    }\n    \n    \n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n    public String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        return this == o;\n    }\n\n    @Override\n    public int hashCode() {\n        \n        int result = super.hashCode();\n        result = 31 * result + (tag != null ? tag.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public Element clone() {\n        Element clone = (Element) super.clone();\n        clone.classNames(); \n        return clone;\n    }\n}\n",
      "buggy_signatures": [
        "public class Element extends Node { private Tag tag; private Set<String> classNames; public Element(Tag tag, String baseUri, Attributes attributes)",
        "public Element(Tag tag, String baseUri)",
        "public String nodeName()",
        "public String tagName()",
        "public Element tagName(String tagName)",
        "public Tag tag()",
        "public boolean isBlock()",
        "public String id()",
        "public Element attr(String attributeKey, String attributeValue)",
        "public Map<String, String> dataset()",
        "public final Element parent()",
        "public Elements parents()",
        "private static void accumulateParents(Element el, Elements parents)",
        "public Element child(int index)",
        "public Elements children()",
        "public List<TextNode> textNodes()",
        "public List<DataNode> dataNodes()",
        "public Elements select(String cssQuery)",
        "public Element appendChild(Node child)",
        "public Element prependChild(Node child)",
        "public Element appendElement(String tagName)",
        "public Element prependElement(String tagName)",
        "public Element appendText(String text)",
        "public Element prependText(String text)",
        "public Element append(String html)",
        "public Element prepend(String html)",
        "public Element before(String html)",
        "public Element before(Node node)",
        "public Element after(String html)",
        "public Element after(Node node)",
        "public Element empty()",
        "public Element wrap(String html)",
        "public Elements siblingElements()",
        "public Element nextElementSibling()",
        "public Element previousElementSibling()",
        "public Element firstElementSibling()",
        "public Integer elementSiblingIndex()",
        "public Element lastElementSibling()",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements)",
        "public Elements getElementsByTag(String tagName)",
        "public Element getElementById(String id)",
        "public Elements getElementsByClass(String className)",
        "public Elements getElementsByAttribute(String key)",
        "public Elements getElementsByAttributeStarting(String keyPrefix)",
        "public Elements getElementsByAttributeValue(String key, String value)",
        "public Elements getElementsByAttributeValueNot(String key, String value)",
        "public Elements getElementsByAttributeValueStarting(String key, String valuePrefix)",
        "public Elements getElementsByAttributeValueEnding(String key, String valueSuffix)",
        "public Elements getElementsByAttributeValueContaining(String key, String match)",
        "public Elements getElementsByAttributeValueMatching(String key, Pattern pattern)",
        "public Elements getElementsByAttributeValueMatching(String key, String regex)",
        "public Elements getElementsByIndexLessThan(int index)",
        "public Elements getElementsByIndexGreaterThan(int index)",
        "public Elements getElementsByIndexEquals(int index)",
        "public Elements getElementsContainingText(String searchText)",
        "public Elements getElementsContainingOwnText(String searchText)",
        "public Elements getElementsMatchingText(Pattern pattern)",
        "public Elements getElementsMatchingText(String regex)",
        "public Elements getElementsMatchingOwnText(Pattern pattern)",
        "public Elements getElementsMatchingOwnText(String regex)",
        "public Elements getAllElements()",
        "public String text()",
        "private void text(StringBuilder accum)",
        "public String ownText()",
        "private void ownText(StringBuilder accum)",
        "private void appendNormalisedText(StringBuilder accum, TextNode textNode)",
        "private static void appendWhitespaceIfBr(Element element, StringBuilder accum)",
        "public Element text(String text)",
        "public boolean hasText()",
        "public String data()",
        "public String className()",
        "public Set<String> classNames()",
        "public Element classNames(Set<String> classNames)",
        "public boolean hasClass(String className)",
        "public Element addClass(String className)",
        "public Element removeClass(String className)",
        "public Element toggleClass(String className)",
        "public String val()",
        "public Element val(String value)",
        "public String html()",
        "private void html(StringBuilder accum)",
        "public Element html(String html)",
        "public String toString()",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "public Element clone()"
      ],
      "fixed_signatures": [
        "public class Element extends Node { private Tag tag; private Set<String> classNames; public Element(Tag tag, String baseUri, Attributes attributes)",
        "public Element(Tag tag, String baseUri)",
        "public String nodeName()",
        "public String tagName()",
        "public Element tagName(String tagName)",
        "public Tag tag()",
        "public boolean isBlock()",
        "public String id()",
        "public Element attr(String attributeKey, String attributeValue)",
        "public Map<String, String> dataset()",
        "public final Element parent()",
        "public Elements parents()",
        "private static void accumulateParents(Element el, Elements parents)",
        "public Element child(int index)",
        "public Elements children()",
        "public List<TextNode> textNodes()",
        "public List<DataNode> dataNodes()",
        "public Elements select(String cssQuery)",
        "public Element appendChild(Node child)",
        "public Element prependChild(Node child)",
        "public Element appendElement(String tagName)",
        "public Element prependElement(String tagName)",
        "public Element appendText(String text)",
        "public Element prependText(String text)",
        "public Element append(String html)",
        "public Element prepend(String html)",
        "public Element before(String html)",
        "public Element before(Node node)",
        "public Element after(String html)",
        "public Element after(Node node)",
        "public Element empty()",
        "public Element wrap(String html)",
        "public Elements siblingElements()",
        "public Element nextElementSibling()",
        "public Element previousElementSibling()",
        "public Element firstElementSibling()",
        "public Integer elementSiblingIndex()",
        "public Element lastElementSibling()",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements)",
        "public Elements getElementsByTag(String tagName)",
        "public Element getElementById(String id)",
        "public Elements getElementsByClass(String className)",
        "public Elements getElementsByAttribute(String key)",
        "public Elements getElementsByAttributeStarting(String keyPrefix)",
        "public Elements getElementsByAttributeValue(String key, String value)",
        "public Elements getElementsByAttributeValueNot(String key, String value)",
        "public Elements getElementsByAttributeValueStarting(String key, String valuePrefix)",
        "public Elements getElementsByAttributeValueEnding(String key, String valueSuffix)",
        "public Elements getElementsByAttributeValueContaining(String key, String match)",
        "public Elements getElementsByAttributeValueMatching(String key, Pattern pattern)",
        "public Elements getElementsByAttributeValueMatching(String key, String regex)",
        "public Elements getElementsByIndexLessThan(int index)",
        "public Elements getElementsByIndexGreaterThan(int index)",
        "public Elements getElementsByIndexEquals(int index)",
        "public Elements getElementsContainingText(String searchText)",
        "public Elements getElementsContainingOwnText(String searchText)",
        "public Elements getElementsMatchingText(Pattern pattern)",
        "public Elements getElementsMatchingText(String regex)",
        "public Elements getElementsMatchingOwnText(Pattern pattern)",
        "public Elements getElementsMatchingOwnText(String regex)",
        "public Elements getAllElements()",
        "public String text()",
        "private void text(StringBuilder accum)",
        "public String ownText()",
        "private void ownText(StringBuilder accum)",
        "private void appendNormalisedText(StringBuilder accum, TextNode textNode)",
        "private static void appendWhitespaceIfBr(Element element, StringBuilder accum)",
        "public Element text(String text)",
        "public boolean hasText()",
        "public String data()",
        "public String className()",
        "public Set<String> classNames()",
        "public Element classNames(Set<String> classNames)",
        "public boolean hasClass(String className)",
        "public Element addClass(String className)",
        "public Element removeClass(String className)",
        "public Element toggleClass(String className)",
        "public String val()",
        "public Element val(String value)",
        "public String html()",
        "private void html(StringBuilder accum)",
        "public Element html(String html)",
        "public String toString()",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "public Element clone()"
      ],
      "methods": [
        {
          "buggy_method": "  public Elements siblingElements() {\n\n  return parent().children();\n  }",
          "fixed_method": "  public Elements siblingElements() {\n  if (parentNode == null)\n  return new Elements(0);\n\n  List<Element> elements = parent().children();\n  Elements siblings = new Elements(elements.size() - 1);\n  for (Element el: elements)\n  if (el != this)\n  siblings.add(el);\n  return siblings;\n  }",
          "diff": [
            "@@ -431,8 +431,15 @@",
            "      * @return sibling elements\n",
            "      */\n",
            "     public Elements siblingElements() {\n",
            "-\n",
            "-        return parent().children();\n",
            "+        if (parentNode == null)\n",
            "+            return new Elements(0);\n",
            "+\n",
            "+        List<Element> elements = parent().children();\n",
            "+        Elements siblings = new Elements(elements.size() - 1);\n",
            "+        for (Element el: elements)\n",
            "+            if (el != this)\n",
            "+                siblings.add(el);\n",
            "+        return siblings;\n",
            "     }\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 11
        },
        {
          "buggy_method": "  public Element nextElementSibling() {\n  List<Element> siblings = parent().children();\n  Integer index = indexInList(this, siblings);\n  Validate.notNull(index);\n  if (siblings.size() > index+1)\n  return siblings.get(index+1);\n  else\n  return null;\n  }",
          "fixed_method": "  public Element nextElementSibling() {\n  if (parentNode == null) return null;\n  List<Element> siblings = parent().children();\n  Integer index = indexInList(this, siblings);\n  Validate.notNull(index);\n  if (siblings.size() > index+1)\n  return siblings.get(index+1);\n  else\n  return null;\n  }",
          "diff": [
            "@@ -444,6 +451,7 @@",
            "      * @see #previousElementSibling()\n",
            "      */\n",
            "     public Element nextElementSibling() {\n",
            "+        if (parentNode == null) return null;\n",
            "         List<Element> siblings = parent().children();\n",
            "         Integer index = indexInList(this, siblings);\n",
            "         Validate.notNull(index);\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  public Element previousElementSibling() {\n  List<Element> siblings = parent().children();\n  Integer index = indexInList(this, siblings);\n  Validate.notNull(index);\n  if (index > 0)\n  return siblings.get(index-1);\n  else\n  return null;\n  }",
          "fixed_method": "  public Element previousElementSibling() {\n  if (parentNode == null) return null;\n  List<Element> siblings = parent().children();\n  Integer index = indexInList(this, siblings);\n  Validate.notNull(index);\n  if (index > 0)\n  return siblings.get(index-1);\n  else\n  return null;\n  }",
          "diff": [
            "@@ -459,6 +467,7 @@",
            "      * @see #nextElementSibling()\n",
            "      */\n",
            "     public Element previousElementSibling() {\n",
            "+        if (parentNode == null) return null;\n",
            "         List<Element> siblings = parent().children();\n",
            "         Integer index = indexInList(this, siblings);\n",
            "         Validate.notNull(index);\n"
          ],
          "changed_lines": 1
        }
      ]
    },
    {
      "name": "org/jsoup/nodes/Node.java",
      "buggy_full_code": "package org.jsoup.nodes;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.select.NodeTraversor;\nimport org.jsoup.select.NodeVisitor;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n\npublic abstract class Node implements Cloneable { Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri; int siblingIndex; protected Node(String baseUri, Attributes attributes) {\n        Validate.notNull(baseUri);\n        Validate.notNull(attributes);\n        \n        childNodes = new ArrayList<Node>(4);\n        this.baseUri = baseUri.trim();\n        this.attributes = attributes;\n    }\n\n    protected Node(String baseUri) {\n        this(baseUri, new Attributes());\n    }\n\n    \n    protected Node() {\n        childNodes = Collections.emptyList();\n        attributes = null;\n    }\n\n    \n    public abstract String nodeName(); public String attr(String attributeKey) {\n        Validate.notNull(attributeKey);\n\n        if (attributes.hasKey(attributeKey))\n            return attributes.get(attributeKey);\n        else if (attributeKey.toLowerCase().startsWith(\"abs:\"))\n            return absUrl(attributeKey.substring(\"abs:\".length()));\n        else return \"\";\n    }\n\n    \n    public Attributes attributes() {\n        return attributes;\n    }\n\n    \n    public Node attr(String attributeKey, String attributeValue) {\n        attributes.put(attributeKey, attributeValue);\n        return this;\n    }\n\n    \n    public boolean hasAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n\n        if (attributeKey.toLowerCase().startsWith(\"abs:\")) {\n            String key = attributeKey.substring(\"abs:\".length());\n            if (attributes.hasKey(key) && !absUrl(key).equals(\"\"))\n                return true;\n        }\n        return attributes.hasKey(attributeKey);\n    }\n\n    \n    public Node removeAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        attributes.remove(attributeKey);\n        return this;\n    }\n\n    \n    public String baseUri() {\n        return baseUri;\n    }\n\n    \n    public void setBaseUri(final String baseUri) {\n        Validate.notNull(baseUri);\n\n        traverse(new NodeVisitor() {\n            public void head(Node node, int depth) {\n                node.baseUri = baseUri;\n            }\n\n            public void tail(Node node, int depth) {\n            }\n        });\n    }\n\n    \n    public String absUrl(String attributeKey) {\n        Validate.notEmpty(attributeKey);\n\n        String relUrl = attr(attributeKey);\n        if (!hasAttr(attributeKey)) {\n            return \"\"; \n        } else {\n            URL base;\n            try {\n                try {\n                    base = new URL(baseUri);\n                } catch (MalformedURLException e) {\n                    \n                    URL abs = new URL(relUrl);\n                    return abs.toExternalForm();\n                }\n                \n                if (relUrl.startsWith(\"?\"))\n                    relUrl = base.getPath() + relUrl;\n                URL abs = new URL(base, relUrl);\n                return abs.toExternalForm();\n            } catch (MalformedURLException e) {\n                return \"\";\n            }\n        }\n    }\n\n    \n    public Node childNode(int index) {\n        return childNodes.get(index);\n    }\n\n    \n    public List<Node> childNodes() {\n        return Collections.unmodifiableList(childNodes);\n    }\n    \n    protected Node[] childNodesAsArray() {\n        return childNodes.toArray(new Node[childNodes().size()]);\n    }\n\n    \n    public Node parent() {\n        return parentNode;\n    }\n    \n    \n    public Document ownerDocument() {\n        if (this instanceof Document)\n            return (Document) this;\n        else if (parentNode == null)\n            return null;\n        else\n            return parentNode.ownerDocument();\n    }\n    \n    \n    public void remove() {\n        Validate.notNull(parentNode);\n        parentNode.removeChild(this);\n    }\n\n    \n    public Node before(String html) {\n        addSiblingHtml(siblingIndex(), html);\n        return this;\n    }\n\n    \n    public Node before(Node node) {\n        Validate.notNull(node);\n        Validate.notNull(parentNode);\n\n        parentNode.addChildren(siblingIndex(), node);\n        return this;\n    }\n\n    \n    public Node after(String html) {\n        addSiblingHtml(siblingIndex()+1, html);\n        return this;\n    }\n\n    \n    public Node after(Node node) {\n        Validate.notNull(node);\n        Validate.notNull(parentNode);\n\n        parentNode.addChildren(siblingIndex()+1, node);\n        return this;\n    }\n\n    private void addSiblingHtml(int index, String html) {\n        Validate.notNull(html);\n        Validate.notNull(parentNode);\n\n        Element context = parent() instanceof Element ? (Element) parent() : null;        \n        List<Node> nodes = Parser.parseFragment(html, context, baseUri());\n        parentNode.addChildren(index, nodes.toArray(new Node[nodes.size()]));\n    }\n\n    \n    public Node wrap(String html) {\n        Validate.notEmpty(html);\n\n        Element context = parent() instanceof Element ? (Element) parent() : null;\n        List<Node> wrapChildren = Parser.parseFragment(html, context, baseUri());\n        Node wrapNode = wrapChildren.get(0);\n        if (wrapNode == null || !(wrapNode instanceof Element)) \n            return null;\n\n        Element wrap = (Element) wrapNode;\n        Element deepest = getDeepChild(wrap);\n        parentNode.replaceChild(this, wrap);\n        deepest.addChildren(this);\n\n        \n        if (wrapChildren.size() > 0) {\n            for (int i = 0; i < wrapChildren.size(); i++) {\n                Node remainder = wrapChildren.get(i);\n                remainder.parentNode.removeChild(remainder);\n                wrap.appendChild(remainder);\n            }\n        }\n        return this;\n    }\n\n    \n    public Node unwrap() {\n        Validate.notNull(parentNode);\n\n        int index = siblingIndex;\n        Node firstChild = childNodes.size() > 0 ? childNodes.get(0) : null;\n        parentNode.addChildren(index, this.childNodesAsArray());\n        this.remove();\n\n        return firstChild;\n    }\n\n    private Element getDeepChild(Element el) {\n        List<Element> children = el.children();\n        if (children.size() > 0)\n            return getDeepChild(children.get(0));\n        else\n            return el;\n    }\n    \n    \n    public void replaceWith(Node in) {\n        Validate.notNull(in);\n        Validate.notNull(parentNode);\n        parentNode.replaceChild(this, in);\n    }\n\n    protected void setParentNode(Node parentNode) {\n        if (this.parentNode != null)\n            this.parentNode.removeChild(this);\n        this.parentNode = parentNode;\n    }\n\n    protected void replaceChild(Node out, Node in) {\n        Validate.isTrue(out.parentNode == this);\n        Validate.notNull(in);\n        if (in.parentNode != null)\n            in.parentNode.removeChild(in);\n        \n        Integer index = out.siblingIndex();\n        childNodes.set(index, in);\n        in.parentNode = this;\n        in.setSiblingIndex(index);\n        out.parentNode = null;\n    }\n\n    protected void removeChild(Node out) {\n        Validate.isTrue(out.parentNode == this);\n        int index = out.siblingIndex();\n        childNodes.remove(index);\n        reindexChildren();\n        out.parentNode = null;\n    }\n\n    protected void addChildren(Node... children) {\n        \n        for (Node child: children) {\n            reparentChild(child);\n            childNodes.add(child);\n            child.setSiblingIndex(childNodes.size()-1);\n        }\n    }\n\n    protected void addChildren(int index, Node... children) {\n        Validate.noNullElements(children);\n        for (int i = children.length - 1; i >= 0; i--) {\n            Node in = children[i];\n            reparentChild(in);\n            childNodes.add(index, in);\n        }\n        reindexChildren();\n    }\n\n    private void reparentChild(Node child) {\n        if (child.parentNode != null)\n            child.parentNode.removeChild(child);\n        child.setParentNode(this);\n    }\n    \n    private void reindexChildren() {\n        for (int i = 0; i < childNodes.size(); i++) {\n            childNodes.get(i).setSiblingIndex(i);\n        }\n    }\n    \n    \n    public List<Node> siblingNodes() {\n\n        return parent().childNodes();\n    }\n\n    \n    public Node nextSibling() {\n        if (parentNode == null)\n            return null; \n        \n        List<Node> siblings = parentNode.childNodes;\n        Integer index = siblingIndex();\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }\n\n    \n    public Node previousSibling() {\n\n        List<Node> siblings = parentNode.childNodes;\n        Integer index = siblingIndex();\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }\n\n    \n    public int siblingIndex() {\n        return siblingIndex;\n    }\n    \n    protected void setSiblingIndex(int siblingIndex) {\n        this.siblingIndex = siblingIndex;\n    }\n\n    \n    public Node traverse(NodeVisitor nodeVisitor) {\n        Validate.notNull(nodeVisitor);\n        NodeTraversor traversor = new NodeTraversor(nodeVisitor);\n        traversor.traverse(this);\n        return this;\n    }\n\n    \n    public String outerHtml() {\n        StringBuilder accum = new StringBuilder(128);\n        outerHtml(accum);\n        return accum.toString();\n    }\n\n    protected void outerHtml(StringBuilder accum) {\n        new NodeTraversor(new OuterHtmlVisitor(accum, getOutputSettings())).traverse(this);\n    }\n\n    \n    private Document.OutputSettings getOutputSettings() {\n        return ownerDocument() != null ? ownerDocument().outputSettings() : (new Document(\"\")).outputSettings();\n    }\n\n    \n    abstract void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out); abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out); public String toString() {\n        return outerHtml();\n    }\n\n    protected void indent(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"\\n\").append(StringUtil.padding(depth * out.indentAmount()));\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        \n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = parentNode != null ? parentNode.hashCode() : 0;\n        \n        result = 31 * result + (attributes != null ? attributes.hashCode() : 0);\n        return result;\n    }\n\n    \n    @Override\n    public Node clone() {\n        return doClone(null); \n    }\n\n    protected Node doClone(Node parent) {\n        Node clone;\n        try {\n            clone = (Node) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n\n        clone.parentNode = parent; \n        clone.siblingIndex = parent == null ? 0 : siblingIndex;\n        clone.attributes = attributes != null ? attributes.clone() : null;\n        clone.baseUri = baseUri;\n        clone.childNodes = new ArrayList<Node>(childNodes.size());\n        for (Node child: childNodes)\n            clone.childNodes.add(child.doClone(clone)); \n\n        return clone;\n    }\n\n    private static class OuterHtmlVisitor implements NodeVisitor { private StringBuilder accum; private Document.OutputSettings out; OuterHtmlVisitor(StringBuilder accum, Document.OutputSettings out) {\n            this.accum = accum;\n            this.out = out;\n        }\n\n        public void head(Node node, int depth) {\n            node.outerHtmlHead(accum, depth, out);\n        }\n\n        public void tail(Node node, int depth) {\n            if (!node.nodeName().equals(\"#text\")) \n                node.outerHtmlTail(accum, depth, out);\n        }\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.nodes;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.select.NodeTraversor;\nimport org.jsoup.select.NodeVisitor;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n\npublic abstract class Node implements Cloneable { Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri; int siblingIndex; protected Node(String baseUri, Attributes attributes) {\n        Validate.notNull(baseUri);\n        Validate.notNull(attributes);\n        \n        childNodes = new ArrayList<Node>(4);\n        this.baseUri = baseUri.trim();\n        this.attributes = attributes;\n    }\n\n    protected Node(String baseUri) {\n        this(baseUri, new Attributes());\n    }\n\n    \n    protected Node() {\n        childNodes = Collections.emptyList();\n        attributes = null;\n    }\n\n    \n    public abstract String nodeName(); public String attr(String attributeKey) {\n        Validate.notNull(attributeKey);\n\n        if (attributes.hasKey(attributeKey))\n            return attributes.get(attributeKey);\n        else if (attributeKey.toLowerCase().startsWith(\"abs:\"))\n            return absUrl(attributeKey.substring(\"abs:\".length()));\n        else return \"\";\n    }\n\n    \n    public Attributes attributes() {\n        return attributes;\n    }\n\n    \n    public Node attr(String attributeKey, String attributeValue) {\n        attributes.put(attributeKey, attributeValue);\n        return this;\n    }\n\n    \n    public boolean hasAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n\n        if (attributeKey.toLowerCase().startsWith(\"abs:\")) {\n            String key = attributeKey.substring(\"abs:\".length());\n            if (attributes.hasKey(key) && !absUrl(key).equals(\"\"))\n                return true;\n        }\n        return attributes.hasKey(attributeKey);\n    }\n\n    \n    public Node removeAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        attributes.remove(attributeKey);\n        return this;\n    }\n\n    \n    public String baseUri() {\n        return baseUri;\n    }\n\n    \n    public void setBaseUri(final String baseUri) {\n        Validate.notNull(baseUri);\n\n        traverse(new NodeVisitor() {\n            public void head(Node node, int depth) {\n                node.baseUri = baseUri;\n            }\n\n            public void tail(Node node, int depth) {\n            }\n        });\n    }\n\n    \n    public String absUrl(String attributeKey) {\n        Validate.notEmpty(attributeKey);\n\n        String relUrl = attr(attributeKey);\n        if (!hasAttr(attributeKey)) {\n            return \"\"; \n        } else {\n            URL base;\n            try {\n                try {\n                    base = new URL(baseUri);\n                } catch (MalformedURLException e) {\n                    \n                    URL abs = new URL(relUrl);\n                    return abs.toExternalForm();\n                }\n                \n                if (relUrl.startsWith(\"?\"))\n                    relUrl = base.getPath() + relUrl;\n                URL abs = new URL(base, relUrl);\n                return abs.toExternalForm();\n            } catch (MalformedURLException e) {\n                return \"\";\n            }\n        }\n    }\n\n    \n    public Node childNode(int index) {\n        return childNodes.get(index);\n    }\n\n    \n    public List<Node> childNodes() {\n        return Collections.unmodifiableList(childNodes);\n    }\n    \n    protected Node[] childNodesAsArray() {\n        return childNodes.toArray(new Node[childNodes().size()]);\n    }\n\n    \n    public Node parent() {\n        return parentNode;\n    }\n    \n    \n    public Document ownerDocument() {\n        if (this instanceof Document)\n            return (Document) this;\n        else if (parentNode == null)\n            return null;\n        else\n            return parentNode.ownerDocument();\n    }\n    \n    \n    public void remove() {\n        Validate.notNull(parentNode);\n        parentNode.removeChild(this);\n    }\n\n    \n    public Node before(String html) {\n        addSiblingHtml(siblingIndex(), html);\n        return this;\n    }\n\n    \n    public Node before(Node node) {\n        Validate.notNull(node);\n        Validate.notNull(parentNode);\n\n        parentNode.addChildren(siblingIndex(), node);\n        return this;\n    }\n\n    \n    public Node after(String html) {\n        addSiblingHtml(siblingIndex()+1, html);\n        return this;\n    }\n\n    \n    public Node after(Node node) {\n        Validate.notNull(node);\n        Validate.notNull(parentNode);\n\n        parentNode.addChildren(siblingIndex()+1, node);\n        return this;\n    }\n\n    private void addSiblingHtml(int index, String html) {\n        Validate.notNull(html);\n        Validate.notNull(parentNode);\n\n        Element context = parent() instanceof Element ? (Element) parent() : null;        \n        List<Node> nodes = Parser.parseFragment(html, context, baseUri());\n        parentNode.addChildren(index, nodes.toArray(new Node[nodes.size()]));\n    }\n\n    \n    public Node wrap(String html) {\n        Validate.notEmpty(html);\n\n        Element context = parent() instanceof Element ? (Element) parent() : null;\n        List<Node> wrapChildren = Parser.parseFragment(html, context, baseUri());\n        Node wrapNode = wrapChildren.get(0);\n        if (wrapNode == null || !(wrapNode instanceof Element)) \n            return null;\n\n        Element wrap = (Element) wrapNode;\n        Element deepest = getDeepChild(wrap);\n        parentNode.replaceChild(this, wrap);\n        deepest.addChildren(this);\n\n        \n        if (wrapChildren.size() > 0) {\n            for (int i = 0; i < wrapChildren.size(); i++) {\n                Node remainder = wrapChildren.get(i);\n                remainder.parentNode.removeChild(remainder);\n                wrap.appendChild(remainder);\n            }\n        }\n        return this;\n    }\n\n    \n    public Node unwrap() {\n        Validate.notNull(parentNode);\n\n        int index = siblingIndex;\n        Node firstChild = childNodes.size() > 0 ? childNodes.get(0) : null;\n        parentNode.addChildren(index, this.childNodesAsArray());\n        this.remove();\n\n        return firstChild;\n    }\n\n    private Element getDeepChild(Element el) {\n        List<Element> children = el.children();\n        if (children.size() > 0)\n            return getDeepChild(children.get(0));\n        else\n            return el;\n    }\n    \n    \n    public void replaceWith(Node in) {\n        Validate.notNull(in);\n        Validate.notNull(parentNode);\n        parentNode.replaceChild(this, in);\n    }\n\n    protected void setParentNode(Node parentNode) {\n        if (this.parentNode != null)\n            this.parentNode.removeChild(this);\n        this.parentNode = parentNode;\n    }\n\n    protected void replaceChild(Node out, Node in) {\n        Validate.isTrue(out.parentNode == this);\n        Validate.notNull(in);\n        if (in.parentNode != null)\n            in.parentNode.removeChild(in);\n        \n        Integer index = out.siblingIndex();\n        childNodes.set(index, in);\n        in.parentNode = this;\n        in.setSiblingIndex(index);\n        out.parentNode = null;\n    }\n\n    protected void removeChild(Node out) {\n        Validate.isTrue(out.parentNode == this);\n        int index = out.siblingIndex();\n        childNodes.remove(index);\n        reindexChildren();\n        out.parentNode = null;\n    }\n\n    protected void addChildren(Node... children) {\n        \n        for (Node child: children) {\n            reparentChild(child);\n            childNodes.add(child);\n            child.setSiblingIndex(childNodes.size()-1);\n        }\n    }\n\n    protected void addChildren(int index, Node... children) {\n        Validate.noNullElements(children);\n        for (int i = children.length - 1; i >= 0; i--) {\n            Node in = children[i];\n            reparentChild(in);\n            childNodes.add(index, in);\n        }\n        reindexChildren();\n    }\n\n    private void reparentChild(Node child) {\n        if (child.parentNode != null)\n            child.parentNode.removeChild(child);\n        child.setParentNode(this);\n    }\n    \n    private void reindexChildren() {\n        for (int i = 0; i < childNodes.size(); i++) {\n            childNodes.get(i).setSiblingIndex(i);\n        }\n    }\n    \n    \n    public List<Node> siblingNodes() {\n        if (parentNode == null)\n            return Collections.emptyList();\n\n        List<Node> nodes = parentNode.childNodes;\n        List<Node> siblings = new ArrayList<Node>(nodes.size() - 1);\n        for (Node node: nodes)\n            if (node != this)\n                siblings.add(node);\n        return siblings;\n    }\n\n    \n    public Node nextSibling() {\n        if (parentNode == null)\n            return null; \n        \n        List<Node> siblings = parentNode.childNodes;\n        Integer index = siblingIndex();\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }\n\n    \n    public Node previousSibling() {\n        if (parentNode == null)\n            return null; \n\n        List<Node> siblings = parentNode.childNodes;\n        Integer index = siblingIndex();\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }\n\n    \n    public int siblingIndex() {\n        return siblingIndex;\n    }\n    \n    protected void setSiblingIndex(int siblingIndex) {\n        this.siblingIndex = siblingIndex;\n    }\n\n    \n    public Node traverse(NodeVisitor nodeVisitor) {\n        Validate.notNull(nodeVisitor);\n        NodeTraversor traversor = new NodeTraversor(nodeVisitor);\n        traversor.traverse(this);\n        return this;\n    }\n\n    \n    public String outerHtml() {\n        StringBuilder accum = new StringBuilder(128);\n        outerHtml(accum);\n        return accum.toString();\n    }\n\n    protected void outerHtml(StringBuilder accum) {\n        new NodeTraversor(new OuterHtmlVisitor(accum, getOutputSettings())).traverse(this);\n    }\n\n    \n    private Document.OutputSettings getOutputSettings() {\n        return ownerDocument() != null ? ownerDocument().outputSettings() : (new Document(\"\")).outputSettings();\n    }\n\n    \n    abstract void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out); abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out); public String toString() {\n        return outerHtml();\n    }\n\n    protected void indent(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"\\n\").append(StringUtil.padding(depth * out.indentAmount()));\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        \n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = parentNode != null ? parentNode.hashCode() : 0;\n        \n        result = 31 * result + (attributes != null ? attributes.hashCode() : 0);\n        return result;\n    }\n\n    \n    @Override\n    public Node clone() {\n        return doClone(null); \n    }\n\n    protected Node doClone(Node parent) {\n        Node clone;\n        try {\n            clone = (Node) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n\n        clone.parentNode = parent; \n        clone.siblingIndex = parent == null ? 0 : siblingIndex;\n        clone.attributes = attributes != null ? attributes.clone() : null;\n        clone.baseUri = baseUri;\n        clone.childNodes = new ArrayList<Node>(childNodes.size());\n        for (Node child: childNodes)\n            clone.childNodes.add(child.doClone(clone)); \n\n        return clone;\n    }\n\n    private static class OuterHtmlVisitor implements NodeVisitor { private StringBuilder accum; private Document.OutputSettings out; OuterHtmlVisitor(StringBuilder accum, Document.OutputSettings out) {\n            this.accum = accum;\n            this.out = out;\n        }\n\n        public void head(Node node, int depth) {\n            node.outerHtmlHead(accum, depth, out);\n        }\n\n        public void tail(Node node, int depth) {\n            if (!node.nodeName().equals(\"#text\")) \n                node.outerHtmlTail(accum, depth, out);\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public abstract class Node implements Cloneable { Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri; int siblingIndex; protected Node(String baseUri, Attributes attributes)",
        "protected Node(String baseUri)",
        "protected Node()",
        "public abstract String nodeName(); public String attr(String attributeKey)",
        "public Attributes attributes()",
        "public Node attr(String attributeKey, String attributeValue)",
        "public boolean hasAttr(String attributeKey)",
        "public Node removeAttr(String attributeKey)",
        "public String baseUri()",
        "public void setBaseUri(final String baseUri)",
        "public void head(Node node, int depth)",
        "public void tail(Node node, int depth)",
        "public String absUrl(String attributeKey)",
        "public Node childNode(int index)",
        "public List<Node> childNodes()",
        "protected Node[] childNodesAsArray()",
        "public Node parent()",
        "public Document ownerDocument()",
        "public void remove()",
        "public Node before(String html)",
        "public Node before(Node node)",
        "public Node after(String html)",
        "public Node after(Node node)",
        "private void addSiblingHtml(int index, String html)",
        "public Node wrap(String html)",
        "public Node unwrap()",
        "private Element getDeepChild(Element el)",
        "public void replaceWith(Node in)",
        "protected void setParentNode(Node parentNode)",
        "protected void replaceChild(Node out, Node in)",
        "protected void removeChild(Node out)",
        "protected void addChildren(Node... children)",
        "protected void addChildren(int index, Node... children)",
        "private void reparentChild(Node child)",
        "private void reindexChildren()",
        "public List<Node> siblingNodes()",
        "public Node nextSibling()",
        "public Node previousSibling()",
        "public int siblingIndex()",
        "protected void setSiblingIndex(int siblingIndex)",
        "public Node traverse(NodeVisitor nodeVisitor)",
        "public String outerHtml()",
        "protected void outerHtml(StringBuilder accum)",
        "private Document.OutputSettings getOutputSettings()",
        "abstract void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out); abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out); public String toString()",
        "protected void indent(StringBuilder accum, int depth, Document.OutputSettings out)",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "public Node clone()",
        "protected Node doClone(Node parent)",
        "private static class OuterHtmlVisitor implements NodeVisitor { private StringBuilder accum; private Document.OutputSettings out; OuterHtmlVisitor(StringBuilder accum, Document.OutputSettings out)",
        "public void head(Node node, int depth)",
        "public void tail(Node node, int depth)"
      ],
      "fixed_signatures": [
        "public abstract class Node implements Cloneable { Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri; int siblingIndex; protected Node(String baseUri, Attributes attributes)",
        "protected Node(String baseUri)",
        "protected Node()",
        "public abstract String nodeName(); public String attr(String attributeKey)",
        "public Attributes attributes()",
        "public Node attr(String attributeKey, String attributeValue)",
        "public boolean hasAttr(String attributeKey)",
        "public Node removeAttr(String attributeKey)",
        "public String baseUri()",
        "public void setBaseUri(final String baseUri)",
        "public void head(Node node, int depth)",
        "public void tail(Node node, int depth)",
        "public String absUrl(String attributeKey)",
        "public Node childNode(int index)",
        "public List<Node> childNodes()",
        "protected Node[] childNodesAsArray()",
        "public Node parent()",
        "public Document ownerDocument()",
        "public void remove()",
        "public Node before(String html)",
        "public Node before(Node node)",
        "public Node after(String html)",
        "public Node after(Node node)",
        "private void addSiblingHtml(int index, String html)",
        "public Node wrap(String html)",
        "public Node unwrap()",
        "private Element getDeepChild(Element el)",
        "public void replaceWith(Node in)",
        "protected void setParentNode(Node parentNode)",
        "protected void replaceChild(Node out, Node in)",
        "protected void removeChild(Node out)",
        "protected void addChildren(Node... children)",
        "protected void addChildren(int index, Node... children)",
        "private void reparentChild(Node child)",
        "private void reindexChildren()",
        "public List<Node> siblingNodes()",
        "public Node nextSibling()",
        "public Node previousSibling()",
        "public int siblingIndex()",
        "protected void setSiblingIndex(int siblingIndex)",
        "public Node traverse(NodeVisitor nodeVisitor)",
        "public String outerHtml()",
        "protected void outerHtml(StringBuilder accum)",
        "private Document.OutputSettings getOutputSettings()",
        "abstract void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out); abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out); public String toString()",
        "protected void indent(StringBuilder accum, int depth, Document.OutputSettings out)",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "public Node clone()",
        "protected Node doClone(Node parent)",
        "private static class OuterHtmlVisitor implements NodeVisitor { private StringBuilder accum; private Document.OutputSettings out; OuterHtmlVisitor(StringBuilder accum, Document.OutputSettings out)",
        "public void head(Node node, int depth)",
        "public void tail(Node node, int depth)"
      ],
      "methods": [
        {
          "buggy_method": "  public List<Node> siblingNodes() {\n\n  return parent().childNodes();\n  }",
          "fixed_method": "  public List<Node> siblingNodes() {\n  if (parentNode == null)\n  return Collections.emptyList();\n\n  List<Node> nodes = parentNode.childNodes;\n  List<Node> siblings = new ArrayList<Node>(nodes.size() - 1);\n  for (Node node: nodes)\n  if (node != this)\n  siblings.add(node);\n  return siblings;\n  }",
          "diff": [
            "@@ -441,8 +441,15 @@",
            "      @return node siblings. If the node has no parent, returns an empty list.\n",
            "      */\n",
            "     public List<Node> siblingNodes() {\n",
            "-\n",
            "-        return parent().childNodes();\n",
            "+        if (parentNode == null)\n",
            "+            return Collections.emptyList();\n",
            "+\n",
            "+        List<Node> nodes = parentNode.childNodes;\n",
            "+        List<Node> siblings = new ArrayList<Node>(nodes.size() - 1);\n",
            "+        for (Node node: nodes)\n",
            "+            if (node != this)\n",
            "+                siblings.add(node);\n",
            "+        return siblings;\n",
            "     }\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 11
        },
        {
          "buggy_method": "  public Node previousSibling() {\n\n  List<Node> siblings = parentNode.childNodes;\n  Integer index = siblingIndex();\n  Validate.notNull(index);\n  if (index > 0)\n  return siblings.get(index-1);\n  else\n  return null;\n  }",
          "fixed_method": "  public Node previousSibling() {\n  if (parentNode == null)\n  return null; \n\n  List<Node> siblings = parentNode.childNodes;\n  Integer index = siblingIndex();\n  Validate.notNull(index);\n  if (index > 0)\n  return siblings.get(index-1);\n  else\n  return null;\n  }",
          "diff": [
            "@@ -467,6 +474,8 @@",
            "      @return the previous sibling, or null if this is the first sibling\n",
            "      */\n",
            "     public Node previousSibling() {\n",
            "+        if (parentNode == null)\n",
            "+            return null; // root\n",
            " \n",
            "         List<Node> siblings = parentNode.childNodes;\n",
            "         Integer index = siblingIndex();\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "org/jsoup/select/Elements.java",
      "buggy_full_code": "package org.jsoup.select;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.Node;\n\nimport java.util.*;\n\n\npublic class Elements implements List<Element>, Cloneable { private List<Element> contents; public Elements() {\n        contents = new ArrayList<Element>();\n    }\n\n\n    public Elements(Collection<Element> elements) {\n        contents = new ArrayList<Element>(elements);\n    }\n    \n    public Elements(List<Element> elements) {\n        contents = elements;\n    }\n    \n    public Elements(Element... elements) {\n        this(Arrays.asList(elements));\n    }\n    \n    @Override\n\tpublic Elements clone() {\n    \tList<Element> elements = new ArrayList<Element>();\n    \t\n    \tfor(Element e : contents)\n    \t\telements.add(e.clone());\n\t\t\n    \t\n    \treturn new Elements(elements);\n\t}\n\n\t\n    \n    public String attr(String attributeKey) {\n        for (Element element : contents) {\n            if (element.hasAttr(attributeKey))\n                return element.attr(attributeKey);\n        }\n        return \"\";\n    }\n\n    \n    public boolean hasAttr(String attributeKey) {\n        for (Element element : contents) {\n            if (element.hasAttr(attributeKey))\n                return true;\n        }\n        return false;\n    }\n\n    \n    public Elements attr(String attributeKey, String attributeValue) {\n        for (Element element : contents) {\n            element.attr(attributeKey, attributeValue);\n        }\n        return this;\n    }\n\n    \n    public Elements removeAttr(String attributeKey) {\n        for (Element element : contents) {\n            element.removeAttr(attributeKey);\n        }\n        return this;\n    }\n\n    \n    public Elements addClass(String className) {\n        for (Element element : contents) {\n            element.addClass(className);\n        }\n        return this;\n    }\n\n    \n    public Elements removeClass(String className) {\n        for (Element element : contents) {\n            element.removeClass(className);\n        }\n        return this;\n    }\n\n    \n    public Elements toggleClass(String className) {\n        for (Element element : contents) {\n            element.toggleClass(className);\n        }\n        return this;\n    }\n\n    \n    public boolean hasClass(String className) {\n        for (Element element : contents) {\n            if (element.hasClass(className))\n                return true;\n        }\n        return false;\n    }\n    \n    \n    public String val() {\n        if (size() > 0)\n            return first().val();\n        else\n            return \"\";\n    }\n    \n    \n    public Elements val(String value) {\n        for (Element element : contents)\n            element.val(value);\n        return this;\n    }\n    \n    \n    public String text() {\n        StringBuilder sb = new StringBuilder();\n        for (Element element : contents) {\n            if (sb.length() != 0)\n                sb.append(\" \");\n            sb.append(element.text());\n        }\n        return sb.toString();\n    }\n\n    public boolean hasText() {\n        for (Element element: contents) {\n            if (element.hasText())\n                return true;\n        }\n        return false;\n    }\n    \n    \n    public String html() {\n        StringBuilder sb = new StringBuilder();\n        for (Element element : contents) {\n            if (sb.length() != 0)\n                sb.append(\"\\n\");\n            sb.append(element.html());\n        }\n        return sb.toString();\n    }\n    \n    \n    public String outerHtml() {\n        StringBuilder sb = new StringBuilder();\n        for (Element element : contents) {\n            if (sb.length() != 0)\n                sb.append(\"\\n\");\n            sb.append(element.outerHtml());\n        }\n        return sb.toString();\n    }\n\n    \n    public String toString() {\n        return outerHtml();\n    }\n\n    \n    public Elements tagName(String tagName) {\n        for (Element element : contents) {\n            element.tagName(tagName);\n        }\n        return this;\n    }\n    \n    \n    public Elements html(String html) {\n        for (Element element : contents) {\n            element.html(html);\n        }\n        return this;\n    }\n    \n    \n    public Elements prepend(String html) {\n        for (Element element : contents) {\n            element.prepend(html);\n        }\n        return this;\n    }\n    \n    \n    public Elements append(String html) {\n        for (Element element : contents) {\n            element.append(html);\n        }\n        return this;\n    }\n    \n    \n    public Elements before(String html) {\n        for (Element element : contents) {\n            element.before(html);\n        }\n        return this;\n    }\n    \n    \n    public Elements after(String html) {\n        for (Element element : contents) {\n            element.after(html);\n        }\n        return this;\n    }\n\n    \n    public Elements wrap(String html) {\n        Validate.notEmpty(html);\n        for (Element element : contents) {\n            element.wrap(html);\n        }\n        return this;\n    }\n\n    \n    public Elements unwrap() {\n        for (Element element : contents) {\n            element.unwrap();\n        }\n        return this;\n    }\n\n    \n    public Elements empty() {\n        for (Element element : contents) {\n            element.empty();\n        }\n        return this;\n    }\n\n    \n    public Elements remove() {\n        for (Element element : contents) {\n            element.remove();\n        }\n        return this;\n    }\n    \n    \n    \n    \n    public Elements select(String query) {\n        return Selector.select(query, this);\n    }\n\n    \n    public Elements not(String query) {\n        Elements out = Selector.select(query, this);\n        return Selector.filterOut(this, out);\n    }\n    \n    \n    public Elements eq(int index) {\n        return contents.size() > index ? new Elements(get(index)) : new Elements();\n    }\n    \n    \n    public boolean is(String query) {\n        Elements children = select(query);\n        return !children.isEmpty();\n    }\n\n    \n    public Elements parents() {\n        HashSet<Element> combo = new LinkedHashSet<Element>();\n        for (Element e: contents) {\n            combo.addAll(e.parents());\n        }\n        return new Elements(combo);\n    }\n\n    \n    \n    public Element first() {\n        return contents.isEmpty() ? null : contents.get(0);\n    }\n\n    \n    public Element last() {\n        return contents.isEmpty() ? null : contents.get(contents.size() - 1);\n    }\n\n    \n    public Elements traverse(NodeVisitor nodeVisitor) {\n        Validate.notNull(nodeVisitor);\n        NodeTraversor traversor = new NodeTraversor(nodeVisitor);\n        for (Element el: contents) {\n            traversor.traverse(el);\n        }\n        return this;\n    }\n\n    \n    public int size() {return contents.size();}\n\n    public boolean isEmpty() {return contents.isEmpty();}\n\n    public boolean contains(Object o) {return contents.contains(o);}\n\n    public Iterator<Element> iterator() {return contents.iterator();}\n\n    public Object[] toArray() {return contents.toArray();}\n\n    public <T> T[] toArray(T[] a) {return contents.toArray(a);}\n\n    public boolean add(Element element) {return contents.add(element);}\n\n    public boolean remove(Object o) {return contents.remove(o);}\n\n    public boolean containsAll(Collection<?> c) {return contents.containsAll(c);}\n\n    public boolean addAll(Collection<? extends Element> c) {return contents.addAll(c);}\n\n    public boolean addAll(int index, Collection<? extends Element> c) {return contents.addAll(index, c);}\n\n    public boolean removeAll(Collection<?> c) {return contents.removeAll(c);}\n\n    public boolean retainAll(Collection<?> c) {return contents.retainAll(c);}\n\n    public void clear() {contents.clear();}\n\n    public boolean equals(Object o) {return contents.equals(o);}\n\n    public int hashCode() {return contents.hashCode();}\n\n    public Element get(int index) {return contents.get(index);}\n\n    public Element set(int index, Element element) {return contents.set(index, element);}\n\n    public void add(int index, Element element) {contents.add(index, element);}\n\n    public Element remove(int index) {return contents.remove(index);}\n\n    public int indexOf(Object o) {return contents.indexOf(o);}\n\n    public int lastIndexOf(Object o) {return contents.lastIndexOf(o);}\n\n    public ListIterator<Element> listIterator() {return contents.listIterator();}\n\n    public ListIterator<Element> listIterator(int index) {return contents.listIterator(index);}\n\n    public List<Element> subList(int fromIndex, int toIndex) {return contents.subList(fromIndex, toIndex);}\n}\n",
      "fixed_full_code": "package org.jsoup.select;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.Node;\n\nimport java.util.*;\n\n\npublic class Elements implements List<Element>, Cloneable { private List<Element> contents; public Elements() {\n        contents = new ArrayList<Element>();\n    }\n\n    public Elements(int initialCapacity) {\n        contents = new ArrayList<Element>(initialCapacity);\n    }\n\n    public Elements(Collection<Element> elements) {\n        contents = new ArrayList<Element>(elements);\n    }\n    \n    public Elements(List<Element> elements) {\n        contents = elements;\n    }\n    \n    public Elements(Element... elements) {\n        this(Arrays.asList(elements));\n    }\n    \n    @Override\n\tpublic Elements clone() {\n    \tList<Element> elements = new ArrayList<Element>();\n    \t\n    \tfor(Element e : contents)\n    \t\telements.add(e.clone());\n\t\t\n    \t\n    \treturn new Elements(elements);\n\t}\n\n\t\n    \n    public String attr(String attributeKey) {\n        for (Element element : contents) {\n            if (element.hasAttr(attributeKey))\n                return element.attr(attributeKey);\n        }\n        return \"\";\n    }\n\n    \n    public boolean hasAttr(String attributeKey) {\n        for (Element element : contents) {\n            if (element.hasAttr(attributeKey))\n                return true;\n        }\n        return false;\n    }\n\n    \n    public Elements attr(String attributeKey, String attributeValue) {\n        for (Element element : contents) {\n            element.attr(attributeKey, attributeValue);\n        }\n        return this;\n    }\n\n    \n    public Elements removeAttr(String attributeKey) {\n        for (Element element : contents) {\n            element.removeAttr(attributeKey);\n        }\n        return this;\n    }\n\n    \n    public Elements addClass(String className) {\n        for (Element element : contents) {\n            element.addClass(className);\n        }\n        return this;\n    }\n\n    \n    public Elements removeClass(String className) {\n        for (Element element : contents) {\n            element.removeClass(className);\n        }\n        return this;\n    }\n\n    \n    public Elements toggleClass(String className) {\n        for (Element element : contents) {\n            element.toggleClass(className);\n        }\n        return this;\n    }\n\n    \n    public boolean hasClass(String className) {\n        for (Element element : contents) {\n            if (element.hasClass(className))\n                return true;\n        }\n        return false;\n    }\n    \n    \n    public String val() {\n        if (size() > 0)\n            return first().val();\n        else\n            return \"\";\n    }\n    \n    \n    public Elements val(String value) {\n        for (Element element : contents)\n            element.val(value);\n        return this;\n    }\n    \n    \n    public String text() {\n        StringBuilder sb = new StringBuilder();\n        for (Element element : contents) {\n            if (sb.length() != 0)\n                sb.append(\" \");\n            sb.append(element.text());\n        }\n        return sb.toString();\n    }\n\n    public boolean hasText() {\n        for (Element element: contents) {\n            if (element.hasText())\n                return true;\n        }\n        return false;\n    }\n    \n    \n    public String html() {\n        StringBuilder sb = new StringBuilder();\n        for (Element element : contents) {\n            if (sb.length() != 0)\n                sb.append(\"\\n\");\n            sb.append(element.html());\n        }\n        return sb.toString();\n    }\n    \n    \n    public String outerHtml() {\n        StringBuilder sb = new StringBuilder();\n        for (Element element : contents) {\n            if (sb.length() != 0)\n                sb.append(\"\\n\");\n            sb.append(element.outerHtml());\n        }\n        return sb.toString();\n    }\n\n    \n    public String toString() {\n        return outerHtml();\n    }\n\n    \n    public Elements tagName(String tagName) {\n        for (Element element : contents) {\n            element.tagName(tagName);\n        }\n        return this;\n    }\n    \n    \n    public Elements html(String html) {\n        for (Element element : contents) {\n            element.html(html);\n        }\n        return this;\n    }\n    \n    \n    public Elements prepend(String html) {\n        for (Element element : contents) {\n            element.prepend(html);\n        }\n        return this;\n    }\n    \n    \n    public Elements append(String html) {\n        for (Element element : contents) {\n            element.append(html);\n        }\n        return this;\n    }\n    \n    \n    public Elements before(String html) {\n        for (Element element : contents) {\n            element.before(html);\n        }\n        return this;\n    }\n    \n    \n    public Elements after(String html) {\n        for (Element element : contents) {\n            element.after(html);\n        }\n        return this;\n    }\n\n    \n    public Elements wrap(String html) {\n        Validate.notEmpty(html);\n        for (Element element : contents) {\n            element.wrap(html);\n        }\n        return this;\n    }\n\n    \n    public Elements unwrap() {\n        for (Element element : contents) {\n            element.unwrap();\n        }\n        return this;\n    }\n\n    \n    public Elements empty() {\n        for (Element element : contents) {\n            element.empty();\n        }\n        return this;\n    }\n\n    \n    public Elements remove() {\n        for (Element element : contents) {\n            element.remove();\n        }\n        return this;\n    }\n    \n    \n    \n    \n    public Elements select(String query) {\n        return Selector.select(query, this);\n    }\n\n    \n    public Elements not(String query) {\n        Elements out = Selector.select(query, this);\n        return Selector.filterOut(this, out);\n    }\n    \n    \n    public Elements eq(int index) {\n        return contents.size() > index ? new Elements(get(index)) : new Elements();\n    }\n    \n    \n    public boolean is(String query) {\n        Elements children = select(query);\n        return !children.isEmpty();\n    }\n\n    \n    public Elements parents() {\n        HashSet<Element> combo = new LinkedHashSet<Element>();\n        for (Element e: contents) {\n            combo.addAll(e.parents());\n        }\n        return new Elements(combo);\n    }\n\n    \n    \n    public Element first() {\n        return contents.isEmpty() ? null : contents.get(0);\n    }\n\n    \n    public Element last() {\n        return contents.isEmpty() ? null : contents.get(contents.size() - 1);\n    }\n\n    \n    public Elements traverse(NodeVisitor nodeVisitor) {\n        Validate.notNull(nodeVisitor);\n        NodeTraversor traversor = new NodeTraversor(nodeVisitor);\n        for (Element el: contents) {\n            traversor.traverse(el);\n        }\n        return this;\n    }\n\n    \n    public int size() {return contents.size();}\n\n    public boolean isEmpty() {return contents.isEmpty();}\n\n    public boolean contains(Object o) {return contents.contains(o);}\n\n    public Iterator<Element> iterator() {return contents.iterator();}\n\n    public Object[] toArray() {return contents.toArray();}\n\n    public <T> T[] toArray(T[] a) {return contents.toArray(a);}\n\n    public boolean add(Element element) {return contents.add(element);}\n\n    public boolean remove(Object o) {return contents.remove(o);}\n\n    public boolean containsAll(Collection<?> c) {return contents.containsAll(c);}\n\n    public boolean addAll(Collection<? extends Element> c) {return contents.addAll(c);}\n\n    public boolean addAll(int index, Collection<? extends Element> c) {return contents.addAll(index, c);}\n\n    public boolean removeAll(Collection<?> c) {return contents.removeAll(c);}\n\n    public boolean retainAll(Collection<?> c) {return contents.retainAll(c);}\n\n    public void clear() {contents.clear();}\n\n    public boolean equals(Object o) {return contents.equals(o);}\n\n    public int hashCode() {return contents.hashCode();}\n\n    public Element get(int index) {return contents.get(index);}\n\n    public Element set(int index, Element element) {return contents.set(index, element);}\n\n    public void add(int index, Element element) {contents.add(index, element);}\n\n    public Element remove(int index) {return contents.remove(index);}\n\n    public int indexOf(Object o) {return contents.indexOf(o);}\n\n    public int lastIndexOf(Object o) {return contents.lastIndexOf(o);}\n\n    public ListIterator<Element> listIterator() {return contents.listIterator();}\n\n    public ListIterator<Element> listIterator(int index) {return contents.listIterator(index);}\n\n    public List<Element> subList(int fromIndex, int toIndex) {return contents.subList(fromIndex, toIndex);}\n}\n",
      "buggy_signatures": [
        "public class Elements implements List<Element>, Cloneable { private List<Element> contents; public Elements()",
        "public Elements(Collection<Element> elements)",
        "public Elements(List<Element> elements)",
        "public Elements(Element... elements)",
        "public Elements clone()",
        "public String attr(String attributeKey)",
        "public boolean hasAttr(String attributeKey)",
        "public Elements attr(String attributeKey, String attributeValue)",
        "public Elements removeAttr(String attributeKey)",
        "public Elements addClass(String className)",
        "public Elements removeClass(String className)",
        "public Elements toggleClass(String className)",
        "public boolean hasClass(String className)",
        "public String val()",
        "public Elements val(String value)",
        "public String text()",
        "public boolean hasText()",
        "public String html()",
        "public String outerHtml()",
        "public String toString()",
        "public Elements tagName(String tagName)",
        "public Elements html(String html)",
        "public Elements prepend(String html)",
        "public Elements append(String html)",
        "public Elements before(String html)",
        "public Elements after(String html)",
        "public Elements wrap(String html)",
        "public Elements unwrap()",
        "public Elements empty()",
        "public Elements remove()",
        "public Elements select(String query)",
        "public Elements not(String query)",
        "public Elements eq(int index)",
        "public boolean is(String query)",
        "public Elements parents()",
        "public Element first()",
        "public Element last()",
        "public Elements traverse(NodeVisitor nodeVisitor)",
        "public int size()",
        "public boolean isEmpty()",
        "public boolean contains(Object o)",
        "public Iterator<Element> iterator()",
        "public Object[] toArray()",
        "public <T> T[] toArray(T[] a)",
        "public boolean add(Element element)",
        "public boolean remove(Object o)",
        "public boolean containsAll(Collection<?> c)",
        "public boolean addAll(Collection<? extends Element> c)",
        "public boolean addAll(int index, Collection<? extends Element> c)",
        "public boolean removeAll(Collection<?> c)",
        "public boolean retainAll(Collection<?> c)",
        "public void clear()",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "public Element get(int index)",
        "public Element set(int index, Element element)",
        "public void add(int index, Element element)",
        "public Element remove(int index)",
        "public int indexOf(Object o)",
        "public int lastIndexOf(Object o)",
        "public ListIterator<Element> listIterator()",
        "public ListIterator<Element> listIterator(int index)",
        "public List<Element> subList(int fromIndex, int toIndex)"
      ],
      "fixed_signatures": [
        "public class Elements implements List<Element>, Cloneable { private List<Element> contents; public Elements()",
        "public Elements(int initialCapacity)",
        "public Elements(Collection<Element> elements)",
        "public Elements(List<Element> elements)",
        "public Elements(Element... elements)",
        "public Elements clone()",
        "public String attr(String attributeKey)",
        "public boolean hasAttr(String attributeKey)",
        "public Elements attr(String attributeKey, String attributeValue)",
        "public Elements removeAttr(String attributeKey)",
        "public Elements addClass(String className)",
        "public Elements removeClass(String className)",
        "public Elements toggleClass(String className)",
        "public boolean hasClass(String className)",
        "public String val()",
        "public Elements val(String value)",
        "public String text()",
        "public boolean hasText()",
        "public String html()",
        "public String outerHtml()",
        "public String toString()",
        "public Elements tagName(String tagName)",
        "public Elements html(String html)",
        "public Elements prepend(String html)",
        "public Elements append(String html)",
        "public Elements before(String html)",
        "public Elements after(String html)",
        "public Elements wrap(String html)",
        "public Elements unwrap()",
        "public Elements empty()",
        "public Elements remove()",
        "public Elements select(String query)",
        "public Elements not(String query)",
        "public Elements eq(int index)",
        "public boolean is(String query)",
        "public Elements parents()",
        "public Element first()",
        "public Element last()",
        "public Elements traverse(NodeVisitor nodeVisitor)",
        "public int size()",
        "public boolean isEmpty()",
        "public boolean contains(Object o)",
        "public Iterator<Element> iterator()",
        "public Object[] toArray()",
        "public <T> T[] toArray(T[] a)",
        "public boolean add(Element element)",
        "public boolean remove(Object o)",
        "public boolean containsAll(Collection<?> c)",
        "public boolean addAll(Collection<? extends Element> c)",
        "public boolean addAll(int index, Collection<? extends Element> c)",
        "public boolean removeAll(Collection<?> c)",
        "public boolean retainAll(Collection<?> c)",
        "public void clear()",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "public Element get(int index)",
        "public Element set(int index, Element element)",
        "public void add(int index, Element element)",
        "public Element remove(int index)",
        "public int indexOf(Object o)",
        "public int lastIndexOf(Object o)",
        "public ListIterator<Element> listIterator()",
        "public ListIterator<Element> listIterator(int index)",
        "public List<Element> subList(int fromIndex, int toIndex)"
      ],
      "methods": [
        {
          "buggy_method": "  public Elements(Collection<Element> elements) {\n  contents = new ArrayList<Element>(elements);\n  }",
          "fixed_method": "  public Elements(int initialCapacity) {\n  contents = new ArrayList<Element>(initialCapacity);\n  }",
          "diff": [
            "@@ -19,6 +19,9 @@",
            "         contents = new ArrayList<Element>();\n",
            "     }\n",
            " \n",
            "+    public Elements(int initialCapacity) {\n",
            "+        contents = new ArrayList<Element>(initialCapacity);\n",
            "+    }\n",
            " \n",
            "     public Elements(Collection<Element> elements) {\n",
            "         contents = new ArrayList<Element>(elements);\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
