{
  "bug_id": "29",
  "failed_tests": {
    "org.apache.commons.math3.linear.SparseRealVectorTest": [
      {
        "methodName": "testEbeDivideMixedTypes",
        "error": "junit.framework.AssertionFailedError",
        "message": "entry #0, left = 0.0, right = 0.0 expected:<NaN> but was:<0.0>",
        "fail_line": "",
        "test_source": "",
        "stack": [
          "RealVectorAbstractTest.doTestEbeBinaryOperation line 519, RealVectorAbstractTest.testEbeDivideMixedTypes line 595"
        ]
      },
      {
        "methodName": "testEbeMultiplyMixedTypes",
        "error": "junit.framework.AssertionFailedError",
        "message": "entry #5, left = 0.0, right = Infinity expected:<NaN> but was:<0.0>",
        "fail_line": "",
        "test_source": "",
        "stack": [
          "RealVectorAbstractTest.doTestEbeBinaryOperation line 519, RealVectorAbstractTest.testEbeMultiplyMixedTypes line 580"
        ]
      },
      {
        "methodName": "testEbeMultiplySameType",
        "error": "junit.framework.AssertionFailedError",
        "message": "entry #5, left = 0.0, right = Infinity expected:<NaN> but was:<0.0>",
        "fail_line": "",
        "test_source": "",
        "stack": [
          "RealVectorAbstractTest.doTestEbeBinaryOperation line 519, RealVectorAbstractTest.testEbeMultiplySameType line 575"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math3/linear/OpenMapRealVector.java",
      "buggy_full_code": "\npackage org.apache.commons.math3.linear;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math3.exception.MathArithmeticException;\nimport org.apache.commons.math3.exception.NotPositiveException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.util.OpenIntToDoubleHashMap;\nimport org.apache.commons.math3.util.OpenIntToDoubleHashMap.Iterator;\nimport org.apache.commons.math3.util.FastMath;\n\n\npublic class OpenMapRealVector extends SparseRealVector implements Serializable { public static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12; private static final long serialVersionUID = 8772222695580707260L; private final OpenIntToDoubleHashMap entries; private final int virtualSize; private final double epsilon; public OpenMapRealVector() {\n        this(0, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(int dimension) {\n        this(dimension, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(int dimension, double epsilon) {\n        virtualSize = dimension;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n    }\n\n    \n    protected OpenMapRealVector(OpenMapRealVector v, int resize) {\n        virtualSize = v.getDimension() + resize;\n        entries = new OpenIntToDoubleHashMap(v.entries);\n        epsilon = v.epsilon;\n    }\n\n    \n    public OpenMapRealVector(int dimension, int expectedSize) {\n        this(dimension, expectedSize, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(int dimension, int expectedSize, double epsilon) {\n        virtualSize = dimension;\n        entries = new OpenIntToDoubleHashMap(expectedSize, 0.0);\n        this.epsilon = epsilon;\n    }\n\n    \n    public OpenMapRealVector(double[] values) {\n        this(values, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(double[] values, double epsilon) {\n        virtualSize = values.length;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n        for (int key = 0; key < values.length; key++) {\n            double value = values[key];\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    \n    public OpenMapRealVector(Double[] values) {\n        this(values, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(Double[] values, double epsilon) {\n        virtualSize = values.length;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n        for (int key = 0; key < values.length; key++) {\n            double value = values[key].doubleValue();\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    \n    public OpenMapRealVector(OpenMapRealVector v) {\n        virtualSize = v.getDimension();\n        entries = new OpenIntToDoubleHashMap(v.getEntries());\n        epsilon = v.epsilon;\n    }\n\n    \n    public OpenMapRealVector(RealVector v) {\n        virtualSize = v.getDimension();\n        entries = new OpenIntToDoubleHashMap(0.0);\n        epsilon = DEFAULT_ZERO_TOLERANCE;\n        for (int key = 0; key < virtualSize; key++) {\n            double value = v.getEntry(key);\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    \n    private OpenIntToDoubleHashMap getEntries() {\n        return entries;\n    }\n\n    \n    protected boolean isDefaultValue(double value) {\n        return FastMath.abs(value) < epsilon;\n    }\n\n    \n    @Override\n    public RealVector add(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return add((OpenMapRealVector) v);\n        } else {\n            return super.add(v);\n        }\n    }\n\n    \n    public OpenMapRealVector add(OpenMapRealVector v) {\n        checkVectorDimensions(v.getDimension());\n        boolean copyThis = entries.size() > v.entries.size();\n        OpenMapRealVector res = copyThis ? this.copy() : v.copy();\n        Iterator iter = copyThis ? v.entries.iterator() : entries.iterator();\n        OpenIntToDoubleHashMap randomAccess = copyThis ? entries : v.entries;\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (randomAccess.containsKey(key)) {\n                res.setEntry(key, randomAccess.get(key) + iter.value());\n            } else {\n                res.setEntry(key, iter.value());\n            }\n        }\n        return res;\n    }\n\n    \n    public OpenMapRealVector append(OpenMapRealVector v) {\n        OpenMapRealVector res = new OpenMapRealVector(this, v.getDimension());\n        Iterator iter = v.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key() + virtualSize, iter.value());\n        }\n        return res;\n    }\n\n    \n    @Override\n    public OpenMapRealVector append(RealVector v) {\n        if (v instanceof OpenMapRealVector) {\n            return append((OpenMapRealVector) v);\n        } else {\n            final OpenMapRealVector res = new OpenMapRealVector(this, v.getDimension());\n            for (int i = 0; i < v.getDimension(); i++) {\n                res.setEntry(i + virtualSize, v.getEntry(i));\n            }\n            return res;\n        }\n    }\n\n    \n    @Override\n    public OpenMapRealVector append(double d) {\n        OpenMapRealVector res = new OpenMapRealVector(this, 1);\n        res.setEntry(virtualSize, d);\n        return res;\n    }\n\n    \n    @Override\n    public OpenMapRealVector copy() {\n        return new OpenMapRealVector(this);\n    }\n\n    \n    public double dotProduct(OpenMapRealVector v) {\n        checkVectorDimensions(v.getDimension());\n        boolean thisIsSmaller  = entries.size() < v.entries.size();\n        Iterator iter = thisIsSmaller  ? entries.iterator() : v.entries.iterator();\n        OpenIntToDoubleHashMap larger = thisIsSmaller  ? v.entries : entries;\n        double d = 0;\n        while(iter.hasNext()) {\n            iter.advance();\n            d += iter.value() * larger.get(iter.key());\n        }\n        return d;\n    }\n\n    \n    @Override\n    public double dotProduct(RealVector v) {\n        if(v instanceof OpenMapRealVector) {\n            return dotProduct((OpenMapRealVector)v);\n        } else {\n            return super.dotProduct(v);\n        }\n    }\n\n    \n    @Override\n    public OpenMapRealVector ebeDivide(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        \n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n        }\n        return res;\n    }\n\n    \n    @Override\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        \n        return res;\n    }\n\n    \n    @Override\n    public OpenMapRealVector getSubVector(int index, int n) {\n        checkIndex(index);\n        if (n < 0) {\n            throw new NotPositiveException(LocalizedFormats.NUMBER_OF_ELEMENTS_SHOULD_BE_POSITIVE, n);\n        }\n        checkIndex(index + n - 1);\n        OpenMapRealVector res = new OpenMapRealVector(n);\n        int end = index + n;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (key >= index && key < end) {\n                res.setEntry(key - index, iter.value());\n            }\n        }\n        return res;\n    }\n\n    \n    @Override\n    public int getDimension() {\n        return virtualSize;\n    }\n\n    \n    public double getDistance(OpenMapRealVector v) {\n        Iterator iter = entries.iterator();\n        double res = 0;\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            double delta;\n            delta = iter.value() - v.getEntry(key);\n            res += delta * delta;\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                final double value = iter.value();\n                res += value * value;\n            }\n        }\n        return FastMath.sqrt(res);\n    }\n\n    \n    @Override\n    public double getDistance(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getDistance((OpenMapRealVector) v);\n        } else {\n            return super.getDistance(v);\n        }\n    }\n\n    \n    @Override\n    public double getEntry(int index) {\n        checkIndex(index);\n        return entries.get(index);\n    }\n\n    \n    public double getL1Distance(OpenMapRealVector v) {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double delta = FastMath.abs(iter.value() - v.getEntry(iter.key()));\n            max += delta;\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                double delta = FastMath.abs(iter.value());\n                max +=  FastMath.abs(delta);\n            }\n        }\n        return max;\n    }\n\n    \n    @Override\n    public double getL1Distance(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getL1Distance((OpenMapRealVector) v);\n        } else {\n            return super.getL1Distance(v);\n        }\n    }\n\n    \n    private double getLInfDistance(OpenMapRealVector v) {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double delta = FastMath.abs(iter.value() - v.getEntry(iter.key()));\n            if (delta > max) {\n                max = delta;\n            }\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                if (iter.value() > max) {\n                    max = iter.value();\n                }\n            }\n        }\n        return max;\n    }\n\n    \n    @Override\n    public double getLInfDistance(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getLInfDistance((OpenMapRealVector) v);\n        } else {\n            return super.getLInfDistance(v);\n        }\n    }\n\n    \n    @Override\n    public boolean isInfinite() {\n        boolean infiniteFound = false;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            final double value = iter.value();\n            if (Double.isNaN(value)) {\n                return false;\n            }\n            if (Double.isInfinite(value)) {\n                infiniteFound = true;\n            }\n        }\n        return infiniteFound;\n    }\n\n    \n    @Override\n    public boolean isNaN() {\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            if (Double.isNaN(iter.value())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    @Override\n    public OpenMapRealVector mapAdd(double d) {\n        return copy().mapAddToSelf(d);\n    }\n\n    \n    @Override\n    public OpenMapRealVector mapAddToSelf(double d) {\n        for (int i = 0; i < virtualSize; i++) {\n            setEntry(i, getEntry(i) + d);\n        }\n        return this;\n    }\n\n    \n    @Override\n    public RealVector projection(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        return v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n    }\n\n    \n    @Override\n    public void setEntry(int index, double value) {\n        checkIndex(index);\n        if (!isDefaultValue(value)) {\n            entries.put(index, value);\n        } else if (entries.containsKey(index)) {\n            entries.remove(index);\n        }\n    }\n\n    \n    @Override\n    public void setSubVector(int index, RealVector v) {\n        checkIndex(index);\n        checkIndex(index + v.getDimension() - 1);\n        for (int i = 0; i < v.getDimension(); i++) {\n            setEntry(i + index, v.getEntry(i));\n        }\n    }\n\n    \n    @Override\n    public void set(double value) {\n        for (int i = 0; i < virtualSize; i++) {\n            setEntry(i, value);\n        }\n    }\n\n    \n    public OpenMapRealVector subtract(OpenMapRealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = copy();\n        Iterator iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (entries.containsKey(key)) {\n                res.setEntry(key, entries.get(key) - iter.value());\n            } else {\n                res.setEntry(key, -iter.value());\n            }\n        }\n        return res;\n    }\n\n    \n    @Override\n    public RealVector subtract(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return subtract((OpenMapRealVector) v);\n        } else {\n            return super.subtract(v);\n        }\n    }\n\n    \n    @Override\n    public OpenMapRealVector unitVector() {\n        OpenMapRealVector res = copy();\n        res.unitize();\n        return res;\n    }\n\n    \n    @Override\n    public void unitize() {\n        double norm = getNorm();\n        if (isDefaultValue(norm)) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            entries.put(iter.key(), iter.value() / norm);\n        }\n    }\n\n    \n    @Override\n    public double[] toArray() {\n        double[] res = new double[virtualSize];\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res[iter.key()] = iter.value();\n        }\n        return res;\n    }\n\n    \n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        long temp;\n        temp = Double.doubleToLongBits(epsilon);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        result = prime * result + virtualSize;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            temp = Double.doubleToLongBits(iter.value());\n            result = prime * result + (int) (temp ^ (temp >>32));\n        }\n        return result;\n    }\n\n    \n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof OpenMapRealVector)) {\n            return false;\n        }\n        OpenMapRealVector other = (OpenMapRealVector) obj;\n        if (virtualSize != other.virtualSize) {\n            return false;\n        }\n        if (Double.doubleToLongBits(epsilon) !=\n            Double.doubleToLongBits(other.epsilon)) {\n            return false;\n        }\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double test = other.getEntry(iter.key());\n            if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {\n                return false;\n            }\n        }\n        iter = other.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double test = iter.value();\n            if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public double getSparsity() {\n        return (double)entries.size()/(double)getDimension();\n    }\n\n    \n    @Override\n    public java.util.Iterator<Entry> sparseIterator() {\n        return new OpenMapSparseIterator();\n    }\n\n    \n    protected class OpenMapEntry extends Entry { private final Iterator iter; protected OpenMapEntry(Iterator iter) {\n            this.iter = iter;\n        }\n\n        \n        @Override\n        public double getValue() {\n            return iter.value();\n        }\n\n        \n        @Override\n        public void setValue(double value) {\n            entries.put(iter.key(), value);\n        }\n\n        \n        @Override\n        public int getIndex() {\n            return iter.key();\n        }\n\n    }\n\n    \n    protected class OpenMapSparseIterator implements java.util.Iterator<Entry> { private final Iterator iter; private final Entry current; protected OpenMapSparseIterator() {\n            iter = entries.iterator();\n            current = new OpenMapEntry(iter);\n        }\n\n        \n        public boolean hasNext() {\n            return iter.hasNext();\n        }\n\n        \n        public Entry next() {\n            iter.advance();\n            return current;\n        }\n\n        \n        public void remove() {\n            throw new UnsupportedOperationException(\"Not supported\");\n        }\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.math3.linear;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math3.exception.MathArithmeticException;\nimport org.apache.commons.math3.exception.NotPositiveException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.util.OpenIntToDoubleHashMap;\nimport org.apache.commons.math3.util.OpenIntToDoubleHashMap.Iterator;\nimport org.apache.commons.math3.util.FastMath;\n\n\npublic class OpenMapRealVector extends SparseRealVector implements Serializable { public static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12; private static final long serialVersionUID = 8772222695580707260L; private final OpenIntToDoubleHashMap entries; private final int virtualSize; private final double epsilon; public OpenMapRealVector() {\n        this(0, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(int dimension) {\n        this(dimension, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(int dimension, double epsilon) {\n        virtualSize = dimension;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n    }\n\n    \n    protected OpenMapRealVector(OpenMapRealVector v, int resize) {\n        virtualSize = v.getDimension() + resize;\n        entries = new OpenIntToDoubleHashMap(v.entries);\n        epsilon = v.epsilon;\n    }\n\n    \n    public OpenMapRealVector(int dimension, int expectedSize) {\n        this(dimension, expectedSize, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(int dimension, int expectedSize, double epsilon) {\n        virtualSize = dimension;\n        entries = new OpenIntToDoubleHashMap(expectedSize, 0.0);\n        this.epsilon = epsilon;\n    }\n\n    \n    public OpenMapRealVector(double[] values) {\n        this(values, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(double[] values, double epsilon) {\n        virtualSize = values.length;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n        for (int key = 0; key < values.length; key++) {\n            double value = values[key];\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    \n    public OpenMapRealVector(Double[] values) {\n        this(values, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(Double[] values, double epsilon) {\n        virtualSize = values.length;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n        for (int key = 0; key < values.length; key++) {\n            double value = values[key].doubleValue();\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    \n    public OpenMapRealVector(OpenMapRealVector v) {\n        virtualSize = v.getDimension();\n        entries = new OpenIntToDoubleHashMap(v.getEntries());\n        epsilon = v.epsilon;\n    }\n\n    \n    public OpenMapRealVector(RealVector v) {\n        virtualSize = v.getDimension();\n        entries = new OpenIntToDoubleHashMap(0.0);\n        epsilon = DEFAULT_ZERO_TOLERANCE;\n        for (int key = 0; key < virtualSize; key++) {\n            double value = v.getEntry(key);\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    \n    private OpenIntToDoubleHashMap getEntries() {\n        return entries;\n    }\n\n    \n    protected boolean isDefaultValue(double value) {\n        return FastMath.abs(value) < epsilon;\n    }\n\n    \n    @Override\n    public RealVector add(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return add((OpenMapRealVector) v);\n        } else {\n            return super.add(v);\n        }\n    }\n\n    \n    public OpenMapRealVector add(OpenMapRealVector v) {\n        checkVectorDimensions(v.getDimension());\n        boolean copyThis = entries.size() > v.entries.size();\n        OpenMapRealVector res = copyThis ? this.copy() : v.copy();\n        Iterator iter = copyThis ? v.entries.iterator() : entries.iterator();\n        OpenIntToDoubleHashMap randomAccess = copyThis ? entries : v.entries;\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (randomAccess.containsKey(key)) {\n                res.setEntry(key, randomAccess.get(key) + iter.value());\n            } else {\n                res.setEntry(key, iter.value());\n            }\n        }\n        return res;\n    }\n\n    \n    public OpenMapRealVector append(OpenMapRealVector v) {\n        OpenMapRealVector res = new OpenMapRealVector(this, v.getDimension());\n        Iterator iter = v.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key() + virtualSize, iter.value());\n        }\n        return res;\n    }\n\n    \n    @Override\n    public OpenMapRealVector append(RealVector v) {\n        if (v instanceof OpenMapRealVector) {\n            return append((OpenMapRealVector) v);\n        } else {\n            final OpenMapRealVector res = new OpenMapRealVector(this, v.getDimension());\n            for (int i = 0; i < v.getDimension(); i++) {\n                res.setEntry(i + virtualSize, v.getEntry(i));\n            }\n            return res;\n        }\n    }\n\n    \n    @Override\n    public OpenMapRealVector append(double d) {\n        OpenMapRealVector res = new OpenMapRealVector(this, 1);\n        res.setEntry(virtualSize, d);\n        return res;\n    }\n\n    \n    @Override\n    public OpenMapRealVector copy() {\n        return new OpenMapRealVector(this);\n    }\n\n    \n    public double dotProduct(OpenMapRealVector v) {\n        checkVectorDimensions(v.getDimension());\n        boolean thisIsSmaller  = entries.size() < v.entries.size();\n        Iterator iter = thisIsSmaller  ? entries.iterator() : v.entries.iterator();\n        OpenIntToDoubleHashMap larger = thisIsSmaller  ? v.entries : entries;\n        double d = 0;\n        while(iter.hasNext()) {\n            iter.advance();\n            d += iter.value() * larger.get(iter.key());\n        }\n        return d;\n    }\n\n    \n    @Override\n    public double dotProduct(RealVector v) {\n        if(v instanceof OpenMapRealVector) {\n            return dotProduct((OpenMapRealVector)v);\n        } else {\n            return super.dotProduct(v);\n        }\n    }\n\n    \n    @Override\n    public OpenMapRealVector ebeDivide(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        \n        final int n = getDimension();\n        for (int i = 0; i < n; i++) {\n            res.setEntry(i, this.getEntry(i) / v.getEntry(i));\n        }\n        return res;\n    }\n\n    \n    @Override\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        \n        if (v.isNaN() || v.isInfinite()) {\n            final int n = getDimension();\n            for (int i = 0; i < n; i++) {\n                final double y = v.getEntry(i);\n                if (Double.isNaN(y)) {\n                    res.setEntry(i, Double.NaN);\n                } else if (Double.isInfinite(y)) {\n                    final double x = this.getEntry(i);\n                    res.setEntry(i, x * y);\n                }\n            }\n        }\n        return res;\n    }\n\n    \n    @Override\n    public OpenMapRealVector getSubVector(int index, int n) {\n        checkIndex(index);\n        if (n < 0) {\n            throw new NotPositiveException(LocalizedFormats.NUMBER_OF_ELEMENTS_SHOULD_BE_POSITIVE, n);\n        }\n        checkIndex(index + n - 1);\n        OpenMapRealVector res = new OpenMapRealVector(n);\n        int end = index + n;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (key >= index && key < end) {\n                res.setEntry(key - index, iter.value());\n            }\n        }\n        return res;\n    }\n\n    \n    @Override\n    public int getDimension() {\n        return virtualSize;\n    }\n\n    \n    public double getDistance(OpenMapRealVector v) {\n        Iterator iter = entries.iterator();\n        double res = 0;\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            double delta;\n            delta = iter.value() - v.getEntry(key);\n            res += delta * delta;\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                final double value = iter.value();\n                res += value * value;\n            }\n        }\n        return FastMath.sqrt(res);\n    }\n\n    \n    @Override\n    public double getDistance(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getDistance((OpenMapRealVector) v);\n        } else {\n            return super.getDistance(v);\n        }\n    }\n\n    \n    @Override\n    public double getEntry(int index) {\n        checkIndex(index);\n        return entries.get(index);\n    }\n\n    \n    public double getL1Distance(OpenMapRealVector v) {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double delta = FastMath.abs(iter.value() - v.getEntry(iter.key()));\n            max += delta;\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                double delta = FastMath.abs(iter.value());\n                max +=  FastMath.abs(delta);\n            }\n        }\n        return max;\n    }\n\n    \n    @Override\n    public double getL1Distance(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getL1Distance((OpenMapRealVector) v);\n        } else {\n            return super.getL1Distance(v);\n        }\n    }\n\n    \n    private double getLInfDistance(OpenMapRealVector v) {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double delta = FastMath.abs(iter.value() - v.getEntry(iter.key()));\n            if (delta > max) {\n                max = delta;\n            }\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                if (iter.value() > max) {\n                    max = iter.value();\n                }\n            }\n        }\n        return max;\n    }\n\n    \n    @Override\n    public double getLInfDistance(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getLInfDistance((OpenMapRealVector) v);\n        } else {\n            return super.getLInfDistance(v);\n        }\n    }\n\n    \n    @Override\n    public boolean isInfinite() {\n        boolean infiniteFound = false;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            final double value = iter.value();\n            if (Double.isNaN(value)) {\n                return false;\n            }\n            if (Double.isInfinite(value)) {\n                infiniteFound = true;\n            }\n        }\n        return infiniteFound;\n    }\n\n    \n    @Override\n    public boolean isNaN() {\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            if (Double.isNaN(iter.value())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    @Override\n    public OpenMapRealVector mapAdd(double d) {\n        return copy().mapAddToSelf(d);\n    }\n\n    \n    @Override\n    public OpenMapRealVector mapAddToSelf(double d) {\n        for (int i = 0; i < virtualSize; i++) {\n            setEntry(i, getEntry(i) + d);\n        }\n        return this;\n    }\n\n    \n    @Override\n    public RealVector projection(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        return v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n    }\n\n    \n    @Override\n    public void setEntry(int index, double value) {\n        checkIndex(index);\n        if (!isDefaultValue(value)) {\n            entries.put(index, value);\n        } else if (entries.containsKey(index)) {\n            entries.remove(index);\n        }\n    }\n\n    \n    @Override\n    public void setSubVector(int index, RealVector v) {\n        checkIndex(index);\n        checkIndex(index + v.getDimension() - 1);\n        for (int i = 0; i < v.getDimension(); i++) {\n            setEntry(i + index, v.getEntry(i));\n        }\n    }\n\n    \n    @Override\n    public void set(double value) {\n        for (int i = 0; i < virtualSize; i++) {\n            setEntry(i, value);\n        }\n    }\n\n    \n    public OpenMapRealVector subtract(OpenMapRealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = copy();\n        Iterator iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (entries.containsKey(key)) {\n                res.setEntry(key, entries.get(key) - iter.value());\n            } else {\n                res.setEntry(key, -iter.value());\n            }\n        }\n        return res;\n    }\n\n    \n    @Override\n    public RealVector subtract(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return subtract((OpenMapRealVector) v);\n        } else {\n            return super.subtract(v);\n        }\n    }\n\n    \n    @Override\n    public OpenMapRealVector unitVector() {\n        OpenMapRealVector res = copy();\n        res.unitize();\n        return res;\n    }\n\n    \n    @Override\n    public void unitize() {\n        double norm = getNorm();\n        if (isDefaultValue(norm)) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            entries.put(iter.key(), iter.value() / norm);\n        }\n    }\n\n    \n    @Override\n    public double[] toArray() {\n        double[] res = new double[virtualSize];\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res[iter.key()] = iter.value();\n        }\n        return res;\n    }\n\n    \n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        long temp;\n        temp = Double.doubleToLongBits(epsilon);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        result = prime * result + virtualSize;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            temp = Double.doubleToLongBits(iter.value());\n            result = prime * result + (int) (temp ^ (temp >>32));\n        }\n        return result;\n    }\n\n    \n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof OpenMapRealVector)) {\n            return false;\n        }\n        OpenMapRealVector other = (OpenMapRealVector) obj;\n        if (virtualSize != other.virtualSize) {\n            return false;\n        }\n        if (Double.doubleToLongBits(epsilon) !=\n            Double.doubleToLongBits(other.epsilon)) {\n            return false;\n        }\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double test = other.getEntry(iter.key());\n            if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {\n                return false;\n            }\n        }\n        iter = other.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double test = iter.value();\n            if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public double getSparsity() {\n        return (double)entries.size()/(double)getDimension();\n    }\n\n    \n    @Override\n    public java.util.Iterator<Entry> sparseIterator() {\n        return new OpenMapSparseIterator();\n    }\n\n    \n    protected class OpenMapEntry extends Entry { private final Iterator iter; protected OpenMapEntry(Iterator iter) {\n            this.iter = iter;\n        }\n\n        \n        @Override\n        public double getValue() {\n            return iter.value();\n        }\n\n        \n        @Override\n        public void setValue(double value) {\n            entries.put(iter.key(), value);\n        }\n\n        \n        @Override\n        public int getIndex() {\n            return iter.key();\n        }\n\n    }\n\n    \n    protected class OpenMapSparseIterator implements java.util.Iterator<Entry> { private final Iterator iter; private final Entry current; protected OpenMapSparseIterator() {\n            iter = entries.iterator();\n            current = new OpenMapEntry(iter);\n        }\n\n        \n        public boolean hasNext() {\n            return iter.hasNext();\n        }\n\n        \n        public Entry next() {\n            iter.advance();\n            return current;\n        }\n\n        \n        public void remove() {\n            throw new UnsupportedOperationException(\"Not supported\");\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public OpenMapRealVector(int dimension)",
        "public OpenMapRealVector(int dimension, double epsilon)",
        "protected OpenMapRealVector(OpenMapRealVector v, int resize)",
        "public OpenMapRealVector(int dimension, int expectedSize)",
        "public OpenMapRealVector(int dimension, int expectedSize, double epsilon)",
        "public OpenMapRealVector(double[] values)",
        "public OpenMapRealVector(double[] values, double epsilon)",
        "public OpenMapRealVector(Double[] values)",
        "public OpenMapRealVector(Double[] values, double epsilon)",
        "public OpenMapRealVector(OpenMapRealVector v)",
        "public OpenMapRealVector(RealVector v)",
        "private OpenIntToDoubleHashMap getEntries()",
        "protected boolean isDefaultValue(double value)",
        "public RealVector add(RealVector v)",
        "public OpenMapRealVector add(OpenMapRealVector v)",
        "public OpenMapRealVector append(OpenMapRealVector v)",
        "public OpenMapRealVector append(RealVector v)",
        "public OpenMapRealVector append(double d)",
        "public OpenMapRealVector copy()",
        "public double dotProduct(OpenMapRealVector v)",
        "public double dotProduct(RealVector v)",
        "public OpenMapRealVector ebeDivide(RealVector v)",
        "public OpenMapRealVector ebeMultiply(RealVector v)",
        "public OpenMapRealVector getSubVector(int index, int n)",
        "public int getDimension()",
        "public double getDistance(OpenMapRealVector v)",
        "public double getDistance(RealVector v)",
        "public double getEntry(int index)",
        "public double getL1Distance(OpenMapRealVector v)",
        "public double getL1Distance(RealVector v)",
        "private double getLInfDistance(OpenMapRealVector v)",
        "public double getLInfDistance(RealVector v)",
        "public boolean isInfinite()",
        "public boolean isNaN()",
        "public OpenMapRealVector mapAdd(double d)",
        "public OpenMapRealVector mapAddToSelf(double d)",
        "public RealVector projection(RealVector v)",
        "public void setEntry(int index, double value)",
        "public void setSubVector(int index, RealVector v)",
        "public void set(double value)",
        "public OpenMapRealVector subtract(OpenMapRealVector v)",
        "public RealVector subtract(RealVector v)",
        "public OpenMapRealVector unitVector()",
        "public void unitize()",
        "public double[] toArray()",
        "public int hashCode()",
        "public boolean equals(Object obj)",
        "public double getSparsity()",
        "public java.util.Iterator<Entry> sparseIterator()",
        "protected class OpenMapEntry extends Entry { private final Iterator iter; protected OpenMapEntry(Iterator iter)",
        "public double getValue()",
        "public void setValue(double value)",
        "public int getIndex()",
        "protected class OpenMapSparseIterator implements java.util.Iterator<Entry> { private final Iterator iter; private final Entry current; protected OpenMapSparseIterator()",
        "public boolean hasNext()",
        "public Entry next()",
        "public void remove()"
      ],
      "fixed_signatures": [
        "public OpenMapRealVector(int dimension)",
        "public OpenMapRealVector(int dimension, double epsilon)",
        "protected OpenMapRealVector(OpenMapRealVector v, int resize)",
        "public OpenMapRealVector(int dimension, int expectedSize)",
        "public OpenMapRealVector(int dimension, int expectedSize, double epsilon)",
        "public OpenMapRealVector(double[] values)",
        "public OpenMapRealVector(double[] values, double epsilon)",
        "public OpenMapRealVector(Double[] values)",
        "public OpenMapRealVector(Double[] values, double epsilon)",
        "public OpenMapRealVector(OpenMapRealVector v)",
        "public OpenMapRealVector(RealVector v)",
        "private OpenIntToDoubleHashMap getEntries()",
        "protected boolean isDefaultValue(double value)",
        "public RealVector add(RealVector v)",
        "public OpenMapRealVector add(OpenMapRealVector v)",
        "public OpenMapRealVector append(OpenMapRealVector v)",
        "public OpenMapRealVector append(RealVector v)",
        "public OpenMapRealVector append(double d)",
        "public OpenMapRealVector copy()",
        "public double dotProduct(OpenMapRealVector v)",
        "public double dotProduct(RealVector v)",
        "public OpenMapRealVector ebeDivide(RealVector v)",
        "public OpenMapRealVector ebeMultiply(RealVector v)",
        "public OpenMapRealVector getSubVector(int index, int n)",
        "public int getDimension()",
        "public double getDistance(OpenMapRealVector v)",
        "public double getDistance(RealVector v)",
        "public double getEntry(int index)",
        "public double getL1Distance(OpenMapRealVector v)",
        "public double getL1Distance(RealVector v)",
        "private double getLInfDistance(OpenMapRealVector v)",
        "public double getLInfDistance(RealVector v)",
        "public boolean isInfinite()",
        "public boolean isNaN()",
        "public OpenMapRealVector mapAdd(double d)",
        "public OpenMapRealVector mapAddToSelf(double d)",
        "public RealVector projection(RealVector v)",
        "public void setEntry(int index, double value)",
        "public void setSubVector(int index, RealVector v)",
        "public void set(double value)",
        "public OpenMapRealVector subtract(OpenMapRealVector v)",
        "public RealVector subtract(RealVector v)",
        "public OpenMapRealVector unitVector()",
        "public void unitize()",
        "public double[] toArray()",
        "public int hashCode()",
        "public boolean equals(Object obj)",
        "public double getSparsity()",
        "public java.util.Iterator<Entry> sparseIterator()",
        "protected class OpenMapEntry extends Entry { private final Iterator iter; protected OpenMapEntry(Iterator iter)",
        "public double getValue()",
        "public void setValue(double value)",
        "public int getIndex()",
        "protected class OpenMapSparseIterator implements java.util.Iterator<Entry> { private final Iterator iter; private final Entry current; protected OpenMapSparseIterator()",
        "public boolean hasNext()",
        "public Entry next()",
        "public void remove()"
      ],
      "methods": [
        {
          "buggy_method": "  public OpenMapRealVector ebeDivide(RealVector v) {\n  checkVectorDimensions(v.getDimension());\n  OpenMapRealVector res = new OpenMapRealVector(this);\n  \n  Iterator iter = entries.iterator();\n  while (iter.hasNext()) {\n  iter.advance();\n  res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n  }\n  return res;\n  }",
          "fixed_method": "  public OpenMapRealVector ebeDivide(RealVector v) {\n  checkVectorDimensions(v.getDimension());\n  OpenMapRealVector res = new OpenMapRealVector(this);\n  \n  final int n = getDimension();\n  for (int i = 0; i < n; i++) {\n  res.setEntry(i, this.getEntry(i) / v.getEntry(i));\n  }\n  return res;\n  }",
          "diff": [
            "@@ -346,10 +346,9 @@",
            "          * this only. Indeed, if this[i] = 0d and v[i] = 0d, then\n",
            "          * this[i] / v[i] = NaN, and not 0d.\n",
            "          */\n",
            "-        Iterator iter = entries.iterator();\n",
            "-        while (iter.hasNext()) {\n",
            "-            iter.advance();\n",
            "-            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n",
            "+        final int n = getDimension();\n",
            "+        for (int i = 0; i < n; i++) {\n",
            "+            res.setEntry(i, this.getEntry(i) / v.getEntry(i));\n",
            "         }\n",
            "         return res;\n",
            "     }\n"
          ],
          "changed_lines": 7
        },
        {
          "buggy_method": "  public OpenMapRealVector ebeMultiply(RealVector v) {\n  checkVectorDimensions(v.getDimension());\n  OpenMapRealVector res = new OpenMapRealVector(this);\n  Iterator iter = entries.iterator();\n  while (iter.hasNext()) {\n  iter.advance();\n  res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n  }\n  \n  return res;\n  }",
          "fixed_method": "  public OpenMapRealVector ebeMultiply(RealVector v) {\n  checkVectorDimensions(v.getDimension());\n  OpenMapRealVector res = new OpenMapRealVector(this);\n  Iterator iter = entries.iterator();\n  while (iter.hasNext()) {\n  iter.advance();\n  res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n  }\n  \n  if (v.isNaN() || v.isInfinite()) {\n  final int n = getDimension();\n  for (int i = 0; i < n; i++) {\n  final double y = v.getEntry(i);\n  if (Double.isNaN(y)) {\n  res.setEntry(i, Double.NaN);\n  } else if (Double.isInfinite(y)) {\n  final double x = this.getEntry(i);\n  res.setEntry(i, x * y);\n  }\n  }\n  }\n  return res;\n  }",
          "diff": [
            "@@ -371,6 +370,18 @@",
            "          *\n",
            "          * These special cases are handled below.\n",
            "          */\n",
            "+        if (v.isNaN() || v.isInfinite()) {\n",
            "+            final int n = getDimension();\n",
            "+            for (int i = 0; i < n; i++) {\n",
            "+                final double y = v.getEntry(i);\n",
            "+                if (Double.isNaN(y)) {\n",
            "+                    res.setEntry(i, Double.NaN);\n",
            "+                } else if (Double.isInfinite(y)) {\n",
            "+                    final double x = this.getEntry(i);\n",
            "+                    res.setEntry(i, x * y);\n",
            "+                }\n",
            "+            }\n",
            "+        }\n",
            "         return res;\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 12
        }
      ]
    }
  ]
}
