{
  "bug_id": "6",
  "failed_tests": {
    "org.apache.commons.codec.binary.Base64InputStreamTest": [
      {
        "methodName": "testCodec101",
        "error": "junit.framework.AssertionFailedError",
        "message": "Codec101: First read successful [c=0]",
        "fail_line": "        assertTrue(\"Codec101: First read successful [c=\" + c + \"]\", c > 0);",
        "test_source": "  public void testCodec101() throws Exception {\n  byte[] codec101 = StringUtils.getBytesUtf8(Base64TestData.CODEC_101_MULTIPLE_OF_3);\n  ByteArrayInputStream bais = new ByteArrayInputStream(codec101);\n  Base64InputStream in = new Base64InputStream(bais);\n  byte[] result = new byte[8192];\n  int c = in.read(result);\n  assertTrue(\"Codec101: First read successful [c=\" + c + \"]\", c > 0);\n\n  c = in.read(result);\n  assertTrue(\"Codec101: Second read should report end-of-stream [c=\" + c + \"]\", c < 0);\n  }",
        "stack": [
          "Base64InputStreamTest.testCodec101 line 61"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/codec/binary/Base64InputStream.java",
      "buggy_full_code": "\n\npackage org.apache.commons.codec.binary;\n\nimport java.io.FilterInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n\npublic class Base64InputStream extends FilterInputStream { private final boolean doEncode; private final Base64 base64; private final byte[] singleByte = new byte[1]; public Base64InputStream(InputStream in) {\n        this(in, false);\n    }\n\n    \n    public Base64InputStream(InputStream in, boolean doEncode) {\n        super(in);\n        this.doEncode = doEncode;\n        this.base64 = new Base64(false);\n    }\n\n    \n    public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {\n        super(in);\n        this.doEncode = doEncode;\n        this.base64 = new Base64(lineLength, lineSeparator);\n    }\n\n    \n    public int read() throws IOException {\n        int r = read(singleByte, 0, 1);\n        while (r == 0) {\n            r = read(singleByte, 0, 1);\n        }\n        if (r > 0) {\n            return singleByte[0] < 0 ? 256 + singleByte[0] : singleByte[0];\n        }\n        return -1;\n    }\n\n    \n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            \n                if (!base64.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    \n                    \n                    if (c > 0 && b.length == len) {\n                        base64.setInitialBuffer(b, offset, len);\n                    }\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n            return base64.readResults(b, offset, len);\n        }\n    }\n\n    \n    public boolean markSupported() {\n        return false; \n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.codec.binary;\n\nimport java.io.FilterInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n\npublic class Base64InputStream extends FilterInputStream { private final boolean doEncode; private final Base64 base64; private final byte[] singleByte = new byte[1]; public Base64InputStream(InputStream in) {\n        this(in, false);\n    }\n\n    \n    public Base64InputStream(InputStream in, boolean doEncode) {\n        super(in);\n        this.doEncode = doEncode;\n        this.base64 = new Base64(false);\n    }\n\n    \n    public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {\n        super(in);\n        this.doEncode = doEncode;\n        this.base64 = new Base64(lineLength, lineSeparator);\n    }\n\n    \n    public int read() throws IOException {\n        int r = read(singleByte, 0, 1);\n        while (r == 0) {\n            r = read(singleByte, 0, 1);\n        }\n        if (r > 0) {\n            return singleByte[0] < 0 ? 256 + singleByte[0] : singleByte[0];\n        }\n        return -1;\n    }\n\n    \n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            int readLen = 0;\n            \n            while (readLen == 0) {\n                if (!base64.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    \n                    \n                    if (c > 0 && b.length == len) {\n                        base64.setInitialBuffer(b, offset, len);\n                    }\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n                readLen = base64.readResults(b, offset, len);\n            }\n            return readLen;\n        }\n    }\n\n    \n    public boolean markSupported() {\n        return false; \n    }\n}\n",
      "buggy_signatures": [
        "public Base64InputStream(InputStream in, boolean doEncode)",
        "public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator)",
        "public int read() throws IOException",
        "public int read(byte b[], int offset, int len) throws IOException",
        "public boolean markSupported()"
      ],
      "fixed_signatures": [
        "public Base64InputStream(InputStream in, boolean doEncode)",
        "public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator)",
        "public int read() throws IOException",
        "public int read(byte b[], int offset, int len) throws IOException",
        "public boolean markSupported()"
      ],
      "methods": [
        {
          "buggy_method": "  public int read(byte b[], int offset, int len) throws IOException {\n  if (b == null) {\n  throw new NullPointerException();\n  } else if (offset < 0 || len < 0) {\n  throw new IndexOutOfBoundsException();\n  } else if (offset > b.length || offset + len > b.length) {\n  throw new IndexOutOfBoundsException();\n  } else if (len == 0) {\n  return 0;\n  } else {\n  \n  if (!base64.hasData()) {\n  byte[] buf = new byte[doEncode ? 4096 : 8192];\n  int c = in.read(buf);\n  \n  \n  if (c > 0 && b.length == len) {\n  base64.setInitialBuffer(b, offset, len);\n  }\n  if (doEncode) {\n  base64.encode(buf, 0, c);\n  } else {\n  base64.decode(buf, 0, c);\n  }\n  }\n  return base64.readResults(b, offset, len);\n  }\n  }",
          "fixed_method": "  public int read(byte b[], int offset, int len) throws IOException {\n  if (b == null) {\n  throw new NullPointerException();\n  } else if (offset < 0 || len < 0) {\n  throw new IndexOutOfBoundsException();\n  } else if (offset > b.length || offset + len > b.length) {\n  throw new IndexOutOfBoundsException();\n  } else if (len == 0) {\n  return 0;\n  } else {\n  int readLen = 0;\n  \n  while (readLen == 0) {\n  if (!base64.hasData()) {\n  byte[] buf = new byte[doEncode ? 4096 : 8192];\n  int c = in.read(buf);\n  \n  \n  if (c > 0 && b.length == len) {\n  base64.setInitialBuffer(b, offset, len);\n  }\n  if (doEncode) {\n  base64.encode(buf, 0, c);\n  } else {\n  base64.decode(buf, 0, c);\n  }\n  }\n  readLen = base64.readResults(b, offset, len);\n  }\n  return readLen;\n  }\n  }",
          "diff": [
            "@@ -145,6 +145,7 @@",
            "         } else if (len == 0) {\n",
            "             return 0;\n",
            "         } else {\n",
            "+            int readLen = 0;\n",
            "             /*\n",
            "              Rationale for while-loop on (readLen == 0):\n",
            "              -----\n",
            "@@ -161,6 +162,7 @@",
            "              -----\n",
            "              This is a fix for CODEC-101\n",
            "             */\n",
            "+            while (readLen == 0) {\n",
            "                 if (!base64.hasData()) {\n",
            "                     byte[] buf = new byte[doEncode ? 4096 : 8192];\n",
            "                     int c = in.read(buf);\n",
            "@@ -175,7 +177,9 @@",
            "                         base64.decode(buf, 0, c);\n",
            "                     }\n",
            "                 }\n",
            "-            return base64.readResults(b, offset, len);\n",
            "+                readLen = base64.readResults(b, offset, len);\n",
            "+            }\n",
            "+            return readLen;\n",
            "         }\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 6
        }
      ]
    }
  ]
}
