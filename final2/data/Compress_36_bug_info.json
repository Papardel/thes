{
  "bug_id": "36",
  "failed_tests": {
    "org.apache.commons.compress.archivers.sevenz.SevenZFileTest": [
      {
        "methodName": "readEntriesOfSize0",
        "error": "java.lang.IllegalStateException",
        "message": "No current 7z entry (call getNextEntry() first).",
        "fail_line": "                int b = sevenZFile.read();",
        "test_source": "  public void readEntriesOfSize0() throws IOException {\n  final SevenZFile sevenZFile = new SevenZFile(getFile(\"COMPRESS-348.7z\"));\n  try {\n  int entries = 0;\n  SevenZArchiveEntry entry = sevenZFile.getNextEntry();\n  while (entry != null) {\n  entries++;\n  int b = sevenZFile.read();\n  if (\"2.txt\".equals(entry.getName()) || \"5.txt\".equals(entry.getName())) {\n  assertEquals(-1, b);\n  } else {\n  assertNotEquals(-1, b);\n  }\n  entry = sevenZFile.getNextEntry();\n  }\n  assertEquals(5, entries);\n  } finally {\n  sevenZFile.close();\n  }\n  }",
        "stack": [
          "SevenZFile.getCurrentStream line 903, SevenZFile.read line 898, SevenZFileTest.readEntriesOfSize0 line 274"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/compress/archivers/sevenz/SevenZFile.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.sevenz;\n\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.Closeable;\nimport java.io.DataInput;\nimport java.io.DataInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.RandomAccessFile;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.LinkedList;\nimport java.util.zip.CRC32;\n\nimport org.apache.commons.compress.utils.BoundedInputStream;\nimport org.apache.commons.compress.utils.CRC32VerifyingInputStream;\nimport org.apache.commons.compress.utils.CharsetNames;\nimport org.apache.commons.compress.utils.IOUtils;\n\n\npublic class SevenZFile implements Closeable { static final int SIGNATURE_HEADER_SIZE = 32; private final String fileName; private RandomAccessFile file; private final Archive archive; private int currentEntryIndex = -1; private int currentFolderIndex = -1; private InputStream currentFolderInputStream = null; private byte[] password; private final ArrayList<InputStream> deferredBlockStreams = new ArrayList<InputStream>(); static final byte[] sevenZSignature = {\n        (byte)'7', (byte)'z', (byte)0xBC, (byte)0xAF, (byte)0x27, (byte)0x1C\n    };\n    \n    \n    public SevenZFile(final File filename, final byte[] password) throws IOException {\n        boolean succeeded = false;\n        this.file = new RandomAccessFile(filename, \"r\");\n        this.fileName = filename.getAbsolutePath();\n        try {\n            archive = readHeaders(password);\n            if (password != null) {\n                this.password = new byte[password.length];\n                System.arraycopy(password, 0, this.password, 0, password.length);\n            } else {\n                this.password = null;\n            }\n            succeeded = true;\n        } finally {\n            if (!succeeded) {\n                this.file.close();\n            }\n        }\n    }\n    \n    \n    public SevenZFile(final File filename) throws IOException {\n        this(filename, null);\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        if (file != null) {\n            try {\n                file.close();\n            } finally {\n                file = null;\n                if (password != null) {\n                    Arrays.fill(password, (byte) 0);\n                }\n                password = null;\n            }\n        }\n    }\n    \n    \n    public SevenZArchiveEntry getNextEntry() throws IOException {\n        if (currentEntryIndex >= archive.files.length - 1) {\n            return null;\n        }\n        ++currentEntryIndex;\n        final SevenZArchiveEntry entry = archive.files[currentEntryIndex];\n        buildDecodingStream();\n        return entry;\n    }\n    \n    \n    public Iterable<SevenZArchiveEntry> getEntries() {\n        return Arrays.asList(archive.files);\n    }\n    \n    private Archive readHeaders(final byte[] password) throws IOException {\n        final byte[] signature = new byte[6];\n        file.readFully(signature);\n        if (!Arrays.equals(signature, sevenZSignature)) {\n            throw new IOException(\"Bad 7z signature\");\n        }\n        \n        final byte archiveVersionMajor = file.readByte();\n        final byte archiveVersionMinor = file.readByte();\n        if (archiveVersionMajor != 0) {\n            throw new IOException(String.format(\"Unsupported 7z version (%d,%d)\",\n                    archiveVersionMajor, archiveVersionMinor));\n        }\n\n        final long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\n        final StartHeader startHeader = readStartHeader(startHeaderCrc);\n        \n        final int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\n        if (nextHeaderSizeInt != startHeader.nextHeaderSize) {\n            throw new IOException(\"cannot handle nextHeaderSize \" + startHeader.nextHeaderSize);\n        }\n        file.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\n        final byte[] nextHeader = new byte[nextHeaderSizeInt];\n        file.readFully(nextHeader);\n        final CRC32 crc = new CRC32();\n        crc.update(nextHeader);\n        if (startHeader.nextHeaderCrc != crc.getValue()) {\n            throw new IOException(\"NextHeader CRC mismatch\");\n        }\n        \n        final ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\n        DataInputStream nextHeaderInputStream = new DataInputStream(\n                byteStream);\n        Archive archive = new Archive();\n        int nid = nextHeaderInputStream.readUnsignedByte();\n        if (nid == NID.kEncodedHeader) {\n            nextHeaderInputStream =\n                readEncodedHeader(nextHeaderInputStream, archive, password);\n            \n            archive = new Archive();\n            nid = nextHeaderInputStream.readUnsignedByte();\n        }\n        if (nid == NID.kHeader) {\n            readHeader(nextHeaderInputStream, archive);\n            nextHeaderInputStream.close();\n        } else {\n            throw new IOException(\"Broken or unsupported archive: no Header\");\n        }\n        return archive;\n    }\n    \n    private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\n        final StartHeader startHeader = new StartHeader();\n        DataInputStream dataInputStream = null;\n        try {\n             dataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\n                    new BoundedRandomAccessFileInputStream(file, 20), 20, startHeaderCrc));\n             startHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\n             startHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\n             startHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\n             return startHeader;\n        } finally {\n            if (dataInputStream != null) {\n                dataInputStream.close();\n            }\n        }\n    }\n    \n    private void readHeader(final DataInput header, final Archive archive) throws IOException {\n        int nid = header.readUnsignedByte();\n        \n        if (nid == NID.kArchiveProperties) {\n            readArchiveProperties(header);\n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid == NID.kAdditionalStreamsInfo) {\n            throw new IOException(\"Additional streams unsupported\");\n            \n        }\n        \n        if (nid == NID.kMainStreamsInfo) {\n            readStreamsInfo(header, archive);\n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid == NID.kFilesInfo) {\n            readFilesInfo(header, archive);\n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid != NID.kEnd) {\n            throw new IOException(\"Badly terminated header, found \" + nid);\n        }\n    }\n    \n    private void readArchiveProperties(final DataInput input) throws IOException {\n        \n        int nid =  input.readUnsignedByte();\n        while (nid != NID.kEnd) {\n            final long propertySize = readUint64(input);\n            final byte[] property = new byte[(int)propertySize];\n            input.readFully(property);\n            nid = input.readUnsignedByte();\n        }\n    }\n    \n    private DataInputStream readEncodedHeader(final DataInputStream header, final Archive archive, final byte[] password) throws IOException {\n        readStreamsInfo(header, archive);\n        \n        \n        final Folder folder = archive.folders[0];\n        final int firstPackStreamIndex = 0;\n        final long folderOffset = SIGNATURE_HEADER_SIZE + archive.packPos +\n                0;\n        \n        file.seek(folderOffset);\n        InputStream inputStreamStack = new BoundedRandomAccessFileInputStream(file,\n                archive.packSizes[firstPackStreamIndex]);\n        for (final Coder coder : folder.getOrderedCoders()) {\n            if (coder.numInStreams != 1 || coder.numOutStreams != 1) {\n                throw new IOException(\"Multi input/output stream coders are not yet supported\");\n            }\n            inputStreamStack = Coders.addDecoder(fileName, inputStreamStack,\n                    folder.getUnpackSizeForCoder(coder), coder, password);\n        }\n        if (folder.hasCrc) {\n            inputStreamStack = new CRC32VerifyingInputStream(inputStreamStack,\n                    folder.getUnpackSize(), folder.crc);\n        }\n        final byte[] nextHeader = new byte[(int)folder.getUnpackSize()];\n        final DataInputStream nextHeaderInputStream = new DataInputStream(inputStreamStack);\n        try {\n            nextHeaderInputStream.readFully(nextHeader);\n        } finally {\n            nextHeaderInputStream.close();\n        }\n        return new DataInputStream(new ByteArrayInputStream(nextHeader));\n    }\n    \n    private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\n        int nid = header.readUnsignedByte();\n        \n        if (nid == NID.kPackInfo) {\n            readPackInfo(header, archive);\n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid == NID.kUnpackInfo) {\n            readUnpackInfo(header, archive);\n            nid = header.readUnsignedByte();\n        } else {\n            \n            archive.folders = new Folder[0];\n        }\n        \n        if (nid == NID.kSubStreamsInfo) {\n            readSubStreamsInfo(header, archive);\n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid != NID.kEnd) {\n            throw new IOException(\"Badly terminated StreamsInfo\");\n        }\n    }\n    \n    private void readPackInfo(final DataInput header, final Archive archive) throws IOException {\n        archive.packPos = readUint64(header);\n        final long numPackStreams = readUint64(header);\n        int nid = header.readUnsignedByte();\n        if (nid == NID.kSize) {\n            archive.packSizes = new long[(int)numPackStreams];\n            for (int i = 0; i < archive.packSizes.length; i++) {\n                archive.packSizes[i] = readUint64(header);\n            }\n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid == NID.kCRC) {\n            archive.packCrcsDefined = readAllOrBits(header, (int)numPackStreams);\n            archive.packCrcs = new long[(int)numPackStreams];\n            for (int i = 0; i < (int)numPackStreams; i++) {\n                if (archive.packCrcsDefined.get(i)) {\n                    archive.packCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n                }\n            }\n            \n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid != NID.kEnd) {\n            throw new IOException(\"Badly terminated PackInfo (\" + nid + \")\");\n        }\n    }\n    \n    private void readUnpackInfo(final DataInput header, final Archive archive) throws IOException {\n        int nid = header.readUnsignedByte();\n        if (nid != NID.kFolder) {\n            throw new IOException(\"Expected kFolder, got \" + nid);\n        }\n        final long numFolders = readUint64(header);\n        final Folder[] folders = new Folder[(int)numFolders];\n        archive.folders = folders;\n        final int external = header.readUnsignedByte();\n        if (external != 0) {\n            throw new IOException(\"External unsupported\");\n        }\n        for (int i = 0; i < (int)numFolders; i++) {\n            folders[i] = readFolder(header);\n        }\n        \n        nid = header.readUnsignedByte();\n        if (nid != NID.kCodersUnpackSize) {\n            throw new IOException(\"Expected kCodersUnpackSize, got \" + nid);\n        }\n        for (final Folder folder : folders) {\n            folder.unpackSizes = new long[(int)folder.totalOutputStreams];\n            for (int i = 0; i < folder.totalOutputStreams; i++) {\n                folder.unpackSizes[i] = readUint64(header);\n            }\n        }\n        \n        nid = header.readUnsignedByte();\n        if (nid == NID.kCRC) {\n            final BitSet crcsDefined = readAllOrBits(header, (int)numFolders);\n            for (int i = 0; i < (int)numFolders; i++) {\n                if (crcsDefined.get(i)) {\n                    folders[i].hasCrc = true;\n                    folders[i].crc = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n                } else {\n                    folders[i].hasCrc = false;\n                }\n            }\n            \n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid != NID.kEnd) {\n            throw new IOException(\"Badly terminated UnpackInfo\");\n        }\n    }\n    \n    private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\n        for (final Folder folder : archive.folders) {\n            folder.numUnpackSubStreams = 1;\n        }\n        int totalUnpackStreams = archive.folders.length;\n        \n        int nid = header.readUnsignedByte();\n        if (nid == NID.kNumUnpackStream) {\n            totalUnpackStreams = 0;\n            for (final Folder folder : archive.folders) {\n                final long numStreams = readUint64(header);\n                folder.numUnpackSubStreams = (int)numStreams;\n                totalUnpackStreams += numStreams;\n            }\n            nid = header.readUnsignedByte();\n        }\n        \n        final SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\n        subStreamsInfo.unpackSizes = new long[totalUnpackStreams];\n        subStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\n        subStreamsInfo.crcs = new long[totalUnpackStreams];\n        \n        int nextUnpackStream = 0;\n        for (final Folder folder : archive.folders) {\n            if (folder.numUnpackSubStreams == 0) {\n                continue;\n            }\n            long sum = 0;\n            if (nid == NID.kSize) {\n                for (int i = 0; i < folder.numUnpackSubStreams - 1; i++) {\n                    final long size = readUint64(header);\n                    subStreamsInfo.unpackSizes[nextUnpackStream++] = size;\n                    sum += size;\n                }\n            }\n            subStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;\n        }\n        if (nid == NID.kSize) {\n            nid = header.readUnsignedByte();\n        }\n        \n        int numDigests = 0;\n        for (final Folder folder : archive.folders) {\n            if (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {\n                numDigests += folder.numUnpackSubStreams;\n            }\n        }\n        \n        if (nid == NID.kCRC) {\n            final BitSet hasMissingCrc = readAllOrBits(header, numDigests);\n            final long[] missingCrcs = new long[numDigests];\n            for (int i = 0; i < numDigests; i++) {\n                if (hasMissingCrc.get(i)) {\n                    missingCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n                }\n            }\n            int nextCrc = 0;\n            int nextMissingCrc = 0;\n            for (final Folder folder: archive.folders) {\n                if (folder.numUnpackSubStreams == 1 && folder.hasCrc) {\n                    subStreamsInfo.hasCrc.set(nextCrc, true);\n                    subStreamsInfo.crcs[nextCrc] = folder.crc;\n                    ++nextCrc;\n                } else {\n                    for (int i = 0; i < folder.numUnpackSubStreams; i++) {\n                        subStreamsInfo.hasCrc.set(nextCrc, hasMissingCrc.get(nextMissingCrc));\n                        subStreamsInfo.crcs[nextCrc] = missingCrcs[nextMissingCrc];\n                        ++nextCrc;\n                        ++nextMissingCrc;\n                    }\n                }\n            }\n            \n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid != NID.kEnd) {\n            throw new IOException(\"Badly terminated SubStreamsInfo\");\n        }\n        \n        archive.subStreamsInfo = subStreamsInfo;\n    }\n    \n    private Folder readFolder(final DataInput header) throws IOException {\n        final Folder folder = new Folder();\n        \n        final long numCoders = readUint64(header);\n        final Coder[] coders = new Coder[(int)numCoders];\n        long totalInStreams = 0;\n        long totalOutStreams = 0;\n        for (int i = 0; i < coders.length; i++) {\n            coders[i] = new Coder();\n            final int bits = header.readUnsignedByte();\n            final int idSize = bits & 0xf;\n            final boolean isSimple = (bits & 0x10) == 0;\n            final boolean hasAttributes = (bits & 0x20) != 0;\n            final boolean moreAlternativeMethods = (bits & 0x80) != 0;\n            \n            coders[i].decompressionMethodId = new byte[idSize];\n            header.readFully(coders[i].decompressionMethodId);\n            if (isSimple) {\n                coders[i].numInStreams = 1;\n                coders[i].numOutStreams = 1;\n            } else {\n                coders[i].numInStreams = readUint64(header);\n                coders[i].numOutStreams = readUint64(header);\n            }\n            totalInStreams += coders[i].numInStreams;\n            totalOutStreams += coders[i].numOutStreams;\n            if (hasAttributes) {\n                final long propertiesSize = readUint64(header);\n                coders[i].properties = new byte[(int)propertiesSize];\n                header.readFully(coders[i].properties);\n            }\n            \n            while (moreAlternativeMethods) {\n                throw new IOException(\"Alternative methods are unsupported, please report. \" +\n                        \"The reference implementation doesn't support them either.\");\n            }\n        }\n        folder.coders = coders;\n        folder.totalInputStreams = totalInStreams;\n        folder.totalOutputStreams = totalOutStreams;\n        \n        if (totalOutStreams == 0) {\n            throw new IOException(\"Total output streams can't be 0\");\n        }\n        final long numBindPairs = totalOutStreams - 1;\n        final BindPair[] bindPairs = new BindPair[(int)numBindPairs];\n        for (int i = 0; i < bindPairs.length; i++) {\n            bindPairs[i] = new BindPair();\n            bindPairs[i].inIndex = readUint64(header);\n            bindPairs[i].outIndex = readUint64(header);\n        }\n        folder.bindPairs = bindPairs;\n        \n        if (totalInStreams < numBindPairs) {\n            throw new IOException(\"Total input streams can't be less than the number of bind pairs\");\n        }\n        final long numPackedStreams = totalInStreams - numBindPairs;\n        final long packedStreams[] = new long[(int)numPackedStreams];\n        if (numPackedStreams == 1) {\n            int i;\n            for (i = 0; i < (int)totalInStreams; i++) {\n                if (folder.findBindPairForInStream(i) < 0) {\n                    break;\n                }\n            }\n            if (i == (int)totalInStreams) {\n                throw new IOException(\"Couldn't find stream's bind pair index\");\n            }\n            packedStreams[0] = i;\n        } else {\n            for (int i = 0; i < (int)numPackedStreams; i++) {\n                packedStreams[i] = readUint64(header);\n            }\n        }\n        folder.packedStreams = packedStreams;\n        \n        return folder;\n    }\n    \n    private BitSet readAllOrBits(final DataInput header, final int size) throws IOException {\n        final int areAllDefined = header.readUnsignedByte();\n        final BitSet bits;\n        if (areAllDefined != 0) {\n            bits = new BitSet(size);\n            for (int i = 0; i < size; i++) {\n                bits.set(i, true);\n            }\n        } else {\n            bits = readBits(header, size);\n        }\n        return bits;\n    }\n    \n    private BitSet readBits(final DataInput header, final int size) throws IOException {\n        final BitSet bits = new BitSet(size);\n        int mask = 0;\n        int cache = 0;\n        for (int i = 0; i < size; i++) {\n            if (mask == 0) {\n                mask = 0x80;\n                cache = header.readUnsignedByte();\n            }\n            bits.set(i, (cache & mask) != 0);\n            mask >>>= 1;\n        }\n        return bits;\n    }\n    \n    private void readFilesInfo(final DataInput header, final Archive archive) throws IOException {\n        final long numFiles = readUint64(header);\n        final SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\n        for (int i = 0; i < files.length; i++) {\n            files[i] = new SevenZArchiveEntry();\n        }\n        BitSet isEmptyStream = null;\n        BitSet isEmptyFile = null; \n        BitSet isAnti = null;\n        while (true) {\n            final int propertyType = header.readUnsignedByte();\n            if (propertyType == 0) {\n                break;\n            }\n            final long size = readUint64(header);\n            switch (propertyType) {\n                case NID.kEmptyStream: {\n                    isEmptyStream = readBits(header, files.length);\n                    break;\n                }\n                case NID.kEmptyFile: {\n                    if (isEmptyStream == null) { \n                        throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n                    }\n                    isEmptyFile = readBits(header, isEmptyStream.cardinality());\n                    break;\n                }\n                case NID.kAnti: {\n                    if (isEmptyStream == null) { \n                        throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n                    }\n                    isAnti = readBits(header, isEmptyStream.cardinality());\n                    break;\n                }\n                case NID.kName: {\n                    final int external = header.readUnsignedByte();\n                    if (external != 0) {\n                        throw new IOException(\"Not implemented\");\n                    }\n                    if (((size - 1) & 1) != 0) {\n                        throw new IOException(\"File names length invalid\");\n                    }\n                    final byte[] names = new byte[(int)(size - 1)];\n                    header.readFully(names);\n                    int nextFile = 0;\n                    int nextName = 0;\n                    for (int i = 0; i < names.length; i += 2) {\n                        if (names[i] == 0 && names[i+1] == 0) {\n                            files[nextFile++].setName(new String(names, nextName, i-nextName, CharsetNames.UTF_16LE));\n                            nextName = i + 2;\n                        }\n                    }\n                    if (nextName != names.length || nextFile != files.length) {\n                        throw new IOException(\"Error parsing file names\");\n                    }\n                    break;\n                }\n                case NID.kCTime: {\n                    final BitSet timesDefined = readAllOrBits(header, files.length);\n                    final int external = header.readUnsignedByte();\n                    if (external != 0) {\n                        throw new IOException(\"Unimplemented\");\n                    }\n                    for (int i = 0; i < files.length; i++) {\n                        files[i].setHasCreationDate(timesDefined.get(i));\n                        if (files[i].getHasCreationDate()) {\n                            files[i].setCreationDate(Long.reverseBytes(header.readLong()));\n                        }\n                    }\n                    break;\n                }\n                case NID.kATime: {\n                    final BitSet timesDefined = readAllOrBits(header, files.length);\n                    final int external = header.readUnsignedByte();\n                    if (external != 0) {\n                        throw new IOException(\"Unimplemented\");\n                    }\n                    for (int i = 0; i < files.length; i++) {\n                        files[i].setHasAccessDate(timesDefined.get(i));\n                        if (files[i].getHasAccessDate()) {\n                            files[i].setAccessDate(Long.reverseBytes(header.readLong()));\n                        }\n                    }\n                    break;\n                }\n                case NID.kMTime: {\n                    final BitSet timesDefined = readAllOrBits(header, files.length);\n                    final int external = header.readUnsignedByte();\n                    if (external != 0) {\n                        throw new IOException(\"Unimplemented\");\n                    }\n                    for (int i = 0; i < files.length; i++) {\n                        files[i].setHasLastModifiedDate(timesDefined.get(i));\n                        if (files[i].getHasLastModifiedDate()) {\n                            files[i].setLastModifiedDate(Long.reverseBytes(header.readLong()));\n                        }\n                    }\n                    break;\n                }\n                case NID.kWinAttributes: {\n                    final BitSet attributesDefined = readAllOrBits(header, files.length);\n                    final int external = header.readUnsignedByte();\n                    if (external != 0) {\n                        throw new IOException(\"Unimplemented\");\n                    }\n                    for (int i = 0; i < files.length; i++) {\n                        files[i].setHasWindowsAttributes(attributesDefined.get(i));\n                        if (files[i].getHasWindowsAttributes()) {\n                            files[i].setWindowsAttributes(Integer.reverseBytes(header.readInt()));\n                        }\n                    }\n                    break;\n                }\n                case NID.kStartPos: {\n                    throw new IOException(\"kStartPos is unsupported, please report\");\n                }\n                case NID.kDummy: {\n                    \n                    \n                    \n                    if (skipBytesFully(header, size) < size) {\n                        throw new IOException(\"Incomplete kDummy property\");\n                    }\n                    break;\n                }\n\n                default: {\n                    \n                    if (skipBytesFully(header, size) < size) {\n                        throw new IOException(\"Incomplete property of type \" + propertyType);\n                    }\n                    break;\n                }\n            }\n        }\n        int nonEmptyFileCounter = 0;\n        int emptyFileCounter = 0;\n        for (int i = 0; i < files.length; i++) {\n            files[i].setHasStream(isEmptyStream == null ? true : !isEmptyStream.get(i));\n            if (files[i].hasStream()) {\n                files[i].setDirectory(false);\n                files[i].setAntiItem(false);\n                files[i].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\n                files[i].setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\n                files[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n                ++nonEmptyFileCounter;\n            } else {\n                files[i].setDirectory(isEmptyFile == null ? true : !isEmptyFile.get(emptyFileCounter));\n                files[i].setAntiItem(isAnti == null ? false : isAnti.get(emptyFileCounter));\n                files[i].setHasCrc(false);\n                files[i].setSize(0);\n                ++emptyFileCounter;\n            }\n        }\n        archive.files = files;\n        calculateStreamMap(archive);\n    }\n    \n    private void calculateStreamMap(final Archive archive) throws IOException {\n        final StreamMap streamMap = new StreamMap();\n        \n        int nextFolderPackStreamIndex = 0;\n        final int numFolders = archive.folders != null ? archive.folders.length : 0;\n        streamMap.folderFirstPackStreamIndex = new int[numFolders];\n        for (int i = 0; i < numFolders; i++) {\n            streamMap.folderFirstPackStreamIndex[i] = nextFolderPackStreamIndex;\n            nextFolderPackStreamIndex += archive.folders[i].packedStreams.length;\n        }\n        \n        long nextPackStreamOffset = 0;\n        final int numPackSizes = archive.packSizes != null ? archive.packSizes.length : 0;\n        streamMap.packStreamOffsets = new long[numPackSizes];\n        for (int i = 0; i < numPackSizes; i++) {\n            streamMap.packStreamOffsets[i] = nextPackStreamOffset;\n            nextPackStreamOffset += archive.packSizes[i]; \n        }\n        \n        streamMap.folderFirstFileIndex = new int[numFolders];\n        streamMap.fileFolderIndex = new int[archive.files.length];\n        int nextFolderIndex = 0;\n        int nextFolderUnpackStreamIndex = 0;\n        for (int i = 0; i < archive.files.length; i++) {\n            if (!archive.files[i].hasStream() && nextFolderUnpackStreamIndex == 0) {\n                streamMap.fileFolderIndex[i] = -1;\n                continue;\n            }\n            if (nextFolderUnpackStreamIndex == 0) {\n                for (; nextFolderIndex < archive.folders.length; ++nextFolderIndex) {\n                    streamMap.folderFirstFileIndex[nextFolderIndex] = i;\n                    if (archive.folders[nextFolderIndex].numUnpackSubStreams > 0) {\n                        break;\n                    }\n                }\n                if (nextFolderIndex >= archive.folders.length) {\n                    throw new IOException(\"Too few folders in archive\");\n                }\n            }\n            streamMap.fileFolderIndex[i] = nextFolderIndex;\n            if (!archive.files[i].hasStream()) {\n                continue;\n            }\n            ++nextFolderUnpackStreamIndex;\n            if (nextFolderUnpackStreamIndex >= archive.folders[nextFolderIndex].numUnpackSubStreams) {\n                ++nextFolderIndex;\n                nextFolderUnpackStreamIndex = 0;\n            }\n        }\n        \n        archive.streamMap = streamMap;\n    }\n    \n    private void buildDecodingStream() throws IOException {\n        final int folderIndex = archive.streamMap.fileFolderIndex[currentEntryIndex];\n        if (folderIndex < 0) {\n            deferredBlockStreams.clear();\n            \n            \n            return;\n        }\n        final SevenZArchiveEntry file = archive.files[currentEntryIndex];\n        if (currentFolderIndex == folderIndex) {\n            \n            \n            \n            \n            \n\n            file.setContentMethods(archive.files[currentEntryIndex - 1].getContentMethods());\n        } else {\n            \n            currentFolderIndex = folderIndex;\n            deferredBlockStreams.clear();\n            if (currentFolderInputStream != null) {\n                currentFolderInputStream.close();\n                currentFolderInputStream = null;\n            }\n            \n            final Folder folder = archive.folders[folderIndex];\n            final int firstPackStreamIndex = archive.streamMap.folderFirstPackStreamIndex[folderIndex];\n            final long folderOffset = SIGNATURE_HEADER_SIZE + archive.packPos +\n                    archive.streamMap.packStreamOffsets[firstPackStreamIndex];\n            currentFolderInputStream = buildDecoderStack(folder, folderOffset, firstPackStreamIndex, file);\n        }\n\n        InputStream fileStream = new BoundedInputStream(currentFolderInputStream, file.getSize());\n        if (file.getHasCrc()) {\n            fileStream = new CRC32VerifyingInputStream(fileStream, file.getSize(), file.getCrcValue());\n        }\n        \n        deferredBlockStreams.add(fileStream);\n    }\n\n    private InputStream buildDecoderStack(final Folder folder, final long folderOffset, final int firstPackStreamIndex, final SevenZArchiveEntry entry) throws IOException {\n        file.seek(folderOffset);\n        InputStream inputStreamStack =\n            new BufferedInputStream(\n              new BoundedRandomAccessFileInputStream(file,\n                  archive.packSizes[firstPackStreamIndex]));\n        final LinkedList<SevenZMethodConfiguration> methods = new LinkedList<SevenZMethodConfiguration>();\n        for (final Coder coder : folder.getOrderedCoders()) {\n            if (coder.numInStreams != 1 || coder.numOutStreams != 1) {\n                throw new IOException(\"Multi input/output stream coders are not yet supported\");\n            }\n            final SevenZMethod method = SevenZMethod.byId(coder.decompressionMethodId);\n            inputStreamStack = Coders.addDecoder(fileName, inputStreamStack,\n                    folder.getUnpackSizeForCoder(coder), coder, password);\n            methods.addFirst(new SevenZMethodConfiguration(method,\n                     Coders.findByMethod(method).getOptionsFromCoder(coder, inputStreamStack)));\n        }\n        entry.setContentMethods(methods);\n        if (folder.hasCrc) {\n            return new CRC32VerifyingInputStream(inputStreamStack,\n                    folder.getUnpackSize(), folder.crc);\n        }\n        return inputStreamStack;\n    }\n    \n    \n    public int read() throws IOException {\n        return getCurrentStream().read();\n    }\n    \n    private InputStream getCurrentStream() throws IOException {\n        if (deferredBlockStreams.isEmpty()) {\n            throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n        }\n        \n        while (deferredBlockStreams.size() > 1) {\n            \n            \n            \n            final InputStream stream = deferredBlockStreams.remove(0);\n            IOUtils.skip(stream, Long.MAX_VALUE);\n            stream.close();\n        }\n\n        return deferredBlockStreams.get(0);\n    }\n\n    \n    public int read(final byte[] b) throws IOException {\n        return read(b, 0, b.length);\n    }\n    \n    \n    public int read(final byte[] b, final int off, final int len) throws IOException {\n        return getCurrentStream().read(b, off, len);\n    }\n    \n    private static long readUint64(final DataInput in) throws IOException {\n        \n        final long firstByte = in.readUnsignedByte();\n        int mask = 0x80;\n        long value = 0;\n        for (int i = 0; i < 8; i++) {\n            if ((firstByte & mask) == 0) {\n                return value | ((firstByte & (mask - 1)) << (8 * i));\n            }\n            final long nextByte = in.readUnsignedByte();\n            value |= nextByte << (8 * i);\n            mask >>>= 1;\n        }\n        return value;\n    }\n\n    \n    public static boolean matches(final byte[] signature, final int length) {\n        if (length < sevenZSignature.length) {\n            return false;\n        }\n\n        for (int i = 0; i < sevenZSignature.length; i++) {\n            if (signature[i] != sevenZSignature[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static long skipBytesFully(final DataInput input, long bytesToSkip) throws IOException {\n        if (bytesToSkip < 1) {\n            return 0;\n        }\n        long skipped = 0;\n        while (bytesToSkip > Integer.MAX_VALUE) {\n            final long skippedNow = skipBytesFully(input, Integer.MAX_VALUE);\n            if (skippedNow == 0) {\n                return skipped;\n            }\n            skipped += skippedNow;\n            bytesToSkip -= skippedNow;\n        }\n        while (bytesToSkip > 0) {\n            final int skippedNow = input.skipBytes((int) bytesToSkip);\n            if (skippedNow == 0) {\n                return skipped;\n            }\n            skipped += skippedNow;\n            bytesToSkip -= skippedNow;\n        }\n        return skipped;\n    }\n    \n    @Override\n    public String toString() {\n      return archive.toString();\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.sevenz;\n\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.Closeable;\nimport java.io.DataInput;\nimport java.io.DataInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.RandomAccessFile;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.LinkedList;\nimport java.util.zip.CRC32;\n\nimport org.apache.commons.compress.utils.BoundedInputStream;\nimport org.apache.commons.compress.utils.CRC32VerifyingInputStream;\nimport org.apache.commons.compress.utils.CharsetNames;\nimport org.apache.commons.compress.utils.IOUtils;\n\n\npublic class SevenZFile implements Closeable { static final int SIGNATURE_HEADER_SIZE = 32; private final String fileName; private RandomAccessFile file; private final Archive archive; private int currentEntryIndex = -1; private int currentFolderIndex = -1; private InputStream currentFolderInputStream = null; private byte[] password; private final ArrayList<InputStream> deferredBlockStreams = new ArrayList<InputStream>(); static final byte[] sevenZSignature = {\n        (byte)'7', (byte)'z', (byte)0xBC, (byte)0xAF, (byte)0x27, (byte)0x1C\n    };\n    \n    \n    public SevenZFile(final File filename, final byte[] password) throws IOException {\n        boolean succeeded = false;\n        this.file = new RandomAccessFile(filename, \"r\");\n        this.fileName = filename.getAbsolutePath();\n        try {\n            archive = readHeaders(password);\n            if (password != null) {\n                this.password = new byte[password.length];\n                System.arraycopy(password, 0, this.password, 0, password.length);\n            } else {\n                this.password = null;\n            }\n            succeeded = true;\n        } finally {\n            if (!succeeded) {\n                this.file.close();\n            }\n        }\n    }\n    \n    \n    public SevenZFile(final File filename) throws IOException {\n        this(filename, null);\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        if (file != null) {\n            try {\n                file.close();\n            } finally {\n                file = null;\n                if (password != null) {\n                    Arrays.fill(password, (byte) 0);\n                }\n                password = null;\n            }\n        }\n    }\n    \n    \n    public SevenZArchiveEntry getNextEntry() throws IOException {\n        if (currentEntryIndex >= archive.files.length - 1) {\n            return null;\n        }\n        ++currentEntryIndex;\n        final SevenZArchiveEntry entry = archive.files[currentEntryIndex];\n        buildDecodingStream();\n        return entry;\n    }\n    \n    \n    public Iterable<SevenZArchiveEntry> getEntries() {\n        return Arrays.asList(archive.files);\n    }\n    \n    private Archive readHeaders(final byte[] password) throws IOException {\n        final byte[] signature = new byte[6];\n        file.readFully(signature);\n        if (!Arrays.equals(signature, sevenZSignature)) {\n            throw new IOException(\"Bad 7z signature\");\n        }\n        \n        final byte archiveVersionMajor = file.readByte();\n        final byte archiveVersionMinor = file.readByte();\n        if (archiveVersionMajor != 0) {\n            throw new IOException(String.format(\"Unsupported 7z version (%d,%d)\",\n                    archiveVersionMajor, archiveVersionMinor));\n        }\n\n        final long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\n        final StartHeader startHeader = readStartHeader(startHeaderCrc);\n        \n        final int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\n        if (nextHeaderSizeInt != startHeader.nextHeaderSize) {\n            throw new IOException(\"cannot handle nextHeaderSize \" + startHeader.nextHeaderSize);\n        }\n        file.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\n        final byte[] nextHeader = new byte[nextHeaderSizeInt];\n        file.readFully(nextHeader);\n        final CRC32 crc = new CRC32();\n        crc.update(nextHeader);\n        if (startHeader.nextHeaderCrc != crc.getValue()) {\n            throw new IOException(\"NextHeader CRC mismatch\");\n        }\n        \n        final ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\n        DataInputStream nextHeaderInputStream = new DataInputStream(\n                byteStream);\n        Archive archive = new Archive();\n        int nid = nextHeaderInputStream.readUnsignedByte();\n        if (nid == NID.kEncodedHeader) {\n            nextHeaderInputStream =\n                readEncodedHeader(nextHeaderInputStream, archive, password);\n            \n            archive = new Archive();\n            nid = nextHeaderInputStream.readUnsignedByte();\n        }\n        if (nid == NID.kHeader) {\n            readHeader(nextHeaderInputStream, archive);\n            nextHeaderInputStream.close();\n        } else {\n            throw new IOException(\"Broken or unsupported archive: no Header\");\n        }\n        return archive;\n    }\n    \n    private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\n        final StartHeader startHeader = new StartHeader();\n        DataInputStream dataInputStream = null;\n        try {\n             dataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\n                    new BoundedRandomAccessFileInputStream(file, 20), 20, startHeaderCrc));\n             startHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\n             startHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\n             startHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\n             return startHeader;\n        } finally {\n            if (dataInputStream != null) {\n                dataInputStream.close();\n            }\n        }\n    }\n    \n    private void readHeader(final DataInput header, final Archive archive) throws IOException {\n        int nid = header.readUnsignedByte();\n        \n        if (nid == NID.kArchiveProperties) {\n            readArchiveProperties(header);\n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid == NID.kAdditionalStreamsInfo) {\n            throw new IOException(\"Additional streams unsupported\");\n            \n        }\n        \n        if (nid == NID.kMainStreamsInfo) {\n            readStreamsInfo(header, archive);\n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid == NID.kFilesInfo) {\n            readFilesInfo(header, archive);\n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid != NID.kEnd) {\n            throw new IOException(\"Badly terminated header, found \" + nid);\n        }\n    }\n    \n    private void readArchiveProperties(final DataInput input) throws IOException {\n        \n        int nid =  input.readUnsignedByte();\n        while (nid != NID.kEnd) {\n            final long propertySize = readUint64(input);\n            final byte[] property = new byte[(int)propertySize];\n            input.readFully(property);\n            nid = input.readUnsignedByte();\n        }\n    }\n    \n    private DataInputStream readEncodedHeader(final DataInputStream header, final Archive archive, final byte[] password) throws IOException {\n        readStreamsInfo(header, archive);\n        \n        \n        final Folder folder = archive.folders[0];\n        final int firstPackStreamIndex = 0;\n        final long folderOffset = SIGNATURE_HEADER_SIZE + archive.packPos +\n                0;\n        \n        file.seek(folderOffset);\n        InputStream inputStreamStack = new BoundedRandomAccessFileInputStream(file,\n                archive.packSizes[firstPackStreamIndex]);\n        for (final Coder coder : folder.getOrderedCoders()) {\n            if (coder.numInStreams != 1 || coder.numOutStreams != 1) {\n                throw new IOException(\"Multi input/output stream coders are not yet supported\");\n            }\n            inputStreamStack = Coders.addDecoder(fileName, inputStreamStack,\n                    folder.getUnpackSizeForCoder(coder), coder, password);\n        }\n        if (folder.hasCrc) {\n            inputStreamStack = new CRC32VerifyingInputStream(inputStreamStack,\n                    folder.getUnpackSize(), folder.crc);\n        }\n        final byte[] nextHeader = new byte[(int)folder.getUnpackSize()];\n        final DataInputStream nextHeaderInputStream = new DataInputStream(inputStreamStack);\n        try {\n            nextHeaderInputStream.readFully(nextHeader);\n        } finally {\n            nextHeaderInputStream.close();\n        }\n        return new DataInputStream(new ByteArrayInputStream(nextHeader));\n    }\n    \n    private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\n        int nid = header.readUnsignedByte();\n        \n        if (nid == NID.kPackInfo) {\n            readPackInfo(header, archive);\n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid == NID.kUnpackInfo) {\n            readUnpackInfo(header, archive);\n            nid = header.readUnsignedByte();\n        } else {\n            \n            archive.folders = new Folder[0];\n        }\n        \n        if (nid == NID.kSubStreamsInfo) {\n            readSubStreamsInfo(header, archive);\n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid != NID.kEnd) {\n            throw new IOException(\"Badly terminated StreamsInfo\");\n        }\n    }\n    \n    private void readPackInfo(final DataInput header, final Archive archive) throws IOException {\n        archive.packPos = readUint64(header);\n        final long numPackStreams = readUint64(header);\n        int nid = header.readUnsignedByte();\n        if (nid == NID.kSize) {\n            archive.packSizes = new long[(int)numPackStreams];\n            for (int i = 0; i < archive.packSizes.length; i++) {\n                archive.packSizes[i] = readUint64(header);\n            }\n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid == NID.kCRC) {\n            archive.packCrcsDefined = readAllOrBits(header, (int)numPackStreams);\n            archive.packCrcs = new long[(int)numPackStreams];\n            for (int i = 0; i < (int)numPackStreams; i++) {\n                if (archive.packCrcsDefined.get(i)) {\n                    archive.packCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n                }\n            }\n            \n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid != NID.kEnd) {\n            throw new IOException(\"Badly terminated PackInfo (\" + nid + \")\");\n        }\n    }\n    \n    private void readUnpackInfo(final DataInput header, final Archive archive) throws IOException {\n        int nid = header.readUnsignedByte();\n        if (nid != NID.kFolder) {\n            throw new IOException(\"Expected kFolder, got \" + nid);\n        }\n        final long numFolders = readUint64(header);\n        final Folder[] folders = new Folder[(int)numFolders];\n        archive.folders = folders;\n        final int external = header.readUnsignedByte();\n        if (external != 0) {\n            throw new IOException(\"External unsupported\");\n        }\n        for (int i = 0; i < (int)numFolders; i++) {\n            folders[i] = readFolder(header);\n        }\n        \n        nid = header.readUnsignedByte();\n        if (nid != NID.kCodersUnpackSize) {\n            throw new IOException(\"Expected kCodersUnpackSize, got \" + nid);\n        }\n        for (final Folder folder : folders) {\n            folder.unpackSizes = new long[(int)folder.totalOutputStreams];\n            for (int i = 0; i < folder.totalOutputStreams; i++) {\n                folder.unpackSizes[i] = readUint64(header);\n            }\n        }\n        \n        nid = header.readUnsignedByte();\n        if (nid == NID.kCRC) {\n            final BitSet crcsDefined = readAllOrBits(header, (int)numFolders);\n            for (int i = 0; i < (int)numFolders; i++) {\n                if (crcsDefined.get(i)) {\n                    folders[i].hasCrc = true;\n                    folders[i].crc = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n                } else {\n                    folders[i].hasCrc = false;\n                }\n            }\n            \n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid != NID.kEnd) {\n            throw new IOException(\"Badly terminated UnpackInfo\");\n        }\n    }\n    \n    private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\n        for (final Folder folder : archive.folders) {\n            folder.numUnpackSubStreams = 1;\n        }\n        int totalUnpackStreams = archive.folders.length;\n        \n        int nid = header.readUnsignedByte();\n        if (nid == NID.kNumUnpackStream) {\n            totalUnpackStreams = 0;\n            for (final Folder folder : archive.folders) {\n                final long numStreams = readUint64(header);\n                folder.numUnpackSubStreams = (int)numStreams;\n                totalUnpackStreams += numStreams;\n            }\n            nid = header.readUnsignedByte();\n        }\n        \n        final SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\n        subStreamsInfo.unpackSizes = new long[totalUnpackStreams];\n        subStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\n        subStreamsInfo.crcs = new long[totalUnpackStreams];\n        \n        int nextUnpackStream = 0;\n        for (final Folder folder : archive.folders) {\n            if (folder.numUnpackSubStreams == 0) {\n                continue;\n            }\n            long sum = 0;\n            if (nid == NID.kSize) {\n                for (int i = 0; i < folder.numUnpackSubStreams - 1; i++) {\n                    final long size = readUint64(header);\n                    subStreamsInfo.unpackSizes[nextUnpackStream++] = size;\n                    sum += size;\n                }\n            }\n            subStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;\n        }\n        if (nid == NID.kSize) {\n            nid = header.readUnsignedByte();\n        }\n        \n        int numDigests = 0;\n        for (final Folder folder : archive.folders) {\n            if (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {\n                numDigests += folder.numUnpackSubStreams;\n            }\n        }\n        \n        if (nid == NID.kCRC) {\n            final BitSet hasMissingCrc = readAllOrBits(header, numDigests);\n            final long[] missingCrcs = new long[numDigests];\n            for (int i = 0; i < numDigests; i++) {\n                if (hasMissingCrc.get(i)) {\n                    missingCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n                }\n            }\n            int nextCrc = 0;\n            int nextMissingCrc = 0;\n            for (final Folder folder: archive.folders) {\n                if (folder.numUnpackSubStreams == 1 && folder.hasCrc) {\n                    subStreamsInfo.hasCrc.set(nextCrc, true);\n                    subStreamsInfo.crcs[nextCrc] = folder.crc;\n                    ++nextCrc;\n                } else {\n                    for (int i = 0; i < folder.numUnpackSubStreams; i++) {\n                        subStreamsInfo.hasCrc.set(nextCrc, hasMissingCrc.get(nextMissingCrc));\n                        subStreamsInfo.crcs[nextCrc] = missingCrcs[nextMissingCrc];\n                        ++nextCrc;\n                        ++nextMissingCrc;\n                    }\n                }\n            }\n            \n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid != NID.kEnd) {\n            throw new IOException(\"Badly terminated SubStreamsInfo\");\n        }\n        \n        archive.subStreamsInfo = subStreamsInfo;\n    }\n    \n    private Folder readFolder(final DataInput header) throws IOException {\n        final Folder folder = new Folder();\n        \n        final long numCoders = readUint64(header);\n        final Coder[] coders = new Coder[(int)numCoders];\n        long totalInStreams = 0;\n        long totalOutStreams = 0;\n        for (int i = 0; i < coders.length; i++) {\n            coders[i] = new Coder();\n            final int bits = header.readUnsignedByte();\n            final int idSize = bits & 0xf;\n            final boolean isSimple = (bits & 0x10) == 0;\n            final boolean hasAttributes = (bits & 0x20) != 0;\n            final boolean moreAlternativeMethods = (bits & 0x80) != 0;\n            \n            coders[i].decompressionMethodId = new byte[idSize];\n            header.readFully(coders[i].decompressionMethodId);\n            if (isSimple) {\n                coders[i].numInStreams = 1;\n                coders[i].numOutStreams = 1;\n            } else {\n                coders[i].numInStreams = readUint64(header);\n                coders[i].numOutStreams = readUint64(header);\n            }\n            totalInStreams += coders[i].numInStreams;\n            totalOutStreams += coders[i].numOutStreams;\n            if (hasAttributes) {\n                final long propertiesSize = readUint64(header);\n                coders[i].properties = new byte[(int)propertiesSize];\n                header.readFully(coders[i].properties);\n            }\n            \n            while (moreAlternativeMethods) {\n                throw new IOException(\"Alternative methods are unsupported, please report. \" +\n                        \"The reference implementation doesn't support them either.\");\n            }\n        }\n        folder.coders = coders;\n        folder.totalInputStreams = totalInStreams;\n        folder.totalOutputStreams = totalOutStreams;\n        \n        if (totalOutStreams == 0) {\n            throw new IOException(\"Total output streams can't be 0\");\n        }\n        final long numBindPairs = totalOutStreams - 1;\n        final BindPair[] bindPairs = new BindPair[(int)numBindPairs];\n        for (int i = 0; i < bindPairs.length; i++) {\n            bindPairs[i] = new BindPair();\n            bindPairs[i].inIndex = readUint64(header);\n            bindPairs[i].outIndex = readUint64(header);\n        }\n        folder.bindPairs = bindPairs;\n        \n        if (totalInStreams < numBindPairs) {\n            throw new IOException(\"Total input streams can't be less than the number of bind pairs\");\n        }\n        final long numPackedStreams = totalInStreams - numBindPairs;\n        final long packedStreams[] = new long[(int)numPackedStreams];\n        if (numPackedStreams == 1) {\n            int i;\n            for (i = 0; i < (int)totalInStreams; i++) {\n                if (folder.findBindPairForInStream(i) < 0) {\n                    break;\n                }\n            }\n            if (i == (int)totalInStreams) {\n                throw new IOException(\"Couldn't find stream's bind pair index\");\n            }\n            packedStreams[0] = i;\n        } else {\n            for (int i = 0; i < (int)numPackedStreams; i++) {\n                packedStreams[i] = readUint64(header);\n            }\n        }\n        folder.packedStreams = packedStreams;\n        \n        return folder;\n    }\n    \n    private BitSet readAllOrBits(final DataInput header, final int size) throws IOException {\n        final int areAllDefined = header.readUnsignedByte();\n        final BitSet bits;\n        if (areAllDefined != 0) {\n            bits = new BitSet(size);\n            for (int i = 0; i < size; i++) {\n                bits.set(i, true);\n            }\n        } else {\n            bits = readBits(header, size);\n        }\n        return bits;\n    }\n    \n    private BitSet readBits(final DataInput header, final int size) throws IOException {\n        final BitSet bits = new BitSet(size);\n        int mask = 0;\n        int cache = 0;\n        for (int i = 0; i < size; i++) {\n            if (mask == 0) {\n                mask = 0x80;\n                cache = header.readUnsignedByte();\n            }\n            bits.set(i, (cache & mask) != 0);\n            mask >>>= 1;\n        }\n        return bits;\n    }\n    \n    private void readFilesInfo(final DataInput header, final Archive archive) throws IOException {\n        final long numFiles = readUint64(header);\n        final SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\n        for (int i = 0; i < files.length; i++) {\n            files[i] = new SevenZArchiveEntry();\n        }\n        BitSet isEmptyStream = null;\n        BitSet isEmptyFile = null; \n        BitSet isAnti = null;\n        while (true) {\n            final int propertyType = header.readUnsignedByte();\n            if (propertyType == 0) {\n                break;\n            }\n            final long size = readUint64(header);\n            switch (propertyType) {\n                case NID.kEmptyStream: {\n                    isEmptyStream = readBits(header, files.length);\n                    break;\n                }\n                case NID.kEmptyFile: {\n                    if (isEmptyStream == null) { \n                        throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n                    }\n                    isEmptyFile = readBits(header, isEmptyStream.cardinality());\n                    break;\n                }\n                case NID.kAnti: {\n                    if (isEmptyStream == null) { \n                        throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n                    }\n                    isAnti = readBits(header, isEmptyStream.cardinality());\n                    break;\n                }\n                case NID.kName: {\n                    final int external = header.readUnsignedByte();\n                    if (external != 0) {\n                        throw new IOException(\"Not implemented\");\n                    }\n                    if (((size - 1) & 1) != 0) {\n                        throw new IOException(\"File names length invalid\");\n                    }\n                    final byte[] names = new byte[(int)(size - 1)];\n                    header.readFully(names);\n                    int nextFile = 0;\n                    int nextName = 0;\n                    for (int i = 0; i < names.length; i += 2) {\n                        if (names[i] == 0 && names[i+1] == 0) {\n                            files[nextFile++].setName(new String(names, nextName, i-nextName, CharsetNames.UTF_16LE));\n                            nextName = i + 2;\n                        }\n                    }\n                    if (nextName != names.length || nextFile != files.length) {\n                        throw new IOException(\"Error parsing file names\");\n                    }\n                    break;\n                }\n                case NID.kCTime: {\n                    final BitSet timesDefined = readAllOrBits(header, files.length);\n                    final int external = header.readUnsignedByte();\n                    if (external != 0) {\n                        throw new IOException(\"Unimplemented\");\n                    }\n                    for (int i = 0; i < files.length; i++) {\n                        files[i].setHasCreationDate(timesDefined.get(i));\n                        if (files[i].getHasCreationDate()) {\n                            files[i].setCreationDate(Long.reverseBytes(header.readLong()));\n                        }\n                    }\n                    break;\n                }\n                case NID.kATime: {\n                    final BitSet timesDefined = readAllOrBits(header, files.length);\n                    final int external = header.readUnsignedByte();\n                    if (external != 0) {\n                        throw new IOException(\"Unimplemented\");\n                    }\n                    for (int i = 0; i < files.length; i++) {\n                        files[i].setHasAccessDate(timesDefined.get(i));\n                        if (files[i].getHasAccessDate()) {\n                            files[i].setAccessDate(Long.reverseBytes(header.readLong()));\n                        }\n                    }\n                    break;\n                }\n                case NID.kMTime: {\n                    final BitSet timesDefined = readAllOrBits(header, files.length);\n                    final int external = header.readUnsignedByte();\n                    if (external != 0) {\n                        throw new IOException(\"Unimplemented\");\n                    }\n                    for (int i = 0; i < files.length; i++) {\n                        files[i].setHasLastModifiedDate(timesDefined.get(i));\n                        if (files[i].getHasLastModifiedDate()) {\n                            files[i].setLastModifiedDate(Long.reverseBytes(header.readLong()));\n                        }\n                    }\n                    break;\n                }\n                case NID.kWinAttributes: {\n                    final BitSet attributesDefined = readAllOrBits(header, files.length);\n                    final int external = header.readUnsignedByte();\n                    if (external != 0) {\n                        throw new IOException(\"Unimplemented\");\n                    }\n                    for (int i = 0; i < files.length; i++) {\n                        files[i].setHasWindowsAttributes(attributesDefined.get(i));\n                        if (files[i].getHasWindowsAttributes()) {\n                            files[i].setWindowsAttributes(Integer.reverseBytes(header.readInt()));\n                        }\n                    }\n                    break;\n                }\n                case NID.kStartPos: {\n                    throw new IOException(\"kStartPos is unsupported, please report\");\n                }\n                case NID.kDummy: {\n                    \n                    \n                    \n                    if (skipBytesFully(header, size) < size) {\n                        throw new IOException(\"Incomplete kDummy property\");\n                    }\n                    break;\n                }\n\n                default: {\n                    \n                    if (skipBytesFully(header, size) < size) {\n                        throw new IOException(\"Incomplete property of type \" + propertyType);\n                    }\n                    break;\n                }\n            }\n        }\n        int nonEmptyFileCounter = 0;\n        int emptyFileCounter = 0;\n        for (int i = 0; i < files.length; i++) {\n            files[i].setHasStream(isEmptyStream == null ? true : !isEmptyStream.get(i));\n            if (files[i].hasStream()) {\n                files[i].setDirectory(false);\n                files[i].setAntiItem(false);\n                files[i].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\n                files[i].setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\n                files[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n                ++nonEmptyFileCounter;\n            } else {\n                files[i].setDirectory(isEmptyFile == null ? true : !isEmptyFile.get(emptyFileCounter));\n                files[i].setAntiItem(isAnti == null ? false : isAnti.get(emptyFileCounter));\n                files[i].setHasCrc(false);\n                files[i].setSize(0);\n                ++emptyFileCounter;\n            }\n        }\n        archive.files = files;\n        calculateStreamMap(archive);\n    }\n    \n    private void calculateStreamMap(final Archive archive) throws IOException {\n        final StreamMap streamMap = new StreamMap();\n        \n        int nextFolderPackStreamIndex = 0;\n        final int numFolders = archive.folders != null ? archive.folders.length : 0;\n        streamMap.folderFirstPackStreamIndex = new int[numFolders];\n        for (int i = 0; i < numFolders; i++) {\n            streamMap.folderFirstPackStreamIndex[i] = nextFolderPackStreamIndex;\n            nextFolderPackStreamIndex += archive.folders[i].packedStreams.length;\n        }\n        \n        long nextPackStreamOffset = 0;\n        final int numPackSizes = archive.packSizes != null ? archive.packSizes.length : 0;\n        streamMap.packStreamOffsets = new long[numPackSizes];\n        for (int i = 0; i < numPackSizes; i++) {\n            streamMap.packStreamOffsets[i] = nextPackStreamOffset;\n            nextPackStreamOffset += archive.packSizes[i]; \n        }\n        \n        streamMap.folderFirstFileIndex = new int[numFolders];\n        streamMap.fileFolderIndex = new int[archive.files.length];\n        int nextFolderIndex = 0;\n        int nextFolderUnpackStreamIndex = 0;\n        for (int i = 0; i < archive.files.length; i++) {\n            if (!archive.files[i].hasStream() && nextFolderUnpackStreamIndex == 0) {\n                streamMap.fileFolderIndex[i] = -1;\n                continue;\n            }\n            if (nextFolderUnpackStreamIndex == 0) {\n                for (; nextFolderIndex < archive.folders.length; ++nextFolderIndex) {\n                    streamMap.folderFirstFileIndex[nextFolderIndex] = i;\n                    if (archive.folders[nextFolderIndex].numUnpackSubStreams > 0) {\n                        break;\n                    }\n                }\n                if (nextFolderIndex >= archive.folders.length) {\n                    throw new IOException(\"Too few folders in archive\");\n                }\n            }\n            streamMap.fileFolderIndex[i] = nextFolderIndex;\n            if (!archive.files[i].hasStream()) {\n                continue;\n            }\n            ++nextFolderUnpackStreamIndex;\n            if (nextFolderUnpackStreamIndex >= archive.folders[nextFolderIndex].numUnpackSubStreams) {\n                ++nextFolderIndex;\n                nextFolderUnpackStreamIndex = 0;\n            }\n        }\n        \n        archive.streamMap = streamMap;\n    }\n    \n    private void buildDecodingStream() throws IOException {\n        final int folderIndex = archive.streamMap.fileFolderIndex[currentEntryIndex];\n        if (folderIndex < 0) {\n            deferredBlockStreams.clear();\n            \n            \n            return;\n        }\n        final SevenZArchiveEntry file = archive.files[currentEntryIndex];\n        if (currentFolderIndex == folderIndex) {\n            \n            \n            \n            \n            \n\n            file.setContentMethods(archive.files[currentEntryIndex - 1].getContentMethods());\n        } else {\n            \n            currentFolderIndex = folderIndex;\n            deferredBlockStreams.clear();\n            if (currentFolderInputStream != null) {\n                currentFolderInputStream.close();\n                currentFolderInputStream = null;\n            }\n            \n            final Folder folder = archive.folders[folderIndex];\n            final int firstPackStreamIndex = archive.streamMap.folderFirstPackStreamIndex[folderIndex];\n            final long folderOffset = SIGNATURE_HEADER_SIZE + archive.packPos +\n                    archive.streamMap.packStreamOffsets[firstPackStreamIndex];\n            currentFolderInputStream = buildDecoderStack(folder, folderOffset, firstPackStreamIndex, file);\n        }\n\n        InputStream fileStream = new BoundedInputStream(currentFolderInputStream, file.getSize());\n        if (file.getHasCrc()) {\n            fileStream = new CRC32VerifyingInputStream(fileStream, file.getSize(), file.getCrcValue());\n        }\n        \n        deferredBlockStreams.add(fileStream);\n    }\n\n    private InputStream buildDecoderStack(final Folder folder, final long folderOffset, final int firstPackStreamIndex, final SevenZArchiveEntry entry) throws IOException {\n        file.seek(folderOffset);\n        InputStream inputStreamStack =\n            new BufferedInputStream(\n              new BoundedRandomAccessFileInputStream(file,\n                  archive.packSizes[firstPackStreamIndex]));\n        final LinkedList<SevenZMethodConfiguration> methods = new LinkedList<SevenZMethodConfiguration>();\n        for (final Coder coder : folder.getOrderedCoders()) {\n            if (coder.numInStreams != 1 || coder.numOutStreams != 1) {\n                throw new IOException(\"Multi input/output stream coders are not yet supported\");\n            }\n            final SevenZMethod method = SevenZMethod.byId(coder.decompressionMethodId);\n            inputStreamStack = Coders.addDecoder(fileName, inputStreamStack,\n                    folder.getUnpackSizeForCoder(coder), coder, password);\n            methods.addFirst(new SevenZMethodConfiguration(method,\n                     Coders.findByMethod(method).getOptionsFromCoder(coder, inputStreamStack)));\n        }\n        entry.setContentMethods(methods);\n        if (folder.hasCrc) {\n            return new CRC32VerifyingInputStream(inputStreamStack,\n                    folder.getUnpackSize(), folder.crc);\n        }\n        return inputStreamStack;\n    }\n    \n    \n    public int read() throws IOException {\n        return getCurrentStream().read();\n    }\n    \n    private InputStream getCurrentStream() throws IOException {\n        if (archive.files[currentEntryIndex].getSize() == 0) {\n            return new ByteArrayInputStream(new byte[0]);\n        }\n        if (deferredBlockStreams.isEmpty()) {\n            throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n        }\n        \n        while (deferredBlockStreams.size() > 1) {\n            \n            \n            \n            final InputStream stream = deferredBlockStreams.remove(0);\n            IOUtils.skip(stream, Long.MAX_VALUE);\n            stream.close();\n        }\n\n        return deferredBlockStreams.get(0);\n    }\n\n    \n    public int read(final byte[] b) throws IOException {\n        return read(b, 0, b.length);\n    }\n    \n    \n    public int read(final byte[] b, final int off, final int len) throws IOException {\n        return getCurrentStream().read(b, off, len);\n    }\n    \n    private static long readUint64(final DataInput in) throws IOException {\n        \n        final long firstByte = in.readUnsignedByte();\n        int mask = 0x80;\n        long value = 0;\n        for (int i = 0; i < 8; i++) {\n            if ((firstByte & mask) == 0) {\n                return value | ((firstByte & (mask - 1)) << (8 * i));\n            }\n            final long nextByte = in.readUnsignedByte();\n            value |= nextByte << (8 * i);\n            mask >>>= 1;\n        }\n        return value;\n    }\n\n    \n    public static boolean matches(final byte[] signature, final int length) {\n        if (length < sevenZSignature.length) {\n            return false;\n        }\n\n        for (int i = 0; i < sevenZSignature.length; i++) {\n            if (signature[i] != sevenZSignature[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static long skipBytesFully(final DataInput input, long bytesToSkip) throws IOException {\n        if (bytesToSkip < 1) {\n            return 0;\n        }\n        long skipped = 0;\n        while (bytesToSkip > Integer.MAX_VALUE) {\n            final long skippedNow = skipBytesFully(input, Integer.MAX_VALUE);\n            if (skippedNow == 0) {\n                return skipped;\n            }\n            skipped += skippedNow;\n            bytesToSkip -= skippedNow;\n        }\n        while (bytesToSkip > 0) {\n            final int skippedNow = input.skipBytes((int) bytesToSkip);\n            if (skippedNow == 0) {\n                return skipped;\n            }\n            skipped += skippedNow;\n            bytesToSkip -= skippedNow;\n        }\n        return skipped;\n    }\n    \n    @Override\n    public String toString() {\n      return archive.toString();\n    }\n}\n",
      "buggy_signatures": [
        "public SevenZFile(final File filename, final byte[] password) throws IOException",
        "public SevenZFile(final File filename) throws IOException",
        "public void close() throws IOException",
        "public SevenZArchiveEntry getNextEntry() throws IOException",
        "public Iterable<SevenZArchiveEntry> getEntries()",
        "private Archive readHeaders(final byte[] password) throws IOException",
        "private StartHeader readStartHeader(final long startHeaderCrc) throws IOException",
        "private void readHeader(final DataInput header, final Archive archive) throws IOException",
        "private void readArchiveProperties(final DataInput input) throws IOException",
        "private DataInputStream readEncodedHeader(final DataInputStream header, final Archive archive, final byte[] password) throws IOException",
        "private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException",
        "private void readPackInfo(final DataInput header, final Archive archive) throws IOException",
        "private void readUnpackInfo(final DataInput header, final Archive archive) throws IOException",
        "private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException",
        "private Folder readFolder(final DataInput header) throws IOException",
        "private BitSet readAllOrBits(final DataInput header, final int size) throws IOException",
        "private BitSet readBits(final DataInput header, final int size) throws IOException",
        "private void readFilesInfo(final DataInput header, final Archive archive) throws IOException",
        "private void calculateStreamMap(final Archive archive) throws IOException",
        "private void buildDecodingStream() throws IOException",
        "private InputStream buildDecoderStack(final Folder folder, final long folderOffset, final int firstPackStreamIndex, final SevenZArchiveEntry entry) throws IOException",
        "public int read() throws IOException",
        "private InputStream getCurrentStream() throws IOException",
        "public int read(final byte[] b) throws IOException",
        "public int read(final byte[] b, final int off, final int len) throws IOException",
        "private static long readUint64(final DataInput in) throws IOException",
        "public static boolean matches(final byte[] signature, final int length)",
        "private static long skipBytesFully(final DataInput input, long bytesToSkip) throws IOException",
        "public String toString()"
      ],
      "fixed_signatures": [
        "public SevenZFile(final File filename, final byte[] password) throws IOException",
        "public SevenZFile(final File filename) throws IOException",
        "public void close() throws IOException",
        "public SevenZArchiveEntry getNextEntry() throws IOException",
        "public Iterable<SevenZArchiveEntry> getEntries()",
        "private Archive readHeaders(final byte[] password) throws IOException",
        "private StartHeader readStartHeader(final long startHeaderCrc) throws IOException",
        "private void readHeader(final DataInput header, final Archive archive) throws IOException",
        "private void readArchiveProperties(final DataInput input) throws IOException",
        "private DataInputStream readEncodedHeader(final DataInputStream header, final Archive archive, final byte[] password) throws IOException",
        "private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException",
        "private void readPackInfo(final DataInput header, final Archive archive) throws IOException",
        "private void readUnpackInfo(final DataInput header, final Archive archive) throws IOException",
        "private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException",
        "private Folder readFolder(final DataInput header) throws IOException",
        "private BitSet readAllOrBits(final DataInput header, final int size) throws IOException",
        "private BitSet readBits(final DataInput header, final int size) throws IOException",
        "private void readFilesInfo(final DataInput header, final Archive archive) throws IOException",
        "private void calculateStreamMap(final Archive archive) throws IOException",
        "private void buildDecodingStream() throws IOException",
        "private InputStream buildDecoderStack(final Folder folder, final long folderOffset, final int firstPackStreamIndex, final SevenZArchiveEntry entry) throws IOException",
        "public int read() throws IOException",
        "private InputStream getCurrentStream() throws IOException",
        "public int read(final byte[] b) throws IOException",
        "public int read(final byte[] b, final int off, final int len) throws IOException",
        "private static long readUint64(final DataInput in) throws IOException",
        "public static boolean matches(final byte[] signature, final int length)",
        "private static long skipBytesFully(final DataInput input, long bytesToSkip) throws IOException",
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "  private InputStream getCurrentStream() throws IOException {\n  if (deferredBlockStreams.isEmpty()) {\n  throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n  }\n  \n  while (deferredBlockStreams.size() > 1) {\n  \n  \n  \n  final InputStream stream = deferredBlockStreams.remove(0);\n  IOUtils.skip(stream, Long.MAX_VALUE);\n  stream.close();\n  }\n\n  return deferredBlockStreams.get(0);\n  }",
          "fixed_method": "  private InputStream getCurrentStream() throws IOException {\n  if (archive.files[currentEntryIndex].getSize() == 0) {\n  return new ByteArrayInputStream(new byte[0]);\n  }\n  if (deferredBlockStreams.isEmpty()) {\n  throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n  }\n  \n  while (deferredBlockStreams.size() > 1) {\n  \n  \n  \n  final InputStream stream = deferredBlockStreams.remove(0);\n  IOUtils.skip(stream, Long.MAX_VALUE);\n  stream.close();\n  }\n\n  return deferredBlockStreams.get(0);\n  }",
          "diff": [
            "@@ -899,6 +899,9 @@",
            "     }\n",
            "     \n",
            "     private InputStream getCurrentStream() throws IOException {\n",
            "+        if (archive.files[currentEntryIndex].getSize() == 0) {\n",
            "+            return new ByteArrayInputStream(new byte[0]);\n",
            "+        }\n",
            "         if (deferredBlockStreams.isEmpty()) {\n",
            "             throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n",
            "         }\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
