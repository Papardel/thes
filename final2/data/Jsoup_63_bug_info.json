{
  "bug_id": "63",
  "failed_tests": {
    "org.jsoup.parser.HtmlParserTest": [
      {
        "methodName": "selfClosingOnNonvoidIsError",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<18: [Tag cannot be self closing; not a void tag]> but was:<18: [Self closing flag not acknowledged]>",
        "fail_line": "        assertEquals(\"18: Tag cannot be self closing; not a void tag\", parser.getErrors().get(0).toString());",
        "test_source": "",
        "stack": [
          "HtmlParserTest.selfClosingOnNonvoidIsError line 983"
        ]
      },
      {
        "methodName": "selfClosingVoidIsNotAnError",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<0> but was:<2>",
        "fail_line": "        assertEquals(0, parser.getErrors().size());",
        "test_source": "",
        "stack": [
          "HtmlParserTest.selfClosingVoidIsNotAnError line 971"
        ]
      },
      {
        "methodName": "tracksErrorsWhenRequested",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<50: [Tag cannot be self closing; not a void tag]> but was:<50: [Self closing flag not acknowledged]>",
        "fail_line": "        assertEquals(\"50: Tag cannot be self closing; not a void tag\", errors.get(3).toString());",
        "test_source": "",
        "stack": [
          "HtmlParserTest.tracksErrorsWhenRequested line 699"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/parser/HtmlTreeBuilder.java",
      "buggy_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Comment;\nimport org.jsoup.nodes.DataNode;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.FormElement;\nimport org.jsoup.nodes.Node;\nimport org.jsoup.nodes.TextNode;\nimport org.jsoup.select.Elements;\n\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\n\npublic class HtmlTreeBuilder extends TreeBuilder { private static final String[] TagsSearchInScope = new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"}; private static final String[] TagSearchList = new String[]{\"ol\", \"ul\"}; private static final String[] TagSearchButton = new String[]{\"button\"}; private static final String[] TagSearchTableScope = new String[]{\"html\", \"table\"}; private static final String[] TagSearchSelectScope = new String[]{\"optgroup\", \"option\"}; private static final String[] TagSearchEndTags = new String[]{\"dd\", \"dt\", \"li\", \"option\", \"optgroup\", \"p\", \"rp\", \"rt\"}; private static final String[] TagSearchSpecial = new String[]{\"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\", \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"command\", \"dd\", \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\", \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"marquee\", \"menu\", \"meta\", \"nav\", \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\", \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\"}; private HtmlTreeBuilderState state; private HtmlTreeBuilderState originalState; private boolean baseUriSetFromDoc; private Element headElement; private FormElement formElement; private Element contextElement; private ArrayList<Element> formattingElements; private List<String> pendingTableCharacters; private Token.EndTag emptyEnd; private boolean framesetOk; private boolean fosterInserts; private boolean fragmentParsing; HtmlTreeBuilder() {}\n\n    ParseSettings defaultSettings() {\n        return ParseSettings.htmlDefault;\n    }\n\n    @Override\n    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        super.initialiseParse(input, baseUri, errors, settings);\n\n        \n        state = HtmlTreeBuilderState.Initial;\n        originalState = null;\n        baseUriSetFromDoc = false;\n        headElement = null;\n        formElement = null;\n        contextElement = null;\n        formattingElements = new ArrayList<>();\n        pendingTableCharacters = new ArrayList<>();\n        emptyEnd = new Token.EndTag();\n        framesetOk = true;\n        fosterInserts = false;\n        fragmentParsing = false;\n    }\n\n    List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        \n        state = HtmlTreeBuilderState.Initial;\n        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n        contextElement = context;\n        fragmentParsing = true;\n        Element root = null;\n\n        if (context != null) {\n            if (context.ownerDocument() != null) \n                doc.quirksMode(context.ownerDocument().quirksMode());\n\n            \n            String contextTag = context.tagName();\n            if (StringUtil.in(contextTag, \"title\", \"textarea\"))\n                tokeniser.transition(TokeniserState.Rcdata);\n            else if (StringUtil.in(contextTag, \"iframe\", \"noembed\", \"noframes\", \"style\", \"xmp\"))\n                tokeniser.transition(TokeniserState.Rawtext);\n            else if (contextTag.equals(\"script\"))\n                tokeniser.transition(TokeniserState.ScriptData);\n            else if (contextTag.equals((\"noscript\")))\n                tokeniser.transition(TokeniserState.Data); \n            else if (contextTag.equals(\"plaintext\"))\n                tokeniser.transition(TokeniserState.Data);\n            else\n                tokeniser.transition(TokeniserState.Data); \n\n            root = new Element(Tag.valueOf(\"html\", settings), baseUri);\n            doc.appendChild(root);\n            stack.add(root);\n            resetInsertionMode();\n\n            \n            \n            Elements contextChain = context.parents();\n            contextChain.add(0, context);\n            for (Element parent: contextChain) {\n                if (parent instanceof FormElement) {\n                    formElement = (FormElement) parent;\n                    break;\n                }\n            }\n        }\n\n        runParser();\n        if (context != null)\n            return root.childNodes();\n        else\n            return doc.childNodes();\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        currentToken = token;\n        return this.state.process(token, this);\n    }\n\n    boolean process(Token token, HtmlTreeBuilderState state) {\n        currentToken = token;\n        return state.process(token, this);\n    }\n\n    void transition(HtmlTreeBuilderState state) {\n        this.state = state;\n    }\n\n    HtmlTreeBuilderState state() {\n        return state;\n    }\n\n    void markInsertionMode() {\n        originalState = state;\n    }\n\n    HtmlTreeBuilderState originalState() {\n        return originalState;\n    }\n\n    void framesetOk(boolean framesetOk) {\n        this.framesetOk = framesetOk;\n    }\n\n    boolean framesetOk() {\n        return framesetOk;\n    }\n\n    Document getDocument() {\n        return doc;\n    }\n\n    String getBaseUri() {\n        return baseUri;\n    }\n\n    void maybeSetBaseUri(Element base) {\n        if (baseUriSetFromDoc) \n            return;\n\n        String href = base.absUrl(\"href\");\n        if (href.length() != 0) { \n            baseUri = href;\n            baseUriSetFromDoc = true;\n            doc.setBaseUri(href); \n        }\n    }\n\n    boolean isFragmentParsing() {\n        return fragmentParsing;\n    }\n\n    void error(HtmlTreeBuilderState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }\n\n    Element insert(Token.StartTag startTag) {\n        \n        \n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.transition(TokeniserState.Data); \n            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  \n            return el;\n        }\n        \n        Element el = new Element(Tag.valueOf(startTag.name(), settings), baseUri, settings.normalizeAttributes(startTag.attributes));\n        insert(el);\n        return el;\n    }\n\n    Element insertStartTag(String startTagName) {\n        Element el = new Element(Tag.valueOf(startTagName, settings), baseUri);\n        insert(el);\n        return el;\n    }\n\n    void insert(Element el) {\n        insertNode(el);\n        stack.add(el);\n    }\n\n    Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (tag.isKnownTag()) {\n                if (tag.isSelfClosing()) tokeniser.acknowledgeSelfClosingFlag();\n            }\n            else {\n                tag.setSelfClosing();\n                tokeniser.acknowledgeSelfClosingFlag();\n            }\n        }\n        return el;\n    }\n\n    FormElement insertForm(Token.StartTag startTag, boolean onStack) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        FormElement el = new FormElement(tag, baseUri, startTag.attributes);\n        setFormElement(el);\n        insertNode(el);\n        if (onStack)\n            stack.add(el);\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData(), baseUri);\n        insertNode(comment);\n    }\n\n    void insert(Token.Character characterToken) {\n        Node node;\n        \n        String tagName = currentElement().tagName();\n        if (tagName.equals(\"script\") || tagName.equals(\"style\"))\n            node = new DataNode(characterToken.getData(), baseUri);\n        else\n            node = new TextNode(characterToken.getData(), baseUri);\n        currentElement().appendChild(node); \n    }\n\n    private void insertNode(Node node) {\n        \n        if (stack.size() == 0)\n            doc.appendChild(node);\n        else if (isFosterInserts())\n            insertInFosterParent(node);\n        else\n            currentElement().appendChild(node);\n\n        \n        if (node instanceof Element && ((Element) node).tag().isFormListed()) {\n            if (formElement != null)\n                formElement.addElement((Element) node);\n        }\n    }\n\n    Element pop() {\n        int size = stack.size();\n        return stack.remove(size-1);\n    }\n\n    void push(Element element) {\n        stack.add(element);\n    }\n\n    ArrayList<Element> getStack() {\n        return stack;\n    }\n\n    boolean onStack(Element el) {\n        return isElementInQueue(stack, el);\n    }\n\n    private boolean isElementInQueue(ArrayList<Element> queue, Element element) {\n        for (int pos = queue.size() -1; pos >= 0; pos--) {\n            Element next = queue.get(pos);\n            if (next == element) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    Element getFromStack(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                return next;\n            }\n        }\n        return null;\n    }\n\n    boolean removeFromStack(Element el) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                stack.remove(pos);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    void popStackToClose(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next.nodeName().equals(elName))\n                break;\n        }\n    }\n\n    void popStackToClose(String... elNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (StringUtil.in(next.nodeName(), elNames))\n                break;\n        }\n    }\n\n    void popStackToBefore(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                break;\n            } else {\n                stack.remove(pos);\n            }\n        }\n    }\n\n    void clearStackToTableContext() {\n        clearStackToContext(\"table\");\n    }\n\n    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n    }\n\n    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\");\n    }\n\n    private void clearStackToContext(String... nodeNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n                break;\n            else\n                stack.remove(pos);\n        }\n    }\n\n    Element aboveOnStack(Element el) {\n        assert onStack(el);\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                return stack.get(pos-1);\n            }\n        }\n        return null;\n    }\n\n    void insertOnStackAfter(Element after, Element in) {\n        int i = stack.lastIndexOf(after);\n        Validate.isTrue(i != -1);\n        stack.add(i+1, in);\n    }\n\n    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }\n\n    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.set(i, in);\n    }\n\n    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; \n            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; \n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; \n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; \n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; \n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; \n            }\n        }\n    }\n\n    \n    private String[] specificScopeTarget = {null}; private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        specificScopeTarget[0] = targetName;\n        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.nodeName();\n            if (StringUtil.in(elName, targetNames))\n                return true;\n            if (StringUtil.in(elName, baseTypes))\n                return false;\n            if (extraTypes != null && StringUtil.in(elName, extraTypes))\n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }\n\n    boolean inScope(String[] targetNames) {\n        return inSpecificScope(targetNames, TagsSearchInScope, null);\n    }\n\n    boolean inScope(String targetName) {\n        return inScope(targetName, null);\n    }\n\n    boolean inScope(String targetName, String[] extras) {\n        return inSpecificScope(targetName, TagsSearchInScope, extras);\n        \n        \n    }\n\n    boolean inListItemScope(String targetName) {\n        return inScope(targetName, TagSearchList);\n    }\n\n    boolean inButtonScope(String targetName) {\n        return inScope(targetName, TagSearchButton);\n    }\n\n    boolean inTableScope(String targetName) {\n        return inSpecificScope(targetName, TagSearchTableScope, null);\n    }\n\n    boolean inSelectScope(String targetName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.nodeName();\n            if (elName.equals(targetName))\n                return true;\n            if (!StringUtil.in(elName, TagSearchSelectScope)) \n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }\n\n    void setHeadElement(Element headElement) {\n        this.headElement = headElement;\n    }\n\n    Element getHeadElement() {\n        return headElement;\n    }\n\n    boolean isFosterInserts() {\n        return fosterInserts;\n    }\n\n    void setFosterInserts(boolean fosterInserts) {\n        this.fosterInserts = fosterInserts;\n    }\n\n    FormElement getFormElement() {\n        return formElement;\n    }\n\n    void setFormElement(FormElement formElement) {\n        this.formElement = formElement;\n    }\n\n    void newPendingTableCharacters() {\n        pendingTableCharacters = new ArrayList<>();\n    }\n\n    List<String> getPendingTableCharacters() {\n        return pendingTableCharacters;\n    }\n\n    void setPendingTableCharacters(List<String> pendingTableCharacters) {\n        this.pendingTableCharacters = pendingTableCharacters;\n    }\n\n    \n    void generateImpliedEndTags(String excludeTag) {\n        while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\n                StringUtil.in(currentElement().nodeName(), TagSearchEndTags))\n            pop();\n    }\n\n    void generateImpliedEndTags() {\n        generateImpliedEndTags(null);\n    }\n\n    boolean isSpecial(Element el) {\n        \n        \n        String name = el.nodeName();\n        return StringUtil.in(name, TagSearchSpecial);\n    }\n\n    Element lastFormattingElement() {\n        return formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;\n    }\n\n    Element removeLastFormattingElement() {\n        int size = formattingElements.size();\n        if (size > 0)\n            return formattingElements.remove(size-1);\n        else\n            return null;\n    }\n\n    \n    void pushActiveFormattingElements(Element in) {\n        int numSeen = 0;\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element el = formattingElements.get(pos);\n            if (el == null) \n                break;\n\n            if (isSameFormattingElement(in, el))\n                numSeen++;\n\n            if (numSeen == 3) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n        formattingElements.add(in);\n    }\n\n    private boolean isSameFormattingElement(Element a, Element b) {\n        \n        return a.nodeName().equals(b.nodeName()) &&\n                \n                a.attributes().equals(b.attributes());\n        \n    }\n\n    void reconstructFormattingElements() {\n        Element last = lastFormattingElement();\n        if (last == null || onStack(last))\n            return;\n\n        Element entry = last;\n        int size = formattingElements.size();\n        int pos = size - 1;\n        boolean skip = false;\n        while (true) {\n            if (pos == 0) { \n                skip = true;\n                break;\n            }\n            entry = formattingElements.get(--pos); \n            if (entry == null || onStack(entry)) \n                break; \n        }\n        while(true) {\n            if (!skip) \n                entry = formattingElements.get(++pos);\n            Validate.notNull(entry); \n\n            \n            skip = false; \n            Element newEl = insertStartTag(entry.nodeName()); \n            \n            newEl.attributes().addAll(entry.attributes());\n\n            \n            formattingElements.set(pos, newEl);\n\n            \n            if (pos == size-1) \n                break;\n        }\n    }\n\n    void clearFormattingElementsToLastMarker() {\n        while (!formattingElements.isEmpty()) {\n            Element el = removeLastFormattingElement();\n            if (el == null)\n                break;\n        }\n    }\n\n    void removeFromActiveFormattingElements(Element el) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == el) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n    }\n\n    boolean isInActiveFormattingElements(Element el) {\n        return isElementInQueue(formattingElements, el);\n    }\n\n    Element getActiveFormattingElement(String nodeName) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == null) \n                break;\n            else if (next.nodeName().equals(nodeName))\n                return next;\n        }\n        return null;\n    }\n\n    void replaceActiveFormattingElement(Element out, Element in) {\n        replaceInQueue(formattingElements, out, in);\n    }\n\n    void insertMarkerToFormattingElements() {\n        formattingElements.add(null);\n    }\n\n    void insertInFosterParent(Node in) {\n        Element fosterParent;\n        Element lastTable = getFromStack(\"table\");\n        boolean isLastTableParent = false;\n        if (lastTable != null) {\n            if (lastTable.parent() != null) {\n                fosterParent = lastTable.parent();\n                isLastTableParent = true;\n            } else\n                fosterParent = aboveOnStack(lastTable);\n        } else { \n            fosterParent = stack.get(0);\n        }\n\n        if (isLastTableParent) {\n            Validate.notNull(lastTable); \n            lastTable.before(in);\n        }\n        else\n            fosterParent.appendChild(in);\n    }\n\n    @Override\n    public String toString() {\n        return \"TreeBuilder{\" +\n                \"currentToken=\" + currentToken +\n                \", state=\" + state +\n                \", currentElement=\" + currentElement() +\n                '}';\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Comment;\nimport org.jsoup.nodes.DataNode;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.FormElement;\nimport org.jsoup.nodes.Node;\nimport org.jsoup.nodes.TextNode;\nimport org.jsoup.select.Elements;\n\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\n\npublic class HtmlTreeBuilder extends TreeBuilder { private static final String[] TagsSearchInScope = new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"}; private static final String[] TagSearchList = new String[]{\"ol\", \"ul\"}; private static final String[] TagSearchButton = new String[]{\"button\"}; private static final String[] TagSearchTableScope = new String[]{\"html\", \"table\"}; private static final String[] TagSearchSelectScope = new String[]{\"optgroup\", \"option\"}; private static final String[] TagSearchEndTags = new String[]{\"dd\", \"dt\", \"li\", \"option\", \"optgroup\", \"p\", \"rp\", \"rt\"}; private static final String[] TagSearchSpecial = new String[]{\"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\", \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"command\", \"dd\", \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\", \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"marquee\", \"menu\", \"meta\", \"nav\", \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\", \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\"}; private HtmlTreeBuilderState state; private HtmlTreeBuilderState originalState; private boolean baseUriSetFromDoc; private Element headElement; private FormElement formElement; private Element contextElement; private ArrayList<Element> formattingElements; private List<String> pendingTableCharacters; private Token.EndTag emptyEnd; private boolean framesetOk; private boolean fosterInserts; private boolean fragmentParsing; HtmlTreeBuilder() {}\n\n    ParseSettings defaultSettings() {\n        return ParseSettings.htmlDefault;\n    }\n\n    @Override\n    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        super.initialiseParse(input, baseUri, errors, settings);\n\n        \n        state = HtmlTreeBuilderState.Initial;\n        originalState = null;\n        baseUriSetFromDoc = false;\n        headElement = null;\n        formElement = null;\n        contextElement = null;\n        formattingElements = new ArrayList<>();\n        pendingTableCharacters = new ArrayList<>();\n        emptyEnd = new Token.EndTag();\n        framesetOk = true;\n        fosterInserts = false;\n        fragmentParsing = false;\n    }\n\n    List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        \n        state = HtmlTreeBuilderState.Initial;\n        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n        contextElement = context;\n        fragmentParsing = true;\n        Element root = null;\n\n        if (context != null) {\n            if (context.ownerDocument() != null) \n                doc.quirksMode(context.ownerDocument().quirksMode());\n\n            \n            String contextTag = context.tagName();\n            if (StringUtil.in(contextTag, \"title\", \"textarea\"))\n                tokeniser.transition(TokeniserState.Rcdata);\n            else if (StringUtil.in(contextTag, \"iframe\", \"noembed\", \"noframes\", \"style\", \"xmp\"))\n                tokeniser.transition(TokeniserState.Rawtext);\n            else if (contextTag.equals(\"script\"))\n                tokeniser.transition(TokeniserState.ScriptData);\n            else if (contextTag.equals((\"noscript\")))\n                tokeniser.transition(TokeniserState.Data); \n            else if (contextTag.equals(\"plaintext\"))\n                tokeniser.transition(TokeniserState.Data);\n            else\n                tokeniser.transition(TokeniserState.Data); \n\n            root = new Element(Tag.valueOf(\"html\", settings), baseUri);\n            doc.appendChild(root);\n            stack.add(root);\n            resetInsertionMode();\n\n            \n            \n            Elements contextChain = context.parents();\n            contextChain.add(0, context);\n            for (Element parent: contextChain) {\n                if (parent instanceof FormElement) {\n                    formElement = (FormElement) parent;\n                    break;\n                }\n            }\n        }\n\n        runParser();\n        if (context != null)\n            return root.childNodes();\n        else\n            return doc.childNodes();\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        currentToken = token;\n        return this.state.process(token, this);\n    }\n\n    boolean process(Token token, HtmlTreeBuilderState state) {\n        currentToken = token;\n        return state.process(token, this);\n    }\n\n    void transition(HtmlTreeBuilderState state) {\n        this.state = state;\n    }\n\n    HtmlTreeBuilderState state() {\n        return state;\n    }\n\n    void markInsertionMode() {\n        originalState = state;\n    }\n\n    HtmlTreeBuilderState originalState() {\n        return originalState;\n    }\n\n    void framesetOk(boolean framesetOk) {\n        this.framesetOk = framesetOk;\n    }\n\n    boolean framesetOk() {\n        return framesetOk;\n    }\n\n    Document getDocument() {\n        return doc;\n    }\n\n    String getBaseUri() {\n        return baseUri;\n    }\n\n    void maybeSetBaseUri(Element base) {\n        if (baseUriSetFromDoc) \n            return;\n\n        String href = base.absUrl(\"href\");\n        if (href.length() != 0) { \n            baseUri = href;\n            baseUriSetFromDoc = true;\n            doc.setBaseUri(href); \n        }\n    }\n\n    boolean isFragmentParsing() {\n        return fragmentParsing;\n    }\n\n    void error(HtmlTreeBuilderState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }\n\n    Element insert(Token.StartTag startTag) {\n        \n        \n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.transition(TokeniserState.Data); \n            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  \n            return el;\n        }\n        \n        Element el = new Element(Tag.valueOf(startTag.name(), settings), baseUri, settings.normalizeAttributes(startTag.attributes));\n        insert(el);\n        return el;\n    }\n\n    Element insertStartTag(String startTagName) {\n        Element el = new Element(Tag.valueOf(startTagName, settings), baseUri);\n        insert(el);\n        return el;\n    }\n\n    void insert(Element el) {\n        insertNode(el);\n        stack.add(el);\n    }\n\n    Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (tag.isKnownTag()) {\n                if (!tag.isEmpty())\n                    tokeniser.error(\"Tag cannot be self closing; not a void tag\");\n            }\n            else \n                tag.setSelfClosing();\n        }\n        return el;\n    }\n\n    FormElement insertForm(Token.StartTag startTag, boolean onStack) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        FormElement el = new FormElement(tag, baseUri, startTag.attributes);\n        setFormElement(el);\n        insertNode(el);\n        if (onStack)\n            stack.add(el);\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData(), baseUri);\n        insertNode(comment);\n    }\n\n    void insert(Token.Character characterToken) {\n        Node node;\n        \n        String tagName = currentElement().tagName();\n        if (tagName.equals(\"script\") || tagName.equals(\"style\"))\n            node = new DataNode(characterToken.getData(), baseUri);\n        else\n            node = new TextNode(characterToken.getData(), baseUri);\n        currentElement().appendChild(node); \n    }\n\n    private void insertNode(Node node) {\n        \n        if (stack.size() == 0)\n            doc.appendChild(node);\n        else if (isFosterInserts())\n            insertInFosterParent(node);\n        else\n            currentElement().appendChild(node);\n\n        \n        if (node instanceof Element && ((Element) node).tag().isFormListed()) {\n            if (formElement != null)\n                formElement.addElement((Element) node);\n        }\n    }\n\n    Element pop() {\n        int size = stack.size();\n        return stack.remove(size-1);\n    }\n\n    void push(Element element) {\n        stack.add(element);\n    }\n\n    ArrayList<Element> getStack() {\n        return stack;\n    }\n\n    boolean onStack(Element el) {\n        return isElementInQueue(stack, el);\n    }\n\n    private boolean isElementInQueue(ArrayList<Element> queue, Element element) {\n        for (int pos = queue.size() -1; pos >= 0; pos--) {\n            Element next = queue.get(pos);\n            if (next == element) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    Element getFromStack(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                return next;\n            }\n        }\n        return null;\n    }\n\n    boolean removeFromStack(Element el) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                stack.remove(pos);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    void popStackToClose(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next.nodeName().equals(elName))\n                break;\n        }\n    }\n\n    void popStackToClose(String... elNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (StringUtil.in(next.nodeName(), elNames))\n                break;\n        }\n    }\n\n    void popStackToBefore(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                break;\n            } else {\n                stack.remove(pos);\n            }\n        }\n    }\n\n    void clearStackToTableContext() {\n        clearStackToContext(\"table\");\n    }\n\n    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n    }\n\n    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\");\n    }\n\n    private void clearStackToContext(String... nodeNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n                break;\n            else\n                stack.remove(pos);\n        }\n    }\n\n    Element aboveOnStack(Element el) {\n        assert onStack(el);\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                return stack.get(pos-1);\n            }\n        }\n        return null;\n    }\n\n    void insertOnStackAfter(Element after, Element in) {\n        int i = stack.lastIndexOf(after);\n        Validate.isTrue(i != -1);\n        stack.add(i+1, in);\n    }\n\n    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }\n\n    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.set(i, in);\n    }\n\n    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; \n            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; \n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; \n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; \n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; \n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; \n            }\n        }\n    }\n\n    \n    private String[] specificScopeTarget = {null}; private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        specificScopeTarget[0] = targetName;\n        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.nodeName();\n            if (StringUtil.in(elName, targetNames))\n                return true;\n            if (StringUtil.in(elName, baseTypes))\n                return false;\n            if (extraTypes != null && StringUtil.in(elName, extraTypes))\n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }\n\n    boolean inScope(String[] targetNames) {\n        return inSpecificScope(targetNames, TagsSearchInScope, null);\n    }\n\n    boolean inScope(String targetName) {\n        return inScope(targetName, null);\n    }\n\n    boolean inScope(String targetName, String[] extras) {\n        return inSpecificScope(targetName, TagsSearchInScope, extras);\n        \n        \n    }\n\n    boolean inListItemScope(String targetName) {\n        return inScope(targetName, TagSearchList);\n    }\n\n    boolean inButtonScope(String targetName) {\n        return inScope(targetName, TagSearchButton);\n    }\n\n    boolean inTableScope(String targetName) {\n        return inSpecificScope(targetName, TagSearchTableScope, null);\n    }\n\n    boolean inSelectScope(String targetName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.nodeName();\n            if (elName.equals(targetName))\n                return true;\n            if (!StringUtil.in(elName, TagSearchSelectScope)) \n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }\n\n    void setHeadElement(Element headElement) {\n        this.headElement = headElement;\n    }\n\n    Element getHeadElement() {\n        return headElement;\n    }\n\n    boolean isFosterInserts() {\n        return fosterInserts;\n    }\n\n    void setFosterInserts(boolean fosterInserts) {\n        this.fosterInserts = fosterInserts;\n    }\n\n    FormElement getFormElement() {\n        return formElement;\n    }\n\n    void setFormElement(FormElement formElement) {\n        this.formElement = formElement;\n    }\n\n    void newPendingTableCharacters() {\n        pendingTableCharacters = new ArrayList<>();\n    }\n\n    List<String> getPendingTableCharacters() {\n        return pendingTableCharacters;\n    }\n\n    void setPendingTableCharacters(List<String> pendingTableCharacters) {\n        this.pendingTableCharacters = pendingTableCharacters;\n    }\n\n    \n    void generateImpliedEndTags(String excludeTag) {\n        while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\n                StringUtil.in(currentElement().nodeName(), TagSearchEndTags))\n            pop();\n    }\n\n    void generateImpliedEndTags() {\n        generateImpliedEndTags(null);\n    }\n\n    boolean isSpecial(Element el) {\n        \n        \n        String name = el.nodeName();\n        return StringUtil.in(name, TagSearchSpecial);\n    }\n\n    Element lastFormattingElement() {\n        return formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;\n    }\n\n    Element removeLastFormattingElement() {\n        int size = formattingElements.size();\n        if (size > 0)\n            return formattingElements.remove(size-1);\n        else\n            return null;\n    }\n\n    \n    void pushActiveFormattingElements(Element in) {\n        int numSeen = 0;\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element el = formattingElements.get(pos);\n            if (el == null) \n                break;\n\n            if (isSameFormattingElement(in, el))\n                numSeen++;\n\n            if (numSeen == 3) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n        formattingElements.add(in);\n    }\n\n    private boolean isSameFormattingElement(Element a, Element b) {\n        \n        return a.nodeName().equals(b.nodeName()) &&\n                \n                a.attributes().equals(b.attributes());\n        \n    }\n\n    void reconstructFormattingElements() {\n        Element last = lastFormattingElement();\n        if (last == null || onStack(last))\n            return;\n\n        Element entry = last;\n        int size = formattingElements.size();\n        int pos = size - 1;\n        boolean skip = false;\n        while (true) {\n            if (pos == 0) { \n                skip = true;\n                break;\n            }\n            entry = formattingElements.get(--pos); \n            if (entry == null || onStack(entry)) \n                break; \n        }\n        while(true) {\n            if (!skip) \n                entry = formattingElements.get(++pos);\n            Validate.notNull(entry); \n\n            \n            skip = false; \n            Element newEl = insertStartTag(entry.nodeName()); \n            \n            newEl.attributes().addAll(entry.attributes());\n\n            \n            formattingElements.set(pos, newEl);\n\n            \n            if (pos == size-1) \n                break;\n        }\n    }\n\n    void clearFormattingElementsToLastMarker() {\n        while (!formattingElements.isEmpty()) {\n            Element el = removeLastFormattingElement();\n            if (el == null)\n                break;\n        }\n    }\n\n    void removeFromActiveFormattingElements(Element el) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == el) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n    }\n\n    boolean isInActiveFormattingElements(Element el) {\n        return isElementInQueue(formattingElements, el);\n    }\n\n    Element getActiveFormattingElement(String nodeName) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == null) \n                break;\n            else if (next.nodeName().equals(nodeName))\n                return next;\n        }\n        return null;\n    }\n\n    void replaceActiveFormattingElement(Element out, Element in) {\n        replaceInQueue(formattingElements, out, in);\n    }\n\n    void insertMarkerToFormattingElements() {\n        formattingElements.add(null);\n    }\n\n    void insertInFosterParent(Node in) {\n        Element fosterParent;\n        Element lastTable = getFromStack(\"table\");\n        boolean isLastTableParent = false;\n        if (lastTable != null) {\n            if (lastTable.parent() != null) {\n                fosterParent = lastTable.parent();\n                isLastTableParent = true;\n            } else\n                fosterParent = aboveOnStack(lastTable);\n        } else { \n            fosterParent = stack.get(0);\n        }\n\n        if (isLastTableParent) {\n            Validate.notNull(lastTable); \n            lastTable.before(in);\n        }\n        else\n            fosterParent.appendChild(in);\n    }\n\n    @Override\n    public String toString() {\n        return \"TreeBuilder{\" +\n                \"currentToken=\" + currentToken +\n                \", state=\" + state +\n                \", currentElement=\" + currentElement() +\n                '}';\n    }\n}\n",
      "buggy_signatures": [
        "protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings)",
        "protected boolean process(Token token)",
        "private void insertNode(Node node)",
        "private boolean isElementInQueue(ArrayList<Element> queue, Element element)",
        "private void clearStackToContext(String... nodeNames)",
        "private void replaceInQueue(ArrayList<Element> queue, Element out, Element in)",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes)",
        "private boolean isSameFormattingElement(Element a, Element b)",
        "public String toString()"
      ],
      "fixed_signatures": [
        "protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings)",
        "protected boolean process(Token token)",
        "private void insertNode(Node node)",
        "private boolean isElementInQueue(ArrayList<Element> queue, Element element)",
        "private void clearStackToContext(String... nodeNames)",
        "private void replaceInQueue(ArrayList<Element> queue, Element out, Element in)",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes)",
        "private boolean isSameFormattingElement(Element a, Element b)",
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "  protected boolean process(Token token) {\n  currentToken = token;\n  return this.state.process(token, this);\n  }",
          "fixed_method": "  protected boolean process(Token token) {\n  currentToken = token;\n  return this.state.process(token, this);\n  }",
          "diff": [
            "@@ -224,12 +224,11 @@",
            "         insertNode(el);\n",
            "         if (startTag.isSelfClosing()) {\n",
            "             if (tag.isKnownTag()) {\n",
            "-                if (tag.isSelfClosing()) tokeniser.acknowledgeSelfClosingFlag();\n",
            "-            }\n",
            "-            else {\n",
            "+                if (!tag.isEmpty())\n",
            "+                    tokeniser.error(\"Tag cannot be self closing; not a void tag\");\n",
            "+            }\n",
            "+            else // unknown tag, remember this is self closing for output\n",
            "                 tag.setSelfClosing();\n",
            "-                tokeniser.acknowledgeSelfClosingFlag();\n",
            "-            }\n",
            "         }\n",
            "         return el;\n",
            "     }\n"
          ],
          "changed_lines": 9
        }
      ]
    },
    {
      "name": "org/jsoup/parser/Tokeniser.java",
      "buggy_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Entities;\n\nimport java.util.Arrays;\n\n\nfinal class Tokeniser {\n    static final char replacementChar = '\\uFFFD'; private static final char[] notCharRefCharsSorted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '<', '&'}; static { Arrays.sort(notCharRefCharsSorted); } private final CharacterReader reader; private final ParseErrorList errors; private TokeniserState state = TokeniserState.Data; private Token emitPending; private boolean isEmitPending = false; private String charsString = null; private StringBuilder charsBuilder = new StringBuilder(1024); StringBuilder dataBuffer = new StringBuilder(1024); Token.Tag tagPending; Token.StartTag startPending = new Token.StartTag(); Token.EndTag endPending = new Token.EndTag(); Token.Character charPending = new Token.Character(); Token.Doctype doctypePending = new Token.Doctype(); Token.Comment commentPending = new Token.Comment(); private String lastStartTag; private boolean selfClosingFlagAcknowledged = true; Tokeniser(CharacterReader reader, ParseErrorList errors) {\n        this.reader = reader;\n        this.errors = errors;\n    }\n\n    Token read() {\n        if (!selfClosingFlagAcknowledged) {\n            error(\"Self closing flag not acknowledged\");\n            selfClosingFlagAcknowledged = true;\n        }\n        while (!isEmitPending)\n            state.read(this, reader);\n\n        \n        if (charsBuilder.length() > 0) {\n            String str = charsBuilder.toString();\n            charsBuilder.delete(0, charsBuilder.length());\n            charsString = null;\n            return charPending.data(str);\n        } else if (charsString != null) {\n            Token token = charPending.data(charsString);\n            charsString = null;\n            return token;\n        } else {\n            isEmitPending = false;\n            return emitPending;\n        }\n    }\n\n    void emit(Token token) {\n        Validate.isFalse(isEmitPending, \"There is an unread token pending!\");\n\n        emitPending = token;\n        isEmitPending = true;\n\n        if (token.type == Token.TokenType.StartTag) {\n            Token.StartTag startTag = (Token.StartTag) token;\n            lastStartTag = startTag.tagName;\n            if (startTag.selfClosing)\n                selfClosingFlagAcknowledged = false;\n        } else if (token.type == Token.TokenType.EndTag) {\n            Token.EndTag endTag = (Token.EndTag) token;\n            if (endTag.attributes != null)\n                error(\"Attributes incorrectly present on end tag\");\n        }\n    }\n\n    void emit(final String str) {\n        \n        \n        if (charsString == null) {\n            charsString = str;\n        }\n        else {\n            if (charsBuilder.length() == 0) { \n                charsBuilder.append(charsString);\n            }\n            charsBuilder.append(str);\n        }\n    }\n\n    void emit(char[] chars) {\n        emit(String.valueOf(chars));\n    }\n\n    void emit(int[] codepoints) {\n        emit(new String(codepoints, 0, codepoints.length));\n    }\n\n    void emit(char c) {\n        emit(String.valueOf(c));\n    }\n\n    TokeniserState getState() {\n        return state;\n    }\n\n    void transition(TokeniserState state) {\n        this.state = state;\n    }\n\n    void advanceTransition(TokeniserState state) {\n        reader.advance();\n        this.state = state;\n    }\n\n    void acknowledgeSelfClosingFlag() {\n        selfClosingFlagAcknowledged = true;\n    }\n    final private int[] codepointHolder = new int[1]; final private int[] multipointHolder = new int[2]; int[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n        if (reader.isEmpty())\n            return null;\n        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n            return null;\n        if (reader.matchesAnySorted(notCharRefCharsSorted))\n            return null;\n\n        final int[] codeRef = codepointHolder;\n        reader.mark();\n        if (reader.matchConsume(\"#\")) { \n            boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n            if (numRef.length() == 0) { \n                characterReferenceError(\"numeric reference with no numerals\");\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(\"missing semicolon\"); \n            int charval = -1;\n            try {\n                int base = isHexMode ? 16 : 10;\n                charval = Integer.valueOf(numRef, base);\n            } catch (NumberFormatException ignored) {\n            } \n            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                characterReferenceError(\"character outside of valid range\");\n                codeRef[0] = replacementChar;\n                return codeRef;\n            } else {\n                \n                \n                codeRef[0] = charval;\n                return codeRef;\n            }\n        } else { \n            \n            String nameRef = reader.consumeLetterThenDigitSequence();\n            boolean looksLegit = reader.matches(';');\n            \n            boolean found = (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) && looksLegit));\n\n            if (!found) {\n                reader.rewindToMark();\n                if (looksLegit) \n                    characterReferenceError(String.format(\"invalid named referenece '%s'\", nameRef));\n                return null;\n            }\n            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n                \n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(\"missing semicolon\"); \n            int numChars = Entities.codepointsForName(nameRef, multipointHolder);\n            if (numChars == 1) {\n                codeRef[0] = multipointHolder[0];\n                return codeRef;\n            } else if (numChars ==2) {\n                return multipointHolder;\n            } else {\n                Validate.fail(\"Unexpected characters returned for \" + nameRef);\n                return multipointHolder;\n            }\n        }\n    }\n\n    Token.Tag createTagPending(boolean start) {\n        tagPending = start ? startPending.reset() : endPending.reset();\n        return tagPending;\n    }\n\n    void emitTagPending() {\n        tagPending.finaliseTag();\n        emit(tagPending);\n    }\n\n    void createCommentPending() {\n        commentPending.reset();\n    }\n\n    void emitCommentPending() {\n        emit(commentPending);\n    }\n\n    void createDoctypePending() {\n        doctypePending.reset();\n    }\n\n    void emitDoctypePending() {\n        emit(doctypePending);\n    }\n\n    void createTempBuffer() {\n        Token.reset(dataBuffer);\n    }\n\n    boolean isAppropriateEndTagToken() {\n        return lastStartTag != null && tagPending.name().equalsIgnoreCase(lastStartTag);\n    }\n\n    String appropriateEndTagName() {\n        if (lastStartTag == null)\n            return null;\n        return lastStartTag;\n    }\n\n    void error(TokeniserState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected character '%s' in input state [%s]\", reader.current(), state));\n    }\n\n    void eofError(TokeniserState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpectedly reached end of file (EOF) in input state [%s]\", state));\n    }\n\n    private void characterReferenceError(String message) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Invalid character reference: %s\", message));\n    }\n\n    void error(String errorMsg) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), errorMsg));\n    }\n\n    boolean currentNodeInHtmlNS() {\n        \n        return true;\n        \n        \n    }\n\n    \n    String unescapeEntities(boolean inAttribute) {\n        StringBuilder builder = new StringBuilder();\n        while (!reader.isEmpty()) {\n            builder.append(reader.consumeTo('&'));\n            if (reader.matches('&')) {\n                reader.consume();\n                int[] c = consumeCharacterReference(null, inAttribute);\n                if (c == null || c.length==0)\n                    builder.append('&');\n                else {\n                    builder.appendCodePoint(c[0]);\n                    if (c.length == 2)\n                        builder.appendCodePoint(c[1]);\n                }\n\n            }\n        }\n        return builder.toString();\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Entities;\n\nimport java.util.Arrays;\n\n\nfinal class Tokeniser {\n    static final char replacementChar = '\\uFFFD'; private static final char[] notCharRefCharsSorted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '<', '&'}; static { Arrays.sort(notCharRefCharsSorted); } private final CharacterReader reader; private final ParseErrorList errors; private TokeniserState state = TokeniserState.Data; private Token emitPending; private boolean isEmitPending = false; private String charsString = null; private StringBuilder charsBuilder = new StringBuilder(1024); StringBuilder dataBuffer = new StringBuilder(1024); Token.Tag tagPending; Token.StartTag startPending = new Token.StartTag(); Token.EndTag endPending = new Token.EndTag(); Token.Character charPending = new Token.Character(); Token.Doctype doctypePending = new Token.Doctype(); Token.Comment commentPending = new Token.Comment(); private String lastStartTag; Tokeniser(CharacterReader reader, ParseErrorList errors) {\n        this.reader = reader;\n        this.errors = errors;\n    }\n\n    Token read() {\n        while (!isEmitPending)\n            state.read(this, reader);\n\n        \n        if (charsBuilder.length() > 0) {\n            String str = charsBuilder.toString();\n            charsBuilder.delete(0, charsBuilder.length());\n            charsString = null;\n            return charPending.data(str);\n        } else if (charsString != null) {\n            Token token = charPending.data(charsString);\n            charsString = null;\n            return token;\n        } else {\n            isEmitPending = false;\n            return emitPending;\n        }\n    }\n\n    void emit(Token token) {\n        Validate.isFalse(isEmitPending, \"There is an unread token pending!\");\n\n        emitPending = token;\n        isEmitPending = true;\n\n        if (token.type == Token.TokenType.StartTag) {\n            Token.StartTag startTag = (Token.StartTag) token;\n            lastStartTag = startTag.tagName;\n        } else if (token.type == Token.TokenType.EndTag) {\n            Token.EndTag endTag = (Token.EndTag) token;\n            if (endTag.attributes != null)\n                error(\"Attributes incorrectly present on end tag\");\n        }\n    }\n\n    void emit(final String str) {\n        \n        \n        if (charsString == null) {\n            charsString = str;\n        }\n        else {\n            if (charsBuilder.length() == 0) { \n                charsBuilder.append(charsString);\n            }\n            charsBuilder.append(str);\n        }\n    }\n\n    void emit(char[] chars) {\n        emit(String.valueOf(chars));\n    }\n\n    void emit(int[] codepoints) {\n        emit(new String(codepoints, 0, codepoints.length));\n    }\n\n    void emit(char c) {\n        emit(String.valueOf(c));\n    }\n\n    TokeniserState getState() {\n        return state;\n    }\n\n    void transition(TokeniserState state) {\n        this.state = state;\n    }\n\n    void advanceTransition(TokeniserState state) {\n        reader.advance();\n        this.state = state;\n    }\n\n    final private int[] codepointHolder = new int[1]; final private int[] multipointHolder = new int[2]; int[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n        if (reader.isEmpty())\n            return null;\n        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n            return null;\n        if (reader.matchesAnySorted(notCharRefCharsSorted))\n            return null;\n\n        final int[] codeRef = codepointHolder;\n        reader.mark();\n        if (reader.matchConsume(\"#\")) { \n            boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n            if (numRef.length() == 0) { \n                characterReferenceError(\"numeric reference with no numerals\");\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(\"missing semicolon\"); \n            int charval = -1;\n            try {\n                int base = isHexMode ? 16 : 10;\n                charval = Integer.valueOf(numRef, base);\n            } catch (NumberFormatException ignored) {\n            } \n            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                characterReferenceError(\"character outside of valid range\");\n                codeRef[0] = replacementChar;\n                return codeRef;\n            } else {\n                \n                \n                codeRef[0] = charval;\n                return codeRef;\n            }\n        } else { \n            \n            String nameRef = reader.consumeLetterThenDigitSequence();\n            boolean looksLegit = reader.matches(';');\n            \n            boolean found = (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) && looksLegit));\n\n            if (!found) {\n                reader.rewindToMark();\n                if (looksLegit) \n                    characterReferenceError(String.format(\"invalid named referenece '%s'\", nameRef));\n                return null;\n            }\n            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n                \n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(\"missing semicolon\"); \n            int numChars = Entities.codepointsForName(nameRef, multipointHolder);\n            if (numChars == 1) {\n                codeRef[0] = multipointHolder[0];\n                return codeRef;\n            } else if (numChars ==2) {\n                return multipointHolder;\n            } else {\n                Validate.fail(\"Unexpected characters returned for \" + nameRef);\n                return multipointHolder;\n            }\n        }\n    }\n\n    Token.Tag createTagPending(boolean start) {\n        tagPending = start ? startPending.reset() : endPending.reset();\n        return tagPending;\n    }\n\n    void emitTagPending() {\n        tagPending.finaliseTag();\n        emit(tagPending);\n    }\n\n    void createCommentPending() {\n        commentPending.reset();\n    }\n\n    void emitCommentPending() {\n        emit(commentPending);\n    }\n\n    void createDoctypePending() {\n        doctypePending.reset();\n    }\n\n    void emitDoctypePending() {\n        emit(doctypePending);\n    }\n\n    void createTempBuffer() {\n        Token.reset(dataBuffer);\n    }\n\n    boolean isAppropriateEndTagToken() {\n        return lastStartTag != null && tagPending.name().equalsIgnoreCase(lastStartTag);\n    }\n\n    String appropriateEndTagName() {\n        if (lastStartTag == null)\n            return null;\n        return lastStartTag;\n    }\n\n    void error(TokeniserState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected character '%s' in input state [%s]\", reader.current(), state));\n    }\n\n    void eofError(TokeniserState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpectedly reached end of file (EOF) in input state [%s]\", state));\n    }\n\n    private void characterReferenceError(String message) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Invalid character reference: %s\", message));\n    }\n\n    void error(String errorMsg) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), errorMsg));\n    }\n\n    boolean currentNodeInHtmlNS() {\n        \n        return true;\n        \n        \n    }\n\n    \n    String unescapeEntities(boolean inAttribute) {\n        StringBuilder builder = new StringBuilder();\n        while (!reader.isEmpty()) {\n            builder.append(reader.consumeTo('&'));\n            if (reader.matches('&')) {\n                reader.consume();\n                int[] c = consumeCharacterReference(null, inAttribute);\n                if (c == null || c.length==0)\n                    builder.append('&');\n                else {\n                    builder.appendCodePoint(c[0]);\n                    if (c.length == 2)\n                        builder.appendCodePoint(c[1]);\n                }\n\n            }\n        }\n        return builder.toString();\n    }\n}\n",
      "buggy_signatures": [
        "private void characterReferenceError(String message)"
      ],
      "fixed_signatures": [
        "private void characterReferenceError(String message)"
      ],
      "methods": [
        {
          "buggy_method": "  private StringBuilder charsBuilder = new StringBuilder(1024); StringBuilder dataBuffer = new StringBuilder(1024); Token.Tag tagPending; Token.StartTag startPending = new Token.StartTag(); Token.EndTag endPending = new Token.EndTag(); Token.Character charPending = new Token.Character(); Token.Doctype doctypePending = new Token.Doctype(); Token.Comment commentPending = new Token.Comment(); private String lastStartTag; private boolean selfClosingFlagAcknowledged = true; Tokeniser(CharacterReader reader, ParseErrorList errors) {\n  this.reader = reader;\n  this.errors = errors;\n  }",
          "fixed_method": "  private StringBuilder charsBuilder = new StringBuilder(1024); StringBuilder dataBuffer = new StringBuilder(1024); Token.Tag tagPending; Token.StartTag startPending = new Token.StartTag(); Token.EndTag endPending = new Token.EndTag(); Token.Character charPending = new Token.Character(); Token.Doctype doctypePending = new Token.Doctype(); Token.Comment commentPending = new Token.Comment(); private String lastStartTag; Tokeniser(CharacterReader reader, ParseErrorList errors) {\n  this.reader = reader;\n  this.errors = errors;\n  }",
          "diff": [
            "@@ -33,7 +33,6 @@",
            "     Token.Doctype doctypePending = new Token.Doctype(); // doctype building up\n",
            "     Token.Comment commentPending = new Token.Comment(); // comment building up\n",
            "     private String lastStartTag; // the last start tag emitted, to test appropriate end tag\n",
            "-    private boolean selfClosingFlagAcknowledged = true;\n",
            " \n",
            "     Tokeniser(CharacterReader reader, ParseErrorList errors) {\n",
            "         this.reader = reader;\n",
            "@@ -41,10 +40,6 @@",
            "     }\n",
            " \n",
            "     Token read() {\n",
            "-        if (!selfClosingFlagAcknowledged) {\n",
            "-            error(\"Self closing flag not acknowledged\");\n",
            "-            selfClosingFlagAcknowledged = true;\n",
            "-        }\n",
            "         while (!isEmitPending)\n",
            "             state.read(this, reader);\n",
            " \n",
            "@@ -73,8 +68,6 @@",
            "         if (token.type == Token.TokenType.StartTag) {\n",
            "             Token.StartTag startTag = (Token.StartTag) token;\n",
            "             lastStartTag = startTag.tagName;\n",
            "-            if (startTag.selfClosing)\n",
            "-                selfClosingFlagAcknowledged = false;\n",
            "         } else if (token.type == Token.TokenType.EndTag) {\n",
            "             Token.EndTag endTag = (Token.EndTag) token;\n",
            "             if (endTag.attributes != null)\n",
            "@@ -121,9 +114,6 @@",
            "         this.state = state;\n",
            "     }\n",
            " \n",
            "-    void acknowledgeSelfClosingFlag() {\n",
            "-        selfClosingFlagAcknowledged = true;\n",
            "-    }\n",
            "     final private int[] codepointHolder = new int[1]; // holder to not have to keep creating arrays\n",
            "     final private int[] multipointHolder = new int[2];\n",
            "     int[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n"
          ],
          "changed_lines": 10
        }
      ]
    }
  ]
}
