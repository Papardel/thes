{
  "bug_id": "9",
  "failed_tests": {
    "org.apache.commons.cli.OptionsTest": [
      {
        "methodName": "testMissingOptionsException",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<... required options: f[, ]x> but was:<... required options: f[]x>",
        "fail_line": "            assertEquals(\"Missing required options: f, x\", e.getMessage());",
        "test_source": "  public void testMissingOptionsException() throws ParseException {\n  Options options = new Options();\n  options.addOption(OptionBuilder.isRequired().create(\"f\"));\n  options.addOption(OptionBuilder.isRequired().create(\"x\"));\n  try {\n  new PosixParser().parse(options, new String[0]);\n  fail(\"Expected MissingOptionException to be thrown\");\n  } catch (MissingOptionException e) {\n  assertEquals(\"Missing required options: f, x\", e.getMessage());\n  }\n  }",
        "stack": [
          "OptionsTest.testMissingOptionsException line 116"
        ]
      }
    ],
    "org.apache.commons.cli.ParseRequiredTest": [
      {
        "methodName": "testMissingRequiredOptions",
        "error": "junit.framework.ComparisonFailure",
        "message": "Incorrect exception message expected:<... required options: b[, ]c> but was:<... required options: b[]c>",
        "fail_line": "            assertEquals( \"Incorrect exception message\", \"Missing required options: b, c\", e.getMessage() );",
        "test_source": "  public void testMissingRequiredOptions() {\n  String[] args = new String[] { \"-a\" };\n\n  _options.addOption( OptionBuilder.withLongOpt( \"cfile\" )\n  .hasArg()\n  .isRequired()\n  .withDescription( \"set the value of [c]\" )\n  .create( 'c' ) );\n\n  try\n  {\n  CommandLine cl = parser.parse(_options,args);\n  fail( \"exception should have been thrown\" );\n  }\n  catch (MissingOptionException e)\n  {\n  assertEquals( \"Incorrect exception message\", \"Missing required options: b, c\", e.getMessage() );\n  }\n  catch (ParseException e)\n  {\n  fail( \"expected to catch MissingOptionException\" );\n  }\n  }",
        "stack": [
          "ParseRequiredTest.testMissingRequiredOptions line 135"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/cli/Parser.java",
      "buggy_full_code": "\npackage org.apache.commons.cli;\n\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Properties;\n\n\npublic abstract class Parser implements CommandLineParser { protected CommandLine cmd; private Options options; private List requiredOptions; protected void setOptions(final Options options) {\n        this.options = options;\n        this.requiredOptions = options.getRequiredOptions();\n    }\n\n    protected Options getOptions() {\n        return options;\n    }\n\n    protected List getRequiredOptions() {\n        return requiredOptions;\n    }\n\n\n    \n    protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption); public CommandLine parse(Options options, String[] arguments) throws ParseException {\n        return parse(options, arguments, null, false);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException {\n        return parse(options, arguments, properties, false);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException {\n        \n        for (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\n            Option opt = (Option) it.next();\n            opt.clearValues();\n        }\n\n        \n        setOptions(options);\n\n        cmd = new CommandLine();\n\n        boolean eatTheRest = false;\n\n        if (arguments == null)\n        {\n            arguments = new String[0];\n        }\n\n        List tokenList = Arrays.asList(flatten(getOptions(), \n                                               arguments, \n                                               stopAtNonOption));\n\n        ListIterator iterator = tokenList.listIterator();\n\n        \n        while (iterator.hasNext())\n        {\n            String t = (String) iterator.next();\n\n            \n            if (\"--\".equals(t))\n            {\n                eatTheRest = true;\n            }\n\n            \n            else if (\"-\".equals(t))\n            {\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n                else\n                {\n                    cmd.addArg(t);\n                }\n            }\n\n            \n            else if (t.startsWith(\"-\"))\n            {\n                if (stopAtNonOption && !getOptions().hasOption(t))\n                {\n                    eatTheRest = true;\n                    cmd.addArg(t);\n                }\n                else\n                {\n                    processOption(t, iterator);\n                }\n            }\n\n            \n            else\n            {\n                cmd.addArg(t);\n\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n            }\n\n            \n            if (eatTheRest)\n            {\n                while (iterator.hasNext())\n                {\n                    String str = (String) iterator.next();\n\n                    \n                    if (!\"--\".equals(str))\n                    {\n                        cmd.addArg(str);\n                    }\n                }\n            }\n        }\n\n        processProperties(properties);\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    \n    protected void processProperties(Properties properties) {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            if (!cmd.hasOption(option))\n            {\n                Option opt = getOptions().getOption(option);\n\n                \n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if ((opt.getValues() == null)\n                        || (opt.getValues().length == 0))\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            \n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value) \n                           || \"true\".equalsIgnoreCase(value)\n                           || \"1\".equalsIgnoreCase(value)))\n                {\n                    \n                    \n                    break;\n                }\n\n                cmd.addOption(opt);\n            }\n        }\n    }\n\n    \n    protected void checkRequiredOptions() throws MissingOptionException {\n        \n        \n        if (getRequiredOptions().size() > 0)\n        {\n            Iterator iter = getRequiredOptions().iterator();\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n\n\n            \n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n            }\n\n            throw new MissingOptionException(buff.toString());\n        }\n    }\n\n    \n    public void processArgs(Option opt, ListIterator iter) throws ParseException {\n        \n        while (iter.hasNext())\n        {\n            String str = (String) iter.next();\n\n            \n            if (getOptions().hasOption(str) && str.startsWith(\"-\"))\n            {\n                iter.previous();\n                break;\n            }\n\n            \n            try\n            {\n                opt.addValueForProcessing( Util.stripLeadingAndTrailingQuotes(str) );\n            }\n            catch (RuntimeException exp)\n            {\n                iter.previous();\n                break;\n            }\n        }\n\n        if ((opt.getValues() == null) && !opt.hasOptionalArg())\n        {\n            throw new MissingArgumentException(\"Missing argument for option:\"\n                                               + opt.getKey());\n        }\n    }\n\n    \n    protected void processOption(String arg, ListIterator iter) throws ParseException {\n        boolean hasOption = getOptions().hasOption(arg);\n\n        \n        if (!hasOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" \n                                                  + arg);\n        }\n        \n        \n        final Option opt = getOptions().getOption(arg);\n\n        \n        \n        if (opt.isRequired())\n        {\n            getRequiredOptions().remove(opt.getKey());\n        }\n\n        \n        \n        if (getOptions().getOptionGroup(opt) != null)\n        {\n            OptionGroup group = getOptions().getOptionGroup(opt);\n\n            if (group.isRequired())\n            {\n                getRequiredOptions().remove(group);\n            }\n\n            group.setSelected(opt);\n        }\n\n        \n        if (opt.hasArg())\n        {\n            processArgs(opt, iter);\n        }\n\n\n        \n        cmd.addOption(opt);\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.cli;\n\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Properties;\n\n\npublic abstract class Parser implements CommandLineParser { protected CommandLine cmd; private Options options; private List requiredOptions; protected void setOptions(final Options options) {\n        this.options = options;\n        this.requiredOptions = options.getRequiredOptions();\n    }\n\n    protected Options getOptions() {\n        return options;\n    }\n\n    protected List getRequiredOptions() {\n        return requiredOptions;\n    }\n\n\n    \n    protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption); public CommandLine parse(Options options, String[] arguments) throws ParseException {\n        return parse(options, arguments, null, false);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException {\n        return parse(options, arguments, properties, false);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException {\n        \n        for (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\n            Option opt = (Option) it.next();\n            opt.clearValues();\n        }\n\n        \n        setOptions(options);\n\n        cmd = new CommandLine();\n\n        boolean eatTheRest = false;\n\n        if (arguments == null)\n        {\n            arguments = new String[0];\n        }\n\n        List tokenList = Arrays.asList(flatten(getOptions(), \n                                               arguments, \n                                               stopAtNonOption));\n\n        ListIterator iterator = tokenList.listIterator();\n\n        \n        while (iterator.hasNext())\n        {\n            String t = (String) iterator.next();\n\n            \n            if (\"--\".equals(t))\n            {\n                eatTheRest = true;\n            }\n\n            \n            else if (\"-\".equals(t))\n            {\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n                else\n                {\n                    cmd.addArg(t);\n                }\n            }\n\n            \n            else if (t.startsWith(\"-\"))\n            {\n                if (stopAtNonOption && !getOptions().hasOption(t))\n                {\n                    eatTheRest = true;\n                    cmd.addArg(t);\n                }\n                else\n                {\n                    processOption(t, iterator);\n                }\n            }\n\n            \n            else\n            {\n                cmd.addArg(t);\n\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n            }\n\n            \n            if (eatTheRest)\n            {\n                while (iterator.hasNext())\n                {\n                    String str = (String) iterator.next();\n\n                    \n                    if (!\"--\".equals(str))\n                    {\n                        cmd.addArg(str);\n                    }\n                }\n            }\n        }\n\n        processProperties(properties);\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    \n    protected void processProperties(Properties properties) {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            if (!cmd.hasOption(option))\n            {\n                Option opt = getOptions().getOption(option);\n\n                \n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if ((opt.getValues() == null)\n                        || (opt.getValues().length == 0))\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            \n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value) \n                           || \"true\".equalsIgnoreCase(value)\n                           || \"1\".equalsIgnoreCase(value)))\n                {\n                    \n                    \n                    break;\n                }\n\n                cmd.addOption(opt);\n            }\n        }\n    }\n\n    \n    protected void checkRequiredOptions() throws MissingOptionException {\n        \n        \n        if (getRequiredOptions().size() > 0)\n        {\n            Iterator iter = getRequiredOptions().iterator();\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n\n\n            \n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n                buff.append(\", \");\n            }\n\n            throw new MissingOptionException(buff.substring(0, buff.length() - 2));\n        }\n    }\n\n    \n    public void processArgs(Option opt, ListIterator iter) throws ParseException {\n        \n        while (iter.hasNext())\n        {\n            String str = (String) iter.next();\n\n            \n            if (getOptions().hasOption(str) && str.startsWith(\"-\"))\n            {\n                iter.previous();\n                break;\n            }\n\n            \n            try\n            {\n                opt.addValueForProcessing( Util.stripLeadingAndTrailingQuotes(str) );\n            }\n            catch (RuntimeException exp)\n            {\n                iter.previous();\n                break;\n            }\n        }\n\n        if ((opt.getValues() == null) && !opt.hasOptionalArg())\n        {\n            throw new MissingArgumentException(\"Missing argument for option:\"\n                                               + opt.getKey());\n        }\n    }\n\n    \n    protected void processOption(String arg, ListIterator iter) throws ParseException {\n        boolean hasOption = getOptions().hasOption(arg);\n\n        \n        if (!hasOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" \n                                                  + arg);\n        }\n        \n        \n        final Option opt = getOptions().getOption(arg);\n\n        \n        \n        if (opt.isRequired())\n        {\n            getRequiredOptions().remove(opt.getKey());\n        }\n\n        \n        \n        if (getOptions().getOptionGroup(opt) != null)\n        {\n            OptionGroup group = getOptions().getOptionGroup(opt);\n\n            if (group.isRequired())\n            {\n                getRequiredOptions().remove(group);\n            }\n\n            group.setSelected(opt);\n        }\n\n        \n        if (opt.hasArg())\n        {\n            processArgs(opt, iter);\n        }\n\n\n        \n        cmd.addOption(opt);\n    }\n}\n",
      "buggy_signatures": [
        "public abstract class Parser implements CommandLineParser { protected CommandLine cmd; private Options options; private List requiredOptions; protected void setOptions(final Options options)",
        "protected Options getOptions()",
        "protected List getRequiredOptions()",
        "protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption); public CommandLine parse(Options options, String[] arguments) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException",
        "protected void processProperties(Properties properties)",
        "protected void checkRequiredOptions() throws MissingOptionException",
        "public void processArgs(Option opt, ListIterator iter) throws ParseException",
        "protected void processOption(String arg, ListIterator iter) throws ParseException"
      ],
      "fixed_signatures": [
        "public abstract class Parser implements CommandLineParser { protected CommandLine cmd; private Options options; private List requiredOptions; protected void setOptions(final Options options)",
        "protected Options getOptions()",
        "protected List getRequiredOptions()",
        "protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption); public CommandLine parse(Options options, String[] arguments) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException",
        "protected void processProperties(Properties properties)",
        "protected void checkRequiredOptions() throws MissingOptionException",
        "public void processArgs(Option opt, ListIterator iter) throws ParseException",
        "protected void processOption(String arg, ListIterator iter) throws ParseException"
      ],
      "methods": [
        {
          "buggy_method": "  protected void checkRequiredOptions() throws MissingOptionException {\n  \n  \n  if (getRequiredOptions().size() > 0)\n  {\n  Iterator iter = getRequiredOptions().iterator();\n  StringBuffer buff = new StringBuffer(\"Missing required option\");\n  buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n  buff.append(\": \");\n\n\n  \n  while (iter.hasNext())\n  {\n  buff.append(iter.next());\n  }\n\n  throw new MissingOptionException(buff.toString());\n  }\n  }",
          "fixed_method": "  protected void checkRequiredOptions() throws MissingOptionException {\n  \n  \n  if (getRequiredOptions().size() > 0)\n  {\n  Iterator iter = getRequiredOptions().iterator();\n  StringBuffer buff = new StringBuffer(\"Missing required option\");\n  buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n  buff.append(\": \");\n\n\n  \n  while (iter.hasNext())\n  {\n  buff.append(iter.next());\n  buff.append(\", \");\n  }\n\n  throw new MissingOptionException(buff.substring(0, buff.length() - 2));\n  }\n  }",
          "diff": [
            "@@ -317,9 +317,10 @@",
            "             while (iter.hasNext())\n",
            "             {\n",
            "                 buff.append(iter.next());\n",
            "-            }\n",
            "-\n",
            "-            throw new MissingOptionException(buff.toString());\n",
            "+                buff.append(\", \");\n",
            "+            }\n",
            "+\n",
            "+            throw new MissingOptionException(buff.substring(0, buff.length() - 2));\n",
            "         }\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 7
        }
      ]
    }
  ]
}
