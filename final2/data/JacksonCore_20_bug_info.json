{
  "bug_id": "20",
  "failed_tests": {
    "com.fasterxml.jackson.core.base64.Base64GenerationTest": [
      {
        "methodName": "testBinaryAsEmbeddedObject",
        "error": "com.fasterxml.jackson.core.JsonGenerationException",
        "message": "No native support for writing embedded objects",
        "fail_line": "        g.writeEmbeddedObject(WIKIPEDIA_BASE64_AS_BYTES);",
        "test_source": "  public void testBinaryAsEmbeddedObject() throws Exception {\n  JsonGenerator g;\n\n  StringWriter sw = new StringWriter();\n  g = JSON_F.createGenerator(sw);\n  g.writeEmbeddedObject(WIKIPEDIA_BASE64_AS_BYTES);\n  g.close();\n  assertEquals(quote(WIKIPEDIA_BASE64_ENCODED), sw.toString());\n\n  ByteArrayOutputStream bytes =  new ByteArrayOutputStream(100);\n  g = JSON_F.createGenerator(bytes);\n  g.writeEmbeddedObject(WIKIPEDIA_BASE64_AS_BYTES);\n  g.close();\n  assertEquals(quote(WIKIPEDIA_BASE64_ENCODED), bytes.toString(\"UTF-8\"));\n  }",
        "stack": [
          "JsonGenerator.writeEmbeddedObject line 1330, Base64GenerationTest.testBinaryAsEmbeddedObject line 100"
        ]
      }
    ],
    "com.fasterxml.jackson.core.main.TestGeneratorMisc": [
      {
        "methodName": "testAsEmbedded",
        "error": "com.fasterxml.jackson.core.JsonGenerationException",
        "message": "No native support for writing embedded objects",
        "fail_line": "        g.writeEmbeddedObject(null);",
        "test_source": "  public void testAsEmbedded() throws Exception {\n  JsonGenerator g;\n\n  StringWriter sw = new StringWriter();\n  g = JSON_F.createGenerator(sw);\n  g.writeEmbeddedObject(null);\n  g.close();\n  assertEquals(\"null\", sw.toString());\n\n  ByteArrayOutputStream bytes =  new ByteArrayOutputStream(100);\n  g = JSON_F.createGenerator(bytes);\n  g.writeEmbeddedObject(null);\n  g.close();\n  assertEquals(\"null\", bytes.toString(\"UTF-8\"));\n\n  // also, for fun, try illegal unknown thingy\n\n  try {\n  g = JSON_F.createGenerator(bytes);\n  // try writing a Class object\n  g.writeEmbeddedObject(getClass());\n  fail(\"Expected an exception\");\n  g.close(); // never gets here\n  } catch (JsonGenerationException e) {\n  verifyException(e, \"No native support for\");\n  }\n  }",
        "stack": [
          "JsonGenerator.writeEmbeddedObject line 1330, TestGeneratorMisc.testAsEmbedded line 243"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/core/JsonGenerator.java",
      "buggy_full_code": "\npackage com.fasterxml.jackson.core;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.atomic.AtomicLong; import com.fasterxml.jackson.core.JsonParser.NumberType; import com.fasterxml.jackson.core.io.CharacterEscapes; import com.fasterxml.jackson.core.util.VersionUtil; public abstract class JsonGenerator implements Closeable, Flushable, Versioned { public enum Feature { AUTO_CLOSE_TARGET(true), AUTO_CLOSE_JSON_CONTENT(true), FLUSH_PASSED_TO_STREAM(true), QUOTE_FIELD_NAMES(true), QUOTE_NON_NUMERIC_NUMBERS(true), WRITE_NUMBERS_AS_STRINGS(false), WRITE_BIGDECIMAL_AS_PLAIN(false), ESCAPE_NON_ASCII(false), STRICT_DUPLICATE_DETECTION(false), IGNORE_UNKNOWN(false), ; private final boolean _defaultState; private final int _mask; public static int collectDefaults() {\n            int flags = 0;\n            for (Feature f : values()) {\n                if (f.enabledByDefault()) {\n                    flags |= f.getMask();\n                }\n            }\n            return flags;\n        }\n        \n        private Feature(boolean defaultState) {\n            _defaultState = defaultState;\n            _mask = (1 << ordinal());\n        }\n\n        public boolean enabledByDefault() { return _defaultState; }\n\n        \n        public boolean enabledIn(int flags) { return (flags & _mask) != 0; }\n\n        public int getMask() { return _mask; }\n    }\n\n    \n\n    \n    protected PrettyPrinter _cfgPrettyPrinter; protected JsonGenerator() { }\n\n    \n    public abstract JsonGenerator setCodec(ObjectCodec oc); public abstract ObjectCodec getCodec(); @Override public abstract Version version(); public abstract JsonGenerator enable(Feature f); public abstract JsonGenerator disable(Feature f); public final JsonGenerator configure(Feature f, boolean state) {\n        if (state) enable(f); else disable(f);\n        return this;\n    }\n\n    \n    public abstract boolean isEnabled(Feature f); public abstract int getFeatureMask(); @Deprecated public abstract JsonGenerator setFeatureMask(int values); public JsonGenerator overrideStdFeatures(int values, int mask) {\n        int oldState = getFeatureMask();\n        int newState = (oldState & ~mask) | (values & mask);\n        return setFeatureMask(newState);\n    }\n\n    \n    public int getFormatFeatures() {\n        return 0;\n    }\n    \n    \n    public JsonGenerator overrideFormatFeatures(int values, int mask) {\n        throw new IllegalArgumentException(\"No FormatFeatures defined for generator of type \"+getClass().getName());\n        \n    }\n    \n    \n\n    \n    public void setSchema(FormatSchema schema) {\n        throw new UnsupportedOperationException(\"Generator of type \"+getClass().getName()+\" does not support schema of type '\"\n                +schema.getSchemaType()+\"'\");\n    }\n\n    \n    public FormatSchema getSchema() { return null; }\n\n    \n\n    \n    public JsonGenerator setPrettyPrinter(PrettyPrinter pp) {\n        _cfgPrettyPrinter = pp;\n        return this;\n    }\n\n    \n    public PrettyPrinter getPrettyPrinter() {\n        return _cfgPrettyPrinter;\n    }\n    \n    \n    public abstract JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setHighestNonEscapedChar(int charCode) { return this; }\n\n    \n    public int getHighestEscapedChar() { return 0; }\n\n    \n    public CharacterEscapes getCharacterEscapes() { return null; }\n\n    \n    public JsonGenerator setCharacterEscapes(CharacterEscapes esc) { return this; }\n\n    \n    public JsonGenerator setRootValueSeparator(SerializableString sep) {\n        throw new UnsupportedOperationException();\n    }\n\n    \n    \n    \n    public Object getOutputTarget() {\n        return null;\n    }\n\n    \n    public int getOutputBuffered() {\n        return -1;\n    }\n\n    \n    public Object getCurrentValue() {\n        JsonStreamContext ctxt = getOutputContext();\n        return (ctxt == null) ? null : ctxt.getCurrentValue();\n    }\n\n    \n    public void setCurrentValue(Object v) {\n        JsonStreamContext ctxt = getOutputContext();\n        if (ctxt != null) {\n            ctxt.setCurrentValue(v);\n        }\n    }\n    \n    \n\n    \n    public boolean canUseSchema(FormatSchema schema) { return false; }\n    \n    \n    public boolean canWriteObjectId() { return false; }\n\n    \n    public boolean canWriteTypeId() { return false; }\n\n    \n    public boolean canWriteBinaryNatively() { return false; }\n    \n    \n    public boolean canOmitFields() { return true; }\n\n    \n    public boolean canWriteFormattedNumbers() { return false; }\n    \n    \n\n    \n    public abstract void writeStartArray() throws IOException; public void writeStartArray(int size) throws IOException {\n        writeStartArray();\n    }\n    \n    \n    public abstract void writeEndArray() throws IOException; public abstract void writeStartObject() throws IOException; public void writeStartObject(Object forValue) throws IOException {\n        writeStartObject();\n        setCurrentValue(forValue);\n    }\n\n    \n    public abstract void writeEndObject() throws IOException; public abstract void writeFieldName(String name) throws IOException; public abstract void writeFieldName(SerializableString name) throws IOException; public void writeFieldId(long id) throws IOException {\n        writeFieldName(Long.toString(id));\n    }\n\n    \n\n    \n    public void writeArray(int[] array, int offset, int length) throws IOException {\n        if (array == null) {\n            throw new IllegalArgumentException(\"null array\");\n        }\n        _verifyOffsets(array.length, offset, length);\n        writeStartArray();\n        for (int i = offset, end = offset+length; i < end; ++i) {\n            writeNumber(array[i]);\n        }\n        writeEndArray();\n    }\n\n    \n    public void writeArray(long[] array, int offset, int length) throws IOException {\n        if (array == null) {\n            throw new IllegalArgumentException(\"null array\");\n        }\n        _verifyOffsets(array.length, offset, length);\n        writeStartArray();\n        for (int i = offset, end = offset+length; i < end; ++i) {\n            writeNumber(array[i]);\n        }\n        writeEndArray();\n    }\n\n    \n    public void writeArray(double[] array, int offset, int length) throws IOException {\n        if (array == null) {\n            throw new IllegalArgumentException(\"null array\");\n        }\n        _verifyOffsets(array.length, offset, length);\n        writeStartArray();\n        for (int i = offset, end = offset+length; i < end; ++i) {\n            writeNumber(array[i]);\n        }\n        writeEndArray();\n    }\n\n    \n\n    \n    public abstract void writeString(String text) throws IOException; public abstract void writeString(char[] text, int offset, int len) throws IOException; public abstract void writeString(SerializableString text) throws IOException; public abstract void writeRawUTF8String(byte[] text, int offset, int length) throws IOException; public abstract void writeUTF8String(byte[] text, int offset, int length) throws IOException; public abstract void writeRaw(String text) throws IOException; public abstract void writeRaw(String text, int offset, int len) throws IOException; public abstract void writeRaw(char[] text, int offset, int len) throws IOException; public abstract void writeRaw(char c) throws IOException; public void writeRaw(SerializableString raw) throws IOException {\n        writeRaw(raw.getValue());\n    }\n\n    \n    public abstract void writeRawValue(String text) throws IOException; public abstract void writeRawValue(String text, int offset, int len) throws IOException; public abstract void writeRawValue(char[] text, int offset, int len) throws IOException; public void writeRawValue(SerializableString raw) throws IOException {\n        writeRawValue(raw.getValue());\n    }\n\n    \n    public abstract void writeBinary(Base64Variant bv, byte[] data, int offset, int len) throws IOException; public void writeBinary(byte[] data, int offset, int len) throws IOException {\n        writeBinary(Base64Variants.getDefaultVariant(), data, offset, len);\n    }\n\n    \n    public void writeBinary(byte[] data) throws IOException {\n        writeBinary(Base64Variants.getDefaultVariant(), data, 0, data.length);\n    }\n\n    \n    public int writeBinary(InputStream data, int dataLength) throws IOException {\n        return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength);\n    }\n    \n    \n    public abstract int writeBinary(Base64Variant bv, InputStream data, int dataLength) throws IOException; public void writeNumber(short v) throws IOException { writeNumber((int) v); }\n\n    \n    public abstract void writeNumber(int v) throws IOException; public abstract void writeNumber(long v) throws IOException; public abstract void writeNumber(BigInteger v) throws IOException; public abstract void writeNumber(double v) throws IOException; public abstract void writeNumber(float v) throws IOException; public abstract void writeNumber(BigDecimal v) throws IOException; public abstract void writeNumber(String encodedValue) throws IOException; public abstract void writeBoolean(boolean state) throws IOException; public abstract void writeNull() throws IOException; public void writeEmbeddedObject(Object object) throws IOException {\n        \n        throw new JsonGenerationException(\"No native support for writing embedded objects\", this); } public void writeObjectId(Object id) throws IOException {\n        throw new JsonGenerationException(\"No native support for writing Object Ids\", this); } public void writeObjectRef(Object id) throws IOException {\n        throw new JsonGenerationException(\"No native support for writing Object Ids\", this); } public void writeTypeId(Object id) throws IOException {\n        throw new JsonGenerationException(\"No native support for writing Type Ids\", this); } public abstract void writeObject(Object pojo) throws IOException; public abstract void writeTree(TreeNode rootNode) throws IOException; public void writeStringField(String fieldName, String value) throws IOException {\n        writeFieldName(fieldName);\n        writeString(value);\n    }\n\n    \n    public final void writeBooleanField(String fieldName, boolean value) throws IOException {\n        writeFieldName(fieldName);\n        writeBoolean(value);\n    }\n\n    \n    public final void writeNullField(String fieldName) throws IOException {\n        writeFieldName(fieldName);\n        writeNull();\n    }\n\n    \n    public final void writeNumberField(String fieldName, int value) throws IOException {\n        writeFieldName(fieldName);\n        writeNumber(value);\n    }\n\n    \n    public final void writeNumberField(String fieldName, long value) throws IOException {\n        writeFieldName(fieldName);\n        writeNumber(value);\n    }\n\n    \n    public final void writeNumberField(String fieldName, double value) throws IOException {\n        writeFieldName(fieldName);\n        writeNumber(value);\n    }\n\n    \n    public final void writeNumberField(String fieldName, float value) throws IOException {\n        writeFieldName(fieldName);\n        writeNumber(value);\n    }\n\n    \n    public final void writeNumberField(String fieldName, BigDecimal value) throws IOException {\n        writeFieldName(fieldName);\n        writeNumber(value);\n    }\n\n    \n    public final void writeBinaryField(String fieldName, byte[] data) throws IOException {\n        writeFieldName(fieldName);\n        writeBinary(data);\n    }\n\n    \n    public final void writeArrayFieldStart(String fieldName) throws IOException {\n        writeFieldName(fieldName);\n        writeStartArray();\n    }\n\n    \n    public final void writeObjectFieldStart(String fieldName) throws IOException {\n        writeFieldName(fieldName);\n        writeStartObject();\n    }\n\n    \n    public final void writeObjectField(String fieldName, Object pojo) throws IOException {\n        writeFieldName(fieldName);\n        writeObject(pojo);\n    }\n\n    \n    public void writeOmittedField(String fieldName) throws IOException { }\n    \n    \n\n    \n    public void copyCurrentEvent(JsonParser p) throws IOException {\n        JsonToken t = p.currentToken();\n        \n        if (t == null) {\n            _reportError(\"No current event to copy\");\n        }\n        switch (t.id()) {\n        case ID_NOT_AVAILABLE:\n            _reportError(\"No current event to copy\");\n            break; \n        case ID_START_OBJECT:\n            writeStartObject();\n            break;\n        case ID_END_OBJECT:\n            writeEndObject();\n            break;\n        case ID_START_ARRAY:\n            writeStartArray();\n            break;\n        case ID_END_ARRAY:\n            writeEndArray();\n            break;\n        case ID_FIELD_NAME:\n            writeFieldName(p.getCurrentName());\n            break;\n        case ID_STRING:\n            if (p.hasTextCharacters()) {\n                writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());\n            } else {\n                writeString(p.getText());\n            }\n            break;\n        case ID_NUMBER_INT:\n        {\n            NumberType n = p.getNumberType();\n            if (n == NumberType.INT) {\n                writeNumber(p.getIntValue());\n            } else if (n == NumberType.BIG_INTEGER) {\n                writeNumber(p.getBigIntegerValue());\n            } else {\n                writeNumber(p.getLongValue());\n            }\n            break;\n        }\n        case ID_NUMBER_FLOAT:\n        {\n            NumberType n = p.getNumberType();\n            if (n == NumberType.BIG_DECIMAL) {\n                writeNumber(p.getDecimalValue());\n            } else if (n == NumberType.FLOAT) {\n                writeNumber(p.getFloatValue());\n            } else {\n                writeNumber(p.getDoubleValue());\n            }\n            break;\n        }\n        case ID_TRUE:\n            writeBoolean(true);\n            break;\n        case ID_FALSE:\n            writeBoolean(false);\n            break;\n        case ID_NULL:\n            writeNull();\n            break;\n        case ID_EMBEDDED_OBJECT:\n            writeObject(p.getEmbeddedObject());\n            break;\n        default:\n            _throwInternal();\n        }\n    }\n\n    \n    public void copyCurrentStructure(JsonParser p) throws IOException {\n        JsonToken t = p.currentToken();\n        if (t == null) {\n            _reportError(\"No current event to copy\");\n        }\n        \n        int id = t.id();\n        if (id == ID_FIELD_NAME) {\n            writeFieldName(p.getCurrentName());\n            t = p.nextToken();\n            id = t.id();\n            \n        }\n        switch (id) {\n        case ID_START_OBJECT:\n            writeStartObject();\n            while (p.nextToken() != JsonToken.END_OBJECT) {\n                copyCurrentStructure(p);\n            }\n            writeEndObject();\n            break;\n        case ID_START_ARRAY:\n            writeStartArray();\n            while (p.nextToken() != JsonToken.END_ARRAY) {\n                copyCurrentStructure(p);\n            }\n            writeEndArray();\n            break;\n        default:\n            copyCurrentEvent(p);\n        }\n    }\n\n    \n\n    \n    public abstract JsonStreamContext getOutputContext(); @Override public abstract void flush() throws IOException; public abstract boolean isClosed(); @Override public abstract void close() throws IOException; protected void _reportError(String msg) throws JsonGenerationException {\n        throw new JsonGenerationException(msg, this);\n    }\n\n    protected final void _throwInternal() { VersionUtil.throwInternal(); }\n\n    protected void _reportUnsupportedOperation() {\n        throw new UnsupportedOperationException(\"Operation not supported by generator of type \"+getClass().getName());\n    }\n\n    \n    protected final void _verifyOffsets(int arrayLength, int offset, int length) {\n        if ((offset < 0) || (offset + length) > arrayLength) {\n            throw new IllegalArgumentException(String.format(\n                    \"invalid argument(s) (offset=%d, length=%d) for input array of %d element\",\n                    offset, length, arrayLength));\n        }\n    }\n\n    \n    protected void _writeSimpleObject(Object value) throws IOException {\n        \n        if (value == null) {\n            writeNull();\n            return;\n        }\n        if (value instanceof String) {\n            writeString((String) value);\n            return;\n        }\n        if (value instanceof Number) {\n            Number n = (Number) value;\n            if (n instanceof Integer) {\n                writeNumber(n.intValue());\n                return;\n            } else if (n instanceof Long) {\n                writeNumber(n.longValue());\n                return;\n            } else if (n instanceof Double) {\n                writeNumber(n.doubleValue());\n                return;\n            } else if (n instanceof Float) {\n                writeNumber(n.floatValue());\n                return;\n            } else if (n instanceof Short) {\n                writeNumber(n.shortValue());\n                return;\n            } else if (n instanceof Byte) {\n                writeNumber(n.byteValue());\n                return;\n            } else if (n instanceof BigInteger) {\n                writeNumber((BigInteger) n);\n                return;\n            } else if (n instanceof BigDecimal) {\n                writeNumber((BigDecimal) n);\n                return;\n\n            \n            } else if (n instanceof AtomicInteger) {\n                writeNumber(((AtomicInteger) n).get());\n                return;\n            } else if (n instanceof AtomicLong) {\n                writeNumber(((AtomicLong) n).get());\n                return;\n            }\n        } else if (value instanceof byte[]) {\n            writeBinary((byte[]) value);\n            return;\n        } else if (value instanceof Boolean) {\n            writeBoolean((Boolean) value);\n            return;\n        } else if (value instanceof AtomicBoolean) {\n            writeBoolean(((AtomicBoolean) value).get());\n            return;\n        }\n        throw new IllegalStateException(\"No ObjectCodec defined for the generator, can only serialize simple wrapper types (type passed \"\n                +value.getClass().getName()+\")\");\n    }    \n}\n",
      "fixed_full_code": "\npackage com.fasterxml.jackson.core;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.atomic.AtomicLong; import com.fasterxml.jackson.core.JsonParser.NumberType; import com.fasterxml.jackson.core.io.CharacterEscapes; import com.fasterxml.jackson.core.util.VersionUtil; public abstract class JsonGenerator implements Closeable, Flushable, Versioned { public enum Feature { AUTO_CLOSE_TARGET(true), AUTO_CLOSE_JSON_CONTENT(true), FLUSH_PASSED_TO_STREAM(true), QUOTE_FIELD_NAMES(true), QUOTE_NON_NUMERIC_NUMBERS(true), WRITE_NUMBERS_AS_STRINGS(false), WRITE_BIGDECIMAL_AS_PLAIN(false), ESCAPE_NON_ASCII(false), STRICT_DUPLICATE_DETECTION(false), IGNORE_UNKNOWN(false), ; private final boolean _defaultState; private final int _mask; public static int collectDefaults() {\n            int flags = 0;\n            for (Feature f : values()) {\n                if (f.enabledByDefault()) {\n                    flags |= f.getMask();\n                }\n            }\n            return flags;\n        }\n        \n        private Feature(boolean defaultState) {\n            _defaultState = defaultState;\n            _mask = (1 << ordinal());\n        }\n\n        public boolean enabledByDefault() { return _defaultState; }\n\n        \n        public boolean enabledIn(int flags) { return (flags & _mask) != 0; }\n\n        public int getMask() { return _mask; }\n    }\n\n    \n\n    \n    protected PrettyPrinter _cfgPrettyPrinter; protected JsonGenerator() { }\n\n    \n    public abstract JsonGenerator setCodec(ObjectCodec oc); public abstract ObjectCodec getCodec(); @Override public abstract Version version(); public abstract JsonGenerator enable(Feature f); public abstract JsonGenerator disable(Feature f); public final JsonGenerator configure(Feature f, boolean state) {\n        if (state) enable(f); else disable(f);\n        return this;\n    }\n\n    \n    public abstract boolean isEnabled(Feature f); public abstract int getFeatureMask(); @Deprecated public abstract JsonGenerator setFeatureMask(int values); public JsonGenerator overrideStdFeatures(int values, int mask) {\n        int oldState = getFeatureMask();\n        int newState = (oldState & ~mask) | (values & mask);\n        return setFeatureMask(newState);\n    }\n\n    \n    public int getFormatFeatures() {\n        return 0;\n    }\n    \n    \n    public JsonGenerator overrideFormatFeatures(int values, int mask) {\n        throw new IllegalArgumentException(\"No FormatFeatures defined for generator of type \"+getClass().getName());\n        \n    }\n    \n    \n\n    \n    public void setSchema(FormatSchema schema) {\n        throw new UnsupportedOperationException(\"Generator of type \"+getClass().getName()+\" does not support schema of type '\"\n                +schema.getSchemaType()+\"'\");\n    }\n\n    \n    public FormatSchema getSchema() { return null; }\n\n    \n\n    \n    public JsonGenerator setPrettyPrinter(PrettyPrinter pp) {\n        _cfgPrettyPrinter = pp;\n        return this;\n    }\n\n    \n    public PrettyPrinter getPrettyPrinter() {\n        return _cfgPrettyPrinter;\n    }\n    \n    \n    public abstract JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setHighestNonEscapedChar(int charCode) { return this; }\n\n    \n    public int getHighestEscapedChar() { return 0; }\n\n    \n    public CharacterEscapes getCharacterEscapes() { return null; }\n\n    \n    public JsonGenerator setCharacterEscapes(CharacterEscapes esc) { return this; }\n\n    \n    public JsonGenerator setRootValueSeparator(SerializableString sep) {\n        throw new UnsupportedOperationException();\n    }\n\n    \n    \n    \n    public Object getOutputTarget() {\n        return null;\n    }\n\n    \n    public int getOutputBuffered() {\n        return -1;\n    }\n\n    \n    public Object getCurrentValue() {\n        JsonStreamContext ctxt = getOutputContext();\n        return (ctxt == null) ? null : ctxt.getCurrentValue();\n    }\n\n    \n    public void setCurrentValue(Object v) {\n        JsonStreamContext ctxt = getOutputContext();\n        if (ctxt != null) {\n            ctxt.setCurrentValue(v);\n        }\n    }\n    \n    \n\n    \n    public boolean canUseSchema(FormatSchema schema) { return false; }\n    \n    \n    public boolean canWriteObjectId() { return false; }\n\n    \n    public boolean canWriteTypeId() { return false; }\n\n    \n    public boolean canWriteBinaryNatively() { return false; }\n    \n    \n    public boolean canOmitFields() { return true; }\n\n    \n    public boolean canWriteFormattedNumbers() { return false; }\n    \n    \n\n    \n    public abstract void writeStartArray() throws IOException; public void writeStartArray(int size) throws IOException {\n        writeStartArray();\n    }\n    \n    \n    public abstract void writeEndArray() throws IOException; public abstract void writeStartObject() throws IOException; public void writeStartObject(Object forValue) throws IOException {\n        writeStartObject();\n        setCurrentValue(forValue);\n    }\n\n    \n    public abstract void writeEndObject() throws IOException; public abstract void writeFieldName(String name) throws IOException; public abstract void writeFieldName(SerializableString name) throws IOException; public void writeFieldId(long id) throws IOException {\n        writeFieldName(Long.toString(id));\n    }\n\n    \n\n    \n    public void writeArray(int[] array, int offset, int length) throws IOException {\n        if (array == null) {\n            throw new IllegalArgumentException(\"null array\");\n        }\n        _verifyOffsets(array.length, offset, length);\n        writeStartArray();\n        for (int i = offset, end = offset+length; i < end; ++i) {\n            writeNumber(array[i]);\n        }\n        writeEndArray();\n    }\n\n    \n    public void writeArray(long[] array, int offset, int length) throws IOException {\n        if (array == null) {\n            throw new IllegalArgumentException(\"null array\");\n        }\n        _verifyOffsets(array.length, offset, length);\n        writeStartArray();\n        for (int i = offset, end = offset+length; i < end; ++i) {\n            writeNumber(array[i]);\n        }\n        writeEndArray();\n    }\n\n    \n    public void writeArray(double[] array, int offset, int length) throws IOException {\n        if (array == null) {\n            throw new IllegalArgumentException(\"null array\");\n        }\n        _verifyOffsets(array.length, offset, length);\n        writeStartArray();\n        for (int i = offset, end = offset+length; i < end; ++i) {\n            writeNumber(array[i]);\n        }\n        writeEndArray();\n    }\n\n    \n\n    \n    public abstract void writeString(String text) throws IOException; public abstract void writeString(char[] text, int offset, int len) throws IOException; public abstract void writeString(SerializableString text) throws IOException; public abstract void writeRawUTF8String(byte[] text, int offset, int length) throws IOException; public abstract void writeUTF8String(byte[] text, int offset, int length) throws IOException; public abstract void writeRaw(String text) throws IOException; public abstract void writeRaw(String text, int offset, int len) throws IOException; public abstract void writeRaw(char[] text, int offset, int len) throws IOException; public abstract void writeRaw(char c) throws IOException; public void writeRaw(SerializableString raw) throws IOException {\n        writeRaw(raw.getValue());\n    }\n\n    \n    public abstract void writeRawValue(String text) throws IOException; public abstract void writeRawValue(String text, int offset, int len) throws IOException; public abstract void writeRawValue(char[] text, int offset, int len) throws IOException; public void writeRawValue(SerializableString raw) throws IOException {\n        writeRawValue(raw.getValue());\n    }\n\n    \n    public abstract void writeBinary(Base64Variant bv, byte[] data, int offset, int len) throws IOException; public void writeBinary(byte[] data, int offset, int len) throws IOException {\n        writeBinary(Base64Variants.getDefaultVariant(), data, offset, len);\n    }\n\n    \n    public void writeBinary(byte[] data) throws IOException {\n        writeBinary(Base64Variants.getDefaultVariant(), data, 0, data.length);\n    }\n\n    \n    public int writeBinary(InputStream data, int dataLength) throws IOException {\n        return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength);\n    }\n    \n    \n    public abstract int writeBinary(Base64Variant bv, InputStream data, int dataLength) throws IOException; public void writeNumber(short v) throws IOException { writeNumber((int) v); }\n\n    \n    public abstract void writeNumber(int v) throws IOException; public abstract void writeNumber(long v) throws IOException; public abstract void writeNumber(BigInteger v) throws IOException; public abstract void writeNumber(double v) throws IOException; public abstract void writeNumber(float v) throws IOException; public abstract void writeNumber(BigDecimal v) throws IOException; public abstract void writeNumber(String encodedValue) throws IOException; public abstract void writeBoolean(boolean state) throws IOException; public abstract void writeNull() throws IOException; public void writeEmbeddedObject(Object object) throws IOException {\n        \n        if (object == null) {\n            writeNull();\n            return;\n        }\n        if (object instanceof byte[]) {\n            writeBinary((byte[]) object);\n            return;\n        }\n        throw new JsonGenerationException(\"No native support for writing embedded objects of type \" +object.getClass().getName(), this); } public void writeObjectId(Object id) throws IOException {\n        throw new JsonGenerationException(\"No native support for writing Object Ids\", this); } public void writeObjectRef(Object id) throws IOException {\n        throw new JsonGenerationException(\"No native support for writing Object Ids\", this); } public void writeTypeId(Object id) throws IOException {\n        throw new JsonGenerationException(\"No native support for writing Type Ids\", this); } public abstract void writeObject(Object pojo) throws IOException; public abstract void writeTree(TreeNode rootNode) throws IOException; public void writeStringField(String fieldName, String value) throws IOException {\n        writeFieldName(fieldName);\n        writeString(value);\n    }\n\n    \n    public final void writeBooleanField(String fieldName, boolean value) throws IOException {\n        writeFieldName(fieldName);\n        writeBoolean(value);\n    }\n\n    \n    public final void writeNullField(String fieldName) throws IOException {\n        writeFieldName(fieldName);\n        writeNull();\n    }\n\n    \n    public final void writeNumberField(String fieldName, int value) throws IOException {\n        writeFieldName(fieldName);\n        writeNumber(value);\n    }\n\n    \n    public final void writeNumberField(String fieldName, long value) throws IOException {\n        writeFieldName(fieldName);\n        writeNumber(value);\n    }\n\n    \n    public final void writeNumberField(String fieldName, double value) throws IOException {\n        writeFieldName(fieldName);\n        writeNumber(value);\n    }\n\n    \n    public final void writeNumberField(String fieldName, float value) throws IOException {\n        writeFieldName(fieldName);\n        writeNumber(value);\n    }\n\n    \n    public final void writeNumberField(String fieldName, BigDecimal value) throws IOException {\n        writeFieldName(fieldName);\n        writeNumber(value);\n    }\n\n    \n    public final void writeBinaryField(String fieldName, byte[] data) throws IOException {\n        writeFieldName(fieldName);\n        writeBinary(data);\n    }\n\n    \n    public final void writeArrayFieldStart(String fieldName) throws IOException {\n        writeFieldName(fieldName);\n        writeStartArray();\n    }\n\n    \n    public final void writeObjectFieldStart(String fieldName) throws IOException {\n        writeFieldName(fieldName);\n        writeStartObject();\n    }\n\n    \n    public final void writeObjectField(String fieldName, Object pojo) throws IOException {\n        writeFieldName(fieldName);\n        writeObject(pojo);\n    }\n\n    \n    public void writeOmittedField(String fieldName) throws IOException { }\n    \n    \n\n    \n    public void copyCurrentEvent(JsonParser p) throws IOException {\n        JsonToken t = p.currentToken();\n        \n        if (t == null) {\n            _reportError(\"No current event to copy\");\n        }\n        switch (t.id()) {\n        case ID_NOT_AVAILABLE:\n            _reportError(\"No current event to copy\");\n            break; \n        case ID_START_OBJECT:\n            writeStartObject();\n            break;\n        case ID_END_OBJECT:\n            writeEndObject();\n            break;\n        case ID_START_ARRAY:\n            writeStartArray();\n            break;\n        case ID_END_ARRAY:\n            writeEndArray();\n            break;\n        case ID_FIELD_NAME:\n            writeFieldName(p.getCurrentName());\n            break;\n        case ID_STRING:\n            if (p.hasTextCharacters()) {\n                writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());\n            } else {\n                writeString(p.getText());\n            }\n            break;\n        case ID_NUMBER_INT:\n        {\n            NumberType n = p.getNumberType();\n            if (n == NumberType.INT) {\n                writeNumber(p.getIntValue());\n            } else if (n == NumberType.BIG_INTEGER) {\n                writeNumber(p.getBigIntegerValue());\n            } else {\n                writeNumber(p.getLongValue());\n            }\n            break;\n        }\n        case ID_NUMBER_FLOAT:\n        {\n            NumberType n = p.getNumberType();\n            if (n == NumberType.BIG_DECIMAL) {\n                writeNumber(p.getDecimalValue());\n            } else if (n == NumberType.FLOAT) {\n                writeNumber(p.getFloatValue());\n            } else {\n                writeNumber(p.getDoubleValue());\n            }\n            break;\n        }\n        case ID_TRUE:\n            writeBoolean(true);\n            break;\n        case ID_FALSE:\n            writeBoolean(false);\n            break;\n        case ID_NULL:\n            writeNull();\n            break;\n        case ID_EMBEDDED_OBJECT:\n            writeObject(p.getEmbeddedObject());\n            break;\n        default:\n            _throwInternal();\n        }\n    }\n\n    \n    public void copyCurrentStructure(JsonParser p) throws IOException {\n        JsonToken t = p.currentToken();\n        if (t == null) {\n            _reportError(\"No current event to copy\");\n        }\n        \n        int id = t.id();\n        if (id == ID_FIELD_NAME) {\n            writeFieldName(p.getCurrentName());\n            t = p.nextToken();\n            id = t.id();\n            \n        }\n        switch (id) {\n        case ID_START_OBJECT:\n            writeStartObject();\n            while (p.nextToken() != JsonToken.END_OBJECT) {\n                copyCurrentStructure(p);\n            }\n            writeEndObject();\n            break;\n        case ID_START_ARRAY:\n            writeStartArray();\n            while (p.nextToken() != JsonToken.END_ARRAY) {\n                copyCurrentStructure(p);\n            }\n            writeEndArray();\n            break;\n        default:\n            copyCurrentEvent(p);\n        }\n    }\n\n    \n\n    \n    public abstract JsonStreamContext getOutputContext(); @Override public abstract void flush() throws IOException; public abstract boolean isClosed(); @Override public abstract void close() throws IOException; protected void _reportError(String msg) throws JsonGenerationException {\n        throw new JsonGenerationException(msg, this);\n    }\n\n    protected final void _throwInternal() { VersionUtil.throwInternal(); }\n\n    protected void _reportUnsupportedOperation() {\n        throw new UnsupportedOperationException(\"Operation not supported by generator of type \"+getClass().getName());\n    }\n\n    \n    protected final void _verifyOffsets(int arrayLength, int offset, int length) {\n        if ((offset < 0) || (offset + length) > arrayLength) {\n            throw new IllegalArgumentException(String.format(\n                    \"invalid argument(s) (offset=%d, length=%d) for input array of %d element\",\n                    offset, length, arrayLength));\n        }\n    }\n\n    \n    protected void _writeSimpleObject(Object value) throws IOException {\n        \n        if (value == null) {\n            writeNull();\n            return;\n        }\n        if (value instanceof String) {\n            writeString((String) value);\n            return;\n        }\n        if (value instanceof Number) {\n            Number n = (Number) value;\n            if (n instanceof Integer) {\n                writeNumber(n.intValue());\n                return;\n            } else if (n instanceof Long) {\n                writeNumber(n.longValue());\n                return;\n            } else if (n instanceof Double) {\n                writeNumber(n.doubleValue());\n                return;\n            } else if (n instanceof Float) {\n                writeNumber(n.floatValue());\n                return;\n            } else if (n instanceof Short) {\n                writeNumber(n.shortValue());\n                return;\n            } else if (n instanceof Byte) {\n                writeNumber(n.byteValue());\n                return;\n            } else if (n instanceof BigInteger) {\n                writeNumber((BigInteger) n);\n                return;\n            } else if (n instanceof BigDecimal) {\n                writeNumber((BigDecimal) n);\n                return;\n\n            \n            } else if (n instanceof AtomicInteger) {\n                writeNumber(((AtomicInteger) n).get());\n                return;\n            } else if (n instanceof AtomicLong) {\n                writeNumber(((AtomicLong) n).get());\n                return;\n            }\n        } else if (value instanceof byte[]) {\n            writeBinary((byte[]) value);\n            return;\n        } else if (value instanceof Boolean) {\n            writeBoolean((Boolean) value);\n            return;\n        } else if (value instanceof AtomicBoolean) {\n            writeBoolean(((AtomicBoolean) value).get());\n            return;\n        }\n        throw new IllegalStateException(\"No ObjectCodec defined for the generator, can only serialize simple wrapper types (type passed \"\n                +value.getClass().getName()+\")\");\n    }    \n}\n",
      "buggy_signatures": [
        "static com.fasterxml.jackson.core.JsonTokenId.*; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.atomic.AtomicLong; import com.fasterxml.jackson.core.JsonParser.NumberType; import com.fasterxml.jackson.core.io.CharacterEscapes; import com.fasterxml.jackson.core.util.VersionUtil; public abstract class JsonGenerator implements Closeable, Flushable, Versioned { public enum Feature { AUTO_CLOSE_TARGET(true), AUTO_CLOSE_JSON_CONTENT(true), FLUSH_PASSED_TO_STREAM(true), QUOTE_FIELD_NAMES(true), QUOTE_NON_NUMERIC_NUMBERS(true), WRITE_NUMBERS_AS_STRINGS(false), WRITE_BIGDECIMAL_AS_PLAIN(false), ESCAPE_NON_ASCII(false), STRICT_DUPLICATE_DETECTION(false), IGNORE_UNKNOWN(false), ; private final boolean _defaultState; private final int _mask; public static int collectDefaults()",
        "private Feature(boolean defaultState)",
        "public boolean enabledByDefault()",
        "public boolean enabledIn(int flags)",
        "public int getMask()",
        "protected PrettyPrinter _cfgPrettyPrinter; protected JsonGenerator()",
        "public abstract JsonGenerator setCodec(ObjectCodec oc); public abstract ObjectCodec getCodec(); @Override public abstract Version version(); public abstract JsonGenerator enable(Feature f); public abstract JsonGenerator disable(Feature f); public final JsonGenerator configure(Feature f, boolean state)",
        "public abstract boolean isEnabled(Feature f); public abstract int getFeatureMask(); @Deprecated public abstract JsonGenerator setFeatureMask(int values); public JsonGenerator overrideStdFeatures(int values, int mask)",
        "public int getFormatFeatures()",
        "public JsonGenerator overrideFormatFeatures(int values, int mask)",
        "public void setSchema(FormatSchema schema)",
        "public FormatSchema getSchema()",
        "public JsonGenerator setPrettyPrinter(PrettyPrinter pp)",
        "public PrettyPrinter getPrettyPrinter()",
        "public abstract JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setHighestNonEscapedChar(int charCode)",
        "public int getHighestEscapedChar()",
        "public CharacterEscapes getCharacterEscapes()",
        "public JsonGenerator setCharacterEscapes(CharacterEscapes esc)",
        "public JsonGenerator setRootValueSeparator(SerializableString sep)",
        "public Object getOutputTarget()",
        "public int getOutputBuffered()",
        "public Object getCurrentValue()",
        "public void setCurrentValue(Object v)",
        "public boolean canUseSchema(FormatSchema schema)",
        "public boolean canWriteObjectId()",
        "public boolean canWriteTypeId()",
        "public boolean canWriteBinaryNatively()",
        "public boolean canOmitFields()",
        "public boolean canWriteFormattedNumbers()",
        "public abstract void writeStartArray() throws IOException; public void writeStartArray(int size) throws IOException",
        "public abstract void writeEndArray() throws IOException; public abstract void writeStartObject() throws IOException; public void writeStartObject(Object forValue) throws IOException",
        "public abstract void writeEndObject() throws IOException; public abstract void writeFieldName(String name) throws IOException; public abstract void writeFieldName(SerializableString name) throws IOException; public void writeFieldId(long id) throws IOException",
        "public void writeArray(int[] array, int offset, int length) throws IOException",
        "public void writeArray(long[] array, int offset, int length) throws IOException",
        "public void writeArray(double[] array, int offset, int length) throws IOException",
        "public abstract void writeString(String text) throws IOException; public abstract void writeString(char[] text, int offset, int len) throws IOException; public abstract void writeString(SerializableString text) throws IOException; public abstract void writeRawUTF8String(byte[] text, int offset, int length) throws IOException; public abstract void writeUTF8String(byte[] text, int offset, int length) throws IOException; public abstract void writeRaw(String text) throws IOException; public abstract void writeRaw(String text, int offset, int len) throws IOException; public abstract void writeRaw(char[] text, int offset, int len) throws IOException; public abstract void writeRaw(char c) throws IOException; public void writeRaw(SerializableString raw) throws IOException",
        "public abstract void writeRawValue(String text) throws IOException; public abstract void writeRawValue(String text, int offset, int len) throws IOException; public abstract void writeRawValue(char[] text, int offset, int len) throws IOException; public void writeRawValue(SerializableString raw) throws IOException",
        "public abstract void writeBinary(Base64Variant bv, byte[] data, int offset, int len) throws IOException; public void writeBinary(byte[] data, int offset, int len) throws IOException",
        "public void writeBinary(byte[] data) throws IOException",
        "public int writeBinary(InputStream data, int dataLength) throws IOException",
        "public abstract int writeBinary(Base64Variant bv, InputStream data, int dataLength) throws IOException; public void writeNumber(short v) throws IOException",
        "public abstract void writeNumber(int v) throws IOException; public abstract void writeNumber(long v) throws IOException; public abstract void writeNumber(BigInteger v) throws IOException; public abstract void writeNumber(double v) throws IOException; public abstract void writeNumber(float v) throws IOException; public abstract void writeNumber(BigDecimal v) throws IOException; public abstract void writeNumber(String encodedValue) throws IOException; public abstract void writeBoolean(boolean state) throws IOException; public abstract void writeNull() throws IOException; public void writeEmbeddedObject(Object object) throws IOException",
        "native support for writing embedded objects\", this); } public void writeObjectId(Object id) throws IOException",
        "native support for writing Object Ids\", this); } public void writeObjectRef(Object id) throws IOException",
        "native support for writing Object Ids\", this); } public void writeTypeId(Object id) throws IOException",
        "native support for writing Type Ids\", this); } public abstract void writeObject(Object pojo) throws IOException; public abstract void writeTree(TreeNode rootNode) throws IOException; public void writeStringField(String fieldName, String value) throws IOException",
        "public final void writeBooleanField(String fieldName, boolean value) throws IOException",
        "public final void writeNullField(String fieldName) throws IOException",
        "public final void writeNumberField(String fieldName, int value) throws IOException",
        "public final void writeNumberField(String fieldName, long value) throws IOException",
        "public final void writeNumberField(String fieldName, double value) throws IOException",
        "public final void writeNumberField(String fieldName, float value) throws IOException",
        "public final void writeNumberField(String fieldName, BigDecimal value) throws IOException",
        "public final void writeBinaryField(String fieldName, byte[] data) throws IOException",
        "public final void writeArrayFieldStart(String fieldName) throws IOException",
        "public final void writeObjectFieldStart(String fieldName) throws IOException",
        "public final void writeObjectField(String fieldName, Object pojo) throws IOException",
        "public void writeOmittedField(String fieldName) throws IOException",
        "public void copyCurrentEvent(JsonParser p) throws IOException",
        "public void copyCurrentStructure(JsonParser p) throws IOException",
        "public abstract JsonStreamContext getOutputContext(); @Override public abstract void flush() throws IOException; public abstract boolean isClosed(); @Override public abstract void close() throws IOException; protected void _reportError(String msg) throws JsonGenerationException",
        "protected final void _throwInternal()",
        "protected void _reportUnsupportedOperation()",
        "protected final void _verifyOffsets(int arrayLength, int offset, int length)",
        "protected void _writeSimpleObject(Object value) throws IOException"
      ],
      "fixed_signatures": [
        "static com.fasterxml.jackson.core.JsonTokenId.*; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.atomic.AtomicLong; import com.fasterxml.jackson.core.JsonParser.NumberType; import com.fasterxml.jackson.core.io.CharacterEscapes; import com.fasterxml.jackson.core.util.VersionUtil; public abstract class JsonGenerator implements Closeable, Flushable, Versioned { public enum Feature { AUTO_CLOSE_TARGET(true), AUTO_CLOSE_JSON_CONTENT(true), FLUSH_PASSED_TO_STREAM(true), QUOTE_FIELD_NAMES(true), QUOTE_NON_NUMERIC_NUMBERS(true), WRITE_NUMBERS_AS_STRINGS(false), WRITE_BIGDECIMAL_AS_PLAIN(false), ESCAPE_NON_ASCII(false), STRICT_DUPLICATE_DETECTION(false), IGNORE_UNKNOWN(false), ; private final boolean _defaultState; private final int _mask; public static int collectDefaults()",
        "private Feature(boolean defaultState)",
        "public boolean enabledByDefault()",
        "public boolean enabledIn(int flags)",
        "public int getMask()",
        "protected PrettyPrinter _cfgPrettyPrinter; protected JsonGenerator()",
        "public abstract JsonGenerator setCodec(ObjectCodec oc); public abstract ObjectCodec getCodec(); @Override public abstract Version version(); public abstract JsonGenerator enable(Feature f); public abstract JsonGenerator disable(Feature f); public final JsonGenerator configure(Feature f, boolean state)",
        "public abstract boolean isEnabled(Feature f); public abstract int getFeatureMask(); @Deprecated public abstract JsonGenerator setFeatureMask(int values); public JsonGenerator overrideStdFeatures(int values, int mask)",
        "public int getFormatFeatures()",
        "public JsonGenerator overrideFormatFeatures(int values, int mask)",
        "public void setSchema(FormatSchema schema)",
        "public FormatSchema getSchema()",
        "public JsonGenerator setPrettyPrinter(PrettyPrinter pp)",
        "public PrettyPrinter getPrettyPrinter()",
        "public abstract JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setHighestNonEscapedChar(int charCode)",
        "public int getHighestEscapedChar()",
        "public CharacterEscapes getCharacterEscapes()",
        "public JsonGenerator setCharacterEscapes(CharacterEscapes esc)",
        "public JsonGenerator setRootValueSeparator(SerializableString sep)",
        "public Object getOutputTarget()",
        "public int getOutputBuffered()",
        "public Object getCurrentValue()",
        "public void setCurrentValue(Object v)",
        "public boolean canUseSchema(FormatSchema schema)",
        "public boolean canWriteObjectId()",
        "public boolean canWriteTypeId()",
        "public boolean canWriteBinaryNatively()",
        "public boolean canOmitFields()",
        "public boolean canWriteFormattedNumbers()",
        "public abstract void writeStartArray() throws IOException; public void writeStartArray(int size) throws IOException",
        "public abstract void writeEndArray() throws IOException; public abstract void writeStartObject() throws IOException; public void writeStartObject(Object forValue) throws IOException",
        "public abstract void writeEndObject() throws IOException; public abstract void writeFieldName(String name) throws IOException; public abstract void writeFieldName(SerializableString name) throws IOException; public void writeFieldId(long id) throws IOException",
        "public void writeArray(int[] array, int offset, int length) throws IOException",
        "public void writeArray(long[] array, int offset, int length) throws IOException",
        "public void writeArray(double[] array, int offset, int length) throws IOException",
        "public abstract void writeString(String text) throws IOException; public abstract void writeString(char[] text, int offset, int len) throws IOException; public abstract void writeString(SerializableString text) throws IOException; public abstract void writeRawUTF8String(byte[] text, int offset, int length) throws IOException; public abstract void writeUTF8String(byte[] text, int offset, int length) throws IOException; public abstract void writeRaw(String text) throws IOException; public abstract void writeRaw(String text, int offset, int len) throws IOException; public abstract void writeRaw(char[] text, int offset, int len) throws IOException; public abstract void writeRaw(char c) throws IOException; public void writeRaw(SerializableString raw) throws IOException",
        "public abstract void writeRawValue(String text) throws IOException; public abstract void writeRawValue(String text, int offset, int len) throws IOException; public abstract void writeRawValue(char[] text, int offset, int len) throws IOException; public void writeRawValue(SerializableString raw) throws IOException",
        "public abstract void writeBinary(Base64Variant bv, byte[] data, int offset, int len) throws IOException; public void writeBinary(byte[] data, int offset, int len) throws IOException",
        "public void writeBinary(byte[] data) throws IOException",
        "public int writeBinary(InputStream data, int dataLength) throws IOException",
        "public abstract int writeBinary(Base64Variant bv, InputStream data, int dataLength) throws IOException; public void writeNumber(short v) throws IOException",
        "public abstract void writeNumber(int v) throws IOException; public abstract void writeNumber(long v) throws IOException; public abstract void writeNumber(BigInteger v) throws IOException; public abstract void writeNumber(double v) throws IOException; public abstract void writeNumber(float v) throws IOException; public abstract void writeNumber(BigDecimal v) throws IOException; public abstract void writeNumber(String encodedValue) throws IOException; public abstract void writeBoolean(boolean state) throws IOException; public abstract void writeNull() throws IOException; public void writeEmbeddedObject(Object object) throws IOException",
        "native support for writing embedded objects of type \" +object.getClass().getName(), this); } public void writeObjectId(Object id) throws IOException",
        "native support for writing Object Ids\", this); } public void writeObjectRef(Object id) throws IOException",
        "native support for writing Object Ids\", this); } public void writeTypeId(Object id) throws IOException",
        "native support for writing Type Ids\", this); } public abstract void writeObject(Object pojo) throws IOException; public abstract void writeTree(TreeNode rootNode) throws IOException; public void writeStringField(String fieldName, String value) throws IOException",
        "public final void writeBooleanField(String fieldName, boolean value) throws IOException",
        "public final void writeNullField(String fieldName) throws IOException",
        "public final void writeNumberField(String fieldName, int value) throws IOException",
        "public final void writeNumberField(String fieldName, long value) throws IOException",
        "public final void writeNumberField(String fieldName, double value) throws IOException",
        "public final void writeNumberField(String fieldName, float value) throws IOException",
        "public final void writeNumberField(String fieldName, BigDecimal value) throws IOException",
        "public final void writeBinaryField(String fieldName, byte[] data) throws IOException",
        "public final void writeArrayFieldStart(String fieldName) throws IOException",
        "public final void writeObjectFieldStart(String fieldName) throws IOException",
        "public final void writeObjectField(String fieldName, Object pojo) throws IOException",
        "public void writeOmittedField(String fieldName) throws IOException",
        "public void copyCurrentEvent(JsonParser p) throws IOException",
        "public void copyCurrentStructure(JsonParser p) throws IOException",
        "public abstract JsonStreamContext getOutputContext(); @Override public abstract void flush() throws IOException; public abstract boolean isClosed(); @Override public abstract void close() throws IOException; protected void _reportError(String msg) throws JsonGenerationException",
        "protected final void _throwInternal()",
        "protected void _reportUnsupportedOperation()",
        "protected final void _verifyOffsets(int arrayLength, int offset, int length)",
        "protected void _writeSimpleObject(Object value) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  public void writeEmbeddedObject(Object object) throws IOException {\n  \n  throw new JsonGenerationException(\"No native support for writing embedded objects\",\n  this);\n  }",
          "fixed_method": "  public void writeEmbeddedObject(Object object) throws IOException {\n  \n  if (object == null) {\n  writeNull();\n  return;\n  }\n  if (object instanceof byte[]) {\n  writeBinary((byte[]) object);\n  return;\n  }\n  throw new JsonGenerationException(\"No native support for writing embedded objects of type \"\n  +object.getClass().getName(),\n  this);\n  }",
          "diff": [
            "@@ -1327,7 +1327,16 @@",
            "      */\n",
            "     public void writeEmbeddedObject(Object object) throws IOException {\n",
            "         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n",
            "-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n",
            "+        if (object == null) {\n",
            "+            writeNull();\n",
            "+            return;\n",
            "+        }\n",
            "+        if (object instanceof byte[]) {\n",
            "+            writeBinary((byte[]) object);\n",
            "+            return;\n",
            "+        }\n",
            "+        throw new JsonGenerationException(\"No native support for writing embedded objects of type \"\n",
            "+                +object.getClass().getName(),\n",
            "                 this);\n",
            "     }\n",
            "     \n"
          ],
          "changed_lines": 11
        }
      ]
    }
  ]
}
