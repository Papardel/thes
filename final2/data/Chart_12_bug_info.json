{
  "bug_id": "12",
  "failed_tests": {
    "org.jfree.chart.plot.junit.MultiplePiePlotTests": [
      {
        "methodName": "testConstructor",
        "error": "junit.framework.AssertionFailedError",
        "message": "",
        "fail_line": "    \tassertTrue(dataset.hasListener(plot));",
        "test_source": "  public void testConstructor() {\n  \tMultiplePiePlot plot = new MultiplePiePlot();\n  \tassertNull(plot.getDataset());\n\n  \t// the following checks that the plot registers itself as a listener\n  \t// with the dataset passed to the constructor - see patch 1943021\n  \tDefaultCategoryDataset dataset = new DefaultCategoryDataset();\n  \tplot = new MultiplePiePlot(dataset);\n  \tassertTrue(dataset.hasListener(plot));\n  }",
        "stack": [
          "MultiplePiePlotTests.testConstructor line 112"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jfree/chart/plot/MultiplePiePlot.java",
      "buggy_full_code": "\n\npackage org.jfree.chart.plot;\n\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Rectangle;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jfree.chart.ChartRenderingInfo;\nimport org.jfree.chart.JFreeChart;\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.title.TextTitle;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.chart.util.TableOrder;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.category.CategoryToPieDataset;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\nimport org.jfree.data.general.PieDataset;\n\n\npublic class MultiplePiePlot extends Plot implements Cloneable, Serializable { private static final long serialVersionUID = -355377800470807389L; private JFreeChart pieChart; private CategoryDataset dataset; private TableOrder dataExtractOrder; private double limit = 0.0; private Comparable aggregatedItemsKey; private transient Paint aggregatedItemsPaint; private transient Map sectionPaints; public MultiplePiePlot() {\n        this(null);\n    }\n\n    \n    public MultiplePiePlot(CategoryDataset dataset) {\n        super();\n        this.dataset = dataset;\n        PiePlot piePlot = new PiePlot(null);\n        this.pieChart = new JFreeChart(piePlot);\n        this.pieChart.removeLegend();\n        this.dataExtractOrder = TableOrder.BY_COLUMN;\n        this.pieChart.setBackgroundPaint(null);\n        TextTitle seriesTitle = new TextTitle(\"Series Title\",\n                new Font(\"SansSerif\", Font.BOLD, 12));\n        seriesTitle.setPosition(RectangleEdge.BOTTOM);\n        this.pieChart.setTitle(seriesTitle);\n        this.aggregatedItemsKey = \"Other\";\n        this.aggregatedItemsPaint = Color.lightGray;\n        this.sectionPaints = new HashMap();\n    }\n\n    \n    public CategoryDataset getDataset() {\n        return this.dataset;\n    }\n\n    \n    public void setDataset(CategoryDataset dataset) {\n        \n        \n        if (this.dataset != null) {\n            this.dataset.removeChangeListener(this);\n        }\n\n        \n        this.dataset = dataset;\n        if (dataset != null) {\n            setDatasetGroup(dataset.getGroup());\n            dataset.addChangeListener(this);\n        }\n\n        \n        datasetChanged(new DatasetChangeEvent(this, dataset));\n    }\n\n    \n    public JFreeChart getPieChart() {\n        return this.pieChart;\n    }\n\n    \n    public void setPieChart(JFreeChart pieChart) {\n        if (pieChart == null) {\n            throw new IllegalArgumentException(\"Null 'pieChart' argument.\");\n        }\n        if (!(pieChart.getPlot() instanceof PiePlot)) {\n            throw new IllegalArgumentException(\"The 'pieChart' argument must \"\n                    + \"be a chart based on a PiePlot.\");\n        }\n        this.pieChart = pieChart;\n        fireChangeEvent();\n    }\n\n    \n    public TableOrder getDataExtractOrder() {\n        return this.dataExtractOrder;\n    }\n\n    \n    public void setDataExtractOrder(TableOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument\");\n        }\n        this.dataExtractOrder = order;\n        fireChangeEvent();\n    }\n\n    \n    public double getLimit() {\n        return this.limit;\n    }\n\n    \n    public void setLimit(double limit) {\n        this.limit = limit;\n        fireChangeEvent();\n    }\n\n    \n    public Comparable getAggregatedItemsKey() {\n        return this.aggregatedItemsKey;\n    }\n\n    \n    public void setAggregatedItemsKey(Comparable key) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        this.aggregatedItemsKey = key;\n        fireChangeEvent();\n    }\n\n    \n    public Paint getAggregatedItemsPaint() {\n        return this.aggregatedItemsPaint;\n    }\n\n    \n    public void setAggregatedItemsPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.aggregatedItemsPaint = paint;\n        fireChangeEvent();\n    }\n\n    \n    public String getPlotType() {\n        return \"Multiple Pie Plot\";\n         \n    }\n\n    \n    public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo info) {\n\n\n        \n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n        drawBackground(g2, area);\n        drawOutline(g2, area);\n\n        \n        if (DatasetUtilities.isEmptyOrNull(this.dataset)) {\n            drawNoDataMessage(g2, area);\n            return;\n        }\n\n        int pieCount = 0;\n        if (this.dataExtractOrder == TableOrder.BY_ROW) {\n            pieCount = this.dataset.getRowCount();\n        }\n        else {\n            pieCount = this.dataset.getColumnCount();\n        }\n\n        \n        int displayCols = (int) Math.ceil(Math.sqrt(pieCount));\n        int displayRows\n            = (int) Math.ceil((double) pieCount / (double) displayCols);\n\n        \n        if (displayCols > displayRows && area.getWidth() < area.getHeight()) {\n            int temp = displayCols;\n            displayCols = displayRows;\n            displayRows = temp;\n        }\n\n        prefetchSectionPaints();\n\n        int x = (int) area.getX();\n        int y = (int) area.getY();\n        int width = ((int) area.getWidth()) / displayCols;\n        int height = ((int) area.getHeight()) / displayRows;\n        int row = 0;\n        int column = 0;\n        int diff = (displayRows * displayCols) - pieCount;\n        int xoffset = 0;\n        Rectangle rect = new Rectangle();\n\n        for (int pieIndex = 0; pieIndex < pieCount; pieIndex++) {\n            rect.setBounds(x + xoffset + (width * column), y + (height * row),\n                    width, height);\n\n            String title = null;\n            if (this.dataExtractOrder == TableOrder.BY_ROW) {\n                title = this.dataset.getRowKey(pieIndex).toString();\n            }\n            else {\n                title = this.dataset.getColumnKey(pieIndex).toString();\n            }\n            this.pieChart.setTitle(title);\n\n            PieDataset piedataset = null;\n            PieDataset dd = new CategoryToPieDataset(this.dataset,\n                    this.dataExtractOrder, pieIndex);\n            if (this.limit > 0.0) {\n                piedataset = DatasetUtilities.createConsolidatedPieDataset(\n                        dd, this.aggregatedItemsKey, this.limit);\n            }\n            else {\n                piedataset = dd;\n            }\n            PiePlot piePlot = (PiePlot) this.pieChart.getPlot();\n            piePlot.setDataset(piedataset);\n            piePlot.setPieIndex(pieIndex);\n\n            \n            for (int i = 0; i < piedataset.getItemCount(); i++) {\n                Comparable key = piedataset.getKey(i);\n                Paint p;\n                if (key.equals(this.aggregatedItemsKey)) {\n                    p = this.aggregatedItemsPaint;\n                }\n                else {\n                    p = (Paint) this.sectionPaints.get(key);\n                }\n                piePlot.setSectionPaint(key, p);\n            }\n\n            ChartRenderingInfo subinfo = null;\n            if (info != null) {\n                subinfo = new ChartRenderingInfo();\n            }\n            this.pieChart.draw(g2, rect, subinfo);\n            if (info != null) {\n                info.getOwner().getEntityCollection().addAll(\n                        subinfo.getEntityCollection());\n                info.addSubplotInfo(subinfo.getPlotInfo());\n            }\n\n            ++column;\n            if (column == displayCols) {\n                column = 0;\n                ++row;\n\n                if (row == displayRows - 1 && diff != 0) {\n                    xoffset = (diff * width) / 2;\n                }\n            }\n        }\n\n    }\n\n    \n    private void prefetchSectionPaints() {\n\n        \n        \n        \n\n        PiePlot piePlot = (PiePlot) getPieChart().getPlot();\n\n        if (this.dataExtractOrder == TableOrder.BY_ROW) {\n            \n            for (int c = 0; c < this.dataset.getColumnCount(); c++) {\n                Comparable key = this.dataset.getColumnKey(c);\n                Paint p = piePlot.getSectionPaint(key);\n                if (p == null) {\n                    p = (Paint) this.sectionPaints.get(key);\n                    if (p == null) {\n                        p = getDrawingSupplier().getNextPaint();\n                    }\n                }\n                this.sectionPaints.put(key, p);\n            }\n        }\n        else {\n            \n            for (int r = 0; r < this.dataset.getRowCount(); r++) {\n                Comparable key = this.dataset.getRowKey(r);\n                Paint p = piePlot.getSectionPaint(key);\n                if (p == null) {\n                    p = (Paint) this.sectionPaints.get(key);\n                    if (p == null) {\n                        p = getDrawingSupplier().getNextPaint();\n                    }\n                }\n                this.sectionPaints.put(key, p);\n            }\n        }\n\n    }\n\n    \n    public LegendItemCollection getLegendItems() {\n\n        LegendItemCollection result = new LegendItemCollection();\n\n        if (this.dataset != null) {\n            List keys = null;\n\n            prefetchSectionPaints();\n            if (this.dataExtractOrder == TableOrder.BY_ROW) {\n                keys = this.dataset.getColumnKeys();\n            }\n            else if (this.dataExtractOrder == TableOrder.BY_COLUMN) {\n                keys = this.dataset.getRowKeys();\n            }\n\n            if (keys != null) {\n                int section = 0;\n                Iterator iterator = keys.iterator();\n                while (iterator.hasNext()) {\n                    Comparable key = (Comparable) iterator.next();\n                    String label = key.toString();\n                    String description = label;\n                    Paint paint = (Paint) this.sectionPaints.get(key);\n                    LegendItem item = new LegendItem(label, description,\n                            null, null, Plot.DEFAULT_LEGEND_ITEM_CIRCLE,\n                            paint, Plot.DEFAULT_OUTLINE_STROKE, paint);\n                    item.setDataset(getDataset());\n                    result.add(item);\n                    section++;\n                }\n            }\n            if (this.limit > 0.0) {\n                result.add(new LegendItem(this.aggregatedItemsKey.toString(),\n                        this.aggregatedItemsKey.toString(), null, null,\n                        Plot.DEFAULT_LEGEND_ITEM_CIRCLE,\n                        this.aggregatedItemsPaint,\n                        Plot.DEFAULT_OUTLINE_STROKE,\n                        this.aggregatedItemsPaint));\n            }\n        }\n        return result;\n    }\n\n    \n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof MultiplePiePlot)) {\n            return false;\n        }\n        MultiplePiePlot that = (MultiplePiePlot) obj;\n        if (this.dataExtractOrder != that.dataExtractOrder) {\n            return false;\n        }\n        if (this.limit != that.limit) {\n            return false;\n        }\n        if (!this.aggregatedItemsKey.equals(that.aggregatedItemsKey)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.aggregatedItemsPaint,\n                that.aggregatedItemsPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.pieChart, that.pieChart)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        return true;\n    }\n\n    \n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writePaint(this.aggregatedItemsPaint, stream);\n    }\n\n    \n    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.aggregatedItemsPaint = SerialUtilities.readPaint(stream);\n        this.sectionPaints = new HashMap();\n    }\n\n\n}\n",
      "fixed_full_code": "\n\npackage org.jfree.chart.plot;\n\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Rectangle;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jfree.chart.ChartRenderingInfo;\nimport org.jfree.chart.JFreeChart;\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.title.TextTitle;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.chart.util.TableOrder;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.category.CategoryToPieDataset;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\nimport org.jfree.data.general.PieDataset;\n\n\npublic class MultiplePiePlot extends Plot implements Cloneable, Serializable { private static final long serialVersionUID = -355377800470807389L; private JFreeChart pieChart; private CategoryDataset dataset; private TableOrder dataExtractOrder; private double limit = 0.0; private Comparable aggregatedItemsKey; private transient Paint aggregatedItemsPaint; private transient Map sectionPaints; public MultiplePiePlot() {\n        this(null);\n    }\n\n    \n    public MultiplePiePlot(CategoryDataset dataset) {\n        super();\n        setDataset(dataset);\n        PiePlot piePlot = new PiePlot(null);\n        this.pieChart = new JFreeChart(piePlot);\n        this.pieChart.removeLegend();\n        this.dataExtractOrder = TableOrder.BY_COLUMN;\n        this.pieChart.setBackgroundPaint(null);\n        TextTitle seriesTitle = new TextTitle(\"Series Title\",\n                new Font(\"SansSerif\", Font.BOLD, 12));\n        seriesTitle.setPosition(RectangleEdge.BOTTOM);\n        this.pieChart.setTitle(seriesTitle);\n        this.aggregatedItemsKey = \"Other\";\n        this.aggregatedItemsPaint = Color.lightGray;\n        this.sectionPaints = new HashMap();\n    }\n\n    \n    public CategoryDataset getDataset() {\n        return this.dataset;\n    }\n\n    \n    public void setDataset(CategoryDataset dataset) {\n        \n        \n        if (this.dataset != null) {\n            this.dataset.removeChangeListener(this);\n        }\n\n        \n        this.dataset = dataset;\n        if (dataset != null) {\n            setDatasetGroup(dataset.getGroup());\n            dataset.addChangeListener(this);\n        }\n\n        \n        datasetChanged(new DatasetChangeEvent(this, dataset));\n    }\n\n    \n    public JFreeChart getPieChart() {\n        return this.pieChart;\n    }\n\n    \n    public void setPieChart(JFreeChart pieChart) {\n        if (pieChart == null) {\n            throw new IllegalArgumentException(\"Null 'pieChart' argument.\");\n        }\n        if (!(pieChart.getPlot() instanceof PiePlot)) {\n            throw new IllegalArgumentException(\"The 'pieChart' argument must \"\n                    + \"be a chart based on a PiePlot.\");\n        }\n        this.pieChart = pieChart;\n        fireChangeEvent();\n    }\n\n    \n    public TableOrder getDataExtractOrder() {\n        return this.dataExtractOrder;\n    }\n\n    \n    public void setDataExtractOrder(TableOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument\");\n        }\n        this.dataExtractOrder = order;\n        fireChangeEvent();\n    }\n\n    \n    public double getLimit() {\n        return this.limit;\n    }\n\n    \n    public void setLimit(double limit) {\n        this.limit = limit;\n        fireChangeEvent();\n    }\n\n    \n    public Comparable getAggregatedItemsKey() {\n        return this.aggregatedItemsKey;\n    }\n\n    \n    public void setAggregatedItemsKey(Comparable key) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        this.aggregatedItemsKey = key;\n        fireChangeEvent();\n    }\n\n    \n    public Paint getAggregatedItemsPaint() {\n        return this.aggregatedItemsPaint;\n    }\n\n    \n    public void setAggregatedItemsPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.aggregatedItemsPaint = paint;\n        fireChangeEvent();\n    }\n\n    \n    public String getPlotType() {\n        return \"Multiple Pie Plot\";\n         \n    }\n\n    \n    public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo info) {\n\n\n        \n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n        drawBackground(g2, area);\n        drawOutline(g2, area);\n\n        \n        if (DatasetUtilities.isEmptyOrNull(this.dataset)) {\n            drawNoDataMessage(g2, area);\n            return;\n        }\n\n        int pieCount = 0;\n        if (this.dataExtractOrder == TableOrder.BY_ROW) {\n            pieCount = this.dataset.getRowCount();\n        }\n        else {\n            pieCount = this.dataset.getColumnCount();\n        }\n\n        \n        int displayCols = (int) Math.ceil(Math.sqrt(pieCount));\n        int displayRows\n            = (int) Math.ceil((double) pieCount / (double) displayCols);\n\n        \n        if (displayCols > displayRows && area.getWidth() < area.getHeight()) {\n            int temp = displayCols;\n            displayCols = displayRows;\n            displayRows = temp;\n        }\n\n        prefetchSectionPaints();\n\n        int x = (int) area.getX();\n        int y = (int) area.getY();\n        int width = ((int) area.getWidth()) / displayCols;\n        int height = ((int) area.getHeight()) / displayRows;\n        int row = 0;\n        int column = 0;\n        int diff = (displayRows * displayCols) - pieCount;\n        int xoffset = 0;\n        Rectangle rect = new Rectangle();\n\n        for (int pieIndex = 0; pieIndex < pieCount; pieIndex++) {\n            rect.setBounds(x + xoffset + (width * column), y + (height * row),\n                    width, height);\n\n            String title = null;\n            if (this.dataExtractOrder == TableOrder.BY_ROW) {\n                title = this.dataset.getRowKey(pieIndex).toString();\n            }\n            else {\n                title = this.dataset.getColumnKey(pieIndex).toString();\n            }\n            this.pieChart.setTitle(title);\n\n            PieDataset piedataset = null;\n            PieDataset dd = new CategoryToPieDataset(this.dataset,\n                    this.dataExtractOrder, pieIndex);\n            if (this.limit > 0.0) {\n                piedataset = DatasetUtilities.createConsolidatedPieDataset(\n                        dd, this.aggregatedItemsKey, this.limit);\n            }\n            else {\n                piedataset = dd;\n            }\n            PiePlot piePlot = (PiePlot) this.pieChart.getPlot();\n            piePlot.setDataset(piedataset);\n            piePlot.setPieIndex(pieIndex);\n\n            \n            for (int i = 0; i < piedataset.getItemCount(); i++) {\n                Comparable key = piedataset.getKey(i);\n                Paint p;\n                if (key.equals(this.aggregatedItemsKey)) {\n                    p = this.aggregatedItemsPaint;\n                }\n                else {\n                    p = (Paint) this.sectionPaints.get(key);\n                }\n                piePlot.setSectionPaint(key, p);\n            }\n\n            ChartRenderingInfo subinfo = null;\n            if (info != null) {\n                subinfo = new ChartRenderingInfo();\n            }\n            this.pieChart.draw(g2, rect, subinfo);\n            if (info != null) {\n                info.getOwner().getEntityCollection().addAll(\n                        subinfo.getEntityCollection());\n                info.addSubplotInfo(subinfo.getPlotInfo());\n            }\n\n            ++column;\n            if (column == displayCols) {\n                column = 0;\n                ++row;\n\n                if (row == displayRows - 1 && diff != 0) {\n                    xoffset = (diff * width) / 2;\n                }\n            }\n        }\n\n    }\n\n    \n    private void prefetchSectionPaints() {\n\n        \n        \n        \n\n        PiePlot piePlot = (PiePlot) getPieChart().getPlot();\n\n        if (this.dataExtractOrder == TableOrder.BY_ROW) {\n            \n            for (int c = 0; c < this.dataset.getColumnCount(); c++) {\n                Comparable key = this.dataset.getColumnKey(c);\n                Paint p = piePlot.getSectionPaint(key);\n                if (p == null) {\n                    p = (Paint) this.sectionPaints.get(key);\n                    if (p == null) {\n                        p = getDrawingSupplier().getNextPaint();\n                    }\n                }\n                this.sectionPaints.put(key, p);\n            }\n        }\n        else {\n            \n            for (int r = 0; r < this.dataset.getRowCount(); r++) {\n                Comparable key = this.dataset.getRowKey(r);\n                Paint p = piePlot.getSectionPaint(key);\n                if (p == null) {\n                    p = (Paint) this.sectionPaints.get(key);\n                    if (p == null) {\n                        p = getDrawingSupplier().getNextPaint();\n                    }\n                }\n                this.sectionPaints.put(key, p);\n            }\n        }\n\n    }\n\n    \n    public LegendItemCollection getLegendItems() {\n\n        LegendItemCollection result = new LegendItemCollection();\n\n        if (this.dataset != null) {\n            List keys = null;\n\n            prefetchSectionPaints();\n            if (this.dataExtractOrder == TableOrder.BY_ROW) {\n                keys = this.dataset.getColumnKeys();\n            }\n            else if (this.dataExtractOrder == TableOrder.BY_COLUMN) {\n                keys = this.dataset.getRowKeys();\n            }\n\n            if (keys != null) {\n                int section = 0;\n                Iterator iterator = keys.iterator();\n                while (iterator.hasNext()) {\n                    Comparable key = (Comparable) iterator.next();\n                    String label = key.toString();\n                    String description = label;\n                    Paint paint = (Paint) this.sectionPaints.get(key);\n                    LegendItem item = new LegendItem(label, description,\n                            null, null, Plot.DEFAULT_LEGEND_ITEM_CIRCLE,\n                            paint, Plot.DEFAULT_OUTLINE_STROKE, paint);\n                    item.setDataset(getDataset());\n                    result.add(item);\n                    section++;\n                }\n            }\n            if (this.limit > 0.0) {\n                result.add(new LegendItem(this.aggregatedItemsKey.toString(),\n                        this.aggregatedItemsKey.toString(), null, null,\n                        Plot.DEFAULT_LEGEND_ITEM_CIRCLE,\n                        this.aggregatedItemsPaint,\n                        Plot.DEFAULT_OUTLINE_STROKE,\n                        this.aggregatedItemsPaint));\n            }\n        }\n        return result;\n    }\n\n    \n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof MultiplePiePlot)) {\n            return false;\n        }\n        MultiplePiePlot that = (MultiplePiePlot) obj;\n        if (this.dataExtractOrder != that.dataExtractOrder) {\n            return false;\n        }\n        if (this.limit != that.limit) {\n            return false;\n        }\n        if (!this.aggregatedItemsKey.equals(that.aggregatedItemsKey)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.aggregatedItemsPaint,\n                that.aggregatedItemsPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.pieChart, that.pieChart)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        return true;\n    }\n\n    \n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writePaint(this.aggregatedItemsPaint, stream);\n    }\n\n    \n    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.aggregatedItemsPaint = SerialUtilities.readPaint(stream);\n        this.sectionPaints = new HashMap();\n    }\n\n\n}\n",
      "buggy_signatures": [
        "public MultiplePiePlot(CategoryDataset dataset)",
        "public CategoryDataset getDataset()",
        "public void setDataset(CategoryDataset dataset)",
        "public JFreeChart getPieChart()",
        "public void setPieChart(JFreeChart pieChart)",
        "public TableOrder getDataExtractOrder()",
        "public void setDataExtractOrder(TableOrder order)",
        "public double getLimit()",
        "public void setLimit(double limit)",
        "public Comparable getAggregatedItemsKey()",
        "public void setAggregatedItemsKey(Comparable key)",
        "public Paint getAggregatedItemsPaint()",
        "public void setAggregatedItemsPaint(Paint paint)",
        "public String getPlotType()",
        "public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo info)",
        "private void prefetchSectionPaints()",
        "public LegendItemCollection getLegendItems()",
        "public boolean equals(Object obj)",
        "private void writeObject(ObjectOutputStream stream) throws IOException",
        "private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException"
      ],
      "fixed_signatures": [
        "public MultiplePiePlot(CategoryDataset dataset)",
        "public CategoryDataset getDataset()",
        "public void setDataset(CategoryDataset dataset)",
        "public JFreeChart getPieChart()",
        "public void setPieChart(JFreeChart pieChart)",
        "public TableOrder getDataExtractOrder()",
        "public void setDataExtractOrder(TableOrder order)",
        "public double getLimit()",
        "public void setLimit(double limit)",
        "public Comparable getAggregatedItemsKey()",
        "public void setAggregatedItemsKey(Comparable key)",
        "public Paint getAggregatedItemsPaint()",
        "public void setAggregatedItemsPaint(Paint paint)",
        "public String getPlotType()",
        "public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo info)",
        "private void prefetchSectionPaints()",
        "public LegendItemCollection getLegendItems()",
        "public boolean equals(Object obj)",
        "private void writeObject(ObjectOutputStream stream) throws IOException",
        "private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException"
      ],
      "methods": [
        {
          "buggy_method": "  public MultiplePiePlot(CategoryDataset dataset) {\n  super();\n  this.dataset = dataset;\n  PiePlot piePlot = new PiePlot(null);\n  this.pieChart = new JFreeChart(piePlot);\n  this.pieChart.removeLegend();\n  this.dataExtractOrder = TableOrder.BY_COLUMN;\n  this.pieChart.setBackgroundPaint(null);\n  TextTitle seriesTitle = new TextTitle(\"Series Title\",\n  new Font(\"SansSerif\", Font.BOLD, 12));\n  seriesTitle.setPosition(RectangleEdge.BOTTOM);\n  this.pieChart.setTitle(seriesTitle);\n  this.aggregatedItemsKey = \"Other\";\n  this.aggregatedItemsPaint = Color.lightGray;\n  this.sectionPaints = new HashMap();\n  }",
          "fixed_method": "  public MultiplePiePlot(CategoryDataset dataset) {\n  super();\n  setDataset(dataset);\n  PiePlot piePlot = new PiePlot(null);\n  this.pieChart = new JFreeChart(piePlot);\n  this.pieChart.removeLegend();\n  this.dataExtractOrder = TableOrder.BY_COLUMN;\n  this.pieChart.setBackgroundPaint(null);\n  TextTitle seriesTitle = new TextTitle(\"Series Title\",\n  new Font(\"SansSerif\", Font.BOLD, 12));\n  seriesTitle.setPosition(RectangleEdge.BOTTOM);\n  this.pieChart.setTitle(seriesTitle);\n  this.aggregatedItemsKey = \"Other\";\n  this.aggregatedItemsPaint = Color.lightGray;\n  this.sectionPaints = new HashMap();\n  }",
          "diff": [
            "@@ -142,7 +142,7 @@",
            "      */\n",
            "     public MultiplePiePlot(CategoryDataset dataset) {\n",
            "         super();\n",
            "-        this.dataset = dataset;\n",
            "+        setDataset(dataset);\n",
            "         PiePlot piePlot = new PiePlot(null);\n",
            "         this.pieChart = new JFreeChart(piePlot);\n",
            "         this.pieChart.removeLegend();\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
