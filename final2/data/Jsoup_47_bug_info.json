{
  "bug_id": "47",
  "failed_tests": {
    "org.jsoup.nodes.EntitiesTest": [
      {
        "methodName": "escapesGtInXmlAttributesButNotInHtml",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<<a title=\"[&lt;p>One&lt;]/p>\">One</a>> but was:<<a title=\"[<p>One<]/p>\">One</a>>",
        "fail_line": "        assertEquals(\"<a title=\\\"&lt;p>One&lt;/p>\\\">One</a>\", element.outerHtml());",
        "test_source": "",
        "stack": [
          "EntitiesTest.escapesGtInXmlAttributesButNotInHtml line 102"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/nodes/Entities.java",
      "buggy_full_code": "package org.jsoup.nodes;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.parser.Parser;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.CharsetEncoder;\nimport java.util.*;\n\n\npublic class Entities { public enum EscapeMode { xhtml(xhtmlByVal), base(baseByVal), extended(fullByVal); private Map<Character, String> map; EscapeMode(Map<Character, String> map) {\n            this.map = map;\n        }\n\n        public Map<Character, String> getMap() {\n            return map;\n        }\n    }\n\n    private static final Map<String, Character> full; private static final Map<Character, String> xhtmlByVal; private static final Map<String, Character> base; private static final Map<Character, String> baseByVal; private static final Map<Character, String> fullByVal; private Entities() {}\n\n    \n    public static boolean isNamedEntity(String name) {\n        return full.containsKey(name);\n    }\n\n    \n    public static boolean isBaseNamedEntity(String name) {\n        return base.containsKey(name);\n    }\n\n    \n    public static Character getCharacterByName(String name) {\n        return full.get(name);\n    }\n    \n    static String escape(String string, Document.OutputSettings out) {\n        StringBuilder accum = new StringBuilder(string.length() * 2);\n        escape(accum, string, out, false, false, false);\n        return accum.toString();\n    }\n\n    \n    static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n\n        boolean lastWasWhite = false;\n        boolean reachedNonWhite = false;\n        final EscapeMode escapeMode = out.escapeMode();\n        final CharsetEncoder encoder = out.encoder();\n        final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n        final Map<Character, String> map = escapeMode.getMap();\n        final int length = string.length();\n\n        int codePoint;\n        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n            codePoint = string.codePointAt(offset);\n\n            if (normaliseWhite) {\n                if (StringUtil.isWhitespace(codePoint)) {\n                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            \n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                \n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n                            accum.append(\"&#xa0;\");\n                        break;\n                    case '<':\n                        \n                        if (!inAttribute)\n                            accum.append(\"&lt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '>':\n                        if (!inAttribute)\n                            accum.append(\"&gt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '\"':\n                        if (inAttribute)\n                            accum.append(\"&quot;\");\n                        else\n                            accum.append(c);\n                        break;\n                    default:\n                        if (canEncode(coreCharset, c, encoder))\n                            accum.append(c);\n                        else if (map.containsKey(c))\n                            accum.append('&').append(map.get(c)).append(';');\n                        else\n                            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n                }\n            } else {\n                final String c = new String(Character.toChars(codePoint));\n                if (encoder.canEncode(c)) \n                    accum.append(c);\n                else\n                    accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n            }\n        }\n    }\n\n    static String unescape(String string) {\n        return unescape(string, false);\n    }\n\n    \n    static String unescape(String string, boolean strict) {\n        return Parser.unescapeEntities(string, strict);\n    }\n\n    \n\n    private static boolean canEncode(final CoreCharset charset, final char c, final CharsetEncoder fallback) {\n        \n        switch (charset) {\n            case ascii:\n                return c < 0x80;\n            case utf:\n                return true; \n            default:\n                return fallback.canEncode(c);\n        }\n    }\n\n    private enum CoreCharset { ascii, utf, fallback; private static CoreCharset byName(String name) {\n            if (name.equals(\"US-ASCII\"))\n                return ascii;\n            if (name.startsWith(\"UTF-\")) \n                return utf;\n            return fallback;\n        }\n    }\n\n\n    \n    private static final Object[][] xhtmlArray = { {\"quot\", 0x00022}, {\"amp\", 0x00026}, {\"lt\", 0x0003C}, {\"gt\", 0x0003E} }; static { xhtmlByVal = new HashMap<Character, String>(); base = loadEntities(\"entities-base.properties\"); baseByVal = toCharacterKey(base); full = loadEntities(\"entities-full.properties\"); fullByVal = toCharacterKey(full); for (Object[] entity : xhtmlArray) {\n            Character c = Character.valueOf((char) ((Integer) entity[1]).intValue());\n            xhtmlByVal.put(c, ((String) entity[0]));\n        }\n    }\n\n    private static Map<String, Character> loadEntities(String filename) {\n        Properties properties = new Properties();\n        Map<String, Character> entities = new HashMap<String, Character>();\n        try {\n            InputStream in = Entities.class.getResourceAsStream(filename);\n            properties.load(in);\n            in.close();\n        } catch (IOException e) {\n            throw new MissingResourceException(\"Error loading entities resource: \" + e.getMessage(), \"Entities\", filename);\n        }\n\n        for (Map.Entry entry: properties.entrySet()) {\n            Character val = Character.valueOf((char) Integer.parseInt((String) entry.getValue(), 16));\n            String name = (String) entry.getKey();\n            entities.put(name, val);\n        }\n        return entities;\n    }\n\n    private static Map<Character, String> toCharacterKey(Map<String, Character> inMap) {\n        Map<Character, String> outMap = new HashMap<Character, String>();\n        for (Map.Entry<String, Character> entry: inMap.entrySet()) {\n            Character character = entry.getValue();\n            String name = entry.getKey();\n\n            if (outMap.containsKey(character)) {\n                \n                if (name.toLowerCase().equals(name))\n                    outMap.put(character, name);\n            } else {\n                outMap.put(character, name);\n            }\n        }\n        return outMap;\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.nodes;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.parser.Parser;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.CharsetEncoder;\nimport java.util.*;\n\n\npublic class Entities { public enum EscapeMode { xhtml(xhtmlByVal), base(baseByVal), extended(fullByVal); private Map<Character, String> map; EscapeMode(Map<Character, String> map) {\n            this.map = map;\n        }\n\n        public Map<Character, String> getMap() {\n            return map;\n        }\n    }\n\n    private static final Map<String, Character> full; private static final Map<Character, String> xhtmlByVal; private static final Map<String, Character> base; private static final Map<Character, String> baseByVal; private static final Map<Character, String> fullByVal; private Entities() {}\n\n    \n    public static boolean isNamedEntity(String name) {\n        return full.containsKey(name);\n    }\n\n    \n    public static boolean isBaseNamedEntity(String name) {\n        return base.containsKey(name);\n    }\n\n    \n    public static Character getCharacterByName(String name) {\n        return full.get(name);\n    }\n    \n    static String escape(String string, Document.OutputSettings out) {\n        StringBuilder accum = new StringBuilder(string.length() * 2);\n        escape(accum, string, out, false, false, false);\n        return accum.toString();\n    }\n\n    \n    static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n\n        boolean lastWasWhite = false;\n        boolean reachedNonWhite = false;\n        final EscapeMode escapeMode = out.escapeMode();\n        final CharsetEncoder encoder = out.encoder();\n        final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n        final Map<Character, String> map = escapeMode.getMap();\n        final int length = string.length();\n\n        int codePoint;\n        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n            codePoint = string.codePointAt(offset);\n\n            if (normaliseWhite) {\n                if (StringUtil.isWhitespace(codePoint)) {\n                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            \n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                \n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n                            accum.append(\"&#xa0;\");\n                        break;\n                    case '<':\n                        \n                        if (!inAttribute || escapeMode == EscapeMode.xhtml)\n                            accum.append(\"&lt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '>':\n                        if (!inAttribute)\n                            accum.append(\"&gt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '\"':\n                        if (inAttribute)\n                            accum.append(\"&quot;\");\n                        else\n                            accum.append(c);\n                        break;\n                    default:\n                        if (canEncode(coreCharset, c, encoder))\n                            accum.append(c);\n                        else if (map.containsKey(c))\n                            accum.append('&').append(map.get(c)).append(';');\n                        else\n                            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n                }\n            } else {\n                final String c = new String(Character.toChars(codePoint));\n                if (encoder.canEncode(c)) \n                    accum.append(c);\n                else\n                    accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n            }\n        }\n    }\n\n    static String unescape(String string) {\n        return unescape(string, false);\n    }\n\n    \n    static String unescape(String string, boolean strict) {\n        return Parser.unescapeEntities(string, strict);\n    }\n\n    \n\n    private static boolean canEncode(final CoreCharset charset, final char c, final CharsetEncoder fallback) {\n        \n        switch (charset) {\n            case ascii:\n                return c < 0x80;\n            case utf:\n                return true; \n            default:\n                return fallback.canEncode(c);\n        }\n    }\n\n    private enum CoreCharset { ascii, utf, fallback; private static CoreCharset byName(String name) {\n            if (name.equals(\"US-ASCII\"))\n                return ascii;\n            if (name.startsWith(\"UTF-\")) \n                return utf;\n            return fallback;\n        }\n    }\n\n\n    \n    private static final Object[][] xhtmlArray = { {\"quot\", 0x00022}, {\"amp\", 0x00026}, {\"lt\", 0x0003C}, {\"gt\", 0x0003E} }; static { xhtmlByVal = new HashMap<Character, String>(); base = loadEntities(\"entities-base.properties\"); baseByVal = toCharacterKey(base); full = loadEntities(\"entities-full.properties\"); fullByVal = toCharacterKey(full); for (Object[] entity : xhtmlArray) {\n            Character c = Character.valueOf((char) ((Integer) entity[1]).intValue());\n            xhtmlByVal.put(c, ((String) entity[0]));\n        }\n    }\n\n    private static Map<String, Character> loadEntities(String filename) {\n        Properties properties = new Properties();\n        Map<String, Character> entities = new HashMap<String, Character>();\n        try {\n            InputStream in = Entities.class.getResourceAsStream(filename);\n            properties.load(in);\n            in.close();\n        } catch (IOException e) {\n            throw new MissingResourceException(\"Error loading entities resource: \" + e.getMessage(), \"Entities\", filename);\n        }\n\n        for (Map.Entry entry: properties.entrySet()) {\n            Character val = Character.valueOf((char) Integer.parseInt((String) entry.getValue(), 16));\n            String name = (String) entry.getKey();\n            entities.put(name, val);\n        }\n        return entities;\n    }\n\n    private static Map<Character, String> toCharacterKey(Map<String, Character> inMap) {\n        Map<Character, String> outMap = new HashMap<Character, String>();\n        for (Map.Entry<String, Character> entry: inMap.entrySet()) {\n            Character character = entry.getValue();\n            String name = entry.getKey();\n\n            if (outMap.containsKey(character)) {\n                \n                if (name.toLowerCase().equals(name))\n                    outMap.put(character, name);\n            } else {\n                outMap.put(character, name);\n            }\n        }\n        return outMap;\n    }\n}\n",
      "buggy_signatures": [
        "public class Entities { public enum EscapeMode { xhtml(xhtmlByVal), base(baseByVal), extended(fullByVal); private Map<Character, String> map; EscapeMode(Map<Character, String> map)",
        "public Map<Character, String> getMap()",
        "private static final Map<String, Character> full; private static final Map<Character, String> xhtmlByVal; private static final Map<String, Character> base; private static final Map<Character, String> baseByVal; private static final Map<Character, String> fullByVal; private Entities()",
        "public static boolean isNamedEntity(String name)",
        "public static boolean isBaseNamedEntity(String name)",
        "public static Character getCharacterByName(String name)",
        "static String escape(String string, Document.OutputSettings out)",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite)",
        "static String unescape(String string)",
        "static String unescape(String string, boolean strict)",
        "private static boolean canEncode(final CoreCharset charset, final char c, final CharsetEncoder fallback)",
        "private enum CoreCharset { ascii, utf, fallback; private static CoreCharset byName(String name)",
        "private static Map<String, Character> loadEntities(String filename)",
        "private static Map<Character, String> toCharacterKey(Map<String, Character> inMap)"
      ],
      "fixed_signatures": [
        "public class Entities { public enum EscapeMode { xhtml(xhtmlByVal), base(baseByVal), extended(fullByVal); private Map<Character, String> map; EscapeMode(Map<Character, String> map)",
        "public Map<Character, String> getMap()",
        "private static final Map<String, Character> full; private static final Map<Character, String> xhtmlByVal; private static final Map<String, Character> base; private static final Map<Character, String> baseByVal; private static final Map<Character, String> fullByVal; private Entities()",
        "public static boolean isNamedEntity(String name)",
        "public static boolean isBaseNamedEntity(String name)",
        "public static Character getCharacterByName(String name)",
        "static String escape(String string, Document.OutputSettings out)",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite)",
        "static String unescape(String string)",
        "static String unescape(String string, boolean strict)",
        "private static boolean canEncode(final CoreCharset charset, final char c, final CharsetEncoder fallback)",
        "private enum CoreCharset { ascii, utf, fallback; private static CoreCharset byName(String name)",
        "private static Map<String, Character> loadEntities(String filename)",
        "private static Map<Character, String> toCharacterKey(Map<String, Character> inMap)"
      ],
      "methods": [
        {
          "buggy_method": "  static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n\n  boolean lastWasWhite = false;\n  boolean reachedNonWhite = false;\n  final EscapeMode escapeMode = out.escapeMode();\n  final CharsetEncoder encoder = out.encoder();\n  final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n  final Map<Character, String> map = escapeMode.getMap();\n  final int length = string.length();\n\n  int codePoint;\n  for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n  codePoint = string.codePointAt(offset);\n\n  if (normaliseWhite) {\n  if (StringUtil.isWhitespace(codePoint)) {\n  if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n  continue;\n  accum.append(' ');\n  lastWasWhite = true;\n  continue;\n  } else {\n  lastWasWhite = false;\n  reachedNonWhite = true;\n  }\n  }\n  \n  if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n  final char c = (char) codePoint;\n  \n  switch (c) {\n  case '&':\n  accum.append(\"&amp;\");\n  break;\n  case 0xA0:\n  if (escapeMode != EscapeMode.xhtml)\n  accum.append(\"&nbsp;\");\n  else\n  accum.append(\"&#xa0;\");\n  break;\n  case '<':\n  \n  if (!inAttribute)\n  accum.append(\"&lt;\");\n  else\n  accum.append(c);\n  break;\n  case '>':\n  if (!inAttribute)\n  accum.append(\"&gt;\");\n  else\n  accum.append(c);\n  break;\n  case '\"':\n  if (inAttribute)\n  accum.append(\"&quot;\");\n  else\n  accum.append(c);\n  break;\n  default:\n  if (canEncode(coreCharset, c, encoder))\n  accum.append(c);\n  else if (map.containsKey(c))\n  accum.append('&').append(map.get(c)).append(';');\n  else\n  accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n  }\n  } else {\n  final String c = new String(Character.toChars(codePoint));\n  if (encoder.canEncode(c)) \n  accum.append(c);\n  else\n  accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n  }\n  }\n  }",
          "fixed_method": "  static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n\n  boolean lastWasWhite = false;\n  boolean reachedNonWhite = false;\n  final EscapeMode escapeMode = out.escapeMode();\n  final CharsetEncoder encoder = out.encoder();\n  final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n  final Map<Character, String> map = escapeMode.getMap();\n  final int length = string.length();\n\n  int codePoint;\n  for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n  codePoint = string.codePointAt(offset);\n\n  if (normaliseWhite) {\n  if (StringUtil.isWhitespace(codePoint)) {\n  if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n  continue;\n  accum.append(' ');\n  lastWasWhite = true;\n  continue;\n  } else {\n  lastWasWhite = false;\n  reachedNonWhite = true;\n  }\n  }\n  \n  if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n  final char c = (char) codePoint;\n  \n  switch (c) {\n  case '&':\n  accum.append(\"&amp;\");\n  break;\n  case 0xA0:\n  if (escapeMode != EscapeMode.xhtml)\n  accum.append(\"&nbsp;\");\n  else\n  accum.append(\"&#xa0;\");\n  break;\n  case '<':\n  \n  if (!inAttribute || escapeMode == EscapeMode.xhtml)\n  accum.append(\"&lt;\");\n  else\n  accum.append(c);\n  break;\n  case '>':\n  if (!inAttribute)\n  accum.append(\"&gt;\");\n  else\n  accum.append(c);\n  break;\n  case '\"':\n  if (inAttribute)\n  accum.append(\"&quot;\");\n  else\n  accum.append(c);\n  break;\n  default:\n  if (canEncode(coreCharset, c, encoder))\n  accum.append(c);\n  else if (map.containsKey(c))\n  accum.append('&').append(map.get(c)).append(';');\n  else\n  accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n  }\n  } else {\n  final String c = new String(Character.toChars(codePoint));\n  if (encoder.canEncode(c)) \n  accum.append(c);\n  else\n  accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n  }\n  }\n  }",
          "diff": [
            "@@ -119,7 +119,7 @@",
            "                         break;\n",
            "                     case '<':\n",
            "                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n",
            "-                        if (!inAttribute)\n",
            "+                        if (!inAttribute || escapeMode == EscapeMode.xhtml)\n",
            "                             accum.append(\"&lt;\");\n",
            "                         else\n",
            "                             accum.append(c);\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
