{
  "bug_id": "11",
  "failed_tests": {
    "org.jsoup.select.SelectorTest": [
      {
        "methodName": "notAll",
        "error": "org.jsoup.select.Selector$SelectorParseException",
        "message": "Could not parse query ':not(p)': unexpected token at ':not(p)'",
        "fail_line": "        Elements el1 = doc.body().select(\":not(p)\"); // should just be the span",
        "test_source": "",
        "stack": [
          "Selector.findElements line 182, Selector.select line 111, Selector.select line 84, Element.select line 199, SelectorTest.notAll line 559"
        ]
      },
      {
        "methodName": "testPseudoHas",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<3> but was:<0>",
        "fail_line": "        assertEquals(3, els1.size()); // body, div, dib",
        "test_source": "",
        "stack": [
          "SelectorTest.testPseudoHas line 424"
        ]
      },
      {
        "methodName": "notClass",
        "error": "org.jsoup.select.Selector$SelectorParseException",
        "message": "Could not parse query 'div:not(.left)': unexpected token at ':not(.left)'",
        "fail_line": "        Elements el1 = doc.select(\"div:not(.left)\");",
        "test_source": "",
        "stack": [
          "Selector.findElements line 182, Selector.select line 128, Selector.select line 84, Element.select line 199, SelectorTest.notClass line 568"
        ]
      },
      {
        "methodName": "notParas",
        "error": "org.jsoup.select.Selector$SelectorParseException",
        "message": "Could not parse query 'p:not([id=1])': unexpected token at ':not([id=1])'",
        "fail_line": "        Elements el1 = doc.select(\"p:not([id=1])\");",
        "test_source": "",
        "stack": [
          "Selector.findElements line 182, Selector.select line 128, Selector.select line 84, Element.select line 199, SelectorTest.notParas line 545"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/select/Selector.java",
      "buggy_full_code": "package org.jsoup.select;\n\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.parser.TokenQueue;\n\nimport java.util.Collection;\nimport java.util.LinkedHashSet;\n\n\npublic class Selector { private final static String[] combinators = {\",\", \">\", \"+\", \"~\", \" \"}; private final Element root; private final LinkedHashSet<Element> elements; private final String query; private final TokenQueue tq; private Selector(String query, Element root) {\n        Validate.notNull(query);\n        query = query.trim();\n        Validate.notEmpty(query);\n        Validate.notNull(root);\n\n        this.elements = new LinkedHashSet<Element>();\n        this.query = query;\n        this.root = root;\n        this.tq = new TokenQueue(query);\n    }\n\n    \n    public static Elements select(String query, Element root) {\n        return new Selector(query, root).select();\n    }\n\n    \n    public static Elements select(String query, Iterable<Element> roots) {\n        Validate.notEmpty(query);\n        Validate.notNull(roots);\n        LinkedHashSet<Element> elements = new LinkedHashSet<Element>();\n\n        for (Element root : roots) {\n            elements.addAll(select(query, root));\n        }\n        return new Elements(elements);\n    }\n\n    private Elements select() {\n        tq.consumeWhitespace();\n        \n        if (tq.matchesAny(combinators)) { \n            elements.add(root);\n            combinator(tq.consume().toString());\n        } else {\n            addElements(findElements()); \n        }            \n               \n        while (!tq.isEmpty()) {\n            \n            boolean seenWhite = tq.consumeWhitespace();\n            \n            if (tq.matchChomp(\",\")) { \n                while (!tq.isEmpty()) {\n                    String subQuery = tq.chompTo(\",\");\n                    elements.addAll(select(subQuery, root));\n                }\n            } else if (tq.matchesAny(combinators)) {\n                combinator(tq.consume().toString());\n            } else if (seenWhite) {\n                combinator(\" \");\n            } else { \n                Elements candidates = findElements(); \n                intersectElements(filterForSelf(elements, candidates));\n            }\n        }\n        return new Elements(elements);\n    }\n    \n    private void combinator(String combinator) {\n        tq.consumeWhitespace();\n        String subQuery = tq.consumeToAny(combinators); \n        \n        Elements output;\n        if (combinator.equals(\">\"))\n            output = filterForChildren(elements, select(subQuery, elements));\n        else if (combinator.equals(\" \"))\n            output = filterForDescendants(elements, select(subQuery, elements));\n        else if (combinator.equals(\"+\"))\n            output = filterForAdjacentSiblings(elements, select(subQuery, root));\n        else if (combinator.equals(\"~\"))\n            output = filterForGeneralSiblings(elements, select(subQuery, root));\n        else\n            throw new IllegalStateException(\"Unknown combinator: \" + combinator);\n        \n        elements.clear(); elements.addAll(output);\n    }\n    \n    private Elements findElements() {\n        if (tq.matchChomp(\"#\")) {\n            return byId();\n        } else if (tq.matchChomp(\".\")) {\n            return byClass();\n        } else if (tq.matchesWord()) {\n            return byTag();\n        } else if (tq.matches(\"[\")) {\n            return byAttribute();\n        } else if (tq.matchChomp(\"*\")) {\n            return allElements();\n        } else if (tq.matchChomp(\":lt(\")) {\n            return indexLessThan();\n        } else if (tq.matchChomp(\":gt(\")) {\n            return indexGreaterThan();\n        } else if (tq.matchChomp(\":eq(\")) {\n            return indexEquals();\n        } else if (tq.matches(\":has(\")) {\n            return has();\n        } else if (tq.matches(\":contains(\")) {\n            return contains(false);\n        } else if (tq.matches(\":containsOwn(\")) {\n            return contains(true);\n        } else if (tq.matches(\":matches(\")) {\n            return matches(false);\n        } else if (tq.matches(\":matchesOwn(\")) {\n            return matches(true);\n        } else { \n            throw new SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n        }\n    }\n    \n    private void addElements(Collection<Element> add) {\n        elements.addAll(add);\n    }\n    \n    private void intersectElements(Collection<Element> intersect) {\n        elements.retainAll(intersect);\n    }\n\n    private Elements byId() {\n        String id = tq.consumeCssIdentifier();\n        Validate.notEmpty(id);\n\n        Element found = root.getElementById(id);\n        Elements byId = new Elements();\n        if(found != null)\n            byId.add(found);\n        return byId;\n    }\n\n    private Elements byClass() {\n        String className = tq.consumeCssIdentifier();\n        Validate.notEmpty(className);\n\n        return root.getElementsByClass(className);\n    }\n\n    private Elements byTag() {\n        String tagName = tq.consumeElementSelector();\n        Validate.notEmpty(tagName);\n        \n        \n        if (tagName.contains(\"|\"))\n            tagName = tagName.replace(\"|\", \":\");\n        return root.getElementsByTag(tagName);\n    }\n\n    private Elements byAttribute() {\n        TokenQueue cq = new TokenQueue(tq.chompBalanced('[', ']')); \n        String key = cq.consumeToAny(\"=\", \"!=\", \"^=\", \"$=\", \"*=\", \"~=\"); \n        Validate.notEmpty(key);\n        cq.consumeWhitespace();\n\n        if (cq.isEmpty()) {\n            return key.startsWith(\"^\") ? root.getElementsByAttributeStarting(key.substring(1)) : root.getElementsByAttribute(key);\n        } else {\n            if (cq.matchChomp(\"=\"))\n                return root.getElementsByAttributeValue(key, cq.remainder());\n\n            else if (cq.matchChomp(\"!=\"))\n                return root.getElementsByAttributeValueNot(key, cq.remainder());\n\n            else if (cq.matchChomp(\"^=\"))\n                return root.getElementsByAttributeValueStarting(key, cq.remainder());\n\n            else if (cq.matchChomp(\"$=\"))\n                return root.getElementsByAttributeValueEnding(key, cq.remainder());\n\n            else if (cq.matchChomp(\"*=\"))\n                return root.getElementsByAttributeValueContaining(key, cq.remainder());\n            \n            else if (cq.matchChomp(\"~=\"))\n                return root.getElementsByAttributeValueMatching(key, cq.remainder());\n            \n            else\n                throw new SelectorParseException(\"Could not parse attribute query '%s': unexpected token at '%s'\", query, cq.remainder());\n        }\n    }\n\n    private Elements allElements() {\n        return root.getAllElements();\n    }\n    \n    \n    private Elements indexLessThan() {\n        return root.getElementsByIndexLessThan(consumeIndex());\n    }\n    \n    private Elements indexGreaterThan() {\n        return root.getElementsByIndexGreaterThan(consumeIndex());\n    }\n    \n    private Elements indexEquals() {\n        return root.getElementsByIndexEquals(consumeIndex());\n    }\n\n    private int consumeIndex() {\n        String indexS = tq.chompTo(\")\").trim();\n        Validate.isTrue(StringUtil.isNumeric(indexS), \"Index must be numeric\");\n        return Integer.parseInt(indexS);\n    }\n\n    \n    private Elements has() {\n        tq.consume(\":has\");\n        String subQuery = tq.chompBalanced('(',')');\n        Validate.notEmpty(subQuery, \":has(el) subselect must not be empty\");\n\n        return filterForParentsOfDescendants(elements, select(subQuery, elements));\n    }\n    \n    \n    private Elements contains(boolean own) {\n        tq.consume(own ? \":containsOwn\" : \":contains\");\n        String searchText = TokenQueue.unescape(tq.chompBalanced('(',')'));\n        Validate.notEmpty(searchText, \":contains(text) query must not be empty\");\n        \n        return own ? root.getElementsContainingOwnText(searchText) : root.getElementsContainingText(searchText);\n    }\n    \n    \n    private Elements matches(boolean own) {\n        tq.consume(own? \":matchesOwn\" : \":matches\");\n        String regex = tq.chompBalanced('(', ')'); \n        Validate.notEmpty(regex, \":matches(regex) query must not be empty\");\n        \n        return own ? root.getElementsMatchingOwnText(regex) : root.getElementsMatchingText(regex);\n    }\n\n    \n\n\n    \n    private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates) {\n        Elements children = new Elements();\n        CHILD: for (Element c : candidates) {\n            for (Element p : parents) {\n                if (c.parent() != null && c.parent().equals(p)) {\n                    children.add(c);\n                    continue CHILD;\n                }\n            }\n        }\n        return children;\n    }\n    \n    \n    \n    private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates) {\n        Elements children = new Elements();\n        CHILD: for (Element c : candidates) {\n            for (Element p : parents) {\n                if (c.equals(p)) {\n                    continue CHILD;\n                }\n            }\n            children.add(c);\n        }\n        return children;\n    }\n\n    \n    private static Elements filterForParentsOfDescendants(Collection<Element> parents, Collection<Element> children) {\n        Elements filteredParents = new Elements();\n        for (Element p : parents) {\n            for (Element c : children) {\n                if (c.parents().contains(p)) {\n                    filteredParents.add(p);\n                }\n            }\n        }\n        return filteredParents;\n    }\n    \n    \n    private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates) {\n        Elements siblings = new Elements();\n        SIBLING: for (Element c: candidates) {\n            for (Element e: elements) {\n                if (!e.parent().equals(c.parent()))\n                    continue;\n                Element previousSib = c.previousElementSibling();\n                if (previousSib != null && previousSib.equals(e)) {\n                    siblings.add(c);\n                    continue SIBLING;\n                }\n            }\n        }\n        return siblings;\n    }\n    \n    \n    private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates) {\n        Elements output = new Elements();\n        SIBLING: for (Element c: candidates) {\n            for (Element e: elements) {\n                if (!e.parent().equals(c.parent()))\n                    continue;\n                int ePos = e.elementSiblingIndex();\n                int cPos = c.elementSiblingIndex();\n                if (cPos > ePos) {\n                    output.add(c);\n                    continue SIBLING;\n                }\n            }\n        }\n        return output;\n    }\n    \n    \n    private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates) {\n        Elements children = new Elements();\n        CHILD: for (Element c : candidates) {\n            for (Element p : parents) {\n                if (c.equals(p)) {\n                    children.add(c);\n                    continue CHILD;\n                }\n            }   \n        }\n        return children;\n    }\n\n    \n\n    public static class SelectorParseException extends IllegalStateException { public SelectorParseException(String msg, Object... params) {\n            super(String.format(msg, params));\n        }\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.select;\n\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.parser.TokenQueue;\n\nimport java.util.Collection;\nimport java.util.LinkedHashSet;\n\n\npublic class Selector { private final static String[] combinators = {\",\", \">\", \"+\", \"~\", \" \"}; private final Element root; private final LinkedHashSet<Element> elements; private final String query; private final TokenQueue tq; private Selector(String query, Element root) {\n        Validate.notNull(query);\n        query = query.trim();\n        Validate.notEmpty(query);\n        Validate.notNull(root);\n\n        this.elements = new LinkedHashSet<Element>();\n        this.query = query;\n        this.root = root;\n        this.tq = new TokenQueue(query);\n    }\n\n    \n    public static Elements select(String query, Element root) {\n        return new Selector(query, root).select();\n    }\n\n    \n    public static Elements select(String query, Iterable<Element> roots) {\n        Validate.notEmpty(query);\n        Validate.notNull(roots);\n        LinkedHashSet<Element> elements = new LinkedHashSet<Element>();\n\n        for (Element root : roots) {\n            elements.addAll(select(query, root));\n        }\n        return new Elements(elements);\n    }\n\n    private Elements select() {\n        tq.consumeWhitespace();\n        \n        if (tq.matchesAny(combinators)) { \n            elements.add(root);\n            combinator(tq.consume().toString());\n        } else if (tq.matches(\":has(\")) {\n            elements.addAll(root.getAllElements());\n        } else {\n            addElements(findElements()); \n        }            \n               \n        while (!tq.isEmpty()) {\n            \n            boolean seenWhite = tq.consumeWhitespace();\n            \n            if (tq.matchChomp(\",\")) { \n                while (!tq.isEmpty()) {\n                    String subQuery = tq.chompTo(\",\");\n                    elements.addAll(select(subQuery, root));\n                }\n            } else if (tq.matchesAny(combinators)) {\n                combinator(tq.consume().toString());\n            } else if (seenWhite) {\n                combinator(\" \");\n            } else { \n                Elements candidates = findElements(); \n                intersectElements(filterForSelf(elements, candidates));\n            }\n        }\n        return new Elements(elements);\n    }\n    \n    private void combinator(String combinator) {\n        tq.consumeWhitespace();\n        String subQuery = tq.consumeToAny(combinators); \n        \n        Elements output;\n        if (combinator.equals(\">\"))\n            output = filterForChildren(elements, select(subQuery, elements));\n        else if (combinator.equals(\" \"))\n            output = filterForDescendants(elements, select(subQuery, elements));\n        else if (combinator.equals(\"+\"))\n            output = filterForAdjacentSiblings(elements, select(subQuery, root));\n        else if (combinator.equals(\"~\"))\n            output = filterForGeneralSiblings(elements, select(subQuery, root));\n        else\n            throw new IllegalStateException(\"Unknown combinator: \" + combinator);\n        \n        elements.clear(); elements.addAll(output);\n    }\n    \n    private Elements findElements() {\n        if (tq.matchChomp(\"#\")) {\n            return byId();\n        } else if (tq.matchChomp(\".\")) {\n            return byClass();\n        } else if (tq.matchesWord()) {\n            return byTag();\n        } else if (tq.matches(\"[\")) {\n            return byAttribute();\n        } else if (tq.matchChomp(\"*\")) {\n            return allElements();\n        } else if (tq.matchChomp(\":lt(\")) {\n            return indexLessThan();\n        } else if (tq.matchChomp(\":gt(\")) {\n            return indexGreaterThan();\n        } else if (tq.matchChomp(\":eq(\")) {\n            return indexEquals();\n        } else if (tq.matches(\":has(\")) {\n            return has();\n        } else if (tq.matches(\":contains(\")) {\n            return contains(false);\n        } else if (tq.matches(\":containsOwn(\")) {\n            return contains(true);\n        } else if (tq.matches(\":matches(\")) {\n            return matches(false);\n        } else if (tq.matches(\":matchesOwn(\")) {\n            return matches(true);\n        } else if (tq.matches(\":not(\")) {\n            return not();\n        } else { \n            throw new SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n        }\n    }\n    \n    private void addElements(Collection<Element> add) {\n        elements.addAll(add);\n    }\n    \n    private void intersectElements(Collection<Element> intersect) {\n        elements.retainAll(intersect);\n    }\n\n    private Elements byId() {\n        String id = tq.consumeCssIdentifier();\n        Validate.notEmpty(id);\n\n        Element found = root.getElementById(id);\n        Elements byId = new Elements();\n        if(found != null)\n            byId.add(found);\n        return byId;\n    }\n\n    private Elements byClass() {\n        String className = tq.consumeCssIdentifier();\n        Validate.notEmpty(className);\n\n        return root.getElementsByClass(className);\n    }\n\n    private Elements byTag() {\n        String tagName = tq.consumeElementSelector();\n        Validate.notEmpty(tagName);\n        \n        \n        if (tagName.contains(\"|\"))\n            tagName = tagName.replace(\"|\", \":\");\n        return root.getElementsByTag(tagName);\n    }\n\n    private Elements byAttribute() {\n        TokenQueue cq = new TokenQueue(tq.chompBalanced('[', ']')); \n        String key = cq.consumeToAny(\"=\", \"!=\", \"^=\", \"$=\", \"*=\", \"~=\"); \n        Validate.notEmpty(key);\n        cq.consumeWhitespace();\n\n        if (cq.isEmpty()) {\n            return key.startsWith(\"^\") ? root.getElementsByAttributeStarting(key.substring(1)) : root.getElementsByAttribute(key);\n        } else {\n            if (cq.matchChomp(\"=\"))\n                return root.getElementsByAttributeValue(key, cq.remainder());\n\n            else if (cq.matchChomp(\"!=\"))\n                return root.getElementsByAttributeValueNot(key, cq.remainder());\n\n            else if (cq.matchChomp(\"^=\"))\n                return root.getElementsByAttributeValueStarting(key, cq.remainder());\n\n            else if (cq.matchChomp(\"$=\"))\n                return root.getElementsByAttributeValueEnding(key, cq.remainder());\n\n            else if (cq.matchChomp(\"*=\"))\n                return root.getElementsByAttributeValueContaining(key, cq.remainder());\n            \n            else if (cq.matchChomp(\"~=\"))\n                return root.getElementsByAttributeValueMatching(key, cq.remainder());\n            \n            else\n                throw new SelectorParseException(\"Could not parse attribute query '%s': unexpected token at '%s'\", query, cq.remainder());\n        }\n    }\n\n    private Elements allElements() {\n        return root.getAllElements();\n    }\n    \n    \n    private Elements indexLessThan() {\n        return root.getElementsByIndexLessThan(consumeIndex());\n    }\n    \n    private Elements indexGreaterThan() {\n        return root.getElementsByIndexGreaterThan(consumeIndex());\n    }\n    \n    private Elements indexEquals() {\n        return root.getElementsByIndexEquals(consumeIndex());\n    }\n\n    private int consumeIndex() {\n        String indexS = tq.chompTo(\")\").trim();\n        Validate.isTrue(StringUtil.isNumeric(indexS), \"Index must be numeric\");\n        return Integer.parseInt(indexS);\n    }\n\n    \n    private Elements has() {\n        tq.consume(\":has\");\n        String subQuery = tq.chompBalanced('(',')');\n        Validate.notEmpty(subQuery, \":has(el) subselect must not be empty\");\n\n        return filterForParentsOfDescendants(elements, select(subQuery, elements));\n    }\n    \n    \n    private Elements contains(boolean own) {\n        tq.consume(own ? \":containsOwn\" : \":contains\");\n        String searchText = TokenQueue.unescape(tq.chompBalanced('(',')'));\n        Validate.notEmpty(searchText, \":contains(text) query must not be empty\");\n        \n        return own ? root.getElementsContainingOwnText(searchText) : root.getElementsContainingText(searchText);\n    }\n    \n    \n    private Elements matches(boolean own) {\n        tq.consume(own? \":matchesOwn\" : \":matches\");\n        String regex = tq.chompBalanced('(', ')'); \n        Validate.notEmpty(regex, \":matches(regex) query must not be empty\");\n        \n        return own ? root.getElementsMatchingOwnText(regex) : root.getElementsMatchingText(regex);\n    }\n\n    \n    private Elements not() {\n        tq.consume(\":not\");\n        String subQuery = tq.chompBalanced('(', ')');\n        Validate.notEmpty(subQuery, \":not(selector) subselect must not be empty\");\n\n        return filterOut(root.getAllElements(), select(subQuery, root));\n    }\n\n    \n    private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates) {\n        Elements children = new Elements();\n        CHILD: for (Element c : candidates) {\n            for (Element p : parents) {\n                if (c.parent() != null && c.parent().equals(p)) {\n                    children.add(c);\n                    continue CHILD;\n                }\n            }\n        }\n        return children;\n    }\n    \n    \n    \n    private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates) {\n        Elements children = new Elements();\n        CHILD: for (Element c : candidates) {\n            for (Element p : parents) {\n                if (c.equals(p)) {\n                    continue CHILD;\n                }\n            }\n            children.add(c);\n        }\n        return children;\n    }\n\n    \n    private static Elements filterForParentsOfDescendants(Collection<Element> parents, Collection<Element> children) {\n        Elements filteredParents = new Elements();\n        for (Element p : parents) {\n            for (Element c : children) {\n                if (c.parents().contains(p)) {\n                    filteredParents.add(p);\n                }\n            }\n        }\n        return filteredParents;\n    }\n    \n    \n    private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates) {\n        Elements siblings = new Elements();\n        SIBLING: for (Element c: candidates) {\n            for (Element e: elements) {\n                if (!e.parent().equals(c.parent()))\n                    continue;\n                Element previousSib = c.previousElementSibling();\n                if (previousSib != null && previousSib.equals(e)) {\n                    siblings.add(c);\n                    continue SIBLING;\n                }\n            }\n        }\n        return siblings;\n    }\n    \n    \n    private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates) {\n        Elements output = new Elements();\n        SIBLING: for (Element c: candidates) {\n            for (Element e: elements) {\n                if (!e.parent().equals(c.parent()))\n                    continue;\n                int ePos = e.elementSiblingIndex();\n                int cPos = c.elementSiblingIndex();\n                if (cPos > ePos) {\n                    output.add(c);\n                    continue SIBLING;\n                }\n            }\n        }\n        return output;\n    }\n    \n    \n    private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates) {\n        Elements children = new Elements();\n        CHILD: for (Element c : candidates) {\n            for (Element p : parents) {\n                if (c.equals(p)) {\n                    children.add(c);\n                    continue CHILD;\n                }\n            }   \n        }\n        return children;\n    }\n\n    \n    static Elements filterOut(Collection<Element> elements, Collection<Element> outs) {\n        Elements output = new Elements();\n        for (Element el: elements) {\n            boolean found = false;\n            for (Element out: outs) {\n                if (el.equals(out)) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found)\n                output.add(el);\n        }\n        return output;\n    }\n\n    public static class SelectorParseException extends IllegalStateException { public SelectorParseException(String msg, Object... params) {\n            super(String.format(msg, params));\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public static Elements select(String query, Element root)",
        "public static Elements select(String query, Iterable<Element> roots)",
        "private Elements select()",
        "private void combinator(String combinator)",
        "private Elements findElements()",
        "private void addElements(Collection<Element> add)",
        "private void intersectElements(Collection<Element> intersect)",
        "private Elements byId()",
        "private Elements byClass()",
        "private Elements byTag()",
        "private Elements byAttribute()",
        "private Elements allElements()",
        "private Elements indexLessThan()",
        "private Elements indexGreaterThan()",
        "private Elements indexEquals()",
        "private int consumeIndex()",
        "private Elements has()",
        "private Elements contains(boolean own)",
        "private Elements matches(boolean own)",
        "private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates)",
        "private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates)",
        "private static Elements filterForParentsOfDescendants(Collection<Element> parents, Collection<Element> children)",
        "private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates)",
        "private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates)",
        "private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates)",
        "public static class SelectorParseException extends IllegalStateException { public SelectorParseException(String msg, Object... params)"
      ],
      "fixed_signatures": [
        "public static Elements select(String query, Element root)",
        "public static Elements select(String query, Iterable<Element> roots)",
        "private Elements select()",
        "private void combinator(String combinator)",
        "private Elements findElements()",
        "private void addElements(Collection<Element> add)",
        "private void intersectElements(Collection<Element> intersect)",
        "private Elements byId()",
        "private Elements byClass()",
        "private Elements byTag()",
        "private Elements byAttribute()",
        "private Elements allElements()",
        "private Elements indexLessThan()",
        "private Elements indexGreaterThan()",
        "private Elements indexEquals()",
        "private int consumeIndex()",
        "private Elements has()",
        "private Elements contains(boolean own)",
        "private Elements matches(boolean own)",
        "private Elements not()",
        "private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates)",
        "private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates)",
        "private static Elements filterForParentsOfDescendants(Collection<Element> parents, Collection<Element> children)",
        "private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates)",
        "private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates)",
        "private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates)",
        "static Elements filterOut(Collection<Element> elements, Collection<Element> outs)",
        "public static class SelectorParseException extends IllegalStateException { public SelectorParseException(String msg, Object... params)"
      ],
      "methods": [
        {
          "buggy_method": "  private Elements select() {\n  tq.consumeWhitespace();\n  \n  if (tq.matchesAny(combinators)) { \n  elements.add(root);\n  combinator(tq.consume().toString());\n  } else {\n  addElements(findElements()); \n  }  \n  \n  while (!tq.isEmpty()) {\n  \n  boolean seenWhite = tq.consumeWhitespace();\n  \n  if (tq.matchChomp(\",\")) { \n  while (!tq.isEmpty()) {\n  String subQuery = tq.chompTo(\",\");\n  elements.addAll(select(subQuery, root));\n  }\n  } else if (tq.matchesAny(combinators)) {\n  combinator(tq.consume().toString());\n  } else if (seenWhite) {\n  combinator(\" \");\n  } else { \n  Elements candidates = findElements(); \n  intersectElements(filterForSelf(elements, candidates));\n  }\n  }\n  return new Elements(elements);\n  }",
          "fixed_method": "  private Elements select() {\n  tq.consumeWhitespace();\n  \n  if (tq.matchesAny(combinators)) { \n  elements.add(root);\n  combinator(tq.consume().toString());\n  } else if (tq.matches(\":has(\")) {\n  elements.addAll(root.getAllElements());\n  } else {\n  addElements(findElements()); \n  }  \n  \n  while (!tq.isEmpty()) {\n  \n  boolean seenWhite = tq.consumeWhitespace();\n  \n  if (tq.matchChomp(\",\")) { \n  while (!tq.isEmpty()) {\n  String subQuery = tq.chompTo(\",\");\n  elements.addAll(select(subQuery, root));\n  }\n  } else if (tq.matchesAny(combinators)) {\n  combinator(tq.consume().toString());\n  } else if (seenWhite) {\n  combinator(\" \");\n  } else { \n  Elements candidates = findElements(); \n  intersectElements(filterForSelf(elements, candidates));\n  }\n  }\n  return new Elements(elements);\n  }",
          "diff": [
            "@@ -107,6 +107,8 @@",
            "         if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\n",
            "             elements.add(root);\n",
            "             combinator(tq.consume().toString());\n",
            "+        } else if (tq.matches(\":has(\")) {\n",
            "+            elements.addAll(root.getAllElements());\n",
            "         } else {\n",
            "             addElements(findElements()); // chomp first element matcher off queue \n",
            "         }            \n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  private Elements findElements() {\n  if (tq.matchChomp(\"#\")) {\n  return byId();\n  } else if (tq.matchChomp(\".\")) {\n  return byClass();\n  } else if (tq.matchesWord()) {\n  return byTag();\n  } else if (tq.matches(\"[\")) {\n  return byAttribute();\n  } else if (tq.matchChomp(\"*\")) {\n  return allElements();\n  } else if (tq.matchChomp(\":lt(\")) {\n  return indexLessThan();\n  } else if (tq.matchChomp(\":gt(\")) {\n  return indexGreaterThan();\n  } else if (tq.matchChomp(\":eq(\")) {\n  return indexEquals();\n  } else if (tq.matches(\":has(\")) {\n  return has();\n  } else if (tq.matches(\":contains(\")) {\n  return contains(false);\n  } else if (tq.matches(\":containsOwn(\")) {\n  return contains(true);\n  } else if (tq.matches(\":matches(\")) {\n  return matches(false);\n  } else if (tq.matches(\":matchesOwn(\")) {\n  return matches(true);\n  } else { \n  throw new SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n  }\n  }",
          "fixed_method": "  private Elements findElements() {\n  if (tq.matchChomp(\"#\")) {\n  return byId();\n  } else if (tq.matchChomp(\".\")) {\n  return byClass();\n  } else if (tq.matchesWord()) {\n  return byTag();\n  } else if (tq.matches(\"[\")) {\n  return byAttribute();\n  } else if (tq.matchChomp(\"*\")) {\n  return allElements();\n  } else if (tq.matchChomp(\":lt(\")) {\n  return indexLessThan();\n  } else if (tq.matchChomp(\":gt(\")) {\n  return indexGreaterThan();\n  } else if (tq.matchChomp(\":eq(\")) {\n  return indexEquals();\n  } else if (tq.matches(\":has(\")) {\n  return has();\n  } else if (tq.matches(\":contains(\")) {\n  return contains(false);\n  } else if (tq.matches(\":containsOwn(\")) {\n  return contains(true);\n  } else if (tq.matches(\":matches(\")) {\n  return matches(false);\n  } else if (tq.matches(\":matchesOwn(\")) {\n  return matches(true);\n  } else if (tq.matches(\":not(\")) {\n  return not();\n  } else { \n  throw new SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n  }\n  }",
          "diff": [
            "@@ -178,6 +180,8 @@",
            "             return matches(false);\n",
            "         } else if (tq.matches(\":matchesOwn(\")) {\n",
            "             return matches(true);\n",
            "+        } else if (tq.matches(\":not(\")) {\n",
            "+            return not();\n",
            "         } else { // unhandled\n",
            "             throw new SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n",
            "         }\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates) {\n  Elements children = new Elements();\n  CHILD: for (Element c : candidates) {\n  for (Element p : parents) {\n  if (c.parent() != null && c.parent().equals(p)) {\n  children.add(c);\n  continue CHILD;\n  }\n  }\n  }\n  return children;\n  }",
          "fixed_method": "  private Elements not() {\n  tq.consume(\":not\");\n  String subQuery = tq.chompBalanced('(', ')');\n  Validate.notEmpty(subQuery, \":not(selector) subselect must not be empty\");\n\n  return filterOut(root.getAllElements(), select(subQuery, root));\n  }",
          "diff": [
            "@@ -302,7 +306,13 @@",
            "     }\n",
            " \n",
            "     // :not(selector)\n",
            "-\n",
            "+    private Elements not() {\n",
            "+        tq.consume(\":not\");\n",
            "+        String subQuery = tq.chompBalanced('(', ')');\n",
            "+        Validate.notEmpty(subQuery, \":not(selector) subselect must not be empty\");\n",
            "+\n",
            "+        return filterOut(root.getAllElements(), select(subQuery, root));\n",
            "+    }\n",
            " \n",
            "     // direct child descendants\n",
            "     private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates) {\n"
          ],
          "changed_lines": 8
        },
        {
          "buggy_method": "  public SelectorParseException(String msg, Object... params) {\n  super(String.format(msg, params));\n  }",
          "fixed_method": "  static Elements filterOut(Collection<Element> elements, Collection<Element> outs) {\n  Elements output = new Elements();\n  for (Element el: elements) {\n  boolean found = false;\n  for (Element out: outs) {\n  if (el.equals(out)) {\n  found = true;\n  break;\n  }\n  }\n  if (!found)\n  output.add(el);\n  }\n  return output;\n  }",
          "diff": [
            "@@ -396,6 +406,21 @@",
            "     }\n",
            " \n",
            "     // exclude set. package open so that Elements can implement .not() selector.\n",
            "+    static Elements filterOut(Collection<Element> elements, Collection<Element> outs) {\n",
            "+        Elements output = new Elements();\n",
            "+        for (Element el: elements) {\n",
            "+            boolean found = false;\n",
            "+            for (Element out: outs) {\n",
            "+                if (el.equals(out)) {\n",
            "+                    found = true;\n",
            "+                    break;\n",
            "+                }\n",
            "+            }\n",
            "+            if (!found)\n",
            "+                output.add(el);\n",
            "+        }\n",
            "+        return output;\n",
            "+    }\n",
            " \n",
            "     public static class SelectorParseException extends IllegalStateException {\n",
            "         public SelectorParseException(String msg, Object... params) {\n"
          ],
          "changed_lines": 15
        }
      ]
    }
  ]
}
