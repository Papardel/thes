{
  "bug_id": "92",
  "failed_tests": {
    "org.apache.commons.math.util.MathUtilsTest": [
      {
        "methodName": "testBinomialCoefficientLarge",
        "error": "junit.framework.AssertionFailedError",
        "message": "48,22 expected:<27385657281648> but was:<27385657281647>",
        "fail_line": "                assertEquals(n+\",\"+k, exactResult, ourResult);",
        "test_source": "  public void testBinomialCoefficientLarge() throws Exception {\n  // This tests all legal and illegal values for n <= 200.\n  for (int n = 0; n <= 200; n++) {\n  for (int k = 0; k <= n; k++) {\n  long ourResult = -1;\n  long exactResult = -1;\n  boolean shouldThrow = false;\n  boolean didThrow = false;\n  try {\n  ourResult = MathUtils.binomialCoefficient(n, k);\n  } catch (ArithmeticException ex) {\n  didThrow = true;\n  }\n  try {\n  exactResult = binomialCoefficient(n, k);\n  } catch (ArithmeticException ex) {\n  shouldThrow = true;\n  }\n  assertEquals(n+\",\"+k, shouldThrow, didThrow);\n  assertEquals(n+\",\"+k, exactResult, ourResult);\n  assertTrue(n+\",\"+k, (n > 66 || !didThrow));\n  }\n  }\n\n  long ourResult = MathUtils.binomialCoefficient(300, 3);\n  long exactResult = binomialCoefficient(300, 3);\n  assertEquals(exactResult, ourResult);\n\n  ourResult = MathUtils.binomialCoefficient(700, 697);\n  exactResult = binomialCoefficient(700, 697);\n  assertEquals(exactResult, ourResult);\n\n  // This one should throw\n  try {\n  MathUtils.binomialCoefficient(700, 300);\n  fail(\"Expecting ArithmeticException\");\n  } catch (ArithmeticException ex) {\n  // Expected\n  }\n\n  // Larger values cannot be computed directly by our\n  // test implementation because of stack limitations,\n  // so we make little jumps to fill the cache.\n  for (int i = 2000; i <= 10000; i += 2000) {\n  ourResult = MathUtils.binomialCoefficient(i, 3);\n  exactResult = binomialCoefficient(i, 3);\n  assertEquals(exactResult, ourResult);\n  }\n\n  }",
        "stack": [
          "MathUtilsTest.testBinomialCoefficientLarge line 195"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/util/MathUtils.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.util;\n\nimport java.math.BigDecimal;\nimport java.util.Arrays;\n\n\npublic final class MathUtils { public static final double EPSILON = 0x1.0p-53; public static final double SAFE_MIN = 0x1.0p-1022; private static final byte NB = (byte)-1; private static final short NS = (short)-1; private static final byte PB = (byte)1; private static final short PS = (short)1; private static final byte ZB = (byte)0; private static final short ZS = (short)0; private static final double TWO_PI = 2 * Math.PI; private MathUtils() {\n        super();\n    }\n\n    \n    public static int addAndCheck(int x, int y) {\n        long s = (long)x + (long)y;\n        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: add\");\n        }\n        return (int)s;\n    }\n\n    \n    public static long addAndCheck(long a, long b) {\n        return addAndCheck(a, b, \"overflow: add\");\n    }\n    \n    \n    private static long addAndCheck(long a, long b, String msg) {\n        long ret;\n        if (a > b) {\n            \n            ret = addAndCheck(b, a, msg);\n        } else {\n            \n            \n            if (a < 0) {\n                if (b < 0) {\n                    \n                    if (Long.MIN_VALUE - b <= a) {\n                        ret = a + b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                    }\n                } else {\n                    \n                    ret = a + b;\n                }\n            } else {\n                \n                \n\n                \n                if (a <= Long.MAX_VALUE - b) {\n                    ret = a + b;\n                } else {\n                    throw new ArithmeticException(msg);\n                }\n            }\n        }\n        return ret;\n    }\n    \n    \n    public static long binomialCoefficient(final int n, final int k) {\n        if (n < k) {\n            throw new IllegalArgumentException(\n                \"must have n >= k for binomial coefficient (n,k)\");\n        }\n        if (n < 0) {\n            throw new IllegalArgumentException(\n                \"must have n >= 0 for binomial coefficient (n,k)\");\n        }\n        if ((n == k) || (k == 0)) {\n            return 1;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return n;\n        }\n        long result = Math.round(binomialCoefficientDouble(n, k));\n        if (result == Long.MAX_VALUE) {\n            throw new ArithmeticException(\n                \"result too large to represent in a long integer\");\n        }\n        \n        \n        \n        \n        \n        \n        \n            \n            \n            \n                \n                \n                \n                \n                \n                \n            \n            \n            \n        return result;\n    }\n\n    \n    public static double binomialCoefficientDouble(final int n, final int k) {\n        \n  \n        return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);\n    }\n    \n    \n    public static double binomialCoefficientLog(final int n, final int k) {\n        if (n < k) {\n            throw new IllegalArgumentException(\n                \"must have n >= k for binomial coefficient (n,k)\");\n        }\n        if (n < 0) {\n            throw new IllegalArgumentException(\n                \"must have n >= 0 for binomial coefficient (n,k)\");\n        }\n        if ((n == k) || (k == 0)) {\n            return 0;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return Math.log((double) n);\n        }\n        \n        \n        \n        \n        \n        \n        double logSum = 0;\n\n        \n        for (int i = k + 1; i <= n; i++) {\n            logSum += Math.log((double)i);\n        }\n\n        \n        for (int i = 2; i <= n - k; i++) {\n            logSum -= Math.log((double)i);\n        }\n\n        return logSum;      \n    }\n    \n    \n    public static double cosh(double x) {\n        return (Math.exp(x) + Math.exp(-x)) / 2.0;\n    }\n    \n    \n    public static boolean equals(double x, double y) {\n        return ((Double.isNaN(x) && Double.isNaN(y)) || x == y);\n    }\n\n    \n    public static boolean equals(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    \n    private static final long[] factorials = new long[] {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 6227020800l, 87178291200l, 1307674368000l, 20922789888000l, 355687428096000l, 6402373705728000l, 121645100408832000l, 2432902008176640000l}; public static long factorial(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n        }\n        if (n > 20) {\n            throw new ArithmeticException(\n                    \"factorial value is too large to fit in a long\");\n        }\n        return factorials[n];\n    }\n\n    \n    public static double factorialDouble(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n        }\n        if (n < 21) {\n            return factorial(n);\n        }\n        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n    }\n\n    \n    public static double factorialLog(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n > 0 for n!\");\n        }\n        if (n < 21) {\n            return Math.log(factorial(n));\n        }\n        double logSum = 0;\n        for (int i = 2; i <= n; i++) {\n            logSum += Math.log((double)i);\n        }\n        return logSum;\n    }\n\n    \n    public static int gcd(int u, int v) {\n        if ((u == 0) || (v == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }\n        \n        \n        \n        \n        \n        if (u > 0) {\n            u = -u;\n        } \n        if (v > 0) {\n            v = -v;\n        } \n        \n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { \n                                                            \n            u /= 2;\n            v /= 2;\n            k++; \n        }\n        if (k == 31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        \n        \n        int t = ((u & 1) == 1) ? v : -(u / 2);\n        \n        \n        do {\n            \n            \n            while ((t & 1) == 0) { \n                t /= 2; \n            }\n            \n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            \n            t = (v - u) / 2;\n            \n            \n        } while (t != 0);\n        return -u * (1 << k); \n    }\n\n    \n    public static int hash(double value) {\n        return new Double(value).hashCode();\n    }\n\n    \n    public static int hash(double[] value) {\n        return Arrays.hashCode(value);\n    }\n\n    \n    public static byte indicator(final byte x) {\n        return (x >= ZB) ? PB : NB;\n    }\n\n    \n    public static double indicator(final double x) {\n        if (Double.isNaN(x)) {\n            return Double.NaN;\n        }\n        return (x >= 0.0) ? 1.0 : -1.0;\n    }\n\n    \n    public static float indicator(final float x) {\n        if (Float.isNaN(x)) {\n            return Float.NaN;\n        }\n        return (x >= 0.0F) ? 1.0F : -1.0F;\n    }\n\n    \n    public static int indicator(final int x) {\n        return (x >= 0) ? 1 : -1;\n    }\n\n    \n    public static long indicator(final long x) {\n        return (x >= 0L) ? 1L : -1L;\n    }\n\n    \n    public static short indicator(final short x) {\n        return (x >= ZS) ? PS : NS;\n    }\n\n    \n    public static int lcm(int a, int b) {\n        return Math.abs(mulAndCheck(a / gcd(a, b), b));\n    }\n\n     \n    public static double log(double base, double x) {\n        return Math.log(x)/Math.log(base);\n    }\n\n    \n    public static int mulAndCheck(int x, int y) {\n        long m = ((long)x) * ((long)y);\n        if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: mul\");\n        }\n        return (int)m;\n    }\n\n    \n    public static long mulAndCheck(long a, long b) {\n        long ret;\n        String msg = \"overflow: multiply\";\n        if (a > b) {\n            \n            ret = mulAndCheck(b, a);\n        } else {\n            if (a < 0) {\n                if (b < 0) {\n                    \n                    if (a >= Long.MAX_VALUE / b) {\n                        ret = a * b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                    }\n                } else if (b > 0) {\n                    \n                    if (Long.MIN_VALUE / b <= a) {\n                        ret = a * b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                        \n                    }\n                } else {\n                    \n                    ret = 0;\n                }\n            } else if (a > 0) {\n                \n                \n                \n                \n                if (a <= Long.MAX_VALUE / b) {\n                    ret = a * b;\n                } else {\n                    throw new ArithmeticException(msg);\n                }\n            } else {\n                \n                ret = 0;\n            }\n        }\n        return ret;\n    }\n\n    \n    public static double nextAfter(double d, double direction) {\n\n        \n        if (Double.isNaN(d) || Double.isInfinite(d)) {\n                return d;\n        } else if (d == 0) {\n                return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n        }\n        \n        \n\n        \n        long bits     = Double.doubleToLongBits(d);\n        long sign     = bits & 0x8000000000000000L;\n        long exponent = bits & 0x7ff0000000000000L;\n        long mantissa = bits & 0x000fffffffffffffL;\n\n        if (d * (direction - d) >= 0) {\n                \n                if (mantissa == 0x000fffffffffffffL) {\n                        return Double.longBitsToDouble(sign |\n                                        (exponent + 0x0010000000000000L));\n                } else {\n                        return Double.longBitsToDouble(sign |\n                                        exponent | (mantissa + 1));\n                }\n        } else {\n                \n                if (mantissa == 0L) {\n                        return Double.longBitsToDouble(sign |\n                                        (exponent - 0x0010000000000000L) |\n                                        0x000fffffffffffffL);\n                } else {\n                        return Double.longBitsToDouble(sign |\n                                        exponent | (mantissa - 1));\n                }\n        }\n\n    }\n\n    \n    public static double scalb(final double d, final int scaleFactor) {\n\n        \n        if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {\n            return d;\n        }\n\n        \n        final long bits     = Double.doubleToLongBits(d);\n        final long exponent = bits & 0x7ff0000000000000L;\n        final long rest     = bits & 0x800fffffffffffffL;\n\n        \n        final long newBits = rest | (exponent + (((long) scaleFactor) << 52));\n        return Double.longBitsToDouble(newBits);\n\n    }\n\n    \n     public static double normalizeAngle(double a, double center) {\n         return a - TWO_PI * Math.floor((a + Math.PI - center) / TWO_PI);\n     }\n\n    \n    public static double round(double x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }\n\n    \n    public static double round(double x, int scale, int roundingMethod) {\n        try {\n            return (new BigDecimal\n                   (Double.toString(x))\n                   .setScale(scale, roundingMethod))\n                   .doubleValue();\n        } catch (NumberFormatException ex) {\n            if (Double.isInfinite(x)) {\n                return x;          \n            } else {\n                return Double.NaN;\n            }\n        }\n    }\n\n    \n    public static float round(float x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }\n\n    \n    public static float round(float x, int scale, int roundingMethod) {\n        float sign = indicator(x);\n        float factor = (float)Math.pow(10.0f, scale) * sign;\n        return (float)roundUnscaled(x * factor, sign, roundingMethod) / factor;\n    }\n\n    \n    private static double roundUnscaled(double unscaled, double sign, int roundingMethod) {\n        switch (roundingMethod) {\n        case BigDecimal.ROUND_CEILING :\n            if (sign == -1) {\n                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            } else {\n                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_DOWN :\n            unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            break;\n        case BigDecimal.ROUND_FLOOR :\n            if (sign == -1) {\n                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            } else {\n                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_HALF_DOWN : {\n            unscaled = nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction > 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else {\n                unscaled = Math.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_EVEN : {\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction > 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else if (fraction < 0.5) {\n                unscaled = Math.floor(unscaled);\n            } else {\n                \n                if (Math.floor(unscaled) / 2.0 == Math.floor(Math\n                    .floor(unscaled) / 2.0)) { \n                    unscaled = Math.floor(unscaled);\n                } else { \n                    unscaled = Math.ceil(unscaled);\n                }\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_UP : {\n            unscaled = nextAfter(unscaled, Double.POSITIVE_INFINITY);\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction >= 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else {\n                unscaled = Math.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_UNNECESSARY :\n            if (unscaled != Math.floor(unscaled)) {\n                throw new ArithmeticException(\"Inexact result from rounding\");\n            }\n            break;\n        case BigDecimal.ROUND_UP :\n            unscaled = Math.ceil(nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n            break;\n        default :\n            throw new IllegalArgumentException(\"Invalid rounding method.\");\n        }\n        return unscaled;\n    }\n\n    \n    public static byte sign(final byte x) {\n        return (x == ZB) ? ZB : (x > ZB) ? PB : NB;\n    }\n\n    \n    public static double sign(final double x) {\n        if (Double.isNaN(x)) {\n            return Double.NaN;\n        }\n        return (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;\n    }\n\n    \n    public static float sign(final float x) {\n        if (Float.isNaN(x)) {\n            return Float.NaN;\n        }\n        return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;\n    }\n\n    \n    public static int sign(final int x) {\n        return (x == 0) ? 0 : (x > 0) ? 1 : -1;\n    }\n\n    \n    public static long sign(final long x) {\n        return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;\n    }\n\n    \n    public static short sign(final short x) {\n        return (x == ZS) ? ZS : (x > ZS) ? PS : NS;\n    }\n\n    \n    public static double sinh(double x) {\n        return (Math.exp(x) - Math.exp(-x)) / 2.0;\n    }\n\n    \n    public static int subAndCheck(int x, int y) {\n        long s = (long)x - (long)y;\n        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: subtract\");\n        }\n        return (int)s;\n    }\n\n    \n    public static long subAndCheck(long a, long b) {\n        long ret;\n        String msg = \"overflow: subtract\";\n        if (b == Long.MIN_VALUE) {\n            if (a < 0) {\n                ret = a - b;\n            } else {\n                throw new ArithmeticException(msg);\n            }\n        } else {\n            \n            ret = addAndCheck(a, -b, msg);\n        }\n        return ret;\n    }\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.util;\n\nimport java.math.BigDecimal;\nimport java.util.Arrays;\n\n\npublic final class MathUtils { public static final double EPSILON = 0x1.0p-53; public static final double SAFE_MIN = 0x1.0p-1022; private static final byte NB = (byte)-1; private static final short NS = (short)-1; private static final byte PB = (byte)1; private static final short PS = (short)1; private static final byte ZB = (byte)0; private static final short ZS = (short)0; private static final double TWO_PI = 2 * Math.PI; private MathUtils() {\n        super();\n    }\n\n    \n    public static int addAndCheck(int x, int y) {\n        long s = (long)x + (long)y;\n        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: add\");\n        }\n        return (int)s;\n    }\n\n    \n    public static long addAndCheck(long a, long b) {\n        return addAndCheck(a, b, \"overflow: add\");\n    }\n    \n    \n    private static long addAndCheck(long a, long b, String msg) {\n        long ret;\n        if (a > b) {\n            \n            ret = addAndCheck(b, a, msg);\n        } else {\n            \n            \n            if (a < 0) {\n                if (b < 0) {\n                    \n                    if (Long.MIN_VALUE - b <= a) {\n                        ret = a + b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                    }\n                } else {\n                    \n                    ret = a + b;\n                }\n            } else {\n                \n                \n\n                \n                if (a <= Long.MAX_VALUE - b) {\n                    ret = a + b;\n                } else {\n                    throw new ArithmeticException(msg);\n                }\n            }\n        }\n        return ret;\n    }\n    \n    \n    public static long binomialCoefficient(final int n, final int k) {\n        if (n < k) {\n            throw new IllegalArgumentException(\n                \"must have n >= k for binomial coefficient (n,k)\");\n        }\n        if (n < 0) {\n            throw new IllegalArgumentException(\n                \"must have n >= 0 for binomial coefficient (n,k)\");\n        }\n        if ((n == k) || (k == 0)) {\n            return 1;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return n;\n        }\n        \n        if (k > n / 2)\n            return binomialCoefficient(n, n - k);\n        \n        \n        \n        \n        \n        \n        long result = 1;\n        if (n <= 61) {\n            \n            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n                result = result * i / j;\n            }\n        } else if (n <= 66) {\n            \n            \n            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n                \n                \n                \n                \n                \n                \n                long d = gcd(i, j);\n                result = (result / (j / d)) * (i / d);\n            }\n        } else {\n            \n            \n            \n            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n                long d = gcd(i, j);\n                result = mulAndCheck((result / (j / d)), (i / d));\n            }\n        }\n        return result;\n    }\n\n    \n    public static double binomialCoefficientDouble(final int n, final int k) {\n        if (n < k) {\n            throw new IllegalArgumentException(\n                \"must have n >= k for binomial coefficient (n,k)\");\n        }\n        if (n < 0) {\n            throw new IllegalArgumentException(\n                \"must have n >= 0 for binomial coefficient (n,k)\");\n        }\n        if ((n == k) || (k == 0)) {\n            return 1d;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return n;\n        }\n        if (k > n/2) {\n            return binomialCoefficientDouble(n, n - k);\n        }\n        if (n < 67) {\n            return binomialCoefficient(n,k);\n        }\n        \n        double result = 1d;\n        for (int i = 1; i <= k; i++) {\n             result *= (double)(n - k + i) / (double)i;\n        }\n  \n        return Math.floor(result + 0.5);\n    }\n    \n    \n    public static double binomialCoefficientLog(final int n, final int k) {\n        if (n < k) {\n            throw new IllegalArgumentException(\n                \"must have n >= k for binomial coefficient (n,k)\");\n        }\n        if (n < 0) {\n            throw new IllegalArgumentException(\n                \"must have n >= 0 for binomial coefficient (n,k)\");\n        }\n        if ((n == k) || (k == 0)) {\n            return 0;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return Math.log((double) n);\n        }\n        \n        \n        if (n < 67) {  \n            return Math.log(binomialCoefficient(n,k));\n        }\n        \n        \n        if (n < 1030) { \n            return Math.log(binomialCoefficientDouble(n, k));\n        } \n        \n        \n        double logSum = 0;\n\n        \n        for (int i = k + 1; i <= n; i++) {\n            logSum += Math.log((double)i);\n        }\n\n        \n        for (int i = 2; i <= n - k; i++) {\n            logSum -= Math.log((double)i);\n        }\n\n        return logSum;      \n    }\n    \n    \n    public static double cosh(double x) {\n        return (Math.exp(x) + Math.exp(-x)) / 2.0;\n    }\n    \n    \n    public static boolean equals(double x, double y) {\n        return ((Double.isNaN(x) && Double.isNaN(y)) || x == y);\n    }\n\n    \n    public static boolean equals(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    \n    private static final long[] factorials = new long[] {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 6227020800l, 87178291200l, 1307674368000l, 20922789888000l, 355687428096000l, 6402373705728000l, 121645100408832000l, 2432902008176640000l}; public static long factorial(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n        }\n        if (n > 20) {\n            throw new ArithmeticException(\n                    \"factorial value is too large to fit in a long\");\n        }\n        return factorials[n];\n    }\n\n    \n    public static double factorialDouble(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n        }\n        if (n < 21) {\n            return factorial(n);\n        }\n        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n    }\n\n    \n    public static double factorialLog(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n > 0 for n!\");\n        }\n        if (n < 21) {\n            return Math.log(factorial(n));\n        }\n        double logSum = 0;\n        for (int i = 2; i <= n; i++) {\n            logSum += Math.log((double)i);\n        }\n        return logSum;\n    }\n\n    \n    public static int gcd(int u, int v) {\n        if ((u == 0) || (v == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }\n        \n        \n        \n        \n        \n        if (u > 0) {\n            u = -u;\n        } \n        if (v > 0) {\n            v = -v;\n        } \n        \n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { \n                                                            \n            u /= 2;\n            v /= 2;\n            k++; \n        }\n        if (k == 31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        \n        \n        int t = ((u & 1) == 1) ? v : -(u / 2);\n        \n        \n        do {\n            \n            \n            while ((t & 1) == 0) { \n                t /= 2; \n            }\n            \n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            \n            t = (v - u) / 2;\n            \n            \n        } while (t != 0);\n        return -u * (1 << k); \n    }\n\n    \n    public static int hash(double value) {\n        return new Double(value).hashCode();\n    }\n\n    \n    public static int hash(double[] value) {\n        return Arrays.hashCode(value);\n    }\n\n    \n    public static byte indicator(final byte x) {\n        return (x >= ZB) ? PB : NB;\n    }\n\n    \n    public static double indicator(final double x) {\n        if (Double.isNaN(x)) {\n            return Double.NaN;\n        }\n        return (x >= 0.0) ? 1.0 : -1.0;\n    }\n\n    \n    public static float indicator(final float x) {\n        if (Float.isNaN(x)) {\n            return Float.NaN;\n        }\n        return (x >= 0.0F) ? 1.0F : -1.0F;\n    }\n\n    \n    public static int indicator(final int x) {\n        return (x >= 0) ? 1 : -1;\n    }\n\n    \n    public static long indicator(final long x) {\n        return (x >= 0L) ? 1L : -1L;\n    }\n\n    \n    public static short indicator(final short x) {\n        return (x >= ZS) ? PS : NS;\n    }\n\n    \n    public static int lcm(int a, int b) {\n        return Math.abs(mulAndCheck(a / gcd(a, b), b));\n    }\n\n     \n    public static double log(double base, double x) {\n        return Math.log(x)/Math.log(base);\n    }\n\n    \n    public static int mulAndCheck(int x, int y) {\n        long m = ((long)x) * ((long)y);\n        if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: mul\");\n        }\n        return (int)m;\n    }\n\n    \n    public static long mulAndCheck(long a, long b) {\n        long ret;\n        String msg = \"overflow: multiply\";\n        if (a > b) {\n            \n            ret = mulAndCheck(b, a);\n        } else {\n            if (a < 0) {\n                if (b < 0) {\n                    \n                    if (a >= Long.MAX_VALUE / b) {\n                        ret = a * b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                    }\n                } else if (b > 0) {\n                    \n                    if (Long.MIN_VALUE / b <= a) {\n                        ret = a * b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                        \n                    }\n                } else {\n                    \n                    ret = 0;\n                }\n            } else if (a > 0) {\n                \n                \n                \n                \n                if (a <= Long.MAX_VALUE / b) {\n                    ret = a * b;\n                } else {\n                    throw new ArithmeticException(msg);\n                }\n            } else {\n                \n                ret = 0;\n            }\n        }\n        return ret;\n    }\n\n    \n    public static double nextAfter(double d, double direction) {\n\n        \n        if (Double.isNaN(d) || Double.isInfinite(d)) {\n                return d;\n        } else if (d == 0) {\n                return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n        }\n        \n        \n\n        \n        long bits     = Double.doubleToLongBits(d);\n        long sign     = bits & 0x8000000000000000L;\n        long exponent = bits & 0x7ff0000000000000L;\n        long mantissa = bits & 0x000fffffffffffffL;\n\n        if (d * (direction - d) >= 0) {\n                \n                if (mantissa == 0x000fffffffffffffL) {\n                        return Double.longBitsToDouble(sign |\n                                        (exponent + 0x0010000000000000L));\n                } else {\n                        return Double.longBitsToDouble(sign |\n                                        exponent | (mantissa + 1));\n                }\n        } else {\n                \n                if (mantissa == 0L) {\n                        return Double.longBitsToDouble(sign |\n                                        (exponent - 0x0010000000000000L) |\n                                        0x000fffffffffffffL);\n                } else {\n                        return Double.longBitsToDouble(sign |\n                                        exponent | (mantissa - 1));\n                }\n        }\n\n    }\n\n    \n    public static double scalb(final double d, final int scaleFactor) {\n\n        \n        if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {\n            return d;\n        }\n\n        \n        final long bits     = Double.doubleToLongBits(d);\n        final long exponent = bits & 0x7ff0000000000000L;\n        final long rest     = bits & 0x800fffffffffffffL;\n\n        \n        final long newBits = rest | (exponent + (((long) scaleFactor) << 52));\n        return Double.longBitsToDouble(newBits);\n\n    }\n\n    \n     public static double normalizeAngle(double a, double center) {\n         return a - TWO_PI * Math.floor((a + Math.PI - center) / TWO_PI);\n     }\n\n    \n    public static double round(double x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }\n\n    \n    public static double round(double x, int scale, int roundingMethod) {\n        try {\n            return (new BigDecimal\n                   (Double.toString(x))\n                   .setScale(scale, roundingMethod))\n                   .doubleValue();\n        } catch (NumberFormatException ex) {\n            if (Double.isInfinite(x)) {\n                return x;          \n            } else {\n                return Double.NaN;\n            }\n        }\n    }\n\n    \n    public static float round(float x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }\n\n    \n    public static float round(float x, int scale, int roundingMethod) {\n        float sign = indicator(x);\n        float factor = (float)Math.pow(10.0f, scale) * sign;\n        return (float)roundUnscaled(x * factor, sign, roundingMethod) / factor;\n    }\n\n    \n    private static double roundUnscaled(double unscaled, double sign, int roundingMethod) {\n        switch (roundingMethod) {\n        case BigDecimal.ROUND_CEILING :\n            if (sign == -1) {\n                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            } else {\n                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_DOWN :\n            unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            break;\n        case BigDecimal.ROUND_FLOOR :\n            if (sign == -1) {\n                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            } else {\n                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_HALF_DOWN : {\n            unscaled = nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction > 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else {\n                unscaled = Math.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_EVEN : {\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction > 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else if (fraction < 0.5) {\n                unscaled = Math.floor(unscaled);\n            } else {\n                \n                if (Math.floor(unscaled) / 2.0 == Math.floor(Math\n                    .floor(unscaled) / 2.0)) { \n                    unscaled = Math.floor(unscaled);\n                } else { \n                    unscaled = Math.ceil(unscaled);\n                }\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_UP : {\n            unscaled = nextAfter(unscaled, Double.POSITIVE_INFINITY);\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction >= 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else {\n                unscaled = Math.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_UNNECESSARY :\n            if (unscaled != Math.floor(unscaled)) {\n                throw new ArithmeticException(\"Inexact result from rounding\");\n            }\n            break;\n        case BigDecimal.ROUND_UP :\n            unscaled = Math.ceil(nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n            break;\n        default :\n            throw new IllegalArgumentException(\"Invalid rounding method.\");\n        }\n        return unscaled;\n    }\n\n    \n    public static byte sign(final byte x) {\n        return (x == ZB) ? ZB : (x > ZB) ? PB : NB;\n    }\n\n    \n    public static double sign(final double x) {\n        if (Double.isNaN(x)) {\n            return Double.NaN;\n        }\n        return (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;\n    }\n\n    \n    public static float sign(final float x) {\n        if (Float.isNaN(x)) {\n            return Float.NaN;\n        }\n        return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;\n    }\n\n    \n    public static int sign(final int x) {\n        return (x == 0) ? 0 : (x > 0) ? 1 : -1;\n    }\n\n    \n    public static long sign(final long x) {\n        return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;\n    }\n\n    \n    public static short sign(final short x) {\n        return (x == ZS) ? ZS : (x > ZS) ? PS : NS;\n    }\n\n    \n    public static double sinh(double x) {\n        return (Math.exp(x) - Math.exp(-x)) / 2.0;\n    }\n\n    \n    public static int subAndCheck(int x, int y) {\n        long s = (long)x - (long)y;\n        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: subtract\");\n        }\n        return (int)s;\n    }\n\n    \n    public static long subAndCheck(long a, long b) {\n        long ret;\n        String msg = \"overflow: subtract\";\n        if (b == Long.MIN_VALUE) {\n            if (a < 0) {\n                ret = a - b;\n            } else {\n                throw new ArithmeticException(msg);\n            }\n        } else {\n            \n            ret = addAndCheck(a, -b, msg);\n        }\n        return ret;\n    }\n\n}\n",
      "buggy_signatures": [
        "public static int addAndCheck(int x, int y)",
        "public static long addAndCheck(long a, long b)",
        "private static long addAndCheck(long a, long b, String msg)",
        "public static long binomialCoefficient(final int n, final int k)",
        "public static double binomialCoefficientDouble(final int n, final int k)",
        "public static double binomialCoefficientLog(final int n, final int k)",
        "public static double cosh(double x)",
        "public static boolean equals(double x, double y)",
        "public static boolean equals(double[] x, double[] y)",
        "public static double factorialDouble(final int n)",
        "public static double factorialLog(final int n)",
        "public static int gcd(int u, int v)",
        "public static int hash(double value)",
        "public static int hash(double[] value)",
        "public static byte indicator(final byte x)",
        "public static double indicator(final double x)",
        "public static float indicator(final float x)",
        "public static int indicator(final int x)",
        "public static long indicator(final long x)",
        "public static short indicator(final short x)",
        "public static int lcm(int a, int b)",
        "public static double log(double base, double x)",
        "public static int mulAndCheck(int x, int y)",
        "public static long mulAndCheck(long a, long b)",
        "public static double nextAfter(double d, double direction)",
        "public static double scalb(final double d, final int scaleFactor)",
        "public static double normalizeAngle(double a, double center)",
        "public static double round(double x, int scale)",
        "public static double round(double x, int scale, int roundingMethod)",
        "public static float round(float x, int scale)",
        "public static float round(float x, int scale, int roundingMethod)",
        "private static double roundUnscaled(double unscaled, double sign, int roundingMethod)",
        "public static byte sign(final byte x)",
        "public static double sign(final double x)",
        "public static float sign(final float x)",
        "public static int sign(final int x)",
        "public static long sign(final long x)",
        "public static short sign(final short x)",
        "public static double sinh(double x)",
        "public static int subAndCheck(int x, int y)",
        "public static long subAndCheck(long a, long b)"
      ],
      "fixed_signatures": [
        "public static int addAndCheck(int x, int y)",
        "public static long addAndCheck(long a, long b)",
        "private static long addAndCheck(long a, long b, String msg)",
        "public static long binomialCoefficient(final int n, final int k)",
        "public static double binomialCoefficientDouble(final int n, final int k)",
        "public static double binomialCoefficientLog(final int n, final int k)",
        "public static double cosh(double x)",
        "public static boolean equals(double x, double y)",
        "public static boolean equals(double[] x, double[] y)",
        "public static double factorialDouble(final int n)",
        "public static double factorialLog(final int n)",
        "public static int gcd(int u, int v)",
        "public static int hash(double value)",
        "public static int hash(double[] value)",
        "public static byte indicator(final byte x)",
        "public static double indicator(final double x)",
        "public static float indicator(final float x)",
        "public static int indicator(final int x)",
        "public static long indicator(final long x)",
        "public static short indicator(final short x)",
        "public static int lcm(int a, int b)",
        "public static double log(double base, double x)",
        "public static int mulAndCheck(int x, int y)",
        "public static long mulAndCheck(long a, long b)",
        "public static double nextAfter(double d, double direction)",
        "public static double scalb(final double d, final int scaleFactor)",
        "public static double normalizeAngle(double a, double center)",
        "public static double round(double x, int scale)",
        "public static double round(double x, int scale, int roundingMethod)",
        "public static float round(float x, int scale)",
        "public static float round(float x, int scale, int roundingMethod)",
        "private static double roundUnscaled(double unscaled, double sign, int roundingMethod)",
        "public static byte sign(final byte x)",
        "public static double sign(final double x)",
        "public static float sign(final float x)",
        "public static int sign(final int x)",
        "public static long sign(final long x)",
        "public static short sign(final short x)",
        "public static double sinh(double x)",
        "public static int subAndCheck(int x, int y)",
        "public static long subAndCheck(long a, long b)"
      ],
      "methods": [
        {
          "buggy_method": "  public static long binomialCoefficient(final int n, final int k) {\n  if (n < k) {\n  throw new IllegalArgumentException(\n  \"must have n >= k for binomial coefficient (n,k)\");\n  }\n  if (n < 0) {\n  throw new IllegalArgumentException(\n  \"must have n >= 0 for binomial coefficient (n,k)\");\n  }\n  if ((n == k) || (k == 0)) {\n  return 1;\n  }\n  if ((k == 1) || (k == n - 1)) {\n  return n;\n  }\n  long result = Math.round(binomialCoefficientDouble(n, k));\n  if (result == Long.MAX_VALUE) {\n  throw new ArithmeticException(\n  \"result too large to represent in a long integer\");\n  }\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return result;\n  }",
          "fixed_method": "  public static long binomialCoefficient(final int n, final int k) {\n  if (n < k) {\n  throw new IllegalArgumentException(\n  \"must have n >= k for binomial coefficient (n,k)\");\n  }\n  if (n < 0) {\n  throw new IllegalArgumentException(\n  \"must have n >= 0 for binomial coefficient (n,k)\");\n  }\n  if ((n == k) || (k == 0)) {\n  return 1;\n  }\n  if ((k == 1) || (k == n - 1)) {\n  return n;\n  }\n  \n  if (k > n / 2)\n  return binomialCoefficient(n, n - k);\n  \n  \n  \n  \n  \n  \n  long result = 1;\n  if (n <= 61) {\n  \n  for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n  result = result * i / j;\n  }\n  } else if (n <= 66) {\n  \n  \n  for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n  \n  \n  \n  \n  \n  \n  long d = gcd(i, j);\n  result = (result / (j / d)) * (i / d);\n  }\n  } else {\n  \n  \n  \n  for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n  long d = gcd(i, j);\n  result = mulAndCheck((result / (j / d)), (i / d));\n  }\n  }\n  return result;\n  }",
          "diff": [
            "@@ -181,30 +181,43 @@",
            "         if ((k == 1) || (k == n - 1)) {\n",
            "             return n;\n",
            "         }\n",
            "-        long result = Math.round(binomialCoefficientDouble(n, k));\n",
            "-        if (result == Long.MAX_VALUE) {\n",
            "-            throw new ArithmeticException(\n",
            "-                \"result too large to represent in a long integer\");\n",
            "-        }\n",
            "         // Use symmetry for large k\n",
            "+        if (k > n / 2)\n",
            "+            return binomialCoefficient(n, n - k);\n",
            "         \n",
            "         // We use the formula\n",
            "         // (n choose k) = n! / (n-k)! / k!\n",
            "         // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n",
            "         // which could be written\n",
            "         // (n choose k) == (n-1 choose k-1) * n / k\n",
            "+        long result = 1;\n",
            "+        if (n <= 61) {\n",
            "             // For n <= 61, the naive implementation cannot overflow.\n",
            "+            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n",
            "+                result = result * i / j;\n",
            "+            }\n",
            "+        } else if (n <= 66) {\n",
            "             // For n > 61 but n <= 66, the result cannot overflow,\n",
            "             // but we must take care not to overflow intermediate values.\n",
            "+            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n",
            "                 // We know that (result * i) is divisible by j,\n",
            "                 // but (result * i) may overflow, so we split j:\n",
            "                 // Filter out the gcd, d, so j/d and i/d are integer.\n",
            "                 // result is divisible by (j/d) because (j/d)\n",
            "                 // is relative prime to (i/d) and is a divisor of\n",
            "                 // result * (i/d).\n",
            "+                long d = gcd(i, j);\n",
            "+                result = (result / (j / d)) * (i / d);\n",
            "+            }\n",
            "+        } else {\n",
            "             // For n > 66, a result overflow might occur, so we check\n",
            "             // the multiplication, taking care to not overflow\n",
            "             // unnecessary.\n",
            "+            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n",
            "+                long d = gcd(i, j);\n",
            "+                result = mulAndCheck((result / (j / d)), (i / d));\n",
            "+            }\n",
            "+        }\n",
            "         return result;\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 23
        },
        {
          "buggy_method": "  public static double binomialCoefficientDouble(final int n, final int k) {\n  \n  \n  return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);\n  }",
          "fixed_method": "  public static double binomialCoefficientDouble(final int n, final int k) {\n  if (n < k) {\n  throw new IllegalArgumentException(\n  \"must have n >= k for binomial coefficient (n,k)\");\n  }\n  if (n < 0) {\n  throw new IllegalArgumentException(\n  \"must have n >= 0 for binomial coefficient (n,k)\");\n  }\n  if ((n == k) || (k == 0)) {\n  return 1d;\n  }\n  if ((k == 1) || (k == n - 1)) {\n  return n;\n  }\n  if (k > n/2) {\n  return binomialCoefficientDouble(n, n - k);\n  }\n  if (n < 67) {\n  return binomialCoefficient(n,k);\n  }\n  \n  double result = 1d;\n  for (int i = 1; i <= k; i++) {\n  result *= (double)(n - k + i) / (double)i;\n  }\n  \n  return Math.floor(result + 0.5);\n  }",
          "diff": [
            "@@ -231,9 +244,33 @@",
            "      * @throws IllegalArgumentException if preconditions are not met.\n",
            "      */\n",
            "     public static double binomialCoefficientDouble(final int n, final int k) {\n",
            "+        if (n < k) {\n",
            "+            throw new IllegalArgumentException(\n",
            "+                \"must have n >= k for binomial coefficient (n,k)\");\n",
            "+        }\n",
            "+        if (n < 0) {\n",
            "+            throw new IllegalArgumentException(\n",
            "+                \"must have n >= 0 for binomial coefficient (n,k)\");\n",
            "+        }\n",
            "+        if ((n == k) || (k == 0)) {\n",
            "+            return 1d;\n",
            "+        }\n",
            "+        if ((k == 1) || (k == n - 1)) {\n",
            "+            return n;\n",
            "+        }\n",
            "+        if (k > n/2) {\n",
            "+            return binomialCoefficientDouble(n, n - k);\n",
            "+        }\n",
            "+        if (n < 67) {\n",
            "+            return binomialCoefficient(n,k);\n",
            "+        }\n",
            "         \n",
            "+        double result = 1d;\n",
            "+        for (int i = 1; i <= k; i++) {\n",
            "+             result *= (double)(n - k + i) / (double)i;\n",
            "+        }\n",
            "   \n",
            "-        return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);\n",
            "+        return Math.floor(result + 0.5);\n",
            "     }\n",
            "     \n",
            "     /**\n"
          ],
          "changed_lines": 26
        },
        {
          "buggy_method": "  public static double binomialCoefficientLog(final int n, final int k) {\n  if (n < k) {\n  throw new IllegalArgumentException(\n  \"must have n >= k for binomial coefficient (n,k)\");\n  }\n  if (n < 0) {\n  throw new IllegalArgumentException(\n  \"must have n >= 0 for binomial coefficient (n,k)\");\n  }\n  if ((n == k) || (k == 0)) {\n  return 0;\n  }\n  if ((k == 1) || (k == n - 1)) {\n  return Math.log((double) n);\n  }\n  \n  \n  \n  \n  \n  \n  double logSum = 0;\n\n  \n  for (int i = k + 1; i <= n; i++) {\n  logSum += Math.log((double)i);\n  }\n\n  \n  for (int i = 2; i <= n - k; i++) {\n  logSum -= Math.log((double)i);\n  }\n\n  return logSum;  \n  }",
          "fixed_method": "  public static double binomialCoefficientLog(final int n, final int k) {\n  if (n < k) {\n  throw new IllegalArgumentException(\n  \"must have n >= k for binomial coefficient (n,k)\");\n  }\n  if (n < 0) {\n  throw new IllegalArgumentException(\n  \"must have n >= 0 for binomial coefficient (n,k)\");\n  }\n  if ((n == k) || (k == 0)) {\n  return 0;\n  }\n  if ((k == 1) || (k == n - 1)) {\n  return Math.log((double) n);\n  }\n  \n  \n  if (n < 67) {  \n  return Math.log(binomialCoefficient(n,k));\n  }\n  \n  \n  if (n < 1030) { \n  return Math.log(binomialCoefficientDouble(n, k));\n  } \n  \n  \n  double logSum = 0;\n\n  \n  for (int i = k + 1; i <= n; i++) {\n  logSum += Math.log((double)i);\n  }\n\n  \n  for (int i = 2; i <= n - k; i++) {\n  logSum -= Math.log((double)i);\n  }\n\n  return logSum;  \n  }",
          "diff": [
            "@@ -274,11 +311,17 @@",
            "          * For values small enough to do exact integer computation,\n",
            "          * return the log of the exact value \n",
            "          */\n",
            "+        if (n < 67) {  \n",
            "+            return Math.log(binomialCoefficient(n,k));\n",
            "+        }\n",
            "         \n",
            "         /*\n",
            "          * Return the log of binomialCoefficientDouble for values that will not\n",
            "          * overflow binomialCoefficientDouble\n",
            "          */\n",
            "+        if (n < 1030) { \n",
            "+            return Math.log(binomialCoefficientDouble(n, k));\n",
            "+        } \n",
            "         \n",
            "         /*\n",
            "          * Sum logs for values that could overflow\n"
          ],
          "changed_lines": 6
        }
      ]
    }
  ]
}
