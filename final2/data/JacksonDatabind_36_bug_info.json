{
  "bug_id": "36",
  "failed_tests": {
    "com.fasterxml.jackson.databind.TestStdDateFormat": [
      {
        "methodName": "testLenient",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "        f2.setLenient(false);",
        "test_source": "  public void testLenient() throws Exception {\n  StdDateFormat f = StdDateFormat.instance;\n\n  // default should be lenient\n  assertTrue(f.isLenient());\n\n  StdDateFormat f2 = f.clone();\n  assertTrue(f2.isLenient());\n\n  f2.setLenient(false);\n  assertFalse(f2.isLenient());\n\n  f2.setLenient(true);\n  assertTrue(f2.isLenient());\n\n  // and for testing, finally, leave as non-lenient\n  f2.setLenient(false);\n  assertFalse(f2.isLenient());\n  StdDateFormat f3 = f2.clone();\n  assertFalse(f3.isLenient());\n\n  // first, legal dates are... legal\n  Date dt = f3.parse(\"2015-11-30\");\n  assertNotNull(dt);\n\n  // but as importantly, when not lenient, do not allow\n  try {\n  f3.parse(\"2015-11-32\");\n  fail(\"Should not pass\");\n  } catch (ParseException e) {\n  verifyException(e, \"can not parse date\");\n  }\n\n  // ... yet, with lenient, do allow\n  f3.setLenient(true);\n  dt = f3.parse(\"2015-11-32\");\n  assertNotNull(dt);\n  }",
        "stack": [
          "TestStdDateFormat.testLenient line 29"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/util/StdDateFormat.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.util;\n\nimport java.text.DateFormat;\nimport java.text.FieldPosition;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n\n@SuppressWarnings(\"serial\")\npublic class StdDateFormat extends DateFormat { protected final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"; protected final static String DATE_FORMAT_STR_ISO8601_Z = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"; protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\"; protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }; private final static TimeZone DEFAULT_TIMEZONE; static { DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); } private final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123; protected final static DateFormat DATE_FORMAT_ISO8601; protected final static DateFormat DATE_FORMAT_ISO8601_Z; protected final static DateFormat DATE_FORMAT_PLAIN; static {\n        \n\n        DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE);\n        DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE);\n        DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE);\n    }\n    \n    \n    public final static StdDateFormat instance = new StdDateFormat(); protected transient TimeZone _timezone; protected final Locale _locale; protected Boolean _lenient; protected transient DateFormat _formatRFC1123; protected transient DateFormat _formatISO8601; protected transient DateFormat _formatISO8601_z; protected transient DateFormat _formatPlain; public StdDateFormat() {\n        _locale = DEFAULT_LOCALE;\n    }\n\n    @Deprecated \n    public StdDateFormat(TimeZone tz, Locale loc) {\n        _timezone = tz;\n        _locale = loc;\n    }\n\n    protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) {\n        _timezone = tz;\n        _locale = loc;\n        _lenient = lenient;\n    }\n    \n    public static TimeZone getDefaultTimeZone() {\n        return DEFAULT_TIMEZONE;\n    }\n    \n    \n    public StdDateFormat withTimeZone(TimeZone tz) {\n        if (tz == null) {\n            tz = DEFAULT_TIMEZONE;\n        }\n        if ((tz == _timezone) || tz.equals(_timezone)) {\n            return this;\n        }\n        return new StdDateFormat(tz, _locale, _lenient);\n    }\n\n    public StdDateFormat withLocale(Locale loc) {\n        if (loc.equals(_locale)) {\n            return this;\n        }\n        return new StdDateFormat(_timezone, loc, _lenient);\n    }\n    \n    @Override\n    public StdDateFormat clone() {\n        \n        return new StdDateFormat(_timezone, _locale, _lenient);\n    }\n\n    \n    @Deprecated\n    public static DateFormat getISO8601Format(TimeZone tz) {\n        return getISO8601Format(tz, DEFAULT_LOCALE);\n    }\n\n    \n    public static DateFormat getISO8601Format(TimeZone tz, Locale loc) {\n        return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null);\n    }\n\n    \n    public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) {\n        return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,\n                tz, loc, null);\n    }\n\n    \n    @Deprecated\n    public static DateFormat getRFC1123Format(TimeZone tz) {\n        return getRFC1123Format(tz, DEFAULT_LOCALE);\n    }\n\n    \n\n    @Override \n    public TimeZone getTimeZone() {\n        return _timezone;\n    }\n\n    @Override\n    public void setTimeZone(TimeZone tz) {\n        \n        if (!tz.equals(_timezone)) {\n            _clearFormats();\n            _timezone = tz;\n        }\n    }\n\n    \n            \n\n    @Override \n    public boolean isLenient() {\n        if (_lenient == null) {\n            \n            return true;\n        }\n        return _lenient.booleanValue();\n    }\n\n    \n\n    @Override\n    public Date parse(String dateStr) throws ParseException {\n        dateStr = dateStr.trim();\n        ParsePosition pos = new ParsePosition(0);\n\n        Date dt;\n\n        if (looksLikeISO8601(dateStr)) { \n            dt = parseAsISO8601(dateStr, pos, true);\n        } else {\n            \n            int i = dateStr.length();\n            while (--i >= 0) {\n                char ch = dateStr.charAt(i);\n                if (ch < '0' || ch > '9') {\n                    \n                    if (i > 0 || ch != '-') {\n                        break;\n                    }\n                }\n            }\n            if ((i < 0)\n                \n                    && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) {\n                dt = new Date(Long.parseLong(dateStr));\n            } else {\n                \n                dt = parseAsRFC1123(dateStr, pos);\n            }\n        }\n        if (dt != null) {\n            return dt;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (String f : ALL_FORMATS) {\n            if (sb.length() > 0) {\n                sb.append(\"\\\", \\\"\");\n            } else {\n                sb.append('\"');\n            }\n            sb.append(f);\n        }\n        sb.append('\"');\n        throw new ParseException\n            (String.format(\"Can not parse date \\\"%s\\\": not compatible with any of standard forms (%s)\",\n                           dateStr, sb.toString()), pos.getErrorIndex());\n    }\n\n    @Override\n    public Date parse(String dateStr, ParsePosition pos) {\n        if (looksLikeISO8601(dateStr)) { \n            try {\n                return parseAsISO8601(dateStr, pos, false);\n            } catch (ParseException e) { \n                return null;\n            }\n        }\n        \n        int i = dateStr.length();\n        while (--i >= 0) {\n            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') {\n                \n                if (i > 0 || ch != '-') {\n                    break;\n                }\n            }\n        }\n        if (i < 0) { \n            \n            if (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        \n        return parseAsRFC1123(dateStr, pos);\n    }\n\n    \n    \n    @Override\n    public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) {\n        if (_formatISO8601 == null) {\n            _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601,\n                    _timezone, _locale, _lenient);\n        }\n        return _formatISO8601.format(date, toAppendTo, fieldPosition);\n    }\n\n    \n    \n    @Override\n    public String toString() {\n        String str = \"DateFormat \"+getClass().getName();\n        TimeZone tz = _timezone;\n        if (tz != null) {\n            str += \" (timezone: \"+tz+\")\";\n        }\n        str += \"(locale: \"+_locale+\")\";\n        return str;\n    }\n    \n    \n\n    \n    protected boolean looksLikeISO8601(String dateStr) {\n        if (dateStr.length() >= 5\n            && Character.isDigit(dateStr.charAt(0))\n            && Character.isDigit(dateStr.charAt(3))\n            && dateStr.charAt(4) == '-'\n            ) {\n            return true;\n        }\n        return false;\n    }\n\n    protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n        \n\n        \n        int len = dateStr.length();\n        char c = dateStr.charAt(len-1);\n        DateFormat df;\n        String formatStr;\n\n        \n        if (len <= 10 && Character.isDigit(c)) {\n            df = _formatPlain;\n            formatStr = DATE_FORMAT_STR_PLAIN;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr,\n                        _timezone, _locale, _lenient);\n            }\n        } else if (c == 'Z') {\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,\n                        _timezone, _locale, _lenient);\n            }\n            \n            if (dateStr.charAt(len-4) == ':') {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len-1, \".000\");\n                dateStr = sb.toString();\n            }\n        } else {\n            \n            if (hasTimeZone(dateStr)) {\n                c = dateStr.charAt(len-3);\n                if (c == ':') { \n                    \n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.delete(len-3, len-2);\n                    dateStr = sb.toString();\n                } else if (c == '+' || c == '-') { \n                    \n                    dateStr += \"00\";\n                }\n                \n                len = dateStr.length();\n                \n                int timeLen = len - dateStr.lastIndexOf('T') - 6;\n                if (timeLen < 12) { \n                    int offset = len - 5; \n                    StringBuilder sb = new StringBuilder(dateStr);\n                    switch (timeLen) {\n                    case 11:\n                        sb.insert(offset, '0'); break;\n                    case 10:\n                        sb.insert(offset, \"00\"); break;\n                    case 9: \n                        sb.insert(offset, \"000\"); break;\n                    case 8:\n                        sb.insert(offset, \".000\"); break;\n                    case 7: \n                        break;\n                    case 6: \n                        sb.insert(offset, \"00.000\");\n                    case 5: \n                        sb.insert(offset, \":00.000\");\n                    }\n                    dateStr = sb.toString();\n                }\n                df = _formatISO8601;\n                formatStr = DATE_FORMAT_STR_ISO8601;\n                if (_formatISO8601 == null) {\n                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr,\n                            _timezone, _locale, _lenient);\n                }\n            } else {\n                \n                StringBuilder sb = new StringBuilder(dateStr);\n                \n                int timeLen = len - dateStr.lastIndexOf('T') - 1;\n                if (timeLen < 12) { \n                    switch (timeLen) {\n                    case 11: sb.append('0');\n                    case 10: sb.append('0');\n                    case 9: sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                    }\n                }\n                sb.append('Z');\n                dateStr = sb.toString();\n                df = _formatISO8601_z;\n                formatStr = DATE_FORMAT_STR_ISO8601_Z;\n                if (df == null) {\n                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,\n                            _timezone, _locale, _lenient);\n                }\n            }\n        }\n        Date dt = df.parse(dateStr, pos);\n        \n        if (dt == null) {\n            throw new ParseException\n            (String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\",\n                           dateStr, formatStr, _lenient),\n               pos.getErrorIndex());\n        }\n        return dt;\n    }\n\n    protected Date parseAsRFC1123(String dateStr, ParsePosition pos) {\n        if (_formatRFC1123 == null) {\n            _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,\n                    _timezone, _locale, _lenient);\n        }\n        return _formatRFC1123.parse(dateStr, pos);\n    }\n\n    private final static boolean hasTimeZone(String str) {\n        \n        int len = str.length();\n        if (len >= 6) {\n            char c = str.charAt(len-6);\n            if (c == '+' || c == '-') return true;\n            c = str.charAt(len-5);\n            if (c == '+' || c == '-') return true;\n            c = str.charAt(len-3);\n            if (c == '+' || c == '-') return true;\n        }\n        return false;\n    }\n\n    private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n        if (!loc.equals(DEFAULT_LOCALE)) {\n            df = new SimpleDateFormat(format, loc);\n            df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n        } else {\n            df = (DateFormat) df.clone();\n            if (tz != null) {\n                df.setTimeZone(tz);\n            }\n        }\n        return df;\n    }\n\n    protected void _clearFormats() {\n        _formatRFC1123 = null;\n        _formatISO8601 = null;\n        _formatISO8601_z = null;\n        _formatPlain = null;\n    }\n}\n\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.util;\n\nimport java.text.DateFormat;\nimport java.text.FieldPosition;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n\n@SuppressWarnings(\"serial\")\npublic class StdDateFormat extends DateFormat { protected final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"; protected final static String DATE_FORMAT_STR_ISO8601_Z = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"; protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\"; protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }; private final static TimeZone DEFAULT_TIMEZONE; static { DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); } private final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123; protected final static DateFormat DATE_FORMAT_ISO8601; protected final static DateFormat DATE_FORMAT_ISO8601_Z; protected final static DateFormat DATE_FORMAT_PLAIN; static {\n        \n\n        DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE);\n        DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE);\n        DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE);\n    }\n    \n    \n    public final static StdDateFormat instance = new StdDateFormat(); protected transient TimeZone _timezone; protected final Locale _locale; protected Boolean _lenient; protected transient DateFormat _formatRFC1123; protected transient DateFormat _formatISO8601; protected transient DateFormat _formatISO8601_z; protected transient DateFormat _formatPlain; public StdDateFormat() {\n        _locale = DEFAULT_LOCALE;\n    }\n\n    @Deprecated \n    public StdDateFormat(TimeZone tz, Locale loc) {\n        _timezone = tz;\n        _locale = loc;\n    }\n\n    protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) {\n        _timezone = tz;\n        _locale = loc;\n        _lenient = lenient;\n    }\n    \n    public static TimeZone getDefaultTimeZone() {\n        return DEFAULT_TIMEZONE;\n    }\n    \n    \n    public StdDateFormat withTimeZone(TimeZone tz) {\n        if (tz == null) {\n            tz = DEFAULT_TIMEZONE;\n        }\n        if ((tz == _timezone) || tz.equals(_timezone)) {\n            return this;\n        }\n        return new StdDateFormat(tz, _locale, _lenient);\n    }\n\n    public StdDateFormat withLocale(Locale loc) {\n        if (loc.equals(_locale)) {\n            return this;\n        }\n        return new StdDateFormat(_timezone, loc, _lenient);\n    }\n    \n    @Override\n    public StdDateFormat clone() {\n        \n        return new StdDateFormat(_timezone, _locale, _lenient);\n    }\n\n    \n    @Deprecated\n    public static DateFormat getISO8601Format(TimeZone tz) {\n        return getISO8601Format(tz, DEFAULT_LOCALE);\n    }\n\n    \n    public static DateFormat getISO8601Format(TimeZone tz, Locale loc) {\n        return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null);\n    }\n\n    \n    public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) {\n        return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,\n                tz, loc, null);\n    }\n\n    \n    @Deprecated\n    public static DateFormat getRFC1123Format(TimeZone tz) {\n        return getRFC1123Format(tz, DEFAULT_LOCALE);\n    }\n\n    \n\n    @Override \n    public TimeZone getTimeZone() {\n        return _timezone;\n    }\n\n    @Override\n    public void setTimeZone(TimeZone tz) {\n        \n        if (!tz.equals(_timezone)) {\n            _clearFormats();\n            _timezone = tz;\n        }\n    }\n\n    \n    @Override \n    public void setLenient(boolean enabled) {\n        Boolean newValue = enabled;\n        if (_lenient != newValue) {\n            _lenient = newValue;\n            \n            _clearFormats();\n        }\n    }\n\n    @Override \n    public boolean isLenient() {\n        if (_lenient == null) {\n            \n            return true;\n        }\n        return _lenient.booleanValue();\n    }\n\n    \n\n    @Override\n    public Date parse(String dateStr) throws ParseException {\n        dateStr = dateStr.trim();\n        ParsePosition pos = new ParsePosition(0);\n\n        Date dt;\n\n        if (looksLikeISO8601(dateStr)) { \n            dt = parseAsISO8601(dateStr, pos, true);\n        } else {\n            \n            int i = dateStr.length();\n            while (--i >= 0) {\n                char ch = dateStr.charAt(i);\n                if (ch < '0' || ch > '9') {\n                    \n                    if (i > 0 || ch != '-') {\n                        break;\n                    }\n                }\n            }\n            if ((i < 0)\n                \n                    && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) {\n                dt = new Date(Long.parseLong(dateStr));\n            } else {\n                \n                dt = parseAsRFC1123(dateStr, pos);\n            }\n        }\n        if (dt != null) {\n            return dt;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (String f : ALL_FORMATS) {\n            if (sb.length() > 0) {\n                sb.append(\"\\\", \\\"\");\n            } else {\n                sb.append('\"');\n            }\n            sb.append(f);\n        }\n        sb.append('\"');\n        throw new ParseException\n            (String.format(\"Can not parse date \\\"%s\\\": not compatible with any of standard forms (%s)\",\n                           dateStr, sb.toString()), pos.getErrorIndex());\n    }\n\n    @Override\n    public Date parse(String dateStr, ParsePosition pos) {\n        if (looksLikeISO8601(dateStr)) { \n            try {\n                return parseAsISO8601(dateStr, pos, false);\n            } catch (ParseException e) { \n                return null;\n            }\n        }\n        \n        int i = dateStr.length();\n        while (--i >= 0) {\n            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') {\n                \n                if (i > 0 || ch != '-') {\n                    break;\n                }\n            }\n        }\n        if (i < 0) { \n            \n            if (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        \n        return parseAsRFC1123(dateStr, pos);\n    }\n\n    \n    \n    @Override\n    public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) {\n        if (_formatISO8601 == null) {\n            _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601,\n                    _timezone, _locale, _lenient);\n        }\n        return _formatISO8601.format(date, toAppendTo, fieldPosition);\n    }\n\n    \n    \n    @Override\n    public String toString() {\n        String str = \"DateFormat \"+getClass().getName();\n        TimeZone tz = _timezone;\n        if (tz != null) {\n            str += \" (timezone: \"+tz+\")\";\n        }\n        str += \"(locale: \"+_locale+\")\";\n        return str;\n    }\n    \n    \n\n    \n    protected boolean looksLikeISO8601(String dateStr) {\n        if (dateStr.length() >= 5\n            && Character.isDigit(dateStr.charAt(0))\n            && Character.isDigit(dateStr.charAt(3))\n            && dateStr.charAt(4) == '-'\n            ) {\n            return true;\n        }\n        return false;\n    }\n\n    protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n        \n\n        \n        int len = dateStr.length();\n        char c = dateStr.charAt(len-1);\n        DateFormat df;\n        String formatStr;\n\n        \n        if (len <= 10 && Character.isDigit(c)) {\n            df = _formatPlain;\n            formatStr = DATE_FORMAT_STR_PLAIN;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr,\n                        _timezone, _locale, _lenient);\n            }\n        } else if (c == 'Z') {\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,\n                        _timezone, _locale, _lenient);\n            }\n            \n            if (dateStr.charAt(len-4) == ':') {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len-1, \".000\");\n                dateStr = sb.toString();\n            }\n        } else {\n            \n            if (hasTimeZone(dateStr)) {\n                c = dateStr.charAt(len-3);\n                if (c == ':') { \n                    \n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.delete(len-3, len-2);\n                    dateStr = sb.toString();\n                } else if (c == '+' || c == '-') { \n                    \n                    dateStr += \"00\";\n                }\n                \n                len = dateStr.length();\n                \n                int timeLen = len - dateStr.lastIndexOf('T') - 6;\n                if (timeLen < 12) { \n                    int offset = len - 5; \n                    StringBuilder sb = new StringBuilder(dateStr);\n                    switch (timeLen) {\n                    case 11:\n                        sb.insert(offset, '0'); break;\n                    case 10:\n                        sb.insert(offset, \"00\"); break;\n                    case 9: \n                        sb.insert(offset, \"000\"); break;\n                    case 8:\n                        sb.insert(offset, \".000\"); break;\n                    case 7: \n                        break;\n                    case 6: \n                        sb.insert(offset, \"00.000\");\n                    case 5: \n                        sb.insert(offset, \":00.000\");\n                    }\n                    dateStr = sb.toString();\n                }\n                df = _formatISO8601;\n                formatStr = DATE_FORMAT_STR_ISO8601;\n                if (_formatISO8601 == null) {\n                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr,\n                            _timezone, _locale, _lenient);\n                }\n            } else {\n                \n                StringBuilder sb = new StringBuilder(dateStr);\n                \n                int timeLen = len - dateStr.lastIndexOf('T') - 1;\n                if (timeLen < 12) { \n                    switch (timeLen) {\n                    case 11: sb.append('0');\n                    case 10: sb.append('0');\n                    case 9: sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                    }\n                }\n                sb.append('Z');\n                dateStr = sb.toString();\n                df = _formatISO8601_z;\n                formatStr = DATE_FORMAT_STR_ISO8601_Z;\n                if (df == null) {\n                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,\n                            _timezone, _locale, _lenient);\n                }\n            }\n        }\n        Date dt = df.parse(dateStr, pos);\n        \n        if (dt == null) {\n            throw new ParseException\n            (String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\",\n                           dateStr, formatStr, _lenient),\n               pos.getErrorIndex());\n        }\n        return dt;\n    }\n\n    protected Date parseAsRFC1123(String dateStr, ParsePosition pos) {\n        if (_formatRFC1123 == null) {\n            _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,\n                    _timezone, _locale, _lenient);\n        }\n        return _formatRFC1123.parse(dateStr, pos);\n    }\n\n    private final static boolean hasTimeZone(String str) {\n        \n        int len = str.length();\n        if (len >= 6) {\n            char c = str.charAt(len-6);\n            if (c == '+' || c == '-') return true;\n            c = str.charAt(len-5);\n            if (c == '+' || c == '-') return true;\n            c = str.charAt(len-3);\n            if (c == '+' || c == '-') return true;\n        }\n        return false;\n    }\n\n    private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n        if (!loc.equals(DEFAULT_LOCALE)) {\n            df = new SimpleDateFormat(format, loc);\n            df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n        } else {\n            df = (DateFormat) df.clone();\n            if (tz != null) {\n                df.setTimeZone(tz);\n            }\n        }\n        if (lenient != null) {\n            df.setLenient(lenient.booleanValue());\n        }\n        return df;\n    }\n\n    protected void _clearFormats() {\n        _formatRFC1123 = null;\n        _formatISO8601 = null;\n        _formatISO8601_z = null;\n        _formatPlain = null;\n    }\n}\n\n",
      "buggy_signatures": [
        "public StdDateFormat(TimeZone tz, Locale loc)",
        "protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient)",
        "public static TimeZone getDefaultTimeZone()",
        "public StdDateFormat withTimeZone(TimeZone tz)",
        "public StdDateFormat withLocale(Locale loc)",
        "public StdDateFormat clone()",
        "public static DateFormat getISO8601Format(TimeZone tz)",
        "public static DateFormat getISO8601Format(TimeZone tz, Locale loc)",
        "public static DateFormat getRFC1123Format(TimeZone tz, Locale loc)",
        "public static DateFormat getRFC1123Format(TimeZone tz)",
        "public TimeZone getTimeZone()",
        "public void setTimeZone(TimeZone tz)",
        "public boolean isLenient()",
        "public Date parse(String dateStr) throws ParseException",
        "public Date parse(String dateStr, ParsePosition pos)",
        "public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition)",
        "public String toString()",
        "protected boolean looksLikeISO8601(String dateStr)",
        "protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException",
        "protected Date parseAsRFC1123(String dateStr, ParsePosition pos)",
        "private final static boolean hasTimeZone(String str)",
        "private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient)",
        "protected void _clearFormats()"
      ],
      "fixed_signatures": [
        "public StdDateFormat(TimeZone tz, Locale loc)",
        "protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient)",
        "public static TimeZone getDefaultTimeZone()",
        "public StdDateFormat withTimeZone(TimeZone tz)",
        "public StdDateFormat withLocale(Locale loc)",
        "public StdDateFormat clone()",
        "public static DateFormat getISO8601Format(TimeZone tz)",
        "public static DateFormat getISO8601Format(TimeZone tz, Locale loc)",
        "public static DateFormat getRFC1123Format(TimeZone tz, Locale loc)",
        "public static DateFormat getRFC1123Format(TimeZone tz)",
        "public TimeZone getTimeZone()",
        "public void setTimeZone(TimeZone tz)",
        "public void setLenient(boolean enabled)",
        "public boolean isLenient()",
        "public Date parse(String dateStr) throws ParseException",
        "public Date parse(String dateStr, ParsePosition pos)",
        "public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition)",
        "public String toString()",
        "protected boolean looksLikeISO8601(String dateStr)",
        "protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException",
        "protected Date parseAsRFC1123(String dateStr, ParsePosition pos)",
        "private final static boolean hasTimeZone(String str)",
        "private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient)",
        "protected void _clearFormats()"
      ],
      "methods": [
        {
          "buggy_method": "  public boolean isLenient() {\n  if (_lenient == null) {\n  \n  return true;\n  }\n  return _lenient.booleanValue();\n  }",
          "fixed_method": "  public void setLenient(boolean enabled) {\n  Boolean newValue = enabled;\n  if (_lenient != newValue) {\n  _lenient = newValue;\n  \n  _clearFormats();\n  }\n  }",
          "diff": [
            "@@ -247,7 +247,15 @@",
            "      * and not via underlying {@link Calendar} instance like base class\n",
            "      * does.\n",
            "      */\n",
            "+    @Override // since 2.7\n",
            "+    public void setLenient(boolean enabled) {\n",
            "+        Boolean newValue = enabled;\n",
            "+        if (_lenient != newValue) {\n",
            "+            _lenient = newValue;\n",
            "             // and since leniency settings may have been used:\n",
            "+            _clearFormats();\n",
            "+        }\n",
            "+    }\n",
            " \n",
            "     @Override // since 2.7\n",
            "     public boolean isLenient() {\n"
          ],
          "changed_lines": 8
        },
        {
          "buggy_method": "  protected void _clearFormats() {\n  _formatRFC1123 = null;\n  _formatISO8601 = null;\n  _formatISO8601_z = null;\n  _formatPlain = null;\n  }",
          "fixed_method": "  private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n  if (!loc.equals(DEFAULT_LOCALE)) {\n  df = new SimpleDateFormat(format, loc);\n  df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n  } else {\n  df = (DateFormat) df.clone();\n  if (tz != null) {\n  df.setTimeZone(tz);\n  }\n  }\n  if (lenient != null) {\n  df.setLenient(lenient.booleanValue());\n  }\n  return df;\n  }",
          "diff": [
            "@@ -554,6 +562,9 @@",
            "                 df.setTimeZone(tz);\n",
            "             }\n",
            "         }\n",
            "+        if (lenient != null) {\n",
            "+            df.setLenient(lenient.booleanValue());\n",
            "+        }\n",
            "         return df;\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
