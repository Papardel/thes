{
  "bug_id": "49",
  "failed_tests": {
    "org.jsoup.nodes.ElementTest": [
      {
        "methodName": "appendMustCorrectlyMoveChildrenInsideOneParentElement",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<...><div3>Check</div3><[div4></div4><div1></div1><div2></div2><]/body>> but was:<...><div3>Check</div3><[]/body>>",
        "fail_line": "        assertEquals(\"<body><div3>Check</div3><div4></div4><div1></div1><div2></div2></body>\", result);",
        "test_source": "  public void appendMustCorrectlyMoveChildrenInsideOneParentElement() {\n  Document doc = new Document(\"\");\n  Element body = doc.appendElement(\"body\");\n  body.appendElement(\"div1\");\n  body.appendElement(\"div2\");\n  final Element div3 = body.appendElement(\"div3\");\n  div3.text(\"Check\");\n  final Element div4 = body.appendElement(\"div4\");\n\n  ArrayList<Element> toMove = new ArrayList<Element>();\n  toMove.add(div3);\n  toMove.add(div4);\n\n  body.insertChildren(0, toMove);\n\n  String result = doc.toString().replaceAll(\"\\\\s+\", \"\");\n  assertEquals(\"<body><div3>Check</div3><div4></div4><div1></div1><div2></div2></body>\", result);\n\n  }",
        "stack": [
          "ElementTest.appendMustCorrectlyMoveChildrenInsideOneParentElement line 878"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/nodes/Node.java",
      "buggy_full_code": "package org.jsoup.nodes;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.select.NodeTraversor;\nimport org.jsoup.select.NodeVisitor;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\n\n\npublic abstract class Node implements Cloneable { private static final List<Node> EMPTY_NODES = Collections.emptyList(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri; int siblingIndex; protected Node(String baseUri, Attributes attributes) {\n        Validate.notNull(baseUri);\n        Validate.notNull(attributes);\n        \n        childNodes = EMPTY_NODES;\n        this.baseUri = baseUri.trim();\n        this.attributes = attributes;\n    }\n\n    protected Node(String baseUri) {\n        this(baseUri, new Attributes());\n    }\n\n    \n    protected Node() {\n        childNodes = EMPTY_NODES;\n        attributes = null;\n    }\n\n    \n    public abstract String nodeName(); public String attr(String attributeKey) {\n        Validate.notNull(attributeKey);\n\n        if (attributes.hasKey(attributeKey))\n            return attributes.get(attributeKey);\n        else if (attributeKey.toLowerCase().startsWith(\"abs:\"))\n            return absUrl(attributeKey.substring(\"abs:\".length()));\n        else return \"\";\n    }\n\n    \n    public Attributes attributes() {\n        return attributes;\n    }\n\n    \n    public Node attr(String attributeKey, String attributeValue) {\n        attributes.put(attributeKey, attributeValue);\n        return this;\n    }\n\n    \n    public boolean hasAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n\n        if (attributeKey.startsWith(\"abs:\")) {\n            String key = attributeKey.substring(\"abs:\".length());\n            if (attributes.hasKey(key) && !absUrl(key).equals(\"\"))\n                return true;\n        }\n        return attributes.hasKey(attributeKey);\n    }\n\n    \n    public Node removeAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        attributes.remove(attributeKey);\n        return this;\n    }\n\n    \n    public String baseUri() {\n        return baseUri;\n    }\n\n    \n    public void setBaseUri(final String baseUri) {\n        Validate.notNull(baseUri);\n\n        traverse(new NodeVisitor() {\n            public void head(Node node, int depth) {\n                node.baseUri = baseUri;\n            }\n\n            public void tail(Node node, int depth) {\n            }\n        });\n    }\n\n    \n    public String absUrl(String attributeKey) {\n        Validate.notEmpty(attributeKey);\n\n        if (!hasAttr(attributeKey)) {\n            return \"\"; \n        } else {\n            return StringUtil.resolve(baseUri, attr(attributeKey));\n        }\n    }\n\n    \n    public Node childNode(int index) {\n        return childNodes.get(index);\n    }\n\n    \n    public List<Node> childNodes() {\n        return Collections.unmodifiableList(childNodes);\n    }\n\n    \n    public List<Node> childNodesCopy() {\n        List<Node> children = new ArrayList<Node>(childNodes.size());\n        for (Node node : childNodes) {\n            children.add(node.clone());\n        }\n        return children;\n    }\n\n    \n    public final int childNodeSize() {\n        return childNodes.size();\n    }\n    \n    protected Node[] childNodesAsArray() {\n        return childNodes.toArray(new Node[childNodeSize()]);\n    }\n\n    \n    public Node parent() {\n        return parentNode;\n    }\n\n    \n    public final Node parentNode() {\n        return parentNode;\n    }\n    \n    \n    public Document ownerDocument() {\n        if (this instanceof Document)\n            return (Document) this;\n        else if (parentNode == null)\n            return null;\n        else\n            return parentNode.ownerDocument();\n    }\n    \n    \n    public void remove() {\n        Validate.notNull(parentNode);\n        parentNode.removeChild(this);\n    }\n\n    \n    public Node before(String html) {\n        addSiblingHtml(siblingIndex, html);\n        return this;\n    }\n\n    \n    public Node before(Node node) {\n        Validate.notNull(node);\n        Validate.notNull(parentNode);\n\n        parentNode.addChildren(siblingIndex, node);\n        return this;\n    }\n\n    \n    public Node after(String html) {\n        addSiblingHtml(siblingIndex + 1, html);\n        return this;\n    }\n\n    \n    public Node after(Node node) {\n        Validate.notNull(node);\n        Validate.notNull(parentNode);\n\n        parentNode.addChildren(siblingIndex + 1, node);\n        return this;\n    }\n\n    private void addSiblingHtml(int index, String html) {\n        Validate.notNull(html);\n        Validate.notNull(parentNode);\n\n        Element context = parent() instanceof Element ? (Element) parent() : null;        \n        List<Node> nodes = Parser.parseFragment(html, context, baseUri());\n        parentNode.addChildren(index, nodes.toArray(new Node[nodes.size()]));\n    }\n\n    \n    public Node wrap(String html) {\n        Validate.notEmpty(html);\n\n        Element context = parent() instanceof Element ? (Element) parent() : null;\n        List<Node> wrapChildren = Parser.parseFragment(html, context, baseUri());\n        Node wrapNode = wrapChildren.get(0);\n        if (wrapNode == null || !(wrapNode instanceof Element)) \n            return null;\n\n        Element wrap = (Element) wrapNode;\n        Element deepest = getDeepChild(wrap);\n        parentNode.replaceChild(this, wrap);\n        deepest.addChildren(this);\n\n        \n        if (wrapChildren.size() > 0) {\n            for (int i = 0; i < wrapChildren.size(); i++) {\n                Node remainder = wrapChildren.get(i);\n                remainder.parentNode.removeChild(remainder);\n                wrap.appendChild(remainder);\n            }\n        }\n        return this;\n    }\n\n    \n    public Node unwrap() {\n        Validate.notNull(parentNode);\n\n        Node firstChild = childNodes.size() > 0 ? childNodes.get(0) : null;\n        parentNode.addChildren(siblingIndex, this.childNodesAsArray());\n        this.remove();\n\n        return firstChild;\n    }\n\n    private Element getDeepChild(Element el) {\n        List<Element> children = el.children();\n        if (children.size() > 0)\n            return getDeepChild(children.get(0));\n        else\n            return el;\n    }\n    \n    \n    public void replaceWith(Node in) {\n        Validate.notNull(in);\n        Validate.notNull(parentNode);\n        parentNode.replaceChild(this, in);\n    }\n\n    protected void setParentNode(Node parentNode) {\n        if (this.parentNode != null)\n            this.parentNode.removeChild(this);\n        this.parentNode = parentNode;\n    }\n\n    protected void replaceChild(Node out, Node in) {\n        Validate.isTrue(out.parentNode == this);\n        Validate.notNull(in);\n        if (in.parentNode != null)\n            in.parentNode.removeChild(in);\n        \n        final int index = out.siblingIndex;\n        childNodes.set(index, in);\n        in.parentNode = this;\n        in.setSiblingIndex(index);\n        out.parentNode = null;\n    }\n\n    protected void removeChild(Node out) {\n        Validate.isTrue(out.parentNode == this);\n        final int index = out.siblingIndex;\n        childNodes.remove(index);\n        reindexChildren(index);\n        out.parentNode = null;\n    }\n\n    protected void addChildren(Node... children) {\n        \n        for (Node child: children) {\n            reparentChild(child);\n            ensureChildNodes();\n            childNodes.add(child);\n            child.setSiblingIndex(childNodes.size()-1);\n        }\n    }\n\n    protected void addChildren(int index, Node... children) {\n        Validate.noNullElements(children);\n        ensureChildNodes();\n        for (int i = children.length - 1; i >= 0; i--) {\n            Node in = children[i];\n            reparentChild(in);\n            childNodes.add(index, in);\n        }\n        reindexChildren(index);\n    }\n\n    protected void ensureChildNodes() {\n        if (childNodes == EMPTY_NODES) {\n            childNodes = new ArrayList<Node>(4);\n        }\n    }\n\n    protected void reparentChild(Node child) {\n        if (child.parentNode != null)\n            child.parentNode.removeChild(child);\n        child.setParentNode(this);\n    }\n    \n    private void reindexChildren(int start) {\n        for (int i = start; i < childNodes.size(); i++) {\n            childNodes.get(i).setSiblingIndex(i);\n        }\n    }\n    \n    \n    public List<Node> siblingNodes() {\n        if (parentNode == null)\n            return Collections.emptyList();\n\n        List<Node> nodes = parentNode.childNodes;\n        List<Node> siblings = new ArrayList<Node>(nodes.size() - 1);\n        for (Node node: nodes)\n            if (node != this)\n                siblings.add(node);\n        return siblings;\n    }\n\n    \n    public Node nextSibling() {\n        if (parentNode == null)\n            return null; \n        \n        final List<Node> siblings = parentNode.childNodes;\n        final int index = siblingIndex+1;\n        if (siblings.size() > index)\n            return siblings.get(index);\n        else\n            return null;\n    }\n\n    \n    public Node previousSibling() {\n        if (parentNode == null)\n            return null; \n\n        if (siblingIndex > 0)\n            return parentNode.childNodes.get(siblingIndex-1);\n        else\n            return null;\n    }\n\n    \n    public int siblingIndex() {\n        return siblingIndex;\n    }\n    \n    protected void setSiblingIndex(int siblingIndex) {\n        this.siblingIndex = siblingIndex;\n    }\n\n    \n    public Node traverse(NodeVisitor nodeVisitor) {\n        Validate.notNull(nodeVisitor);\n        NodeTraversor traversor = new NodeTraversor(nodeVisitor);\n        traversor.traverse(this);\n        return this;\n    }\n\n    \n    public String outerHtml() {\n        StringBuilder accum = new StringBuilder(128);\n        outerHtml(accum);\n        return accum.toString();\n    }\n\n    protected void outerHtml(StringBuilder accum) {\n        new NodeTraversor(new OuterHtmlVisitor(accum, getOutputSettings())).traverse(this);\n    }\n\n    \n    Document.OutputSettings getOutputSettings() {\n        return ownerDocument() != null ? ownerDocument().outputSettings() : (new Document(\"\")).outputSettings();\n    }\n\n    \n    abstract void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out); abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out); @Override public String toString() {\n        return outerHtml();\n    }\n\n    protected void indent(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"\\n\").append(StringUtil.padding(depth * out.indentAmount()));\n    }\n\n    \n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Node node = (Node) o;\n\n        if (childNodes != null ? !childNodes.equals(node.childNodes) : node.childNodes != null) return false;\n        return !(attributes != null ? !attributes.equals(node.attributes) : node.attributes != null);\n    }\n\n    \n    @Override\n    public int hashCode() {\n        int result = childNodes != null ? childNodes.hashCode() : 0;\n        result = 31 * result + (attributes != null ? attributes.hashCode() : 0);\n        return result;\n    }\n\n    \n    @Override\n    public Node clone() {\n        Node thisClone = doClone(null); \n\n        \n        LinkedList<Node> nodesToProcess = new LinkedList<Node>();\n        nodesToProcess.add(thisClone);\n\n        while (!nodesToProcess.isEmpty()) {\n            Node currParent = nodesToProcess.remove();\n\n            for (int i = 0; i < currParent.childNodes.size(); i++) {\n                Node childClone = currParent.childNodes.get(i).doClone(currParent);\n                currParent.childNodes.set(i, childClone);\n                nodesToProcess.add(childClone);\n            }\n        }\n\n        return thisClone;\n    }\n\n    \n    protected Node doClone(Node parent) {\n        Node clone;\n\n        try {\n            clone = (Node) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n\n        clone.parentNode = parent; \n        clone.siblingIndex = parent == null ? 0 : siblingIndex;\n        clone.attributes = attributes != null ? attributes.clone() : null;\n        clone.baseUri = baseUri;\n        clone.childNodes = new ArrayList<Node>(childNodes.size());\n\n        for (Node child: childNodes)\n            clone.childNodes.add(child);\n\n        return clone;\n    }\n\n    private static class OuterHtmlVisitor implements NodeVisitor { private StringBuilder accum; private Document.OutputSettings out; OuterHtmlVisitor(StringBuilder accum, Document.OutputSettings out) {\n            this.accum = accum;\n            this.out = out;\n        }\n\n        public void head(Node node, int depth) {\n            node.outerHtmlHead(accum, depth, out);\n        }\n\n        public void tail(Node node, int depth) {\n            if (!node.nodeName().equals(\"#text\")) \n                node.outerHtmlTail(accum, depth, out);\n        }\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.nodes;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.select.NodeTraversor;\nimport org.jsoup.select.NodeVisitor;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\n\n\npublic abstract class Node implements Cloneable { private static final List<Node> EMPTY_NODES = Collections.emptyList(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri; int siblingIndex; protected Node(String baseUri, Attributes attributes) {\n        Validate.notNull(baseUri);\n        Validate.notNull(attributes);\n        \n        childNodes = EMPTY_NODES;\n        this.baseUri = baseUri.trim();\n        this.attributes = attributes;\n    }\n\n    protected Node(String baseUri) {\n        this(baseUri, new Attributes());\n    }\n\n    \n    protected Node() {\n        childNodes = EMPTY_NODES;\n        attributes = null;\n    }\n\n    \n    public abstract String nodeName(); public String attr(String attributeKey) {\n        Validate.notNull(attributeKey);\n\n        if (attributes.hasKey(attributeKey))\n            return attributes.get(attributeKey);\n        else if (attributeKey.toLowerCase().startsWith(\"abs:\"))\n            return absUrl(attributeKey.substring(\"abs:\".length()));\n        else return \"\";\n    }\n\n    \n    public Attributes attributes() {\n        return attributes;\n    }\n\n    \n    public Node attr(String attributeKey, String attributeValue) {\n        attributes.put(attributeKey, attributeValue);\n        return this;\n    }\n\n    \n    public boolean hasAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n\n        if (attributeKey.startsWith(\"abs:\")) {\n            String key = attributeKey.substring(\"abs:\".length());\n            if (attributes.hasKey(key) && !absUrl(key).equals(\"\"))\n                return true;\n        }\n        return attributes.hasKey(attributeKey);\n    }\n\n    \n    public Node removeAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        attributes.remove(attributeKey);\n        return this;\n    }\n\n    \n    public String baseUri() {\n        return baseUri;\n    }\n\n    \n    public void setBaseUri(final String baseUri) {\n        Validate.notNull(baseUri);\n\n        traverse(new NodeVisitor() {\n            public void head(Node node, int depth) {\n                node.baseUri = baseUri;\n            }\n\n            public void tail(Node node, int depth) {\n            }\n        });\n    }\n\n    \n    public String absUrl(String attributeKey) {\n        Validate.notEmpty(attributeKey);\n\n        if (!hasAttr(attributeKey)) {\n            return \"\"; \n        } else {\n            return StringUtil.resolve(baseUri, attr(attributeKey));\n        }\n    }\n\n    \n    public Node childNode(int index) {\n        return childNodes.get(index);\n    }\n\n    \n    public List<Node> childNodes() {\n        return Collections.unmodifiableList(childNodes);\n    }\n\n    \n    public List<Node> childNodesCopy() {\n        List<Node> children = new ArrayList<Node>(childNodes.size());\n        for (Node node : childNodes) {\n            children.add(node.clone());\n        }\n        return children;\n    }\n\n    \n    public final int childNodeSize() {\n        return childNodes.size();\n    }\n    \n    protected Node[] childNodesAsArray() {\n        return childNodes.toArray(new Node[childNodeSize()]);\n    }\n\n    \n    public Node parent() {\n        return parentNode;\n    }\n\n    \n    public final Node parentNode() {\n        return parentNode;\n    }\n    \n    \n    public Document ownerDocument() {\n        if (this instanceof Document)\n            return (Document) this;\n        else if (parentNode == null)\n            return null;\n        else\n            return parentNode.ownerDocument();\n    }\n    \n    \n    public void remove() {\n        Validate.notNull(parentNode);\n        parentNode.removeChild(this);\n    }\n\n    \n    public Node before(String html) {\n        addSiblingHtml(siblingIndex, html);\n        return this;\n    }\n\n    \n    public Node before(Node node) {\n        Validate.notNull(node);\n        Validate.notNull(parentNode);\n\n        parentNode.addChildren(siblingIndex, node);\n        return this;\n    }\n\n    \n    public Node after(String html) {\n        addSiblingHtml(siblingIndex + 1, html);\n        return this;\n    }\n\n    \n    public Node after(Node node) {\n        Validate.notNull(node);\n        Validate.notNull(parentNode);\n\n        parentNode.addChildren(siblingIndex + 1, node);\n        return this;\n    }\n\n    private void addSiblingHtml(int index, String html) {\n        Validate.notNull(html);\n        Validate.notNull(parentNode);\n\n        Element context = parent() instanceof Element ? (Element) parent() : null;        \n        List<Node> nodes = Parser.parseFragment(html, context, baseUri());\n        parentNode.addChildren(index, nodes.toArray(new Node[nodes.size()]));\n    }\n\n    \n    public Node wrap(String html) {\n        Validate.notEmpty(html);\n\n        Element context = parent() instanceof Element ? (Element) parent() : null;\n        List<Node> wrapChildren = Parser.parseFragment(html, context, baseUri());\n        Node wrapNode = wrapChildren.get(0);\n        if (wrapNode == null || !(wrapNode instanceof Element)) \n            return null;\n\n        Element wrap = (Element) wrapNode;\n        Element deepest = getDeepChild(wrap);\n        parentNode.replaceChild(this, wrap);\n        deepest.addChildren(this);\n\n        \n        if (wrapChildren.size() > 0) {\n            for (int i = 0; i < wrapChildren.size(); i++) {\n                Node remainder = wrapChildren.get(i);\n                remainder.parentNode.removeChild(remainder);\n                wrap.appendChild(remainder);\n            }\n        }\n        return this;\n    }\n\n    \n    public Node unwrap() {\n        Validate.notNull(parentNode);\n\n        Node firstChild = childNodes.size() > 0 ? childNodes.get(0) : null;\n        parentNode.addChildren(siblingIndex, this.childNodesAsArray());\n        this.remove();\n\n        return firstChild;\n    }\n\n    private Element getDeepChild(Element el) {\n        List<Element> children = el.children();\n        if (children.size() > 0)\n            return getDeepChild(children.get(0));\n        else\n            return el;\n    }\n    \n    \n    public void replaceWith(Node in) {\n        Validate.notNull(in);\n        Validate.notNull(parentNode);\n        parentNode.replaceChild(this, in);\n    }\n\n    protected void setParentNode(Node parentNode) {\n        if (this.parentNode != null)\n            this.parentNode.removeChild(this);\n        this.parentNode = parentNode;\n    }\n\n    protected void replaceChild(Node out, Node in) {\n        Validate.isTrue(out.parentNode == this);\n        Validate.notNull(in);\n        if (in.parentNode != null)\n            in.parentNode.removeChild(in);\n        \n        final int index = out.siblingIndex;\n        childNodes.set(index, in);\n        in.parentNode = this;\n        in.setSiblingIndex(index);\n        out.parentNode = null;\n    }\n\n    protected void removeChild(Node out) {\n        Validate.isTrue(out.parentNode == this);\n        final int index = out.siblingIndex;\n        childNodes.remove(index);\n        reindexChildren(index);\n        out.parentNode = null;\n    }\n\n    protected void addChildren(Node... children) {\n        \n        for (Node child: children) {\n            reparentChild(child);\n            ensureChildNodes();\n            childNodes.add(child);\n            child.setSiblingIndex(childNodes.size()-1);\n        }\n    }\n\n    protected void addChildren(int index, Node... children) {\n        Validate.noNullElements(children);\n        ensureChildNodes();\n        for (int i = children.length - 1; i >= 0; i--) {\n            Node in = children[i];\n            reparentChild(in);\n            childNodes.add(index, in);\n            reindexChildren(index);\n        }\n    }\n\n    protected void ensureChildNodes() {\n        if (childNodes == EMPTY_NODES) {\n            childNodes = new ArrayList<Node>(4);\n        }\n    }\n\n    protected void reparentChild(Node child) {\n        if (child.parentNode != null)\n            child.parentNode.removeChild(child);\n        child.setParentNode(this);\n    }\n    \n    private void reindexChildren(int start) {\n        for (int i = start; i < childNodes.size(); i++) {\n            childNodes.get(i).setSiblingIndex(i);\n        }\n    }\n    \n    \n    public List<Node> siblingNodes() {\n        if (parentNode == null)\n            return Collections.emptyList();\n\n        List<Node> nodes = parentNode.childNodes;\n        List<Node> siblings = new ArrayList<Node>(nodes.size() - 1);\n        for (Node node: nodes)\n            if (node != this)\n                siblings.add(node);\n        return siblings;\n    }\n\n    \n    public Node nextSibling() {\n        if (parentNode == null)\n            return null; \n        \n        final List<Node> siblings = parentNode.childNodes;\n        final int index = siblingIndex+1;\n        if (siblings.size() > index)\n            return siblings.get(index);\n        else\n            return null;\n    }\n\n    \n    public Node previousSibling() {\n        if (parentNode == null)\n            return null; \n\n        if (siblingIndex > 0)\n            return parentNode.childNodes.get(siblingIndex-1);\n        else\n            return null;\n    }\n\n    \n    public int siblingIndex() {\n        return siblingIndex;\n    }\n    \n    protected void setSiblingIndex(int siblingIndex) {\n        this.siblingIndex = siblingIndex;\n    }\n\n    \n    public Node traverse(NodeVisitor nodeVisitor) {\n        Validate.notNull(nodeVisitor);\n        NodeTraversor traversor = new NodeTraversor(nodeVisitor);\n        traversor.traverse(this);\n        return this;\n    }\n\n    \n    public String outerHtml() {\n        StringBuilder accum = new StringBuilder(128);\n        outerHtml(accum);\n        return accum.toString();\n    }\n\n    protected void outerHtml(StringBuilder accum) {\n        new NodeTraversor(new OuterHtmlVisitor(accum, getOutputSettings())).traverse(this);\n    }\n\n    \n    Document.OutputSettings getOutputSettings() {\n        return ownerDocument() != null ? ownerDocument().outputSettings() : (new Document(\"\")).outputSettings();\n    }\n\n    \n    abstract void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out); abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out); @Override public String toString() {\n        return outerHtml();\n    }\n\n    protected void indent(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"\\n\").append(StringUtil.padding(depth * out.indentAmount()));\n    }\n\n    \n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Node node = (Node) o;\n\n        if (childNodes != null ? !childNodes.equals(node.childNodes) : node.childNodes != null) return false;\n        return !(attributes != null ? !attributes.equals(node.attributes) : node.attributes != null);\n    }\n\n    \n    @Override\n    public int hashCode() {\n        int result = childNodes != null ? childNodes.hashCode() : 0;\n        result = 31 * result + (attributes != null ? attributes.hashCode() : 0);\n        return result;\n    }\n\n    \n    @Override\n    public Node clone() {\n        Node thisClone = doClone(null); \n\n        \n        LinkedList<Node> nodesToProcess = new LinkedList<Node>();\n        nodesToProcess.add(thisClone);\n\n        while (!nodesToProcess.isEmpty()) {\n            Node currParent = nodesToProcess.remove();\n\n            for (int i = 0; i < currParent.childNodes.size(); i++) {\n                Node childClone = currParent.childNodes.get(i).doClone(currParent);\n                currParent.childNodes.set(i, childClone);\n                nodesToProcess.add(childClone);\n            }\n        }\n\n        return thisClone;\n    }\n\n    \n    protected Node doClone(Node parent) {\n        Node clone;\n\n        try {\n            clone = (Node) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n\n        clone.parentNode = parent; \n        clone.siblingIndex = parent == null ? 0 : siblingIndex;\n        clone.attributes = attributes != null ? attributes.clone() : null;\n        clone.baseUri = baseUri;\n        clone.childNodes = new ArrayList<Node>(childNodes.size());\n\n        for (Node child: childNodes)\n            clone.childNodes.add(child);\n\n        return clone;\n    }\n\n    private static class OuterHtmlVisitor implements NodeVisitor { private StringBuilder accum; private Document.OutputSettings out; OuterHtmlVisitor(StringBuilder accum, Document.OutputSettings out) {\n            this.accum = accum;\n            this.out = out;\n        }\n\n        public void head(Node node, int depth) {\n            node.outerHtmlHead(accum, depth, out);\n        }\n\n        public void tail(Node node, int depth) {\n            if (!node.nodeName().equals(\"#text\")) \n                node.outerHtmlTail(accum, depth, out);\n        }\n    }\n}\n",
      "buggy_signatures": [
        "protected Node(String baseUri)",
        "protected Node()",
        "public abstract String nodeName(); public String attr(String attributeKey)",
        "public Attributes attributes()",
        "public Node attr(String attributeKey, String attributeValue)",
        "public boolean hasAttr(String attributeKey)",
        "public Node removeAttr(String attributeKey)",
        "public String baseUri()",
        "public void setBaseUri(final String baseUri)",
        "public void head(Node node, int depth)",
        "public void tail(Node node, int depth)",
        "public String absUrl(String attributeKey)",
        "public Node childNode(int index)",
        "public List<Node> childNodes()",
        "public List<Node> childNodesCopy()",
        "public final int childNodeSize()",
        "protected Node[] childNodesAsArray()",
        "public Node parent()",
        "public final Node parentNode()",
        "public Document ownerDocument()",
        "public void remove()",
        "public Node before(String html)",
        "public Node before(Node node)",
        "public Node after(String html)",
        "public Node after(Node node)",
        "private void addSiblingHtml(int index, String html)",
        "public Node wrap(String html)",
        "public Node unwrap()",
        "private Element getDeepChild(Element el)",
        "public void replaceWith(Node in)",
        "protected void setParentNode(Node parentNode)",
        "protected void replaceChild(Node out, Node in)",
        "protected void removeChild(Node out)",
        "protected void addChildren(Node... children)",
        "protected void addChildren(int index, Node... children)",
        "protected void ensureChildNodes()",
        "protected void reparentChild(Node child)",
        "private void reindexChildren(int start)",
        "public List<Node> siblingNodes()",
        "public Node nextSibling()",
        "public Node previousSibling()",
        "public int siblingIndex()",
        "protected void setSiblingIndex(int siblingIndex)",
        "public Node traverse(NodeVisitor nodeVisitor)",
        "public String outerHtml()",
        "protected void outerHtml(StringBuilder accum)",
        "abstract void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out); abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out); @Override public String toString()",
        "protected void indent(StringBuilder accum, int depth, Document.OutputSettings out)",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "public Node clone()",
        "protected Node doClone(Node parent)",
        "private static class OuterHtmlVisitor implements NodeVisitor { private StringBuilder accum; private Document.OutputSettings out; OuterHtmlVisitor(StringBuilder accum, Document.OutputSettings out)",
        "public void head(Node node, int depth)",
        "public void tail(Node node, int depth)"
      ],
      "fixed_signatures": [
        "protected Node(String baseUri)",
        "protected Node()",
        "public abstract String nodeName(); public String attr(String attributeKey)",
        "public Attributes attributes()",
        "public Node attr(String attributeKey, String attributeValue)",
        "public boolean hasAttr(String attributeKey)",
        "public Node removeAttr(String attributeKey)",
        "public String baseUri()",
        "public void setBaseUri(final String baseUri)",
        "public void head(Node node, int depth)",
        "public void tail(Node node, int depth)",
        "public String absUrl(String attributeKey)",
        "public Node childNode(int index)",
        "public List<Node> childNodes()",
        "public List<Node> childNodesCopy()",
        "public final int childNodeSize()",
        "protected Node[] childNodesAsArray()",
        "public Node parent()",
        "public final Node parentNode()",
        "public Document ownerDocument()",
        "public void remove()",
        "public Node before(String html)",
        "public Node before(Node node)",
        "public Node after(String html)",
        "public Node after(Node node)",
        "private void addSiblingHtml(int index, String html)",
        "public Node wrap(String html)",
        "public Node unwrap()",
        "private Element getDeepChild(Element el)",
        "public void replaceWith(Node in)",
        "protected void setParentNode(Node parentNode)",
        "protected void replaceChild(Node out, Node in)",
        "protected void removeChild(Node out)",
        "protected void addChildren(Node... children)",
        "protected void addChildren(int index, Node... children)",
        "protected void ensureChildNodes()",
        "protected void reparentChild(Node child)",
        "private void reindexChildren(int start)",
        "public List<Node> siblingNodes()",
        "public Node nextSibling()",
        "public Node previousSibling()",
        "public int siblingIndex()",
        "protected void setSiblingIndex(int siblingIndex)",
        "public Node traverse(NodeVisitor nodeVisitor)",
        "public String outerHtml()",
        "protected void outerHtml(StringBuilder accum)",
        "abstract void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out); abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out); @Override public String toString()",
        "protected void indent(StringBuilder accum, int depth, Document.OutputSettings out)",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "public Node clone()",
        "protected Node doClone(Node parent)",
        "private static class OuterHtmlVisitor implements NodeVisitor { private StringBuilder accum; private Document.OutputSettings out; OuterHtmlVisitor(StringBuilder accum, Document.OutputSettings out)",
        "public void head(Node node, int depth)",
        "public void tail(Node node, int depth)"
      ],
      "methods": [
        {
          "buggy_method": "  protected void addChildren(int index, Node... children) {\n  Validate.noNullElements(children);\n  ensureChildNodes();\n  for (int i = children.length - 1; i >= 0; i--) {\n  Node in = children[i];\n  reparentChild(in);\n  childNodes.add(index, in);\n  }\n  reindexChildren(index);\n  }",
          "fixed_method": "  protected void addChildren(int index, Node... children) {\n  Validate.noNullElements(children);\n  ensureChildNodes();\n  for (int i = children.length - 1; i >= 0; i--) {\n  Node in = children[i];\n  reparentChild(in);\n  childNodes.add(index, in);\n  reindexChildren(index);\n  }\n  }",
          "diff": [
            "@@ -442,8 +442,8 @@",
            "             Node in = children[i];\n",
            "             reparentChild(in);\n",
            "             childNodes.add(index, in);\n",
            "-        }\n",
            "-        reindexChildren(index);\n",
            "+            reindexChildren(index);\n",
            "+        }\n",
            "     }\n",
            " \n",
            "     protected void ensureChildNodes() {\n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
