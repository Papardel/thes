{
  "bug_id": "100",
  "failed_tests": {
    "org.apache.commons.math.estimation.GaussNewtonEstimatorTest": [
      {
        "methodName": "testBoundParameters",
        "error": "java.lang.ArrayIndexOutOfBoundsException",
        "message": "Index 6 out of bounds for length 6",
        "fail_line": "      double[][] covariances = estimator.getCovariances(problem);",
        "test_source": "  public void testBoundParameters() throws EstimationException {\n  EstimatedParameter[] p = {\n  new EstimatedParameter(\"unbound0\", 2, false),\n  new EstimatedParameter(\"unbound1\", 2, false),\n  new EstimatedParameter(\"bound\",  2, true)\n  };\n  LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n  new LinearMeasurement(new double[] { 1.0, 1.0, 1.0 },\n  new EstimatedParameter[] { p[0], p[1], p[2] },\n  3.0),\n  new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 },\n  new EstimatedParameter[] { p[0], p[1], p[2] },\n  1.0),\n  new LinearMeasurement(new double[] { 1.0, 3.0, 2.0 },\n  new EstimatedParameter[] { p[0], p[1], p[2] },\n  7.0)\n  });\n\n  GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);\n  estimator.estimate(problem);\n  assertTrue(estimator.getRMS(problem) < 1.0e-10);\n  double[][] covariances = estimator.getCovariances(problem);\n  int i0 = 0, i1 = 1;\n  if (problem.getUnboundParameters()[0].getName().endsWith(\"1\")) {\n  i0 = 1;\n  i1 = 0;\n  }\n  assertEquals(11.0 / 24, covariances[i0][i0], 1.0e-10);\n  assertEquals(-3.0 / 24, covariances[i0][i1], 1.0e-10);\n  assertEquals(-3.0 / 24, covariances[i1][i0], 1.0e-10);\n  assertEquals( 3.0 / 24, covariances[i1][i1], 1.0e-10);\n\n  double[] errors = estimator.guessParametersErrors(problem);\n  assertEquals(0, errors[i0], 1.0e-10);\n  assertEquals(0, errors[i1], 1.0e-10);\n\n  }",
        "stack": [
          "AbstractEstimator.getCovariances line 173, GaussNewtonEstimatorTest.testBoundParameters line 472"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/estimation/AbstractEstimator.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.estimation;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.math.linear.InvalidMatrixException;\nimport org.apache.commons.math.linear.RealMatrixImpl;\n\n\npublic abstract class AbstractEstimator implements Estimator { protected AbstractEstimator() {\n    }\n\n    \n    public final void setMaxCostEval(int maxCostEval) {\n        this.maxCostEval = maxCostEval;\n    }\n\n    \n    public final int getCostEvaluations() {\n        return costEvaluations;\n    }\n\n    \n    public final int getJacobianEvaluations() {\n        return jacobianEvaluations;\n    }\n\n    \n    protected void updateJacobian() {\n        incrementJacobianEvaluationsCounter();\n        Arrays.fill(jacobian, 0);\n        for (int i = 0, index = 0; i < rows; i++) {\n            WeightedMeasurement wm = measurements[i];\n            double factor = -Math.sqrt(wm.getWeight());\n            for (int j = 0; j < cols; ++j) {\n                jacobian[index++] = factor * wm.getPartial(parameters[j]);\n            }\n        }\n    }\n\n    \n    protected final void incrementJacobianEvaluationsCounter() {\n      ++jacobianEvaluations;\n    }\n\n    \n    protected void updateResidualsAndCost() throws EstimationException {\n\n        if (++costEvaluations > maxCostEval) {\n            throw new EstimationException(\"maximal number of evaluations exceeded ({0})\",\n                                          new Object[] { new Integer(maxCostEval) });\n        }\n\n        cost = 0;\n        for (int i = 0, index = 0; i < rows; i++, index += cols) {\n            WeightedMeasurement wm = measurements[i];\n            double residual = wm.getResidual();\n            residuals[i] = Math.sqrt(wm.getWeight()) * residual;\n            cost += wm.getWeight() * residual * residual;\n        }\n        cost = Math.sqrt(cost);\n\n    }\n\n    \n    public double getRMS(EstimationProblem problem) {\n        WeightedMeasurement[] wm = problem.getMeasurements();\n        double criterion = 0;\n        for (int i = 0; i < wm.length; ++i) {\n            double residual = wm[i].getResidual();\n            criterion += wm[i].getWeight() * residual * residual;\n        }\n        return Math.sqrt(criterion / wm.length);\n    }\n\n    \n    public double getChiSquare(EstimationProblem problem) {\n        WeightedMeasurement[] wm = problem.getMeasurements();\n        double chiSquare = 0;\n        for (int i = 0; i < wm.length; ++i) {\n            double residual = wm[i].getResidual();\n            chiSquare += residual * residual / wm[i].getWeight();\n        }\n        return chiSquare;\n    }\n\n    \n    public double[][] getCovariances(EstimationProblem problem) throws EstimationException {\n \n        \n        updateJacobian();\n\n        \n        final int rows = problem.getMeasurements().length;\n        final int cols = problem.getAllParameters().length;\n        final int max  = cols * rows;\n        double[][] jTj = new double[cols][cols];\n        for (int i = 0; i < cols; ++i) {\n            for (int j = i; j < cols; ++j) {\n                double sum = 0;\n                for (int k = 0; k < max; k += cols) {\n                    sum += jacobian[k + i] * jacobian[k + j];\n                }\n                jTj[i][j] = sum;\n                jTj[j][i] = sum;\n            }\n        }\n\n        try {\n            \n            return new RealMatrixImpl(jTj).inverse().getData();\n        } catch (InvalidMatrixException ime) {\n            throw new EstimationException(\"unable to compute covariances: singular problem\",\n                                          new Object[0]);\n        }\n\n    }\n\n    \n    public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException {\n        int m = problem.getMeasurements().length;\n        int p = problem.getAllParameters().length;\n        if (m <= p) {\n            throw new EstimationException(\"no degrees of freedom ({0} measurements, {1} parameters)\",\n                                          new Object[] { new Integer(m), new Integer(p)});\n        }\n        double[] errors = new double[problem.getAllParameters().length];\n        final double c = Math.sqrt(getChiSquare(problem) / (m - p));\n        double[][] covar = getCovariances(problem);\n        for (int i = 0; i < errors.length; ++i) {\n            errors[i] = Math.sqrt(covar[i][i]) * c;\n        }\n        return errors;\n    }\n\n    \n    protected void initializeEstimate(EstimationProblem problem) {\n\n        \n        costEvaluations     = 0;\n        jacobianEvaluations = 0;\n\n        \n        measurements = problem.getMeasurements();\n        parameters   = problem.getUnboundParameters();\n\n        \n        rows      = measurements.length;\n        cols      = parameters.length;\n        jacobian  = new double[rows * cols];\n        residuals = new double[rows];\n\n        cost = Double.POSITIVE_INFINITY;\n\n    }\n\n    \n    public abstract void estimate(EstimationProblem problem)\n    throws EstimationException;\n\n    \n    protected WeightedMeasurement[] measurements;\n\n    \n    protected EstimatedParameter[] parameters;\n\n    \n    protected double[] jacobian;\n\n    \n    protected int cols;\n\n    \n    protected int rows;\n\n    \n    protected double[] residuals;\n\n    \n    protected double cost;\n\n    \n    private int maxCostEval;\n\n    \n    private int costEvaluations;\n\n    \n    private int jacobianEvaluations;\n\n}",
      "fixed_full_code": "\n\npackage org.apache.commons.math.estimation;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.math.linear.InvalidMatrixException;\nimport org.apache.commons.math.linear.RealMatrixImpl;\n\n\npublic abstract class AbstractEstimator implements Estimator { protected AbstractEstimator() {\n    }\n\n    \n    public final void setMaxCostEval(int maxCostEval) {\n        this.maxCostEval = maxCostEval;\n    }\n\n    \n    public final int getCostEvaluations() {\n        return costEvaluations;\n    }\n\n    \n    public final int getJacobianEvaluations() {\n        return jacobianEvaluations;\n    }\n\n    \n    protected void updateJacobian() {\n        incrementJacobianEvaluationsCounter();\n        Arrays.fill(jacobian, 0);\n        for (int i = 0, index = 0; i < rows; i++) {\n            WeightedMeasurement wm = measurements[i];\n            double factor = -Math.sqrt(wm.getWeight());\n            for (int j = 0; j < cols; ++j) {\n                jacobian[index++] = factor * wm.getPartial(parameters[j]);\n            }\n        }\n    }\n\n    \n    protected final void incrementJacobianEvaluationsCounter() {\n      ++jacobianEvaluations;\n    }\n\n    \n    protected void updateResidualsAndCost() throws EstimationException {\n\n        if (++costEvaluations > maxCostEval) {\n            throw new EstimationException(\"maximal number of evaluations exceeded ({0})\",\n                                          new Object[] { new Integer(maxCostEval) });\n        }\n\n        cost = 0;\n        for (int i = 0, index = 0; i < rows; i++, index += cols) {\n            WeightedMeasurement wm = measurements[i];\n            double residual = wm.getResidual();\n            residuals[i] = Math.sqrt(wm.getWeight()) * residual;\n            cost += wm.getWeight() * residual * residual;\n        }\n        cost = Math.sqrt(cost);\n\n    }\n\n    \n    public double getRMS(EstimationProblem problem) {\n        WeightedMeasurement[] wm = problem.getMeasurements();\n        double criterion = 0;\n        for (int i = 0; i < wm.length; ++i) {\n            double residual = wm[i].getResidual();\n            criterion += wm[i].getWeight() * residual * residual;\n        }\n        return Math.sqrt(criterion / wm.length);\n    }\n\n    \n    public double getChiSquare(EstimationProblem problem) {\n        WeightedMeasurement[] wm = problem.getMeasurements();\n        double chiSquare = 0;\n        for (int i = 0; i < wm.length; ++i) {\n            double residual = wm[i].getResidual();\n            chiSquare += residual * residual / wm[i].getWeight();\n        }\n        return chiSquare;\n    }\n\n    \n    public double[][] getCovariances(EstimationProblem problem) throws EstimationException {\n \n        \n        updateJacobian();\n\n        \n        final int rows = problem.getMeasurements().length;\n        final int cols = problem.getUnboundParameters().length;\n        final int max  = cols * rows;\n        double[][] jTj = new double[cols][cols];\n        for (int i = 0; i < cols; ++i) {\n            for (int j = i; j < cols; ++j) {\n                double sum = 0;\n                for (int k = 0; k < max; k += cols) {\n                    sum += jacobian[k + i] * jacobian[k + j];\n                }\n                jTj[i][j] = sum;\n                jTj[j][i] = sum;\n            }\n        }\n\n        try {\n            \n            return new RealMatrixImpl(jTj).inverse().getData();\n        } catch (InvalidMatrixException ime) {\n            throw new EstimationException(\"unable to compute covariances: singular problem\",\n                                          new Object[0]);\n        }\n\n    }\n\n    \n    public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException {\n        int m = problem.getMeasurements().length;\n        int p = problem.getUnboundParameters().length;\n        if (m <= p) {\n            throw new EstimationException(\"no degrees of freedom ({0} measurements, {1} parameters)\",\n                                          new Object[] { new Integer(m), new Integer(p)});\n        }\n        double[] errors = new double[problem.getUnboundParameters().length];\n        final double c = Math.sqrt(getChiSquare(problem) / (m - p));\n        double[][] covar = getCovariances(problem);\n        for (int i = 0; i < errors.length; ++i) {\n            errors[i] = Math.sqrt(covar[i][i]) * c;\n        }\n        return errors;\n    }\n\n    \n    protected void initializeEstimate(EstimationProblem problem) {\n\n        \n        costEvaluations     = 0;\n        jacobianEvaluations = 0;\n\n        \n        measurements = problem.getMeasurements();\n        parameters   = problem.getUnboundParameters();\n\n        \n        rows      = measurements.length;\n        cols      = parameters.length;\n        jacobian  = new double[rows * cols];\n        residuals = new double[rows];\n\n        cost = Double.POSITIVE_INFINITY;\n\n    }\n\n    \n    public abstract void estimate(EstimationProblem problem)\n    throws EstimationException;\n\n    \n    protected WeightedMeasurement[] measurements;\n\n    \n    protected EstimatedParameter[] parameters;\n\n    \n    protected double[] jacobian;\n\n    \n    protected int cols;\n\n    \n    protected int rows;\n\n    \n    protected double[] residuals;\n\n    \n    protected double cost;\n\n    \n    private int maxCostEval;\n\n    \n    private int costEvaluations;\n\n    \n    private int jacobianEvaluations;\n\n}",
      "buggy_signatures": [
        "public abstract class AbstractEstimator implements Estimator { protected AbstractEstimator()",
        "public final void setMaxCostEval(int maxCostEval)",
        "public final int getCostEvaluations()",
        "public final int getJacobianEvaluations()",
        "protected void updateJacobian()",
        "protected final void incrementJacobianEvaluationsCounter()",
        "protected void updateResidualsAndCost() throws EstimationException",
        "public double getRMS(EstimationProblem problem)",
        "public double getChiSquare(EstimationProblem problem)",
        "public double[][] getCovariances(EstimationProblem problem) throws EstimationException",
        "public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException",
        "protected void initializeEstimate(EstimationProblem problem)"
      ],
      "fixed_signatures": [
        "public abstract class AbstractEstimator implements Estimator { protected AbstractEstimator()",
        "public final void setMaxCostEval(int maxCostEval)",
        "public final int getCostEvaluations()",
        "public final int getJacobianEvaluations()",
        "protected void updateJacobian()",
        "protected final void incrementJacobianEvaluationsCounter()",
        "protected void updateResidualsAndCost() throws EstimationException",
        "public double getRMS(EstimationProblem problem)",
        "public double getChiSquare(EstimationProblem problem)",
        "public double[][] getCovariances(EstimationProblem problem) throws EstimationException",
        "public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException",
        "protected void initializeEstimate(EstimationProblem problem)"
      ],
      "methods": [
        {
          "buggy_method": "  public double[][] getCovariances(EstimationProblem problem) throws EstimationException {\n \n  \n  updateJacobian();\n\n  \n  final int rows = problem.getMeasurements().length;\n  final int cols = problem.getAllParameters().length;\n  final int max  = cols * rows;\n  double[][] jTj = new double[cols][cols];\n  for (int i = 0; i < cols; ++i) {\n  for (int j = i; j < cols; ++j) {\n  double sum = 0;\n  for (int k = 0; k < max; k += cols) {\n  sum += jacobian[k + i] * jacobian[k + j];\n  }\n  jTj[i][j] = sum;\n  jTj[j][i] = sum;\n  }\n  }\n\n  try {\n  \n  return new RealMatrixImpl(jTj).inverse().getData();\n  } catch (InvalidMatrixException ime) {\n  throw new EstimationException(\"unable to compute covariances: singular problem\",\n  new Object[0]);\n  }\n\n  }",
          "fixed_method": "  public double[][] getCovariances(EstimationProblem problem) throws EstimationException {\n \n  \n  updateJacobian();\n\n  \n  final int rows = problem.getMeasurements().length;\n  final int cols = problem.getUnboundParameters().length;\n  final int max  = cols * rows;\n  double[][] jTj = new double[cols][cols];\n  for (int i = 0; i < cols; ++i) {\n  for (int j = i; j < cols; ++j) {\n  double sum = 0;\n  for (int k = 0; k < max; k += cols) {\n  sum += jacobian[k + i] * jacobian[k + j];\n  }\n  jTj[i][j] = sum;\n  jTj[j][i] = sum;\n  }\n  }\n\n  try {\n  \n  return new RealMatrixImpl(jTj).inverse().getData();\n  } catch (InvalidMatrixException ime) {\n  throw new EstimationException(\"unable to compute covariances: singular problem\",\n  new Object[0]);\n  }\n\n  }",
          "diff": [
            "@@ -163,7 +163,7 @@",
            " \n",
            "         // compute transpose(J).J, avoiding building big intermediate matrices\n",
            "         final int rows = problem.getMeasurements().length;\n",
            "-        final int cols = problem.getAllParameters().length;\n",
            "+        final int cols = problem.getUnboundParameters().length;\n",
            "         final int max  = cols * rows;\n",
            "         double[][] jTj = new double[cols][cols];\n",
            "         for (int i = 0; i < cols; ++i) {\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException {\n  int m = problem.getMeasurements().length;\n  int p = problem.getAllParameters().length;\n  if (m <= p) {\n  throw new EstimationException(\"no degrees of freedom ({0} measurements, {1} parameters)\",\n  new Object[] { new Integer(m), new Integer(p)});\n  }\n  double[] errors = new double[problem.getAllParameters().length];\n  final double c = Math.sqrt(getChiSquare(problem) / (m - p));\n  double[][] covar = getCovariances(problem);\n  for (int i = 0; i < errors.length; ++i) {\n  errors[i] = Math.sqrt(covar[i][i]) * c;\n  }\n  return errors;\n  }",
          "fixed_method": "  public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException {\n  int m = problem.getMeasurements().length;\n  int p = problem.getUnboundParameters().length;\n  if (m <= p) {\n  throw new EstimationException(\"no degrees of freedom ({0} measurements, {1} parameters)\",\n  new Object[] { new Integer(m), new Integer(p)});\n  }\n  double[] errors = new double[problem.getUnboundParameters().length];\n  final double c = Math.sqrt(getChiSquare(problem) / (m - p));\n  double[][] covar = getCovariances(problem);\n  for (int i = 0; i < errors.length; ++i) {\n  errors[i] = Math.sqrt(covar[i][i]) * c;\n  }\n  return errors;\n  }",
          "diff": [
            "@@ -199,12 +199,12 @@",
            "     public double[] guessParametersErrors(EstimationProblem problem)\n",
            "       throws EstimationException {\n",
            "         int m = problem.getMeasurements().length;\n",
            "-        int p = problem.getAllParameters().length;\n",
            "+        int p = problem.getUnboundParameters().length;\n",
            "         if (m <= p) {\n",
            "             throw new EstimationException(\"no degrees of freedom ({0} measurements, {1} parameters)\",\n",
            "                                           new Object[] { new Integer(m), new Integer(p)});\n",
            "         }\n",
            "-        double[] errors = new double[problem.getAllParameters().length];\n",
            "+        double[] errors = new double[problem.getUnboundParameters().length];\n",
            "         final double c = Math.sqrt(getChiSquare(problem) / (m - p));\n",
            "         double[][] covar = getCovariances(problem);\n",
            "         for (int i = 0; i < errors.length; ++i) {\n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
