{
  "bug_id": "91",
  "failed_tests": {
    "org.apache.commons.math.fraction.FractionTest": [
      {
        "methodName": "testCompareTo",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<-1> but was:<0>",
        "fail_line": "        assertEquals(-1, pi1.compareTo(pi2));",
        "test_source": "  public void testCompareTo() {\n  Fraction first = new Fraction(1, 2);\n  Fraction second = new Fraction(1, 3);\n  Fraction third = new Fraction(1, 2);\n  \n  assertEquals(0, first.compareTo(first));\n  assertEquals(0, first.compareTo(third));\n  assertEquals(1, first.compareTo(second));\n  assertEquals(-1, second.compareTo(first));\n\n  // these two values are different approximations of PI\n  // the first  one is approximately PI - 3.07e-18\n  // the second one is approximately PI + 1.936e-17\n  Fraction pi1 = new Fraction(1068966896, 340262731);\n  Fraction pi2 = new Fraction( 411557987, 131002976);\n  assertEquals(-1, pi1.compareTo(pi2));\n  assertEquals( 1, pi2.compareTo(pi1));\n  assertEquals(0.0, pi1.doubleValue() - pi2.doubleValue(), 1.0e-20);\n  }",
        "stack": [
          "FractionTest.testCompareTo line 178"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/fraction/Fraction.java",
      "buggy_full_code": "\npackage org.apache.commons.math.fraction;\n\nimport java.math.BigInteger;\n\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.util.MathUtils;\n\n\npublic class Fraction extends Number implements Comparable<Fraction> { public static final Fraction TWO = new Fraction(2, 1); public static final Fraction ONE = new Fraction(1, 1); public static final Fraction ZERO = new Fraction(0, 1); public static final Fraction MINUS_ONE = new Fraction(-1, 1); private static final long serialVersionUID = 3071409609509774764L; private final int denominator; private final int numerator; public Fraction(double value) throws FractionConversionException {\n        this(value, 1.0e-5, 100);\n    }\n\n    \n    public Fraction(double value, double epsilon, int maxIterations) throws FractionConversionException {\n        this(value, epsilon, Integer.MAX_VALUE, maxIterations);\n    }\n\n    \n    public Fraction(double value, int maxDenominator) throws FractionConversionException {\n       this(value, 0, maxDenominator, 100);\n    }\n\n    \n    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long)Math.floor(r0);\n        if (a0 > overflow) {\n            throw new FractionConversionException(value, a0, 1l);\n        }\n\n        \n        \n        if (Math.abs(a0 - value) < epsilon) {\n            this.numerator = (int) a0;\n            this.denominator = 1;\n            return;\n        }\n\n        long p0 = 1;\n        long q0 = 0;\n        long p1 = a0;\n        long q1 = 1;\n\n        long p2 = 0;\n        long q2 = 1;\n\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            double r1 = 1.0 / (r0 - a0);\n            long a1 = (long)Math.floor(r1);\n            p2 = (a1 * p1) + p0;\n            q2 = (a1 * q1) + q0;\n            if ((p2 > overflow) || (q2 > overflow)) {\n                throw new FractionConversionException(value, p2, q2);\n            }\n            \n            double convergent = (double)p2 / (double)q2;\n            if (n < maxIterations && Math.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n                p0 = p1;\n                p1 = p2;\n                q0 = q1;\n                q1 = q2;\n                a0 = a1;\n                r0 = r1;\n            } else {\n                stop = true;\n            }\n        } while (!stop);\n\n        if (n >= maxIterations) {\n            throw new FractionConversionException(value, maxIterations);\n        }\n        \n        if (q2 < maxDenominator) {\n            this.numerator = (int) p2;\n            this.denominator = (int) q2;\n        } else {\n            this.numerator = (int) p1;\n            this.denominator = (int) q1;\n        }\n\n    }\n    \n    \n    public Fraction(int num, int den) {\n        super();\n        if (den == 0) {\n            throw MathRuntimeException.createArithmeticException(\"zero denominator in fraction {0}/{1}\",\n                                                                 num, den);\n        }\n        if (den < 0) {\n            if (num == Integer.MIN_VALUE || den == Integer.MIN_VALUE) {\n                throw MathRuntimeException.createArithmeticException(\"overflow in fraction {0}/{1}, cannot negate\",\n                                                                     num, den);\n            }\n            num = -num;\n            den = -den;\n        }\n        \n        int d = MathUtils.gcd(num, den);\n        if (d > 1) {\n            num /= d;\n            den /= d;\n        }\n        \n        \n        if (den < 0) {\n            num *= -1;\n            den *= -1;\n        }\n        this.numerator = num;\n        this.denominator = den;\n    }\n    \n    \n    public Fraction abs() {\n        Fraction ret;\n        if (numerator >= 0) {\n            ret = this;\n        } else {\n            ret = negate();\n        }\n        return ret;        \n    }\n    \n    \n    public int compareTo(Fraction object) {\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n        return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n    }\n    \n    \n    public double doubleValue() {\n        return (double)numerator / (double)denominator;\n    }\n    \n    \n    public boolean equals(Object other) {\n        boolean ret;\n        \n        if (this == other) { \n            ret = true;\n        } else if (other == null) {\n            ret = false;\n        } else {\n            try {\n                \n                \n                Fraction rhs = (Fraction)other;\n                ret = (numerator == rhs.numerator) &&\n                    (denominator == rhs.denominator);\n            } catch (ClassCastException ex) {\n                \n                ret = false;\n            }\n        }\n        \n        return ret;\n    }\n    \n    \n    public float floatValue() {\n        return (float)doubleValue();\n    }\n    \n    \n    public int getDenominator() {\n        return denominator;\n    }\n    \n    \n    public int getNumerator() {\n        return numerator;\n    }\n    \n    \n    public int hashCode() {\n        return 37 * (37 * 17 + getNumerator()) + getDenominator();\n    }\n    \n    \n    public int intValue() {\n        return (int)doubleValue();\n    }\n    \n    \n    public long longValue() {\n        return (long)doubleValue();\n    }\n    \n    \n    public Fraction negate() {\n        if (numerator==Integer.MIN_VALUE) {\n            throw MathRuntimeException.createArithmeticException(\"overflow in fraction {0}/{1}, cannot negate\",\n                                                                 numerator, denominator);\n        }\n        return new Fraction(-numerator, denominator);\n    }\n\n    \n    public Fraction reciprocal() {\n        return new Fraction(denominator, numerator);\n    }\n    \n    \n    public Fraction add(Fraction fraction) {\n        return addSub(fraction, true );\n    }\n\n    \n    public Fraction subtract(Fraction fraction) {\n        return addSub(fraction, false );\n    }\n\n    \n    private Fraction addSub(Fraction fraction, boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        \n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        \n        \n        int d1 = MathUtils.gcd(denominator, fraction.denominator);\n        if (d1==1) {\n            \n            int uvp = MathUtils.mulAndCheck(numerator, fraction.denominator);\n            int upv = MathUtils.mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? MathUtils.addAndCheck(uvp, upv) : \n                 MathUtils.subAndCheck(uvp, upv),\n                 MathUtils.mulAndCheck(denominator, fraction.denominator));\n        }\n        \n        \n        \n        BigInteger uvp = BigInteger.valueOf(numerator)\n        .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        BigInteger upv = BigInteger.valueOf(fraction.numerator)\n        .multiply(BigInteger.valueOf(denominator/d1));\n        BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);\n        \n        \n        int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        int d2 = (tmodd1==0)?d1:MathUtils.gcd(tmodd1, d1);\n\n        \n        BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw MathRuntimeException.createArithmeticException(\"overflow, numerator too large after multiply: {0}\",\n                                                                 w);\n        }\n        return new Fraction (w.intValue(), \n                MathUtils.mulAndCheck(denominator/d1, \n                        fraction.denominator/d2));\n    }\n\n    \n    public Fraction multiply(Fraction fraction) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        if (numerator == 0 || fraction.numerator == 0) {\n            return ZERO;\n        }\n        \n        \n        int d1 = MathUtils.gcd(numerator, fraction.denominator);\n        int d2 = MathUtils.gcd(fraction.numerator, denominator);\n        return getReducedFraction\n        (MathUtils.mulAndCheck(numerator/d1, fraction.numerator/d2),\n                MathUtils.mulAndCheck(denominator/d2, fraction.denominator/d1));\n    }\n\n    \n    public Fraction divide(Fraction fraction) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        if (fraction.numerator == 0) {\n            throw MathRuntimeException.createArithmeticException(\n                    \"the fraction to divide by must not be zero: {0}/{1}\",\n                    fraction.numerator, fraction.denominator);\n        }\n        return multiply(fraction.reciprocal());\n    }\n    \n    \n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw MathRuntimeException.createArithmeticException(\n                    \"zero denominator in fraction {0}/{1}\",\n                    numerator, denominator);\n        }\n        if (numerator==0) {\n            return ZERO; \n        }\n        \n        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n            numerator/=2; denominator/=2;\n        }\n        if (denominator < 0) {\n            if (numerator==Integer.MIN_VALUE ||\n                    denominator==Integer.MIN_VALUE) {\n                throw MathRuntimeException.createArithmeticException(\n                        \"overflow in fraction {0}/{1}, cannot negate\",\n                        numerator, denominator);\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        \n        int gcd = MathUtils.gcd(numerator, denominator);\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.math.fraction;\n\nimport java.math.BigInteger;\n\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.util.MathUtils;\n\n\npublic class Fraction extends Number implements Comparable<Fraction> { public static final Fraction TWO = new Fraction(2, 1); public static final Fraction ONE = new Fraction(1, 1); public static final Fraction ZERO = new Fraction(0, 1); public static final Fraction MINUS_ONE = new Fraction(-1, 1); private static final long serialVersionUID = 3071409609509774764L; private final int denominator; private final int numerator; public Fraction(double value) throws FractionConversionException {\n        this(value, 1.0e-5, 100);\n    }\n\n    \n    public Fraction(double value, double epsilon, int maxIterations) throws FractionConversionException {\n        this(value, epsilon, Integer.MAX_VALUE, maxIterations);\n    }\n\n    \n    public Fraction(double value, int maxDenominator) throws FractionConversionException {\n       this(value, 0, maxDenominator, 100);\n    }\n\n    \n    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long)Math.floor(r0);\n        if (a0 > overflow) {\n            throw new FractionConversionException(value, a0, 1l);\n        }\n\n        \n        \n        if (Math.abs(a0 - value) < epsilon) {\n            this.numerator = (int) a0;\n            this.denominator = 1;\n            return;\n        }\n\n        long p0 = 1;\n        long q0 = 0;\n        long p1 = a0;\n        long q1 = 1;\n\n        long p2 = 0;\n        long q2 = 1;\n\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            double r1 = 1.0 / (r0 - a0);\n            long a1 = (long)Math.floor(r1);\n            p2 = (a1 * p1) + p0;\n            q2 = (a1 * q1) + q0;\n            if ((p2 > overflow) || (q2 > overflow)) {\n                throw new FractionConversionException(value, p2, q2);\n            }\n            \n            double convergent = (double)p2 / (double)q2;\n            if (n < maxIterations && Math.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n                p0 = p1;\n                p1 = p2;\n                q0 = q1;\n                q1 = q2;\n                a0 = a1;\n                r0 = r1;\n            } else {\n                stop = true;\n            }\n        } while (!stop);\n\n        if (n >= maxIterations) {\n            throw new FractionConversionException(value, maxIterations);\n        }\n        \n        if (q2 < maxDenominator) {\n            this.numerator = (int) p2;\n            this.denominator = (int) q2;\n        } else {\n            this.numerator = (int) p1;\n            this.denominator = (int) q1;\n        }\n\n    }\n    \n    \n    public Fraction(int num, int den) {\n        super();\n        if (den == 0) {\n            throw MathRuntimeException.createArithmeticException(\"zero denominator in fraction {0}/{1}\",\n                                                                 num, den);\n        }\n        if (den < 0) {\n            if (num == Integer.MIN_VALUE || den == Integer.MIN_VALUE) {\n                throw MathRuntimeException.createArithmeticException(\"overflow in fraction {0}/{1}, cannot negate\",\n                                                                     num, den);\n            }\n            num = -num;\n            den = -den;\n        }\n        \n        int d = MathUtils.gcd(num, den);\n        if (d > 1) {\n            num /= d;\n            den /= d;\n        }\n        \n        \n        if (den < 0) {\n            num *= -1;\n            den *= -1;\n        }\n        this.numerator = num;\n        this.denominator = den;\n    }\n    \n    \n    public Fraction abs() {\n        Fraction ret;\n        if (numerator >= 0) {\n            ret = this;\n        } else {\n            ret = negate();\n        }\n        return ret;        \n    }\n    \n    \n    public int compareTo(Fraction object) {\n        long nOd = ((long) numerator) * object.denominator;\n        long dOn = ((long) denominator) * object.numerator;\n        return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n    }\n    \n    \n    public double doubleValue() {\n        return (double)numerator / (double)denominator;\n    }\n    \n    \n    public boolean equals(Object other) {\n        boolean ret;\n        \n        if (this == other) { \n            ret = true;\n        } else if (other == null) {\n            ret = false;\n        } else {\n            try {\n                \n                \n                Fraction rhs = (Fraction)other;\n                ret = (numerator == rhs.numerator) &&\n                    (denominator == rhs.denominator);\n            } catch (ClassCastException ex) {\n                \n                ret = false;\n            }\n        }\n        \n        return ret;\n    }\n    \n    \n    public float floatValue() {\n        return (float)doubleValue();\n    }\n    \n    \n    public int getDenominator() {\n        return denominator;\n    }\n    \n    \n    public int getNumerator() {\n        return numerator;\n    }\n    \n    \n    public int hashCode() {\n        return 37 * (37 * 17 + getNumerator()) + getDenominator();\n    }\n    \n    \n    public int intValue() {\n        return (int)doubleValue();\n    }\n    \n    \n    public long longValue() {\n        return (long)doubleValue();\n    }\n    \n    \n    public Fraction negate() {\n        if (numerator==Integer.MIN_VALUE) {\n            throw MathRuntimeException.createArithmeticException(\"overflow in fraction {0}/{1}, cannot negate\",\n                                                                 numerator, denominator);\n        }\n        return new Fraction(-numerator, denominator);\n    }\n\n    \n    public Fraction reciprocal() {\n        return new Fraction(denominator, numerator);\n    }\n    \n    \n    public Fraction add(Fraction fraction) {\n        return addSub(fraction, true );\n    }\n\n    \n    public Fraction subtract(Fraction fraction) {\n        return addSub(fraction, false );\n    }\n\n    \n    private Fraction addSub(Fraction fraction, boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        \n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        \n        \n        int d1 = MathUtils.gcd(denominator, fraction.denominator);\n        if (d1==1) {\n            \n            int uvp = MathUtils.mulAndCheck(numerator, fraction.denominator);\n            int upv = MathUtils.mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? MathUtils.addAndCheck(uvp, upv) : \n                 MathUtils.subAndCheck(uvp, upv),\n                 MathUtils.mulAndCheck(denominator, fraction.denominator));\n        }\n        \n        \n        \n        BigInteger uvp = BigInteger.valueOf(numerator)\n        .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        BigInteger upv = BigInteger.valueOf(fraction.numerator)\n        .multiply(BigInteger.valueOf(denominator/d1));\n        BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);\n        \n        \n        int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        int d2 = (tmodd1==0)?d1:MathUtils.gcd(tmodd1, d1);\n\n        \n        BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw MathRuntimeException.createArithmeticException(\"overflow, numerator too large after multiply: {0}\",\n                                                                 w);\n        }\n        return new Fraction (w.intValue(), \n                MathUtils.mulAndCheck(denominator/d1, \n                        fraction.denominator/d2));\n    }\n\n    \n    public Fraction multiply(Fraction fraction) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        if (numerator == 0 || fraction.numerator == 0) {\n            return ZERO;\n        }\n        \n        \n        int d1 = MathUtils.gcd(numerator, fraction.denominator);\n        int d2 = MathUtils.gcd(fraction.numerator, denominator);\n        return getReducedFraction\n        (MathUtils.mulAndCheck(numerator/d1, fraction.numerator/d2),\n                MathUtils.mulAndCheck(denominator/d2, fraction.denominator/d1));\n    }\n\n    \n    public Fraction divide(Fraction fraction) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        if (fraction.numerator == 0) {\n            throw MathRuntimeException.createArithmeticException(\n                    \"the fraction to divide by must not be zero: {0}/{1}\",\n                    fraction.numerator, fraction.denominator);\n        }\n        return multiply(fraction.reciprocal());\n    }\n    \n    \n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw MathRuntimeException.createArithmeticException(\n                    \"zero denominator in fraction {0}/{1}\",\n                    numerator, denominator);\n        }\n        if (numerator==0) {\n            return ZERO; \n        }\n        \n        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n            numerator/=2; denominator/=2;\n        }\n        if (denominator < 0) {\n            if (numerator==Integer.MIN_VALUE ||\n                    denominator==Integer.MIN_VALUE) {\n                throw MathRuntimeException.createArithmeticException(\n                        \"overflow in fraction {0}/{1}, cannot negate\",\n                        numerator, denominator);\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        \n        int gcd = MathUtils.gcd(numerator, denominator);\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }\n}\n",
      "buggy_signatures": [
        "public Fraction(double value, double epsilon, int maxIterations) throws FractionConversionException",
        "public Fraction(double value, int maxDenominator) throws FractionConversionException",
        "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException",
        "public Fraction(int num, int den)",
        "public Fraction abs()",
        "public int compareTo(Fraction object)",
        "public double doubleValue()",
        "public boolean equals(Object other)",
        "public float floatValue()",
        "public int getDenominator()",
        "public int getNumerator()",
        "public int hashCode()",
        "public int intValue()",
        "public long longValue()",
        "public Fraction negate()",
        "public Fraction reciprocal()",
        "public Fraction add(Fraction fraction)",
        "public Fraction subtract(Fraction fraction)",
        "private Fraction addSub(Fraction fraction, boolean isAdd)",
        "public Fraction multiply(Fraction fraction)",
        "public Fraction divide(Fraction fraction)",
        "public static Fraction getReducedFraction(int numerator, int denominator)"
      ],
      "fixed_signatures": [
        "public Fraction(double value, double epsilon, int maxIterations) throws FractionConversionException",
        "public Fraction(double value, int maxDenominator) throws FractionConversionException",
        "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException",
        "public Fraction(int num, int den)",
        "public Fraction abs()",
        "public int compareTo(Fraction object)",
        "public double doubleValue()",
        "public boolean equals(Object other)",
        "public float floatValue()",
        "public int getDenominator()",
        "public int getNumerator()",
        "public int hashCode()",
        "public int intValue()",
        "public long longValue()",
        "public Fraction negate()",
        "public Fraction reciprocal()",
        "public Fraction add(Fraction fraction)",
        "public Fraction subtract(Fraction fraction)",
        "private Fraction addSub(Fraction fraction, boolean isAdd)",
        "public Fraction multiply(Fraction fraction)",
        "public Fraction divide(Fraction fraction)",
        "public static Fraction getReducedFraction(int numerator, int denominator)"
      ],
      "methods": [
        {
          "buggy_method": "  public int compareTo(Fraction object) {\n  double nOd = doubleValue();\n  double dOn = object.doubleValue();\n  return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n  }",
          "fixed_method": "  public int compareTo(Fraction object) {\n  long nOd = ((long) numerator) * object.denominator;\n  long dOn = ((long) denominator) * object.numerator;\n  return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n  }",
          "diff": [
            "@@ -256,8 +256,8 @@",
            "      *         than <tt>object</tt>, 0 if they are equal.\n",
            "      */\n",
            "     public int compareTo(Fraction object) {\n",
            "-        double nOd = doubleValue();\n",
            "-        double dOn = object.doubleValue();\n",
            "+        long nOd = ((long) numerator) * object.denominator;\n",
            "+        long dOn = ((long) denominator) * object.numerator;\n",
            "         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n",
            "     }\n",
            "     \n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
