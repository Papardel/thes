{
  "bug_id": "98",
  "failed_tests": {
    "org.apache.commons.math.linear.BigMatrixImplTest": [
      {
        "methodName": "testMath209",
        "error": "java.lang.ArrayIndexOutOfBoundsException",
        "message": "Index 2 out of bounds for length 2",
        "fail_line": "        BigDecimal[] b = a.operate(new BigDecimal[] { new BigDecimal(1), new BigDecimal(1) });",
        "test_source": "  public void testMath209() {\n  BigMatrix a = new BigMatrixImpl(new BigDecimal[][] {\n  { new BigDecimal(1), new BigDecimal(2) },\n  { new BigDecimal(3), new BigDecimal(4) },\n  { new BigDecimal(5), new BigDecimal(6) }\n  }, false);\n  BigDecimal[] b = a.operate(new BigDecimal[] { new BigDecimal(1), new BigDecimal(1) });\n  assertEquals(a.getRowDimension(), b.length);\n  assertEquals( 3.0, b[0].doubleValue(), 1.0e-12);\n  assertEquals( 7.0, b[1].doubleValue(), 1.0e-12);\n  assertEquals(11.0, b[2].doubleValue(), 1.0e-12);\n  }",
        "stack": [
          "BigMatrixImpl.operate line 997, BigMatrixImplTest.testMath209 line 446"
        ]
      }
    ],
    "org.apache.commons.math.linear.RealMatrixImplTest": [
      {
        "methodName": "testMath209",
        "error": "java.lang.ArrayIndexOutOfBoundsException",
        "message": "Index 2 out of bounds for length 2",
        "fail_line": "        double[] b = a.operate(new double[] { 1, 1 });",
        "test_source": "  public void testMath209() {\n  RealMatrix a = new RealMatrixImpl(new double[][] {\n  { 1, 2 }, { 3, 4 }, { 5, 6 }\n  }, false);\n  double[] b = a.operate(new double[] { 1, 1 });\n  assertEquals(a.getRowDimension(), b.length);\n  assertEquals( 3.0, b[0], 1.0e-12);\n  assertEquals( 7.0, b[1], 1.0e-12);\n  assertEquals(11.0, b[2], 1.0e-12);\n  }",
        "stack": [
          "RealMatrixImpl.operate line 786, RealMatrixImplTest.testMath209 line 351"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/linear/BigMatrixImpl.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.linear;\nimport java.io.Serializable;\nimport java.math.BigDecimal;\n\n\npublic class BigMatrixImpl implements BigMatrix, Serializable { private static final long serialVersionUID = -1011428905656140431L; protected BigDecimal data[][] = null; protected BigDecimal lu[][] = null; protected int[] permutation = null; protected int parity = 1; private int roundingMode = BigDecimal.ROUND_HALF_UP; private int scale = 64; private static final BigDecimal TOO_SMALL = new BigDecimal(10E-12); static final BigDecimal ZERO = new BigDecimal(0); static final BigDecimal ONE = new BigDecimal(1); public BigMatrixImpl() {\n    }\n    \n    \n    public BigMatrixImpl(int rowDimension, int columnDimension) {\n        if (rowDimension <=0 || columnDimension <=0) {\n            throw new IllegalArgumentException\n            (\"row and column dimensions must be positive\");\n        }\n        data = new BigDecimal[rowDimension][columnDimension];\n        lu = null;\n    }\n    \n    \n    public BigMatrixImpl(BigDecimal[][] d) {\n        this.copyIn(d);\n        lu = null;\n    }\n\n    \n    public BigMatrixImpl(BigDecimal[][] d, boolean copyArray) {\n        if (copyArray) {\n            copyIn(d);\n        } else {\n            if (d == null) {\n                throw new NullPointerException();\n            }   \n            final int nRows = d.length;\n            if (nRows == 0) {\n                throw new IllegalArgumentException(\"Matrix must have at least one row.\"); \n            }\n            final int nCols = d[0].length;\n            if (nCols == 0) {\n                throw new IllegalArgumentException(\"Matrix must have at least one column.\"); \n            }\n            for (int r = 1; r < nRows; r++) {\n                if (d[r].length != nCols) {\n                    throw new IllegalArgumentException(\"All input rows must have the same length.\");\n                }\n            }       \n            data = d;\n        }\n        lu = null;\n    }\n\n    \n    public BigMatrixImpl(double[][] d) {\n        final int nRows = d.length;\n        if (nRows == 0) {\n            throw new IllegalArgumentException(\n            \"Matrix must have at least one row.\"); \n        }\n        final int nCols = d[0].length;\n        if (nCols == 0) {\n            throw new IllegalArgumentException(\n            \"Matrix must have at least one column.\"); \n        }\n        for (int row = 1; row < nRows; row++) {\n            if (d[row].length != nCols) {\n                throw new IllegalArgumentException(\n                \"All input rows must have the same length.\");\n            }\n        }\n        this.copyIn(d);\n        lu = null;\n    }\n    \n    \n    public BigMatrixImpl(String[][] d) {\n        final int nRows = d.length;\n        if (nRows == 0) {\n            throw new IllegalArgumentException(\n            \"Matrix must have at least one row.\"); \n        }\n        final int nCols = d[0].length;\n        if (nCols == 0) {\n            throw new IllegalArgumentException(\n            \"Matrix must have at least one column.\"); \n        }\n        for (int row = 1; row < nRows; row++) {\n            if (d[row].length != nCols) {\n                throw new IllegalArgumentException(\n                \"All input rows must have the same length.\");\n            }\n        }\n        this.copyIn(d);\n        lu = null;\n    }\n    \n    \n    public BigMatrixImpl(BigDecimal[] v) {\n        final int nRows = v.length;\n        data = new BigDecimal[nRows][1];\n        for (int row = 0; row < nRows; row++) {\n            data[row][0] = v[row];\n        }\n    }\n    \n    \n    public BigMatrix copy() {\n        return new BigMatrixImpl(this.copyOut(), false);\n    }\n    \n    \n    public BigMatrix add(BigMatrix m) throws IllegalArgumentException {\n        try {\n            return add((BigMatrixImpl) m);\n        } catch (ClassCastException cce) {\n            final int rowCount    = getRowDimension();\n            final int columnCount = getColumnDimension();\n            if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n                throw new IllegalArgumentException(\"matrix dimension mismatch\");\n            }\n            final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n            for (int row = 0; row < rowCount; row++) {\n                final BigDecimal[] dataRow    = data[row];\n                final BigDecimal[] outDataRow = outData[row];\n                for (int col = 0; col < columnCount; col++) {\n                    outDataRow[col] = dataRow[col].add(m.getEntry(row, col));\n                }  \n            }\n            return new BigMatrixImpl(outData, false);\n        }\n    }\n\n    \n    public BigMatrixImpl add(BigMatrixImpl m) throws IllegalArgumentException {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n            throw new IllegalArgumentException(\"matrix dimension mismatch\");\n        }\n        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n        for (int row = 0; row < rowCount; row++) {\n            final BigDecimal[] dataRow    = data[row];\n            final BigDecimal[] mRow       = m.data[row];\n            final BigDecimal[] outDataRow = outData[row];\n            for (int col = 0; col < columnCount; col++) {\n                outDataRow[col] = dataRow[col].add(mRow[col]);\n            }  \n        }\n        return new BigMatrixImpl(outData, false);\n    }\n\n    \n    public BigMatrix subtract(BigMatrix m) throws IllegalArgumentException {\n        try {\n            return subtract((BigMatrixImpl) m);\n        } catch (ClassCastException cce) {\n            final int rowCount    = getRowDimension();\n            final int columnCount = getColumnDimension();\n            if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n                throw new IllegalArgumentException(\"matrix dimension mismatch\");\n            }\n            final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n            for (int row = 0; row < rowCount; row++) {\n                final BigDecimal[] dataRow    = data[row];\n                final BigDecimal[] outDataRow = outData[row];\n                for (int col = 0; col < columnCount; col++) {\n                    outDataRow[col] = dataRow[col].subtract(getEntry(row, col));\n                }  \n            }\n            return new BigMatrixImpl(outData, false);\n        }\n    }\n\n    \n    public BigMatrixImpl subtract(BigMatrixImpl m) throws IllegalArgumentException {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n            throw new IllegalArgumentException(\"matrix dimension mismatch\");\n        }\n        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n        for (int row = 0; row < rowCount; row++) {\n            final BigDecimal[] dataRow    = data[row];\n            final BigDecimal[] mRow       = m.data[row];\n            final BigDecimal[] outDataRow = outData[row];\n            for (int col = 0; col < columnCount; col++) {\n                outDataRow[col] = dataRow[col].subtract(mRow[col]);\n            }  \n        }\n        return new BigMatrixImpl(outData, false);\n    }\n\n    \n    public BigMatrix scalarAdd(BigDecimal d) {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n        for (int row = 0; row < rowCount; row++) {\n            final BigDecimal[] dataRow    = data[row];\n            final BigDecimal[] outDataRow = outData[row];\n            for (int col = 0; col < columnCount; col++) {\n                outDataRow[col] = dataRow[col].add(d);\n            }\n        }\n        return new BigMatrixImpl(outData, false);\n    }\n\n    \n    public BigMatrix scalarMultiply(BigDecimal d) {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n        for (int row = 0; row < rowCount; row++) {\n            final BigDecimal[] dataRow    = data[row];\n            final BigDecimal[] outDataRow = outData[row];\n            for (int col = 0; col < columnCount; col++) {\n                outDataRow[col] = dataRow[col].multiply(d);\n            }\n        }\n        return new BigMatrixImpl(outData, false);\n    }\n\n    \n    public BigMatrix multiply(BigMatrix m) throws IllegalArgumentException {\n        try {\n            return multiply((BigMatrixImpl) m);\n        } catch (ClassCastException cce) {\n            if (this.getColumnDimension() != m.getRowDimension()) {\n                throw new IllegalArgumentException(\"Matrices are not multiplication compatible.\");\n            }\n            final int nRows = this.getRowDimension();\n            final int nCols = m.getColumnDimension();\n            final int nSum = this.getColumnDimension();\n            final BigDecimal[][] outData = new BigDecimal[nRows][nCols];\n            for (int row = 0; row < nRows; row++) {\n                final BigDecimal[] dataRow    = data[row];\n                final BigDecimal[] outDataRow = outData[row];\n                for (int col = 0; col < nCols; col++) {\n                    BigDecimal sum = ZERO;\n                    for (int i = 0; i < nSum; i++) {\n                        sum = sum.add(dataRow[i].multiply(m.getEntry(i, col)));\n                    }\n                    outDataRow[col] = sum;\n                }\n            }\n            return new BigMatrixImpl(outData, false);\n        }\n    }\n\n    \n    public BigMatrixImpl multiply(BigMatrixImpl m) throws IllegalArgumentException {\n        if (this.getColumnDimension() != m.getRowDimension()) {\n            throw new IllegalArgumentException(\"Matrices are not multiplication compatible.\");\n        }\n        final int nRows = this.getRowDimension();\n        final int nCols = m.getColumnDimension();\n        final int nSum = this.getColumnDimension();\n        final BigDecimal[][] outData = new BigDecimal[nRows][nCols];\n        for (int row = 0; row < nRows; row++) {\n            final BigDecimal[] dataRow    = data[row];\n            final BigDecimal[] outDataRow = outData[row];\n            for (int col = 0; col < nCols; col++) {\n                BigDecimal sum = ZERO;\n                for (int i = 0; i < nSum; i++) {\n                    sum = sum.add(dataRow[i].multiply(m.data[i][col]));\n                }\n                outDataRow[col] = sum;\n            }\n        }            \n        return new BigMatrixImpl(outData, false);\n    }\n\n    \n    public BigMatrix preMultiply(BigMatrix m) throws IllegalArgumentException {\n        return m.multiply(this);\n    }\n\n    \n    public BigDecimal[][] getData() {\n        return copyOut();\n    }\n    \n    \n    public double[][] getDataAsDoubleArray() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final double d[][] = new double[nRows][nCols];\n        for (int i = 0; i < nRows; i++) {\n            for (int j = 0; j < nCols; j++) {\n                d[i][j] = data[i][j].doubleValue();\n            }\n        }\n        return d;\n    }\n    \n    \n    public BigDecimal[][] getDataRef() {\n        return data;\n    }\n    \n     \n    public int getRoundingMode() {\n        return roundingMode;\n    }\n    \n    \n    public void setRoundingMode(int roundingMode) {\n        this.roundingMode = roundingMode;\n    }\n    \n    \n    public int getScale() {\n        return scale;\n    }\n    \n    \n    public void setScale(int scale) {\n        this.scale = scale;\n    }\n    \n    \n    public BigDecimal getNorm() {\n        BigDecimal maxColSum = ZERO;\n        for (int col = 0; col < this.getColumnDimension(); col++) {\n            BigDecimal sum = ZERO;\n            for (int row = 0; row < this.getRowDimension(); row++) {\n                sum = sum.add(data[row][col].abs());\n            }\n            maxColSum = maxColSum.max(sum);\n        }\n        return maxColSum;\n    }\n    \n    \n    public BigMatrix getSubMatrix(int startRow, int endRow, int startColumn, int endColumn) throws MatrixIndexException {\n        if (startRow < 0 || startRow > endRow || endRow > data.length ||\n                startColumn < 0 || startColumn > endColumn ||\n                endColumn > data[0].length ) {\n            throw new MatrixIndexException(\n            \"invalid row or column index selection\");\n        }\n        final BigDecimal[][] subMatrixData =\n            new BigDecimal[endRow - startRow + 1][endColumn - startColumn + 1];\n        for (int i = startRow; i <= endRow; i++) {\n            System.arraycopy(data[i], startColumn,\n                    subMatrixData[i - startRow], 0,\n                    endColumn - startColumn + 1);\n        }\n        return new BigMatrixImpl(subMatrixData, false);\n    }\n    \n    \n    public BigMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns) throws MatrixIndexException {\n        if (selectedRows.length * selectedColumns.length == 0) {\n            throw new MatrixIndexException(\n            \"selected row and column index arrays must be non-empty\");\n        }\n        final BigDecimal[][] subMatrixData =\n            new BigDecimal[selectedRows.length][selectedColumns.length];\n        try  {\n            for (int i = 0; i < selectedRows.length; i++) {\n                final BigDecimal[] subI = subMatrixData[i];\n                final BigDecimal[] dataSelectedI = data[selectedRows[i]];\n                for (int j = 0; j < selectedColumns.length; j++) {\n                    subI[j] = dataSelectedI[selectedColumns[j]];\n                }\n            }\n        }\n        catch (ArrayIndexOutOfBoundsException e) {\n            throw new MatrixIndexException(\"matrix dimension mismatch\");\n        }\n        return new BigMatrixImpl(subMatrixData, false);\n    } \n    \n    \n    public void setSubMatrix(BigDecimal[][] subMatrix, int row, int column) throws MatrixIndexException {\n        if ((row < 0) || (column < 0)){\n            throw new MatrixIndexException\n            (\"invalid row or column index selection\");          \n        }\n        final int nRows = subMatrix.length;\n        if (nRows == 0) {\n            throw new IllegalArgumentException(\n            \"Matrix must have at least one row.\"); \n        }\n        final int nCols = subMatrix[0].length;\n        if (nCols == 0) {\n            throw new IllegalArgumentException(\n            \"Matrix must have at least one column.\"); \n        }\n        for (int r = 1; r < nRows; r++) {\n            if (subMatrix[r].length != nCols) {\n                throw new IllegalArgumentException(\n                \"All input rows must have the same length.\");\n            }\n        }       \n        if (data == null) {\n            if ((row > 0)||(column > 0)) throw new MatrixIndexException\n            (\"matrix must be initialized to perfom this method\");\n            data = new BigDecimal[nRows][nCols];\n            System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);          \n        }   \n        if (((nRows + row) > this.getRowDimension()) ||\n            (nCols + column > this.getColumnDimension()))\n            throw new MatrixIndexException(\n            \"invalid row or column index selection\");                   \n        for (int i = 0; i < nRows; i++) {\n            System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);\n        } \n        lu = null;\n    }\n    \n    \n    public BigMatrix getRowMatrix(int row) throws MatrixIndexException {\n        if ( !isValidCoordinate( row, 0)) {\n            throw new MatrixIndexException(\"illegal row argument\");\n        }\n        final int ncols = this.getColumnDimension();\n        final BigDecimal[][] out = new BigDecimal[1][ncols]; \n        System.arraycopy(data[row], 0, out[0], 0, ncols);\n        return new BigMatrixImpl(out, false);\n    } \n    \n    \n    public BigMatrix getColumnMatrix(int column) throws MatrixIndexException {\n        if ( !isValidCoordinate( 0, column)) {\n            throw new MatrixIndexException(\"illegal column argument\");\n        }\n        final int nRows = this.getRowDimension();\n        final BigDecimal[][] out = new BigDecimal[nRows][1]; \n        for (int row = 0; row < nRows; row++) {\n            out[row][0] = data[row][column];\n        }\n        return new BigMatrixImpl(out, false);\n    }\n    \n    \n    public BigDecimal[] getRow(int row) throws MatrixIndexException {\n        if ( !isValidCoordinate( row, 0 ) ) {\n            throw new MatrixIndexException(\"illegal row argument\");\n        }\n        final int ncols = this.getColumnDimension();\n        final BigDecimal[] out = new BigDecimal[ncols];\n        System.arraycopy(data[row], 0, out, 0, ncols);\n        return out;\n    }\n    \n     \n    public double[] getRowAsDoubleArray(int row) throws MatrixIndexException {\n        if ( !isValidCoordinate( row, 0 ) ) {\n            throw new MatrixIndexException(\"illegal row argument\");\n        }\n        final int ncols = this.getColumnDimension();\n        final double[] out = new double[ncols];\n        for (int i=0;i<ncols;i++) {\n            out[i] = data[row][i].doubleValue();\n        }\n        return out;\n    }\n    \n     \n    public BigDecimal[] getColumn(int col) throws MatrixIndexException {\n        if ( !isValidCoordinate(0, col) ) {\n            throw new MatrixIndexException(\"illegal column argument\");\n        }\n        final int nRows = this.getRowDimension();\n        final BigDecimal[] out = new BigDecimal[nRows];\n        for (int i = 0; i < nRows; i++) {\n            out[i] = data[i][col];\n        }\n        return out;\n    }\n    \n    \n    public double[] getColumnAsDoubleArray(int col) throws MatrixIndexException {\n        if ( !isValidCoordinate( 0, col ) ) {\n            throw new MatrixIndexException(\"illegal column argument\");\n        }\n        final int nrows = this.getRowDimension();\n        final double[] out = new double[nrows];\n        for (int i=0;i<nrows;i++) {\n            out[i] = data[i][col].doubleValue();\n        }\n        return out;\n    }\n    \n     \n    public BigDecimal getEntry(int row, int column) throws MatrixIndexException {\n        try {\n            return data[row][column];\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new MatrixIndexException(\"matrix entry does not exist\");\n        }\n    }\n    \n    \n    public double getEntryAsDouble(int row, int column) throws MatrixIndexException {\n        return getEntry(row,column).doubleValue();\n    }\n    \n    \n    public BigMatrix transpose() {\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        final BigDecimal[][] outData = new BigDecimal[nCols][nRows];\n        for (int row = 0; row < nRows; row++) {\n            final BigDecimal[] dataRow = data[row];\n            for (int col = 0; col < nCols; col++) {\n                outData[col][row] = dataRow[col];\n            }\n        }\n        return new BigMatrixImpl(outData, false);\n    }\n    \n    \n    public BigMatrix inverse() throws InvalidMatrixException {\n        return solve(MatrixUtils.createBigIdentityMatrix(getRowDimension()));\n    }\n    \n    \n    public BigDecimal getDeterminant() throws InvalidMatrixException {\n        if (!isSquare()) {\n            throw new InvalidMatrixException(\"matrix is not square\");\n        }\n        if (isSingular()) {   \n            return ZERO;\n        } else {\n            BigDecimal det = (parity == 1) ? ONE : ONE.negate();\n            for (int i = 0; i < this.getRowDimension(); i++) {\n                det = det.multiply(lu[i][i]);\n            }\n            return det;\n        }\n    }\n    \n     \n    public boolean isSquare() {\n        return (this.getColumnDimension() == this.getRowDimension());\n    }\n    \n    \n    public boolean isSingular() {\n        if (lu == null) {\n            try {\n                luDecompose();\n                return false;\n            } catch (InvalidMatrixException ex) {\n                return true;\n            }\n        } else { \n            return false; \n        }\n    }\n    \n    \n    public int getRowDimension() {\n        return data.length;\n    }\n    \n    \n    public int getColumnDimension() {\n        return data[0].length;\n    }\n    \n     \n    public BigDecimal getTrace() throws IllegalArgumentException {\n        if (!isSquare()) {\n            throw new IllegalArgumentException(\"matrix is not square\");\n        }\n        BigDecimal trace = data[0][0];\n        for (int i = 1; i < this.getRowDimension(); i++) {\n            trace = trace.add(data[i][i]);\n        }\n        return trace;\n    }\n    \n    \n    public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n        if (v.length != this.getColumnDimension()) {\n            throw new IllegalArgumentException(\"vector has wrong length\");\n        }\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        final BigDecimal[] out = new BigDecimal[v.length];\n        for (int row = 0; row < nRows; row++) {\n            BigDecimal sum = ZERO;\n            for (int i = 0; i < nCols; i++) {\n                sum = sum.add(data[row][i].multiply(v[i]));\n            }\n            out[row] = sum;\n        }\n        return out;\n    }\n    \n    \n    public BigDecimal[] operate(double[] v) throws IllegalArgumentException {\n        final BigDecimal bd[] = new BigDecimal[v.length];\n        for (int i = 0; i < bd.length; i++) {\n            bd[i] = new BigDecimal(v[i]);\n        }\n        return operate(bd);\n    }\n    \n    \n    public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n        final int nRows = this.getRowDimension();\n        if (v.length != nRows) {\n            throw new IllegalArgumentException(\"vector has wrong length\");\n        }\n        final int nCols = this.getColumnDimension();\n        final BigDecimal[] out = new BigDecimal[nCols];\n        for (int col = 0; col < nCols; col++) {\n            BigDecimal sum = ZERO;\n            for (int i = 0; i < nRows; i++) {\n                sum = sum.add(data[i][col].multiply(v[i]));\n            }\n            out[col] = sum;\n        }\n        return out;\n    }\n    \n    \n    public BigDecimal[] solve(BigDecimal[] b) throws IllegalArgumentException, InvalidMatrixException {\n        final int nRows = this.getRowDimension();\n        if (b.length != nRows) {\n            throw new IllegalArgumentException(\"constant vector has wrong length\");\n        }\n        final BigMatrix bMatrix = new BigMatrixImpl(b);\n        final BigDecimal[][] solution = ((BigMatrixImpl) (solve(bMatrix))).getDataRef();\n        final BigDecimal[] out = new BigDecimal[nRows];\n        for (int row = 0; row < nRows; row++) {\n            out[row] = solution[row][0];\n        }\n        return out;\n    }\n    \n    \n    public BigDecimal[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {\n        final BigDecimal bd[] = new BigDecimal[b.length];\n        for (int i = 0; i < bd.length; i++) {\n            bd[i] = new BigDecimal(b[i]);\n        }\n        return solve(bd);\n    }\n    \n    \n    public BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException {\n        if (b.getRowDimension() != this.getRowDimension()) {\n            throw new IllegalArgumentException(\"Incorrect row dimension\");\n        }\n        if (!this.isSquare()) {\n            throw new InvalidMatrixException(\"coefficient matrix is not square\");\n        }\n        if (this.isSingular()) { \n            throw new InvalidMatrixException(\"Matrix is singular.\");\n        }\n        \n        final int nCol = this.getColumnDimension();\n        final int nColB = b.getColumnDimension();\n        final int nRowB = b.getRowDimension();\n        \n        \n        final BigDecimal[][] bp = new BigDecimal[nRowB][nColB];\n        for (int row = 0; row < nRowB; row++) {\n            final BigDecimal[] bpRow = bp[row];\n            for (int col = 0; col < nColB; col++) {\n                bpRow[col] = b.getEntry(permutation[row], col);\n            }\n        }\n        \n        \n        for (int col = 0; col < nCol; col++) {\n            for (int i = col + 1; i < nCol; i++) {\n                final BigDecimal[] bpI = bp[i];\n                final BigDecimal[] luI = lu[i];\n                for (int j = 0; j < nColB; j++) {\n                    bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col]));\n                }\n            }\n        }\n        \n        \n        for (int col = nCol - 1; col >= 0; col--) {\n            final BigDecimal[] bpCol = bp[col];\n            final BigDecimal luDiag = lu[col][col];\n            for (int j = 0; j < nColB; j++) {\n                bpCol[j] = bpCol[j].divide(luDiag, scale, roundingMode);\n            }\n            for (int i = 0; i < col; i++) {\n                final BigDecimal[] bpI = bp[i];\n                final BigDecimal[] luI = lu[i];\n                for (int j = 0; j < nColB; j++) {\n                    bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col]));\n                }\n            }\n        }\n\n        return new BigMatrixImpl(bp, false);\n\n    }\n    \n    \n    public void luDecompose() throws InvalidMatrixException {\n        \n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        if (nRows != nCols) {\n            throw new InvalidMatrixException(\"LU decomposition requires that the matrix be square.\");\n        }\n        lu = this.getData();\n        \n        \n        permutation = new int[nRows];\n        for (int row = 0; row < nRows; row++) {\n            permutation[row] = row;\n        }\n        parity = 1;\n        \n        \n        for (int col = 0; col < nCols; col++) {\n            \n            BigDecimal sum = ZERO;\n            \n            \n            for (int row = 0; row < col; row++) {\n                final BigDecimal[] luRow = lu[row];\n                sum = luRow[col];\n                for (int i = 0; i < row; i++) {\n                    sum = sum.subtract(luRow[i].multiply(lu[i][col]));\n                }\n                luRow[col] = sum;\n            }\n            \n            \n            int max = col; \n            BigDecimal largest = ZERO;\n            for (int row = col; row < nRows; row++) {\n                final BigDecimal[] luRow = lu[row];\n                sum = luRow[col];\n                for (int i = 0; i < col; i++) {\n                    sum = sum.subtract(luRow[i].multiply(lu[i][col]));\n                }\n                luRow[col] = sum;\n                \n                \n                if (sum.abs().compareTo(largest) == 1) {\n                    largest = sum.abs();\n                    max = row;\n                }\n            }\n            \n            \n            if (lu[max][col].abs().compareTo(TOO_SMALL) <= 0) {\n                lu = null;\n                throw new InvalidMatrixException(\"matrix is singular\");\n            }\n            \n            \n            if (max != col) {\n                BigDecimal tmp = ZERO;\n                for (int i = 0; i < nCols; i++) {\n                    tmp = lu[max][i];\n                    lu[max][i] = lu[col][i];\n                    lu[col][i] = tmp;\n                }\n                int temp = permutation[max];\n                permutation[max] = permutation[col];\n                permutation[col] = temp;\n                parity = -parity;\n            }\n            \n            \n            final BigDecimal luDiag = lu[col][col];\n            for (int row = col + 1; row < nRows; row++) {\n                final BigDecimal[] luRow = lu[row];\n                luRow[col] = luRow[col].divide(luDiag, scale, roundingMode);\n            }\n            \n        }\n        \n    }\n    \n    \n    public String toString() {\n        StringBuffer res = new StringBuffer();\n        res.append(\"BigMatrixImpl{\");\n        if (data != null) {\n            for (int i = 0; i < data.length; i++) {\n                if (i > 0) {\n                    res.append(\",\");\n                }\n                res.append(\"{\");\n                for (int j = 0; j < data[0].length; j++) {\n                    if (j > 0) {\n                        res.append(\",\");\n                    }\n                    res.append(data[i][j]);\n                } \n                res.append(\"}\");\n            } \n        }\n        res.append(\"}\");\n        return res.toString();\n    } \n    \n    \n    public boolean equals(Object object) {\n        if (object == this ) {\n            return true;\n        }\n        if (object instanceof BigMatrixImpl == false) {\n            return false;\n        }\n        final BigMatrix m = (BigMatrix) object;\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {\n            return false;\n        }\n        for (int row = 0; row < nRows; row++) {\n            final BigDecimal[] dataRow = data[row];\n            for (int col = 0; col < nCols; col++) {\n                if (!dataRow[col].equals(m.getEntry(row, col))) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    \n    public int hashCode() {\n        int ret = 7;\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        ret = ret * 31 + nRows;\n        ret = ret * 31 + nCols;\n        for (int row = 0; row < nRows; row++) {\n            final BigDecimal[] dataRow = data[row];\n            for (int col = 0; col < nCols; col++) {\n                ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * \n                dataRow[col].hashCode();\n            }\n        }   \n        return ret;\n    }\n    \n    \n    \n    \n    protected BigMatrix getLUMatrix() throws InvalidMatrixException {\n        if (lu == null) {\n            luDecompose();\n        }\n        return new BigMatrixImpl(lu);\n    }\n    \n    \n    protected int[] getPermutation() {\n        final int[] out = new int[permutation.length];\n        System.arraycopy(permutation, 0, out, 0, permutation.length);\n        return out;\n    }\n    \n    \n    \n    \n    private BigDecimal[][] copyOut() {\n        final int nRows = this.getRowDimension();\n        final BigDecimal[][] out = new BigDecimal[nRows][this.getColumnDimension()];\n        \n        for (int i = 0; i < nRows; i++) {\n            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n        }\n        return out;\n    }\n    \n    \n    private void copyIn(BigDecimal[][] in) {\n        setSubMatrix(in,0,0);\n    }\n    \n    \n    private void copyIn(double[][] in) {\n        final int nRows = in.length;\n        final int nCols = in[0].length;\n        data = new BigDecimal[nRows][nCols];\n        for (int i = 0; i < nRows; i++) {\n            final BigDecimal[] dataI = data[i];\n            final double[] inI = in[i];\n            for (int j = 0; j < nCols; j++) {\n                dataI[j] = new BigDecimal(inI[j]);\n            }\n        }\n        lu = null;\n    }\n    \n    \n    private void copyIn(String[][] in) {\n        final int nRows = in.length;\n        final int nCols = in[0].length;\n        data = new BigDecimal[nRows][nCols];\n        for (int i = 0; i < nRows; i++) {\n            final BigDecimal[] dataI = data[i];\n            final String[] inI = in[i];\n            for (int j = 0; j < nCols; j++) {\n                dataI[j] = new BigDecimal(inI[j]);\n            }\n        }\n        lu = null;\n    }\n    \n    \n    private boolean isValidCoordinate(int row, int col) {\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        return !(row < 0 || row >= nRows || col < 0 || col >= nCols);\n    }\n    \n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.linear;\nimport java.io.Serializable;\nimport java.math.BigDecimal;\n\n\npublic class BigMatrixImpl implements BigMatrix, Serializable { private static final long serialVersionUID = -1011428905656140431L; protected BigDecimal data[][] = null; protected BigDecimal lu[][] = null; protected int[] permutation = null; protected int parity = 1; private int roundingMode = BigDecimal.ROUND_HALF_UP; private int scale = 64; private static final BigDecimal TOO_SMALL = new BigDecimal(10E-12); static final BigDecimal ZERO = new BigDecimal(0); static final BigDecimal ONE = new BigDecimal(1); public BigMatrixImpl() {\n    }\n    \n    \n    public BigMatrixImpl(int rowDimension, int columnDimension) {\n        if (rowDimension <=0 || columnDimension <=0) {\n            throw new IllegalArgumentException\n            (\"row and column dimensions must be positive\");\n        }\n        data = new BigDecimal[rowDimension][columnDimension];\n        lu = null;\n    }\n    \n    \n    public BigMatrixImpl(BigDecimal[][] d) {\n        this.copyIn(d);\n        lu = null;\n    }\n\n    \n    public BigMatrixImpl(BigDecimal[][] d, boolean copyArray) {\n        if (copyArray) {\n            copyIn(d);\n        } else {\n            if (d == null) {\n                throw new NullPointerException();\n            }   \n            final int nRows = d.length;\n            if (nRows == 0) {\n                throw new IllegalArgumentException(\"Matrix must have at least one row.\"); \n            }\n            final int nCols = d[0].length;\n            if (nCols == 0) {\n                throw new IllegalArgumentException(\"Matrix must have at least one column.\"); \n            }\n            for (int r = 1; r < nRows; r++) {\n                if (d[r].length != nCols) {\n                    throw new IllegalArgumentException(\"All input rows must have the same length.\");\n                }\n            }       \n            data = d;\n        }\n        lu = null;\n    }\n\n    \n    public BigMatrixImpl(double[][] d) {\n        final int nRows = d.length;\n        if (nRows == 0) {\n            throw new IllegalArgumentException(\n            \"Matrix must have at least one row.\"); \n        }\n        final int nCols = d[0].length;\n        if (nCols == 0) {\n            throw new IllegalArgumentException(\n            \"Matrix must have at least one column.\"); \n        }\n        for (int row = 1; row < nRows; row++) {\n            if (d[row].length != nCols) {\n                throw new IllegalArgumentException(\n                \"All input rows must have the same length.\");\n            }\n        }\n        this.copyIn(d);\n        lu = null;\n    }\n    \n    \n    public BigMatrixImpl(String[][] d) {\n        final int nRows = d.length;\n        if (nRows == 0) {\n            throw new IllegalArgumentException(\n            \"Matrix must have at least one row.\"); \n        }\n        final int nCols = d[0].length;\n        if (nCols == 0) {\n            throw new IllegalArgumentException(\n            \"Matrix must have at least one column.\"); \n        }\n        for (int row = 1; row < nRows; row++) {\n            if (d[row].length != nCols) {\n                throw new IllegalArgumentException(\n                \"All input rows must have the same length.\");\n            }\n        }\n        this.copyIn(d);\n        lu = null;\n    }\n    \n    \n    public BigMatrixImpl(BigDecimal[] v) {\n        final int nRows = v.length;\n        data = new BigDecimal[nRows][1];\n        for (int row = 0; row < nRows; row++) {\n            data[row][0] = v[row];\n        }\n    }\n    \n    \n    public BigMatrix copy() {\n        return new BigMatrixImpl(this.copyOut(), false);\n    }\n    \n    \n    public BigMatrix add(BigMatrix m) throws IllegalArgumentException {\n        try {\n            return add((BigMatrixImpl) m);\n        } catch (ClassCastException cce) {\n            final int rowCount    = getRowDimension();\n            final int columnCount = getColumnDimension();\n            if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n                throw new IllegalArgumentException(\"matrix dimension mismatch\");\n            }\n            final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n            for (int row = 0; row < rowCount; row++) {\n                final BigDecimal[] dataRow    = data[row];\n                final BigDecimal[] outDataRow = outData[row];\n                for (int col = 0; col < columnCount; col++) {\n                    outDataRow[col] = dataRow[col].add(m.getEntry(row, col));\n                }  \n            }\n            return new BigMatrixImpl(outData, false);\n        }\n    }\n\n    \n    public BigMatrixImpl add(BigMatrixImpl m) throws IllegalArgumentException {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n            throw new IllegalArgumentException(\"matrix dimension mismatch\");\n        }\n        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n        for (int row = 0; row < rowCount; row++) {\n            final BigDecimal[] dataRow    = data[row];\n            final BigDecimal[] mRow       = m.data[row];\n            final BigDecimal[] outDataRow = outData[row];\n            for (int col = 0; col < columnCount; col++) {\n                outDataRow[col] = dataRow[col].add(mRow[col]);\n            }  \n        }\n        return new BigMatrixImpl(outData, false);\n    }\n\n    \n    public BigMatrix subtract(BigMatrix m) throws IllegalArgumentException {\n        try {\n            return subtract((BigMatrixImpl) m);\n        } catch (ClassCastException cce) {\n            final int rowCount    = getRowDimension();\n            final int columnCount = getColumnDimension();\n            if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n                throw new IllegalArgumentException(\"matrix dimension mismatch\");\n            }\n            final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n            for (int row = 0; row < rowCount; row++) {\n                final BigDecimal[] dataRow    = data[row];\n                final BigDecimal[] outDataRow = outData[row];\n                for (int col = 0; col < columnCount; col++) {\n                    outDataRow[col] = dataRow[col].subtract(getEntry(row, col));\n                }  \n            }\n            return new BigMatrixImpl(outData, false);\n        }\n    }\n\n    \n    public BigMatrixImpl subtract(BigMatrixImpl m) throws IllegalArgumentException {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n            throw new IllegalArgumentException(\"matrix dimension mismatch\");\n        }\n        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n        for (int row = 0; row < rowCount; row++) {\n            final BigDecimal[] dataRow    = data[row];\n            final BigDecimal[] mRow       = m.data[row];\n            final BigDecimal[] outDataRow = outData[row];\n            for (int col = 0; col < columnCount; col++) {\n                outDataRow[col] = dataRow[col].subtract(mRow[col]);\n            }  \n        }\n        return new BigMatrixImpl(outData, false);\n    }\n\n    \n    public BigMatrix scalarAdd(BigDecimal d) {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n        for (int row = 0; row < rowCount; row++) {\n            final BigDecimal[] dataRow    = data[row];\n            final BigDecimal[] outDataRow = outData[row];\n            for (int col = 0; col < columnCount; col++) {\n                outDataRow[col] = dataRow[col].add(d);\n            }\n        }\n        return new BigMatrixImpl(outData, false);\n    }\n\n    \n    public BigMatrix scalarMultiply(BigDecimal d) {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n        for (int row = 0; row < rowCount; row++) {\n            final BigDecimal[] dataRow    = data[row];\n            final BigDecimal[] outDataRow = outData[row];\n            for (int col = 0; col < columnCount; col++) {\n                outDataRow[col] = dataRow[col].multiply(d);\n            }\n        }\n        return new BigMatrixImpl(outData, false);\n    }\n\n    \n    public BigMatrix multiply(BigMatrix m) throws IllegalArgumentException {\n        try {\n            return multiply((BigMatrixImpl) m);\n        } catch (ClassCastException cce) {\n            if (this.getColumnDimension() != m.getRowDimension()) {\n                throw new IllegalArgumentException(\"Matrices are not multiplication compatible.\");\n            }\n            final int nRows = this.getRowDimension();\n            final int nCols = m.getColumnDimension();\n            final int nSum = this.getColumnDimension();\n            final BigDecimal[][] outData = new BigDecimal[nRows][nCols];\n            for (int row = 0; row < nRows; row++) {\n                final BigDecimal[] dataRow    = data[row];\n                final BigDecimal[] outDataRow = outData[row];\n                for (int col = 0; col < nCols; col++) {\n                    BigDecimal sum = ZERO;\n                    for (int i = 0; i < nSum; i++) {\n                        sum = sum.add(dataRow[i].multiply(m.getEntry(i, col)));\n                    }\n                    outDataRow[col] = sum;\n                }\n            }\n            return new BigMatrixImpl(outData, false);\n        }\n    }\n\n    \n    public BigMatrixImpl multiply(BigMatrixImpl m) throws IllegalArgumentException {\n        if (this.getColumnDimension() != m.getRowDimension()) {\n            throw new IllegalArgumentException(\"Matrices are not multiplication compatible.\");\n        }\n        final int nRows = this.getRowDimension();\n        final int nCols = m.getColumnDimension();\n        final int nSum = this.getColumnDimension();\n        final BigDecimal[][] outData = new BigDecimal[nRows][nCols];\n        for (int row = 0; row < nRows; row++) {\n            final BigDecimal[] dataRow    = data[row];\n            final BigDecimal[] outDataRow = outData[row];\n            for (int col = 0; col < nCols; col++) {\n                BigDecimal sum = ZERO;\n                for (int i = 0; i < nSum; i++) {\n                    sum = sum.add(dataRow[i].multiply(m.data[i][col]));\n                }\n                outDataRow[col] = sum;\n            }\n        }            \n        return new BigMatrixImpl(outData, false);\n    }\n\n    \n    public BigMatrix preMultiply(BigMatrix m) throws IllegalArgumentException {\n        return m.multiply(this);\n    }\n\n    \n    public BigDecimal[][] getData() {\n        return copyOut();\n    }\n    \n    \n    public double[][] getDataAsDoubleArray() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final double d[][] = new double[nRows][nCols];\n        for (int i = 0; i < nRows; i++) {\n            for (int j = 0; j < nCols; j++) {\n                d[i][j] = data[i][j].doubleValue();\n            }\n        }\n        return d;\n    }\n    \n    \n    public BigDecimal[][] getDataRef() {\n        return data;\n    }\n    \n     \n    public int getRoundingMode() {\n        return roundingMode;\n    }\n    \n    \n    public void setRoundingMode(int roundingMode) {\n        this.roundingMode = roundingMode;\n    }\n    \n    \n    public int getScale() {\n        return scale;\n    }\n    \n    \n    public void setScale(int scale) {\n        this.scale = scale;\n    }\n    \n    \n    public BigDecimal getNorm() {\n        BigDecimal maxColSum = ZERO;\n        for (int col = 0; col < this.getColumnDimension(); col++) {\n            BigDecimal sum = ZERO;\n            for (int row = 0; row < this.getRowDimension(); row++) {\n                sum = sum.add(data[row][col].abs());\n            }\n            maxColSum = maxColSum.max(sum);\n        }\n        return maxColSum;\n    }\n    \n    \n    public BigMatrix getSubMatrix(int startRow, int endRow, int startColumn, int endColumn) throws MatrixIndexException {\n        if (startRow < 0 || startRow > endRow || endRow > data.length ||\n                startColumn < 0 || startColumn > endColumn ||\n                endColumn > data[0].length ) {\n            throw new MatrixIndexException(\n            \"invalid row or column index selection\");\n        }\n        final BigDecimal[][] subMatrixData =\n            new BigDecimal[endRow - startRow + 1][endColumn - startColumn + 1];\n        for (int i = startRow; i <= endRow; i++) {\n            System.arraycopy(data[i], startColumn,\n                    subMatrixData[i - startRow], 0,\n                    endColumn - startColumn + 1);\n        }\n        return new BigMatrixImpl(subMatrixData, false);\n    }\n    \n    \n    public BigMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns) throws MatrixIndexException {\n        if (selectedRows.length * selectedColumns.length == 0) {\n            throw new MatrixIndexException(\n            \"selected row and column index arrays must be non-empty\");\n        }\n        final BigDecimal[][] subMatrixData =\n            new BigDecimal[selectedRows.length][selectedColumns.length];\n        try  {\n            for (int i = 0; i < selectedRows.length; i++) {\n                final BigDecimal[] subI = subMatrixData[i];\n                final BigDecimal[] dataSelectedI = data[selectedRows[i]];\n                for (int j = 0; j < selectedColumns.length; j++) {\n                    subI[j] = dataSelectedI[selectedColumns[j]];\n                }\n            }\n        }\n        catch (ArrayIndexOutOfBoundsException e) {\n            throw new MatrixIndexException(\"matrix dimension mismatch\");\n        }\n        return new BigMatrixImpl(subMatrixData, false);\n    } \n    \n    \n    public void setSubMatrix(BigDecimal[][] subMatrix, int row, int column) throws MatrixIndexException {\n        if ((row < 0) || (column < 0)){\n            throw new MatrixIndexException\n            (\"invalid row or column index selection\");          \n        }\n        final int nRows = subMatrix.length;\n        if (nRows == 0) {\n            throw new IllegalArgumentException(\n            \"Matrix must have at least one row.\"); \n        }\n        final int nCols = subMatrix[0].length;\n        if (nCols == 0) {\n            throw new IllegalArgumentException(\n            \"Matrix must have at least one column.\"); \n        }\n        for (int r = 1; r < nRows; r++) {\n            if (subMatrix[r].length != nCols) {\n                throw new IllegalArgumentException(\n                \"All input rows must have the same length.\");\n            }\n        }       \n        if (data == null) {\n            if ((row > 0)||(column > 0)) throw new MatrixIndexException\n            (\"matrix must be initialized to perfom this method\");\n            data = new BigDecimal[nRows][nCols];\n            System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);          \n        }   \n        if (((nRows + row) > this.getRowDimension()) ||\n            (nCols + column > this.getColumnDimension()))\n            throw new MatrixIndexException(\n            \"invalid row or column index selection\");                   \n        for (int i = 0; i < nRows; i++) {\n            System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);\n        } \n        lu = null;\n    }\n    \n    \n    public BigMatrix getRowMatrix(int row) throws MatrixIndexException {\n        if ( !isValidCoordinate( row, 0)) {\n            throw new MatrixIndexException(\"illegal row argument\");\n        }\n        final int ncols = this.getColumnDimension();\n        final BigDecimal[][] out = new BigDecimal[1][ncols]; \n        System.arraycopy(data[row], 0, out[0], 0, ncols);\n        return new BigMatrixImpl(out, false);\n    } \n    \n    \n    public BigMatrix getColumnMatrix(int column) throws MatrixIndexException {\n        if ( !isValidCoordinate( 0, column)) {\n            throw new MatrixIndexException(\"illegal column argument\");\n        }\n        final int nRows = this.getRowDimension();\n        final BigDecimal[][] out = new BigDecimal[nRows][1]; \n        for (int row = 0; row < nRows; row++) {\n            out[row][0] = data[row][column];\n        }\n        return new BigMatrixImpl(out, false);\n    }\n    \n    \n    public BigDecimal[] getRow(int row) throws MatrixIndexException {\n        if ( !isValidCoordinate( row, 0 ) ) {\n            throw new MatrixIndexException(\"illegal row argument\");\n        }\n        final int ncols = this.getColumnDimension();\n        final BigDecimal[] out = new BigDecimal[ncols];\n        System.arraycopy(data[row], 0, out, 0, ncols);\n        return out;\n    }\n    \n     \n    public double[] getRowAsDoubleArray(int row) throws MatrixIndexException {\n        if ( !isValidCoordinate( row, 0 ) ) {\n            throw new MatrixIndexException(\"illegal row argument\");\n        }\n        final int ncols = this.getColumnDimension();\n        final double[] out = new double[ncols];\n        for (int i=0;i<ncols;i++) {\n            out[i] = data[row][i].doubleValue();\n        }\n        return out;\n    }\n    \n     \n    public BigDecimal[] getColumn(int col) throws MatrixIndexException {\n        if ( !isValidCoordinate(0, col) ) {\n            throw new MatrixIndexException(\"illegal column argument\");\n        }\n        final int nRows = this.getRowDimension();\n        final BigDecimal[] out = new BigDecimal[nRows];\n        for (int i = 0; i < nRows; i++) {\n            out[i] = data[i][col];\n        }\n        return out;\n    }\n    \n    \n    public double[] getColumnAsDoubleArray(int col) throws MatrixIndexException {\n        if ( !isValidCoordinate( 0, col ) ) {\n            throw new MatrixIndexException(\"illegal column argument\");\n        }\n        final int nrows = this.getRowDimension();\n        final double[] out = new double[nrows];\n        for (int i=0;i<nrows;i++) {\n            out[i] = data[i][col].doubleValue();\n        }\n        return out;\n    }\n    \n     \n    public BigDecimal getEntry(int row, int column) throws MatrixIndexException {\n        try {\n            return data[row][column];\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new MatrixIndexException(\"matrix entry does not exist\");\n        }\n    }\n    \n    \n    public double getEntryAsDouble(int row, int column) throws MatrixIndexException {\n        return getEntry(row,column).doubleValue();\n    }\n    \n    \n    public BigMatrix transpose() {\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        final BigDecimal[][] outData = new BigDecimal[nCols][nRows];\n        for (int row = 0; row < nRows; row++) {\n            final BigDecimal[] dataRow = data[row];\n            for (int col = 0; col < nCols; col++) {\n                outData[col][row] = dataRow[col];\n            }\n        }\n        return new BigMatrixImpl(outData, false);\n    }\n    \n    \n    public BigMatrix inverse() throws InvalidMatrixException {\n        return solve(MatrixUtils.createBigIdentityMatrix(getRowDimension()));\n    }\n    \n    \n    public BigDecimal getDeterminant() throws InvalidMatrixException {\n        if (!isSquare()) {\n            throw new InvalidMatrixException(\"matrix is not square\");\n        }\n        if (isSingular()) {   \n            return ZERO;\n        } else {\n            BigDecimal det = (parity == 1) ? ONE : ONE.negate();\n            for (int i = 0; i < this.getRowDimension(); i++) {\n                det = det.multiply(lu[i][i]);\n            }\n            return det;\n        }\n    }\n    \n     \n    public boolean isSquare() {\n        return (this.getColumnDimension() == this.getRowDimension());\n    }\n    \n    \n    public boolean isSingular() {\n        if (lu == null) {\n            try {\n                luDecompose();\n                return false;\n            } catch (InvalidMatrixException ex) {\n                return true;\n            }\n        } else { \n            return false; \n        }\n    }\n    \n    \n    public int getRowDimension() {\n        return data.length;\n    }\n    \n    \n    public int getColumnDimension() {\n        return data[0].length;\n    }\n    \n     \n    public BigDecimal getTrace() throws IllegalArgumentException {\n        if (!isSquare()) {\n            throw new IllegalArgumentException(\"matrix is not square\");\n        }\n        BigDecimal trace = data[0][0];\n        for (int i = 1; i < this.getRowDimension(); i++) {\n            trace = trace.add(data[i][i]);\n        }\n        return trace;\n    }\n    \n    \n    public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n        if (v.length != this.getColumnDimension()) {\n            throw new IllegalArgumentException(\"vector has wrong length\");\n        }\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        final BigDecimal[] out = new BigDecimal[nRows];\n        for (int row = 0; row < nRows; row++) {\n            BigDecimal sum = ZERO;\n            for (int i = 0; i < nCols; i++) {\n                sum = sum.add(data[row][i].multiply(v[i]));\n            }\n            out[row] = sum;\n        }\n        return out;\n    }\n    \n    \n    public BigDecimal[] operate(double[] v) throws IllegalArgumentException {\n        final BigDecimal bd[] = new BigDecimal[v.length];\n        for (int i = 0; i < bd.length; i++) {\n            bd[i] = new BigDecimal(v[i]);\n        }\n        return operate(bd);\n    }\n    \n    \n    public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n        final int nRows = this.getRowDimension();\n        if (v.length != nRows) {\n            throw new IllegalArgumentException(\"vector has wrong length\");\n        }\n        final int nCols = this.getColumnDimension();\n        final BigDecimal[] out = new BigDecimal[nCols];\n        for (int col = 0; col < nCols; col++) {\n            BigDecimal sum = ZERO;\n            for (int i = 0; i < nRows; i++) {\n                sum = sum.add(data[i][col].multiply(v[i]));\n            }\n            out[col] = sum;\n        }\n        return out;\n    }\n    \n    \n    public BigDecimal[] solve(BigDecimal[] b) throws IllegalArgumentException, InvalidMatrixException {\n        final int nRows = this.getRowDimension();\n        if (b.length != nRows) {\n            throw new IllegalArgumentException(\"constant vector has wrong length\");\n        }\n        final BigMatrix bMatrix = new BigMatrixImpl(b);\n        final BigDecimal[][] solution = ((BigMatrixImpl) (solve(bMatrix))).getDataRef();\n        final BigDecimal[] out = new BigDecimal[nRows];\n        for (int row = 0; row < nRows; row++) {\n            out[row] = solution[row][0];\n        }\n        return out;\n    }\n    \n    \n    public BigDecimal[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {\n        final BigDecimal bd[] = new BigDecimal[b.length];\n        for (int i = 0; i < bd.length; i++) {\n            bd[i] = new BigDecimal(b[i]);\n        }\n        return solve(bd);\n    }\n    \n    \n    public BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException {\n        if (b.getRowDimension() != this.getRowDimension()) {\n            throw new IllegalArgumentException(\"Incorrect row dimension\");\n        }\n        if (!this.isSquare()) {\n            throw new InvalidMatrixException(\"coefficient matrix is not square\");\n        }\n        if (this.isSingular()) { \n            throw new InvalidMatrixException(\"Matrix is singular.\");\n        }\n        \n        final int nCol = this.getColumnDimension();\n        final int nColB = b.getColumnDimension();\n        final int nRowB = b.getRowDimension();\n        \n        \n        final BigDecimal[][] bp = new BigDecimal[nRowB][nColB];\n        for (int row = 0; row < nRowB; row++) {\n            final BigDecimal[] bpRow = bp[row];\n            for (int col = 0; col < nColB; col++) {\n                bpRow[col] = b.getEntry(permutation[row], col);\n            }\n        }\n        \n        \n        for (int col = 0; col < nCol; col++) {\n            for (int i = col + 1; i < nCol; i++) {\n                final BigDecimal[] bpI = bp[i];\n                final BigDecimal[] luI = lu[i];\n                for (int j = 0; j < nColB; j++) {\n                    bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col]));\n                }\n            }\n        }\n        \n        \n        for (int col = nCol - 1; col >= 0; col--) {\n            final BigDecimal[] bpCol = bp[col];\n            final BigDecimal luDiag = lu[col][col];\n            for (int j = 0; j < nColB; j++) {\n                bpCol[j] = bpCol[j].divide(luDiag, scale, roundingMode);\n            }\n            for (int i = 0; i < col; i++) {\n                final BigDecimal[] bpI = bp[i];\n                final BigDecimal[] luI = lu[i];\n                for (int j = 0; j < nColB; j++) {\n                    bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col]));\n                }\n            }\n        }\n\n        return new BigMatrixImpl(bp, false);\n\n    }\n    \n    \n    public void luDecompose() throws InvalidMatrixException {\n        \n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        if (nRows != nCols) {\n            throw new InvalidMatrixException(\"LU decomposition requires that the matrix be square.\");\n        }\n        lu = this.getData();\n        \n        \n        permutation = new int[nRows];\n        for (int row = 0; row < nRows; row++) {\n            permutation[row] = row;\n        }\n        parity = 1;\n        \n        \n        for (int col = 0; col < nCols; col++) {\n            \n            BigDecimal sum = ZERO;\n            \n            \n            for (int row = 0; row < col; row++) {\n                final BigDecimal[] luRow = lu[row];\n                sum = luRow[col];\n                for (int i = 0; i < row; i++) {\n                    sum = sum.subtract(luRow[i].multiply(lu[i][col]));\n                }\n                luRow[col] = sum;\n            }\n            \n            \n            int max = col; \n            BigDecimal largest = ZERO;\n            for (int row = col; row < nRows; row++) {\n                final BigDecimal[] luRow = lu[row];\n                sum = luRow[col];\n                for (int i = 0; i < col; i++) {\n                    sum = sum.subtract(luRow[i].multiply(lu[i][col]));\n                }\n                luRow[col] = sum;\n                \n                \n                if (sum.abs().compareTo(largest) == 1) {\n                    largest = sum.abs();\n                    max = row;\n                }\n            }\n            \n            \n            if (lu[max][col].abs().compareTo(TOO_SMALL) <= 0) {\n                lu = null;\n                throw new InvalidMatrixException(\"matrix is singular\");\n            }\n            \n            \n            if (max != col) {\n                BigDecimal tmp = ZERO;\n                for (int i = 0; i < nCols; i++) {\n                    tmp = lu[max][i];\n                    lu[max][i] = lu[col][i];\n                    lu[col][i] = tmp;\n                }\n                int temp = permutation[max];\n                permutation[max] = permutation[col];\n                permutation[col] = temp;\n                parity = -parity;\n            }\n            \n            \n            final BigDecimal luDiag = lu[col][col];\n            for (int row = col + 1; row < nRows; row++) {\n                final BigDecimal[] luRow = lu[row];\n                luRow[col] = luRow[col].divide(luDiag, scale, roundingMode);\n            }\n            \n        }\n        \n    }\n    \n    \n    public String toString() {\n        StringBuffer res = new StringBuffer();\n        res.append(\"BigMatrixImpl{\");\n        if (data != null) {\n            for (int i = 0; i < data.length; i++) {\n                if (i > 0) {\n                    res.append(\",\");\n                }\n                res.append(\"{\");\n                for (int j = 0; j < data[0].length; j++) {\n                    if (j > 0) {\n                        res.append(\",\");\n                    }\n                    res.append(data[i][j]);\n                } \n                res.append(\"}\");\n            } \n        }\n        res.append(\"}\");\n        return res.toString();\n    } \n    \n    \n    public boolean equals(Object object) {\n        if (object == this ) {\n            return true;\n        }\n        if (object instanceof BigMatrixImpl == false) {\n            return false;\n        }\n        final BigMatrix m = (BigMatrix) object;\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {\n            return false;\n        }\n        for (int row = 0; row < nRows; row++) {\n            final BigDecimal[] dataRow = data[row];\n            for (int col = 0; col < nCols; col++) {\n                if (!dataRow[col].equals(m.getEntry(row, col))) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    \n    public int hashCode() {\n        int ret = 7;\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        ret = ret * 31 + nRows;\n        ret = ret * 31 + nCols;\n        for (int row = 0; row < nRows; row++) {\n            final BigDecimal[] dataRow = data[row];\n            for (int col = 0; col < nCols; col++) {\n                ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * \n                dataRow[col].hashCode();\n            }\n        }   \n        return ret;\n    }\n    \n    \n    \n    \n    protected BigMatrix getLUMatrix() throws InvalidMatrixException {\n        if (lu == null) {\n            luDecompose();\n        }\n        return new BigMatrixImpl(lu);\n    }\n    \n    \n    protected int[] getPermutation() {\n        final int[] out = new int[permutation.length];\n        System.arraycopy(permutation, 0, out, 0, permutation.length);\n        return out;\n    }\n    \n    \n    \n    \n    private BigDecimal[][] copyOut() {\n        final int nRows = this.getRowDimension();\n        final BigDecimal[][] out = new BigDecimal[nRows][this.getColumnDimension()];\n        \n        for (int i = 0; i < nRows; i++) {\n            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n        }\n        return out;\n    }\n    \n    \n    private void copyIn(BigDecimal[][] in) {\n        setSubMatrix(in,0,0);\n    }\n    \n    \n    private void copyIn(double[][] in) {\n        final int nRows = in.length;\n        final int nCols = in[0].length;\n        data = new BigDecimal[nRows][nCols];\n        for (int i = 0; i < nRows; i++) {\n            final BigDecimal[] dataI = data[i];\n            final double[] inI = in[i];\n            for (int j = 0; j < nCols; j++) {\n                dataI[j] = new BigDecimal(inI[j]);\n            }\n        }\n        lu = null;\n    }\n    \n    \n    private void copyIn(String[][] in) {\n        final int nRows = in.length;\n        final int nCols = in[0].length;\n        data = new BigDecimal[nRows][nCols];\n        for (int i = 0; i < nRows; i++) {\n            final BigDecimal[] dataI = data[i];\n            final String[] inI = in[i];\n            for (int j = 0; j < nCols; j++) {\n                dataI[j] = new BigDecimal(inI[j]);\n            }\n        }\n        lu = null;\n    }\n    \n    \n    private boolean isValidCoordinate(int row, int col) {\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        return !(row < 0 || row >= nRows || col < 0 || col >= nCols);\n    }\n    \n}\n",
      "buggy_signatures": [
        "public BigMatrixImpl(int rowDimension, int columnDimension)",
        "public BigMatrixImpl(BigDecimal[][] d)",
        "public BigMatrixImpl(BigDecimal[][] d, boolean copyArray)",
        "public BigMatrixImpl(double[][] d)",
        "public BigMatrixImpl(String[][] d)",
        "public BigMatrixImpl(BigDecimal[] v)",
        "public BigMatrix copy()",
        "public BigMatrix add(BigMatrix m) throws IllegalArgumentException",
        "public BigMatrixImpl add(BigMatrixImpl m) throws IllegalArgumentException",
        "public BigMatrix subtract(BigMatrix m) throws IllegalArgumentException",
        "public BigMatrixImpl subtract(BigMatrixImpl m) throws IllegalArgumentException",
        "public BigMatrix scalarAdd(BigDecimal d)",
        "public BigMatrix scalarMultiply(BigDecimal d)",
        "public BigMatrix multiply(BigMatrix m) throws IllegalArgumentException",
        "public BigMatrixImpl multiply(BigMatrixImpl m) throws IllegalArgumentException",
        "public BigMatrix preMultiply(BigMatrix m) throws IllegalArgumentException",
        "public BigDecimal[][] getData()",
        "public double[][] getDataAsDoubleArray()",
        "public BigDecimal[][] getDataRef()",
        "public int getRoundingMode()",
        "public void setRoundingMode(int roundingMode)",
        "public int getScale()",
        "public void setScale(int scale)",
        "public BigDecimal getNorm()",
        "public BigMatrix getSubMatrix(int startRow, int endRow, int startColumn, int endColumn) throws MatrixIndexException",
        "public BigMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns) throws MatrixIndexException",
        "public void setSubMatrix(BigDecimal[][] subMatrix, int row, int column) throws MatrixIndexException",
        "public BigMatrix getRowMatrix(int row) throws MatrixIndexException",
        "public BigMatrix getColumnMatrix(int column) throws MatrixIndexException",
        "public BigDecimal[] getRow(int row) throws MatrixIndexException",
        "public double[] getRowAsDoubleArray(int row) throws MatrixIndexException",
        "public BigDecimal[] getColumn(int col) throws MatrixIndexException",
        "public double[] getColumnAsDoubleArray(int col) throws MatrixIndexException",
        "public BigDecimal getEntry(int row, int column) throws MatrixIndexException",
        "public double getEntryAsDouble(int row, int column) throws MatrixIndexException",
        "public BigMatrix transpose()",
        "public BigMatrix inverse() throws InvalidMatrixException",
        "public BigDecimal getDeterminant() throws InvalidMatrixException",
        "public boolean isSquare()",
        "public boolean isSingular()",
        "public int getRowDimension()",
        "public int getColumnDimension()",
        "public BigDecimal getTrace() throws IllegalArgumentException",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException",
        "public BigDecimal[] operate(double[] v) throws IllegalArgumentException",
        "public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException",
        "public BigDecimal[] solve(BigDecimal[] b) throws IllegalArgumentException, InvalidMatrixException",
        "public BigDecimal[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException",
        "public BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException",
        "public void luDecompose() throws InvalidMatrixException",
        "public String toString()",
        "public boolean equals(Object object)",
        "public int hashCode()",
        "protected BigMatrix getLUMatrix() throws InvalidMatrixException",
        "protected int[] getPermutation()",
        "private BigDecimal[][] copyOut()",
        "private void copyIn(BigDecimal[][] in)",
        "private void copyIn(double[][] in)",
        "private void copyIn(String[][] in)",
        "private boolean isValidCoordinate(int row, int col)"
      ],
      "fixed_signatures": [
        "public BigMatrixImpl(int rowDimension, int columnDimension)",
        "public BigMatrixImpl(BigDecimal[][] d)",
        "public BigMatrixImpl(BigDecimal[][] d, boolean copyArray)",
        "public BigMatrixImpl(double[][] d)",
        "public BigMatrixImpl(String[][] d)",
        "public BigMatrixImpl(BigDecimal[] v)",
        "public BigMatrix copy()",
        "public BigMatrix add(BigMatrix m) throws IllegalArgumentException",
        "public BigMatrixImpl add(BigMatrixImpl m) throws IllegalArgumentException",
        "public BigMatrix subtract(BigMatrix m) throws IllegalArgumentException",
        "public BigMatrixImpl subtract(BigMatrixImpl m) throws IllegalArgumentException",
        "public BigMatrix scalarAdd(BigDecimal d)",
        "public BigMatrix scalarMultiply(BigDecimal d)",
        "public BigMatrix multiply(BigMatrix m) throws IllegalArgumentException",
        "public BigMatrixImpl multiply(BigMatrixImpl m) throws IllegalArgumentException",
        "public BigMatrix preMultiply(BigMatrix m) throws IllegalArgumentException",
        "public BigDecimal[][] getData()",
        "public double[][] getDataAsDoubleArray()",
        "public BigDecimal[][] getDataRef()",
        "public int getRoundingMode()",
        "public void setRoundingMode(int roundingMode)",
        "public int getScale()",
        "public void setScale(int scale)",
        "public BigDecimal getNorm()",
        "public BigMatrix getSubMatrix(int startRow, int endRow, int startColumn, int endColumn) throws MatrixIndexException",
        "public BigMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns) throws MatrixIndexException",
        "public void setSubMatrix(BigDecimal[][] subMatrix, int row, int column) throws MatrixIndexException",
        "public BigMatrix getRowMatrix(int row) throws MatrixIndexException",
        "public BigMatrix getColumnMatrix(int column) throws MatrixIndexException",
        "public BigDecimal[] getRow(int row) throws MatrixIndexException",
        "public double[] getRowAsDoubleArray(int row) throws MatrixIndexException",
        "public BigDecimal[] getColumn(int col) throws MatrixIndexException",
        "public double[] getColumnAsDoubleArray(int col) throws MatrixIndexException",
        "public BigDecimal getEntry(int row, int column) throws MatrixIndexException",
        "public double getEntryAsDouble(int row, int column) throws MatrixIndexException",
        "public BigMatrix transpose()",
        "public BigMatrix inverse() throws InvalidMatrixException",
        "public BigDecimal getDeterminant() throws InvalidMatrixException",
        "public boolean isSquare()",
        "public boolean isSingular()",
        "public int getRowDimension()",
        "public int getColumnDimension()",
        "public BigDecimal getTrace() throws IllegalArgumentException",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException",
        "public BigDecimal[] operate(double[] v) throws IllegalArgumentException",
        "public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException",
        "public BigDecimal[] solve(BigDecimal[] b) throws IllegalArgumentException, InvalidMatrixException",
        "public BigDecimal[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException",
        "public BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException",
        "public void luDecompose() throws InvalidMatrixException",
        "public String toString()",
        "public boolean equals(Object object)",
        "public int hashCode()",
        "protected BigMatrix getLUMatrix() throws InvalidMatrixException",
        "protected int[] getPermutation()",
        "private BigDecimal[][] copyOut()",
        "private void copyIn(BigDecimal[][] in)",
        "private void copyIn(double[][] in)",
        "private void copyIn(String[][] in)",
        "private boolean isValidCoordinate(int row, int col)"
      ],
      "methods": [
        {
          "buggy_method": "  public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n  if (v.length != this.getColumnDimension()) {\n  throw new IllegalArgumentException(\"vector has wrong length\");\n  }\n  final int nRows = this.getRowDimension();\n  final int nCols = this.getColumnDimension();\n  final BigDecimal[] out = new BigDecimal[v.length];\n  for (int row = 0; row < nRows; row++) {\n  BigDecimal sum = ZERO;\n  for (int i = 0; i < nCols; i++) {\n  sum = sum.add(data[row][i].multiply(v[i]));\n  }\n  out[row] = sum;\n  }\n  return out;\n  }",
          "fixed_method": "  public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n  if (v.length != this.getColumnDimension()) {\n  throw new IllegalArgumentException(\"vector has wrong length\");\n  }\n  final int nRows = this.getRowDimension();\n  final int nCols = this.getColumnDimension();\n  final BigDecimal[] out = new BigDecimal[nRows];\n  for (int row = 0; row < nRows; row++) {\n  BigDecimal sum = ZERO;\n  for (int i = 0; i < nCols; i++) {\n  sum = sum.add(data[row][i].multiply(v[i]));\n  }\n  out[row] = sum;\n  }\n  return out;\n  }",
          "diff": [
            "@@ -988,7 +988,7 @@",
            "         }\n",
            "         final int nRows = this.getRowDimension();\n",
            "         final int nCols = this.getColumnDimension();\n",
            "-        final BigDecimal[] out = new BigDecimal[v.length];\n",
            "+        final BigDecimal[] out = new BigDecimal[nRows];\n",
            "         for (int row = 0; row < nRows; row++) {\n",
            "             BigDecimal sum = ZERO;\n",
            "             for (int i = 0; i < nCols; i++) {\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "org/apache/commons/math/linear/RealMatrixImpl.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.linear;\n\nimport java.io.Serializable;\nimport org.apache.commons.math.util.MathUtils;\n\n\n\npublic class RealMatrixImpl implements RealMatrix, Serializable { private static final long serialVersionUID = -4828886979278117018L; protected double data[][] = null; protected double lu[][] = null; protected int[] permutation = null; protected int parity = 1; private static final double TOO_SMALL = 10E-12; public RealMatrixImpl() {\n    }\n\n    \n    public RealMatrixImpl(int rowDimension, int columnDimension) {\n        if (rowDimension <= 0 || columnDimension <= 0) {\n            throw new IllegalArgumentException(\n                    \"row and column dimensions must be postive\");\n        }\n        data = new double[rowDimension][columnDimension];\n        lu = null;\n    }\n\n    \n    public RealMatrixImpl(double[][] d) {\n        copyIn(d);\n        lu = null;\n    }\n\n    \n    public RealMatrixImpl(double[][] d, boolean copyArray) {\n        if (copyArray) {\n            copyIn(d);\n        } else {\n            if (d == null) {\n                throw new NullPointerException();\n            }   \n            final int nRows = d.length;\n            if (nRows == 0) {\n                throw new IllegalArgumentException(\"Matrix must have at least one row.\"); \n            }\n            final int nCols = d[0].length;\n            if (nCols == 0) {\n                throw new IllegalArgumentException(\"Matrix must have at least one column.\"); \n            }\n            for (int r = 1; r < nRows; r++) {\n                if (d[r].length != nCols) {\n                    throw new IllegalArgumentException(\"All input rows must have the same length.\");\n                }\n            }       \n            data = d;\n        }\n        lu = null;\n    }\n\n    \n    public RealMatrixImpl(double[] v) {\n        final int nRows = v.length;\n        data = new double[nRows][1];\n        for (int row = 0; row < nRows; row++) {\n            data[row][0] = v[row];\n        }\n    }\n\n    \n    public RealMatrix copy() {\n        return new RealMatrixImpl(copyOut(), false);\n    }\n\n    \n    public RealMatrix add(RealMatrix m) throws IllegalArgumentException {\n        try {\n            return add((RealMatrixImpl) m);\n        } catch (ClassCastException cce) {\n            final int rowCount    = getRowDimension();\n            final int columnCount = getColumnDimension();\n            if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n                throw new IllegalArgumentException(\"matrix dimension mismatch\");\n            }\n            final double[][] outData = new double[rowCount][columnCount];\n            for (int row = 0; row < rowCount; row++) {\n                final double[] dataRow    = data[row];\n                final double[] outDataRow = outData[row];\n                for (int col = 0; col < columnCount; col++) {\n                    outDataRow[col] = dataRow[col] + m.getEntry(row, col);\n                }  \n            }\n            return new RealMatrixImpl(outData, false);\n        }\n    }\n\n    \n    public RealMatrixImpl add(RealMatrixImpl m) throws IllegalArgumentException {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n            throw new IllegalArgumentException(\"matrix dimension mismatch\");\n        }\n        final double[][] outData = new double[rowCount][columnCount];\n        for (int row = 0; row < rowCount; row++) {\n            final double[] dataRow    = data[row];\n            final double[] mRow       = m.data[row];\n            final double[] outDataRow = outData[row];\n            for (int col = 0; col < columnCount; col++) {\n                outDataRow[col] = dataRow[col] + mRow[col];\n            }  \n        }\n        return new RealMatrixImpl(outData, false);\n    }\n\n    \n    public RealMatrix subtract(RealMatrix m) throws IllegalArgumentException {\n        try {\n            return subtract((RealMatrixImpl) m);\n        } catch (ClassCastException cce) {\n            final int rowCount    = getRowDimension();\n            final int columnCount = getColumnDimension();\n            if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n                throw new IllegalArgumentException(\"matrix dimension mismatch\");\n            }\n            final double[][] outData = new double[rowCount][columnCount];\n            for (int row = 0; row < rowCount; row++) {\n                final double[] dataRow    = data[row];\n                final double[] outDataRow = outData[row];\n                for (int col = 0; col < columnCount; col++) {\n                    outDataRow[col] = dataRow[col] - m.getEntry(row, col);\n                }  \n            }\n            return new RealMatrixImpl(outData, false);\n        }\n    }\n\n    \n    public RealMatrixImpl subtract(RealMatrixImpl m) throws IllegalArgumentException {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n            throw new IllegalArgumentException(\"matrix dimension mismatch\");\n        }\n        final double[][] outData = new double[rowCount][columnCount];\n        for (int row = 0; row < rowCount; row++) {\n            final double[] dataRow    = data[row];\n            final double[] mRow       = m.data[row];\n            final double[] outDataRow = outData[row];\n            for (int col = 0; col < columnCount; col++) {\n                outDataRow[col] = dataRow[col] - mRow[col];\n            }  \n        }\n        return new RealMatrixImpl(outData, false);\n    }\n\n    \n    public RealMatrix scalarAdd(double d) {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        final double[][] outData = new double[rowCount][columnCount];\n        for (int row = 0; row < rowCount; row++) {\n            final double[] dataRow    = data[row];\n            final double[] outDataRow = outData[row];\n            for (int col = 0; col < columnCount; col++) {\n                outDataRow[col] = dataRow[col] + d;\n            }\n        }\n        return new RealMatrixImpl(outData, false);\n    }\n\n    \n    public RealMatrix scalarMultiply(double d) {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        final double[][] outData = new double[rowCount][columnCount];\n        for (int row = 0; row < rowCount; row++) {\n            final double[] dataRow    = data[row];\n            final double[] outDataRow = outData[row];\n            for (int col = 0; col < columnCount; col++) {\n                outDataRow[col] = dataRow[col] * d;\n            }\n        }\n        return new RealMatrixImpl(outData, false);\n    }\n\n    \n    public RealMatrix multiply(RealMatrix m) throws IllegalArgumentException {\n        try {\n            return multiply((RealMatrixImpl) m);\n        } catch (ClassCastException cce) {\n            if (this.getColumnDimension() != m.getRowDimension()) {\n                throw new IllegalArgumentException(\"Matrices are not multiplication compatible.\");\n            }\n            final int nRows = this.getRowDimension();\n            final int nCols = m.getColumnDimension();\n            final int nSum = this.getColumnDimension();\n            final double[][] outData = new double[nRows][nCols];\n            for (int row = 0; row < nRows; row++) {\n                final double[] dataRow    = data[row];\n                final double[] outDataRow = outData[row];\n                for (int col = 0; col < nCols; col++) {\n                    double sum = 0;\n                    for (int i = 0; i < nSum; i++) {\n                        sum += dataRow[i] * m.getEntry(i, col);\n                    }\n                    outDataRow[col] = sum;\n                }\n            }\n            return new RealMatrixImpl(outData, false);\n        }\n    }\n\n    \n    public RealMatrixImpl multiply(RealMatrixImpl m) throws IllegalArgumentException {\n        if (this.getColumnDimension() != m.getRowDimension()) {\n            throw new IllegalArgumentException(\"Matrices are not multiplication compatible.\");\n        }\n        final int nRows = this.getRowDimension();\n        final int nCols = m.getColumnDimension();\n        final int nSum = this.getColumnDimension();\n        final double[][] outData = new double[nRows][nCols];\n        for (int row = 0; row < nRows; row++) {\n            final double[] dataRow    = data[row];\n            final double[] outDataRow = outData[row];\n            for (int col = 0; col < nCols; col++) {\n                double sum = 0;\n                for (int i = 0; i < nSum; i++) {\n                    sum += dataRow[i] * m.data[i][col];\n                }\n                outDataRow[col] = sum;\n            }\n        }            \n        return new RealMatrixImpl(outData, false);\n    }\n\n    \n    public RealMatrix preMultiply(RealMatrix m) throws IllegalArgumentException {\n        return m.multiply(this);\n    }\n\n    \n    public double[][] getData() {\n        return copyOut();\n    }\n\n    \n    public double[][] getDataRef() {\n        return data;\n    }\n\n    \n    public double getNorm() {\n        double maxColSum = 0;\n        for (int col = 0; col < this.getColumnDimension(); col++) {\n            double sum = 0;\n            for (int row = 0; row < this.getRowDimension(); row++) {\n                sum += Math.abs(data[row][col]);\n            }\n            maxColSum = Math.max(maxColSum, sum);\n        }\n        return maxColSum;\n    }\n    \n    \n    public RealMatrix getSubMatrix(int startRow, int endRow, int startColumn, int endColumn) throws MatrixIndexException {\n        if (startRow < 0 || startRow > endRow || endRow > data.length ||\n             startColumn < 0 || startColumn > endColumn ||\n             endColumn > data[0].length) {\n            throw new MatrixIndexException(\n                    \"invalid row or column index selection\");\n        }\n        final double[][] subMatrixData =\n            new double[endRow - startRow + 1][endColumn - startColumn + 1];\n        for (int i = startRow; i <= endRow; i++) {\n            System.arraycopy(data[i], startColumn,\n                             subMatrixData[i - startRow], 0,\n                             endColumn - startColumn + 1);\n        }\n        return new RealMatrixImpl(subMatrixData, false);\n    }\n    \n    \n    public RealMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns) throws MatrixIndexException {\n        if (selectedRows.length * selectedColumns.length == 0) {\n            throw new MatrixIndexException(\n                    \"selected row and column index arrays must be non-empty\");\n        }\n        final double[][] subMatrixData =\n            new double[selectedRows.length][selectedColumns.length];\n        try  {\n            for (int i = 0; i < selectedRows.length; i++) {\n                final double[] subI = subMatrixData[i];\n                final double[] dataSelectedI = data[selectedRows[i]];\n                for (int j = 0; j < selectedColumns.length; j++) {\n                    subI[j] = dataSelectedI[selectedColumns[j]];\n                }\n            }\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new MatrixIndexException(\"matrix dimension mismatch\");\n        }\n        return new RealMatrixImpl(subMatrixData, false);\n    } \n\n    \n    public void setSubMatrix(double[][] subMatrix, int row, int column) throws MatrixIndexException {\n        if ((row < 0) || (column < 0)){\n            throw new MatrixIndexException\n                (\"invalid row or column index selection\");          \n        }\n        final int nRows = subMatrix.length;\n        if (nRows == 0) {\n            throw new IllegalArgumentException(\n            \"Matrix must have at least one row.\"); \n        }\n        final int nCols = subMatrix[0].length;\n        if (nCols == 0) {\n            throw new IllegalArgumentException(\n            \"Matrix must have at least one column.\"); \n        }\n        for (int r = 1; r < nRows; r++) {\n            if (subMatrix[r].length != nCols) {\n                throw new IllegalArgumentException(\n                \"All input rows must have the same length.\");\n            }\n        }       \n        if (data == null) {\n            if ((row > 0)||(column > 0)) throw new MatrixIndexException\n                (\"matrix must be initialized to perfom this method\");\n            data = new double[nRows][nCols];\n            System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);          \n        }   \n        if (((nRows + row) > this.getRowDimension()) ||\n            (nCols + column > this.getColumnDimension()))\n            throw new MatrixIndexException(\n                    \"invalid row or column index selection\");                   \n        for (int i = 0; i < nRows; i++) {\n            System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);\n        } \n        lu = null;\n    }\n    \n    \n    public RealMatrix getRowMatrix(int row) throws MatrixIndexException {\n        if ( !isValidCoordinate( row, 0)) {\n            throw new MatrixIndexException(\"illegal row argument\");\n        }\n        final int ncols = this.getColumnDimension();\n        final double[][] out = new double[1][ncols]; \n        System.arraycopy(data[row], 0, out[0], 0, ncols);\n        return new RealMatrixImpl(out, false);\n    }\n    \n    \n    public RealMatrix getColumnMatrix(int column) throws MatrixIndexException {\n        if ( !isValidCoordinate( 0, column)) {\n            throw new MatrixIndexException(\"illegal column argument\");\n        }\n        final int nRows = this.getRowDimension();\n        final double[][] out = new double[nRows][1]; \n        for (int row = 0; row < nRows; row++) {\n            out[row][0] = data[row][column];\n        }\n        return new RealMatrixImpl(out, false);\n    }\n\n     \n    public double[] getRow(int row) throws MatrixIndexException {\n        if ( !isValidCoordinate( row, 0 ) ) {\n            throw new MatrixIndexException(\"illegal row argument\");\n        }\n        final int ncols = this.getColumnDimension();\n        final double[] out = new double[ncols];\n        System.arraycopy(data[row], 0, out, 0, ncols);\n        return out;\n    }\n\n    \n    public double[] getColumn(int col) throws MatrixIndexException {\n        if ( !isValidCoordinate(0, col) ) {\n            throw new MatrixIndexException(\"illegal column argument\");\n        }\n        final int nRows = this.getRowDimension();\n        final double[] out = new double[nRows];\n        for (int row = 0; row < nRows; row++) {\n            out[row] = data[row][col];\n        }\n        return out;\n    }\n\n    \n    public double getEntry(int row, int column) throws MatrixIndexException {\n        try {\n            return data[row][column];\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new MatrixIndexException(\"matrix entry does not exist\");\n        }\n    }\n\n    \n    public RealMatrix transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final double[][] outData = new double[nCols][nRows];\n        for (int row = 0; row < nRows; row++) {\n            final double[] dataRow = data[row];\n            for (int col = 0; col < nCols; col++) {\n                outData[col][row] = dataRow[col];\n            }\n        }\n        return new RealMatrixImpl(outData, false);\n    }\n\n    \n    public RealMatrix inverse() throws InvalidMatrixException {\n        return solve(MatrixUtils.createRealIdentityMatrix(getRowDimension()));\n    }\n\n    \n    public double getDeterminant() throws InvalidMatrixException {\n        if (!isSquare()) {\n            throw new InvalidMatrixException(\"matrix is not square\");\n        }\n        if (isSingular()) {   \n            return 0d;\n        } else {\n            double det = parity;\n            for (int i = 0; i < this.getRowDimension(); i++) {\n                det *= lu[i][i];\n            }\n            return det;\n        }\n    }\n\n    \n    public boolean isSquare() {\n        return (this.getColumnDimension() == this.getRowDimension());\n    }\n\n    \n    public boolean isSingular() {\n        if (lu == null) {\n            try {\n                luDecompose();\n                return false;\n            } catch (InvalidMatrixException ex) {\n                return true;\n            }\n        } else { \n            return false; \n        }\n    }\n\n    \n    public int getRowDimension() {\n        return data.length;\n    }\n\n    \n    public int getColumnDimension() {\n        return data[0].length;\n    }\n\n    \n    public double getTrace() throws IllegalArgumentException {\n        if (!isSquare()) {\n            throw new IllegalArgumentException(\"matrix is not square\");\n        }\n        double trace = data[0][0];\n        for (int i = 1; i < this.getRowDimension(); i++) {\n            trace += data[i][i];\n        }\n        return trace;\n    }\n\n    \n    public double[] operate(double[] v) throws IllegalArgumentException {\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        if (v.length != nCols) {\n            throw new IllegalArgumentException(\"vector has wrong length\");\n        }\n        final double[] out = new double[v.length];\n        for (int row = 0; row < nRows; row++) {\n            final double[] dataRow = data[row];\n            double sum = 0;\n            for (int i = 0; i < nCols; i++) {\n                sum += dataRow[i] * v[i];\n            }\n            out[row] = sum;\n        }\n        return out;\n    }\n\n    \n    public double[] preMultiply(double[] v) throws IllegalArgumentException {\n        final int nRows = this.getRowDimension();\n        if (v.length != nRows) {\n            throw new IllegalArgumentException(\"vector has wrong length\");\n        }\n        final int nCols = this.getColumnDimension();\n        final double[] out = new double[nCols];\n        for (int col = 0; col < nCols; col++) {\n            double sum = 0;\n            for (int i = 0; i < nRows; i++) {\n                sum += data[i][col] * v[i];\n            }\n            out[col] = sum;\n        }\n        return out;\n    }\n\n    \n    public double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {\n        final int nRows = this.getRowDimension();\n        if (b.length != nRows) {\n            throw new IllegalArgumentException(\"constant vector has wrong length\");\n        }\n        final RealMatrix bMatrix = new RealMatrixImpl(b);\n        final double[][] solution = ((RealMatrixImpl) (solve(bMatrix))).getDataRef();\n        final double[] out = new double[nRows];\n        for (int row = 0; row < nRows; row++) {\n            out[row] = solution[row][0];\n        }\n        return out;\n    }\n\n    \n    public RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException {\n        if (b.getRowDimension() != this.getRowDimension()) {\n            throw new IllegalArgumentException(\"Incorrect row dimension\");\n        }\n        if (!this.isSquare()) {\n            throw new InvalidMatrixException(\"coefficient matrix is not square\");\n        }\n        if (this.isSingular()) { \n            throw new InvalidMatrixException(\"Matrix is singular.\");\n        }\n\n        final int nCol  = this.getColumnDimension();\n        final int nColB = b.getColumnDimension();\n        final int nRowB = b.getRowDimension();\n\n        \n        final double[][] bp = new double[nRowB][nColB];\n        for (int row = 0; row < nRowB; row++) {\n            final double[] bpRow = bp[row];\n            for (int col = 0; col < nColB; col++) {\n                bpRow[col] = b.getEntry(permutation[row], col);\n            }\n        }\n\n        \n        for (int col = 0; col < nCol; col++) {\n            for (int i = col + 1; i < nCol; i++) {\n                final double[] bpI = bp[i];\n                final double[] luI = lu[i];\n                for (int j = 0; j < nColB; j++) {\n                    bpI[j] -= bp[col][j] * luI[col];\n                }\n            }\n        }\n\n        \n        for (int col = nCol - 1; col >= 0; col--) {\n            final double[] bpCol = bp[col];\n            final double luDiag = lu[col][col];\n            for (int j = 0; j < nColB; j++) {\n                bpCol[j] /= luDiag;\n            }\n            for (int i = 0; i < col; i++) {\n                final double[] bpI = bp[i];\n                final double[] luI = lu[i];\n                for (int j = 0; j < nColB; j++) {\n                    bpI[j] -= bp[col][j] * luI[col];\n                }\n            }\n        }\n\n        return new RealMatrixImpl(bp, false);\n\n    }\n\n    \n    public void luDecompose() throws InvalidMatrixException {\n\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        if (nRows != nCols) {\n            throw new InvalidMatrixException(\"LU decomposition requires that the matrix be square.\");\n        }\n        lu = getData();\n\n        \n        permutation = new int[nRows];\n        for (int row = 0; row < nRows; row++) {\n            permutation[row] = row;\n        }\n        parity = 1;\n\n        \n        for (int col = 0; col < nCols; col++) {\n\n            double sum = 0;\n\n            \n            for (int row = 0; row < col; row++) {\n                final double[] luRow = lu[row];\n                sum = luRow[col];\n                for (int i = 0; i < row; i++) {\n                    sum -= luRow[i] * lu[i][col];\n                }\n                luRow[col] = sum;\n            }\n\n            \n            int max = col; \n            double largest = 0d;\n            for (int row = col; row < nRows; row++) {\n                final double[] luRow = lu[row];\n                sum = luRow[col];\n                for (int i = 0; i < col; i++) {\n                    sum -= luRow[i] * lu[i][col];\n                }\n                luRow[col] = sum;\n\n                \n                if (Math.abs(sum) > largest) {\n                    largest = Math.abs(sum);\n                    max = row;\n                }\n            }\n\n            \n            if (Math.abs(lu[max][col]) < TOO_SMALL) {\n                lu = null;\n                throw new InvalidMatrixException(\"matrix is singular\");\n            }\n\n            \n            if (max != col) {\n                double tmp = 0;\n                for (int i = 0; i < nCols; i++) {\n                    tmp = lu[max][i];\n                    lu[max][i] = lu[col][i];\n                    lu[col][i] = tmp;\n                }\n                int temp = permutation[max];\n                permutation[max] = permutation[col];\n                permutation[col] = temp;\n                parity = -parity;\n            }\n\n            \n            final double luDiag = lu[col][col];\n            for (int row = col + 1; row < nRows; row++) {\n                lu[row][col] /= luDiag;\n            }\n        }\n    }\n\n    \n    public String toString() {\n        StringBuffer res = new StringBuffer();\n        res.append(\"RealMatrixImpl{\");\n        if (data != null) {\n            for (int i = 0; i < data.length; i++) {\n                if (i > 0) {\n                    res.append(\",\");\n                }\n                res.append(\"{\");\n                for (int j = 0; j < data[0].length; j++) {\n                    if (j > 0) {\n                        res.append(\",\");\n                    }\n                    res.append(data[i][j]);\n                } \n                res.append(\"}\");\n            } \n        }\n        res.append(\"}\");\n        return res.toString();\n    } \n    \n    \n    public boolean equals(Object object) {\n        if (object == this ) {\n            return true;\n        }\n        if (object instanceof RealMatrixImpl == false) {\n            return false;\n        }\n        RealMatrix m = (RealMatrix) object;\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {\n            return false;\n        }\n        for (int row = 0; row < nRows; row++) {\n            final double[] dataRow = data[row];\n            for (int col = 0; col < nCols; col++) {\n                if (Double.doubleToLongBits(dataRow[col]) != \n                    Double.doubleToLongBits(m.getEntry(row, col))) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    \n    public int hashCode() {\n        int ret = 7;\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        ret = ret * 31 + nRows;\n        ret = ret * 31 + nCols;\n        for (int row = 0; row < nRows; row++) {\n            final double[] dataRow = data[row];\n            for (int col = 0; col < nCols; col++) {\n               ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * \n                   MathUtils.hash(dataRow[col]);\n           }\n        }\n        return ret;\n    }\n\n    \n\n    \n    protected RealMatrix getLUMatrix() throws InvalidMatrixException {\n        if (lu == null) {\n            luDecompose();\n        }\n        return new RealMatrixImpl(lu);\n    }\n\n    \n    protected int[] getPermutation() {\n        final int[] out = new int[permutation.length];\n        System.arraycopy(permutation, 0, out, 0, permutation.length);\n        return out;\n    }\n\n    \n\n    \n    private double[][] copyOut() {\n        final int nRows = this.getRowDimension();\n        final double[][] out = new double[nRows][this.getColumnDimension()];\n        \n        for (int i = 0; i < nRows; i++) {\n            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n        }\n        return out;\n    }\n\n    \n    private void copyIn(double[][] in) {\n        setSubMatrix(in,0,0);\n    }\n\n    \n    private boolean isValidCoordinate(int row, int col) {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        return !(row < 0 || row > nRows - 1 || col < 0 || col > nCols -1);\n    }\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.linear;\n\nimport java.io.Serializable;\nimport org.apache.commons.math.util.MathUtils;\n\n\n\npublic class RealMatrixImpl implements RealMatrix, Serializable { private static final long serialVersionUID = -4828886979278117018L; protected double data[][] = null; protected double lu[][] = null; protected int[] permutation = null; protected int parity = 1; private static final double TOO_SMALL = 10E-12; public RealMatrixImpl() {\n    }\n\n    \n    public RealMatrixImpl(int rowDimension, int columnDimension) {\n        if (rowDimension <= 0 || columnDimension <= 0) {\n            throw new IllegalArgumentException(\n                    \"row and column dimensions must be postive\");\n        }\n        data = new double[rowDimension][columnDimension];\n        lu = null;\n    }\n\n    \n    public RealMatrixImpl(double[][] d) {\n        copyIn(d);\n        lu = null;\n    }\n\n    \n    public RealMatrixImpl(double[][] d, boolean copyArray) {\n        if (copyArray) {\n            copyIn(d);\n        } else {\n            if (d == null) {\n                throw new NullPointerException();\n            }   \n            final int nRows = d.length;\n            if (nRows == 0) {\n                throw new IllegalArgumentException(\"Matrix must have at least one row.\"); \n            }\n            final int nCols = d[0].length;\n            if (nCols == 0) {\n                throw new IllegalArgumentException(\"Matrix must have at least one column.\"); \n            }\n            for (int r = 1; r < nRows; r++) {\n                if (d[r].length != nCols) {\n                    throw new IllegalArgumentException(\"All input rows must have the same length.\");\n                }\n            }       \n            data = d;\n        }\n        lu = null;\n    }\n\n    \n    public RealMatrixImpl(double[] v) {\n        final int nRows = v.length;\n        data = new double[nRows][1];\n        for (int row = 0; row < nRows; row++) {\n            data[row][0] = v[row];\n        }\n    }\n\n    \n    public RealMatrix copy() {\n        return new RealMatrixImpl(copyOut(), false);\n    }\n\n    \n    public RealMatrix add(RealMatrix m) throws IllegalArgumentException {\n        try {\n            return add((RealMatrixImpl) m);\n        } catch (ClassCastException cce) {\n            final int rowCount    = getRowDimension();\n            final int columnCount = getColumnDimension();\n            if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n                throw new IllegalArgumentException(\"matrix dimension mismatch\");\n            }\n            final double[][] outData = new double[rowCount][columnCount];\n            for (int row = 0; row < rowCount; row++) {\n                final double[] dataRow    = data[row];\n                final double[] outDataRow = outData[row];\n                for (int col = 0; col < columnCount; col++) {\n                    outDataRow[col] = dataRow[col] + m.getEntry(row, col);\n                }  \n            }\n            return new RealMatrixImpl(outData, false);\n        }\n    }\n\n    \n    public RealMatrixImpl add(RealMatrixImpl m) throws IllegalArgumentException {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n            throw new IllegalArgumentException(\"matrix dimension mismatch\");\n        }\n        final double[][] outData = new double[rowCount][columnCount];\n        for (int row = 0; row < rowCount; row++) {\n            final double[] dataRow    = data[row];\n            final double[] mRow       = m.data[row];\n            final double[] outDataRow = outData[row];\n            for (int col = 0; col < columnCount; col++) {\n                outDataRow[col] = dataRow[col] + mRow[col];\n            }  \n        }\n        return new RealMatrixImpl(outData, false);\n    }\n\n    \n    public RealMatrix subtract(RealMatrix m) throws IllegalArgumentException {\n        try {\n            return subtract((RealMatrixImpl) m);\n        } catch (ClassCastException cce) {\n            final int rowCount    = getRowDimension();\n            final int columnCount = getColumnDimension();\n            if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n                throw new IllegalArgumentException(\"matrix dimension mismatch\");\n            }\n            final double[][] outData = new double[rowCount][columnCount];\n            for (int row = 0; row < rowCount; row++) {\n                final double[] dataRow    = data[row];\n                final double[] outDataRow = outData[row];\n                for (int col = 0; col < columnCount; col++) {\n                    outDataRow[col] = dataRow[col] - m.getEntry(row, col);\n                }  \n            }\n            return new RealMatrixImpl(outData, false);\n        }\n    }\n\n    \n    public RealMatrixImpl subtract(RealMatrixImpl m) throws IllegalArgumentException {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n            throw new IllegalArgumentException(\"matrix dimension mismatch\");\n        }\n        final double[][] outData = new double[rowCount][columnCount];\n        for (int row = 0; row < rowCount; row++) {\n            final double[] dataRow    = data[row];\n            final double[] mRow       = m.data[row];\n            final double[] outDataRow = outData[row];\n            for (int col = 0; col < columnCount; col++) {\n                outDataRow[col] = dataRow[col] - mRow[col];\n            }  \n        }\n        return new RealMatrixImpl(outData, false);\n    }\n\n    \n    public RealMatrix scalarAdd(double d) {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        final double[][] outData = new double[rowCount][columnCount];\n        for (int row = 0; row < rowCount; row++) {\n            final double[] dataRow    = data[row];\n            final double[] outDataRow = outData[row];\n            for (int col = 0; col < columnCount; col++) {\n                outDataRow[col] = dataRow[col] + d;\n            }\n        }\n        return new RealMatrixImpl(outData, false);\n    }\n\n    \n    public RealMatrix scalarMultiply(double d) {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        final double[][] outData = new double[rowCount][columnCount];\n        for (int row = 0; row < rowCount; row++) {\n            final double[] dataRow    = data[row];\n            final double[] outDataRow = outData[row];\n            for (int col = 0; col < columnCount; col++) {\n                outDataRow[col] = dataRow[col] * d;\n            }\n        }\n        return new RealMatrixImpl(outData, false);\n    }\n\n    \n    public RealMatrix multiply(RealMatrix m) throws IllegalArgumentException {\n        try {\n            return multiply((RealMatrixImpl) m);\n        } catch (ClassCastException cce) {\n            if (this.getColumnDimension() != m.getRowDimension()) {\n                throw new IllegalArgumentException(\"Matrices are not multiplication compatible.\");\n            }\n            final int nRows = this.getRowDimension();\n            final int nCols = m.getColumnDimension();\n            final int nSum = this.getColumnDimension();\n            final double[][] outData = new double[nRows][nCols];\n            for (int row = 0; row < nRows; row++) {\n                final double[] dataRow    = data[row];\n                final double[] outDataRow = outData[row];\n                for (int col = 0; col < nCols; col++) {\n                    double sum = 0;\n                    for (int i = 0; i < nSum; i++) {\n                        sum += dataRow[i] * m.getEntry(i, col);\n                    }\n                    outDataRow[col] = sum;\n                }\n            }\n            return new RealMatrixImpl(outData, false);\n        }\n    }\n\n    \n    public RealMatrixImpl multiply(RealMatrixImpl m) throws IllegalArgumentException {\n        if (this.getColumnDimension() != m.getRowDimension()) {\n            throw new IllegalArgumentException(\"Matrices are not multiplication compatible.\");\n        }\n        final int nRows = this.getRowDimension();\n        final int nCols = m.getColumnDimension();\n        final int nSum = this.getColumnDimension();\n        final double[][] outData = new double[nRows][nCols];\n        for (int row = 0; row < nRows; row++) {\n            final double[] dataRow    = data[row];\n            final double[] outDataRow = outData[row];\n            for (int col = 0; col < nCols; col++) {\n                double sum = 0;\n                for (int i = 0; i < nSum; i++) {\n                    sum += dataRow[i] * m.data[i][col];\n                }\n                outDataRow[col] = sum;\n            }\n        }            \n        return new RealMatrixImpl(outData, false);\n    }\n\n    \n    public RealMatrix preMultiply(RealMatrix m) throws IllegalArgumentException {\n        return m.multiply(this);\n    }\n\n    \n    public double[][] getData() {\n        return copyOut();\n    }\n\n    \n    public double[][] getDataRef() {\n        return data;\n    }\n\n    \n    public double getNorm() {\n        double maxColSum = 0;\n        for (int col = 0; col < this.getColumnDimension(); col++) {\n            double sum = 0;\n            for (int row = 0; row < this.getRowDimension(); row++) {\n                sum += Math.abs(data[row][col]);\n            }\n            maxColSum = Math.max(maxColSum, sum);\n        }\n        return maxColSum;\n    }\n    \n    \n    public RealMatrix getSubMatrix(int startRow, int endRow, int startColumn, int endColumn) throws MatrixIndexException {\n        if (startRow < 0 || startRow > endRow || endRow > data.length ||\n             startColumn < 0 || startColumn > endColumn ||\n             endColumn > data[0].length) {\n            throw new MatrixIndexException(\n                    \"invalid row or column index selection\");\n        }\n        final double[][] subMatrixData =\n            new double[endRow - startRow + 1][endColumn - startColumn + 1];\n        for (int i = startRow; i <= endRow; i++) {\n            System.arraycopy(data[i], startColumn,\n                             subMatrixData[i - startRow], 0,\n                             endColumn - startColumn + 1);\n        }\n        return new RealMatrixImpl(subMatrixData, false);\n    }\n    \n    \n    public RealMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns) throws MatrixIndexException {\n        if (selectedRows.length * selectedColumns.length == 0) {\n            throw new MatrixIndexException(\n                    \"selected row and column index arrays must be non-empty\");\n        }\n        final double[][] subMatrixData =\n            new double[selectedRows.length][selectedColumns.length];\n        try  {\n            for (int i = 0; i < selectedRows.length; i++) {\n                final double[] subI = subMatrixData[i];\n                final double[] dataSelectedI = data[selectedRows[i]];\n                for (int j = 0; j < selectedColumns.length; j++) {\n                    subI[j] = dataSelectedI[selectedColumns[j]];\n                }\n            }\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new MatrixIndexException(\"matrix dimension mismatch\");\n        }\n        return new RealMatrixImpl(subMatrixData, false);\n    } \n\n    \n    public void setSubMatrix(double[][] subMatrix, int row, int column) throws MatrixIndexException {\n        if ((row < 0) || (column < 0)){\n            throw new MatrixIndexException\n                (\"invalid row or column index selection\");          \n        }\n        final int nRows = subMatrix.length;\n        if (nRows == 0) {\n            throw new IllegalArgumentException(\n            \"Matrix must have at least one row.\"); \n        }\n        final int nCols = subMatrix[0].length;\n        if (nCols == 0) {\n            throw new IllegalArgumentException(\n            \"Matrix must have at least one column.\"); \n        }\n        for (int r = 1; r < nRows; r++) {\n            if (subMatrix[r].length != nCols) {\n                throw new IllegalArgumentException(\n                \"All input rows must have the same length.\");\n            }\n        }       \n        if (data == null) {\n            if ((row > 0)||(column > 0)) throw new MatrixIndexException\n                (\"matrix must be initialized to perfom this method\");\n            data = new double[nRows][nCols];\n            System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);          \n        }   \n        if (((nRows + row) > this.getRowDimension()) ||\n            (nCols + column > this.getColumnDimension()))\n            throw new MatrixIndexException(\n                    \"invalid row or column index selection\");                   \n        for (int i = 0; i < nRows; i++) {\n            System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);\n        } \n        lu = null;\n    }\n    \n    \n    public RealMatrix getRowMatrix(int row) throws MatrixIndexException {\n        if ( !isValidCoordinate( row, 0)) {\n            throw new MatrixIndexException(\"illegal row argument\");\n        }\n        final int ncols = this.getColumnDimension();\n        final double[][] out = new double[1][ncols]; \n        System.arraycopy(data[row], 0, out[0], 0, ncols);\n        return new RealMatrixImpl(out, false);\n    }\n    \n    \n    public RealMatrix getColumnMatrix(int column) throws MatrixIndexException {\n        if ( !isValidCoordinate( 0, column)) {\n            throw new MatrixIndexException(\"illegal column argument\");\n        }\n        final int nRows = this.getRowDimension();\n        final double[][] out = new double[nRows][1]; \n        for (int row = 0; row < nRows; row++) {\n            out[row][0] = data[row][column];\n        }\n        return new RealMatrixImpl(out, false);\n    }\n\n     \n    public double[] getRow(int row) throws MatrixIndexException {\n        if ( !isValidCoordinate( row, 0 ) ) {\n            throw new MatrixIndexException(\"illegal row argument\");\n        }\n        final int ncols = this.getColumnDimension();\n        final double[] out = new double[ncols];\n        System.arraycopy(data[row], 0, out, 0, ncols);\n        return out;\n    }\n\n    \n    public double[] getColumn(int col) throws MatrixIndexException {\n        if ( !isValidCoordinate(0, col) ) {\n            throw new MatrixIndexException(\"illegal column argument\");\n        }\n        final int nRows = this.getRowDimension();\n        final double[] out = new double[nRows];\n        for (int row = 0; row < nRows; row++) {\n            out[row] = data[row][col];\n        }\n        return out;\n    }\n\n    \n    public double getEntry(int row, int column) throws MatrixIndexException {\n        try {\n            return data[row][column];\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new MatrixIndexException(\"matrix entry does not exist\");\n        }\n    }\n\n    \n    public RealMatrix transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final double[][] outData = new double[nCols][nRows];\n        for (int row = 0; row < nRows; row++) {\n            final double[] dataRow = data[row];\n            for (int col = 0; col < nCols; col++) {\n                outData[col][row] = dataRow[col];\n            }\n        }\n        return new RealMatrixImpl(outData, false);\n    }\n\n    \n    public RealMatrix inverse() throws InvalidMatrixException {\n        return solve(MatrixUtils.createRealIdentityMatrix(getRowDimension()));\n    }\n\n    \n    public double getDeterminant() throws InvalidMatrixException {\n        if (!isSquare()) {\n            throw new InvalidMatrixException(\"matrix is not square\");\n        }\n        if (isSingular()) {   \n            return 0d;\n        } else {\n            double det = parity;\n            for (int i = 0; i < this.getRowDimension(); i++) {\n                det *= lu[i][i];\n            }\n            return det;\n        }\n    }\n\n    \n    public boolean isSquare() {\n        return (this.getColumnDimension() == this.getRowDimension());\n    }\n\n    \n    public boolean isSingular() {\n        if (lu == null) {\n            try {\n                luDecompose();\n                return false;\n            } catch (InvalidMatrixException ex) {\n                return true;\n            }\n        } else { \n            return false; \n        }\n    }\n\n    \n    public int getRowDimension() {\n        return data.length;\n    }\n\n    \n    public int getColumnDimension() {\n        return data[0].length;\n    }\n\n    \n    public double getTrace() throws IllegalArgumentException {\n        if (!isSquare()) {\n            throw new IllegalArgumentException(\"matrix is not square\");\n        }\n        double trace = data[0][0];\n        for (int i = 1; i < this.getRowDimension(); i++) {\n            trace += data[i][i];\n        }\n        return trace;\n    }\n\n    \n    public double[] operate(double[] v) throws IllegalArgumentException {\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        if (v.length != nCols) {\n            throw new IllegalArgumentException(\"vector has wrong length\");\n        }\n        final double[] out = new double[nRows];\n        for (int row = 0; row < nRows; row++) {\n            final double[] dataRow = data[row];\n            double sum = 0;\n            for (int i = 0; i < nCols; i++) {\n                sum += dataRow[i] * v[i];\n            }\n            out[row] = sum;\n        }\n        return out;\n    }\n\n    \n    public double[] preMultiply(double[] v) throws IllegalArgumentException {\n        final int nRows = this.getRowDimension();\n        if (v.length != nRows) {\n            throw new IllegalArgumentException(\"vector has wrong length\");\n        }\n        final int nCols = this.getColumnDimension();\n        final double[] out = new double[nCols];\n        for (int col = 0; col < nCols; col++) {\n            double sum = 0;\n            for (int i = 0; i < nRows; i++) {\n                sum += data[i][col] * v[i];\n            }\n            out[col] = sum;\n        }\n        return out;\n    }\n\n    \n    public double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {\n        final int nRows = this.getRowDimension();\n        if (b.length != nRows) {\n            throw new IllegalArgumentException(\"constant vector has wrong length\");\n        }\n        final RealMatrix bMatrix = new RealMatrixImpl(b);\n        final double[][] solution = ((RealMatrixImpl) (solve(bMatrix))).getDataRef();\n        final double[] out = new double[nRows];\n        for (int row = 0; row < nRows; row++) {\n            out[row] = solution[row][0];\n        }\n        return out;\n    }\n\n    \n    public RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException {\n        if (b.getRowDimension() != this.getRowDimension()) {\n            throw new IllegalArgumentException(\"Incorrect row dimension\");\n        }\n        if (!this.isSquare()) {\n            throw new InvalidMatrixException(\"coefficient matrix is not square\");\n        }\n        if (this.isSingular()) { \n            throw new InvalidMatrixException(\"Matrix is singular.\");\n        }\n\n        final int nCol  = this.getColumnDimension();\n        final int nColB = b.getColumnDimension();\n        final int nRowB = b.getRowDimension();\n\n        \n        final double[][] bp = new double[nRowB][nColB];\n        for (int row = 0; row < nRowB; row++) {\n            final double[] bpRow = bp[row];\n            for (int col = 0; col < nColB; col++) {\n                bpRow[col] = b.getEntry(permutation[row], col);\n            }\n        }\n\n        \n        for (int col = 0; col < nCol; col++) {\n            for (int i = col + 1; i < nCol; i++) {\n                final double[] bpI = bp[i];\n                final double[] luI = lu[i];\n                for (int j = 0; j < nColB; j++) {\n                    bpI[j] -= bp[col][j] * luI[col];\n                }\n            }\n        }\n\n        \n        for (int col = nCol - 1; col >= 0; col--) {\n            final double[] bpCol = bp[col];\n            final double luDiag = lu[col][col];\n            for (int j = 0; j < nColB; j++) {\n                bpCol[j] /= luDiag;\n            }\n            for (int i = 0; i < col; i++) {\n                final double[] bpI = bp[i];\n                final double[] luI = lu[i];\n                for (int j = 0; j < nColB; j++) {\n                    bpI[j] -= bp[col][j] * luI[col];\n                }\n            }\n        }\n\n        return new RealMatrixImpl(bp, false);\n\n    }\n\n    \n    public void luDecompose() throws InvalidMatrixException {\n\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        if (nRows != nCols) {\n            throw new InvalidMatrixException(\"LU decomposition requires that the matrix be square.\");\n        }\n        lu = getData();\n\n        \n        permutation = new int[nRows];\n        for (int row = 0; row < nRows; row++) {\n            permutation[row] = row;\n        }\n        parity = 1;\n\n        \n        for (int col = 0; col < nCols; col++) {\n\n            double sum = 0;\n\n            \n            for (int row = 0; row < col; row++) {\n                final double[] luRow = lu[row];\n                sum = luRow[col];\n                for (int i = 0; i < row; i++) {\n                    sum -= luRow[i] * lu[i][col];\n                }\n                luRow[col] = sum;\n            }\n\n            \n            int max = col; \n            double largest = 0d;\n            for (int row = col; row < nRows; row++) {\n                final double[] luRow = lu[row];\n                sum = luRow[col];\n                for (int i = 0; i < col; i++) {\n                    sum -= luRow[i] * lu[i][col];\n                }\n                luRow[col] = sum;\n\n                \n                if (Math.abs(sum) > largest) {\n                    largest = Math.abs(sum);\n                    max = row;\n                }\n            }\n\n            \n            if (Math.abs(lu[max][col]) < TOO_SMALL) {\n                lu = null;\n                throw new InvalidMatrixException(\"matrix is singular\");\n            }\n\n            \n            if (max != col) {\n                double tmp = 0;\n                for (int i = 0; i < nCols; i++) {\n                    tmp = lu[max][i];\n                    lu[max][i] = lu[col][i];\n                    lu[col][i] = tmp;\n                }\n                int temp = permutation[max];\n                permutation[max] = permutation[col];\n                permutation[col] = temp;\n                parity = -parity;\n            }\n\n            \n            final double luDiag = lu[col][col];\n            for (int row = col + 1; row < nRows; row++) {\n                lu[row][col] /= luDiag;\n            }\n        }\n    }\n\n    \n    public String toString() {\n        StringBuffer res = new StringBuffer();\n        res.append(\"RealMatrixImpl{\");\n        if (data != null) {\n            for (int i = 0; i < data.length; i++) {\n                if (i > 0) {\n                    res.append(\",\");\n                }\n                res.append(\"{\");\n                for (int j = 0; j < data[0].length; j++) {\n                    if (j > 0) {\n                        res.append(\",\");\n                    }\n                    res.append(data[i][j]);\n                } \n                res.append(\"}\");\n            } \n        }\n        res.append(\"}\");\n        return res.toString();\n    } \n    \n    \n    public boolean equals(Object object) {\n        if (object == this ) {\n            return true;\n        }\n        if (object instanceof RealMatrixImpl == false) {\n            return false;\n        }\n        RealMatrix m = (RealMatrix) object;\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {\n            return false;\n        }\n        for (int row = 0; row < nRows; row++) {\n            final double[] dataRow = data[row];\n            for (int col = 0; col < nCols; col++) {\n                if (Double.doubleToLongBits(dataRow[col]) != \n                    Double.doubleToLongBits(m.getEntry(row, col))) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    \n    public int hashCode() {\n        int ret = 7;\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        ret = ret * 31 + nRows;\n        ret = ret * 31 + nCols;\n        for (int row = 0; row < nRows; row++) {\n            final double[] dataRow = data[row];\n            for (int col = 0; col < nCols; col++) {\n               ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * \n                   MathUtils.hash(dataRow[col]);\n           }\n        }\n        return ret;\n    }\n\n    \n\n    \n    protected RealMatrix getLUMatrix() throws InvalidMatrixException {\n        if (lu == null) {\n            luDecompose();\n        }\n        return new RealMatrixImpl(lu);\n    }\n\n    \n    protected int[] getPermutation() {\n        final int[] out = new int[permutation.length];\n        System.arraycopy(permutation, 0, out, 0, permutation.length);\n        return out;\n    }\n\n    \n\n    \n    private double[][] copyOut() {\n        final int nRows = this.getRowDimension();\n        final double[][] out = new double[nRows][this.getColumnDimension()];\n        \n        for (int i = 0; i < nRows; i++) {\n            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n        }\n        return out;\n    }\n\n    \n    private void copyIn(double[][] in) {\n        setSubMatrix(in,0,0);\n    }\n\n    \n    private boolean isValidCoordinate(int row, int col) {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        return !(row < 0 || row > nRows - 1 || col < 0 || col > nCols -1);\n    }\n\n}\n",
      "buggy_signatures": [
        "public RealMatrixImpl(int rowDimension, int columnDimension)",
        "public RealMatrixImpl(double[][] d)",
        "public RealMatrixImpl(double[][] d, boolean copyArray)",
        "public RealMatrixImpl(double[] v)",
        "public RealMatrix copy()",
        "public RealMatrix add(RealMatrix m) throws IllegalArgumentException",
        "public RealMatrixImpl add(RealMatrixImpl m) throws IllegalArgumentException",
        "public RealMatrix subtract(RealMatrix m) throws IllegalArgumentException",
        "public RealMatrixImpl subtract(RealMatrixImpl m) throws IllegalArgumentException",
        "public RealMatrix scalarAdd(double d)",
        "public RealMatrix scalarMultiply(double d)",
        "public RealMatrix multiply(RealMatrix m) throws IllegalArgumentException",
        "public RealMatrixImpl multiply(RealMatrixImpl m) throws IllegalArgumentException",
        "public RealMatrix preMultiply(RealMatrix m) throws IllegalArgumentException",
        "public double[][] getData()",
        "public double[][] getDataRef()",
        "public double getNorm()",
        "public RealMatrix getSubMatrix(int startRow, int endRow, int startColumn, int endColumn) throws MatrixIndexException",
        "public RealMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns) throws MatrixIndexException",
        "public void setSubMatrix(double[][] subMatrix, int row, int column) throws MatrixIndexException",
        "public RealMatrix getRowMatrix(int row) throws MatrixIndexException",
        "public RealMatrix getColumnMatrix(int column) throws MatrixIndexException",
        "public double[] getRow(int row) throws MatrixIndexException",
        "public double[] getColumn(int col) throws MatrixIndexException",
        "public double getEntry(int row, int column) throws MatrixIndexException",
        "public RealMatrix transpose()",
        "public RealMatrix inverse() throws InvalidMatrixException",
        "public double getDeterminant() throws InvalidMatrixException",
        "public boolean isSquare()",
        "public boolean isSingular()",
        "public int getRowDimension()",
        "public int getColumnDimension()",
        "public double getTrace() throws IllegalArgumentException",
        "public double[] operate(double[] v) throws IllegalArgumentException",
        "public double[] preMultiply(double[] v) throws IllegalArgumentException",
        "public double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException",
        "public RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException",
        "public void luDecompose() throws InvalidMatrixException",
        "public String toString()",
        "public boolean equals(Object object)",
        "public int hashCode()",
        "protected RealMatrix getLUMatrix() throws InvalidMatrixException",
        "protected int[] getPermutation()",
        "private double[][] copyOut()",
        "private void copyIn(double[][] in)",
        "private boolean isValidCoordinate(int row, int col)"
      ],
      "fixed_signatures": [
        "public RealMatrixImpl(int rowDimension, int columnDimension)",
        "public RealMatrixImpl(double[][] d)",
        "public RealMatrixImpl(double[][] d, boolean copyArray)",
        "public RealMatrixImpl(double[] v)",
        "public RealMatrix copy()",
        "public RealMatrix add(RealMatrix m) throws IllegalArgumentException",
        "public RealMatrixImpl add(RealMatrixImpl m) throws IllegalArgumentException",
        "public RealMatrix subtract(RealMatrix m) throws IllegalArgumentException",
        "public RealMatrixImpl subtract(RealMatrixImpl m) throws IllegalArgumentException",
        "public RealMatrix scalarAdd(double d)",
        "public RealMatrix scalarMultiply(double d)",
        "public RealMatrix multiply(RealMatrix m) throws IllegalArgumentException",
        "public RealMatrixImpl multiply(RealMatrixImpl m) throws IllegalArgumentException",
        "public RealMatrix preMultiply(RealMatrix m) throws IllegalArgumentException",
        "public double[][] getData()",
        "public double[][] getDataRef()",
        "public double getNorm()",
        "public RealMatrix getSubMatrix(int startRow, int endRow, int startColumn, int endColumn) throws MatrixIndexException",
        "public RealMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns) throws MatrixIndexException",
        "public void setSubMatrix(double[][] subMatrix, int row, int column) throws MatrixIndexException",
        "public RealMatrix getRowMatrix(int row) throws MatrixIndexException",
        "public RealMatrix getColumnMatrix(int column) throws MatrixIndexException",
        "public double[] getRow(int row) throws MatrixIndexException",
        "public double[] getColumn(int col) throws MatrixIndexException",
        "public double getEntry(int row, int column) throws MatrixIndexException",
        "public RealMatrix transpose()",
        "public RealMatrix inverse() throws InvalidMatrixException",
        "public double getDeterminant() throws InvalidMatrixException",
        "public boolean isSquare()",
        "public boolean isSingular()",
        "public int getRowDimension()",
        "public int getColumnDimension()",
        "public double getTrace() throws IllegalArgumentException",
        "public double[] operate(double[] v) throws IllegalArgumentException",
        "public double[] preMultiply(double[] v) throws IllegalArgumentException",
        "public double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException",
        "public RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException",
        "public void luDecompose() throws InvalidMatrixException",
        "public String toString()",
        "public boolean equals(Object object)",
        "public int hashCode()",
        "protected RealMatrix getLUMatrix() throws InvalidMatrixException",
        "protected int[] getPermutation()",
        "private double[][] copyOut()",
        "private void copyIn(double[][] in)",
        "private boolean isValidCoordinate(int row, int col)"
      ],
      "methods": [
        {
          "buggy_method": "  public double[] operate(double[] v) throws IllegalArgumentException {\n  final int nRows = this.getRowDimension();\n  final int nCols = this.getColumnDimension();\n  if (v.length != nCols) {\n  throw new IllegalArgumentException(\"vector has wrong length\");\n  }\n  final double[] out = new double[v.length];\n  for (int row = 0; row < nRows; row++) {\n  final double[] dataRow = data[row];\n  double sum = 0;\n  for (int i = 0; i < nCols; i++) {\n  sum += dataRow[i] * v[i];\n  }\n  out[row] = sum;\n  }\n  return out;\n  }",
          "fixed_method": "  public double[] operate(double[] v) throws IllegalArgumentException {\n  final int nRows = this.getRowDimension();\n  final int nCols = this.getColumnDimension();\n  if (v.length != nCols) {\n  throw new IllegalArgumentException(\"vector has wrong length\");\n  }\n  final double[] out = new double[nRows];\n  for (int row = 0; row < nRows; row++) {\n  final double[] dataRow = data[row];\n  double sum = 0;\n  for (int i = 0; i < nCols; i++) {\n  sum += dataRow[i] * v[i];\n  }\n  out[row] = sum;\n  }\n  return out;\n  }",
          "diff": [
            "@@ -776,7 +776,7 @@",
            "         if (v.length != nCols) {\n",
            "             throw new IllegalArgumentException(\"vector has wrong length\");\n",
            "         }\n",
            "-        final double[] out = new double[v.length];\n",
            "+        final double[] out = new double[nRows];\n",
            "         for (int row = 0; row < nRows; row++) {\n",
            "             final double[] dataRow = data[row];\n",
            "             double sum = 0;\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
