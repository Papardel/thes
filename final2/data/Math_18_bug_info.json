{
  "bug_id": "18",
  "failed_tests": {
    "org.apache.commons.math3.optimization.direct.CMAESOptimizerTest": [
      {
        "methodName": "testFitAccuracyDependsOnBoundary",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<11.099999999907052> but was:<8.0>",
        "fail_line": "        Assert.assertEquals(resNoBound, resNearHi, 1e-3);",
        "test_source": "  public void testFitAccuracyDependsOnBoundary() {\n  final CMAESOptimizer optimizer = new CMAESOptimizer();\n  final MultivariateFunction fitnessFunction = new MultivariateFunction() {\n  public double value(double[] parameters) {\n  final double target = 11.1;\n  final double error = target - parameters[0];\n  return error * error;\n  }\n  };\n\n  final double[] start = { 1 };\n \n  // No bounds.\n  PointValuePair result = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE,\n  start);\n  final double resNoBound = result.getPoint()[0];\n\n  // Optimum is near the lower bound.\n  final double[] lower = { -20 };\n  final double[] upper = { 5e16 };\n  result = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE,\n  start, lower, upper);\n  final double resNearLo = result.getPoint()[0];\n\n  // Optimum is near the upper bound.\n  lower[0] = -5e16;\n  upper[0] = 20;\n  result = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE,\n  start, lower, upper);\n  final double resNearHi = result.getPoint()[0];\n\n  // System.out.println(\"resNoBound=\" + resNoBound +\n  //  \" resNearLo=\" + resNearLo +\n  //  \" resNearHi=\" + resNearHi);\n\n  // The two values currently differ by a substantial amount, indicating that\n  // the bounds definition can prevent reaching the optimum.\n  Assert.assertEquals(resNoBound, resNearLo, 1e-3);\n  Assert.assertEquals(resNoBound, resNearHi, 1e-3);\n  }",
        "stack": [
          "CMAESOptimizerTest.testFitAccuracyDependsOnBoundary line 477, RetryRunner$1.evaluate line 60"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math3.optimization.direct;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.apache.commons.math3.analysis.MultivariateFunction;\nimport org.apache.commons.math3.exception.DimensionMismatchException;\nimport org.apache.commons.math3.exception.MathUnsupportedOperationException;\nimport org.apache.commons.math3.exception.NotPositiveException;\nimport org.apache.commons.math3.exception.NumberIsTooLargeException;\nimport org.apache.commons.math3.exception.OutOfRangeException;\nimport org.apache.commons.math3.exception.TooManyEvaluationsException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.EigenDecomposition;\nimport org.apache.commons.math3.linear.MatrixUtils;\nimport org.apache.commons.math3.linear.RealMatrix;\nimport org.apache.commons.math3.optimization.ConvergenceChecker;\nimport org.apache.commons.math3.optimization.GoalType;\nimport org.apache.commons.math3.optimization.MultivariateOptimizer;\nimport org.apache.commons.math3.optimization.PointValuePair;\nimport org.apache.commons.math3.optimization.SimpleValueChecker;\nimport org.apache.commons.math3.random.MersenneTwister;\nimport org.apache.commons.math3.random.RandomGenerator;\nimport org.apache.commons.math3.util.MathArrays;\n\n\n\npublic class CMAESOptimizer extends BaseAbstractMultivariateSimpleBoundsOptimizer<MultivariateFunction> implements MultivariateOptimizer { public static final int DEFAULT_CHECKFEASABLECOUNT = 0; public static final double DEFAULT_STOPFITNESS = 0; public static final boolean DEFAULT_ISACTIVECMA = true; public static final int DEFAULT_MAXITERATIONS = 30000; public static final int DEFAULT_DIAGONALONLY = 0; public static final RandomGenerator DEFAULT_RANDOMGENERATOR = new MersenneTwister(); private int lambda; private boolean isActiveCMA; private int checkFeasableCount; private double[][] boundaries; private double[] inputSigma; private int dimension; private int diagonalOnly = 0; private boolean isMinimize = true; private boolean generateStatistics = false; private int maxIterations; private double stopFitness; private double stopTolUpX; private double stopTolX; private double stopTolFun; private double stopTolHistFun; private int mu; private double logMu2; private RealMatrix weights; private double mueff; private double sigma; private double cc; private double cs; private double damps; private double ccov1; private double ccovmu; private double chiN; private double ccov1Sep; private double ccovmuSep; private RealMatrix xmean; private RealMatrix pc; private RealMatrix ps; private double normps; private RealMatrix B; private RealMatrix D; private RealMatrix BD; private RealMatrix diagD; private RealMatrix C; private RealMatrix diagC; private int iterations; private double[] fitnessHistory; private int historySize; private RandomGenerator random; private List<Double> statisticsSigmaHistory = new ArrayList<Double>(); private List<RealMatrix> statisticsMeanHistory = new ArrayList<RealMatrix>(); private List<Double> statisticsFitnessHistory = new ArrayList<Double>(); private List<RealMatrix> statisticsDHistory = new ArrayList<RealMatrix>(); public CMAESOptimizer() {\n        this(0);\n    }\n\n    \n    public CMAESOptimizer(int lambda) {\n        this(lambda, null, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,\n             DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY,\n             DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false);\n    }\n\n    \n    public CMAESOptimizer(int lambda, double[] inputSigma) {\n        this(lambda, inputSigma, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,\n             DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY,\n             DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false);\n    }\n\n    \n    @Deprecated\n    public CMAESOptimizer(int lambda, double[] inputSigma, int maxIterations, double stopFitness, boolean isActiveCMA, int diagonalOnly, int checkFeasableCount, RandomGenerator random, boolean generateStatistics) {\n        this(lambda, inputSigma, maxIterations, stopFitness, isActiveCMA,\n             diagonalOnly, checkFeasableCount, random, generateStatistics,\n             new SimpleValueChecker());\n    }\n\n    \n    public CMAESOptimizer(int lambda, double[] inputSigma, int maxIterations, double stopFitness, boolean isActiveCMA, int diagonalOnly, int checkFeasableCount, RandomGenerator random, boolean generateStatistics, ConvergenceChecker<PointValuePair> checker) {\n        super(checker);\n        this.lambda = lambda;\n        this.inputSigma = inputSigma == null ? null : (double[]) inputSigma.clone();\n        this.maxIterations = maxIterations;\n        this.stopFitness = stopFitness;\n        this.isActiveCMA = isActiveCMA;\n        this.diagonalOnly = diagonalOnly;\n        this.checkFeasableCount = checkFeasableCount;\n        this.random = random;\n        this.generateStatistics = generateStatistics;\n    }\n\n    \n    public List<Double> getStatisticsSigmaHistory() {\n        return statisticsSigmaHistory;\n    }\n\n    \n    public List<RealMatrix> getStatisticsMeanHistory() {\n        return statisticsMeanHistory;\n    }\n\n    \n    public List<Double> getStatisticsFitnessHistory() {\n        return statisticsFitnessHistory;\n    }\n\n    \n    public List<RealMatrix> getStatisticsDHistory() {\n        return statisticsDHistory;\n    }\n\n    \n    @Override\n    protected PointValuePair doOptimize() {\n        checkParameters();\n         \n        isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n        final FitnessFunction fitfun = new FitnessFunction();\n        final double[] guess = fitfun.encode(getStartPoint());\n        \n        dimension = guess.length;\n        initializeCMA(guess);\n        iterations = 0;\n        double bestValue = fitfun.value(guess);\n        push(fitnessHistory, bestValue);\n        PointValuePair optimum = new PointValuePair(getStartPoint(),\n                isMinimize ? bestValue : -bestValue);\n        PointValuePair lastResult = null;\n\n        \n\n        generationLoop:\n            for (iterations = 1; iterations <= maxIterations; iterations++) {\n                \n                RealMatrix arz = randn1(dimension, lambda);\n                RealMatrix arx = zeros(dimension, lambda);\n                double[] fitness = new double[lambda];\n                \n                for (int k = 0; k < lambda; k++) {\n                    RealMatrix arxk = null;\n                    for (int i = 0; i < checkFeasableCount+1; i++) {\n                        if (diagonalOnly <= 0) {\n                            arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))\n                                    .scalarMultiply(sigma)); \n                        } else {\n                            arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))\n                                    .scalarMultiply(sigma));\n                        }\n                        if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {\n                            break;\n                        }\n                        \n                        arz.setColumn(k, randn(dimension));\n                    }\n                    copyColumn(arxk, 0, arx, k);\n                    try {\n                        fitness[k] = fitfun.value(arx.getColumn(k)); \n                    } catch (TooManyEvaluationsException e) {\n                        break generationLoop;\n                    }\n                }\n                \n                int[] arindex = sortedIndices(fitness);\n                \n                RealMatrix xold = xmean; \n                RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\n                xmean = bestArx.multiply(weights);\n                RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\n                RealMatrix zmean = bestArz.multiply(weights);\n                boolean hsig = updateEvolutionPaths(zmean, xold);\n                if (diagonalOnly <= 0) {\n                    updateCovariance(hsig, bestArx, arz, arindex, xold);\n                } else {\n                    updateCovarianceDiagonalOnly(hsig, bestArz, xold);\n                }\n                \n                sigma *= Math.exp(Math.min(1.0,(normps/chiN - 1.)*cs/damps));\n                double bestFitness = fitness[arindex[0]];\n                double worstFitness = fitness[arindex[arindex.length-1]];\n                if (bestValue > bestFitness) {\n                    bestValue = bestFitness;\n                    lastResult = optimum;\n                    optimum = new PointValuePair(\n                            fitfun.repairAndDecode(bestArx.getColumn(0)),\n                            isMinimize ? bestFitness : -bestFitness);\n                    if (getConvergenceChecker() != null && lastResult != null) {\n                        if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n                            break generationLoop;\n                        }\n                    }\n                }\n                \n                \n                if (stopFitness != 0) { \n                    if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n                        break generationLoop;\n                    }\n                }\n                double[] sqrtDiagC = sqrt(diagC).getColumn(0);\n                double[] pcCol = pc.getColumn(0);\n                for (int i = 0; i < dimension; i++) {\n                    if (sigma*(Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {\n                        break;\n                    }\n                    if (i >= dimension-1) {\n                        break generationLoop;\n                    }\n                }\n                for (int i = 0; i < dimension; i++) {\n                    if (sigma*sqrtDiagC[i] > stopTolUpX) {\n                        break generationLoop;\n                    }\n                }\n                double historyBest = min(fitnessHistory);\n                double historyWorst = max(fitnessHistory);\n                if (iterations > 2 && Math.max(historyWorst, worstFitness) -\n                        Math.min(historyBest, bestFitness) < stopTolFun) {\n                    break generationLoop;\n                }\n                if (iterations > fitnessHistory.length &&\n                        historyWorst-historyBest < stopTolHistFun) {\n                    break generationLoop;\n                }\n                \n                if (max(diagD)/min(diagD) > 1e7) {\n                    break generationLoop;\n                }\n                \n                if (getConvergenceChecker() != null) {\n                    PointValuePair current =\n                        new PointValuePair(bestArx.getColumn(0),\n                                isMinimize ? bestFitness : -bestFitness);\n                    if (lastResult != null &&\n                        getConvergenceChecker().converged(iterations, current, lastResult)) {\n                        break generationLoop;\n                    }\n                    lastResult = current;\n                }\n                \n                if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {\n                    sigma = sigma * Math.exp(0.2+cs/damps);\n                }\n                if (iterations > 2 && Math.max(historyWorst, bestFitness) -\n                        Math.min(historyBest, bestFitness) == 0) {\n                    sigma = sigma * Math.exp(0.2+cs/damps);\n                }\n                \n                push(fitnessHistory,bestFitness);\n                fitfun.setValueRange(worstFitness-bestFitness);\n                if (generateStatistics) {\n                    statisticsSigmaHistory.add(sigma);\n                    statisticsFitnessHistory.add(bestFitness);\n                    statisticsMeanHistory.add(xmean.transpose());\n                    statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\n                }\n            }\n        return optimum;\n    }\n\n    \n    private void checkParameters() {\n        final double[] init = getStartPoint();\n        final double[] lB = getLowerBound();\n        final double[] uB = getUpperBound();\n\n        \n        boolean hasFiniteBounds = false;\n        for (int i = 0; i < lB.length; i++) {\n            if (!Double.isInfinite(lB[i]) ||\n                !Double.isInfinite(uB[i])) {\n                hasFiniteBounds = true;\n                break;\n            }\n        }\n        \n        boolean hasInfiniteBounds = false;\n        if (hasFiniteBounds) {\n            for (int i = 0; i < lB.length; i++) {\n                if (Double.isInfinite(lB[i]) ||\n                    Double.isInfinite(uB[i])) {\n                    hasInfiniteBounds = true;\n                    break;\n                }\n            }\n\n            if (hasInfiniteBounds) {\n                \n                \n                throw new MathUnsupportedOperationException();\n            } else {\n                \n                boundaries = new double[2][];\n                boundaries[0] = lB;\n                boundaries[1] = uB;\n\n                \n                for (int i = 0; i < lB.length; i++) {\n                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\n                        final double max = Double.MAX_VALUE + boundaries[0][i];\n                        final NumberIsTooLargeException e\n                            = new NumberIsTooLargeException(boundaries[1][i],\n                                                            max,\n                                                            true);\n                        e.getContext().addMessage(LocalizedFormats.OVERFLOW);\n                        e.getContext().addMessage(LocalizedFormats.INDEX, i);\n\n                        throw e;\n                    }\n                }\n            }\n        } else {\n            \n            boundaries = null;\n        }\n\n        if (inputSigma != null) {\n            if (inputSigma.length != init.length) {\n                throw new DimensionMismatchException(inputSigma.length, init.length);\n            }\n            for (int i = 0; i < init.length; i++) {\n                if (inputSigma[i] < 0) {\n                    throw new NotPositiveException(inputSigma[i]);\n                }\n                if (boundaries != null) {\n                    if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                        throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                    }\n                }\n            }\n        }\n    }\n\n    \n    private void initializeCMA(double[] guess) {\n        if (lambda <= 0) {\n            lambda = 4 + (int) (3. * Math.log(dimension));\n        }\n        \n        double[][] sigmaArray = new double[guess.length][1];\n        for (int i = 0; i < guess.length; i++) {\n            final double range = (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i];\n            sigmaArray[i][0] = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range;\n        }\n        RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);\n        sigma = max(insigma); \n\n        \n        stopTolUpX = 1e3 * max(insigma);\n        stopTolX = 1e-11 * max(insigma);\n        stopTolFun = 1e-12;\n        stopTolHistFun = 1e-13;\n\n        \n        mu = lambda / 2; \n        logMu2 = Math.log(mu + 0.5);\n        weights = log(sequence(1, mu, 1)).scalarMultiply(-1.).scalarAdd(logMu2);\n        double sumw = 0;\n        double sumwq = 0;\n        for (int i = 0; i < mu; i++) {\n            double w = weights.getEntry(i, 0);\n            sumw += w;\n            sumwq += w * w;\n        }\n        weights = weights.scalarMultiply(1. / sumw);\n        mueff = sumw * sumw / sumwq; \n\n        \n        cc = (4. + mueff / dimension) /\n                (dimension + 4. + 2. * mueff / dimension);\n        cs = (mueff + 2.) / (dimension + mueff + 3.);\n        damps = (1. + 2. * Math.max(0, Math.sqrt((mueff - 1.) /\n                (dimension + 1.)) - 1.)) *\n                Math.max(0.3, 1. - dimension /\n                        (1e-6 + Math.min(maxIterations, getMaxEvaluations() /\n                                lambda))) + cs; \n        ccov1 = 2. / ((dimension + 1.3) * (dimension + 1.3) + mueff);\n        ccovmu = Math.min(1 - ccov1, 2. * (mueff - 2. + 1. / mueff) /\n                ((dimension + 2.) * (dimension + 2.) + mueff));\n        ccov1Sep = Math.min(1, ccov1 * (dimension + 1.5) / 3.);\n        ccovmuSep = Math.min(1 - ccov1, ccovmu * (dimension + 1.5) / 3.);\n        chiN = Math.sqrt(dimension) *\n                (1. - 1. / (4. * dimension) + 1 / (21. * dimension * dimension));\n        \n        xmean = MatrixUtils.createColumnRealMatrix(guess); \n                                                           \n        diagD = insigma.scalarMultiply(1. / sigma);\n        diagC = square(diagD);\n        pc = zeros(dimension, 1); \n        ps = zeros(dimension, 1); \n        normps = ps.getFrobeniusNorm();\n\n        B = eye(dimension, dimension);\n        D = ones(dimension, 1); \n        BD = times(B, repmat(diagD.transpose(), dimension, 1));\n        C = B.multiply(diag(square(D)).multiply(B.transpose())); \n        historySize = 10 + (int) (3. * 10. * dimension / lambda);\n        fitnessHistory = new double[historySize]; \n        for (int i = 0; i < historySize; i++) {\n            fitnessHistory[i] = Double.MAX_VALUE;\n        }\n    }\n\n    \n    private boolean updateEvolutionPaths(RealMatrix zmean, RealMatrix xold) {\n        ps = ps.scalarMultiply(1. - cs).add(\n                B.multiply(zmean).scalarMultiply(\n                        Math.sqrt(cs * (2. - cs) * mueff)));\n        normps = ps.getFrobeniusNorm();\n        boolean hsig = normps /\n            Math.sqrt(1. - Math.pow(1. - cs, 2. * iterations)) /\n                chiN < 1.4 + 2. / (dimension + 1.);\n        pc = pc.scalarMultiply(1. - cc);\n        if (hsig) {\n            pc = pc.add(xmean.subtract(xold).scalarMultiply(\n                    Math.sqrt(cc * (2. - cc) * mueff) / sigma));\n        }\n        return hsig;\n    }\n\n    \n    private void updateCovarianceDiagonalOnly(boolean hsig, final RealMatrix bestArz, final RealMatrix xold) {\n        \n        double oldFac = hsig ? 0 : ccov1Sep * cc * (2. - cc);\n        oldFac += 1. - ccov1Sep - ccovmuSep;\n        diagC = diagC.scalarMultiply(oldFac) \n                \n                .add(square(pc).scalarMultiply(ccov1Sep))\n                \n                .add((times(diagC, square(bestArz).multiply(weights)))\n                        .scalarMultiply(ccovmuSep));\n        diagD = sqrt(diagC); \n        if (diagonalOnly > 1 && iterations > diagonalOnly) {\n            \n            diagonalOnly = 0;\n            B = eye(dimension, dimension);\n            BD = diag(diagD);\n            C = diag(diagC);\n        }\n    }\n\n    \n    private void updateCovariance(boolean hsig, final RealMatrix bestArx, final RealMatrix arz, final int[] arindex, final RealMatrix xold) {\n        double negccov = 0;\n        if (ccov1 + ccovmu > 0) {\n            RealMatrix arpos = bestArx.subtract(repmat(xold, 1, mu))\n                    .scalarMultiply(1. / sigma); \n            RealMatrix roneu = pc.multiply(pc.transpose())\n                    .scalarMultiply(ccov1); \n            \n            double oldFac = hsig ? 0 : ccov1 * cc * (2. - cc);\n            oldFac += 1. - ccov1 - ccovmu;\n            if (isActiveCMA) {\n                \n                negccov = (1. - ccovmu) * 0.25 * mueff /\n                (Math.pow(dimension + 2., 1.5) + 2. * mueff);\n                double negminresidualvariance = 0.66;\n                \n                \n                double negalphaold = 0.5; \n                                          \n                \n                int[] arReverseIndex = reverse(arindex);\n                RealMatrix arzneg\n                    = selectColumns(arz, MathArrays.copyOf(arReverseIndex, mu));\n                RealMatrix arnorms = sqrt(sumRows(square(arzneg)));\n                int[] idxnorms = sortedIndices(arnorms.getRow(0));\n                RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms);\n                int[] idxReverse = reverse(idxnorms);\n                RealMatrix arnormsReverse = selectColumns(arnorms, idxReverse);\n                arnorms = divide(arnormsReverse, arnormsSorted);\n                int[] idxInv = inverse(idxnorms);\n                RealMatrix arnormsInv = selectColumns(arnorms, idxInv);\n                \n                double negcovMax = (1. - negminresidualvariance) /\n                        square(arnormsInv).multiply(weights).getEntry(0, 0);\n                if (negccov > negcovMax) {\n                    negccov = negcovMax;\n                }\n                arzneg = times(arzneg, repmat(arnormsInv, dimension, 1));\n                RealMatrix artmp = BD.multiply(arzneg);\n                RealMatrix Cneg = artmp.multiply(diag(weights)).multiply(\n                        artmp.transpose());\n                oldFac += negalphaold * negccov;\n                C = C.scalarMultiply(oldFac)\n                        \n                        .add(roneu)\n                        \n                        .add(arpos.scalarMultiply(\n                                \n                                ccovmu + (1. - negalphaold) * negccov)\n                                .multiply(\n                                        times(repmat(weights, 1, dimension),\n                                                arpos.transpose())))\n                        .subtract(Cneg.scalarMultiply(negccov));\n            } else {\n                \n                C = C.scalarMultiply(oldFac) \n                        .add(roneu)\n                        \n                        .add(arpos.scalarMultiply(ccovmu) \n                                .multiply(\n                                        times(repmat(weights, 1, dimension),\n                                                arpos.transpose())));\n            }\n        }\n        updateBD(negccov);\n    }\n\n    \n    private void updateBD(double negccov) {\n        if (ccov1 + ccovmu + negccov > 0 &&\n                (iterations % 1. / (ccov1 + ccovmu + negccov) / dimension / 10.) < 1.) {\n            \n            C = triu(C, 0).add(triu(C, 1).transpose());\n            \n            EigenDecomposition eig = new EigenDecomposition(C);\n            B = eig.getV(); \n            D = eig.getD();\n            diagD = diag(D);\n            if (min(diagD) <= 0) {\n                for (int i = 0; i < dimension; i++) {\n                    if (diagD.getEntry(i, 0) < 0) {\n                        diagD.setEntry(i, 0, 0.);\n                    }\n                }\n                double tfac = max(diagD) / 1e14;\n                C = C.add(eye(dimension, dimension).scalarMultiply(tfac));\n                diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));\n            }\n            if (max(diagD) > 1e14 * min(diagD)) {\n                double tfac = max(diagD) / 1e14 - min(diagD);\n                C = C.add(eye(dimension, dimension).scalarMultiply(tfac));\n                diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));\n            }\n            diagC = diag(C);\n            diagD = sqrt(diagD); \n            BD = times(B, repmat(diagD.transpose(), dimension, 1)); \n        }\n    }\n\n    \n    private static void push(double[] vals, double val) {\n        for (int i = vals.length-1; i > 0; i--) {\n            vals[i] = vals[i-1];\n        }\n        vals[0] = val;\n    }\n\n    \n    private int[] sortedIndices(final double[] doubles) {\n        DoubleIndex[] dis = new DoubleIndex[doubles.length];\n        for (int i = 0; i < doubles.length; i++) {\n            dis[i] = new DoubleIndex(doubles[i], i);\n        }\n        Arrays.sort(dis);\n        int[] indices = new int[doubles.length];\n        for (int i = 0; i < doubles.length; i++) {\n            indices[i] = dis[i].index;\n        }\n        return indices;\n    }\n\n    \n    private static class DoubleIndex implements Comparable<DoubleIndex> { private double value; private int index; DoubleIndex(double value, int index) {\n            this.value = value;\n            this.index = index;\n        }\n\n        \n        public int compareTo(DoubleIndex o) {\n            return Double.compare(value, o.value);\n        }\n\n        \n        @Override\n        public boolean equals(Object other) {\n\n            if (this == other) {\n                return true;\n            }\n\n            if (other instanceof DoubleIndex) {\n                return Double.compare(value, ((DoubleIndex) other).value) == 0;\n            }\n\n            return false;\n\n        }\n\n        \n        @Override\n        public int hashCode() {\n            long bits = Double.doubleToLongBits(value);\n            return (int) ((1438542 ^ (bits >>> 32) ^ bits) & 0xffffffff);\n        }\n\n    }\n\n    \n    private class FitnessFunction { private double valueRange; private boolean isRepairMode; public FitnessFunction() {\n            valueRange = 1.0;\n            isRepairMode = true;\n        }\n\n        \n        public double[] encode(final double[] x) {\n            if (boundaries == null) {\n                return x;\n            }\n            double[] res = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                double diff = boundaries[1][i] - boundaries[0][i];\n                res[i] = (x[i] - boundaries[0][i]) / diff;\n            }\n            return res;\n        }\n\n        \n        public double[] repairAndDecode(final double[] x) {\n            return boundaries != null && isRepairMode ?\n                decode(repair(x)) :\n                decode(x);\n        }\n\n        \n        public double[] decode(final double[] x) {\n            if (boundaries == null) {\n                return x;\n            }\n            double[] res = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                double diff = boundaries[1][i] - boundaries[0][i];\n                res[i] = diff * x[i] + boundaries[0][i];\n            }\n            return res;\n        }\n\n        \n        public double value(final double[] point) {\n            double value;\n            if (boundaries != null && isRepairMode) {\n                double[] repaired = repair(point);\n                value = CMAESOptimizer.this\n                        .computeObjectiveValue(decode(repaired)) +\n                        penalty(point, repaired);\n            } else {\n                value = CMAESOptimizer.this\n                        .computeObjectiveValue(decode(point));\n            }\n            return isMinimize ? value : -value;\n        }\n\n        \n        public boolean isFeasible(final double[] x) {\n            if (boundaries == null) {\n                return true;\n            }\n\n\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < 0) {\n                    return false;\n                }\n                if (x[i] > 1.0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        \n        public void setValueRange(double valueRange) {\n            this.valueRange = valueRange;\n        }\n\n        \n        private double[] repair(final double[] x) {\n            double[] repaired = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < 0) {\n                    repaired[i] = 0;\n                } else if (x[i] > 1.0) {\n                    repaired[i] = 1.0;\n                } else {\n                    repaired[i] = x[i];\n                }\n            }\n            return repaired;\n        }\n\n        \n        private double penalty(final double[] x, final double[] repaired) {\n            double penalty = 0;\n            for (int i = 0; i < x.length; i++) {\n                double diff = Math.abs(x[i] - repaired[i]);\n                penalty += diff * valueRange;\n            }\n            return isMinimize ? penalty : -penalty;\n        }\n    }\n\n    \n\n    \n    private static RealMatrix log(final RealMatrix m) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = Math.log(m.getEntry(r, c));\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    \n    private static RealMatrix sqrt(final RealMatrix m) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = Math.sqrt(m.getEntry(r, c));\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    \n    private static RealMatrix square(final RealMatrix m) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                d[r][c] = e * e;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    \n    private static RealMatrix times(final RealMatrix m, final RealMatrix n) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) * n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    \n    private static RealMatrix divide(final RealMatrix m, final RealMatrix n) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) / n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    \n    private static RealMatrix selectColumns(final RealMatrix m, final int[] cols) {\n        double[][] d = new double[m.getRowDimension()][cols.length];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < cols.length; c++) {\n                d[r][c] = m.getEntry(r, cols[c]);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    \n    private static RealMatrix triu(final RealMatrix m, int k) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = r <= c - k ? m.getEntry(r, c) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    \n    private static RealMatrix sumRows(final RealMatrix m) {\n        double[][] d = new double[1][m.getColumnDimension()];\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            double sum = 0;\n            for (int r = 0; r < m.getRowDimension(); r++) {\n                sum += m.getEntry(r, c);\n            }\n            d[0][c] = sum;\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    \n    private static RealMatrix diag(final RealMatrix m) {\n        if (m.getColumnDimension() == 1) {\n            double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n            for (int i = 0; i < m.getRowDimension(); i++) {\n                d[i][i] = m.getEntry(i, 0);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        } else {\n            double[][] d = new double[m.getRowDimension()][1];\n            for (int i = 0; i < m.getColumnDimension(); i++) {\n                d[i][0] = m.getEntry(i, i);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        }\n    }\n\n    \n    private static void copyColumn(final RealMatrix m1, int col1, RealMatrix m2, int col2) {\n        for (int i = 0; i < m1.getRowDimension(); i++) {\n            m2.setEntry(i, col2, m1.getEntry(i, col1));\n        }\n    }\n\n    \n    private static RealMatrix ones(int n, int m) {\n        double[][] d = new double[n][m];\n        for (int r = 0; r < n; r++) {\n            Arrays.fill(d[r], 1.0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    \n    private static RealMatrix eye(int n, int m) {\n        double[][] d = new double[n][m];\n        for (int r = 0; r < n; r++) {\n            if (r < m) {\n                d[r][r] = 1;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    \n    private static RealMatrix zeros(int n, int m) {\n        return new Array2DRowRealMatrix(n, m);\n    }\n\n    \n    private static RealMatrix repmat(final RealMatrix mat, int n, int m) {\n        int rd = mat.getRowDimension();\n        int cd = mat.getColumnDimension();\n        double[][] d = new double[n * rd][m * cd];\n        for (int r = 0; r < n * rd; r++) {\n            for (int c = 0; c < m * cd; c++) {\n                d[r][c] = mat.getEntry(r % rd, c % cd);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    \n    private static RealMatrix sequence(double start, double end, double step) {\n        int size = (int) ((end - start) / step + 1);\n        double[][] d = new double[size][1];\n        double value = start;\n        for (int r = 0; r < size; r++) {\n            d[r][0] = value;\n            value += step;\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    \n    private static double max(final RealMatrix m) {\n        double max = -Double.MAX_VALUE;\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                if (max < e) {\n                    max = e;\n                }\n            }\n        }\n        return max;\n    }\n\n    \n    private static double min(final RealMatrix m) {\n        double min = Double.MAX_VALUE;\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                if (min > e) {\n                    min = e;\n                }\n            }\n        }\n        return min;\n    }\n\n    \n    private static double max(final double[] m) {\n        double max = -Double.MAX_VALUE;\n        for (int r = 0; r < m.length; r++) {\n            if (max < m[r]) {\n                max = m[r];\n            }\n        }\n        return max;\n    }\n\n    \n    private static double min(final double[] m) {\n        double min = Double.MAX_VALUE;\n        for (int r = 0; r < m.length; r++) {\n            if (min > m[r]) {\n                min = m[r];\n            }\n        }\n        return min;\n    }\n\n    \n    private static int[] inverse(final int[] indices) {\n        int[] inverse = new int[indices.length];\n        for (int i = 0; i < indices.length; i++) {\n            inverse[indices[i]] = i;\n        }\n        return inverse;\n    }\n\n    \n    private static int[] reverse(final int[] indices) {\n        int[] reverse = new int[indices.length];\n        for (int i = 0; i < indices.length; i++) {\n            reverse[i] = indices[indices.length - i - 1];\n        }\n        return reverse;\n    }\n\n    \n    private double[] randn(int size) {\n        double[] randn = new double[size];\n        for (int i = 0; i < size; i++) {\n            randn[i] = random.nextGaussian();\n        }\n        return randn;\n    }\n\n    \n    private RealMatrix randn1(int size, int popSize) {\n        double[][] d = new double[size][popSize];\n        for (int r = 0; r < size; r++) {\n            for (int c = 0; c < popSize; c++) {\n                d[r][c] = random.nextGaussian();\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math3.optimization.direct;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.apache.commons.math3.analysis.MultivariateFunction;\nimport org.apache.commons.math3.exception.DimensionMismatchException;\nimport org.apache.commons.math3.exception.MathUnsupportedOperationException;\nimport org.apache.commons.math3.exception.NotPositiveException;\nimport org.apache.commons.math3.exception.NumberIsTooLargeException;\nimport org.apache.commons.math3.exception.OutOfRangeException;\nimport org.apache.commons.math3.exception.TooManyEvaluationsException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.EigenDecomposition;\nimport org.apache.commons.math3.linear.MatrixUtils;\nimport org.apache.commons.math3.linear.RealMatrix;\nimport org.apache.commons.math3.optimization.ConvergenceChecker;\nimport org.apache.commons.math3.optimization.GoalType;\nimport org.apache.commons.math3.optimization.MultivariateOptimizer;\nimport org.apache.commons.math3.optimization.PointValuePair;\nimport org.apache.commons.math3.optimization.SimpleValueChecker;\nimport org.apache.commons.math3.random.MersenneTwister;\nimport org.apache.commons.math3.random.RandomGenerator;\nimport org.apache.commons.math3.util.MathArrays;\n\n\n\npublic class CMAESOptimizer extends BaseAbstractMultivariateSimpleBoundsOptimizer<MultivariateFunction> implements MultivariateOptimizer { public static final int DEFAULT_CHECKFEASABLECOUNT = 0; public static final double DEFAULT_STOPFITNESS = 0; public static final boolean DEFAULT_ISACTIVECMA = true; public static final int DEFAULT_MAXITERATIONS = 30000; public static final int DEFAULT_DIAGONALONLY = 0; public static final RandomGenerator DEFAULT_RANDOMGENERATOR = new MersenneTwister(); private int lambda; private boolean isActiveCMA; private int checkFeasableCount; private double[][] boundaries; private double[] inputSigma; private int dimension; private int diagonalOnly = 0; private boolean isMinimize = true; private boolean generateStatistics = false; private int maxIterations; private double stopFitness; private double stopTolUpX; private double stopTolX; private double stopTolFun; private double stopTolHistFun; private int mu; private double logMu2; private RealMatrix weights; private double mueff; private double sigma; private double cc; private double cs; private double damps; private double ccov1; private double ccovmu; private double chiN; private double ccov1Sep; private double ccovmuSep; private RealMatrix xmean; private RealMatrix pc; private RealMatrix ps; private double normps; private RealMatrix B; private RealMatrix D; private RealMatrix BD; private RealMatrix diagD; private RealMatrix C; private RealMatrix diagC; private int iterations; private double[] fitnessHistory; private int historySize; private RandomGenerator random; private List<Double> statisticsSigmaHistory = new ArrayList<Double>(); private List<RealMatrix> statisticsMeanHistory = new ArrayList<RealMatrix>(); private List<Double> statisticsFitnessHistory = new ArrayList<Double>(); private List<RealMatrix> statisticsDHistory = new ArrayList<RealMatrix>(); public CMAESOptimizer() {\n        this(0);\n    }\n\n    \n    public CMAESOptimizer(int lambda) {\n        this(lambda, null, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,\n             DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY,\n             DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false);\n    }\n\n    \n    public CMAESOptimizer(int lambda, double[] inputSigma) {\n        this(lambda, inputSigma, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,\n             DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY,\n             DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false);\n    }\n\n    \n    @Deprecated\n    public CMAESOptimizer(int lambda, double[] inputSigma, int maxIterations, double stopFitness, boolean isActiveCMA, int diagonalOnly, int checkFeasableCount, RandomGenerator random, boolean generateStatistics) {\n        this(lambda, inputSigma, maxIterations, stopFitness, isActiveCMA,\n             diagonalOnly, checkFeasableCount, random, generateStatistics,\n             new SimpleValueChecker());\n    }\n\n    \n    public CMAESOptimizer(int lambda, double[] inputSigma, int maxIterations, double stopFitness, boolean isActiveCMA, int diagonalOnly, int checkFeasableCount, RandomGenerator random, boolean generateStatistics, ConvergenceChecker<PointValuePair> checker) {\n        super(checker);\n        this.lambda = lambda;\n        this.inputSigma = inputSigma == null ? null : (double[]) inputSigma.clone();\n        this.maxIterations = maxIterations;\n        this.stopFitness = stopFitness;\n        this.isActiveCMA = isActiveCMA;\n        this.diagonalOnly = diagonalOnly;\n        this.checkFeasableCount = checkFeasableCount;\n        this.random = random;\n        this.generateStatistics = generateStatistics;\n    }\n\n    \n    public List<Double> getStatisticsSigmaHistory() {\n        return statisticsSigmaHistory;\n    }\n\n    \n    public List<RealMatrix> getStatisticsMeanHistory() {\n        return statisticsMeanHistory;\n    }\n\n    \n    public List<Double> getStatisticsFitnessHistory() {\n        return statisticsFitnessHistory;\n    }\n\n    \n    public List<RealMatrix> getStatisticsDHistory() {\n        return statisticsDHistory;\n    }\n\n    \n    @Override\n    protected PointValuePair doOptimize() {\n        checkParameters();\n         \n        isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n        final FitnessFunction fitfun = new FitnessFunction();\n        final double[] guess = fitfun.encode(getStartPoint());\n        \n        dimension = guess.length;\n        initializeCMA(guess);\n        iterations = 0;\n        double bestValue = fitfun.value(guess);\n        push(fitnessHistory, bestValue);\n        PointValuePair optimum = new PointValuePair(getStartPoint(),\n                isMinimize ? bestValue : -bestValue);\n        PointValuePair lastResult = null;\n\n        \n\n        generationLoop:\n            for (iterations = 1; iterations <= maxIterations; iterations++) {\n                \n                RealMatrix arz = randn1(dimension, lambda);\n                RealMatrix arx = zeros(dimension, lambda);\n                double[] fitness = new double[lambda];\n                \n                for (int k = 0; k < lambda; k++) {\n                    RealMatrix arxk = null;\n                    for (int i = 0; i < checkFeasableCount+1; i++) {\n                        if (diagonalOnly <= 0) {\n                            arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))\n                                    .scalarMultiply(sigma)); \n                        } else {\n                            arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))\n                                    .scalarMultiply(sigma));\n                        }\n                        if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {\n                            break;\n                        }\n                        \n                        arz.setColumn(k, randn(dimension));\n                    }\n                    copyColumn(arxk, 0, arx, k);\n                    try {\n                        fitness[k] = fitfun.value(arx.getColumn(k)); \n                    } catch (TooManyEvaluationsException e) {\n                        break generationLoop;\n                    }\n                }\n                \n                int[] arindex = sortedIndices(fitness);\n                \n                RealMatrix xold = xmean; \n                RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\n                xmean = bestArx.multiply(weights);\n                RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\n                RealMatrix zmean = bestArz.multiply(weights);\n                boolean hsig = updateEvolutionPaths(zmean, xold);\n                if (diagonalOnly <= 0) {\n                    updateCovariance(hsig, bestArx, arz, arindex, xold);\n                } else {\n                    updateCovarianceDiagonalOnly(hsig, bestArz, xold);\n                }\n                \n                sigma *= Math.exp(Math.min(1.0,(normps/chiN - 1.)*cs/damps));\n                double bestFitness = fitness[arindex[0]];\n                double worstFitness = fitness[arindex[arindex.length-1]];\n                if (bestValue > bestFitness) {\n                    bestValue = bestFitness;\n                    lastResult = optimum;\n                    optimum = new PointValuePair(\n                            fitfun.repairAndDecode(bestArx.getColumn(0)),\n                            isMinimize ? bestFitness : -bestFitness);\n                    if (getConvergenceChecker() != null && lastResult != null) {\n                        if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n                            break generationLoop;\n                        }\n                    }\n                }\n                \n                \n                if (stopFitness != 0) { \n                    if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n                        break generationLoop;\n                    }\n                }\n                double[] sqrtDiagC = sqrt(diagC).getColumn(0);\n                double[] pcCol = pc.getColumn(0);\n                for (int i = 0; i < dimension; i++) {\n                    if (sigma*(Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {\n                        break;\n                    }\n                    if (i >= dimension-1) {\n                        break generationLoop;\n                    }\n                }\n                for (int i = 0; i < dimension; i++) {\n                    if (sigma*sqrtDiagC[i] > stopTolUpX) {\n                        break generationLoop;\n                    }\n                }\n                double historyBest = min(fitnessHistory);\n                double historyWorst = max(fitnessHistory);\n                if (iterations > 2 && Math.max(historyWorst, worstFitness) -\n                        Math.min(historyBest, bestFitness) < stopTolFun) {\n                    break generationLoop;\n                }\n                if (iterations > fitnessHistory.length &&\n                        historyWorst-historyBest < stopTolHistFun) {\n                    break generationLoop;\n                }\n                \n                if (max(diagD)/min(diagD) > 1e7) {\n                    break generationLoop;\n                }\n                \n                if (getConvergenceChecker() != null) {\n                    PointValuePair current =\n                        new PointValuePair(bestArx.getColumn(0),\n                                isMinimize ? bestFitness : -bestFitness);\n                    if (lastResult != null &&\n                        getConvergenceChecker().converged(iterations, current, lastResult)) {\n                        break generationLoop;\n                    }\n                    lastResult = current;\n                }\n                \n                if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {\n                    sigma = sigma * Math.exp(0.2+cs/damps);\n                }\n                if (iterations > 2 && Math.max(historyWorst, bestFitness) -\n                        Math.min(historyBest, bestFitness) == 0) {\n                    sigma = sigma * Math.exp(0.2+cs/damps);\n                }\n                \n                push(fitnessHistory,bestFitness);\n                fitfun.setValueRange(worstFitness-bestFitness);\n                if (generateStatistics) {\n                    statisticsSigmaHistory.add(sigma);\n                    statisticsFitnessHistory.add(bestFitness);\n                    statisticsMeanHistory.add(xmean.transpose());\n                    statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\n                }\n            }\n        return optimum;\n    }\n\n    \n    private void checkParameters() {\n        final double[] init = getStartPoint();\n        final double[] lB = getLowerBound();\n        final double[] uB = getUpperBound();\n\n        \n        boolean hasFiniteBounds = false;\n        for (int i = 0; i < lB.length; i++) {\n            if (!Double.isInfinite(lB[i]) ||\n                !Double.isInfinite(uB[i])) {\n                hasFiniteBounds = true;\n                break;\n            }\n        }\n        \n        boolean hasInfiniteBounds = false;\n        if (hasFiniteBounds) {\n            for (int i = 0; i < lB.length; i++) {\n                if (Double.isInfinite(lB[i]) ||\n                    Double.isInfinite(uB[i])) {\n                    hasInfiniteBounds = true;\n                    break;\n                }\n            }\n\n            if (hasInfiniteBounds) {\n                \n                \n                throw new MathUnsupportedOperationException();\n            } else {\n                \n                boundaries = new double[2][];\n                boundaries[0] = lB;\n                boundaries[1] = uB;\n\n                \n                for (int i = 0; i < lB.length; i++) {\n                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\n                        final double max = Double.MAX_VALUE + boundaries[0][i];\n                        final NumberIsTooLargeException e\n                            = new NumberIsTooLargeException(boundaries[1][i],\n                                                            max,\n                                                            true);\n                        e.getContext().addMessage(LocalizedFormats.OVERFLOW);\n                        e.getContext().addMessage(LocalizedFormats.INDEX, i);\n\n                        throw e;\n                    }\n                }\n            }\n        } else {\n            \n            boundaries = null;\n        }\n\n        if (inputSigma != null) {\n            if (inputSigma.length != init.length) {\n                throw new DimensionMismatchException(inputSigma.length, init.length);\n            }\n            for (int i = 0; i < init.length; i++) {\n                if (inputSigma[i] < 0) {\n                    throw new NotPositiveException(inputSigma[i]);\n                }\n                if (boundaries != null) {\n                    if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                        throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                    }\n                }\n            }\n        }\n    }\n\n    \n    private void initializeCMA(double[] guess) {\n        if (lambda <= 0) {\n            lambda = 4 + (int) (3. * Math.log(dimension));\n        }\n        \n        double[][] sigmaArray = new double[guess.length][1];\n        for (int i = 0; i < guess.length; i++) {\n            final double range = (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i];\n            sigmaArray[i][0] = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range;\n        }\n        RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);\n        sigma = max(insigma); \n\n        \n        stopTolUpX = 1e3 * max(insigma);\n        stopTolX = 1e-11 * max(insigma);\n        stopTolFun = 1e-12;\n        stopTolHistFun = 1e-13;\n\n        \n        mu = lambda / 2; \n        logMu2 = Math.log(mu + 0.5);\n        weights = log(sequence(1, mu, 1)).scalarMultiply(-1.).scalarAdd(logMu2);\n        double sumw = 0;\n        double sumwq = 0;\n        for (int i = 0; i < mu; i++) {\n            double w = weights.getEntry(i, 0);\n            sumw += w;\n            sumwq += w * w;\n        }\n        weights = weights.scalarMultiply(1. / sumw);\n        mueff = sumw * sumw / sumwq; \n\n        \n        cc = (4. + mueff / dimension) /\n                (dimension + 4. + 2. * mueff / dimension);\n        cs = (mueff + 2.) / (dimension + mueff + 3.);\n        damps = (1. + 2. * Math.max(0, Math.sqrt((mueff - 1.) /\n                (dimension + 1.)) - 1.)) *\n                Math.max(0.3, 1. - dimension /\n                        (1e-6 + Math.min(maxIterations, getMaxEvaluations() /\n                                lambda))) + cs; \n        ccov1 = 2. / ((dimension + 1.3) * (dimension + 1.3) + mueff);\n        ccovmu = Math.min(1 - ccov1, 2. * (mueff - 2. + 1. / mueff) /\n                ((dimension + 2.) * (dimension + 2.) + mueff));\n        ccov1Sep = Math.min(1, ccov1 * (dimension + 1.5) / 3.);\n        ccovmuSep = Math.min(1 - ccov1, ccovmu * (dimension + 1.5) / 3.);\n        chiN = Math.sqrt(dimension) *\n                (1. - 1. / (4. * dimension) + 1 / (21. * dimension * dimension));\n        \n        xmean = MatrixUtils.createColumnRealMatrix(guess); \n                                                           \n        diagD = insigma.scalarMultiply(1. / sigma);\n        diagC = square(diagD);\n        pc = zeros(dimension, 1); \n        ps = zeros(dimension, 1); \n        normps = ps.getFrobeniusNorm();\n\n        B = eye(dimension, dimension);\n        D = ones(dimension, 1); \n        BD = times(B, repmat(diagD.transpose(), dimension, 1));\n        C = B.multiply(diag(square(D)).multiply(B.transpose())); \n        historySize = 10 + (int) (3. * 10. * dimension / lambda);\n        fitnessHistory = new double[historySize]; \n        for (int i = 0; i < historySize; i++) {\n            fitnessHistory[i] = Double.MAX_VALUE;\n        }\n    }\n\n    \n    private boolean updateEvolutionPaths(RealMatrix zmean, RealMatrix xold) {\n        ps = ps.scalarMultiply(1. - cs).add(\n                B.multiply(zmean).scalarMultiply(\n                        Math.sqrt(cs * (2. - cs) * mueff)));\n        normps = ps.getFrobeniusNorm();\n        boolean hsig = normps /\n            Math.sqrt(1. - Math.pow(1. - cs, 2. * iterations)) /\n                chiN < 1.4 + 2. / (dimension + 1.);\n        pc = pc.scalarMultiply(1. - cc);\n        if (hsig) {\n            pc = pc.add(xmean.subtract(xold).scalarMultiply(\n                    Math.sqrt(cc * (2. - cc) * mueff) / sigma));\n        }\n        return hsig;\n    }\n\n    \n    private void updateCovarianceDiagonalOnly(boolean hsig, final RealMatrix bestArz, final RealMatrix xold) {\n        \n        double oldFac = hsig ? 0 : ccov1Sep * cc * (2. - cc);\n        oldFac += 1. - ccov1Sep - ccovmuSep;\n        diagC = diagC.scalarMultiply(oldFac) \n                \n                .add(square(pc).scalarMultiply(ccov1Sep))\n                \n                .add((times(diagC, square(bestArz).multiply(weights)))\n                        .scalarMultiply(ccovmuSep));\n        diagD = sqrt(diagC); \n        if (diagonalOnly > 1 && iterations > diagonalOnly) {\n            \n            diagonalOnly = 0;\n            B = eye(dimension, dimension);\n            BD = diag(diagD);\n            C = diag(diagC);\n        }\n    }\n\n    \n    private void updateCovariance(boolean hsig, final RealMatrix bestArx, final RealMatrix arz, final int[] arindex, final RealMatrix xold) {\n        double negccov = 0;\n        if (ccov1 + ccovmu > 0) {\n            RealMatrix arpos = bestArx.subtract(repmat(xold, 1, mu))\n                    .scalarMultiply(1. / sigma); \n            RealMatrix roneu = pc.multiply(pc.transpose())\n                    .scalarMultiply(ccov1); \n            \n            double oldFac = hsig ? 0 : ccov1 * cc * (2. - cc);\n            oldFac += 1. - ccov1 - ccovmu;\n            if (isActiveCMA) {\n                \n                negccov = (1. - ccovmu) * 0.25 * mueff /\n                (Math.pow(dimension + 2., 1.5) + 2. * mueff);\n                double negminresidualvariance = 0.66;\n                \n                \n                double negalphaold = 0.5; \n                                          \n                \n                int[] arReverseIndex = reverse(arindex);\n                RealMatrix arzneg\n                    = selectColumns(arz, MathArrays.copyOf(arReverseIndex, mu));\n                RealMatrix arnorms = sqrt(sumRows(square(arzneg)));\n                int[] idxnorms = sortedIndices(arnorms.getRow(0));\n                RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms);\n                int[] idxReverse = reverse(idxnorms);\n                RealMatrix arnormsReverse = selectColumns(arnorms, idxReverse);\n                arnorms = divide(arnormsReverse, arnormsSorted);\n                int[] idxInv = inverse(idxnorms);\n                RealMatrix arnormsInv = selectColumns(arnorms, idxInv);\n                \n                double negcovMax = (1. - negminresidualvariance) /\n                        square(arnormsInv).multiply(weights).getEntry(0, 0);\n                if (negccov > negcovMax) {\n                    negccov = negcovMax;\n                }\n                arzneg = times(arzneg, repmat(arnormsInv, dimension, 1));\n                RealMatrix artmp = BD.multiply(arzneg);\n                RealMatrix Cneg = artmp.multiply(diag(weights)).multiply(\n                        artmp.transpose());\n                oldFac += negalphaold * negccov;\n                C = C.scalarMultiply(oldFac)\n                        \n                        .add(roneu)\n                        \n                        .add(arpos.scalarMultiply(\n                                \n                                ccovmu + (1. - negalphaold) * negccov)\n                                .multiply(\n                                        times(repmat(weights, 1, dimension),\n                                                arpos.transpose())))\n                        .subtract(Cneg.scalarMultiply(negccov));\n            } else {\n                \n                C = C.scalarMultiply(oldFac) \n                        .add(roneu)\n                        \n                        .add(arpos.scalarMultiply(ccovmu) \n                                .multiply(\n                                        times(repmat(weights, 1, dimension),\n                                                arpos.transpose())));\n            }\n        }\n        updateBD(negccov);\n    }\n\n    \n    private void updateBD(double negccov) {\n        if (ccov1 + ccovmu + negccov > 0 &&\n                (iterations % 1. / (ccov1 + ccovmu + negccov) / dimension / 10.) < 1.) {\n            \n            C = triu(C, 0).add(triu(C, 1).transpose());\n            \n            EigenDecomposition eig = new EigenDecomposition(C);\n            B = eig.getV(); \n            D = eig.getD();\n            diagD = diag(D);\n            if (min(diagD) <= 0) {\n                for (int i = 0; i < dimension; i++) {\n                    if (diagD.getEntry(i, 0) < 0) {\n                        diagD.setEntry(i, 0, 0.);\n                    }\n                }\n                double tfac = max(diagD) / 1e14;\n                C = C.add(eye(dimension, dimension).scalarMultiply(tfac));\n                diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));\n            }\n            if (max(diagD) > 1e14 * min(diagD)) {\n                double tfac = max(diagD) / 1e14 - min(diagD);\n                C = C.add(eye(dimension, dimension).scalarMultiply(tfac));\n                diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));\n            }\n            diagC = diag(C);\n            diagD = sqrt(diagD); \n            BD = times(B, repmat(diagD.transpose(), dimension, 1)); \n        }\n    }\n\n    \n    private static void push(double[] vals, double val) {\n        for (int i = vals.length-1; i > 0; i--) {\n            vals[i] = vals[i-1];\n        }\n        vals[0] = val;\n    }\n\n    \n    private int[] sortedIndices(final double[] doubles) {\n        DoubleIndex[] dis = new DoubleIndex[doubles.length];\n        for (int i = 0; i < doubles.length; i++) {\n            dis[i] = new DoubleIndex(doubles[i], i);\n        }\n        Arrays.sort(dis);\n        int[] indices = new int[doubles.length];\n        for (int i = 0; i < doubles.length; i++) {\n            indices[i] = dis[i].index;\n        }\n        return indices;\n    }\n\n    \n    private static class DoubleIndex implements Comparable<DoubleIndex> { private double value; private int index; DoubleIndex(double value, int index) {\n            this.value = value;\n            this.index = index;\n        }\n\n        \n        public int compareTo(DoubleIndex o) {\n            return Double.compare(value, o.value);\n        }\n\n        \n        @Override\n        public boolean equals(Object other) {\n\n            if (this == other) {\n                return true;\n            }\n\n            if (other instanceof DoubleIndex) {\n                return Double.compare(value, ((DoubleIndex) other).value) == 0;\n            }\n\n            return false;\n\n        }\n\n        \n        @Override\n        public int hashCode() {\n            long bits = Double.doubleToLongBits(value);\n            return (int) ((1438542 ^ (bits >>> 32) ^ bits) & 0xffffffff);\n        }\n\n    }\n\n    \n    private class FitnessFunction { private double valueRange; private boolean isRepairMode; public FitnessFunction() {\n            valueRange = 1.0;\n            isRepairMode = true;\n        }\n\n        \n        public double[] encode(final double[] x) {\n            if (boundaries == null) {\n                return x;\n            }\n            double[] res = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                double diff = boundaries[1][i] - boundaries[0][i];\n                res[i] = x[i] / diff;\n            }\n            return res;\n        }\n\n        \n        public double[] repairAndDecode(final double[] x) {\n            return boundaries != null && isRepairMode ?\n                decode(repair(x)) :\n                decode(x);\n        }\n\n        \n        public double[] decode(final double[] x) {\n            if (boundaries == null) {\n                return x;\n            }\n            double[] res = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                double diff = boundaries[1][i] - boundaries[0][i];\n                res[i] = diff * x[i];\n            }\n            return res;\n        }\n\n        \n        public double value(final double[] point) {\n            double value;\n            if (boundaries != null && isRepairMode) {\n                double[] repaired = repair(point);\n                value = CMAESOptimizer.this\n                        .computeObjectiveValue(decode(repaired)) +\n                        penalty(point, repaired);\n            } else {\n                value = CMAESOptimizer.this\n                        .computeObjectiveValue(decode(point));\n            }\n            return isMinimize ? value : -value;\n        }\n\n        \n        public boolean isFeasible(final double[] x) {\n            if (boundaries == null) {\n                return true;\n            }\n\n            final double[] bLoEnc = encode(boundaries[0]);\n            final double[] bHiEnc = encode(boundaries[1]);\n\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < bLoEnc[i]) {\n                    return false;\n                }\n                if (x[i] > bHiEnc[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        \n        public void setValueRange(double valueRange) {\n            this.valueRange = valueRange;\n        }\n\n        \n        private double[] repair(final double[] x) {\n            double[] repaired = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < 0) {\n                    repaired[i] = 0;\n                } else if (x[i] > 1.0) {\n                    repaired[i] = 1.0;\n                } else {\n                    repaired[i] = x[i];\n                }\n            }\n            return repaired;\n        }\n\n        \n        private double penalty(final double[] x, final double[] repaired) {\n            double penalty = 0;\n            for (int i = 0; i < x.length; i++) {\n                double diff = Math.abs(x[i] - repaired[i]);\n                penalty += diff * valueRange;\n            }\n            return isMinimize ? penalty : -penalty;\n        }\n    }\n\n    \n\n    \n    private static RealMatrix log(final RealMatrix m) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = Math.log(m.getEntry(r, c));\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    \n    private static RealMatrix sqrt(final RealMatrix m) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = Math.sqrt(m.getEntry(r, c));\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    \n    private static RealMatrix square(final RealMatrix m) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                d[r][c] = e * e;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    \n    private static RealMatrix times(final RealMatrix m, final RealMatrix n) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) * n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    \n    private static RealMatrix divide(final RealMatrix m, final RealMatrix n) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) / n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    \n    private static RealMatrix selectColumns(final RealMatrix m, final int[] cols) {\n        double[][] d = new double[m.getRowDimension()][cols.length];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < cols.length; c++) {\n                d[r][c] = m.getEntry(r, cols[c]);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    \n    private static RealMatrix triu(final RealMatrix m, int k) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = r <= c - k ? m.getEntry(r, c) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    \n    private static RealMatrix sumRows(final RealMatrix m) {\n        double[][] d = new double[1][m.getColumnDimension()];\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            double sum = 0;\n            for (int r = 0; r < m.getRowDimension(); r++) {\n                sum += m.getEntry(r, c);\n            }\n            d[0][c] = sum;\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    \n    private static RealMatrix diag(final RealMatrix m) {\n        if (m.getColumnDimension() == 1) {\n            double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n            for (int i = 0; i < m.getRowDimension(); i++) {\n                d[i][i] = m.getEntry(i, 0);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        } else {\n            double[][] d = new double[m.getRowDimension()][1];\n            for (int i = 0; i < m.getColumnDimension(); i++) {\n                d[i][0] = m.getEntry(i, i);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        }\n    }\n\n    \n    private static void copyColumn(final RealMatrix m1, int col1, RealMatrix m2, int col2) {\n        for (int i = 0; i < m1.getRowDimension(); i++) {\n            m2.setEntry(i, col2, m1.getEntry(i, col1));\n        }\n    }\n\n    \n    private static RealMatrix ones(int n, int m) {\n        double[][] d = new double[n][m];\n        for (int r = 0; r < n; r++) {\n            Arrays.fill(d[r], 1.0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    \n    private static RealMatrix eye(int n, int m) {\n        double[][] d = new double[n][m];\n        for (int r = 0; r < n; r++) {\n            if (r < m) {\n                d[r][r] = 1;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    \n    private static RealMatrix zeros(int n, int m) {\n        return new Array2DRowRealMatrix(n, m);\n    }\n\n    \n    private static RealMatrix repmat(final RealMatrix mat, int n, int m) {\n        int rd = mat.getRowDimension();\n        int cd = mat.getColumnDimension();\n        double[][] d = new double[n * rd][m * cd];\n        for (int r = 0; r < n * rd; r++) {\n            for (int c = 0; c < m * cd; c++) {\n                d[r][c] = mat.getEntry(r % rd, c % cd);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    \n    private static RealMatrix sequence(double start, double end, double step) {\n        int size = (int) ((end - start) / step + 1);\n        double[][] d = new double[size][1];\n        double value = start;\n        for (int r = 0; r < size; r++) {\n            d[r][0] = value;\n            value += step;\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    \n    private static double max(final RealMatrix m) {\n        double max = -Double.MAX_VALUE;\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                if (max < e) {\n                    max = e;\n                }\n            }\n        }\n        return max;\n    }\n\n    \n    private static double min(final RealMatrix m) {\n        double min = Double.MAX_VALUE;\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                if (min > e) {\n                    min = e;\n                }\n            }\n        }\n        return min;\n    }\n\n    \n    private static double max(final double[] m) {\n        double max = -Double.MAX_VALUE;\n        for (int r = 0; r < m.length; r++) {\n            if (max < m[r]) {\n                max = m[r];\n            }\n        }\n        return max;\n    }\n\n    \n    private static double min(final double[] m) {\n        double min = Double.MAX_VALUE;\n        for (int r = 0; r < m.length; r++) {\n            if (min > m[r]) {\n                min = m[r];\n            }\n        }\n        return min;\n    }\n\n    \n    private static int[] inverse(final int[] indices) {\n        int[] inverse = new int[indices.length];\n        for (int i = 0; i < indices.length; i++) {\n            inverse[indices[i]] = i;\n        }\n        return inverse;\n    }\n\n    \n    private static int[] reverse(final int[] indices) {\n        int[] reverse = new int[indices.length];\n        for (int i = 0; i < indices.length; i++) {\n            reverse[i] = indices[indices.length - i - 1];\n        }\n        return reverse;\n    }\n\n    \n    private double[] randn(int size) {\n        double[] randn = new double[size];\n        for (int i = 0; i < size; i++) {\n            randn[i] = random.nextGaussian();\n        }\n        return randn;\n    }\n\n    \n    private RealMatrix randn1(int size, int popSize) {\n        double[][] d = new double[size][popSize];\n        for (int r = 0; r < size; r++) {\n            for (int c = 0; c < popSize; c++) {\n                d[r][c] = random.nextGaussian();\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}\n",
      "buggy_signatures": [
        "public CMAESOptimizer(int lambda)",
        "public CMAESOptimizer(int lambda, double[] inputSigma)",
        "public CMAESOptimizer(int lambda, double[] inputSigma, int maxIterations, double stopFitness, boolean isActiveCMA, int diagonalOnly, int checkFeasableCount, RandomGenerator random, boolean generateStatistics)",
        "public CMAESOptimizer(int lambda, double[] inputSigma, int maxIterations, double stopFitness, boolean isActiveCMA, int diagonalOnly, int checkFeasableCount, RandomGenerator random, boolean generateStatistics, ConvergenceChecker<PointValuePair> checker)",
        "public List<Double> getStatisticsSigmaHistory()",
        "public List<RealMatrix> getStatisticsMeanHistory()",
        "public List<Double> getStatisticsFitnessHistory()",
        "public List<RealMatrix> getStatisticsDHistory()",
        "protected PointValuePair doOptimize()",
        "private void checkParameters()",
        "private void initializeCMA(double[] guess)",
        "private boolean updateEvolutionPaths(RealMatrix zmean, RealMatrix xold)",
        "private void updateCovarianceDiagonalOnly(boolean hsig, final RealMatrix bestArz, final RealMatrix xold)",
        "private void updateCovariance(boolean hsig, final RealMatrix bestArx, final RealMatrix arz, final int[] arindex, final RealMatrix xold)",
        "private void updateBD(double negccov)",
        "private static void push(double[] vals, double val)",
        "private int[] sortedIndices(final double[] doubles)",
        "private static class DoubleIndex implements Comparable<DoubleIndex> { private double value; private int index; DoubleIndex(double value, int index)",
        "public int compareTo(DoubleIndex o)",
        "public boolean equals(Object other)",
        "public int hashCode()",
        "private class FitnessFunction { private double valueRange; private boolean isRepairMode; public FitnessFunction()",
        "public double[] encode(final double[] x)",
        "public double[] repairAndDecode(final double[] x)",
        "public double[] decode(final double[] x)",
        "public double value(final double[] point)",
        "public boolean isFeasible(final double[] x)",
        "public void setValueRange(double valueRange)",
        "private double[] repair(final double[] x)",
        "private double penalty(final double[] x, final double[] repaired)",
        "private static RealMatrix log(final RealMatrix m)",
        "private static RealMatrix sqrt(final RealMatrix m)",
        "private static RealMatrix square(final RealMatrix m)",
        "private static RealMatrix times(final RealMatrix m, final RealMatrix n)",
        "private static RealMatrix divide(final RealMatrix m, final RealMatrix n)",
        "private static RealMatrix selectColumns(final RealMatrix m, final int[] cols)",
        "private static RealMatrix triu(final RealMatrix m, int k)",
        "private static RealMatrix sumRows(final RealMatrix m)",
        "private static RealMatrix diag(final RealMatrix m)",
        "private static void copyColumn(final RealMatrix m1, int col1, RealMatrix m2, int col2)",
        "private static RealMatrix ones(int n, int m)",
        "private static RealMatrix eye(int n, int m)",
        "private static RealMatrix zeros(int n, int m)",
        "private static RealMatrix repmat(final RealMatrix mat, int n, int m)",
        "private static RealMatrix sequence(double start, double end, double step)",
        "private static double max(final RealMatrix m)",
        "private static double min(final RealMatrix m)",
        "private static double max(final double[] m)",
        "private static double min(final double[] m)",
        "private static int[] inverse(final int[] indices)",
        "private static int[] reverse(final int[] indices)",
        "private double[] randn(int size)",
        "private RealMatrix randn1(int size, int popSize)"
      ],
      "fixed_signatures": [
        "public CMAESOptimizer(int lambda)",
        "public CMAESOptimizer(int lambda, double[] inputSigma)",
        "public CMAESOptimizer(int lambda, double[] inputSigma, int maxIterations, double stopFitness, boolean isActiveCMA, int diagonalOnly, int checkFeasableCount, RandomGenerator random, boolean generateStatistics)",
        "public CMAESOptimizer(int lambda, double[] inputSigma, int maxIterations, double stopFitness, boolean isActiveCMA, int diagonalOnly, int checkFeasableCount, RandomGenerator random, boolean generateStatistics, ConvergenceChecker<PointValuePair> checker)",
        "public List<Double> getStatisticsSigmaHistory()",
        "public List<RealMatrix> getStatisticsMeanHistory()",
        "public List<Double> getStatisticsFitnessHistory()",
        "public List<RealMatrix> getStatisticsDHistory()",
        "protected PointValuePair doOptimize()",
        "private void checkParameters()",
        "private void initializeCMA(double[] guess)",
        "private boolean updateEvolutionPaths(RealMatrix zmean, RealMatrix xold)",
        "private void updateCovarianceDiagonalOnly(boolean hsig, final RealMatrix bestArz, final RealMatrix xold)",
        "private void updateCovariance(boolean hsig, final RealMatrix bestArx, final RealMatrix arz, final int[] arindex, final RealMatrix xold)",
        "private void updateBD(double negccov)",
        "private static void push(double[] vals, double val)",
        "private int[] sortedIndices(final double[] doubles)",
        "private static class DoubleIndex implements Comparable<DoubleIndex> { private double value; private int index; DoubleIndex(double value, int index)",
        "public int compareTo(DoubleIndex o)",
        "public boolean equals(Object other)",
        "public int hashCode()",
        "private class FitnessFunction { private double valueRange; private boolean isRepairMode; public FitnessFunction()",
        "public double[] encode(final double[] x)",
        "public double[] repairAndDecode(final double[] x)",
        "public double[] decode(final double[] x)",
        "public double value(final double[] point)",
        "public boolean isFeasible(final double[] x)",
        "public void setValueRange(double valueRange)",
        "private double[] repair(final double[] x)",
        "private double penalty(final double[] x, final double[] repaired)",
        "private static RealMatrix log(final RealMatrix m)",
        "private static RealMatrix sqrt(final RealMatrix m)",
        "private static RealMatrix square(final RealMatrix m)",
        "private static RealMatrix times(final RealMatrix m, final RealMatrix n)",
        "private static RealMatrix divide(final RealMatrix m, final RealMatrix n)",
        "private static RealMatrix selectColumns(final RealMatrix m, final int[] cols)",
        "private static RealMatrix triu(final RealMatrix m, int k)",
        "private static RealMatrix sumRows(final RealMatrix m)",
        "private static RealMatrix diag(final RealMatrix m)",
        "private static void copyColumn(final RealMatrix m1, int col1, RealMatrix m2, int col2)",
        "private static RealMatrix ones(int n, int m)",
        "private static RealMatrix eye(int n, int m)",
        "private static RealMatrix zeros(int n, int m)",
        "private static RealMatrix repmat(final RealMatrix mat, int n, int m)",
        "private static RealMatrix sequence(double start, double end, double step)",
        "private static double max(final RealMatrix m)",
        "private static double min(final RealMatrix m)",
        "private static double max(final double[] m)",
        "private static double min(final double[] m)",
        "private static int[] inverse(final int[] indices)",
        "private static int[] reverse(final int[] indices)",
        "private double[] randn(int size)",
        "private RealMatrix randn1(int size, int popSize)"
      ],
      "methods": [
        {
          "buggy_method": "  public double[] encode(final double[] x) {\n  if (boundaries == null) {\n  return x;\n  }\n  double[] res = new double[x.length];\n  for (int i = 0; i < x.length; i++) {\n  double diff = boundaries[1][i] - boundaries[0][i];\n  res[i] = (x[i] - boundaries[0][i]) / diff;\n  }\n  return res;\n  }",
          "fixed_method": "  public double[] encode(final double[] x) {\n  if (boundaries == null) {\n  return x;\n  }\n  double[] res = new double[x.length];\n  for (int i = 0; i < x.length; i++) {\n  double diff = boundaries[1][i] - boundaries[0][i];\n  res[i] = x[i] / diff;\n  }\n  return res;\n  }",
          "diff": [
            "@@ -929,7 +929,7 @@",
            "             double[] res = new double[x.length];\n",
            "             for (int i = 0; i < x.length; i++) {\n",
            "                 double diff = boundaries[1][i] - boundaries[0][i];\n",
            "-                res[i] = (x[i] - boundaries[0][i]) / diff;\n",
            "+                res[i] = x[i] / diff;\n",
            "             }\n",
            "             return res;\n",
            "         }\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  public double[] decode(final double[] x) {\n  if (boundaries == null) {\n  return x;\n  }\n  double[] res = new double[x.length];\n  for (int i = 0; i < x.length; i++) {\n  double diff = boundaries[1][i] - boundaries[0][i];\n  res[i] = diff * x[i] + boundaries[0][i];\n  }\n  return res;\n  }",
          "fixed_method": "  public double[] decode(final double[] x) {\n  if (boundaries == null) {\n  return x;\n  }\n  double[] res = new double[x.length];\n  for (int i = 0; i < x.length; i++) {\n  double diff = boundaries[1][i] - boundaries[0][i];\n  res[i] = diff * x[i];\n  }\n  return res;\n  }",
          "diff": [
            "@@ -955,7 +955,7 @@",
            "             double[] res = new double[x.length];\n",
            "             for (int i = 0; i < x.length; i++) {\n",
            "                 double diff = boundaries[1][i] - boundaries[0][i];\n",
            "-                res[i] = diff * x[i] + boundaries[0][i];\n",
            "+                res[i] = diff * x[i];\n",
            "             }\n",
            "             return res;\n",
            "         }\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  public boolean isFeasible(final double[] x) {\n  if (boundaries == null) {\n  return true;\n  }\n\n\n  for (int i = 0; i < x.length; i++) {\n  if (x[i] < 0) {\n  return false;\n  }\n  if (x[i] > 1.0) {\n  return false;\n  }\n  }\n  return true;\n  }",
          "fixed_method": "  public boolean isFeasible(final double[] x) {\n  if (boundaries == null) {\n  return true;\n  }\n\n  final double[] bLoEnc = encode(boundaries[0]);\n  final double[] bHiEnc = encode(boundaries[1]);\n\n  for (int i = 0; i < x.length; i++) {\n  if (x[i] < bLoEnc[i]) {\n  return false;\n  }\n  if (x[i] > bHiEnc[i]) {\n  return false;\n  }\n  }\n  return true;\n  }",
          "diff": [
            "@@ -987,12 +987,14 @@",
            "                 return true;\n",
            "             }\n",
            " \n",
            "+            final double[] bLoEnc = encode(boundaries[0]);\n",
            "+            final double[] bHiEnc = encode(boundaries[1]);\n",
            " \n",
            "             for (int i = 0; i < x.length; i++) {\n",
            "-                if (x[i] < 0) {\n",
            "+                if (x[i] < bLoEnc[i]) {\n",
            "                     return false;\n",
            "                 }\n",
            "-                if (x[i] > 1.0) {\n",
            "+                if (x[i] > bHiEnc[i]) {\n",
            "                     return false;\n",
            "                 }\n",
            "             }\n"
          ],
          "changed_lines": 6
        }
      ]
    }
  ]
}
