{
  "bug_id": "78",
  "failed_tests": {
    "org.apache.commons.math.ode.events.EventStateTest": [
      {
        "methodName": "closeEvents",
        "error": "org.apache.commons.math.MathRuntimeException$4",
        "message": "function values at endpoints do not have different signs.  Endpoints: [89.999, 153.1], Values: [-0.066, -1,142.11]",
        "fail_line": "        Assert.assertTrue(es.evaluateStep(interpolator));",
        "test_source": "  public void closeEvents() throws EventException, ConvergenceException, DerivativeException {\n\n  final double r1  = 90.0;\n  final double r2  = 135.0;\n  final double gap = r2 - r1;\n  EventHandler closeEventsGenerator = new EventHandler() {\n  public void resetState(double t, double[] y) {\n  }\n  public double g(double t, double[] y) {\n  return (t - r1) * (r2 - t);\n  }\n  public int eventOccurred(double t, double[] y, boolean increasing) {\n  return CONTINUE;\n  }\n  };\n\n  final double tolerance = 0.1;\n  EventState es = new EventState(closeEventsGenerator, 1.5 * gap, tolerance, 10);\n\n  double t0 = r1 - 0.5 * gap;\n  es.reinitializeBegin(t0, new double[0]);\n  AbstractStepInterpolator interpolator =\n  new DummyStepInterpolator(new double[0], true);\n  interpolator.storeTime(t0);\n\n  interpolator.shift();\n  interpolator.storeTime(0.5 * (r1 + r2));\n  Assert.assertTrue(es.evaluateStep(interpolator));\n  Assert.assertEquals(r1, es.getEventTime(), tolerance);\n  es.stepAccepted(es.getEventTime(), new double[0]);\n\n  interpolator.shift();\n  interpolator.storeTime(r2 + 0.4 * gap);\n  Assert.assertTrue(es.evaluateStep(interpolator));\n  Assert.assertEquals(r2, es.getEventTime(), tolerance);\n\n  }",
        "stack": [
          "MathRuntimeException.createIllegalArgumentException line 305, BrentSolver.solve line 178, EventState.evaluateStep line 218, EventStateTest.closeEvents line 66"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/ode/events/EventState.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.ode.events;\n\nimport org.apache.commons.math.ConvergenceException;\nimport org.apache.commons.math.FunctionEvaluationException;\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.analysis.UnivariateRealFunction;\nimport org.apache.commons.math.analysis.solvers.BrentSolver;\nimport org.apache.commons.math.ode.DerivativeException;\nimport org.apache.commons.math.ode.sampling.StepInterpolator;\n\n\npublic class EventState { private final EventHandler handler; private final double maxCheckInterval; private final double convergence; private final int maxIterationCount; private double t0; private double g0; private boolean g0Positive; private boolean pendingEvent; private double pendingEventTime; private double previousEventTime; private boolean forward; private boolean increasing; private int nextAction; public EventState(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount) {\n        this.handler           = handler;\n        this.maxCheckInterval  = maxCheckInterval;\n        this.convergence       = Math.abs(convergence);\n        this.maxIterationCount = maxIterationCount;\n\n        \n        t0                = Double.NaN;\n        g0                = Double.NaN;\n        g0Positive        = true;\n        pendingEvent      = false;\n        pendingEventTime  = Double.NaN;\n        previousEventTime = Double.NaN;\n        increasing        = true;\n        nextAction        = EventHandler.CONTINUE;\n\n    }\n\n    \n    public EventHandler getEventHandler() {\n        return handler;\n    }\n\n    \n    public double getMaxCheckInterval() {\n        return maxCheckInterval;\n    }\n\n    \n    public double getConvergence() {\n        return convergence;\n    }\n\n    \n    public int getMaxIterationCount() {\n        return maxIterationCount;\n    }\n\n    \n    public void reinitializeBegin(final double tStart, final double[] yStart) throws EventException {\n        t0 = tStart;\n        g0 = handler.g(tStart, yStart);\n        g0Positive = g0 >= 0;\n    }\n\n    \n    public boolean evaluateStep(final StepInterpolator interpolator) throws DerivativeException, EventException, ConvergenceException {\n\n        try {\n\n            forward = interpolator.isForward();\n            final double t1 = interpolator.getCurrentTime();\n            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n            final double h  = (t1 - t0) / n;\n\n            double ta = t0;\n            double ga = g0;\n            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);\n            for (int i = 0; i < n; ++i) {\n\n                \n                tb += h;\n                interpolator.setInterpolatedTime(tb);\n                final double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n                \n                if (g0Positive ^ (gb >= 0)) {\n                    \n\n                        \n                        \n                        \n                        \n                        \n                        \n                        \n                            \n                         \n                    \n                    increasing = gb >= ga;\n\n                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n                        public double value(final double t) throws FunctionEvaluationException {\n                            try {\n                                interpolator.setInterpolatedTime(t);\n                                return handler.g(t, interpolator.getInterpolatedState());\n                            } catch (DerivativeException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            } catch (EventException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            }\n                        }\n                    };\n                    final BrentSolver solver = new BrentSolver();\n                    solver.setAbsoluteAccuracy(convergence);\n                    solver.setMaximalIterationCount(maxIterationCount);\n                    final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n                    if ((Math.abs(root - ta) <= convergence) &&\n                         (Math.abs(root - previousEventTime) <= convergence)) {\n                        \n                        ta = tb;\n                        ga = gb;\n                    } else if (Double.isNaN(previousEventTime) ||\n                               (Math.abs(previousEventTime - root) > convergence)) {\n                        pendingEventTime = root;\n                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n                            \n                            \n                            \n                            \n                            return false;\n                        }\n                        \n                        \n                        pendingEvent = true;\n                        return true;\n                    }\n\n                } else {\n                    \n                    ta = tb;\n                    ga = gb;\n                }\n\n            }\n\n            \n            pendingEvent     = false;\n            pendingEventTime = Double.NaN;\n            return false;\n\n        } catch (FunctionEvaluationException e) {\n            final Throwable cause = e.getCause();\n            if ((cause != null) && (cause instanceof DerivativeException)) {\n                throw (DerivativeException) cause;\n            } else if ((cause != null) && (cause instanceof EventException)) {\n                throw (EventException) cause;\n            }\n            throw new EventException(e);\n        }\n\n    }\n\n    \n    public double getEventTime() {\n        return pendingEventTime;\n    }\n\n    \n    public void stepAccepted(final double t, final double[] y) throws EventException {\n\n        t0 = t;\n        g0 = handler.g(t, y);\n\n        if (pendingEvent) {\n            \n            previousEventTime = t;\n            g0Positive        = increasing;\n            nextAction        = handler.eventOccurred(t, y, !(increasing ^ forward));\n        } else {\n            g0Positive = g0 >= 0;\n            nextAction = EventHandler.CONTINUE;\n        }\n    }\n\n    \n    public boolean stop() {\n        return nextAction == EventHandler.STOP;\n    }\n\n    \n    public boolean reset(final double t, final double[] y) throws EventException {\n\n        if (! pendingEvent) {\n            return false;\n        }\n\n        if (nextAction == EventHandler.RESET_STATE) {\n            handler.resetState(t, y);\n        }\n        pendingEvent      = false;\n        pendingEventTime  = Double.NaN;\n\n        return (nextAction == EventHandler.RESET_STATE) ||\n               (nextAction == EventHandler.RESET_DERIVATIVES);\n\n    }\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.ode.events;\n\nimport org.apache.commons.math.ConvergenceException;\nimport org.apache.commons.math.FunctionEvaluationException;\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.analysis.UnivariateRealFunction;\nimport org.apache.commons.math.analysis.solvers.BrentSolver;\nimport org.apache.commons.math.ode.DerivativeException;\nimport org.apache.commons.math.ode.sampling.StepInterpolator;\n\n\npublic class EventState { private final EventHandler handler; private final double maxCheckInterval; private final double convergence; private final int maxIterationCount; private double t0; private double g0; private boolean g0Positive; private boolean pendingEvent; private double pendingEventTime; private double previousEventTime; private boolean forward; private boolean increasing; private int nextAction; public EventState(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount) {\n        this.handler           = handler;\n        this.maxCheckInterval  = maxCheckInterval;\n        this.convergence       = Math.abs(convergence);\n        this.maxIterationCount = maxIterationCount;\n\n        \n        t0                = Double.NaN;\n        g0                = Double.NaN;\n        g0Positive        = true;\n        pendingEvent      = false;\n        pendingEventTime  = Double.NaN;\n        previousEventTime = Double.NaN;\n        increasing        = true;\n        nextAction        = EventHandler.CONTINUE;\n\n    }\n\n    \n    public EventHandler getEventHandler() {\n        return handler;\n    }\n\n    \n    public double getMaxCheckInterval() {\n        return maxCheckInterval;\n    }\n\n    \n    public double getConvergence() {\n        return convergence;\n    }\n\n    \n    public int getMaxIterationCount() {\n        return maxIterationCount;\n    }\n\n    \n    public void reinitializeBegin(final double tStart, final double[] yStart) throws EventException {\n        t0 = tStart;\n        g0 = handler.g(tStart, yStart);\n        g0Positive = g0 >= 0;\n    }\n\n    \n    public boolean evaluateStep(final StepInterpolator interpolator) throws DerivativeException, EventException, ConvergenceException {\n\n        try {\n\n            forward = interpolator.isForward();\n            final double t1 = interpolator.getCurrentTime();\n            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n            final double h  = (t1 - t0) / n;\n\n            double ta = t0;\n            double ga = g0;\n            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);\n            for (int i = 0; i < n; ++i) {\n\n                \n                tb += h;\n                interpolator.setInterpolatedTime(tb);\n                final double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n                \n                if (g0Positive ^ (gb >= 0)) {\n                    \n\n                    if (ga * gb > 0) {\n                        \n                        \n                        \n                        \n                        \n                        \n                        \n                        final double epsilon = (forward ? 0.25 : -0.25) * convergence;\n                        for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n                            ta += epsilon;\n                            interpolator.setInterpolatedTime(ta);\n                            ga = handler.g(ta, interpolator.getInterpolatedState());\n                        }\n                        if (ga * gb > 0) {\n                            \n                            throw MathRuntimeException.createInternalError(null);\n                        }\n                    }\n                         \n                    \n                    increasing = gb >= ga;\n\n                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n                        public double value(final double t) throws FunctionEvaluationException {\n                            try {\n                                interpolator.setInterpolatedTime(t);\n                                return handler.g(t, interpolator.getInterpolatedState());\n                            } catch (DerivativeException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            } catch (EventException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            }\n                        }\n                    };\n                    final BrentSolver solver = new BrentSolver();\n                    solver.setAbsoluteAccuracy(convergence);\n                    solver.setMaximalIterationCount(maxIterationCount);\n                    final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n                    if ((Math.abs(root - ta) <= convergence) &&\n                         (Math.abs(root - previousEventTime) <= convergence)) {\n                        \n                        ta = tb;\n                        ga = gb;\n                    } else if (Double.isNaN(previousEventTime) ||\n                               (Math.abs(previousEventTime - root) > convergence)) {\n                        pendingEventTime = root;\n                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n                            \n                            \n                            \n                            \n                            return false;\n                        }\n                        \n                        \n                        pendingEvent = true;\n                        return true;\n                    }\n\n                } else {\n                    \n                    ta = tb;\n                    ga = gb;\n                }\n\n            }\n\n            \n            pendingEvent     = false;\n            pendingEventTime = Double.NaN;\n            return false;\n\n        } catch (FunctionEvaluationException e) {\n            final Throwable cause = e.getCause();\n            if ((cause != null) && (cause instanceof DerivativeException)) {\n                throw (DerivativeException) cause;\n            } else if ((cause != null) && (cause instanceof EventException)) {\n                throw (EventException) cause;\n            }\n            throw new EventException(e);\n        }\n\n    }\n\n    \n    public double getEventTime() {\n        return pendingEventTime;\n    }\n\n    \n    public void stepAccepted(final double t, final double[] y) throws EventException {\n\n        t0 = t;\n        g0 = handler.g(t, y);\n\n        if (pendingEvent) {\n            \n            previousEventTime = t;\n            g0Positive        = increasing;\n            nextAction        = handler.eventOccurred(t, y, !(increasing ^ forward));\n        } else {\n            g0Positive = g0 >= 0;\n            nextAction = EventHandler.CONTINUE;\n        }\n    }\n\n    \n    public boolean stop() {\n        return nextAction == EventHandler.STOP;\n    }\n\n    \n    public boolean reset(final double t, final double[] y) throws EventException {\n\n        if (! pendingEvent) {\n            return false;\n        }\n\n        if (nextAction == EventHandler.RESET_STATE) {\n            handler.resetState(t, y);\n        }\n        pendingEvent      = false;\n        pendingEventTime  = Double.NaN;\n\n        return (nextAction == EventHandler.RESET_STATE) ||\n               (nextAction == EventHandler.RESET_DERIVATIVES);\n\n    }\n\n}\n",
      "buggy_signatures": [
        "public class EventState { private final EventHandler handler; private final double maxCheckInterval; private final double convergence; private final int maxIterationCount; private double t0; private double g0; private boolean g0Positive; private boolean pendingEvent; private double pendingEventTime; private double previousEventTime; private boolean forward; private boolean increasing; private int nextAction; public EventState(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount)",
        "public EventHandler getEventHandler()",
        "public double getMaxCheckInterval()",
        "public double getConvergence()",
        "public int getMaxIterationCount()",
        "public void reinitializeBegin(final double tStart, final double[] yStart) throws EventException",
        "public boolean evaluateStep(final StepInterpolator interpolator) throws DerivativeException, EventException, ConvergenceException",
        "public double value(final double t) throws FunctionEvaluationException",
        "public double getEventTime()",
        "public void stepAccepted(final double t, final double[] y) throws EventException",
        "public boolean stop()",
        "public boolean reset(final double t, final double[] y) throws EventException"
      ],
      "fixed_signatures": [
        "public class EventState { private final EventHandler handler; private final double maxCheckInterval; private final double convergence; private final int maxIterationCount; private double t0; private double g0; private boolean g0Positive; private boolean pendingEvent; private double pendingEventTime; private double previousEventTime; private boolean forward; private boolean increasing; private int nextAction; public EventState(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount)",
        "public EventHandler getEventHandler()",
        "public double getMaxCheckInterval()",
        "public double getConvergence()",
        "public int getMaxIterationCount()",
        "public void reinitializeBegin(final double tStart, final double[] yStart) throws EventException",
        "public boolean evaluateStep(final StepInterpolator interpolator) throws DerivativeException, EventException, ConvergenceException",
        "public double value(final double t) throws FunctionEvaluationException",
        "public double getEventTime()",
        "public void stepAccepted(final double t, final double[] y) throws EventException",
        "public boolean stop()",
        "public boolean reset(final double t, final double[] y) throws EventException"
      ],
      "methods": [
        {
          "buggy_method": "  public boolean evaluateStep(final StepInterpolator interpolator) throws DerivativeException, EventException, ConvergenceException {\n\n  try {\n\n  forward = interpolator.isForward();\n  final double t1 = interpolator.getCurrentTime();\n  final int  n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n  final double h  = (t1 - t0) / n;\n\n  double ta = t0;\n  double ga = g0;\n  double tb = t0 + (interpolator.isForward() ? convergence : -convergence);\n  for (int i = 0; i < n; ++i) {\n\n  \n  tb += h;\n  interpolator.setInterpolatedTime(tb);\n  final double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n  \n  if (g0Positive ^ (gb >= 0)) {\n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  increasing = gb >= ga;\n\n  final UnivariateRealFunction f = new UnivariateRealFunction() {\n  public double value(final double t) throws FunctionEvaluationException {\n  try {\n  interpolator.setInterpolatedTime(t);\n  return handler.g(t, interpolator.getInterpolatedState());\n  } catch (DerivativeException e) {\n  throw new FunctionEvaluationException(e, t);\n  } catch (EventException e) {\n  throw new FunctionEvaluationException(e, t);\n  }\n  }\n  };\n  final BrentSolver solver = new BrentSolver();\n  solver.setAbsoluteAccuracy(convergence);\n  solver.setMaximalIterationCount(maxIterationCount);\n  final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n  if ((Math.abs(root - ta) <= convergence) &&\n  (Math.abs(root - previousEventTime) <= convergence)) {\n  \n  ta = tb;\n  ga = gb;\n  } else if (Double.isNaN(previousEventTime) ||\n  (Math.abs(previousEventTime - root) > convergence)) {\n  pendingEventTime = root;\n  if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  \n  \n  \n  \n  return false;\n  }\n  \n  \n  pendingEvent = true;\n  return true;\n  }\n\n  } else {\n  \n  ta = tb;\n  ga = gb;\n  }\n\n  }\n\n  \n  pendingEvent  = false;\n  pendingEventTime = Double.NaN;\n  return false;\n\n  } catch (FunctionEvaluationException e) {\n  final Throwable cause = e.getCause();\n  if ((cause != null) && (cause instanceof DerivativeException)) {\n  throw (DerivativeException) cause;\n  } else if ((cause != null) && (cause instanceof EventException)) {\n  throw (EventException) cause;\n  }\n  throw new EventException(e);\n  }\n\n  }",
          "fixed_method": "  public boolean evaluateStep(final StepInterpolator interpolator) throws DerivativeException, EventException, ConvergenceException {\n\n  try {\n\n  forward = interpolator.isForward();\n  final double t1 = interpolator.getCurrentTime();\n  final int  n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n  final double h  = (t1 - t0) / n;\n\n  double ta = t0;\n  double ga = g0;\n  double tb = t0 + (interpolator.isForward() ? convergence : -convergence);\n  for (int i = 0; i < n; ++i) {\n\n  \n  tb += h;\n  interpolator.setInterpolatedTime(tb);\n  final double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n  \n  if (g0Positive ^ (gb >= 0)) {\n  \n\n  if (ga * gb > 0) {\n  \n  \n  \n  \n  \n  \n  \n  final double epsilon = (forward ? 0.25 : -0.25) * convergence;\n  for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n  ta += epsilon;\n  interpolator.setInterpolatedTime(ta);\n  ga = handler.g(ta, interpolator.getInterpolatedState());\n  }\n  if (ga * gb > 0) {\n  \n  throw MathRuntimeException.createInternalError(null);\n  }\n  }\n  \n  \n  increasing = gb >= ga;\n\n  final UnivariateRealFunction f = new UnivariateRealFunction() {\n  public double value(final double t) throws FunctionEvaluationException {\n  try {\n  interpolator.setInterpolatedTime(t);\n  return handler.g(t, interpolator.getInterpolatedState());\n  } catch (DerivativeException e) {\n  throw new FunctionEvaluationException(e, t);\n  } catch (EventException e) {\n  throw new FunctionEvaluationException(e, t);\n  }\n  }\n  };\n  final BrentSolver solver = new BrentSolver();\n  solver.setAbsoluteAccuracy(convergence);\n  solver.setMaximalIterationCount(maxIterationCount);\n  final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n  if ((Math.abs(root - ta) <= convergence) &&\n  (Math.abs(root - previousEventTime) <= convergence)) {\n  \n  ta = tb;\n  ga = gb;\n  } else if (Double.isNaN(previousEventTime) ||\n  (Math.abs(previousEventTime - root) > convergence)) {\n  pendingEventTime = root;\n  if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  \n  \n  \n  \n  return false;\n  }\n  \n  \n  pendingEvent = true;\n  return true;\n  }\n\n  } else {\n  \n  ta = tb;\n  ga = gb;\n  }\n\n  }\n\n  \n  pendingEvent  = false;\n  pendingEventTime = Double.NaN;\n  return false;\n\n  } catch (FunctionEvaluationException e) {\n  final Throwable cause = e.getCause();\n  if ((cause != null) && (cause instanceof DerivativeException)) {\n  throw (DerivativeException) cause;\n  } else if ((cause != null) && (cause instanceof EventException)) {\n  throw (EventException) cause;\n  }\n  throw new EventException(e);\n  }\n\n  }",
          "diff": [
            "@@ -188,6 +188,7 @@",
            "                 if (g0Positive ^ (gb >= 0)) {\n",
            "                     // there is a sign change: an event is expected during this step\n",
            " \n",
            "+                    if (ga * gb > 0) {\n",
            "                         // this is a corner case:\n",
            "                         // - there was an event near ta,\n",
            "                         // - there is another event between ta and tb\n",
            "@@ -195,7 +196,17 @@",
            "                         // this implies that the real sign of ga is the same as gb, so we need to slightly\n",
            "                         // shift ta to make sure ga and gb get opposite signs and the solver won't complain\n",
            "                         // about bracketing\n",
            "+                        final double epsilon = (forward ? 0.25 : -0.25) * convergence;\n",
            "+                        for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n",
            "+                            ta += epsilon;\n",
            "+                            interpolator.setInterpolatedTime(ta);\n",
            "+                            ga = handler.g(ta, interpolator.getInterpolatedState());\n",
            "+                        }\n",
            "+                        if (ga * gb > 0) {\n",
            "                             // this should never happen\n",
            "+                            throw MathRuntimeException.createInternalError(null);\n",
            "+                        }\n",
            "+                    }\n",
            "                          \n",
            "                     // variation direction, with respect to the integration direction\n",
            "                     increasing = gb >= ga;\n"
          ],
          "changed_lines": 11
        }
      ]
    }
  ]
}
