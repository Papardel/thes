{
  "bug_id": "7",
  "failed_tests": {
    "org.apache.commons.csv.CSVParserTest": [
      {
        "methodName": "testDuplicateHeaderEntries",
        "error": "junit.framework.AssertionFailedError",
        "message": "Expected exception: java.lang.IllegalStateException",
        "fail_line": "",
        "test_source": "  public void testDuplicateHeaderEntries() throws Exception {\n  CSVParser.parse(\"a,b,a\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(new String[]{}));\n  }",
        "stack": [
          ""
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/csv/CSVParser.java",
      "buggy_full_code": "\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN; import java.io.Closeable; import java.io.File; import java.io.FileReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.Reader; import java.io.StringReader; import java.net.URL; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.List; import java.util.Map; import java.util.NoSuchElementException; public final class CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final File file, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new FileReader(file), format);\n    }\n\n    \n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    \n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    \n\n    private final CSVFormat format; private final Map<String, Integer> headerMap; private final Lexer lexer; private final List<String> record = new ArrayList<String>(); private long recordNumber; private final Token reusableToken = new Token(); public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        format.validate();\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.headerMap = this.initializeHeader();\n    }\n\n    private void addRecordValue() {\n        final String input = this.reusableToken.content.toString();\n        final String nullString = this.format.getNullString();\n        if (nullString == null) {\n            this.record.add(input);\n        } else {\n            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n        }\n    }\n\n    \n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    \n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    \n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n\n    \n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    \n    public List<CSVRecord> getRecords() throws IOException {\n        return getRecords(new ArrayList<CSVRecord>());\n    }\n\n    \n    public <T extends Collection<CSVRecord>> T getRecords(T records) throws IOException {\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    \n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] header = null;\n            if (formatHeader.length == 0) {\n                \n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    header = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                header = formatHeader;\n            }\n\n            \n            if (header != null) {\n                for (int i = 0; i < header.length; i++) {\n                    hdrMap.put(header[i], Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    \n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current; private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    \n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    \n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n\n    \n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.record.clear();\n        StringBuilder sb = null;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: \n                if (sb == null) { \n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; \n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.record.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n                    this.recordNumber);\n        }\n        return result;\n    }\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN; import java.io.Closeable; import java.io.File; import java.io.FileReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.Reader; import java.io.StringReader; import java.net.URL; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.List; import java.util.Map; import java.util.NoSuchElementException; public final class CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final File file, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new FileReader(file), format);\n    }\n\n    \n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    \n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    \n\n    private final CSVFormat format; private final Map<String, Integer> headerMap; private final Lexer lexer; private final List<String> record = new ArrayList<String>(); private long recordNumber; private final Token reusableToken = new Token(); public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        format.validate();\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.headerMap = this.initializeHeader();\n    }\n\n    private void addRecordValue() {\n        final String input = this.reusableToken.content.toString();\n        final String nullString = this.format.getNullString();\n        if (nullString == null) {\n            this.record.add(input);\n        } else {\n            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n        }\n    }\n\n    \n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    \n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    \n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n\n    \n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    \n    public List<CSVRecord> getRecords() throws IOException {\n        return getRecords(new ArrayList<CSVRecord>());\n    }\n\n    \n    public <T extends Collection<CSVRecord>> T getRecords(T records) throws IOException {\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    \n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] header = null;\n            if (formatHeader.length == 0) {\n                \n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    header = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                header = formatHeader;\n            }\n\n            \n            if (header != null) {\n                for (int i = 0; i < header.length; i++) {\n                    if (hdrMap.containsKey(header[i])) {\n                        throw new IllegalStateException(\"The header contains duplicate names: \" + Arrays.toString(header));\n                    }\n                    hdrMap.put(header[i], Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    \n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current; private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    \n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    \n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n\n    \n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.record.clear();\n        StringBuilder sb = null;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: \n                if (sb == null) { \n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; \n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.record.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n                    this.recordNumber);\n        }\n        return result;\n    }\n\n}\n",
      "buggy_signatures": [
        "static org.apache.commons.csv.Token.Type.TOKEN; import java.io.Closeable; import java.io.File; import java.io.FileReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.Reader; import java.io.StringReader; import java.net.URL; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.List; import java.util.Map; import java.util.NoSuchElementException; public final class CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final File file, final CSVFormat format) throws IOException",
        "public static CSVParser parse(final String string, final CSVFormat format) throws IOException",
        "public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException",
        "private void addRecordValue()",
        "public void close() throws IOException",
        "public long getCurrentLineNumber()",
        "public Map<String, Integer> getHeaderMap()",
        "public long getRecordNumber()",
        "public List<CSVRecord> getRecords() throws IOException",
        "public <T extends Collection<CSVRecord>> T getRecords(T records) throws IOException",
        "private Map<String, Integer> initializeHeader() throws IOException",
        "public boolean isClosed()",
        "public Iterator<CSVRecord> iterator()",
        "private CSVRecord current; private CSVRecord getNextRecord()",
        "public boolean hasNext()",
        "public CSVRecord next()",
        "public void remove()"
      ],
      "fixed_signatures": [
        "static org.apache.commons.csv.Token.Type.TOKEN; import java.io.Closeable; import java.io.File; import java.io.FileReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.Reader; import java.io.StringReader; import java.net.URL; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.List; import java.util.Map; import java.util.NoSuchElementException; public final class CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final File file, final CSVFormat format) throws IOException",
        "public static CSVParser parse(final String string, final CSVFormat format) throws IOException",
        "public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException",
        "private void addRecordValue()",
        "public void close() throws IOException",
        "public long getCurrentLineNumber()",
        "public Map<String, Integer> getHeaderMap()",
        "public long getRecordNumber()",
        "public List<CSVRecord> getRecords() throws IOException",
        "public <T extends Collection<CSVRecord>> T getRecords(T records) throws IOException",
        "private Map<String, Integer> initializeHeader() throws IOException",
        "public boolean isClosed()",
        "public Iterator<CSVRecord> iterator()",
        "private CSVRecord current; private CSVRecord getNextRecord()",
        "public boolean hasNext()",
        "public CSVRecord next()",
        "public void remove()"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -29,6 +29,7 @@",
            " import java.net.URL;\n",
            " import java.nio.charset.Charset;\n",
            " import java.util.ArrayList;\n",
            "+import java.util.Arrays;\n",
            " import java.util.Collection;\n",
            " import java.util.Iterator;\n",
            " import java.util.LinkedHashMap;\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  private Map<String, Integer> initializeHeader() throws IOException {\n  Map<String, Integer> hdrMap = null;\n  final String[] formatHeader = this.format.getHeader();\n  if (formatHeader != null) {\n  hdrMap = new LinkedHashMap<String, Integer>();\n\n  String[] header = null;\n  if (formatHeader.length == 0) {\n  \n  final CSVRecord nextRecord = this.nextRecord();\n  if (nextRecord != null) {\n  header = nextRecord.values();\n  }\n  } else {\n  if (this.format.getSkipHeaderRecord()) {\n  this.nextRecord();\n  }\n  header = formatHeader;\n  }\n\n  \n  if (header != null) {\n  for (int i = 0; i < header.length; i++) {\n  hdrMap.put(header[i], Integer.valueOf(i));\n  }\n  }\n  }\n  return hdrMap;\n  }",
          "fixed_method": "  private Map<String, Integer> initializeHeader() throws IOException {\n  Map<String, Integer> hdrMap = null;\n  final String[] formatHeader = this.format.getHeader();\n  if (formatHeader != null) {\n  hdrMap = new LinkedHashMap<String, Integer>();\n\n  String[] header = null;\n  if (formatHeader.length == 0) {\n  \n  final CSVRecord nextRecord = this.nextRecord();\n  if (nextRecord != null) {\n  header = nextRecord.values();\n  }\n  } else {\n  if (this.format.getSkipHeaderRecord()) {\n  this.nextRecord();\n  }\n  header = formatHeader;\n  }\n\n  \n  if (header != null) {\n  for (int i = 0; i < header.length; i++) {\n  if (hdrMap.containsKey(header[i])) {\n  throw new IllegalStateException(\"The header contains duplicate names: \" + Arrays.toString(header));\n  }\n  hdrMap.put(header[i], Integer.valueOf(i));\n  }\n  }\n  }\n  return hdrMap;\n  }",
          "diff": [
            "@@ -368,6 +369,9 @@",
            "             // build the name to index mappings\n",
            "             if (header != null) {\n",
            "                 for (int i = 0; i < header.length; i++) {\n",
            "+                    if (hdrMap.containsKey(header[i])) {\n",
            "+                        throw new IllegalStateException(\"The header contains duplicate names: \" + Arrays.toString(header));\n",
            "+                    }\n",
            "                     hdrMap.put(header[i], Integer.valueOf(i));\n",
            "                 }\n",
            "             }\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
