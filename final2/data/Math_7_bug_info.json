{
  "bug_id": "7",
  "failed_tests": {
    "org.apache.commons.math3.ode.nonstiff.DormandPrince853IntegratorTest": [
      {
        "methodName": "testEventsScheduling",
        "error": "junit.framework.AssertionFailedError",
        "message": "",
        "fail_line": "      integ.integrate(sincos, t0, y0, t, y);",
        "test_source": "  public void testEventsScheduling() {\n\n  FirstOrderDifferentialEquations sincos = new FirstOrderDifferentialEquations() {\n\n  public int getDimension() {\n  return 2;\n  }\n\n  public void computeDerivatives(double t, double[] y, double[] yDot) {\n  yDot[0] =  y[1];\n  yDot[1] = -y[0];\n  }\n\n  };\n\n  SchedulingChecker sinChecker = new SchedulingChecker(0); // events at 0, PI, 2PI ...\n  SchedulingChecker cosChecker = new SchedulingChecker(1); // events at PI/2, 3PI/2, 5PI/2 ...\n\n  FirstOrderIntegrator integ =\n  new DormandPrince853Integrator(0.001, 1.0, 1.0e-12, 0.0);\n  integ.addEventHandler(sinChecker, 0.01, 1.0e-7, 100);\n  integ.addStepHandler(sinChecker);\n  integ.addEventHandler(cosChecker, 0.01, 1.0e-7, 100);\n  integ.addStepHandler(cosChecker);\n  double  t0 = 0.5;\n  double[] y0 = new double[] { FastMath.sin(t0), FastMath.cos(t0) };\n  double  t  = 10.0;\n  double[] y  = new double[2];\n  integ.integrate(sincos, t0, y0, t, y);\n\n  }",
        "stack": [
          "DormandPrince853IntegratorTest$SchedulingChecker.g line 389, EventState.evaluateStep line 224, AbstractIntegrator.acceptStep line 323, EmbeddedRungeKuttaIntegrator.integrate line 303, AbstractIntegrator.integrate line 228, DormandPrince853IntegratorTest.testEventsScheduling line 365"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math3/ode/AbstractIntegrator.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math3.ode;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\nimport org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver;\nimport org.apache.commons.math3.analysis.solvers.UnivariateSolver;\nimport org.apache.commons.math3.exception.DimensionMismatchException;\nimport org.apache.commons.math3.exception.MaxCountExceededException;\nimport org.apache.commons.math3.exception.NoBracketingException;\nimport org.apache.commons.math3.exception.NumberIsTooSmallException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.ode.events.EventHandler;\nimport org.apache.commons.math3.ode.events.EventState;\nimport org.apache.commons.math3.ode.sampling.AbstractStepInterpolator;\nimport org.apache.commons.math3.ode.sampling.StepHandler;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.util.Incrementor;\nimport org.apache.commons.math3.util.Precision;\n\n\npublic abstract class AbstractIntegrator implements FirstOrderIntegrator { protected Collection<StepHandler> stepHandlers; protected double stepStart; protected double stepSize; protected boolean isLastStep; protected boolean resetOccurred; private Collection<EventState> eventsStates; private boolean statesInitialized; private final String name; private Incrementor evaluations; private transient ExpandableStatefulODE expandable; public AbstractIntegrator(final String name) {\n        this.name = name;\n        stepHandlers = new ArrayList<StepHandler>();\n        stepStart = Double.NaN;\n        stepSize  = Double.NaN;\n        eventsStates = new ArrayList<EventState>();\n        statesInitialized = false;\n        evaluations = new Incrementor();\n        setMaxEvaluations(-1);\n        evaluations.resetCount();\n    }\n\n    \n    protected AbstractIntegrator() {\n        this(null);\n    }\n\n    \n    public String getName() {\n        return name;\n    }\n\n    \n    public void addStepHandler(final StepHandler handler) {\n        stepHandlers.add(handler);\n    }\n\n    \n    public Collection<StepHandler> getStepHandlers() {\n        return Collections.unmodifiableCollection(stepHandlers);\n    }\n\n    \n    public void clearStepHandlers() {\n        stepHandlers.clear();\n    }\n\n    \n    public void addEventHandler(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount) {\n        addEventHandler(handler, maxCheckInterval, convergence,\n                        maxIterationCount,\n                        new BracketingNthOrderBrentSolver(convergence, 5));\n    }\n\n    \n    public void addEventHandler(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount, final UnivariateSolver solver) {\n        eventsStates.add(new EventState(handler, maxCheckInterval, convergence,\n                                        maxIterationCount, solver));\n    }\n\n    \n    public Collection<EventHandler> getEventHandlers() {\n        final List<EventHandler> list = new ArrayList<EventHandler>();\n        for (EventState state : eventsStates) {\n            list.add(state.getEventHandler());\n        }\n        return Collections.unmodifiableCollection(list);\n    }\n\n    \n    public void clearEventHandlers() {\n        eventsStates.clear();\n    }\n\n    \n    public double getCurrentStepStart() {\n        return stepStart;\n    }\n\n    \n    public double getCurrentSignedStepsize() {\n        return stepSize;\n    }\n\n    \n    public void setMaxEvaluations(int maxEvaluations) {\n        evaluations.setMaximalCount((maxEvaluations < 0) ? Integer.MAX_VALUE : maxEvaluations);\n    }\n\n    \n    public int getMaxEvaluations() {\n        return evaluations.getMaximalCount();\n    }\n\n    \n    public int getEvaluations() {\n        return evaluations.getCount();\n    }\n\n    \n    protected void initIntegration(final double t0, final double[] y0, final double t) {\n\n        evaluations.resetCount();\n\n        for (final EventState state : eventsStates) {\n            state.getEventHandler().init(t0, y0, t);\n        }\n\n        for (StepHandler handler : stepHandlers) {\n            handler.init(t0, y0, t);\n        }\n\n        setStateInitialized(false);\n\n    }\n\n    \n    protected void setEquations(final ExpandableStatefulODE equations) {\n        this.expandable = equations;\n    }\n\n    \n    public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {\n\n        if (y0.length != equations.getDimension()) {\n            throw new DimensionMismatchException(y0.length, equations.getDimension());\n        }\n        if (y.length != equations.getDimension()) {\n            throw new DimensionMismatchException(y.length, equations.getDimension());\n        }\n\n        \n        final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);\n        expandableODE.setTime(t0);\n        expandableODE.setPrimaryState(y0);\n\n        \n        integrate(expandableODE, t);\n\n        \n        System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);\n        return expandableODE.getTime();\n\n    }\n\n    \n    public abstract void integrate(ExpandableStatefulODE equations, double t) throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException; public void computeDerivatives(final double t, final double[] y, final double[] yDot) throws MaxCountExceededException, DimensionMismatchException {\n        evaluations.incrementCount();\n        expandable.computeDerivatives(t, y, yDot);\n    }\n\n    \n    protected void setStateInitialized(final boolean stateInitialized) {\n        this.statesInitialized = stateInitialized;\n    }\n\n    \n    protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            \n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            \n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                \n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    \n                    occuringEvents.add(state);\n                }\n            }\n\n            while (!occuringEvents.isEmpty()) {\n\n                \n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                \n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                \n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n\n                \n                currentEvent.stepAccepted(eventT, eventY);\n                isLastStep = currentEvent.stop();\n\n                \n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    \n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                    return eventT;\n                }\n\n                boolean needReset = currentEvent.reset(eventT, eventY);\n                if (needReset) {\n                    \n                    \n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                    return eventT;\n                }\n\n                \n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                \n                if (currentEvent.evaluateStep(interpolator)) {\n                    \n                    occuringEvents.add(currentEvent);\n                }\n\n            }\n\n            \n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            \n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }\n\n    \n    protected void sanityChecks(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException, DimensionMismatchException {\n\n        final double threshold = 1000 * FastMath.ulp(FastMath.max(FastMath.abs(equations.getTime()),\n                                                                  FastMath.abs(t)));\n        final double dt = FastMath.abs(equations.getTime() - t);\n        if (dt <= threshold) {\n            throw new NumberIsTooSmallException(LocalizedFormats.TOO_SMALL_INTEGRATION_INTERVAL,\n                                                dt, threshold, false);\n        }\n\n    }\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math3.ode;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\nimport org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver;\nimport org.apache.commons.math3.analysis.solvers.UnivariateSolver;\nimport org.apache.commons.math3.exception.DimensionMismatchException;\nimport org.apache.commons.math3.exception.MaxCountExceededException;\nimport org.apache.commons.math3.exception.NoBracketingException;\nimport org.apache.commons.math3.exception.NumberIsTooSmallException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.ode.events.EventHandler;\nimport org.apache.commons.math3.ode.events.EventState;\nimport org.apache.commons.math3.ode.sampling.AbstractStepInterpolator;\nimport org.apache.commons.math3.ode.sampling.StepHandler;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.util.Incrementor;\nimport org.apache.commons.math3.util.Precision;\n\n\npublic abstract class AbstractIntegrator implements FirstOrderIntegrator { protected Collection<StepHandler> stepHandlers; protected double stepStart; protected double stepSize; protected boolean isLastStep; protected boolean resetOccurred; private Collection<EventState> eventsStates; private boolean statesInitialized; private final String name; private Incrementor evaluations; private transient ExpandableStatefulODE expandable; public AbstractIntegrator(final String name) {\n        this.name = name;\n        stepHandlers = new ArrayList<StepHandler>();\n        stepStart = Double.NaN;\n        stepSize  = Double.NaN;\n        eventsStates = new ArrayList<EventState>();\n        statesInitialized = false;\n        evaluations = new Incrementor();\n        setMaxEvaluations(-1);\n        evaluations.resetCount();\n    }\n\n    \n    protected AbstractIntegrator() {\n        this(null);\n    }\n\n    \n    public String getName() {\n        return name;\n    }\n\n    \n    public void addStepHandler(final StepHandler handler) {\n        stepHandlers.add(handler);\n    }\n\n    \n    public Collection<StepHandler> getStepHandlers() {\n        return Collections.unmodifiableCollection(stepHandlers);\n    }\n\n    \n    public void clearStepHandlers() {\n        stepHandlers.clear();\n    }\n\n    \n    public void addEventHandler(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount) {\n        addEventHandler(handler, maxCheckInterval, convergence,\n                        maxIterationCount,\n                        new BracketingNthOrderBrentSolver(convergence, 5));\n    }\n\n    \n    public void addEventHandler(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount, final UnivariateSolver solver) {\n        eventsStates.add(new EventState(handler, maxCheckInterval, convergence,\n                                        maxIterationCount, solver));\n    }\n\n    \n    public Collection<EventHandler> getEventHandlers() {\n        final List<EventHandler> list = new ArrayList<EventHandler>();\n        for (EventState state : eventsStates) {\n            list.add(state.getEventHandler());\n        }\n        return Collections.unmodifiableCollection(list);\n    }\n\n    \n    public void clearEventHandlers() {\n        eventsStates.clear();\n    }\n\n    \n    public double getCurrentStepStart() {\n        return stepStart;\n    }\n\n    \n    public double getCurrentSignedStepsize() {\n        return stepSize;\n    }\n\n    \n    public void setMaxEvaluations(int maxEvaluations) {\n        evaluations.setMaximalCount((maxEvaluations < 0) ? Integer.MAX_VALUE : maxEvaluations);\n    }\n\n    \n    public int getMaxEvaluations() {\n        return evaluations.getMaximalCount();\n    }\n\n    \n    public int getEvaluations() {\n        return evaluations.getCount();\n    }\n\n    \n    protected void initIntegration(final double t0, final double[] y0, final double t) {\n\n        evaluations.resetCount();\n\n        for (final EventState state : eventsStates) {\n            state.getEventHandler().init(t0, y0, t);\n        }\n\n        for (StepHandler handler : stepHandlers) {\n            handler.init(t0, y0, t);\n        }\n\n        setStateInitialized(false);\n\n    }\n\n    \n    protected void setEquations(final ExpandableStatefulODE equations) {\n        this.expandable = equations;\n    }\n\n    \n    public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {\n\n        if (y0.length != equations.getDimension()) {\n            throw new DimensionMismatchException(y0.length, equations.getDimension());\n        }\n        if (y.length != equations.getDimension()) {\n            throw new DimensionMismatchException(y.length, equations.getDimension());\n        }\n\n        \n        final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);\n        expandableODE.setTime(t0);\n        expandableODE.setPrimaryState(y0);\n\n        \n        integrate(expandableODE, t);\n\n        \n        System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);\n        return expandableODE.getTime();\n\n    }\n\n    \n    public abstract void integrate(ExpandableStatefulODE equations, double t) throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException; public void computeDerivatives(final double t, final double[] y, final double[] yDot) throws MaxCountExceededException, DimensionMismatchException {\n        evaluations.incrementCount();\n        expandable.computeDerivatives(t, y, yDot);\n    }\n\n    \n    protected void setStateInitialized(final boolean stateInitialized) {\n        this.statesInitialized = stateInitialized;\n    }\n\n    \n    protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            \n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            \n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                \n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    \n                    occuringEvents.add(state);\n                }\n            }\n\n            while (!occuringEvents.isEmpty()) {\n\n                \n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                \n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                \n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n\n                \n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventY);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                \n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    \n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventY);\n                }\n                if (needReset) {\n                    \n                    \n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                \n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                \n                if (currentEvent.evaluateStep(interpolator)) {\n                    \n                    occuringEvents.add(currentEvent);\n                }\n\n            }\n\n            \n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            \n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }\n\n    \n    protected void sanityChecks(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException, DimensionMismatchException {\n\n        final double threshold = 1000 * FastMath.ulp(FastMath.max(FastMath.abs(equations.getTime()),\n                                                                  FastMath.abs(t)));\n        final double dt = FastMath.abs(equations.getTime() - t);\n        if (dt <= threshold) {\n            throw new NumberIsTooSmallException(LocalizedFormats.TOO_SMALL_INTEGRATION_INTERVAL,\n                                                dt, threshold, false);\n        }\n\n    }\n\n}\n",
      "buggy_signatures": [
        "public abstract class AbstractIntegrator implements FirstOrderIntegrator { protected Collection<StepHandler> stepHandlers; protected double stepStart; protected double stepSize; protected boolean isLastStep; protected boolean resetOccurred; private Collection<EventState> eventsStates; private boolean statesInitialized; private final String name; private Incrementor evaluations; private transient ExpandableStatefulODE expandable; public AbstractIntegrator(final String name)",
        "protected AbstractIntegrator()",
        "public String getName()",
        "public void addStepHandler(final StepHandler handler)",
        "public Collection<StepHandler> getStepHandlers()",
        "public void clearStepHandlers()",
        "public void addEventHandler(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount)",
        "public void addEventHandler(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount, final UnivariateSolver solver)",
        "public Collection<EventHandler> getEventHandlers()",
        "public void clearEventHandlers()",
        "public double getCurrentStepStart()",
        "public double getCurrentSignedStepsize()",
        "public void setMaxEvaluations(int maxEvaluations)",
        "public int getMaxEvaluations()",
        "public int getEvaluations()",
        "protected void initIntegration(final double t0, final double[] y0, final double t)",
        "protected void setEquations(final ExpandableStatefulODE equations)",
        "public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException",
        "public abstract void integrate(ExpandableStatefulODE equations, double t) throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException; public void computeDerivatives(final double t, final double[] y, final double[] yDot) throws MaxCountExceededException, DimensionMismatchException",
        "protected void setStateInitialized(final boolean stateInitialized)",
        "protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MaxCountExceededException, DimensionMismatchException, NoBracketingException",
        "public int compare(EventState es0, EventState es1)",
        "protected void sanityChecks(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException, DimensionMismatchException"
      ],
      "fixed_signatures": [
        "public abstract class AbstractIntegrator implements FirstOrderIntegrator { protected Collection<StepHandler> stepHandlers; protected double stepStart; protected double stepSize; protected boolean isLastStep; protected boolean resetOccurred; private Collection<EventState> eventsStates; private boolean statesInitialized; private final String name; private Incrementor evaluations; private transient ExpandableStatefulODE expandable; public AbstractIntegrator(final String name)",
        "protected AbstractIntegrator()",
        "public String getName()",
        "public void addStepHandler(final StepHandler handler)",
        "public Collection<StepHandler> getStepHandlers()",
        "public void clearStepHandlers()",
        "public void addEventHandler(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount)",
        "public void addEventHandler(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount, final UnivariateSolver solver)",
        "public Collection<EventHandler> getEventHandlers()",
        "public void clearEventHandlers()",
        "public double getCurrentStepStart()",
        "public double getCurrentSignedStepsize()",
        "public void setMaxEvaluations(int maxEvaluations)",
        "public int getMaxEvaluations()",
        "public int getEvaluations()",
        "protected void initIntegration(final double t0, final double[] y0, final double t)",
        "protected void setEquations(final ExpandableStatefulODE equations)",
        "public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException",
        "public abstract void integrate(ExpandableStatefulODE equations, double t) throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException; public void computeDerivatives(final double t, final double[] y, final double[] yDot) throws MaxCountExceededException, DimensionMismatchException",
        "protected void setStateInitialized(final boolean stateInitialized)",
        "protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MaxCountExceededException, DimensionMismatchException, NoBracketingException",
        "public int compare(EventState es0, EventState es1)",
        "protected void sanityChecks(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException, DimensionMismatchException"
      ],
      "methods": [
        {
          "buggy_method": "  public int compare(EventState es0, EventState es1) {\n  return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n  }",
          "fixed_method": "  public int compare(EventState es0, EventState es1) {\n  return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n  }",
          "diff": [
            "@@ -343,8 +343,10 @@",
            "                 final double[] eventY = interpolator.getInterpolatedState().clone();\n",
            " \n",
            "                 // advance all event states to current time\n",
            "-                currentEvent.stepAccepted(eventT, eventY);\n",
            "-                isLastStep = currentEvent.stop();\n",
            "+                for (final EventState state : eventsStates) {\n",
            "+                    state.stepAccepted(eventT, eventY);\n",
            "+                    isLastStep = isLastStep || state.stop();\n",
            "+                }\n",
            " \n",
            "                 // handle the first part of the step, up to the event\n",
            "                 for (final StepHandler handler : stepHandlers) {\n",
            "@@ -354,22 +356,19 @@",
            "                 if (isLastStep) {\n",
            "                     // the event asked to stop integration\n",
            "                     System.arraycopy(eventY, 0, y, 0, y.length);\n",
            "-                    for (final EventState remaining : occuringEvents) {\n",
            "-                        remaining.stepAccepted(eventT, eventY);\n",
            "-                    }\n",
            "                     return eventT;\n",
            "                 }\n",
            " \n",
            "-                boolean needReset = currentEvent.reset(eventT, eventY);\n",
            "+                boolean needReset = false;\n",
            "+                for (final EventState state : eventsStates) {\n",
            "+                    needReset =  needReset || state.reset(eventT, eventY);\n",
            "+                }\n",
            "                 if (needReset) {\n",
            "                     // some event handler has triggered changes that\n",
            "                     // invalidate the derivatives, we need to recompute them\n",
            "                     System.arraycopy(eventY, 0, y, 0, y.length);\n",
            "                     computeDerivatives(eventT, y, yDot);\n",
            "                     resetOccurred = true;\n",
            "-                    for (final EventState remaining : occuringEvents) {\n",
            "-                        remaining.stepAccepted(eventT, eventY);\n",
            "-                    }\n",
            "                     return eventT;\n",
            "                 }\n",
            " \n"
          ],
          "changed_lines": 17
        }
      ]
    }
  ]
}
