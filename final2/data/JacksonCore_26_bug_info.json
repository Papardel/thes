{
  "bug_id": "26",
  "failed_tests": {
    "com.fasterxml.jackson.core.json.async.AsyncLocationTest": [
      {
        "methodName": "testLocationOffsets",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<1> but was:<3>",
        "fail_line": "        assertEquals(1, parser.getCurrentLocation().getByteOffset());",
        "test_source": "  public void testLocationOffsets() throws Exception {\n  JsonParser parser = DEFAULT_F.createNonBlockingByteArrayParser();\n  ByteArrayFeeder feeder = (ByteArrayFeeder) parser.getNonBlockingInputFeeder();\n\n  byte[] input = utf8Bytes(\"[[[\");\n\n  feeder.feedInput(input, 2, 3);\n  assertEquals(JsonToken.START_ARRAY, parser.nextToken());\n  assertEquals(1, parser.getCurrentLocation().getByteOffset());\n  assertEquals(1, parser.getTokenLocation().getByteOffset());\n  assertEquals(1, parser.getCurrentLocation().getLineNr());\n  assertEquals(1, parser.getTokenLocation().getLineNr());\n  assertEquals(2, parser.getCurrentLocation().getColumnNr());\n  assertEquals(1, parser.getTokenLocation().getColumnNr());\n\n  feeder.feedInput(input, 0, 1);\n  assertEquals(JsonToken.START_ARRAY, parser.nextToken());\n  assertEquals(2, parser.getCurrentLocation().getByteOffset());\n  assertEquals(2, parser.getTokenLocation().getByteOffset());\n  assertEquals(1, parser.getCurrentLocation().getLineNr());\n  assertEquals(1, parser.getTokenLocation().getLineNr());\n  assertEquals(3, parser.getCurrentLocation().getColumnNr());\n  assertEquals(2, parser.getTokenLocation().getColumnNr());\n  parser.close();\n  }",
        "stack": [
          "AsyncLocationTest.testLocationOffsets line 21"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/core/json/async/NonBlockingJsonParser.java",
      "buggy_full_code": "package com.fasterxml.jackson.core.json.async;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.async.ByteArrayFeeder;\nimport com.fasterxml.jackson.core.async.NonBlockingInputFeeder;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\npublic class NonBlockingJsonParser extends NonBlockingJsonParserBase implements ByteArrayFeeder { @SuppressWarnings(\"deprecation\") private final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask(); @SuppressWarnings(\"deprecation\") private final static int FEAT_MASK_LEADING_ZEROS = Feature.ALLOW_NUMERIC_LEADING_ZEROS.getMask(); @SuppressWarnings(\"deprecation\") private final static int FEAT_MASK_ALLOW_MISSING = Feature.ALLOW_MISSING_VALUES.getMask(); private final static int FEAT_MASK_ALLOW_SINGLE_QUOTES = Feature.ALLOW_SINGLE_QUOTES.getMask(); private final static int FEAT_MASK_ALLOW_UNQUOTED_NAMES = Feature.ALLOW_UNQUOTED_FIELD_NAMES.getMask(); private final static int FEAT_MASK_ALLOW_JAVA_COMMENTS = Feature.ALLOW_COMMENTS.getMask(); private final static int FEAT_MASK_ALLOW_YAML_COMMENTS = Feature.ALLOW_YAML_COMMENTS.getMask(); private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8(); protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); protected byte[] _inputBuffer = NO_BYTES; protected int _origBufferLen; public NonBlockingJsonParser(IOContext ctxt, int parserFeatures, ByteQuadsCanonicalizer sym) {\n        super(ctxt, parserFeatures, sym);\n    }\n\n    \n\n    @Override\n    public ByteArrayFeeder getNonBlockingInputFeeder() {\n        return this;\n    }\n\n    @Override\n    public final boolean needMoreInput() {\n        return (_inputPtr >=_inputEnd) && !_endOfInput;\n    }\n\n    @Override\n    public void feedInput(byte[] buf, int start, int end) throws IOException {\n        \n        if (_inputPtr < _inputEnd) {\n            _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n        }\n        if (end < start) {\n            _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n        }\n        \n        if (_endOfInput) {\n            _reportError(\"Already closed, can not feed more input\");\n        }\n        \n        _currInputProcessed += _origBufferLen;\n\n        \n        _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n\n        \n        _inputBuffer = buf;\n        _inputPtr = start;\n        _inputEnd = end;\n        _origBufferLen = end - start;\n    }\n\n    @Override\n    public void endOfInput() {\n        _endOfInput = true;\n    }\n\n    \n\n    \n\n\n\n\n\n\n\n    @Override\n    public int releaseBuffered(OutputStream out) throws IOException {\n        int avail = _inputEnd - _inputPtr;\n        if (avail > 0) {\n            out.write(_inputBuffer, _inputPtr, avail);\n        }\n        return avail;\n    }\n\n    \n    \n    @Override\n    protected char _decodeEscaped() throws IOException {\n        VersionUtil.throwInternal();\n        return ' ';\n    }\n\n    \n\n    @Override\n    public JsonToken nextToken() throws IOException {\n        \n        \n        if (_inputPtr >= _inputEnd) {\n            if (_closed) {\n                return null;\n            }\n            \n            if (_endOfInput) { \n                \n                \n                if (_currToken == JsonToken.NOT_AVAILABLE) {\n                    return _finishTokenWithEOF();\n                }\n                return _eofAsNextToken();\n            }\n            return JsonToken.NOT_AVAILABLE;\n        }\n        \n        if (_currToken == JsonToken.NOT_AVAILABLE) {\n            return _finishToken();\n        }\n\n        \n        _numTypesValid = NR_UNKNOWN;\n        _tokenInputTotal = _currInputProcessed + _inputPtr;\n        \n        _binaryValue = null;\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n\n        switch (_majorState) {\n        case MAJOR_INITIAL:\n            return _startDocument(ch);\n\n        case MAJOR_ROOT:\n            return _startValue(ch);\n\n        case MAJOR_OBJECT_FIELD_FIRST: \n            return _startFieldName(ch);\n        case MAJOR_OBJECT_FIELD_NEXT: \n            return _startFieldNameAfterComma(ch);\n\n        case MAJOR_OBJECT_VALUE: \n            return _startValueExpectColon(ch);\n\n        case MAJOR_ARRAY_ELEMENT_FIRST: \n            return _startValue(ch);\n\n        case MAJOR_ARRAY_ELEMENT_NEXT: \n            return _startValueExpectComma(ch);\n\n        default:\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    \n    protected final JsonToken _finishToken() throws IOException {\n        \n        switch (_minorState) {\n        case MINOR_ROOT_BOM:\n            return _finishBOM(_pending32);\n        case MINOR_FIELD_LEADING_WS:\n            return _startFieldName(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_FIELD_LEADING_COMMA:\n            return _startFieldNameAfterComma(_inputBuffer[_inputPtr++] & 0xFF);\n\n        \n        case MINOR_FIELD_NAME:\n            return _parseEscapedName(_quadLength,  _pending32, _pendingBytes);\n        case MINOR_FIELD_NAME_ESCAPE:\n            return _finishFieldWithEscape();\n        case MINOR_FIELD_APOS_NAME:\n            return _finishAposName(_quadLength,  _pending32, _pendingBytes);\n        case MINOR_FIELD_UNQUOTED_NAME:\n            return _finishUnquotedName(_quadLength,  _pending32, _pendingBytes);\n\n        \n\n        case MINOR_VALUE_LEADING_WS:\n            return _startValue(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_VALUE_WS_AFTER_COMMA:\n            return _startValueAfterComma(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_VALUE_EXPECTING_COMMA:\n            return _startValueExpectComma(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_VALUE_EXPECTING_COLON:\n            return _startValueExpectColon(_inputBuffer[_inputPtr++] & 0xFF);\n\n        case MINOR_VALUE_TOKEN_NULL:\n            return _finishKeywordToken(\"null\", _pending32, JsonToken.VALUE_NULL);\n        case MINOR_VALUE_TOKEN_TRUE:\n            return _finishKeywordToken(\"true\", _pending32, JsonToken.VALUE_TRUE);\n        case MINOR_VALUE_TOKEN_FALSE:\n            return _finishKeywordToken(\"false\", _pending32, JsonToken.VALUE_FALSE);\n        case MINOR_VALUE_TOKEN_NON_STD:\n            return _finishNonStdToken(_nonStdTokenType, _pending32);\n\n        case MINOR_NUMBER_MINUS:\n            return _finishNumberMinus(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_NUMBER_ZERO:\n            return _finishNumberLeadingZeroes();\n        case MINOR_NUMBER_MINUSZERO:\n            return _finishNumberLeadingNegZeroes();\n        case MINOR_NUMBER_INTEGER_DIGITS:\n            return _finishNumberIntegralPart(_textBuffer.getBufferWithoutReset(),\n                    _textBuffer.getCurrentSegmentSize());\n        case MINOR_NUMBER_FRACTION_DIGITS:\n            return _finishFloatFraction();\n        case MINOR_NUMBER_EXPONENT_MARKER:\n            return _finishFloatExponent(true, _inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_NUMBER_EXPONENT_DIGITS:\n            return _finishFloatExponent(false, _inputBuffer[_inputPtr++] & 0xFF);\n\n        case MINOR_VALUE_STRING:\n            return _finishRegularString();\n        case MINOR_VALUE_STRING_UTF8_2:\n            _textBuffer.append((char) _decodeUTF8_2(_pending32, _inputBuffer[_inputPtr++]));\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n        case MINOR_VALUE_STRING_UTF8_3:\n            if (!_decodeSplitUTF8_3(_pending32, _pendingBytes, _inputBuffer[_inputPtr++])) {\n                return JsonToken.NOT_AVAILABLE;\n            }\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n        case MINOR_VALUE_STRING_UTF8_4:\n            if (!_decodeSplitUTF8_4(_pending32, _pendingBytes, _inputBuffer[_inputPtr++])) {\n                return JsonToken.NOT_AVAILABLE;\n            }\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n\n        case MINOR_VALUE_STRING_ESCAPE:\n            {\n                int c = _decodeSplitEscaped(_quoted32, _quotedDigits);\n                if (c < 0) {\n                    return JsonToken.NOT_AVAILABLE;\n                }\n                _textBuffer.append((char) c);\n            }\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n\n        case MINOR_VALUE_APOS_STRING:\n            return _finishAposString();\n\n        case MINOR_VALUE_TOKEN_ERROR: \n            return _finishErrorToken();\n\n        \n            \n        case MINOR_COMMENT_LEADING_SLASH:\n            return _startSlashComment(_pending32);\n        case MINOR_COMMENT_CLOSING_ASTERISK:\n            return _finishCComment(_pending32, true);\n        case MINOR_COMMENT_C:\n            return _finishCComment(_pending32, false);\n        case MINOR_COMMENT_CPP:\n            return _finishCppComment(_pending32);\n        case MINOR_COMMENT_YAML:\n            return _finishHashComment(_pending32);\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    \n    protected final JsonToken _finishTokenWithEOF() throws IOException {\n        \n        JsonToken t = _currToken;\n        switch (_minorState) {\n        case MINOR_ROOT_GOT_SEPARATOR: \n            return _eofAsNextToken();\n        case MINOR_VALUE_LEADING_WS: \n            return _eofAsNextToken();\n\n\n        case MINOR_VALUE_TOKEN_NULL:\n            return _finishKeywordTokenWithEOF(\"null\", _pending32, JsonToken.VALUE_NULL);\n        case MINOR_VALUE_TOKEN_TRUE:\n            return _finishKeywordTokenWithEOF(\"true\", _pending32, JsonToken.VALUE_TRUE);\n        case MINOR_VALUE_TOKEN_FALSE:\n            return _finishKeywordTokenWithEOF(\"false\", _pending32, JsonToken.VALUE_FALSE);\n        case MINOR_VALUE_TOKEN_NON_STD:\n            return _finishNonStdTokenWithEOF(_nonStdTokenType, _pending32);\n        case MINOR_VALUE_TOKEN_ERROR: \n            return _finishErrorTokenWithEOF();\n\n        \n        case MINOR_NUMBER_ZERO:\n        case MINOR_NUMBER_MINUSZERO:\n            \n            \n            return _valueCompleteInt(0, \"0\");\n        case MINOR_NUMBER_INTEGER_DIGITS:\n            \n            {\n                int len = _textBuffer.getCurrentSegmentSize();\n                if (_numberNegative) {\n                    --len;\n                }\n                _intLength = len;\n            }\n            return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n\n        case MINOR_NUMBER_FRACTION_DIGITS:\n            _expLength = 0;\n            \n        case MINOR_NUMBER_EXPONENT_DIGITS:\n            return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n\n        case MINOR_NUMBER_EXPONENT_MARKER:\n            _reportInvalidEOF(\": was expecting fraction after exponent marker\", JsonToken.VALUE_NUMBER_FLOAT);\n\n            \n            \n\n\n        case MINOR_COMMENT_CLOSING_ASTERISK:\n        case MINOR_COMMENT_C:\n            _reportInvalidEOF(\": was expecting closing '*/' for comment\", JsonToken.NOT_AVAILABLE);\n\n        case MINOR_COMMENT_CPP:\n        case MINOR_COMMENT_YAML:\n            \n            return _eofAsNextToken();\n            \n        default:\n        }\n        _reportInvalidEOF(\": was expecting rest of token (internal state: \"+_minorState+\")\", _currToken);\n        return t; \n    }\n\n    \n\n    private final JsonToken _startDocument(int ch) throws IOException {\n        ch &= 0xFF;\n\n        \n        if ((ch == 0xEF) && (_minorState != MINOR_ROOT_BOM)) {\n            return _finishBOM(1);\n        }\n\n        \n        while (ch <= 0x020) {\n            if (ch != INT_SPACE) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_ROOT_GOT_SEPARATOR;\n                if (_closed) {\n                    return null;\n                }\n                \n                if (_endOfInput) { \n                    return _eofAsNextToken();\n                }\n                return JsonToken.NOT_AVAILABLE;\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        return _startValue(ch);\n    }\n\n    private final JsonToken _finishBOM(int bytesHandled) throws IOException {\n        \n        \n        \n\n        while (_inputPtr < _inputEnd) {\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            switch (bytesHandled) {\n            case 3:\n                \n                \n                _currInputProcessed -= 3;\n                return _startDocument(ch);\n            case 2:\n                if (ch != 0xBF) {\n                    _reportError(\"Unexpected byte 0x%02x following 0xEF 0xBB; should get 0xBF as third byte of UTF-8 BOM\", ch);\n                }\n                break;\n            case 1:\n                if (ch != 0xBB) {\n                    _reportError(\"Unexpected byte 0x%02x following 0xEF; should get 0xBB as second byte UTF-8 BOM\", ch);\n                }\n                break;\n            }\n            ++bytesHandled;\n        }\n        _pending32 = bytesHandled;\n        _minorState = MINOR_ROOT_BOM;\n        return (_currToken = JsonToken.NOT_AVAILABLE);\n    }\n\n    \n\n    \n    private final JsonToken _startFieldName(int ch) throws IOException {\n        \n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch != INT_QUOTE) {\n            if (ch == INT_RCURLY) {\n                return _closeObjectScope();\n            }\n            return _handleOddName(ch);\n        }\n        \n        if ((_inputPtr + 13) <= _inputEnd) { \n            String n = _fastParseName();\n            if (n != null) {\n                return _fieldComplete(n);\n            }\n        }\n        return _parseEscapedName(0, 0, 0);\n    }\n\n    private final JsonToken _startFieldNameAfterComma(int ch) throws IOException {\n        \n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); \n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_COMMA;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COMMA) { \n            if (ch == INT_RCURLY) {\n                return _closeObjectScope();\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_FIELD_LEADING_COMMA);\n            }\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_FIELD_LEADING_COMMA);\n            }\n            _reportUnexpectedChar(ch, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_FIELD_LEADING_WS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch != INT_QUOTE) {\n            if (ch == INT_RCURLY) {\n                if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                    return _closeObjectScope();\n                }\n            }\n            return _handleOddName(ch);\n        }\n        \n        if ((_inputPtr + 13) <= _inputEnd) { \n            String n = _fastParseName();\n            if (n != null) {\n                return _fieldComplete(n);\n            }\n        }\n        return _parseEscapedName(0, 0, 0);\n    }\n\n    \n    \n    \n    private final JsonToken _startValue(int ch) throws IOException {\n        \n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_LEADING_WS);\n        case '-':\n            return _startNegativeNumber();\n        case '/': \n            return _startSlashComment(MINOR_VALUE_LEADING_WS);\n            \n        \n        \n        \n        case '0':\n            return _startNumberLeadingZero();\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            return _closeArrayScope();\n        case '{':\n            return _startObjectScope();\n        case '}':\n            return _closeObjectScope();\n        default:\n        }\n        return _startUnexpectedValue(false, ch);\n    }\n\n    \n    private final JsonToken _startValueExpectComma(int ch) throws IOException {\n        \n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); \n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_EXPECTING_COMMA;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COMMA) {\n            if (ch == INT_RBRACKET) {\n                return _closeArrayScope();\n            }\n            if (ch == INT_RCURLY){\n                return _closeObjectScope();\n            }\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_VALUE_EXPECTING_COMMA);\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_VALUE_EXPECTING_COMMA);\n            }\n            _reportUnexpectedChar(ch, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_WS_AFTER_COMMA);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_WS_AFTER_COMMA);\n\n        \n        \n        \n        case '0':\n            return _startNumberLeadingZero();\n\n        case '1':\n        case '2': case '3':\n        case '4': case '5':\n        case '6': case '7':\n        case '8': case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            \n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeArrayScope();\n            }\n            break;\n        case '{':\n            return _startObjectScope();\n        case '}':\n            \n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeObjectScope();\n            }\n            break;\n        default:\n        }\n        return _startUnexpectedValue(true, ch);\n    }\n\n    \n    private final JsonToken _startValueExpectColon(int ch) throws IOException {\n        \n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); \n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_EXPECTING_COLON;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COLON) {\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_VALUE_EXPECTING_COLON);\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_VALUE_EXPECTING_COLON);\n            }\n            \n            _reportUnexpectedChar(ch, \"was expecting a colon to separate field name and value\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_VALUE_LEADING_WS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); \n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_LEADING_WS);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_LEADING_WS);\n\n        \n        \n        \n        case '0':\n            return _startNumberLeadingZero();\n\n        case '1':\n        case '2': case '3':\n        case '4': case '5':\n        case '6': case '7':\n        case '8': case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case '{':\n            return _startObjectScope();\n        default:\n        }\n        return _startUnexpectedValue(false, ch);\n    }\n\n    \n    private final JsonToken _startValueAfterComma(int ch) throws IOException {\n        \n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_WS_AFTER_COMMA);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_WS_AFTER_COMMA);\n\n        \n        \n        \n        case '0':\n            return _startNumberLeadingZero();\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            \n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeArrayScope();\n            }\n            break;\n        case '{':\n            return _startObjectScope();\n        case '}':\n            \n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeObjectScope();\n            }\n            break;\n        default:\n        }\n        return _startUnexpectedValue(true, ch);\n    }\n\n    protected JsonToken _startUnexpectedValue(boolean leadingComma, int ch) throws IOException {\n        switch (ch) {\n        case ']':\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            \n        case ',':\n            \n            \n            \n            if ((_features & FEAT_MASK_ALLOW_MISSING) != 0) {\n                --_inputPtr;\n                return _valueComplete(JsonToken.VALUE_NULL);\n            }\n            \n        case '}':\n            \n            \n            break;\n        case '\\'':\n            if ((_features & FEAT_MASK_ALLOW_SINGLE_QUOTES) != 0) {\n                return _startAposString();\n            }\n            break;\n        case '+':\n            return _finishNonStdToken(NON_STD_TOKEN_PLUS_INFINITY, 1);\n        case 'N':\n            return _finishNonStdToken(NON_STD_TOKEN_NAN, 1);            \n        case 'I':\n            return _finishNonStdToken(NON_STD_TOKEN_INFINITY, 1);\n        }\n        \n        _reportUnexpectedChar(ch, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    \n    \n    private final int _skipWS(int ch) throws IOException {\n        do {\n            if (ch != INT_SPACE) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n            if (_inputPtr >= _inputEnd) {\n                _currToken = JsonToken.NOT_AVAILABLE;\n                return 0;\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        } while (ch <= 0x0020);\n        return ch;\n    }\n\n    private final JsonToken _startSlashComment(int fromMinorState) throws IOException {\n        if ((_features & FEAT_MASK_ALLOW_JAVA_COMMENTS) == 0) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n\n        \n        if (_inputPtr >= _inputEnd) {\n            _pending32 = fromMinorState;\n            _minorState = MINOR_COMMENT_LEADING_SLASH;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++];\n        if (ch == INT_ASTERISK) { \n            return _finishCComment(fromMinorState, false);\n        }\n        if (ch == INT_SLASH) { \n            return _finishCppComment(fromMinorState);\n        }\n        _reportUnexpectedChar(ch & 0xFF, \"was expecting either '*' or '/' for a comment\");\n        return null;\n    }\n\n    private final JsonToken _finishHashComment(int fromMinorState) throws IOException {\n        \n        if ((_features & FEAT_MASK_ALLOW_YAML_COMMENTS) == 0) {\n            _reportUnexpectedChar('#', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_YAML_COMMENTS' not enabled for parser)\");\n        }\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_COMMENT_YAML;\n                _pending32 = fromMinorState;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < 0x020) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n        }\n        return _startAfterComment(fromMinorState);\n    }\n\n    private final JsonToken _finishCppComment(int fromMinorState) throws IOException {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_COMMENT_CPP;\n                _pending32 = fromMinorState;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < 0x020) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n        }\n        return _startAfterComment(fromMinorState);\n    }\n\n    private final JsonToken _finishCComment(int fromMinorState, boolean gotStar) throws IOException {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = gotStar ? MINOR_COMMENT_CLOSING_ASTERISK : MINOR_COMMENT_C;\n                _pending32 = fromMinorState;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < 0x020) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            } else if (ch == INT_ASTERISK) {\n                gotStar = true;\n                continue;\n            } else if (ch == INT_SLASH) {\n                if (gotStar) {\n                    break;\n                }\n            }\n            gotStar = false;\n        }\n        return _startAfterComment(fromMinorState);\n    }\n\n    private final JsonToken _startAfterComment(int fromMinorState) throws IOException {\n        \n        if (_inputPtr >= _inputEnd) {\n            _minorState = fromMinorState;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        switch (fromMinorState) {\n        case MINOR_FIELD_LEADING_WS:\n            return _startFieldName(ch);\n        case MINOR_FIELD_LEADING_COMMA:\n            return _startFieldNameAfterComma(ch);\n        case MINOR_VALUE_LEADING_WS:\n            return _startValue(ch);\n        case MINOR_VALUE_EXPECTING_COMMA:\n            return _startValueExpectComma(ch);\n        case MINOR_VALUE_EXPECTING_COLON:\n            return _startValueExpectColon(ch);\n        case MINOR_VALUE_WS_AFTER_COMMA:\n            return _startValueAfterComma(ch);\n        default:\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    \n\n    protected JsonToken _startFalseToken() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) { \n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'a') \n                   && (buf[ptr++] == 'l')\n                   && (buf[ptr++] == 's')\n                   && (buf[ptr++] == 'e')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { \n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_FALSE);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_FALSE;\n        return _finishKeywordToken(\"false\", 1, JsonToken.VALUE_FALSE);\n    }\n\n    protected JsonToken _startTrueToken() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) { \n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'r') \n                   && (buf[ptr++] == 'u')\n                   && (buf[ptr++] == 'e')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { \n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_TRUE);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_TRUE;\n        return _finishKeywordToken(\"true\", 1, JsonToken.VALUE_TRUE);\n    }\n\n    protected JsonToken _startNullToken() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) { \n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'u') \n                   && (buf[ptr++] == 'l')\n                   && (buf[ptr++] == 'l')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { \n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_NULL);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_NULL;\n        return _finishKeywordToken(\"null\", 1, JsonToken.VALUE_NULL);\n    }\n\n    protected JsonToken _finishKeywordToken(String expToken, int matched, JsonToken result) throws IOException {\n        final int end = expToken.length();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _pending32 = matched;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr];\n            if (matched == end) { \n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { \n                    return _valueComplete(result);\n                }\n                break;\n            }\n            if (ch != expToken.charAt(matched)) {\n                break;\n            }\n            ++matched;\n            ++_inputPtr;\n        }\n        _minorState = MINOR_VALUE_TOKEN_ERROR;\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorToken();\n    }\n\n    protected JsonToken _finishKeywordTokenWithEOF(String expToken, int matched, JsonToken result) throws IOException {\n        if (matched == expToken.length()) {\n            return (_currToken = result);\n        }\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorTokenWithEOF();\n    }\n\n    protected JsonToken _finishNonStdToken(int type, int matched) throws IOException {\n        final String expToken = _nonStdToken(type);\n        final int end = expToken.length();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _nonStdTokenType = type;\n                _pending32 = matched;\n                _minorState = MINOR_VALUE_TOKEN_NON_STD;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr];\n            if (matched == end) { \n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { \n                    return _valueNonStdNumberComplete(type);\n                }\n                break;\n            }\n            if (ch != expToken.charAt(matched)) {\n                break;\n            }\n            ++matched;\n            ++_inputPtr;\n        }\n        _minorState = MINOR_VALUE_TOKEN_ERROR;\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorToken();\n    }\n\n    protected JsonToken _finishNonStdTokenWithEOF(int type, int matched) throws IOException {\n        final String expToken = _nonStdToken(type);\n        if (matched == expToken.length()) {\n            return _valueNonStdNumberComplete(type);\n        }\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorTokenWithEOF();\n    }\n\n    protected JsonToken _finishErrorToken() throws IOException {\n        while (_inputPtr < _inputEnd) {\n            int i = (int) _inputBuffer[_inputPtr++];\n\n\n\n\n            char ch = (char) i;\n            if (Character.isJavaIdentifierPart(ch)) {\n                \n                \n                _textBuffer.append(ch);\n                if (_textBuffer.size() < MAX_ERROR_TOKEN_LENGTH) {\n                    continue;\n                }\n            }\n            return _reportErrorToken(_textBuffer.contentsAsString());\n        }\n        return (_currToken = JsonToken.NOT_AVAILABLE);\n    }\n\n    protected JsonToken _finishErrorTokenWithEOF() throws IOException {\n        return _reportErrorToken(_textBuffer.contentsAsString());\n    }\n\n    protected JsonToken _reportErrorToken(String actualToken) throws IOException {\n        \n        _reportError(\"Unrecognized token '%s': was expecting %s\", _textBuffer.contentsAsString(),\n                \"'null', 'true' or 'false'\");\n        return JsonToken.NOT_AVAILABLE; \n    }\n    \n    \n\n    protected JsonToken _startPositiveNumber(int ch) throws IOException {\n        _numberNegative = false;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = (char) ch;\n        \n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n            _textBuffer.setCurrentLength(1);\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n\n        int outPtr = 1;\n\n        ch = _inputBuffer[_inputPtr] & 0xFF;\n        while (true) {\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    _intLength = outPtr;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    _intLength = outPtr;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                \n                \n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (++_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n                _textBuffer.setCurrentLength(outPtr);\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n        }\n        _intLength = outPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }\n\n    protected JsonToken _startNegativeNumber() throws IOException {\n        _numberNegative = true;\n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_MINUS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch <= INT_0) {\n            if (ch == INT_0) {\n                return _finishNumberLeadingNegZeroes();\n            }\n            \n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        } else if (ch > INT_9) {\n            if (ch == 'I') {\n                return _finishNonStdToken(NON_STD_TOKEN_MINUS_INFINITY, 2);\n            }\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        }\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = '-';\n        outBuf[1] = (char) ch;\n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n            _textBuffer.setCurrentLength(2);\n            _intLength = 1;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[_inputPtr];\n        int outPtr = 2;\n\n        while (true) {\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    _intLength = outPtr-1;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    _intLength = outPtr-1;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                \n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (++_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n                _textBuffer.setCurrentLength(outPtr);\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n        }\n        _intLength = outPtr-1;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }\n\n    protected JsonToken _startNumberLeadingZero() throws IOException {\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_ZERO;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n\n        \n        \n        \n\n        int ch = _inputBuffer[ptr++] & 0xFF;\n        \n        if (ch < INT_0) {\n            if (ch == INT_PERIOD) {\n                _inputPtr = ptr;\n                _intLength = 1;\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                outBuf[0] = '0';\n                return _startFloat(outBuf, 1, ch);\n            }\n        } else if (ch > INT_9) {\n            if (ch == INT_e || ch == INT_E) {\n                _inputPtr = ptr;\n                _intLength = 1;\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                outBuf[0] = '0';\n                return _startFloat(outBuf, 1, ch);\n            }\n            \n            \n            \n            if ((ch != INT_RBRACKET) && (ch != INT_RCURLY)) {\n                reportUnexpectedNumberChar(ch,\n                        \"expected digit (0-9), decimal point (.) or exponent indicator (e/E) to follow '0'\");\n            }\n        } else { \n            \n            return _finishNumberLeadingZeroes();\n        }\n        \n        return _valueCompleteInt(0, \"0\");\n    }\n\n    protected JsonToken _finishNumberMinus(int ch) throws IOException {\n        if (ch <= INT_0) {\n            if (ch == INT_0) {\n                return _finishNumberLeadingNegZeroes();\n            }\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        } else if (ch > INT_9) {\n            if (ch == 'I') {\n                return _finishNonStdToken(NON_STD_TOKEN_MINUS_INFINITY, 2);\n            }\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        }\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = '-';\n        outBuf[1] = (char) ch;\n        _intLength = 1;\n        return _finishNumberIntegralPart(outBuf, 2);\n    }\n\n    protected JsonToken _finishNumberLeadingZeroes() throws IOException {\n        \n        \n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_ZERO;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 1, ch);\n                }\n            } else if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 1, ch);\n                }\n                \n                \n                \n                if ((ch != INT_RBRACKET) && (ch != INT_RCURLY)) {\n                    reportUnexpectedNumberChar(ch,\n                            \"expected digit (0-9), decimal point (.) or exponent indicator (e/E) to follow '0'\");\n                }\n            } else { \n                \n                \n                if ((_features & FEAT_MASK_LEADING_ZEROS) == 0) {\n                    reportInvalidNumber(\"Leading zeroes not allowed\");\n                }\n                if (ch == INT_0) { \n                    continue;\n                }\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                \n                outBuf[0] = (char) ch;\n                _intLength = 1;\n                return _finishNumberIntegralPart(outBuf, 1);\n            }\n            --_inputPtr;\n            return _valueCompleteInt(0, \"0\");\n        }\n    }\n\n    protected JsonToken _finishNumberLeadingNegZeroes() throws IOException {\n        \n        \n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_MINUSZERO;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '-';\n                    outBuf[1] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 2, ch);\n                }\n            } else if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '-';\n                    outBuf[1] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 2, ch);\n                }\n                \n                \n                \n                if ((ch != INT_RBRACKET) && (ch != INT_RCURLY)) {\n                    reportUnexpectedNumberChar(ch,\n                            \"expected digit (0-9), decimal point (.) or exponent indicator (e/E) to follow '0'\");\n                }\n            } else { \n                \n                \n                if ((_features & FEAT_MASK_LEADING_ZEROS) == 0) {\n                    reportInvalidNumber(\"Leading zeroes not allowed\");\n                }\n                if (ch == INT_0) { \n                    continue;\n                }\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                \n                outBuf[0] = '-';\n                outBuf[1] = (char) ch;\n                _intLength = 1;\n                return _finishNumberIntegralPart(outBuf, 2);\n            }\n            --_inputPtr;\n            return _valueCompleteInt(0, \"0\");\n        }\n    }\n\n    protected JsonToken _finishNumberIntegralPart(char[] outBuf, int outPtr) throws IOException {\n        int negMod = _numberNegative ? -1 : 0;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n                _textBuffer.setCurrentLength(outPtr);\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    _intLength = outPtr+negMod;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    _intLength = outPtr+negMod;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            ++_inputPtr;\n            if (outPtr >= outBuf.length) {\n                \n                \n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n        }\n        _intLength = outPtr+negMod;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }\n\n    protected JsonToken _startFloat(char[] outBuf, int outPtr, int ch) throws IOException {\n        int fractLen = 0;\n        if (ch == INT_PERIOD) {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = '.';\n            while (true) {\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_FRACTION_DIGITS;\n                    _fractLength = fractLen;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++]; \n                if (ch < INT_0 || ch > INT_9) {\n                    ch &= 0xFF; \n                    \n                    if (fractLen == 0) {\n                        reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                    }\n                    break;\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                ++fractLen;\n            }\n        }\n        _fractLength = fractLen;\n        int expLen = 0;\n        if (ch == INT_e || ch == INT_E) { \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (_inputPtr >= _inputEnd) {\n                _textBuffer.setCurrentLength(outPtr);\n                _minorState = MINOR_NUMBER_EXPONENT_MARKER;\n                _expLength = 0;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr++]; \n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n                    _expLength = 0;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++];\n            }\n            while (ch >= INT_0 && ch <= INT_9) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n                    _expLength = expLen;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++];\n            }\n            \n            ch &= 0xFF;\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        \n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        \n        _expLength = expLen;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }\n\n    protected JsonToken _finishFloatFraction() throws IOException {\n        int fractLen = _fractLength;\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        \n        int ch;\n        while (((ch = _inputBuffer[_inputPtr++]) >= INT_0) && (ch <= INT_9)) {\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (_inputPtr >= _inputEnd) {\n                _textBuffer.setCurrentLength(outPtr);\n                _fractLength = fractLen;\n                return JsonToken.NOT_AVAILABLE;\n            }\n        }\n        \n        \n        \n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n        }\n        _fractLength = fractLen;\n        _textBuffer.setCurrentLength(outPtr);\n\n        \n        if (ch == INT_e || ch == INT_E) { \n            _textBuffer.append((char) ch);\n            _expLength = 0;\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_EXPONENT_MARKER;\n                return JsonToken.NOT_AVAILABLE;\n            }\n            _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n            return _finishFloatExponent(true, _inputBuffer[_inputPtr++] & 0xFF);\n        }\n\n        \n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        \n        _expLength = 0;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }\n\n    protected JsonToken _finishFloatExponent(boolean checkSign, int ch) throws IOException {\n        if (checkSign) {\n            _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                _textBuffer.append((char) ch);\n                if (_inputPtr >= _inputEnd) {\n                    _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n                    _expLength = 0;\n                    return JsonToken.NOT_AVAILABLE;\n                }\n                ch = _inputBuffer[_inputPtr++];\n            }\n        }\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int expLen = _expLength;\n\n        while (ch >= INT_0 && ch <= INT_9) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (_inputPtr >= _inputEnd) {\n                _textBuffer.setCurrentLength(outPtr);\n                _expLength = expLen;\n                return JsonToken.NOT_AVAILABLE;\n            }\n            ch = _inputBuffer[_inputPtr++];\n        }\n        \n        ch &= 0xFF;\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n        }\n        \n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        \n        _expLength = expLen;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }\n\n    \n\n    private final String _fastParseName() throws IOException {\n        \n        \n        \n        \n\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n        int ptr = _inputPtr;\n\n        int q0 = input[ptr++] & 0xFF;\n        if (codes[q0] == 0) {\n            int i = input[ptr++] & 0xFF;\n            if (codes[i] == 0) {\n                int q = (q0 << 8) | i;\n                i = input[ptr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[ptr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[ptr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return _parseMediumName(ptr, i);\n                        }\n                        if (i == INT_QUOTE) { \n                            _inputPtr = ptr;\n                            return _findName(q, 4);\n                        }\n                        return null;\n                    }\n                    if (i == INT_QUOTE) { \n                        _inputPtr = ptr;\n                        return _findName(q, 3);\n                    }\n                    return null;\n                }\n                if (i == INT_QUOTE) { \n                    _inputPtr = ptr;\n                    return _findName(q, 2);\n                }\n                return null;\n            }\n            if (i == INT_QUOTE) { \n                _inputPtr = ptr;\n                return _findName(q0, 1);\n            }\n            return null;\n        }\n        if (q0 == INT_QUOTE) {\n            _inputPtr = ptr;\n            return \"\";\n        }\n        return null;\n    }\n\n    private final String _parseMediumName(int ptr, int q2) throws IOException {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        \n        int i = input[ptr++] & 0xFF;\n        if (codes[i] == 0) {\n            q2 = (q2 << 8) | i;\n            i = input[ptr++] & 0xFF;\n            if (codes[i] == 0) {\n                q2 = (q2 << 8) | i;\n                i = input[ptr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q2 = (q2 << 8) | i;\n                    i = input[ptr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        return _parseMediumName2(ptr, i, q2);\n                    }\n                    if (i == INT_QUOTE) { \n                        _inputPtr = ptr;\n                        return _findName(_quad1, q2, 4);\n                    }\n                    return null;\n                }\n                if (i == INT_QUOTE) { \n                    _inputPtr = ptr;\n                    return _findName(_quad1, q2, 3);\n                }\n                return null;\n            }\n            if (i == INT_QUOTE) { \n                _inputPtr = ptr;\n                return _findName(_quad1, q2, 2);\n            }\n            return null;\n        }\n        if (i == INT_QUOTE) { \n            _inputPtr = ptr;\n            return _findName(_quad1, q2, 1);\n        }\n        return null;\n    }\n\n    private final String _parseMediumName2(int ptr, int q3, final int q2) throws IOException {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        \n        int i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                _inputPtr = ptr;\n                return _findName(_quad1, q2, q3, 1);\n            }\n            return null;\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                _inputPtr = ptr;\n                return _findName(_quad1, q2, q3, 2);\n            }\n            return null;\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                _inputPtr = ptr;\n                return _findName(_quad1, q2, q3, 3);\n            }\n            return null;\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (i == INT_QUOTE) { \n            _inputPtr = ptr;\n            return _findName(_quad1, q2, q3, 4);\n        }\n        \n        return null;\n    }\n\n    \n    private final JsonToken _parseEscapedName(int qlen, int currQuad, int currQuadBytes) throws IOException {\n        \n        \n        \n        int[] quads = _quadBuffer;\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _quadLength = qlen;\n                _pending32 = currQuad;\n                _pendingBytes = currQuadBytes;\n                _minorState = MINOR_FIELD_NAME;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[ch] == 0) {\n                if (currQuadBytes < 4) {\n                    ++currQuadBytes;\n                    currQuad = (currQuad << 8) | ch;\n                    continue;\n                }\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n                continue;\n            }\n\n            \n            if (ch == INT_QUOTE) { \n                break;\n            }\n            \n            if (ch != INT_BACKSLASH) {\n                \n                _throwUnquotedSpace(ch, \"name\");\n            } else {\n                \n                ch = _decodeCharEscape();\n                if (ch < 0) { \n                    _minorState = MINOR_FIELD_NAME_ESCAPE;\n                    _minorStateAfterSplit = MINOR_FIELD_NAME;\n                    _quadLength = qlen;\n                    _pending32 = currQuad;\n                    _pendingBytes = currQuadBytes;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n            }\n\n            \n            \n            \n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            if (ch > 127) {\n                \n                if (currQuadBytes >= 4) {\n                    quads[qlen++] = currQuad;\n                    currQuad = 0;\n                    currQuadBytes = 0;\n                }\n                if (ch < 0x800) { \n                    currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                    ++currQuadBytes;\n                    \n                } else { \n                    currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                    ++currQuadBytes;\n                    \n                    if (currQuadBytes >= 4) {\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                    ++currQuadBytes;\n                }\n                \n                ch = 0x80 | (ch & 0x3f);\n            }\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n                continue;\n            }\n            quads[qlen++] = currQuad;\n            currQuad = ch;\n            currQuadBytes = 1;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = _padLastQuad(currQuad, currQuadBytes);\n        } else if (qlen == 0) { \n            return _fieldComplete(\"\");\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = _addName(quads, qlen, currQuadBytes);\n        }\n        return _fieldComplete(name);\n    }\n\n    \n    private JsonToken _handleOddName(int ch) throws IOException {\n        \n        switch (ch) {\n        case '#':\n            \n            \n            if ((_features & FEAT_MASK_ALLOW_YAML_COMMENTS) != 0) {\n                return _finishHashComment(MINOR_FIELD_LEADING_WS);\n            }\n            break;\n        case '/':\n            return _startSlashComment(MINOR_FIELD_LEADING_WS);\n        case '\\'':\n            if ((_features & FEAT_MASK_ALLOW_SINGLE_QUOTES) != 0) {\n                return _finishAposName(0, 0, 0);\n            }\n            break;\n        case ']': \n            return _closeArrayScope();\n        }\n        \n        if ((_features & FEAT_MASK_ALLOW_UNQUOTED_NAMES) == 0) {\n         \n\n            char c = (char) ch;\n            _reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n        }\n        \n        \n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n        \n        if (codes[ch] != 0) {\n            _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n\n        return _finishUnquotedName(0, ch, 1);\n    }\n\n    \n    private JsonToken _finishUnquotedName(int qlen, int currQuad, int currQuadBytes) throws IOException {\n        int[] quads = _quadBuffer;\n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n\n        \n        \n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _quadLength = qlen;\n                _pending32 = currQuad;\n                _pendingBytes = currQuadBytes;\n                _minorState = MINOR_FIELD_UNQUOTED_NAME;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (codes[ch] != 0) {\n                break;\n            }\n            ++_inputPtr;\n            \n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = _addName(quads, qlen, currQuadBytes);\n        }\n        return _fieldComplete(name);\n    }\n\n    private JsonToken _finishAposName(int qlen, int currQuad, int currQuadBytes) throws IOException {\n        int[] quads = _quadBuffer;\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _quadLength = qlen;\n                _pending32 = currQuad;\n                _pendingBytes = currQuadBytes;\n                _minorState = MINOR_FIELD_APOS_NAME;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch == INT_APOS) {\n                break;\n            }\n            \n            if (ch != '\"' && codes[ch] != 0) {\n                if (ch != '\\\\') {\n                    \n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    \n                    ch = _decodeCharEscape();\n                    if (ch < 0) { \n                        _minorState = MINOR_FIELD_NAME_ESCAPE;\n                        _minorStateAfterSplit = MINOR_FIELD_APOS_NAME;\n                        _quadLength = qlen;\n                        _pending32 = currQuad;\n                        _pendingBytes = currQuadBytes;\n                        return (_currToken = JsonToken.NOT_AVAILABLE);\n                    }\n                }\n                if (ch > 127) {\n                    \n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { \n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        \n                    } else { \n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        \n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    \n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            \n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = _padLastQuad(currQuad, currQuadBytes);\n        } else if (qlen == 0) { \n            return _fieldComplete(\"\");\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = _addName(quads, qlen, currQuadBytes);\n        }\n        return _fieldComplete(name);\n    }\n\n    protected final JsonToken _finishFieldWithEscape() throws IOException {\n        \n        int ch = _decodeSplitEscaped(_quoted32, _quotedDigits);\n        if (ch < 0) { \n            _minorState = MINOR_FIELD_NAME_ESCAPE;\n            return JsonToken.NOT_AVAILABLE;\n        }\n        if (_quadLength >= _quadBuffer.length) {\n            _quadBuffer = growArrayBy(_quadBuffer, 32);\n        }\n        int currQuad = _pending32;\n        int currQuadBytes = _pendingBytes;\n        if (ch > 127) {\n            \n            if (currQuadBytes >= 4) {\n                _quadBuffer[_quadLength++] = currQuad;\n                currQuad = 0;\n                currQuadBytes = 0;\n            }\n            if (ch < 0x800) { \n                currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                ++currQuadBytes;\n                \n            } else { \n                currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                \n                if (++currQuadBytes >= 4) {\n                    _quadBuffer[_quadLength++] = currQuad;\n                    currQuad = 0;\n                    currQuadBytes = 0;\n                }\n                currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                ++currQuadBytes;\n            }\n            \n            ch = 0x80 | (ch & 0x3f);\n        }\n        if (currQuadBytes < 4) {\n            ++currQuadBytes;\n            currQuad = (currQuad << 8) | ch;\n        } else {\n            _quadBuffer[_quadLength++] = currQuad;\n            currQuad = ch;\n            currQuadBytes = 1;\n        }\n        if (_minorStateAfterSplit == MINOR_FIELD_APOS_NAME) {\n            return _finishAposName(_quadLength, currQuad, currQuadBytes);\n        }\n        return _parseEscapedName(_quadLength, currQuad, currQuadBytes);\n    }\n\n    private int _decodeSplitEscaped(int value, int bytesRead) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            _quoted32 = value;\n            _quotedDigits = bytesRead;\n            return -1;\n        }\n        int c = _inputBuffer[_inputPtr++];\n        if (bytesRead == -1) { \n            switch (c) {\n                \n            case 'b':\n                return '\\b';\n            case 't':\n                return '\\t';\n            case 'n':\n                return '\\n';\n            case 'f':\n                return '\\f';\n            case 'r':\n                return '\\r';\n    \n                \n            case '\"':\n            case '/':\n            case '\\\\':\n                return c;\n    \n            case 'u': \n                break;\n    \n            default:\n                {\n                 \n    \n                    char ch = (char) c;\n                    return _handleUnrecognizedCharacterEscape(ch);\n                }\n            }\n            if (_inputPtr >= _inputEnd) {\n                _quotedDigits = 0;\n                _quoted32 = 0;\n                return -1;\n            }\n            c = _inputBuffer[_inputPtr++];\n            bytesRead = 0;\n        }\n        c &= 0xFF;\n        while (true) {\n            int digit = CharTypes.charToHex(c);\n            if (digit < 0) {\n                _reportUnexpectedChar(c, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n            if (++bytesRead == 4) {\n                return value;\n            }\n            if (_inputPtr >= _inputEnd) {\n                _quotedDigits = bytesRead;\n                _quoted32 = value;\n                return -1;\n            }\n            c = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n    }\n\n    \n\n    protected JsonToken _startString() throws IOException {\n        int ptr = _inputPtr;\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return _valueComplete(JsonToken.VALUE_STRING);\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        _inputPtr = ptr;\n        return _finishRegularString();\n    }\n\n    private final JsonToken _finishRegularString() throws IOException {\n        int c;\n\n        \n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int ptr = _inputPtr;\n        final int safeEnd = _inputEnd - 5; \n        \n        main_loop:\n        while (true) {\n            \n            ascii_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    _inputPtr = ptr;\n                    _minorState = MINOR_VALUE_STRING;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n            \n            if (c == INT_QUOTE) {\n                _inputPtr = ptr;\n                _textBuffer.setCurrentLength(outPtr);\n                return _valueComplete(JsonToken.VALUE_STRING);\n            }\n            \n            if (ptr >= safeEnd) {\n                _inputPtr = ptr;\n                _textBuffer.setCurrentLength(outPtr);\n                if (!_decodeSplitMultiByte(c, codes[c], ptr < _inputEnd)) {\n                    _minorStateAfterSplit = MINOR_VALUE_STRING;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                outBuf = _textBuffer.getBufferWithoutReset();\n                outPtr = _textBuffer.getCurrentSegmentSize();\n                ptr = _inputPtr;\n                continue main_loop;\n            }\n            \n            switch (codes[c]) {\n            case 1: \n                _inputPtr = ptr;\n                c = _decodeFastCharEscape(); \n                ptr = _inputPtr;\n                break;\n            case 2: \n                c = _decodeUTF8_2(c, _inputBuffer[ptr++]);\n                break;\n            case 3: \n                c = _decodeUTF8_3(c, _inputBuffer[ptr++], _inputBuffer[ptr++]);\n                break;\n            case 4: \n                c = _decodeUTF8_4(c, _inputBuffer[ptr++], _inputBuffer[ptr++],\n                        _inputBuffer[ptr++]);\n                \n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                \n                break;\n            default:\n                if (c < INT_SPACE) {\n                    \n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    \n                    _reportInvalidChar(c);\n                }\n            }\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            \n            outBuf[outPtr++] = (char) c;\n        }\n    }\n\n    protected JsonToken _startAposString() throws IOException {\n        int ptr = _inputPtr;\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (c == INT_APOS) {\n                _inputPtr = ptr+1;\n                _textBuffer.setCurrentLength(outPtr);\n                return _valueComplete(JsonToken.VALUE_STRING);\n            }\n\n            if (codes[c] != 0) {\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        _inputPtr = ptr;\n        return _finishAposString();\n    }\n\n    private final JsonToken _finishAposString() throws IOException {\n        int c;\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int ptr = _inputPtr;\n        final int safeEnd = _inputEnd - 5; \n        \n        main_loop:\n        while (true) {\n            ascii_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    _inputPtr = ptr;\n                    _minorState = MINOR_VALUE_APOS_STRING;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = inputBuffer[ptr++] & 0xFF;\n                    if ((codes[c] != 0) && (c != INT_QUOTE)) {\n                        break ascii_loop;\n                    }\n                    if (c == INT_APOS) {\n                        _inputPtr = ptr;\n                        _textBuffer.setCurrentLength(outPtr);\n                        return _valueComplete(JsonToken.VALUE_STRING);\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n            \n            \n            if (ptr >= safeEnd) {\n                _inputPtr = ptr;\n                _textBuffer.setCurrentLength(outPtr);\n                if (!_decodeSplitMultiByte(c, codes[c], ptr < _inputEnd)) {\n                    _minorStateAfterSplit = MINOR_VALUE_APOS_STRING;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                outBuf = _textBuffer.getBufferWithoutReset();\n                outPtr = _textBuffer.getCurrentSegmentSize();\n                ptr = _inputPtr;\n                continue main_loop;\n            }\n            \n            switch (codes[c]) {\n            case 1: \n                _inputPtr = ptr;\n                c = _decodeFastCharEscape(); \n                ptr = _inputPtr;\n                break;\n            case 2: \n                c = _decodeUTF8_2(c, _inputBuffer[ptr++]);\n                break;\n            case 3: \n                c = _decodeUTF8_3(c, _inputBuffer[ptr++], _inputBuffer[ptr++]);\n                break;\n            case 4: \n                c = _decodeUTF8_4(c, _inputBuffer[ptr++], _inputBuffer[ptr++],\n                        _inputBuffer[ptr++]);\n                \n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                \n                break;\n            default:\n                if (c < INT_SPACE) {\n                    \n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    \n                    _reportInvalidChar(c);\n                }\n            }\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            \n            outBuf[outPtr++] = (char) c;\n        }\n    }\n    \n    private final boolean _decodeSplitMultiByte(int c, int type, boolean gotNext) throws IOException {\n        switch (type) {\n        case 1:\n            c = _decodeSplitEscaped(0, -1);\n            if (c < 0) {\n                _minorState = MINOR_VALUE_STRING_ESCAPE;\n                return false;\n            }\n            _textBuffer.append((char) c);\n            return true;\n        case 2: \n            if (gotNext) {\n                \n                c = _decodeUTF8_2(c, _inputBuffer[_inputPtr++]);\n                _textBuffer.append((char) c);\n                return true;\n            }\n            _minorState = MINOR_VALUE_STRING_UTF8_2;\n            _pending32 = c;\n            return false;\n        case 3: \n            c &= 0x0F;\n            if (gotNext) {\n                return _decodeSplitUTF8_3(c, 1, _inputBuffer[_inputPtr++]);\n            }\n            _minorState = MINOR_VALUE_STRING_UTF8_3;\n            _pending32 = c;\n            _pendingBytes = 1;\n            return false;\n        case 4: \n            c &= 0x07;\n            if (gotNext) {\n                return _decodeSplitUTF8_4(c, 1, _inputBuffer[_inputPtr++]);\n            }\n            _pending32 = c;\n            _pendingBytes = 1;\n            _minorState = MINOR_VALUE_STRING_UTF8_4;\n            return false;\n        default:\n            if (c < INT_SPACE) {\n                \n                _throwUnquotedSpace(c, \"string value\");\n            } else {\n                \n                _reportInvalidChar(c);\n            }\n            _textBuffer.append((char) c);\n            return true;\n        }\n    }\n\n    private final boolean _decodeSplitUTF8_3(int prev, int prevCount, int next) throws IOException {\n        if (prevCount == 1) {\n            if ((next & 0xC0) != 0x080) {\n                _reportInvalidOther(next & 0xFF, _inputPtr);\n            }\n            prev = (prev << 6) | (next & 0x3F);\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_VALUE_STRING_UTF8_3;\n                _pending32 = prev;\n                _pendingBytes = 2;\n                return false;\n            }\n            next = _inputBuffer[_inputPtr++];\n        }\n        if ((next & 0xC0) != 0x080) {\n            _reportInvalidOther(next & 0xFF, _inputPtr);\n        }\n        _textBuffer.append((char) ((prev << 6) | (next & 0x3F)));\n        return true;\n    }\n\n    \n    \n    private final boolean _decodeSplitUTF8_4(int prev, int prevCount, int next) throws IOException {\n        if (prevCount == 1) {\n            if ((next & 0xC0) != 0x080) {\n                _reportInvalidOther(next & 0xFF, _inputPtr);\n            }\n            prev = (prev << 6) | (next & 0x3F);\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_VALUE_STRING_UTF8_4;\n                _pending32 = prev;\n                _pendingBytes = 2;\n                return false;\n            }\n            prevCount = 2;\n            next = _inputBuffer[_inputPtr++];\n        }\n        if (prevCount == 2) {\n            if ((next & 0xC0) != 0x080) {\n                _reportInvalidOther(next & 0xFF, _inputPtr);\n            }\n            prev = (prev << 6) | (next & 0x3F);\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_VALUE_STRING_UTF8_4;\n                _pending32 = prev;\n                _pendingBytes = 3;\n                return false;\n            }\n            next = _inputBuffer[_inputPtr++];\n        }\n        if ((next & 0xC0) != 0x080) {\n            _reportInvalidOther(next & 0xFF, _inputPtr);\n        }\n        int c = ((prev << 6) | (next & 0x3F)) - 0x10000;\n        \n        _textBuffer.append((char) (0xD800 | (c >> 10)));\n        c = 0xDC00 | (c & 0x3FF);\n        \n        _textBuffer.append((char) c);\n        return true;\n    }\n\n    \n\n    private final int _decodeCharEscape() throws IOException {\n        int left = _inputEnd - _inputPtr;\n        if (left < 5) { \n            return _decodeSplitEscaped(0, -1);\n        }\n        return _decodeFastCharEscape();\n    }\n\n    private final int _decodeFastCharEscape() throws IOException {\n        int c = (int) _inputBuffer[_inputPtr++];\n        switch (c) {\n            \n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            \n        case '\"':\n        case '/':\n        case '\\\\':\n            return (char) c;\n\n        case 'u': \n            break;\n\n        default:\n            {\n             \n\n                char ch = (char) c;\n                return _handleUnrecognizedCharacterEscape(ch);\n            }\n        }\n\n        int ch = (int) _inputBuffer[_inputPtr++];\n        int digit = CharTypes.charToHex(ch);\n        int result = digit;\n\n        if (digit >= 0) {\n            ch = (int) _inputBuffer[_inputPtr++];\n            digit = CharTypes.charToHex(ch);\n            if (digit >= 0) {\n                result = (result << 4) | digit;\n                ch = (int) _inputBuffer[_inputPtr++];\n                digit = CharTypes.charToHex(ch);\n                if (digit >= 0) {\n                    result = (result << 4) | digit;\n                    ch = (int) _inputBuffer[_inputPtr++];\n                    digit = CharTypes.charToHex(ch);\n                    if (digit >= 0) {\n                        return (result << 4) | digit;\n                    }\n                }\n            }\n        }\n        _reportUnexpectedChar(ch & 0xFF, \"expected a hex-digit for character escape sequence\");\n        return -1;\n    }\n\n    \n\n    private final int _decodeUTF8_2(int c, int d) throws IOException {\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        return ((c & 0x1F) << 6) | (d & 0x3F);\n    }\n\n    private final int _decodeUTF8_3(int c, int d, int e) throws IOException {\n        c &= 0x0F;\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        if ((e & 0xC0) != 0x080) {\n            _reportInvalidOther(e & 0xFF, _inputPtr);\n        }\n        return (c << 6) | (e & 0x3F);\n    }\n\n    \n    \n    private final int _decodeUTF8_4(int c, int d, int e, int f) throws IOException {\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = ((c & 0x07) << 6) | (d & 0x3F);\n        if ((e & 0xC0) != 0x080) {\n            _reportInvalidOther(e & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (e & 0x3F);\n        if ((f & 0xC0) != 0x080) {\n            _reportInvalidOther(f & 0xFF, _inputPtr);\n        }\n        return ((c << 6) | (f & 0x3F)) - 0x10000;\n    }\n\n    \n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.core.json.async;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.async.ByteArrayFeeder;\nimport com.fasterxml.jackson.core.async.NonBlockingInputFeeder;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\npublic class NonBlockingJsonParser extends NonBlockingJsonParserBase implements ByteArrayFeeder { @SuppressWarnings(\"deprecation\") private final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask(); @SuppressWarnings(\"deprecation\") private final static int FEAT_MASK_LEADING_ZEROS = Feature.ALLOW_NUMERIC_LEADING_ZEROS.getMask(); @SuppressWarnings(\"deprecation\") private final static int FEAT_MASK_ALLOW_MISSING = Feature.ALLOW_MISSING_VALUES.getMask(); private final static int FEAT_MASK_ALLOW_SINGLE_QUOTES = Feature.ALLOW_SINGLE_QUOTES.getMask(); private final static int FEAT_MASK_ALLOW_UNQUOTED_NAMES = Feature.ALLOW_UNQUOTED_FIELD_NAMES.getMask(); private final static int FEAT_MASK_ALLOW_JAVA_COMMENTS = Feature.ALLOW_COMMENTS.getMask(); private final static int FEAT_MASK_ALLOW_YAML_COMMENTS = Feature.ALLOW_YAML_COMMENTS.getMask(); private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8(); protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); protected byte[] _inputBuffer = NO_BYTES; protected int _origBufferLen; public NonBlockingJsonParser(IOContext ctxt, int parserFeatures, ByteQuadsCanonicalizer sym) {\n        super(ctxt, parserFeatures, sym);\n    }\n\n    \n\n    @Override\n    public ByteArrayFeeder getNonBlockingInputFeeder() {\n        return this;\n    }\n\n    @Override\n    public final boolean needMoreInput() {\n        return (_inputPtr >=_inputEnd) && !_endOfInput;\n    }\n\n    @Override\n    public void feedInput(byte[] buf, int start, int end) throws IOException {\n        \n        if (_inputPtr < _inputEnd) {\n            _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n        }\n        if (end < start) {\n            _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n        }\n        \n        if (_endOfInput) {\n            _reportError(\"Already closed, can not feed more input\");\n        }\n        \n        _currInputProcessed += _origBufferLen;\n\n        \n        _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n\n        \n        _currBufferStart = start;\n        _inputBuffer = buf;\n        _inputPtr = start;\n        _inputEnd = end;\n        _origBufferLen = end - start;\n    }\n\n    @Override\n    public void endOfInput() {\n        _endOfInput = true;\n    }\n\n    \n\n    \n\n\n\n\n\n\n\n    @Override\n    public int releaseBuffered(OutputStream out) throws IOException {\n        int avail = _inputEnd - _inputPtr;\n        if (avail > 0) {\n            out.write(_inputBuffer, _inputPtr, avail);\n        }\n        return avail;\n    }\n\n    \n    \n    @Override\n    protected char _decodeEscaped() throws IOException {\n        VersionUtil.throwInternal();\n        return ' ';\n    }\n\n    \n\n    @Override\n    public JsonToken nextToken() throws IOException {\n        \n        \n        if (_inputPtr >= _inputEnd) {\n            if (_closed) {\n                return null;\n            }\n            \n            if (_endOfInput) { \n                \n                \n                if (_currToken == JsonToken.NOT_AVAILABLE) {\n                    return _finishTokenWithEOF();\n                }\n                return _eofAsNextToken();\n            }\n            return JsonToken.NOT_AVAILABLE;\n        }\n        \n        if (_currToken == JsonToken.NOT_AVAILABLE) {\n            return _finishToken();\n        }\n\n        \n        _numTypesValid = NR_UNKNOWN;\n        _tokenInputTotal = _currInputProcessed + _inputPtr;\n        \n        _binaryValue = null;\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n\n        switch (_majorState) {\n        case MAJOR_INITIAL:\n            return _startDocument(ch);\n\n        case MAJOR_ROOT:\n            return _startValue(ch);\n\n        case MAJOR_OBJECT_FIELD_FIRST: \n            return _startFieldName(ch);\n        case MAJOR_OBJECT_FIELD_NEXT: \n            return _startFieldNameAfterComma(ch);\n\n        case MAJOR_OBJECT_VALUE: \n            return _startValueExpectColon(ch);\n\n        case MAJOR_ARRAY_ELEMENT_FIRST: \n            return _startValue(ch);\n\n        case MAJOR_ARRAY_ELEMENT_NEXT: \n            return _startValueExpectComma(ch);\n\n        default:\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    \n    protected final JsonToken _finishToken() throws IOException {\n        \n        switch (_minorState) {\n        case MINOR_ROOT_BOM:\n            return _finishBOM(_pending32);\n        case MINOR_FIELD_LEADING_WS:\n            return _startFieldName(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_FIELD_LEADING_COMMA:\n            return _startFieldNameAfterComma(_inputBuffer[_inputPtr++] & 0xFF);\n\n        \n        case MINOR_FIELD_NAME:\n            return _parseEscapedName(_quadLength,  _pending32, _pendingBytes);\n        case MINOR_FIELD_NAME_ESCAPE:\n            return _finishFieldWithEscape();\n        case MINOR_FIELD_APOS_NAME:\n            return _finishAposName(_quadLength,  _pending32, _pendingBytes);\n        case MINOR_FIELD_UNQUOTED_NAME:\n            return _finishUnquotedName(_quadLength,  _pending32, _pendingBytes);\n\n        \n\n        case MINOR_VALUE_LEADING_WS:\n            return _startValue(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_VALUE_WS_AFTER_COMMA:\n            return _startValueAfterComma(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_VALUE_EXPECTING_COMMA:\n            return _startValueExpectComma(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_VALUE_EXPECTING_COLON:\n            return _startValueExpectColon(_inputBuffer[_inputPtr++] & 0xFF);\n\n        case MINOR_VALUE_TOKEN_NULL:\n            return _finishKeywordToken(\"null\", _pending32, JsonToken.VALUE_NULL);\n        case MINOR_VALUE_TOKEN_TRUE:\n            return _finishKeywordToken(\"true\", _pending32, JsonToken.VALUE_TRUE);\n        case MINOR_VALUE_TOKEN_FALSE:\n            return _finishKeywordToken(\"false\", _pending32, JsonToken.VALUE_FALSE);\n        case MINOR_VALUE_TOKEN_NON_STD:\n            return _finishNonStdToken(_nonStdTokenType, _pending32);\n\n        case MINOR_NUMBER_MINUS:\n            return _finishNumberMinus(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_NUMBER_ZERO:\n            return _finishNumberLeadingZeroes();\n        case MINOR_NUMBER_MINUSZERO:\n            return _finishNumberLeadingNegZeroes();\n        case MINOR_NUMBER_INTEGER_DIGITS:\n            return _finishNumberIntegralPart(_textBuffer.getBufferWithoutReset(),\n                    _textBuffer.getCurrentSegmentSize());\n        case MINOR_NUMBER_FRACTION_DIGITS:\n            return _finishFloatFraction();\n        case MINOR_NUMBER_EXPONENT_MARKER:\n            return _finishFloatExponent(true, _inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_NUMBER_EXPONENT_DIGITS:\n            return _finishFloatExponent(false, _inputBuffer[_inputPtr++] & 0xFF);\n\n        case MINOR_VALUE_STRING:\n            return _finishRegularString();\n        case MINOR_VALUE_STRING_UTF8_2:\n            _textBuffer.append((char) _decodeUTF8_2(_pending32, _inputBuffer[_inputPtr++]));\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n        case MINOR_VALUE_STRING_UTF8_3:\n            if (!_decodeSplitUTF8_3(_pending32, _pendingBytes, _inputBuffer[_inputPtr++])) {\n                return JsonToken.NOT_AVAILABLE;\n            }\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n        case MINOR_VALUE_STRING_UTF8_4:\n            if (!_decodeSplitUTF8_4(_pending32, _pendingBytes, _inputBuffer[_inputPtr++])) {\n                return JsonToken.NOT_AVAILABLE;\n            }\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n\n        case MINOR_VALUE_STRING_ESCAPE:\n            {\n                int c = _decodeSplitEscaped(_quoted32, _quotedDigits);\n                if (c < 0) {\n                    return JsonToken.NOT_AVAILABLE;\n                }\n                _textBuffer.append((char) c);\n            }\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n\n        case MINOR_VALUE_APOS_STRING:\n            return _finishAposString();\n\n        case MINOR_VALUE_TOKEN_ERROR: \n            return _finishErrorToken();\n\n        \n            \n        case MINOR_COMMENT_LEADING_SLASH:\n            return _startSlashComment(_pending32);\n        case MINOR_COMMENT_CLOSING_ASTERISK:\n            return _finishCComment(_pending32, true);\n        case MINOR_COMMENT_C:\n            return _finishCComment(_pending32, false);\n        case MINOR_COMMENT_CPP:\n            return _finishCppComment(_pending32);\n        case MINOR_COMMENT_YAML:\n            return _finishHashComment(_pending32);\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    \n    protected final JsonToken _finishTokenWithEOF() throws IOException {\n        \n        JsonToken t = _currToken;\n        switch (_minorState) {\n        case MINOR_ROOT_GOT_SEPARATOR: \n            return _eofAsNextToken();\n        case MINOR_VALUE_LEADING_WS: \n            return _eofAsNextToken();\n\n\n        case MINOR_VALUE_TOKEN_NULL:\n            return _finishKeywordTokenWithEOF(\"null\", _pending32, JsonToken.VALUE_NULL);\n        case MINOR_VALUE_TOKEN_TRUE:\n            return _finishKeywordTokenWithEOF(\"true\", _pending32, JsonToken.VALUE_TRUE);\n        case MINOR_VALUE_TOKEN_FALSE:\n            return _finishKeywordTokenWithEOF(\"false\", _pending32, JsonToken.VALUE_FALSE);\n        case MINOR_VALUE_TOKEN_NON_STD:\n            return _finishNonStdTokenWithEOF(_nonStdTokenType, _pending32);\n        case MINOR_VALUE_TOKEN_ERROR: \n            return _finishErrorTokenWithEOF();\n\n        \n        case MINOR_NUMBER_ZERO:\n        case MINOR_NUMBER_MINUSZERO:\n            \n            \n            return _valueCompleteInt(0, \"0\");\n        case MINOR_NUMBER_INTEGER_DIGITS:\n            \n            {\n                int len = _textBuffer.getCurrentSegmentSize();\n                if (_numberNegative) {\n                    --len;\n                }\n                _intLength = len;\n            }\n            return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n\n        case MINOR_NUMBER_FRACTION_DIGITS:\n            _expLength = 0;\n            \n        case MINOR_NUMBER_EXPONENT_DIGITS:\n            return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n\n        case MINOR_NUMBER_EXPONENT_MARKER:\n            _reportInvalidEOF(\": was expecting fraction after exponent marker\", JsonToken.VALUE_NUMBER_FLOAT);\n\n            \n            \n\n\n        case MINOR_COMMENT_CLOSING_ASTERISK:\n        case MINOR_COMMENT_C:\n            _reportInvalidEOF(\": was expecting closing '*/' for comment\", JsonToken.NOT_AVAILABLE);\n\n        case MINOR_COMMENT_CPP:\n        case MINOR_COMMENT_YAML:\n            \n            return _eofAsNextToken();\n            \n        default:\n        }\n        _reportInvalidEOF(\": was expecting rest of token (internal state: \"+_minorState+\")\", _currToken);\n        return t; \n    }\n\n    \n\n    private final JsonToken _startDocument(int ch) throws IOException {\n        ch &= 0xFF;\n\n        \n        if ((ch == 0xEF) && (_minorState != MINOR_ROOT_BOM)) {\n            return _finishBOM(1);\n        }\n\n        \n        while (ch <= 0x020) {\n            if (ch != INT_SPACE) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_ROOT_GOT_SEPARATOR;\n                if (_closed) {\n                    return null;\n                }\n                \n                if (_endOfInput) { \n                    return _eofAsNextToken();\n                }\n                return JsonToken.NOT_AVAILABLE;\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        return _startValue(ch);\n    }\n\n    private final JsonToken _finishBOM(int bytesHandled) throws IOException {\n        \n        \n        \n\n        while (_inputPtr < _inputEnd) {\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            switch (bytesHandled) {\n            case 3:\n                \n                \n                _currInputProcessed -= 3;\n                return _startDocument(ch);\n            case 2:\n                if (ch != 0xBF) {\n                    _reportError(\"Unexpected byte 0x%02x following 0xEF 0xBB; should get 0xBF as third byte of UTF-8 BOM\", ch);\n                }\n                break;\n            case 1:\n                if (ch != 0xBB) {\n                    _reportError(\"Unexpected byte 0x%02x following 0xEF; should get 0xBB as second byte UTF-8 BOM\", ch);\n                }\n                break;\n            }\n            ++bytesHandled;\n        }\n        _pending32 = bytesHandled;\n        _minorState = MINOR_ROOT_BOM;\n        return (_currToken = JsonToken.NOT_AVAILABLE);\n    }\n\n    \n\n    \n    private final JsonToken _startFieldName(int ch) throws IOException {\n        \n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch != INT_QUOTE) {\n            if (ch == INT_RCURLY) {\n                return _closeObjectScope();\n            }\n            return _handleOddName(ch);\n        }\n        \n        if ((_inputPtr + 13) <= _inputEnd) { \n            String n = _fastParseName();\n            if (n != null) {\n                return _fieldComplete(n);\n            }\n        }\n        return _parseEscapedName(0, 0, 0);\n    }\n\n    private final JsonToken _startFieldNameAfterComma(int ch) throws IOException {\n        \n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); \n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_COMMA;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COMMA) { \n            if (ch == INT_RCURLY) {\n                return _closeObjectScope();\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_FIELD_LEADING_COMMA);\n            }\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_FIELD_LEADING_COMMA);\n            }\n            _reportUnexpectedChar(ch, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_FIELD_LEADING_WS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch != INT_QUOTE) {\n            if (ch == INT_RCURLY) {\n                if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                    return _closeObjectScope();\n                }\n            }\n            return _handleOddName(ch);\n        }\n        \n        if ((_inputPtr + 13) <= _inputEnd) { \n            String n = _fastParseName();\n            if (n != null) {\n                return _fieldComplete(n);\n            }\n        }\n        return _parseEscapedName(0, 0, 0);\n    }\n\n    \n    \n    \n    private final JsonToken _startValue(int ch) throws IOException {\n        \n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_LEADING_WS);\n        case '-':\n            return _startNegativeNumber();\n        case '/': \n            return _startSlashComment(MINOR_VALUE_LEADING_WS);\n            \n        \n        \n        \n        case '0':\n            return _startNumberLeadingZero();\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            return _closeArrayScope();\n        case '{':\n            return _startObjectScope();\n        case '}':\n            return _closeObjectScope();\n        default:\n        }\n        return _startUnexpectedValue(false, ch);\n    }\n\n    \n    private final JsonToken _startValueExpectComma(int ch) throws IOException {\n        \n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); \n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_EXPECTING_COMMA;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COMMA) {\n            if (ch == INT_RBRACKET) {\n                return _closeArrayScope();\n            }\n            if (ch == INT_RCURLY){\n                return _closeObjectScope();\n            }\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_VALUE_EXPECTING_COMMA);\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_VALUE_EXPECTING_COMMA);\n            }\n            _reportUnexpectedChar(ch, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_WS_AFTER_COMMA);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_WS_AFTER_COMMA);\n\n        \n        \n        \n        case '0':\n            return _startNumberLeadingZero();\n\n        case '1':\n        case '2': case '3':\n        case '4': case '5':\n        case '6': case '7':\n        case '8': case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            \n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeArrayScope();\n            }\n            break;\n        case '{':\n            return _startObjectScope();\n        case '}':\n            \n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeObjectScope();\n            }\n            break;\n        default:\n        }\n        return _startUnexpectedValue(true, ch);\n    }\n\n    \n    private final JsonToken _startValueExpectColon(int ch) throws IOException {\n        \n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); \n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_EXPECTING_COLON;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COLON) {\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_VALUE_EXPECTING_COLON);\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_VALUE_EXPECTING_COLON);\n            }\n            \n            _reportUnexpectedChar(ch, \"was expecting a colon to separate field name and value\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_VALUE_LEADING_WS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); \n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_LEADING_WS);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_LEADING_WS);\n\n        \n        \n        \n        case '0':\n            return _startNumberLeadingZero();\n\n        case '1':\n        case '2': case '3':\n        case '4': case '5':\n        case '6': case '7':\n        case '8': case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case '{':\n            return _startObjectScope();\n        default:\n        }\n        return _startUnexpectedValue(false, ch);\n    }\n\n    \n    private final JsonToken _startValueAfterComma(int ch) throws IOException {\n        \n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_WS_AFTER_COMMA);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_WS_AFTER_COMMA);\n\n        \n        \n        \n        case '0':\n            return _startNumberLeadingZero();\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            \n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeArrayScope();\n            }\n            break;\n        case '{':\n            return _startObjectScope();\n        case '}':\n            \n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeObjectScope();\n            }\n            break;\n        default:\n        }\n        return _startUnexpectedValue(true, ch);\n    }\n\n    protected JsonToken _startUnexpectedValue(boolean leadingComma, int ch) throws IOException {\n        switch (ch) {\n        case ']':\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            \n        case ',':\n            \n            \n            \n            if ((_features & FEAT_MASK_ALLOW_MISSING) != 0) {\n                --_inputPtr;\n                return _valueComplete(JsonToken.VALUE_NULL);\n            }\n            \n        case '}':\n            \n            \n            break;\n        case '\\'':\n            if ((_features & FEAT_MASK_ALLOW_SINGLE_QUOTES) != 0) {\n                return _startAposString();\n            }\n            break;\n        case '+':\n            return _finishNonStdToken(NON_STD_TOKEN_PLUS_INFINITY, 1);\n        case 'N':\n            return _finishNonStdToken(NON_STD_TOKEN_NAN, 1);            \n        case 'I':\n            return _finishNonStdToken(NON_STD_TOKEN_INFINITY, 1);\n        }\n        \n        _reportUnexpectedChar(ch, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    \n    \n    private final int _skipWS(int ch) throws IOException {\n        do {\n            if (ch != INT_SPACE) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n            if (_inputPtr >= _inputEnd) {\n                _currToken = JsonToken.NOT_AVAILABLE;\n                return 0;\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        } while (ch <= 0x0020);\n        return ch;\n    }\n\n    private final JsonToken _startSlashComment(int fromMinorState) throws IOException {\n        if ((_features & FEAT_MASK_ALLOW_JAVA_COMMENTS) == 0) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n\n        \n        if (_inputPtr >= _inputEnd) {\n            _pending32 = fromMinorState;\n            _minorState = MINOR_COMMENT_LEADING_SLASH;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++];\n        if (ch == INT_ASTERISK) { \n            return _finishCComment(fromMinorState, false);\n        }\n        if (ch == INT_SLASH) { \n            return _finishCppComment(fromMinorState);\n        }\n        _reportUnexpectedChar(ch & 0xFF, \"was expecting either '*' or '/' for a comment\");\n        return null;\n    }\n\n    private final JsonToken _finishHashComment(int fromMinorState) throws IOException {\n        \n        if ((_features & FEAT_MASK_ALLOW_YAML_COMMENTS) == 0) {\n            _reportUnexpectedChar('#', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_YAML_COMMENTS' not enabled for parser)\");\n        }\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_COMMENT_YAML;\n                _pending32 = fromMinorState;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < 0x020) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n        }\n        return _startAfterComment(fromMinorState);\n    }\n\n    private final JsonToken _finishCppComment(int fromMinorState) throws IOException {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_COMMENT_CPP;\n                _pending32 = fromMinorState;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < 0x020) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n        }\n        return _startAfterComment(fromMinorState);\n    }\n\n    private final JsonToken _finishCComment(int fromMinorState, boolean gotStar) throws IOException {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = gotStar ? MINOR_COMMENT_CLOSING_ASTERISK : MINOR_COMMENT_C;\n                _pending32 = fromMinorState;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < 0x020) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            } else if (ch == INT_ASTERISK) {\n                gotStar = true;\n                continue;\n            } else if (ch == INT_SLASH) {\n                if (gotStar) {\n                    break;\n                }\n            }\n            gotStar = false;\n        }\n        return _startAfterComment(fromMinorState);\n    }\n\n    private final JsonToken _startAfterComment(int fromMinorState) throws IOException {\n        \n        if (_inputPtr >= _inputEnd) {\n            _minorState = fromMinorState;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        switch (fromMinorState) {\n        case MINOR_FIELD_LEADING_WS:\n            return _startFieldName(ch);\n        case MINOR_FIELD_LEADING_COMMA:\n            return _startFieldNameAfterComma(ch);\n        case MINOR_VALUE_LEADING_WS:\n            return _startValue(ch);\n        case MINOR_VALUE_EXPECTING_COMMA:\n            return _startValueExpectComma(ch);\n        case MINOR_VALUE_EXPECTING_COLON:\n            return _startValueExpectColon(ch);\n        case MINOR_VALUE_WS_AFTER_COMMA:\n            return _startValueAfterComma(ch);\n        default:\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    \n\n    protected JsonToken _startFalseToken() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) { \n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'a') \n                   && (buf[ptr++] == 'l')\n                   && (buf[ptr++] == 's')\n                   && (buf[ptr++] == 'e')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { \n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_FALSE);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_FALSE;\n        return _finishKeywordToken(\"false\", 1, JsonToken.VALUE_FALSE);\n    }\n\n    protected JsonToken _startTrueToken() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) { \n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'r') \n                   && (buf[ptr++] == 'u')\n                   && (buf[ptr++] == 'e')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { \n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_TRUE);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_TRUE;\n        return _finishKeywordToken(\"true\", 1, JsonToken.VALUE_TRUE);\n    }\n\n    protected JsonToken _startNullToken() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) { \n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'u') \n                   && (buf[ptr++] == 'l')\n                   && (buf[ptr++] == 'l')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { \n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_NULL);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_NULL;\n        return _finishKeywordToken(\"null\", 1, JsonToken.VALUE_NULL);\n    }\n\n    protected JsonToken _finishKeywordToken(String expToken, int matched, JsonToken result) throws IOException {\n        final int end = expToken.length();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _pending32 = matched;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr];\n            if (matched == end) { \n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { \n                    return _valueComplete(result);\n                }\n                break;\n            }\n            if (ch != expToken.charAt(matched)) {\n                break;\n            }\n            ++matched;\n            ++_inputPtr;\n        }\n        _minorState = MINOR_VALUE_TOKEN_ERROR;\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorToken();\n    }\n\n    protected JsonToken _finishKeywordTokenWithEOF(String expToken, int matched, JsonToken result) throws IOException {\n        if (matched == expToken.length()) {\n            return (_currToken = result);\n        }\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorTokenWithEOF();\n    }\n\n    protected JsonToken _finishNonStdToken(int type, int matched) throws IOException {\n        final String expToken = _nonStdToken(type);\n        final int end = expToken.length();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _nonStdTokenType = type;\n                _pending32 = matched;\n                _minorState = MINOR_VALUE_TOKEN_NON_STD;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr];\n            if (matched == end) { \n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { \n                    return _valueNonStdNumberComplete(type);\n                }\n                break;\n            }\n            if (ch != expToken.charAt(matched)) {\n                break;\n            }\n            ++matched;\n            ++_inputPtr;\n        }\n        _minorState = MINOR_VALUE_TOKEN_ERROR;\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorToken();\n    }\n\n    protected JsonToken _finishNonStdTokenWithEOF(int type, int matched) throws IOException {\n        final String expToken = _nonStdToken(type);\n        if (matched == expToken.length()) {\n            return _valueNonStdNumberComplete(type);\n        }\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorTokenWithEOF();\n    }\n\n    protected JsonToken _finishErrorToken() throws IOException {\n        while (_inputPtr < _inputEnd) {\n            int i = (int) _inputBuffer[_inputPtr++];\n\n\n\n\n            char ch = (char) i;\n            if (Character.isJavaIdentifierPart(ch)) {\n                \n                \n                _textBuffer.append(ch);\n                if (_textBuffer.size() < MAX_ERROR_TOKEN_LENGTH) {\n                    continue;\n                }\n            }\n            return _reportErrorToken(_textBuffer.contentsAsString());\n        }\n        return (_currToken = JsonToken.NOT_AVAILABLE);\n    }\n\n    protected JsonToken _finishErrorTokenWithEOF() throws IOException {\n        return _reportErrorToken(_textBuffer.contentsAsString());\n    }\n\n    protected JsonToken _reportErrorToken(String actualToken) throws IOException {\n        \n        _reportError(\"Unrecognized token '%s': was expecting %s\", _textBuffer.contentsAsString(),\n                \"'null', 'true' or 'false'\");\n        return JsonToken.NOT_AVAILABLE; \n    }\n    \n    \n\n    protected JsonToken _startPositiveNumber(int ch) throws IOException {\n        _numberNegative = false;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = (char) ch;\n        \n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n            _textBuffer.setCurrentLength(1);\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n\n        int outPtr = 1;\n\n        ch = _inputBuffer[_inputPtr] & 0xFF;\n        while (true) {\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    _intLength = outPtr;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    _intLength = outPtr;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                \n                \n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (++_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n                _textBuffer.setCurrentLength(outPtr);\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n        }\n        _intLength = outPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }\n\n    protected JsonToken _startNegativeNumber() throws IOException {\n        _numberNegative = true;\n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_MINUS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch <= INT_0) {\n            if (ch == INT_0) {\n                return _finishNumberLeadingNegZeroes();\n            }\n            \n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        } else if (ch > INT_9) {\n            if (ch == 'I') {\n                return _finishNonStdToken(NON_STD_TOKEN_MINUS_INFINITY, 2);\n            }\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        }\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = '-';\n        outBuf[1] = (char) ch;\n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n            _textBuffer.setCurrentLength(2);\n            _intLength = 1;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[_inputPtr];\n        int outPtr = 2;\n\n        while (true) {\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    _intLength = outPtr-1;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    _intLength = outPtr-1;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                \n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (++_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n                _textBuffer.setCurrentLength(outPtr);\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n        }\n        _intLength = outPtr-1;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }\n\n    protected JsonToken _startNumberLeadingZero() throws IOException {\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_ZERO;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n\n        \n        \n        \n\n        int ch = _inputBuffer[ptr++] & 0xFF;\n        \n        if (ch < INT_0) {\n            if (ch == INT_PERIOD) {\n                _inputPtr = ptr;\n                _intLength = 1;\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                outBuf[0] = '0';\n                return _startFloat(outBuf, 1, ch);\n            }\n        } else if (ch > INT_9) {\n            if (ch == INT_e || ch == INT_E) {\n                _inputPtr = ptr;\n                _intLength = 1;\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                outBuf[0] = '0';\n                return _startFloat(outBuf, 1, ch);\n            }\n            \n            \n            \n            if ((ch != INT_RBRACKET) && (ch != INT_RCURLY)) {\n                reportUnexpectedNumberChar(ch,\n                        \"expected digit (0-9), decimal point (.) or exponent indicator (e/E) to follow '0'\");\n            }\n        } else { \n            \n            return _finishNumberLeadingZeroes();\n        }\n        \n        return _valueCompleteInt(0, \"0\");\n    }\n\n    protected JsonToken _finishNumberMinus(int ch) throws IOException {\n        if (ch <= INT_0) {\n            if (ch == INT_0) {\n                return _finishNumberLeadingNegZeroes();\n            }\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        } else if (ch > INT_9) {\n            if (ch == 'I') {\n                return _finishNonStdToken(NON_STD_TOKEN_MINUS_INFINITY, 2);\n            }\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        }\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = '-';\n        outBuf[1] = (char) ch;\n        _intLength = 1;\n        return _finishNumberIntegralPart(outBuf, 2);\n    }\n\n    protected JsonToken _finishNumberLeadingZeroes() throws IOException {\n        \n        \n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_ZERO;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 1, ch);\n                }\n            } else if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 1, ch);\n                }\n                \n                \n                \n                if ((ch != INT_RBRACKET) && (ch != INT_RCURLY)) {\n                    reportUnexpectedNumberChar(ch,\n                            \"expected digit (0-9), decimal point (.) or exponent indicator (e/E) to follow '0'\");\n                }\n            } else { \n                \n                \n                if ((_features & FEAT_MASK_LEADING_ZEROS) == 0) {\n                    reportInvalidNumber(\"Leading zeroes not allowed\");\n                }\n                if (ch == INT_0) { \n                    continue;\n                }\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                \n                outBuf[0] = (char) ch;\n                _intLength = 1;\n                return _finishNumberIntegralPart(outBuf, 1);\n            }\n            --_inputPtr;\n            return _valueCompleteInt(0, \"0\");\n        }\n    }\n\n    protected JsonToken _finishNumberLeadingNegZeroes() throws IOException {\n        \n        \n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_MINUSZERO;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '-';\n                    outBuf[1] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 2, ch);\n                }\n            } else if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '-';\n                    outBuf[1] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 2, ch);\n                }\n                \n                \n                \n                if ((ch != INT_RBRACKET) && (ch != INT_RCURLY)) {\n                    reportUnexpectedNumberChar(ch,\n                            \"expected digit (0-9), decimal point (.) or exponent indicator (e/E) to follow '0'\");\n                }\n            } else { \n                \n                \n                if ((_features & FEAT_MASK_LEADING_ZEROS) == 0) {\n                    reportInvalidNumber(\"Leading zeroes not allowed\");\n                }\n                if (ch == INT_0) { \n                    continue;\n                }\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                \n                outBuf[0] = '-';\n                outBuf[1] = (char) ch;\n                _intLength = 1;\n                return _finishNumberIntegralPart(outBuf, 2);\n            }\n            --_inputPtr;\n            return _valueCompleteInt(0, \"0\");\n        }\n    }\n\n    protected JsonToken _finishNumberIntegralPart(char[] outBuf, int outPtr) throws IOException {\n        int negMod = _numberNegative ? -1 : 0;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n                _textBuffer.setCurrentLength(outPtr);\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    _intLength = outPtr+negMod;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    _intLength = outPtr+negMod;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            ++_inputPtr;\n            if (outPtr >= outBuf.length) {\n                \n                \n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n        }\n        _intLength = outPtr+negMod;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }\n\n    protected JsonToken _startFloat(char[] outBuf, int outPtr, int ch) throws IOException {\n        int fractLen = 0;\n        if (ch == INT_PERIOD) {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = '.';\n            while (true) {\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_FRACTION_DIGITS;\n                    _fractLength = fractLen;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++]; \n                if (ch < INT_0 || ch > INT_9) {\n                    ch &= 0xFF; \n                    \n                    if (fractLen == 0) {\n                        reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                    }\n                    break;\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                ++fractLen;\n            }\n        }\n        _fractLength = fractLen;\n        int expLen = 0;\n        if (ch == INT_e || ch == INT_E) { \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (_inputPtr >= _inputEnd) {\n                _textBuffer.setCurrentLength(outPtr);\n                _minorState = MINOR_NUMBER_EXPONENT_MARKER;\n                _expLength = 0;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr++]; \n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n                    _expLength = 0;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++];\n            }\n            while (ch >= INT_0 && ch <= INT_9) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n                    _expLength = expLen;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++];\n            }\n            \n            ch &= 0xFF;\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        \n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        \n        _expLength = expLen;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }\n\n    protected JsonToken _finishFloatFraction() throws IOException {\n        int fractLen = _fractLength;\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        \n        int ch;\n        while (((ch = _inputBuffer[_inputPtr++]) >= INT_0) && (ch <= INT_9)) {\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (_inputPtr >= _inputEnd) {\n                _textBuffer.setCurrentLength(outPtr);\n                _fractLength = fractLen;\n                return JsonToken.NOT_AVAILABLE;\n            }\n        }\n        \n        \n        \n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n        }\n        _fractLength = fractLen;\n        _textBuffer.setCurrentLength(outPtr);\n\n        \n        if (ch == INT_e || ch == INT_E) { \n            _textBuffer.append((char) ch);\n            _expLength = 0;\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_EXPONENT_MARKER;\n                return JsonToken.NOT_AVAILABLE;\n            }\n            _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n            return _finishFloatExponent(true, _inputBuffer[_inputPtr++] & 0xFF);\n        }\n\n        \n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        \n        _expLength = 0;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }\n\n    protected JsonToken _finishFloatExponent(boolean checkSign, int ch) throws IOException {\n        if (checkSign) {\n            _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                _textBuffer.append((char) ch);\n                if (_inputPtr >= _inputEnd) {\n                    _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n                    _expLength = 0;\n                    return JsonToken.NOT_AVAILABLE;\n                }\n                ch = _inputBuffer[_inputPtr++];\n            }\n        }\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int expLen = _expLength;\n\n        while (ch >= INT_0 && ch <= INT_9) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (_inputPtr >= _inputEnd) {\n                _textBuffer.setCurrentLength(outPtr);\n                _expLength = expLen;\n                return JsonToken.NOT_AVAILABLE;\n            }\n            ch = _inputBuffer[_inputPtr++];\n        }\n        \n        ch &= 0xFF;\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n        }\n        \n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        \n        _expLength = expLen;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }\n\n    \n\n    private final String _fastParseName() throws IOException {\n        \n        \n        \n        \n\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n        int ptr = _inputPtr;\n\n        int q0 = input[ptr++] & 0xFF;\n        if (codes[q0] == 0) {\n            int i = input[ptr++] & 0xFF;\n            if (codes[i] == 0) {\n                int q = (q0 << 8) | i;\n                i = input[ptr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[ptr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[ptr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return _parseMediumName(ptr, i);\n                        }\n                        if (i == INT_QUOTE) { \n                            _inputPtr = ptr;\n                            return _findName(q, 4);\n                        }\n                        return null;\n                    }\n                    if (i == INT_QUOTE) { \n                        _inputPtr = ptr;\n                        return _findName(q, 3);\n                    }\n                    return null;\n                }\n                if (i == INT_QUOTE) { \n                    _inputPtr = ptr;\n                    return _findName(q, 2);\n                }\n                return null;\n            }\n            if (i == INT_QUOTE) { \n                _inputPtr = ptr;\n                return _findName(q0, 1);\n            }\n            return null;\n        }\n        if (q0 == INT_QUOTE) {\n            _inputPtr = ptr;\n            return \"\";\n        }\n        return null;\n    }\n\n    private final String _parseMediumName(int ptr, int q2) throws IOException {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        \n        int i = input[ptr++] & 0xFF;\n        if (codes[i] == 0) {\n            q2 = (q2 << 8) | i;\n            i = input[ptr++] & 0xFF;\n            if (codes[i] == 0) {\n                q2 = (q2 << 8) | i;\n                i = input[ptr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q2 = (q2 << 8) | i;\n                    i = input[ptr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        return _parseMediumName2(ptr, i, q2);\n                    }\n                    if (i == INT_QUOTE) { \n                        _inputPtr = ptr;\n                        return _findName(_quad1, q2, 4);\n                    }\n                    return null;\n                }\n                if (i == INT_QUOTE) { \n                    _inputPtr = ptr;\n                    return _findName(_quad1, q2, 3);\n                }\n                return null;\n            }\n            if (i == INT_QUOTE) { \n                _inputPtr = ptr;\n                return _findName(_quad1, q2, 2);\n            }\n            return null;\n        }\n        if (i == INT_QUOTE) { \n            _inputPtr = ptr;\n            return _findName(_quad1, q2, 1);\n        }\n        return null;\n    }\n\n    private final String _parseMediumName2(int ptr, int q3, final int q2) throws IOException {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        \n        int i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                _inputPtr = ptr;\n                return _findName(_quad1, q2, q3, 1);\n            }\n            return null;\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                _inputPtr = ptr;\n                return _findName(_quad1, q2, q3, 2);\n            }\n            return null;\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                _inputPtr = ptr;\n                return _findName(_quad1, q2, q3, 3);\n            }\n            return null;\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (i == INT_QUOTE) { \n            _inputPtr = ptr;\n            return _findName(_quad1, q2, q3, 4);\n        }\n        \n        return null;\n    }\n\n    \n    private final JsonToken _parseEscapedName(int qlen, int currQuad, int currQuadBytes) throws IOException {\n        \n        \n        \n        int[] quads = _quadBuffer;\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _quadLength = qlen;\n                _pending32 = currQuad;\n                _pendingBytes = currQuadBytes;\n                _minorState = MINOR_FIELD_NAME;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[ch] == 0) {\n                if (currQuadBytes < 4) {\n                    ++currQuadBytes;\n                    currQuad = (currQuad << 8) | ch;\n                    continue;\n                }\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n                continue;\n            }\n\n            \n            if (ch == INT_QUOTE) { \n                break;\n            }\n            \n            if (ch != INT_BACKSLASH) {\n                \n                _throwUnquotedSpace(ch, \"name\");\n            } else {\n                \n                ch = _decodeCharEscape();\n                if (ch < 0) { \n                    _minorState = MINOR_FIELD_NAME_ESCAPE;\n                    _minorStateAfterSplit = MINOR_FIELD_NAME;\n                    _quadLength = qlen;\n                    _pending32 = currQuad;\n                    _pendingBytes = currQuadBytes;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n            }\n\n            \n            \n            \n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            if (ch > 127) {\n                \n                if (currQuadBytes >= 4) {\n                    quads[qlen++] = currQuad;\n                    currQuad = 0;\n                    currQuadBytes = 0;\n                }\n                if (ch < 0x800) { \n                    currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                    ++currQuadBytes;\n                    \n                } else { \n                    currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                    ++currQuadBytes;\n                    \n                    if (currQuadBytes >= 4) {\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                    ++currQuadBytes;\n                }\n                \n                ch = 0x80 | (ch & 0x3f);\n            }\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n                continue;\n            }\n            quads[qlen++] = currQuad;\n            currQuad = ch;\n            currQuadBytes = 1;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = _padLastQuad(currQuad, currQuadBytes);\n        } else if (qlen == 0) { \n            return _fieldComplete(\"\");\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = _addName(quads, qlen, currQuadBytes);\n        }\n        return _fieldComplete(name);\n    }\n\n    \n    private JsonToken _handleOddName(int ch) throws IOException {\n        \n        switch (ch) {\n        case '#':\n            \n            \n            if ((_features & FEAT_MASK_ALLOW_YAML_COMMENTS) != 0) {\n                return _finishHashComment(MINOR_FIELD_LEADING_WS);\n            }\n            break;\n        case '/':\n            return _startSlashComment(MINOR_FIELD_LEADING_WS);\n        case '\\'':\n            if ((_features & FEAT_MASK_ALLOW_SINGLE_QUOTES) != 0) {\n                return _finishAposName(0, 0, 0);\n            }\n            break;\n        case ']': \n            return _closeArrayScope();\n        }\n        \n        if ((_features & FEAT_MASK_ALLOW_UNQUOTED_NAMES) == 0) {\n         \n\n            char c = (char) ch;\n            _reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n        }\n        \n        \n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n        \n        if (codes[ch] != 0) {\n            _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n\n        return _finishUnquotedName(0, ch, 1);\n    }\n\n    \n    private JsonToken _finishUnquotedName(int qlen, int currQuad, int currQuadBytes) throws IOException {\n        int[] quads = _quadBuffer;\n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n\n        \n        \n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _quadLength = qlen;\n                _pending32 = currQuad;\n                _pendingBytes = currQuadBytes;\n                _minorState = MINOR_FIELD_UNQUOTED_NAME;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (codes[ch] != 0) {\n                break;\n            }\n            ++_inputPtr;\n            \n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = _addName(quads, qlen, currQuadBytes);\n        }\n        return _fieldComplete(name);\n    }\n\n    private JsonToken _finishAposName(int qlen, int currQuad, int currQuadBytes) throws IOException {\n        int[] quads = _quadBuffer;\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _quadLength = qlen;\n                _pending32 = currQuad;\n                _pendingBytes = currQuadBytes;\n                _minorState = MINOR_FIELD_APOS_NAME;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch == INT_APOS) {\n                break;\n            }\n            \n            if (ch != '\"' && codes[ch] != 0) {\n                if (ch != '\\\\') {\n                    \n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    \n                    ch = _decodeCharEscape();\n                    if (ch < 0) { \n                        _minorState = MINOR_FIELD_NAME_ESCAPE;\n                        _minorStateAfterSplit = MINOR_FIELD_APOS_NAME;\n                        _quadLength = qlen;\n                        _pending32 = currQuad;\n                        _pendingBytes = currQuadBytes;\n                        return (_currToken = JsonToken.NOT_AVAILABLE);\n                    }\n                }\n                if (ch > 127) {\n                    \n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { \n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        \n                    } else { \n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        \n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    \n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            \n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = _padLastQuad(currQuad, currQuadBytes);\n        } else if (qlen == 0) { \n            return _fieldComplete(\"\");\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = _addName(quads, qlen, currQuadBytes);\n        }\n        return _fieldComplete(name);\n    }\n\n    protected final JsonToken _finishFieldWithEscape() throws IOException {\n        \n        int ch = _decodeSplitEscaped(_quoted32, _quotedDigits);\n        if (ch < 0) { \n            _minorState = MINOR_FIELD_NAME_ESCAPE;\n            return JsonToken.NOT_AVAILABLE;\n        }\n        if (_quadLength >= _quadBuffer.length) {\n            _quadBuffer = growArrayBy(_quadBuffer, 32);\n        }\n        int currQuad = _pending32;\n        int currQuadBytes = _pendingBytes;\n        if (ch > 127) {\n            \n            if (currQuadBytes >= 4) {\n                _quadBuffer[_quadLength++] = currQuad;\n                currQuad = 0;\n                currQuadBytes = 0;\n            }\n            if (ch < 0x800) { \n                currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                ++currQuadBytes;\n                \n            } else { \n                currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                \n                if (++currQuadBytes >= 4) {\n                    _quadBuffer[_quadLength++] = currQuad;\n                    currQuad = 0;\n                    currQuadBytes = 0;\n                }\n                currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                ++currQuadBytes;\n            }\n            \n            ch = 0x80 | (ch & 0x3f);\n        }\n        if (currQuadBytes < 4) {\n            ++currQuadBytes;\n            currQuad = (currQuad << 8) | ch;\n        } else {\n            _quadBuffer[_quadLength++] = currQuad;\n            currQuad = ch;\n            currQuadBytes = 1;\n        }\n        if (_minorStateAfterSplit == MINOR_FIELD_APOS_NAME) {\n            return _finishAposName(_quadLength, currQuad, currQuadBytes);\n        }\n        return _parseEscapedName(_quadLength, currQuad, currQuadBytes);\n    }\n\n    private int _decodeSplitEscaped(int value, int bytesRead) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            _quoted32 = value;\n            _quotedDigits = bytesRead;\n            return -1;\n        }\n        int c = _inputBuffer[_inputPtr++];\n        if (bytesRead == -1) { \n            switch (c) {\n                \n            case 'b':\n                return '\\b';\n            case 't':\n                return '\\t';\n            case 'n':\n                return '\\n';\n            case 'f':\n                return '\\f';\n            case 'r':\n                return '\\r';\n    \n                \n            case '\"':\n            case '/':\n            case '\\\\':\n                return c;\n    \n            case 'u': \n                break;\n    \n            default:\n                {\n                 \n    \n                    char ch = (char) c;\n                    return _handleUnrecognizedCharacterEscape(ch);\n                }\n            }\n            if (_inputPtr >= _inputEnd) {\n                _quotedDigits = 0;\n                _quoted32 = 0;\n                return -1;\n            }\n            c = _inputBuffer[_inputPtr++];\n            bytesRead = 0;\n        }\n        c &= 0xFF;\n        while (true) {\n            int digit = CharTypes.charToHex(c);\n            if (digit < 0) {\n                _reportUnexpectedChar(c, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n            if (++bytesRead == 4) {\n                return value;\n            }\n            if (_inputPtr >= _inputEnd) {\n                _quotedDigits = bytesRead;\n                _quoted32 = value;\n                return -1;\n            }\n            c = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n    }\n\n    \n\n    protected JsonToken _startString() throws IOException {\n        int ptr = _inputPtr;\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return _valueComplete(JsonToken.VALUE_STRING);\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        _inputPtr = ptr;\n        return _finishRegularString();\n    }\n\n    private final JsonToken _finishRegularString() throws IOException {\n        int c;\n\n        \n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int ptr = _inputPtr;\n        final int safeEnd = _inputEnd - 5; \n        \n        main_loop:\n        while (true) {\n            \n            ascii_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    _inputPtr = ptr;\n                    _minorState = MINOR_VALUE_STRING;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n            \n            if (c == INT_QUOTE) {\n                _inputPtr = ptr;\n                _textBuffer.setCurrentLength(outPtr);\n                return _valueComplete(JsonToken.VALUE_STRING);\n            }\n            \n            if (ptr >= safeEnd) {\n                _inputPtr = ptr;\n                _textBuffer.setCurrentLength(outPtr);\n                if (!_decodeSplitMultiByte(c, codes[c], ptr < _inputEnd)) {\n                    _minorStateAfterSplit = MINOR_VALUE_STRING;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                outBuf = _textBuffer.getBufferWithoutReset();\n                outPtr = _textBuffer.getCurrentSegmentSize();\n                ptr = _inputPtr;\n                continue main_loop;\n            }\n            \n            switch (codes[c]) {\n            case 1: \n                _inputPtr = ptr;\n                c = _decodeFastCharEscape(); \n                ptr = _inputPtr;\n                break;\n            case 2: \n                c = _decodeUTF8_2(c, _inputBuffer[ptr++]);\n                break;\n            case 3: \n                c = _decodeUTF8_3(c, _inputBuffer[ptr++], _inputBuffer[ptr++]);\n                break;\n            case 4: \n                c = _decodeUTF8_4(c, _inputBuffer[ptr++], _inputBuffer[ptr++],\n                        _inputBuffer[ptr++]);\n                \n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                \n                break;\n            default:\n                if (c < INT_SPACE) {\n                    \n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    \n                    _reportInvalidChar(c);\n                }\n            }\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            \n            outBuf[outPtr++] = (char) c;\n        }\n    }\n\n    protected JsonToken _startAposString() throws IOException {\n        int ptr = _inputPtr;\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (c == INT_APOS) {\n                _inputPtr = ptr+1;\n                _textBuffer.setCurrentLength(outPtr);\n                return _valueComplete(JsonToken.VALUE_STRING);\n            }\n\n            if (codes[c] != 0) {\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        _inputPtr = ptr;\n        return _finishAposString();\n    }\n\n    private final JsonToken _finishAposString() throws IOException {\n        int c;\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int ptr = _inputPtr;\n        final int safeEnd = _inputEnd - 5; \n        \n        main_loop:\n        while (true) {\n            ascii_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    _inputPtr = ptr;\n                    _minorState = MINOR_VALUE_APOS_STRING;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = inputBuffer[ptr++] & 0xFF;\n                    if ((codes[c] != 0) && (c != INT_QUOTE)) {\n                        break ascii_loop;\n                    }\n                    if (c == INT_APOS) {\n                        _inputPtr = ptr;\n                        _textBuffer.setCurrentLength(outPtr);\n                        return _valueComplete(JsonToken.VALUE_STRING);\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n            \n            \n            if (ptr >= safeEnd) {\n                _inputPtr = ptr;\n                _textBuffer.setCurrentLength(outPtr);\n                if (!_decodeSplitMultiByte(c, codes[c], ptr < _inputEnd)) {\n                    _minorStateAfterSplit = MINOR_VALUE_APOS_STRING;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                outBuf = _textBuffer.getBufferWithoutReset();\n                outPtr = _textBuffer.getCurrentSegmentSize();\n                ptr = _inputPtr;\n                continue main_loop;\n            }\n            \n            switch (codes[c]) {\n            case 1: \n                _inputPtr = ptr;\n                c = _decodeFastCharEscape(); \n                ptr = _inputPtr;\n                break;\n            case 2: \n                c = _decodeUTF8_2(c, _inputBuffer[ptr++]);\n                break;\n            case 3: \n                c = _decodeUTF8_3(c, _inputBuffer[ptr++], _inputBuffer[ptr++]);\n                break;\n            case 4: \n                c = _decodeUTF8_4(c, _inputBuffer[ptr++], _inputBuffer[ptr++],\n                        _inputBuffer[ptr++]);\n                \n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                \n                break;\n            default:\n                if (c < INT_SPACE) {\n                    \n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    \n                    _reportInvalidChar(c);\n                }\n            }\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            \n            outBuf[outPtr++] = (char) c;\n        }\n    }\n    \n    private final boolean _decodeSplitMultiByte(int c, int type, boolean gotNext) throws IOException {\n        switch (type) {\n        case 1:\n            c = _decodeSplitEscaped(0, -1);\n            if (c < 0) {\n                _minorState = MINOR_VALUE_STRING_ESCAPE;\n                return false;\n            }\n            _textBuffer.append((char) c);\n            return true;\n        case 2: \n            if (gotNext) {\n                \n                c = _decodeUTF8_2(c, _inputBuffer[_inputPtr++]);\n                _textBuffer.append((char) c);\n                return true;\n            }\n            _minorState = MINOR_VALUE_STRING_UTF8_2;\n            _pending32 = c;\n            return false;\n        case 3: \n            c &= 0x0F;\n            if (gotNext) {\n                return _decodeSplitUTF8_3(c, 1, _inputBuffer[_inputPtr++]);\n            }\n            _minorState = MINOR_VALUE_STRING_UTF8_3;\n            _pending32 = c;\n            _pendingBytes = 1;\n            return false;\n        case 4: \n            c &= 0x07;\n            if (gotNext) {\n                return _decodeSplitUTF8_4(c, 1, _inputBuffer[_inputPtr++]);\n            }\n            _pending32 = c;\n            _pendingBytes = 1;\n            _minorState = MINOR_VALUE_STRING_UTF8_4;\n            return false;\n        default:\n            if (c < INT_SPACE) {\n                \n                _throwUnquotedSpace(c, \"string value\");\n            } else {\n                \n                _reportInvalidChar(c);\n            }\n            _textBuffer.append((char) c);\n            return true;\n        }\n    }\n\n    private final boolean _decodeSplitUTF8_3(int prev, int prevCount, int next) throws IOException {\n        if (prevCount == 1) {\n            if ((next & 0xC0) != 0x080) {\n                _reportInvalidOther(next & 0xFF, _inputPtr);\n            }\n            prev = (prev << 6) | (next & 0x3F);\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_VALUE_STRING_UTF8_3;\n                _pending32 = prev;\n                _pendingBytes = 2;\n                return false;\n            }\n            next = _inputBuffer[_inputPtr++];\n        }\n        if ((next & 0xC0) != 0x080) {\n            _reportInvalidOther(next & 0xFF, _inputPtr);\n        }\n        _textBuffer.append((char) ((prev << 6) | (next & 0x3F)));\n        return true;\n    }\n\n    \n    \n    private final boolean _decodeSplitUTF8_4(int prev, int prevCount, int next) throws IOException {\n        if (prevCount == 1) {\n            if ((next & 0xC0) != 0x080) {\n                _reportInvalidOther(next & 0xFF, _inputPtr);\n            }\n            prev = (prev << 6) | (next & 0x3F);\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_VALUE_STRING_UTF8_4;\n                _pending32 = prev;\n                _pendingBytes = 2;\n                return false;\n            }\n            prevCount = 2;\n            next = _inputBuffer[_inputPtr++];\n        }\n        if (prevCount == 2) {\n            if ((next & 0xC0) != 0x080) {\n                _reportInvalidOther(next & 0xFF, _inputPtr);\n            }\n            prev = (prev << 6) | (next & 0x3F);\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_VALUE_STRING_UTF8_4;\n                _pending32 = prev;\n                _pendingBytes = 3;\n                return false;\n            }\n            next = _inputBuffer[_inputPtr++];\n        }\n        if ((next & 0xC0) != 0x080) {\n            _reportInvalidOther(next & 0xFF, _inputPtr);\n        }\n        int c = ((prev << 6) | (next & 0x3F)) - 0x10000;\n        \n        _textBuffer.append((char) (0xD800 | (c >> 10)));\n        c = 0xDC00 | (c & 0x3FF);\n        \n        _textBuffer.append((char) c);\n        return true;\n    }\n\n    \n\n    private final int _decodeCharEscape() throws IOException {\n        int left = _inputEnd - _inputPtr;\n        if (left < 5) { \n            return _decodeSplitEscaped(0, -1);\n        }\n        return _decodeFastCharEscape();\n    }\n\n    private final int _decodeFastCharEscape() throws IOException {\n        int c = (int) _inputBuffer[_inputPtr++];\n        switch (c) {\n            \n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            \n        case '\"':\n        case '/':\n        case '\\\\':\n            return (char) c;\n\n        case 'u': \n            break;\n\n        default:\n            {\n             \n\n                char ch = (char) c;\n                return _handleUnrecognizedCharacterEscape(ch);\n            }\n        }\n\n        int ch = (int) _inputBuffer[_inputPtr++];\n        int digit = CharTypes.charToHex(ch);\n        int result = digit;\n\n        if (digit >= 0) {\n            ch = (int) _inputBuffer[_inputPtr++];\n            digit = CharTypes.charToHex(ch);\n            if (digit >= 0) {\n                result = (result << 4) | digit;\n                ch = (int) _inputBuffer[_inputPtr++];\n                digit = CharTypes.charToHex(ch);\n                if (digit >= 0) {\n                    result = (result << 4) | digit;\n                    ch = (int) _inputBuffer[_inputPtr++];\n                    digit = CharTypes.charToHex(ch);\n                    if (digit >= 0) {\n                        return (result << 4) | digit;\n                    }\n                }\n            }\n        }\n        _reportUnexpectedChar(ch & 0xFF, \"expected a hex-digit for character escape sequence\");\n        return -1;\n    }\n\n    \n\n    private final int _decodeUTF8_2(int c, int d) throws IOException {\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        return ((c & 0x1F) << 6) | (d & 0x3F);\n    }\n\n    private final int _decodeUTF8_3(int c, int d, int e) throws IOException {\n        c &= 0x0F;\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        if ((e & 0xC0) != 0x080) {\n            _reportInvalidOther(e & 0xFF, _inputPtr);\n        }\n        return (c << 6) | (e & 0x3F);\n    }\n\n    \n    \n    private final int _decodeUTF8_4(int c, int d, int e, int f) throws IOException {\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = ((c & 0x07) << 6) | (d & 0x3F);\n        if ((e & 0xC0) != 0x080) {\n            _reportInvalidOther(e & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (e & 0x3F);\n        if ((f & 0xC0) != 0x080) {\n            _reportInvalidOther(f & 0xFF, _inputPtr);\n        }\n        return ((c << 6) | (f & 0x3F)) - 0x10000;\n    }\n\n    \n}\n",
      "buggy_signatures": [
        "public class NonBlockingJsonParser extends NonBlockingJsonParserBase implements ByteArrayFeeder { @SuppressWarnings(\"deprecation\") private final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask(); @SuppressWarnings(\"deprecation\") private final static int FEAT_MASK_LEADING_ZEROS = Feature.ALLOW_NUMERIC_LEADING_ZEROS.getMask(); @SuppressWarnings(\"deprecation\") private final static int FEAT_MASK_ALLOW_MISSING = Feature.ALLOW_MISSING_VALUES.getMask(); private final static int FEAT_MASK_ALLOW_SINGLE_QUOTES = Feature.ALLOW_SINGLE_QUOTES.getMask(); private final static int FEAT_MASK_ALLOW_UNQUOTED_NAMES = Feature.ALLOW_UNQUOTED_FIELD_NAMES.getMask(); private final static int FEAT_MASK_ALLOW_JAVA_COMMENTS = Feature.ALLOW_COMMENTS.getMask(); private final static int FEAT_MASK_ALLOW_YAML_COMMENTS = Feature.ALLOW_YAML_COMMENTS.getMask(); private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8(); protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); protected byte[] _inputBuffer = NO_BYTES; protected int _origBufferLen; public NonBlockingJsonParser(IOContext ctxt, int parserFeatures, ByteQuadsCanonicalizer sym)",
        "public ByteArrayFeeder getNonBlockingInputFeeder()",
        "public final boolean needMoreInput()",
        "public void feedInput(byte[] buf, int start, int end) throws IOException",
        "public void endOfInput()",
        "public int releaseBuffered(OutputStream out) throws IOException",
        "protected char _decodeEscaped() throws IOException",
        "public JsonToken nextToken() throws IOException",
        "protected final JsonToken _finishToken() throws IOException",
        "protected final JsonToken _finishTokenWithEOF() throws IOException",
        "private final JsonToken _startDocument(int ch) throws IOException",
        "private final JsonToken _finishBOM(int bytesHandled) throws IOException",
        "private final JsonToken _startFieldName(int ch) throws IOException",
        "private final JsonToken _startFieldNameAfterComma(int ch) throws IOException",
        "private final JsonToken _startValue(int ch) throws IOException",
        "private final JsonToken _startValueExpectComma(int ch) throws IOException",
        "private final JsonToken _startValueExpectColon(int ch) throws IOException",
        "private final JsonToken _startValueAfterComma(int ch) throws IOException",
        "protected JsonToken _startUnexpectedValue(boolean leadingComma, int ch) throws IOException",
        "private final int _skipWS(int ch) throws IOException",
        "private final JsonToken _startSlashComment(int fromMinorState) throws IOException",
        "private final JsonToken _finishHashComment(int fromMinorState) throws IOException",
        "private final JsonToken _finishCppComment(int fromMinorState) throws IOException",
        "private final JsonToken _finishCComment(int fromMinorState, boolean gotStar) throws IOException",
        "private final JsonToken _startAfterComment(int fromMinorState) throws IOException",
        "protected JsonToken _startFalseToken() throws IOException",
        "protected JsonToken _startTrueToken() throws IOException",
        "protected JsonToken _startNullToken() throws IOException",
        "protected JsonToken _finishKeywordToken(String expToken, int matched, JsonToken result) throws IOException",
        "protected JsonToken _finishKeywordTokenWithEOF(String expToken, int matched, JsonToken result) throws IOException",
        "protected JsonToken _finishNonStdToken(int type, int matched) throws IOException",
        "protected JsonToken _finishNonStdTokenWithEOF(int type, int matched) throws IOException",
        "protected JsonToken _finishErrorToken() throws IOException",
        "protected JsonToken _finishErrorTokenWithEOF() throws IOException",
        "protected JsonToken _reportErrorToken(String actualToken) throws IOException",
        "protected JsonToken _startPositiveNumber(int ch) throws IOException",
        "protected JsonToken _startNegativeNumber() throws IOException",
        "protected JsonToken _startNumberLeadingZero() throws IOException",
        "protected JsonToken _finishNumberMinus(int ch) throws IOException",
        "protected JsonToken _finishNumberLeadingZeroes() throws IOException",
        "protected JsonToken _finishNumberLeadingNegZeroes() throws IOException",
        "protected JsonToken _finishNumberIntegralPart(char[] outBuf, int outPtr) throws IOException",
        "protected JsonToken _startFloat(char[] outBuf, int outPtr, int ch) throws IOException",
        "protected JsonToken _finishFloatFraction() throws IOException",
        "protected JsonToken _finishFloatExponent(boolean checkSign, int ch) throws IOException",
        "private final String _fastParseName() throws IOException",
        "private final String _parseMediumName(int ptr, int q2) throws IOException",
        "private final String _parseMediumName2(int ptr, int q3, final int q2) throws IOException",
        "private final JsonToken _parseEscapedName(int qlen, int currQuad, int currQuadBytes) throws IOException",
        "private JsonToken _handleOddName(int ch) throws IOException",
        "private JsonToken _finishUnquotedName(int qlen, int currQuad, int currQuadBytes) throws IOException",
        "private JsonToken _finishAposName(int qlen, int currQuad, int currQuadBytes) throws IOException",
        "protected final JsonToken _finishFieldWithEscape() throws IOException",
        "private int _decodeSplitEscaped(int value, int bytesRead) throws IOException",
        "protected JsonToken _startString() throws IOException",
        "private final JsonToken _finishRegularString() throws IOException",
        "protected JsonToken _startAposString() throws IOException",
        "private final JsonToken _finishAposString() throws IOException",
        "private final boolean _decodeSplitMultiByte(int c, int type, boolean gotNext) throws IOException",
        "private final boolean _decodeSplitUTF8_3(int prev, int prevCount, int next) throws IOException",
        "private final boolean _decodeSplitUTF8_4(int prev, int prevCount, int next) throws IOException",
        "private final int _decodeCharEscape() throws IOException",
        "private final int _decodeFastCharEscape() throws IOException",
        "private final int _decodeUTF8_2(int c, int d) throws IOException",
        "private final int _decodeUTF8_3(int c, int d, int e) throws IOException",
        "private final int _decodeUTF8_4(int c, int d, int e, int f) throws IOException"
      ],
      "fixed_signatures": [
        "public class NonBlockingJsonParser extends NonBlockingJsonParserBase implements ByteArrayFeeder { @SuppressWarnings(\"deprecation\") private final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask(); @SuppressWarnings(\"deprecation\") private final static int FEAT_MASK_LEADING_ZEROS = Feature.ALLOW_NUMERIC_LEADING_ZEROS.getMask(); @SuppressWarnings(\"deprecation\") private final static int FEAT_MASK_ALLOW_MISSING = Feature.ALLOW_MISSING_VALUES.getMask(); private final static int FEAT_MASK_ALLOW_SINGLE_QUOTES = Feature.ALLOW_SINGLE_QUOTES.getMask(); private final static int FEAT_MASK_ALLOW_UNQUOTED_NAMES = Feature.ALLOW_UNQUOTED_FIELD_NAMES.getMask(); private final static int FEAT_MASK_ALLOW_JAVA_COMMENTS = Feature.ALLOW_COMMENTS.getMask(); private final static int FEAT_MASK_ALLOW_YAML_COMMENTS = Feature.ALLOW_YAML_COMMENTS.getMask(); private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8(); protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); protected byte[] _inputBuffer = NO_BYTES; protected int _origBufferLen; public NonBlockingJsonParser(IOContext ctxt, int parserFeatures, ByteQuadsCanonicalizer sym)",
        "public ByteArrayFeeder getNonBlockingInputFeeder()",
        "public final boolean needMoreInput()",
        "public void feedInput(byte[] buf, int start, int end) throws IOException",
        "public void endOfInput()",
        "public int releaseBuffered(OutputStream out) throws IOException",
        "protected char _decodeEscaped() throws IOException",
        "public JsonToken nextToken() throws IOException",
        "protected final JsonToken _finishToken() throws IOException",
        "protected final JsonToken _finishTokenWithEOF() throws IOException",
        "private final JsonToken _startDocument(int ch) throws IOException",
        "private final JsonToken _finishBOM(int bytesHandled) throws IOException",
        "private final JsonToken _startFieldName(int ch) throws IOException",
        "private final JsonToken _startFieldNameAfterComma(int ch) throws IOException",
        "private final JsonToken _startValue(int ch) throws IOException",
        "private final JsonToken _startValueExpectComma(int ch) throws IOException",
        "private final JsonToken _startValueExpectColon(int ch) throws IOException",
        "private final JsonToken _startValueAfterComma(int ch) throws IOException",
        "protected JsonToken _startUnexpectedValue(boolean leadingComma, int ch) throws IOException",
        "private final int _skipWS(int ch) throws IOException",
        "private final JsonToken _startSlashComment(int fromMinorState) throws IOException",
        "private final JsonToken _finishHashComment(int fromMinorState) throws IOException",
        "private final JsonToken _finishCppComment(int fromMinorState) throws IOException",
        "private final JsonToken _finishCComment(int fromMinorState, boolean gotStar) throws IOException",
        "private final JsonToken _startAfterComment(int fromMinorState) throws IOException",
        "protected JsonToken _startFalseToken() throws IOException",
        "protected JsonToken _startTrueToken() throws IOException",
        "protected JsonToken _startNullToken() throws IOException",
        "protected JsonToken _finishKeywordToken(String expToken, int matched, JsonToken result) throws IOException",
        "protected JsonToken _finishKeywordTokenWithEOF(String expToken, int matched, JsonToken result) throws IOException",
        "protected JsonToken _finishNonStdToken(int type, int matched) throws IOException",
        "protected JsonToken _finishNonStdTokenWithEOF(int type, int matched) throws IOException",
        "protected JsonToken _finishErrorToken() throws IOException",
        "protected JsonToken _finishErrorTokenWithEOF() throws IOException",
        "protected JsonToken _reportErrorToken(String actualToken) throws IOException",
        "protected JsonToken _startPositiveNumber(int ch) throws IOException",
        "protected JsonToken _startNegativeNumber() throws IOException",
        "protected JsonToken _startNumberLeadingZero() throws IOException",
        "protected JsonToken _finishNumberMinus(int ch) throws IOException",
        "protected JsonToken _finishNumberLeadingZeroes() throws IOException",
        "protected JsonToken _finishNumberLeadingNegZeroes() throws IOException",
        "protected JsonToken _finishNumberIntegralPart(char[] outBuf, int outPtr) throws IOException",
        "protected JsonToken _startFloat(char[] outBuf, int outPtr, int ch) throws IOException",
        "protected JsonToken _finishFloatFraction() throws IOException",
        "protected JsonToken _finishFloatExponent(boolean checkSign, int ch) throws IOException",
        "private final String _fastParseName() throws IOException",
        "private final String _parseMediumName(int ptr, int q2) throws IOException",
        "private final String _parseMediumName2(int ptr, int q3, final int q2) throws IOException",
        "private final JsonToken _parseEscapedName(int qlen, int currQuad, int currQuadBytes) throws IOException",
        "private JsonToken _handleOddName(int ch) throws IOException",
        "private JsonToken _finishUnquotedName(int qlen, int currQuad, int currQuadBytes) throws IOException",
        "private JsonToken _finishAposName(int qlen, int currQuad, int currQuadBytes) throws IOException",
        "protected final JsonToken _finishFieldWithEscape() throws IOException",
        "private int _decodeSplitEscaped(int value, int bytesRead) throws IOException",
        "protected JsonToken _startString() throws IOException",
        "private final JsonToken _finishRegularString() throws IOException",
        "protected JsonToken _startAposString() throws IOException",
        "private final JsonToken _finishAposString() throws IOException",
        "private final boolean _decodeSplitMultiByte(int c, int type, boolean gotNext) throws IOException",
        "private final boolean _decodeSplitUTF8_3(int prev, int prevCount, int next) throws IOException",
        "private final boolean _decodeSplitUTF8_4(int prev, int prevCount, int next) throws IOException",
        "private final int _decodeCharEscape() throws IOException",
        "private final int _decodeFastCharEscape() throws IOException",
        "private final int _decodeUTF8_2(int c, int d) throws IOException",
        "private final int _decodeUTF8_3(int c, int d, int e) throws IOException",
        "private final int _decodeUTF8_4(int c, int d, int e, int f) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  public void feedInput(byte[] buf, int start, int end) throws IOException {\n  \n  if (_inputPtr < _inputEnd) {\n  _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n  }\n  if (end < start) {\n  _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n  }\n  \n  if (_endOfInput) {\n  _reportError(\"Already closed, can not feed more input\");\n  }\n  \n  _currInputProcessed += _origBufferLen;\n\n  \n  _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n\n  \n  _inputBuffer = buf;\n  _inputPtr = start;\n  _inputEnd = end;\n  _origBufferLen = end - start;\n  }",
          "fixed_method": "  public void feedInput(byte[] buf, int start, int end) throws IOException {\n  \n  if (_inputPtr < _inputEnd) {\n  _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n  }\n  if (end < start) {\n  _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n  }\n  \n  if (_endOfInput) {\n  _reportError(\"Already closed, can not feed more input\");\n  }\n  \n  _currInputProcessed += _origBufferLen;\n\n  \n  _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n\n  \n  _currBufferStart = start;\n  _inputBuffer = buf;\n  _inputPtr = start;\n  _inputEnd = end;\n  _origBufferLen = end - start;\n  }",
          "diff": [
            "@@ -105,6 +105,7 @@",
            "         _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n",
            " \n",
            "         // And then update buffer settings\n",
            "+        _currBufferStart = start;\n",
            "         _inputBuffer = buf;\n",
            "         _inputPtr = start;\n",
            "         _inputEnd = end;\n"
          ],
          "changed_lines": 1
        }
      ]
    }
  ]
}
