{
  "bug_id": "28",
  "failed_tests": {
    "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest": [
      {
        "methodName": "shouldThrowAnExceptionOnTruncatedEntries",
        "error": "junit.framework.AssertionFailedError",
        "message": "Expected exception: java.io.IOException",
        "fail_line": "",
        "test_source": "  public void shouldThrowAnExceptionOnTruncatedEntries() throws Exception {\n  File dir = mkdir(\"COMPRESS-279\");\n  TarArchiveInputStream is = getTestStream(\"/COMPRESS-279.tar\");\n  FileOutputStream out = null;\n  try {\n  TarArchiveEntry entry = is.getNextTarEntry();\n  int count = 0;\n  while (entry != null) {\n  out = new FileOutputStream(new File(dir, String.valueOf(count)));\n  IOUtils.copy(is, out);\n  out.close();\n  out = null;\n  count++;\n  entry = is.getNextTarEntry();\n  }\n  } finally {\n  is.close();\n  if (out != null) {\n  out.close();\n  }\n  }\n  }",
        "stack": [
          ""
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java",
      "buggy_full_code": "\n\n\n\npackage org.apache.commons.compress.archivers.tar;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.archivers.zip.ZipEncoding;\nimport org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\nimport org.apache.commons.compress.utils.ArchiveUtils;\nimport org.apache.commons.compress.utils.CharsetNames;\nimport org.apache.commons.compress.utils.IOUtils;\n\n\npublic class TarArchiveInputStream extends ArchiveInputStream { private static final int SMALL_BUFFER_SIZE = 256; private final byte[] SMALL_BUF = new byte[SMALL_BUFFER_SIZE]; private final int recordSize; private final int blockSize; private boolean hasHitEOF; private long entrySize; private long entryOffset; private final InputStream is; private TarArchiveEntry currEntry; private final ZipEncoding encoding; public TarArchiveInputStream(InputStream is) {\n        this(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveInputStream(InputStream is, String encoding) {\n        this(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE,\n             encoding);\n    }\n\n    \n    public TarArchiveInputStream(InputStream is, int blockSize) {\n        this(is, blockSize, TarConstants.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveInputStream(InputStream is, int blockSize, String encoding) {\n        this(is, blockSize, TarConstants.DEFAULT_RCDSIZE, encoding);\n    }\n\n    \n    public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\n        this(is, blockSize, recordSize, null);      \n    }\n\n    \n    public TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n        this.is = is;\n        this.hasHitEOF = false;\n        this.encoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.recordSize = recordSize;\n        this.blockSize = blockSize;\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        is.close();\n    }\n\n    \n    public int getRecordSize() {\n        return recordSize;\n    }\n\n    \n    @Override\n    public int available() throws IOException {\n        if (entrySize - entryOffset > Integer.MAX_VALUE) {\n            return Integer.MAX_VALUE;\n        }\n        return (int) (entrySize - entryOffset);\n    }\n\n    \n    @Override\n    public long skip(long numToSkip) throws IOException {\n\n        long available = entrySize - entryOffset;\n        numToSkip = Math.min(numToSkip, available);\n\n        long skipped = IOUtils.skip(is, numToSkip); \n        count(skipped);\n        entryOffset += skipped;\n        return skipped;\n    }\n\n    \n    @Override\n    public synchronized void reset() {\n    }\n\n    \n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            \n            skip(Long.MAX_VALUE);\n\n            \n            skipRecordPadding();\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (headerBuf == null) {\n            \n            currEntry = null;\n            return null;\n        }\n\n        try {\n            currEntry = new TarArchiveEntry(headerBuf, encoding);\n        } catch (IllegalArgumentException e) {\n            IOException ioe = new IOException(\"Error detected parsing the header\");\n            ioe.initCause(e);\n            throw ioe;\n        }\n\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongLinkEntry()) {\n            byte[] longLinkData = getLongNameData();\n            if (longLinkData == null) {\n                \n                \n                \n                return null;\n            }\n            currEntry.setLinkName(encoding.decode(longLinkData));\n        }\n\n        if (currEntry.isGNULongNameEntry()) {\n            byte[] longNameData = getLongNameData();\n            if (longNameData == null) {\n                \n                \n                \n                return null;\n            }\n            currEntry.setName(encoding.decode(longNameData));\n        }\n\n        if (currEntry.isPaxHeader()){ \n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()){ \n            readGNUSparse();\n        }\n\n        \n        \n        \n        \n        entrySize = currEntry.getSize();\n\n        return currEntry;\n    }\n    \n    \n    private void skipRecordPadding() throws IOException {\n        if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) {\n            long numRecords = (this.entrySize / this.recordSize) + 1;\n            long padding = (numRecords * this.recordSize) - this.entrySize;\n            long skipped = IOUtils.skip(is, padding);\n            count(skipped);\n        }\n    }\n\n    \n    protected byte[] getLongNameData() throws IOException {\n        \n        ByteArrayOutputStream longName = new ByteArrayOutputStream();\n        int length = 0;\n        while ((length = read(SMALL_BUF)) >= 0) {\n            longName.write(SMALL_BUF, 0, length);\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            \n            \n            return null;\n        }\n        byte[] longNameData = longName.toByteArray();\n        \n        length = longNameData.length;\n        while (length > 0 && longNameData[length - 1] == 0) {\n            --length;\n        }\n        if (length != longNameData.length) {\n            byte[] l = new byte[length];\n            System.arraycopy(longNameData, 0, l, 0, length);\n            longNameData = l;\n        }\n        return longNameData;\n    }\n\n    \n    private byte[] getRecord() throws IOException {\n        byte[] headerBuf = readRecord();\n        hasHitEOF = isEOFRecord(headerBuf);\n        if (hasHitEOF && headerBuf != null) {\n            tryToConsumeSecondEOFRecord();\n            consumeRemainderOfLastBlock();\n            headerBuf = null;\n        }\n        return headerBuf;\n    }\n\n    \n    protected boolean isEOFRecord(byte[] record) {\n        return record == null || ArchiveUtils.isArrayZero(record, recordSize);\n    }\n    \n    \n    protected byte[] readRecord() throws IOException {\n\n        byte[] record = new byte[recordSize];\n\n        int readNow = IOUtils.readFully(is, record);\n        count(readNow);\n        if (readNow != recordSize) {\n            return null;\n        }\n\n        return record;\n    }\n\n    private void paxHeaders() throws IOException {\n        Map<String, String> headers = parsePaxHeaders(this);\n        getNextEntry(); \n        applyPaxHeadersToCurrentEntry(headers);\n    }\n\n    Map<String, String> parsePaxHeaders(InputStream i) throws IOException {\n        Map<String, String> headers = new HashMap<String, String>();\n        \n        while(true){ \n            int ch;\n            int len = 0;\n            int read = 0;\n            while((ch = i.read()) != -1) {\n                read++;\n                if (ch == ' '){ \n                    \n                    ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                    while((ch = i.read()) != -1) {\n                        read++;\n                        if (ch == '='){ \n                            String keyword = coll.toString(CharsetNames.UTF_8);\n                            \n                            byte[] rest = new byte[len - read];\n                            int got = IOUtils.readFully(i, rest);\n                            if (got != len - read){\n                                throw new IOException(\"Failed to read \"\n                                                      + \"Paxheader. Expected \"\n                                                      + (len - read)\n                                                      + \" bytes, read \"\n                                                      + got);\n                            }\n                            \n                            String value = new String(rest, 0,\n                                                      len - read - 1, CharsetNames.UTF_8);\n                            headers.put(keyword, value);\n                            break;\n                        }\n                        coll.write((byte) ch);\n                    }\n                    break; \n                }\n                len *= 10;\n                len += ch - '0';\n            }\n            if (ch == -1){ \n                break;\n            }\n        }\n        return headers;\n    }\n\n    private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n        \n        for (Entry<String, String> ent : headers.entrySet()){\n            String key = ent.getKey();\n            String val = ent.getValue();\n            if (\"path\".equals(key)){\n                currEntry.setName(val);\n            } else if (\"linkpath\".equals(key)){\n                currEntry.setLinkName(val);\n            } else if (\"gid\".equals(key)){\n                currEntry.setGroupId(Integer.parseInt(val));\n            } else if (\"gname\".equals(key)){\n                currEntry.setGroupName(val);\n            } else if (\"uid\".equals(key)){\n                currEntry.setUserId(Integer.parseInt(val));\n            } else if (\"uname\".equals(key)){\n                currEntry.setUserName(val);\n            } else if (\"size\".equals(key)){\n                currEntry.setSize(Long.parseLong(val));\n            } else if (\"mtime\".equals(key)){\n                currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n            } else if (\"SCHILY.devminor\".equals(key)){\n                currEntry.setDevMinor(Integer.parseInt(val));\n            } else if (\"SCHILY.devmajor\".equals(key)){\n                currEntry.setDevMajor(Integer.parseInt(val));\n            }\n        }\n    }\n\n    \n    private void readGNUSparse() throws IOException {\n        \n        if (currEntry.isExtended()) {\n            TarArchiveSparseEntry entry;\n            do {\n                byte[] headerBuf = getRecord();\n                if (headerBuf == null) {\n                    currEntry = null;\n                    break;\n                }\n                entry = new TarArchiveSparseEntry(headerBuf);\n                \n            } while (entry.isExtended());\n        }\n    }\n\n    \n    @Override\n    public ArchiveEntry getNextEntry() throws IOException {\n        return getNextTarEntry();\n    }\n    \n    \n    private void tryToConsumeSecondEOFRecord() throws IOException {\n        boolean shouldReset = true;\n        boolean marked = is.markSupported();\n        if (marked) {\n            is.mark(recordSize);\n        }\n        try {\n            shouldReset = !isEOFRecord(readRecord());\n        } finally {\n            if (shouldReset && marked) {\n                pushedBackBytes(recordSize);\n            \tis.reset();\n            }\n        }\n    }\n\n    \n    @Override\n    public int read(byte[] buf, int offset, int numToRead) throws IOException {\n    \tint totalRead = 0;\n\n        if (hasHitEOF || entryOffset >= entrySize) {\n            return -1;\n        }\n\n        if (currEntry == null) {\n            throw new IllegalStateException(\"No current tar entry\");\n        }\n\n        numToRead = Math.min(numToRead, available());\n        \n        totalRead = is.read(buf, offset, numToRead);\n        count(totalRead);\n        \n        if (totalRead == -1) {\n            hasHitEOF = true;\n        } else {\n            entryOffset += totalRead;\n        }\n\n        return totalRead;\n    }\n\n    \n    @Override\n    public boolean canReadEntryData(ArchiveEntry ae) {\n        if (ae instanceof TarArchiveEntry) {\n            TarArchiveEntry te = (TarArchiveEntry) ae;\n            return !te.isGNUSparse();\n        }\n        return false;\n    }\n\n    \n    public TarArchiveEntry getCurrentEntry() {\n        return currEntry;\n    }\n\n    protected final void setCurrentEntry(TarArchiveEntry e) {\n        currEntry = e;\n    }\n\n    protected final boolean isAtEOF() {\n        return hasHitEOF;\n    }\n\n    protected final void setAtEOF(boolean b) {\n        hasHitEOF = b;\n    }\n\n    \n    private void consumeRemainderOfLastBlock() throws IOException {\n        long bytesReadOfLastBlock = getBytesRead() % blockSize;\n        if (bytesReadOfLastBlock > 0) {\n            long skipped = IOUtils.skip(is, blockSize - bytesReadOfLastBlock);\n            count(skipped);\n        }\n    }\n\n    \n    public static boolean matches(byte[] signature, int length) {\n        if (length < TarConstants.VERSION_OFFSET+TarConstants.VERSIONLEN) {\n            return false;\n        }\n\n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_POSIX,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_POSIX,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n                ){\n            return true;\n        }\n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_GNU,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            (\n             ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_SPACE,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n            ||\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_ZERO,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n            )\n                ){\n            return true;\n        }\n        \n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_ANT,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_ANT,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n                ){\n            return true;\n        }\n        return false;\n    }\n\n}\n",
      "fixed_full_code": "\n\n\n\npackage org.apache.commons.compress.archivers.tar;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.archivers.zip.ZipEncoding;\nimport org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\nimport org.apache.commons.compress.utils.ArchiveUtils;\nimport org.apache.commons.compress.utils.CharsetNames;\nimport org.apache.commons.compress.utils.IOUtils;\n\n\npublic class TarArchiveInputStream extends ArchiveInputStream { private static final int SMALL_BUFFER_SIZE = 256; private final byte[] SMALL_BUF = new byte[SMALL_BUFFER_SIZE]; private final int recordSize; private final int blockSize; private boolean hasHitEOF; private long entrySize; private long entryOffset; private final InputStream is; private TarArchiveEntry currEntry; private final ZipEncoding encoding; public TarArchiveInputStream(InputStream is) {\n        this(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveInputStream(InputStream is, String encoding) {\n        this(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE,\n             encoding);\n    }\n\n    \n    public TarArchiveInputStream(InputStream is, int blockSize) {\n        this(is, blockSize, TarConstants.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveInputStream(InputStream is, int blockSize, String encoding) {\n        this(is, blockSize, TarConstants.DEFAULT_RCDSIZE, encoding);\n    }\n\n    \n    public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\n        this(is, blockSize, recordSize, null);      \n    }\n\n    \n    public TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n        this.is = is;\n        this.hasHitEOF = false;\n        this.encoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.recordSize = recordSize;\n        this.blockSize = blockSize;\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        is.close();\n    }\n\n    \n    public int getRecordSize() {\n        return recordSize;\n    }\n\n    \n    @Override\n    public int available() throws IOException {\n        if (entrySize - entryOffset > Integer.MAX_VALUE) {\n            return Integer.MAX_VALUE;\n        }\n        return (int) (entrySize - entryOffset);\n    }\n\n    \n    @Override\n    public long skip(long numToSkip) throws IOException {\n\n        long available = entrySize - entryOffset;\n        numToSkip = Math.min(numToSkip, available);\n\n        long skipped = IOUtils.skip(is, numToSkip); \n        count(skipped);\n        entryOffset += skipped;\n        return skipped;\n    }\n\n    \n    @Override\n    public synchronized void reset() {\n    }\n\n    \n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            \n            skip(Long.MAX_VALUE);\n\n            \n            skipRecordPadding();\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (headerBuf == null) {\n            \n            currEntry = null;\n            return null;\n        }\n\n        try {\n            currEntry = new TarArchiveEntry(headerBuf, encoding);\n        } catch (IllegalArgumentException e) {\n            IOException ioe = new IOException(\"Error detected parsing the header\");\n            ioe.initCause(e);\n            throw ioe;\n        }\n\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongLinkEntry()) {\n            byte[] longLinkData = getLongNameData();\n            if (longLinkData == null) {\n                \n                \n                \n                return null;\n            }\n            currEntry.setLinkName(encoding.decode(longLinkData));\n        }\n\n        if (currEntry.isGNULongNameEntry()) {\n            byte[] longNameData = getLongNameData();\n            if (longNameData == null) {\n                \n                \n                \n                return null;\n            }\n            currEntry.setName(encoding.decode(longNameData));\n        }\n\n        if (currEntry.isPaxHeader()){ \n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()){ \n            readGNUSparse();\n        }\n\n        \n        \n        \n        \n        entrySize = currEntry.getSize();\n\n        return currEntry;\n    }\n    \n    \n    private void skipRecordPadding() throws IOException {\n        if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) {\n            long numRecords = (this.entrySize / this.recordSize) + 1;\n            long padding = (numRecords * this.recordSize) - this.entrySize;\n            long skipped = IOUtils.skip(is, padding);\n            count(skipped);\n        }\n    }\n\n    \n    protected byte[] getLongNameData() throws IOException {\n        \n        ByteArrayOutputStream longName = new ByteArrayOutputStream();\n        int length = 0;\n        while ((length = read(SMALL_BUF)) >= 0) {\n            longName.write(SMALL_BUF, 0, length);\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            \n            \n            return null;\n        }\n        byte[] longNameData = longName.toByteArray();\n        \n        length = longNameData.length;\n        while (length > 0 && longNameData[length - 1] == 0) {\n            --length;\n        }\n        if (length != longNameData.length) {\n            byte[] l = new byte[length];\n            System.arraycopy(longNameData, 0, l, 0, length);\n            longNameData = l;\n        }\n        return longNameData;\n    }\n\n    \n    private byte[] getRecord() throws IOException {\n        byte[] headerBuf = readRecord();\n        hasHitEOF = isEOFRecord(headerBuf);\n        if (hasHitEOF && headerBuf != null) {\n            tryToConsumeSecondEOFRecord();\n            consumeRemainderOfLastBlock();\n            headerBuf = null;\n        }\n        return headerBuf;\n    }\n\n    \n    protected boolean isEOFRecord(byte[] record) {\n        return record == null || ArchiveUtils.isArrayZero(record, recordSize);\n    }\n    \n    \n    protected byte[] readRecord() throws IOException {\n\n        byte[] record = new byte[recordSize];\n\n        int readNow = IOUtils.readFully(is, record);\n        count(readNow);\n        if (readNow != recordSize) {\n            return null;\n        }\n\n        return record;\n    }\n\n    private void paxHeaders() throws IOException {\n        Map<String, String> headers = parsePaxHeaders(this);\n        getNextEntry(); \n        applyPaxHeadersToCurrentEntry(headers);\n    }\n\n    Map<String, String> parsePaxHeaders(InputStream i) throws IOException {\n        Map<String, String> headers = new HashMap<String, String>();\n        \n        while(true){ \n            int ch;\n            int len = 0;\n            int read = 0;\n            while((ch = i.read()) != -1) {\n                read++;\n                if (ch == ' '){ \n                    \n                    ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                    while((ch = i.read()) != -1) {\n                        read++;\n                        if (ch == '='){ \n                            String keyword = coll.toString(CharsetNames.UTF_8);\n                            \n                            byte[] rest = new byte[len - read];\n                            int got = IOUtils.readFully(i, rest);\n                            if (got != len - read){\n                                throw new IOException(\"Failed to read \"\n                                                      + \"Paxheader. Expected \"\n                                                      + (len - read)\n                                                      + \" bytes, read \"\n                                                      + got);\n                            }\n                            \n                            String value = new String(rest, 0,\n                                                      len - read - 1, CharsetNames.UTF_8);\n                            headers.put(keyword, value);\n                            break;\n                        }\n                        coll.write((byte) ch);\n                    }\n                    break; \n                }\n                len *= 10;\n                len += ch - '0';\n            }\n            if (ch == -1){ \n                break;\n            }\n        }\n        return headers;\n    }\n\n    private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n        \n        for (Entry<String, String> ent : headers.entrySet()){\n            String key = ent.getKey();\n            String val = ent.getValue();\n            if (\"path\".equals(key)){\n                currEntry.setName(val);\n            } else if (\"linkpath\".equals(key)){\n                currEntry.setLinkName(val);\n            } else if (\"gid\".equals(key)){\n                currEntry.setGroupId(Integer.parseInt(val));\n            } else if (\"gname\".equals(key)){\n                currEntry.setGroupName(val);\n            } else if (\"uid\".equals(key)){\n                currEntry.setUserId(Integer.parseInt(val));\n            } else if (\"uname\".equals(key)){\n                currEntry.setUserName(val);\n            } else if (\"size\".equals(key)){\n                currEntry.setSize(Long.parseLong(val));\n            } else if (\"mtime\".equals(key)){\n                currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n            } else if (\"SCHILY.devminor\".equals(key)){\n                currEntry.setDevMinor(Integer.parseInt(val));\n            } else if (\"SCHILY.devmajor\".equals(key)){\n                currEntry.setDevMajor(Integer.parseInt(val));\n            }\n        }\n    }\n\n    \n    private void readGNUSparse() throws IOException {\n        \n        if (currEntry.isExtended()) {\n            TarArchiveSparseEntry entry;\n            do {\n                byte[] headerBuf = getRecord();\n                if (headerBuf == null) {\n                    currEntry = null;\n                    break;\n                }\n                entry = new TarArchiveSparseEntry(headerBuf);\n                \n            } while (entry.isExtended());\n        }\n    }\n\n    \n    @Override\n    public ArchiveEntry getNextEntry() throws IOException {\n        return getNextTarEntry();\n    }\n    \n    \n    private void tryToConsumeSecondEOFRecord() throws IOException {\n        boolean shouldReset = true;\n        boolean marked = is.markSupported();\n        if (marked) {\n            is.mark(recordSize);\n        }\n        try {\n            shouldReset = !isEOFRecord(readRecord());\n        } finally {\n            if (shouldReset && marked) {\n                pushedBackBytes(recordSize);\n            \tis.reset();\n            }\n        }\n    }\n\n    \n    @Override\n    public int read(byte[] buf, int offset, int numToRead) throws IOException {\n    \tint totalRead = 0;\n\n        if (hasHitEOF || entryOffset >= entrySize) {\n            return -1;\n        }\n\n        if (currEntry == null) {\n            throw new IllegalStateException(\"No current tar entry\");\n        }\n\n        numToRead = Math.min(numToRead, available());\n        \n        totalRead = is.read(buf, offset, numToRead);\n        \n        if (totalRead == -1) {\n            if (numToRead > 0) {\n                throw new IOException(\"Truncated TAR archive\");\n            }\n            hasHitEOF = true;\n        } else {\n            count(totalRead);\n            entryOffset += totalRead;\n        }\n\n        return totalRead;\n    }\n\n    \n    @Override\n    public boolean canReadEntryData(ArchiveEntry ae) {\n        if (ae instanceof TarArchiveEntry) {\n            TarArchiveEntry te = (TarArchiveEntry) ae;\n            return !te.isGNUSparse();\n        }\n        return false;\n    }\n\n    \n    public TarArchiveEntry getCurrentEntry() {\n        return currEntry;\n    }\n\n    protected final void setCurrentEntry(TarArchiveEntry e) {\n        currEntry = e;\n    }\n\n    protected final boolean isAtEOF() {\n        return hasHitEOF;\n    }\n\n    protected final void setAtEOF(boolean b) {\n        hasHitEOF = b;\n    }\n\n    \n    private void consumeRemainderOfLastBlock() throws IOException {\n        long bytesReadOfLastBlock = getBytesRead() % blockSize;\n        if (bytesReadOfLastBlock > 0) {\n            long skipped = IOUtils.skip(is, blockSize - bytesReadOfLastBlock);\n            count(skipped);\n        }\n    }\n\n    \n    public static boolean matches(byte[] signature, int length) {\n        if (length < TarConstants.VERSION_OFFSET+TarConstants.VERSIONLEN) {\n            return false;\n        }\n\n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_POSIX,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_POSIX,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n                ){\n            return true;\n        }\n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_GNU,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            (\n             ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_SPACE,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n            ||\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_ZERO,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n            )\n                ){\n            return true;\n        }\n        \n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_ANT,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_ANT,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n                ){\n            return true;\n        }\n        return false;\n    }\n\n}\n",
      "buggy_signatures": [
        "public TarArchiveInputStream(InputStream is, String encoding)",
        "public TarArchiveInputStream(InputStream is, int blockSize)",
        "public TarArchiveInputStream(InputStream is, int blockSize, String encoding)",
        "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize)",
        "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding)",
        "public void close() throws IOException",
        "public int getRecordSize()",
        "public int available() throws IOException",
        "public long skip(long numToSkip) throws IOException",
        "public synchronized void reset()",
        "public TarArchiveEntry getNextTarEntry() throws IOException",
        "private void skipRecordPadding() throws IOException",
        "protected byte[] getLongNameData() throws IOException",
        "private byte[] getRecord() throws IOException",
        "protected boolean isEOFRecord(byte[] record)",
        "protected byte[] readRecord() throws IOException",
        "private void paxHeaders() throws IOException",
        "private void applyPaxHeadersToCurrentEntry(Map<String, String> headers)",
        "private void readGNUSparse() throws IOException",
        "public ArchiveEntry getNextEntry() throws IOException",
        "private void tryToConsumeSecondEOFRecord() throws IOException",
        "public int read(byte[] buf, int offset, int numToRead) throws IOException",
        "public boolean canReadEntryData(ArchiveEntry ae)",
        "public TarArchiveEntry getCurrentEntry()",
        "protected final void setCurrentEntry(TarArchiveEntry e)",
        "protected final boolean isAtEOF()",
        "protected final void setAtEOF(boolean b)",
        "private void consumeRemainderOfLastBlock() throws IOException",
        "public static boolean matches(byte[] signature, int length)"
      ],
      "fixed_signatures": [
        "public TarArchiveInputStream(InputStream is, String encoding)",
        "public TarArchiveInputStream(InputStream is, int blockSize)",
        "public TarArchiveInputStream(InputStream is, int blockSize, String encoding)",
        "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize)",
        "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding)",
        "public void close() throws IOException",
        "public int getRecordSize()",
        "public int available() throws IOException",
        "public long skip(long numToSkip) throws IOException",
        "public synchronized void reset()",
        "public TarArchiveEntry getNextTarEntry() throws IOException",
        "private void skipRecordPadding() throws IOException",
        "protected byte[] getLongNameData() throws IOException",
        "private byte[] getRecord() throws IOException",
        "protected boolean isEOFRecord(byte[] record)",
        "protected byte[] readRecord() throws IOException",
        "private void paxHeaders() throws IOException",
        "private void applyPaxHeadersToCurrentEntry(Map<String, String> headers)",
        "private void readGNUSparse() throws IOException",
        "public ArchiveEntry getNextEntry() throws IOException",
        "private void tryToConsumeSecondEOFRecord() throws IOException",
        "public int read(byte[] buf, int offset, int numToRead) throws IOException",
        "public boolean canReadEntryData(ArchiveEntry ae)",
        "public TarArchiveEntry getCurrentEntry()",
        "protected final void setCurrentEntry(TarArchiveEntry e)",
        "protected final boolean isAtEOF()",
        "protected final void setAtEOF(boolean b)",
        "private void consumeRemainderOfLastBlock() throws IOException",
        "public static boolean matches(byte[] signature, int length)"
      ],
      "methods": [
        {
          "buggy_method": "  public int read(byte[] buf, int offset, int numToRead) throws IOException {\n  \tint totalRead = 0;\n\n  if (hasHitEOF || entryOffset >= entrySize) {\n  return -1;\n  }\n\n  if (currEntry == null) {\n  throw new IllegalStateException(\"No current tar entry\");\n  }\n\n  numToRead = Math.min(numToRead, available());\n  \n  totalRead = is.read(buf, offset, numToRead);\n  count(totalRead);\n  \n  if (totalRead == -1) {\n  hasHitEOF = true;\n  } else {\n  entryOffset += totalRead;\n  }\n\n  return totalRead;\n  }",
          "fixed_method": "  public int read(byte[] buf, int offset, int numToRead) throws IOException {\n  \tint totalRead = 0;\n\n  if (hasHitEOF || entryOffset >= entrySize) {\n  return -1;\n  }\n\n  if (currEntry == null) {\n  throw new IllegalStateException(\"No current tar entry\");\n  }\n\n  numToRead = Math.min(numToRead, available());\n  \n  totalRead = is.read(buf, offset, numToRead);\n  \n  if (totalRead == -1) {\n  if (numToRead > 0) {\n  throw new IOException(\"Truncated TAR archive\");\n  }\n  hasHitEOF = true;\n  } else {\n  count(totalRead);\n  entryOffset += totalRead;\n  }\n\n  return totalRead;\n  }",
          "diff": [
            "@@ -580,11 +580,14 @@",
            "         numToRead = Math.min(numToRead, available());\n",
            "         \n",
            "         totalRead = is.read(buf, offset, numToRead);\n",
            "-        count(totalRead);\n",
            "         \n",
            "         if (totalRead == -1) {\n",
            "+            if (numToRead > 0) {\n",
            "+                throw new IOException(\"Truncated TAR archive\");\n",
            "+            }\n",
            "             hasHitEOF = true;\n",
            "         } else {\n",
            "+            count(totalRead);\n",
            "             entryOffset += totalRead;\n",
            "         }\n",
            " \n"
          ],
          "changed_lines": 5
        }
      ]
    }
  ]
}
