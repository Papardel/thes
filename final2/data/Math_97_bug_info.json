{
  "bug_id": "97",
  "failed_tests": {
    "org.apache.commons.math.analysis.BrentSolverTest": [
      {
        "methodName": "testRootEndpoints",
        "error": "java.lang.IllegalArgumentException",
        "message": "Function values at endpoints do not have different signs.  Endpoints: [3.0,3.141592653589793]  Values: [0.1411200080598672,1.2246467991473532E-16]",
        "fail_line": "        result = solver.solve(3, Math.PI);",
        "test_source": "  public void testRootEndpoints() throws Exception {\n  UnivariateRealFunction f = new SinFunction();\n  UnivariateRealSolver solver = new BrentSolver(f);\n  \n  // endpoint is root\n  double result = solver.solve(Math.PI, 4);\n  assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n\n  result = solver.solve(3, Math.PI);\n  assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n  }",
        "stack": [
          "BrentSolver.solve line 141, BrentSolverTest.testRootEndpoints line 279"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/analysis/BrentSolver.java",
      "buggy_full_code": "\npackage org.apache.commons.math.analysis;\n\n\nimport org.apache.commons.math.FunctionEvaluationException;\nimport org.apache.commons.math.MaxIterationsExceededException;\n\n\npublic class BrentSolver extends UnivariateRealSolverImpl { private static final long serialVersionUID = -2136672307739067002L; public BrentSolver(UnivariateRealFunction f) {\n        super(f, 100, 1E-6);\n    }\n\n    \n    public double solve(double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        if (((initial - min) * (max -initial)) < 0) {\n            throw new IllegalArgumentException(\"Initial guess is not in search\" +\n                      \" interval.\" + \"  Initial: \" + initial +\n                      \"  Endpoints: [\" + min + \",\" + max + \"]\");\n        }\n\n        \n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        \n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        \n        if (yInitial * yMin < 0) {\n            return solve(min, yMin, initial, yInitial, min, yMin);\n        }\n\n        \n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        \n        if (yInitial * yMax < 0) {\n            return solve(initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n        \n        return solve(min, yMin, max, yMax, initial, yInitial);\n\n    }\n    \n    \n    public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n        \n        clearResult();\n        verifyInterval(min, max);\n        \n        double ret = Double.NaN;\n        \n        double yMin = f.value(min);\n        double yMax = f.value(max);\n        \n        \n        double sign = yMin * yMax;\n        if (sign >= 0) {\n            \n                \n                throw new IllegalArgumentException\n                (\"Function values at endpoints do not have different signs.\" +\n                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n        } else {\n            \n            ret = solve(min, yMin, max, yMax, min, yMin);\n            \n        }\n\n        return ret;\n    }\n        \n    \n    private double solve(double x0, double y0, double x1, double y1, double x2, double y2) throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        double delta = x1 - x0;\n        double oldDelta = delta;\n\n        int i = 0;\n        while (i < maximalIterationCount) {\n            if (Math.abs(y2) < Math.abs(y1)) {\n                \n                x0 = x1;\n                x1 = x2;\n                x2 = x0;\n                y0 = y1;\n                y1 = y2;\n                y2 = y0;\n            }\n            if (Math.abs(y1) <= functionValueAccuracy) {\n                \n                \n                \n                setResult(x1, i);\n                return result;\n            }\n            double dx = (x2 - x1);\n            double tolerance =\n                Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n            if (Math.abs(dx) <= tolerance) {\n                setResult(x1, i);\n                return result;\n            }\n            if ((Math.abs(oldDelta) < tolerance) ||\n                    (Math.abs(y0) <= Math.abs(y1))) {\n                \n                delta = 0.5 * dx;\n                oldDelta = delta;\n            } else {\n                double r3 = y1 / y0;\n                double p;\n                double p1;\n                \n                \n                \n                if (x0 == x2) {\n                    \n                    p = dx * r3;\n                    p1 = 1.0 - r3;\n                } else {\n                    \n                    double r1 = y0 / y2;\n                    double r2 = y1 / y2;\n                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                    p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n                }\n                if (p > 0.0) {\n                    p1 = -p1;\n                } else {\n                    p = -p;\n                }\n                if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                        p >= Math.abs(0.5 * oldDelta * p1)) {\n                    \n                    \n                    \n                    delta = 0.5 * dx;\n                    oldDelta = delta;\n                } else {\n                    oldDelta = delta;\n                    delta = p / p1;\n                }\n            }\n            \n            x0 = x1;\n            y0 = y1;\n            \n            if (Math.abs(delta) > tolerance) {\n                x1 = x1 + delta;\n            } else if (dx > 0.0) {\n                x1 = x1 + 0.5 * tolerance;\n            } else if (dx <= 0.0) {\n                x1 = x1 - 0.5 * tolerance;\n            }\n            y1 = f.value(x1);\n            if ((y1 > 0) == (y2 > 0)) {\n                x2 = x0;\n                y2 = y0;\n                delta = x1 - x0;\n                oldDelta = delta;\n            }\n            i++;\n        }\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.math.analysis;\n\n\nimport org.apache.commons.math.FunctionEvaluationException;\nimport org.apache.commons.math.MaxIterationsExceededException;\n\n\npublic class BrentSolver extends UnivariateRealSolverImpl { private static final long serialVersionUID = -2136672307739067002L; public BrentSolver(UnivariateRealFunction f) {\n        super(f, 100, 1E-6);\n    }\n\n    \n    public double solve(double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        if (((initial - min) * (max -initial)) < 0) {\n            throw new IllegalArgumentException(\"Initial guess is not in search\" +\n                      \" interval.\" + \"  Initial: \" + initial +\n                      \"  Endpoints: [\" + min + \",\" + max + \"]\");\n        }\n\n        \n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        \n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        \n        if (yInitial * yMin < 0) {\n            return solve(min, yMin, initial, yInitial, min, yMin);\n        }\n\n        \n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        \n        if (yInitial * yMax < 0) {\n            return solve(initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n        \n        return solve(min, yMin, max, yMax, initial, yInitial);\n\n    }\n    \n    \n    public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n        \n        clearResult();\n        verifyInterval(min, max);\n        \n        double ret = Double.NaN;\n        \n        double yMin = f.value(min);\n        double yMax = f.value(max);\n        \n        \n        double sign = yMin * yMax;\n        if (sign > 0) {\n            \n            if (Math.abs(yMin) <= functionValueAccuracy) {\n                setResult(min, 0);\n                ret = min;\n            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n                setResult(max, 0);\n                ret = max;\n            } else {\n                \n                throw new IllegalArgumentException\n                (\"Function values at endpoints do not have different signs.\" +\n                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n            }\n        } else if (sign < 0){\n            \n            ret = solve(min, yMin, max, yMax, min, yMin);\n        } else {\n            \n            if (yMin == 0.0) {\n                ret = min;\n            } else {\n                ret = max;\n            }\n        }\n\n        return ret;\n    }\n        \n    \n    private double solve(double x0, double y0, double x1, double y1, double x2, double y2) throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        double delta = x1 - x0;\n        double oldDelta = delta;\n\n        int i = 0;\n        while (i < maximalIterationCount) {\n            if (Math.abs(y2) < Math.abs(y1)) {\n                \n                x0 = x1;\n                x1 = x2;\n                x2 = x0;\n                y0 = y1;\n                y1 = y2;\n                y2 = y0;\n            }\n            if (Math.abs(y1) <= functionValueAccuracy) {\n                \n                \n                \n                setResult(x1, i);\n                return result;\n            }\n            double dx = (x2 - x1);\n            double tolerance =\n                Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n            if (Math.abs(dx) <= tolerance) {\n                setResult(x1, i);\n                return result;\n            }\n            if ((Math.abs(oldDelta) < tolerance) ||\n                    (Math.abs(y0) <= Math.abs(y1))) {\n                \n                delta = 0.5 * dx;\n                oldDelta = delta;\n            } else {\n                double r3 = y1 / y0;\n                double p;\n                double p1;\n                \n                \n                \n                if (x0 == x2) {\n                    \n                    p = dx * r3;\n                    p1 = 1.0 - r3;\n                } else {\n                    \n                    double r1 = y0 / y2;\n                    double r2 = y1 / y2;\n                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                    p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n                }\n                if (p > 0.0) {\n                    p1 = -p1;\n                } else {\n                    p = -p;\n                }\n                if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                        p >= Math.abs(0.5 * oldDelta * p1)) {\n                    \n                    \n                    \n                    delta = 0.5 * dx;\n                    oldDelta = delta;\n                } else {\n                    oldDelta = delta;\n                    delta = p / p1;\n                }\n            }\n            \n            x0 = x1;\n            y0 = y1;\n            \n            if (Math.abs(delta) > tolerance) {\n                x1 = x1 + delta;\n            } else if (dx > 0.0) {\n                x1 = x1 + 0.5 * tolerance;\n            } else if (dx <= 0.0) {\n                x1 = x1 - 0.5 * tolerance;\n            }\n            y1 = f.value(x1);\n            if ((y1 > 0) == (y2 > 0)) {\n                x2 = x0;\n                y2 = y0;\n                delta = x1 - x0;\n                oldDelta = delta;\n            }\n            i++;\n        }\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }\n}\n",
      "buggy_signatures": [
        "public double solve(double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException",
        "public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException",
        "private double solve(double x0, double y0, double x1, double y1, double x2, double y2) throws MaxIterationsExceededException, FunctionEvaluationException"
      ],
      "fixed_signatures": [
        "public double solve(double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException",
        "public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException",
        "private double solve(double x0, double y0, double x1, double y1, double x2, double y2) throws MaxIterationsExceededException, FunctionEvaluationException"
      ],
      "methods": [
        {
          "buggy_method": "  public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n  \n  clearResult();\n  verifyInterval(min, max);\n  \n  double ret = Double.NaN;\n  \n  double yMin = f.value(min);\n  double yMax = f.value(max);\n  \n  \n  double sign = yMin * yMax;\n  if (sign >= 0) {\n  \n  \n  throw new IllegalArgumentException\n  (\"Function values at endpoints do not have different signs.\" +\n  \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n  \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n  } else {\n  \n  ret = solve(min, yMin, max, yMax, min, yMin);\n  \n  }\n\n  return ret;\n  }",
          "fixed_method": "  public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n  \n  clearResult();\n  verifyInterval(min, max);\n  \n  double ret = Double.NaN;\n  \n  double yMin = f.value(min);\n  double yMax = f.value(max);\n  \n  \n  double sign = yMin * yMax;\n  if (sign > 0) {\n  \n  if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min, 0);\n  ret = min;\n  } else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max, 0);\n  ret = max;\n  } else {\n  \n  throw new IllegalArgumentException\n  (\"Function values at endpoints do not have different signs.\" +\n  \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n  \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n  }\n  } else if (sign < 0){\n  \n  ret = solve(min, yMin, max, yMax, min, yMin);\n  } else {\n  \n  if (yMin == 0.0) {\n  ret = min;\n  } else {\n  ret = max;\n  }\n  }\n\n  return ret;\n  }",
          "diff": [
            "@@ -135,17 +135,31 @@",
            "         \n",
            "         // Verify bracketing\n",
            "         double sign = yMin * yMax;\n",
            "-        if (sign >= 0) {\n",
            "+        if (sign > 0) {\n",
            "             // check if either value is close to a zero\n",
            "+            if (Math.abs(yMin) <= functionValueAccuracy) {\n",
            "+                setResult(min, 0);\n",
            "+                ret = min;\n",
            "+            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n",
            "+                setResult(max, 0);\n",
            "+                ret = max;\n",
            "+            } else {\n",
            "                 // neither value is close to zero and min and max do not bracket root.\n",
            "                 throw new IllegalArgumentException\n",
            "                 (\"Function values at endpoints do not have different signs.\" +\n",
            "                         \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n",
            "                         \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n",
            "-        } else {\n",
            "+            }\n",
            "+        } else if (sign < 0){\n",
            "             // solve using only the first endpoint as initial guess\n",
            "             ret = solve(min, yMin, max, yMax, min, yMin);\n",
            "+        } else {\n",
            "             // either min or max is a root\n",
            "+            if (yMin == 0.0) {\n",
            "+                ret = min;\n",
            "+            } else {\n",
            "+                ret = max;\n",
            "+            }\n",
            "         }\n",
            " \n",
            "         return ret;\n"
          ],
          "changed_lines": 18
        }
      ]
    }
  ]
}
