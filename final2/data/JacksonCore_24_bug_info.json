{
  "bug_id": "24",
  "failed_tests": {
    "com.fasterxml.jackson.core.json.async.AsyncNumberCoercionTest": [
      {
        "methodName": "testToLongFailing",
        "error": "com.fasterxml.jackson.core.JsonParseException",
        "message": "Numeric value (9223372036854775817) out of range of long (-9223372036854775808 - 9223372036854775807)",
        "fail_line": "            p.getLongValue();",
        "test_source": "  public void testToLongFailing() throws Exception {\n  AsyncReaderWrapper p;\n\n  // BigInteger -> error\n  BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);\n  p = createParser(String.valueOf(big));\n  assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n  assertEquals(NumberType.BIG_INTEGER, p.getNumberType());\n  assertEquals(big, p.getBigIntegerValue());\n  assertEquals(big, p.getNumberValue());\n  try {\n  p.getLongValue();\n  fail(\"Should not pass\");\n  } catch (InputCoercionException e) {\n  verifyException(e, \"out of range of long\");\n  assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n  assertEquals(Long.TYPE, e.getTargetType());\n  }\n  BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);\n  p = createParser(String.valueOf(small));\n  assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n  assertEquals(small, p.getBigIntegerValue());\n  try {\n  p.getLongValue();\n  fail(\"Should not pass\");\n  } catch (InputCoercionException e) {\n  verifyException(e, \"out of range of long\");\n  assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n  assertEquals(Long.TYPE, e.getTargetType());\n  }\n  }",
        "stack": [
          "JsonParser._constructError line 1833, ParserMinimalBase._reportError line 704, ParserMinimalBase.reportOverflowLong line 582, ParserMinimalBase.reportOverflowLong line 577, ParserBase.convertNumberToLong line 921, ParserBase.getLongValue line 663, AsyncReaderWrapper.getLongValue line 57, AsyncNumberCoercionTest.testToLongFailing line 189"
        ]
      },
      {
        "methodName": "testToIntFailing",
        "error": "com.fasterxml.jackson.core.JsonParseException",
        "message": "Numeric value (2147483648) out of range of int",
        "fail_line": "            p.getIntValue();",
        "test_source": "  public void testToIntFailing() throws Exception {\n  AsyncReaderWrapper p;\n\n  // long -> error\n  long big = 1L + Integer.MAX_VALUE;\n  p = createParser(String.valueOf(big));\n  assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n  assertEquals(big, p.getLongValue());\n  try {\n  p.getIntValue();\n  fail(\"Should not pass\");\n  } catch (InputCoercionException e) {\n  verifyException(e, \"out of range of int\");\n  assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n  assertEquals(Integer.TYPE, e.getTargetType());\n  }\n  long small = -1L + Integer.MIN_VALUE;\n  p = createParser(String.valueOf(small));\n  assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n  assertEquals(Long.valueOf(small), p.getNumberValue());\n  assertEquals(small, p.getLongValue());\n  try {\n  p.getIntValue();\n  fail(\"Should not pass\");\n  } catch (InputCoercionException e) {\n  verifyException(e, \"out of range of int\");\n  assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n  assertEquals(Integer.TYPE, e.getTargetType());\n  }\n\n  // double -> error\n  p = createParser(String.valueOf(big)+\".0\");\n  assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());\n  assertEquals((double) big, p.getDoubleValue());\n  try {\n  p.getIntValue();\n  fail(\"Should not pass\");\n  } catch (InputCoercionException e) {\n  verifyException(e, \"out of range of int\");\n  assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n  assertEquals(Integer.TYPE, e.getTargetType());\n  }\n  p = createParser(String.valueOf(small)+\".0\");\n  assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());\n  assertEquals((double) small, p.getDoubleValue());\n  try {\n  p.getIntValue();\n  fail(\"Should not pass\");\n  } catch (InputCoercionException e) {\n  verifyException(e, \"out of range of int\");\n  assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n  assertEquals(Integer.TYPE, e.getTargetType());\n  }\n\n  // BigInteger -> error\n  p = createParser(String.valueOf(big));\n  assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n  assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());\n  try {\n  p.getIntValue();\n  fail(\"Should not pass\");\n  } catch (InputCoercionException e) {\n  verifyException(e, \"out of range of int\");\n  assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n  assertEquals(Integer.TYPE, e.getTargetType());\n  }\n  p = createParser(String.valueOf(small));\n  assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n  assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());\n  try {\n  p.getIntValue();\n  fail(\"Should not pass\");\n  } catch (InputCoercionException e) {\n  verifyException(e, \"out of range of int\");\n  assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n  assertEquals(Integer.TYPE, e.getTargetType());\n  }\n  }",
        "stack": [
          "JsonParser._constructError line 1833, ParserMinimalBase._reportError line 704, ParserBase.convertNumberToInt line 887, ParserBase.getIntValue line 649, AsyncReaderWrapper.getIntValue line 56, AsyncNumberCoercionTest.testToIntFailing line 73"
        ]
      }
    ],
    "com.fasterxml.jackson.core.read.NumberCoercionTest": [
      {
        "methodName": "testToLongFailing",
        "error": "com.fasterxml.jackson.core.JsonParseException",
        "message": "Numeric value (9223372036854775817) out of range of long (-9223372036854775808 - 9223372036854775807)",
        "fail_line": "                p.getLongValue();",
        "test_source": "  public void testToLongFailing() throws Exception {\n  for (int mode : ALL_STREAMING_MODES) {\n  JsonParser p;\n\n  // BigInteger -> error\n  BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);\n  p = createParser(mode, String.valueOf(big));\n  assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n  assertEquals(NumberType.BIG_INTEGER, p.getNumberType());\n  assertEquals(big, p.getBigIntegerValue());\n  assertEquals(big, p.getNumberValue());\n  try {\n  p.getLongValue();\n  fail(\"Should not pass\");\n  } catch (InputCoercionException e) {\n  verifyException(e, \"out of range of long\");\n  assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n  assertEquals(Long.TYPE, e.getTargetType());\n  }\n  BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);\n  p = createParser(mode, String.valueOf(small));\n  assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n  assertEquals(small, p.getBigIntegerValue());\n  try {\n  p.getLongValue();\n  fail(\"Should not pass\");\n  } catch (InputCoercionException e) {\n  verifyException(e, \"out of range of long\");\n  assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n  assertEquals(Long.TYPE, e.getTargetType());\n  }\n  }\n  }",
        "stack": [
          "JsonParser._constructError line 1833, ParserMinimalBase._reportError line 704, ParserMinimalBase.reportOverflowLong line 582, ParserMinimalBase.reportOverflowLong line 577, ParserBase.convertNumberToLong line 921, ParserBase.getLongValue line 663, NumberCoercionTest.testToLongFailing line 189"
        ]
      },
      {
        "methodName": "testToIntFailing",
        "error": "com.fasterxml.jackson.core.JsonParseException",
        "message": "Numeric value (2147483648) out of range of int",
        "fail_line": "                p.getIntValue();",
        "test_source": "  public void testToIntFailing() throws Exception {\n  for (int mode : ALL_STREAMING_MODES) {\n  JsonParser p;\n\n  // long -> error\n  long big = 1L + Integer.MAX_VALUE;\n  p = createParser(mode, String.valueOf(big));\n  assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n  assertEquals(big, p.getLongValue());\n  try {\n  p.getIntValue();\n  fail(\"Should not pass\");\n  } catch (InputCoercionException e) {\n  verifyException(e, \"out of range of int\");\n  assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n  assertEquals(Integer.TYPE, e.getTargetType());\n  }\n  long small = -1L + Integer.MIN_VALUE;\n  p = createParser(mode, String.valueOf(small));\n  assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n  assertEquals(Long.valueOf(small), p.getNumberValue());\n  assertEquals(small, p.getLongValue());\n  try {\n  p.getIntValue();\n  fail(\"Should not pass\");\n  } catch (InputCoercionException e) {\n  verifyException(e, \"out of range of int\");\n  assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n  assertEquals(Integer.TYPE, e.getTargetType());\n  }\n\n  // double -> error\n  p = createParser(mode, String.valueOf(big)+\".0\");\n  assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());\n  assertEquals((double) big, p.getDoubleValue());\n  try {\n  p.getIntValue();\n  fail(\"Should not pass\");\n  } catch (InputCoercionException e) {\n  verifyException(e, \"out of range of int\");\n  assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n  assertEquals(Integer.TYPE, e.getTargetType());\n  }\n  p = createParser(mode, String.valueOf(small)+\".0\");\n  assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());\n  assertEquals((double) small, p.getDoubleValue());\n  try {\n  p.getIntValue();\n  fail(\"Should not pass\");\n  } catch (InputCoercionException e) {\n  verifyException(e, \"out of range of int\");\n  assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n  assertEquals(Integer.TYPE, e.getTargetType());\n  }\n\n  // BigInteger -> error\n  p = createParser(mode, String.valueOf(big));\n  assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n  assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());\n  try {\n  p.getIntValue();\n  fail(\"Should not pass\");\n  } catch (InputCoercionException e) {\n  verifyException(e, \"out of range of int\");\n  assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n  assertEquals(Integer.TYPE, e.getTargetType());\n  }\n  p = createParser(mode, String.valueOf(small));\n  assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n  assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());\n  try {\n  p.getIntValue();\n  fail(\"Should not pass\");\n  } catch (InputCoercionException e) {\n  verifyException(e, \"out of range of int\");\n  assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n  assertEquals(Integer.TYPE, e.getTargetType());\n  }\n  }\n  }",
        "stack": [
          "JsonParser._constructError line 1833, ParserMinimalBase._reportError line 704, ParserBase.convertNumberToInt line 887, ParserBase.getIntValue line 649, NumberCoercionTest.testToIntFailing line 68"
        ]
      }
    ],
    "com.fasterxml.jackson.core.read.NumberOverflowTest": [
      {
        "methodName": "testMaliciousLongOverflow",
        "error": "com.fasterxml.jackson.core.JsonParseException",
        "message": "Numeric value ([Integer with 199999 digits]) out of range of long",
        "fail_line": "                    p.getLongValue();",
        "test_source": "  public void testMaliciousLongOverflow() throws Exception {\n  for (int mode : ALL_STREAMING_MODES) {\n  for (String doc : new String[] { BIG_POS_DOC, BIG_NEG_DOC }) {\n  JsonParser p = createParser(mode, doc);\n  assertToken(JsonToken.START_ARRAY, p.nextToken());\n  assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n  try {\n  p.getLongValue();\n  fail(\"Should not pass\");\n  } catch (InputCoercionException e) {\n  verifyException(e, \"out of range of long\");\n  verifyException(e, \"Integer with \"+BIG_NUM_LEN+\" digits\");\n  }\n  p.close();\n  }\n  }\n  }  ",
        "stack": [
          "JsonParser._constructError line 1833, ParserMinimalBase._reportError line 714, ParserBase._reportTooLongIntegral line 870, ParserBase._parseSlowInt line 849, ParserBase._parseNumericValue line 775, ParserBase.getLongValue line 660, NumberOverflowTest.testMaliciousLongOverflow line 72"
        ]
      },
      {
        "methodName": "testSimpleLongOverflow",
        "error": "com.fasterxml.jackson.core.JsonParseException",
        "message": "Numeric value (-9223372036854775809) out of range of long",
        "fail_line": "                long x = p.getLongValue();",
        "test_source": "  public void testSimpleLongOverflow() throws Exception {\n  BigInteger below = BigInteger.valueOf(Long.MIN_VALUE);\n  below = below.subtract(BigInteger.ONE);\n  BigInteger above = BigInteger.valueOf(Long.MAX_VALUE);\n  above = above.add(BigInteger.ONE);\n\n  String DOC_BELOW = below.toString() + \" \";\n  String DOC_ABOVE = below.toString() + \" \";\n\n  for (int mode : ALL_MODES) {\n  JsonParser p = createParser(FACTORY, mode, DOC_BELOW);\n  p.nextToken();\n  try {\n  long x = p.getLongValue();\n  fail(\"Expected an exception for underflow (input \"+p.getText()+\"): instead, got long value: \"+x);\n  } catch (InputCoercionException e) {\n  verifyException(e, \"out of range of long\");\n  }\n  p.close();\n\n  p = createParser(mode, DOC_ABOVE);\n  p.nextToken();\n  try {\n  long x = p.getLongValue();\n  fail(\"Expected an exception for underflow (input \"+p.getText()+\"): instead, got long value: \"+x);\n  } catch (InputCoercionException e) {\n  verifyException(e, \"out of range of long\");\n  }\n  p.close();\n  }\n  }",
        "stack": [
          "JsonParser._constructError line 1833, ParserMinimalBase._reportError line 714, ParserBase._reportTooLongIntegral line 870, ParserBase._parseSlowInt line 849, ParserBase._parseNumericValue line 775, ParserBase.getLongValue line 660, NumberOverflowTest.testSimpleLongOverflow line 41"
        ]
      },
      {
        "methodName": "testMaliciousIntOverflow",
        "error": "com.fasterxml.jackson.core.JsonParseException",
        "message": "Numeric value ([Integer with 199999 digits]) out of range of int",
        "fail_line": "                    p.getIntValue();",
        "test_source": "  public void testMaliciousIntOverflow() throws Exception {\n  for (int mode : ALL_STREAMING_MODES) {\n  for (String doc : new String[] { BIG_POS_DOC, BIG_NEG_DOC }) {\n  JsonParser p = createParser(mode, doc);\n  assertToken(JsonToken.START_ARRAY, p.nextToken());\n  assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n  try {\n  p.getIntValue();\n  fail(\"Should not pass\");\n  } catch (InputCoercionException e) {\n  verifyException(e, \"out of range of int\");\n  verifyException(e, \"Integer with \"+BIG_NUM_LEN+\" digits\");\n  }\n  p.close();\n  }\n  }\n  }  ",
        "stack": [
          "JsonParser._constructError line 1833, ParserMinimalBase._reportError line 714, ParserBase._reportTooLongIntegral line 870, ParserBase._parseSlowInt line 849, ParserBase._parseNumericValue line 775, ParserBase._parseIntValue line 800, ParserBase.getIntValue line 646, NumberOverflowTest.testMaliciousIntOverflow line 92"
        ]
      }
    ],
    "com.fasterxml.jackson.core.read.NumberParsingTest": [
      {
        "methodName": "testSimpleLong",
        "error": "com.fasterxml.jackson.core.JsonParseException",
        "message": "Numeric value (12345678907) out of range of int",
        "fail_line": "        _testSimpleLong(MODE_INPUT_STREAM);",
        "test_source": "  public void testSimpleLong() throws Exception {\n  _testSimpleLong(MODE_INPUT_STREAM);\n  _testSimpleLong(MODE_INPUT_STREAM_THROTTLED);\n  _testSimpleLong(MODE_READER);\n  _testSimpleLong(MODE_DATA_INPUT);\n  }",
        "stack": [
          "JsonParser._constructError line 1833, ParserMinimalBase._reportError line 704, ParserBase.convertNumberToInt line 887, ParserBase.getIntValue line 649, NumberParsingTest._testSimpleLong line 128, NumberParsingTest.testSimpleLong line 108"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/core/base/ParserBase.java",
      "buggy_full_code": "package com.fasterxml.jackson.core.base;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Arrays;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.JsonParser.Feature;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.io.NumberInput;\nimport com.fasterxml.jackson.core.json.DupDetector;\nimport com.fasterxml.jackson.core.json.JsonReadContext;\nimport com.fasterxml.jackson.core.json.PackageVersion;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.core.util.TextBuffer;\n\n\npublic abstract class ParserBase extends ParserMinimalBase { final protected IOContext _ioContext; protected boolean _closed; protected int _inputPtr; protected int _inputEnd; protected long _currInputProcessed; protected int _currInputRow = 1; protected int _currInputRowStart; protected long _tokenInputTotal; protected int _tokenInputRow = 1; protected int _tokenInputCol; protected JsonReadContext _parsingContext; protected JsonToken _nextToken; protected final TextBuffer _textBuffer; protected char[] _nameCopyBuffer; protected boolean _nameCopied; protected ByteArrayBuilder _byteArrayBuilder; protected byte[] _binaryValue; protected int _numTypesValid = NR_UNKNOWN; protected int _numberInt; protected long _numberLong; protected double _numberDouble; protected BigInteger _numberBigInt; protected BigDecimal _numberBigDecimal; protected boolean _numberNegative; protected int _intLength; protected int _fractLength; protected int _expLength; protected ParserBase(IOContext ctxt, int features) {\n        super(features);\n        _ioContext = ctxt;\n        _textBuffer = ctxt.constructTextBuffer();\n        DupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features)\n                ? DupDetector.rootDetector(this) : null;\n        _parsingContext = JsonReadContext.createRootContext(dups);\n    }\n\n    @Override public Version version() { return PackageVersion.VERSION; }\n\n    @Override\n    public Object getCurrentValue() {\n        return _parsingContext.getCurrentValue();\n    }\n\n    @Override\n    public void setCurrentValue(Object v) {\n        _parsingContext.setCurrentValue(v);\n    }\n    \n    \n\n    @Override\n    public JsonParser enable(Feature f) {\n        _features |= f.getMask();\n        if (f == Feature.STRICT_DUPLICATE_DETECTION) { \n            if (_parsingContext.getDupDetector() == null) { \n                _parsingContext = _parsingContext.withDupDetector(DupDetector.rootDetector(this));\n            }\n        }\n        return this;\n    }\n\n    @Override\n    public JsonParser disable(Feature f) {\n        _features &= ~f.getMask();\n        if (f == Feature.STRICT_DUPLICATE_DETECTION) {\n            _parsingContext = _parsingContext.withDupDetector(null);\n        }\n        return this;\n    }\n\n    @Override\n    @Deprecated\n    public JsonParser setFeatureMask(int newMask) {\n        int changes = (_features ^ newMask);\n        if (changes != 0) {\n            _features = newMask;\n            _checkStdFeatureChanges(newMask, changes);\n        }\n        return this;\n    }\n\n    @Override \n    public JsonParser overrideStdFeatures(int values, int mask) {\n        int oldState = _features;\n        int newState = (oldState & ~mask) | (values & mask);\n        int changed = oldState ^ newState;\n        if (changed != 0) {\n            _features = newState;\n            _checkStdFeatureChanges(newState, changed);\n        }\n        return this;\n    }\n\n    \n    protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures) {\n        int f = Feature.STRICT_DUPLICATE_DETECTION.getMask();\n        \n        if ((changedFeatures & f) != 0) {\n            if ((newFeatureFlags & f) != 0) {\n                if (_parsingContext.getDupDetector() == null) {\n                    _parsingContext = _parsingContext.withDupDetector(DupDetector.rootDetector(this));\n                } else { \n                    _parsingContext = _parsingContext.withDupDetector(null);\n                }\n            }\n        }\n    }\n\n    \n    \n    \n    @Override public String getCurrentName() throws IOException {\n        \n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            JsonReadContext parent = _parsingContext.getParent();\n            if (parent != null) {\n                return parent.getCurrentName();\n            }\n        }\n        return _parsingContext.getCurrentName();\n    }\n\n    @Override public void overrideCurrentName(String name) {\n        \n        JsonReadContext ctxt = _parsingContext;\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            ctxt = ctxt.getParent();\n        }\n        \n        try {\n            ctxt.setCurrentName(name);\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    @Override public void close() throws IOException {\n        if (!_closed) {\n            \n            _inputPtr = Math.max(_inputPtr, _inputEnd);\n            _closed = true;\n            try {\n                _closeInput();\n            } finally {\n                \n                \n                _releaseBuffers();\n            }\n        }\n    }\n\n    @Override public boolean isClosed() { return _closed; }\n    @Override public JsonReadContext getParsingContext() { return _parsingContext; }\n\n    \n    @Override\n    public JsonLocation getTokenLocation() {\n        return new JsonLocation(_getSourceReference(),\n                -1L, getTokenCharacterOffset(), \n                getTokenLineNr(),\n                getTokenColumnNr());\n    }\n\n    \n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; \n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr, \n                _currInputRow, col);\n    }\n\n    \n\n    @Override\n    public boolean hasTextCharacters() {\n        if (_currToken == JsonToken.VALUE_STRING) { return true; } \n        if (_currToken == JsonToken.FIELD_NAME) { return _nameCopied; }\n        return false;\n    }\n\n    @SuppressWarnings(\"resource\")\n    @Override \n    public byte[] getBinaryValue(Base64Variant variant) throws IOException {\n        if (_binaryValue == null) {\n            if (_currToken != JsonToken.VALUE_STRING) {\n                _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING, can not access as binary\");\n            }\n            ByteArrayBuilder builder = _getByteArrayBuilder();\n            _decodeBase64(getText(), builder, variant);\n            _binaryValue = builder.toByteArray();\n        }\n        return _binaryValue;\n    }\n\n    \n\n    public long getTokenCharacterOffset() { return _tokenInputTotal; }\n    public int getTokenLineNr() { return _tokenInputRow; }\n    public int getTokenColumnNr() {\n        \n        int col = _tokenInputCol;\n        return (col < 0) ? col : (col + 1);\n    }\n\n    \n\n    protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException {\n        _textBuffer.releaseBuffers();\n        char[] buf = _nameCopyBuffer;\n        if (buf != null) {\n            _nameCopyBuffer = null;\n            _ioContext.releaseNameCopyBuffer(buf);\n        }\n    }\n    \n    \n    @Override\n    protected void _handleEOF() throws JsonParseException {\n        if (!_parsingContext.inRoot()) {\n            String marker = _parsingContext.inArray() ? \"Array\" : \"Object\";\n            _reportInvalidEOF(String.format(\n                    \": expected close marker for %s (start marker at %s)\",\n                    marker,\n                    _parsingContext.getStartLocation(_getSourceReference())),\n                    null);\n        }\n    }\n\n    \n    protected final int _eofAsNextChar() throws JsonParseException {\n        _handleEOF();\n        return -1;\n    }\n\n    \n    \n    public ByteArrayBuilder _getByteArrayBuilder() {\n        if (_byteArrayBuilder == null) {\n            _byteArrayBuilder = new ByteArrayBuilder();\n        } else {\n            _byteArrayBuilder.reset();\n        }\n        return _byteArrayBuilder;\n    }\n\n    \n\n    \n    \n    protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen) {\n        if (fractLen < 1 && expLen < 1) { \n            return resetInt(negative, intLen);\n        }\n        return resetFloat(negative, intLen, fractLen, expLen);\n    }\n        \n    protected final JsonToken resetInt(boolean negative, int intLen) {\n        _numberNegative = negative;\n        _intLength = intLen;\n        _fractLength = 0;\n        _expLength = 0;\n        _numTypesValid = NR_UNKNOWN; \n        return JsonToken.VALUE_NUMBER_INT;\n    }\n    \n    protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen) {\n        _numberNegative = negative;\n        _intLength = intLen;\n        _fractLength = fractLen;\n        _expLength = expLen;\n        _numTypesValid = NR_UNKNOWN; \n        return JsonToken.VALUE_NUMBER_FLOAT;\n    }\n    \n    protected final JsonToken resetAsNaN(String valueStr, double value) {\n        _textBuffer.resetWithString(valueStr);\n        _numberDouble = value;\n        _numTypesValid = NR_DOUBLE;\n        return JsonToken.VALUE_NUMBER_FLOAT;\n    }\n\n    @Override\n    public boolean isNaN() {\n        if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n            if ((_numTypesValid & NR_DOUBLE) != 0) {\n                \n                double d = _numberDouble;\n                return Double.isNaN(d) || Double.isInfinite(d);              \n            }\n        }\n        return false;\n    }\n\n    \n    \n    @Override\n    public Number getNumberValue() throws IOException {\n        if (_numTypesValid == NR_UNKNOWN) {\n            _parseNumericValue(NR_UNKNOWN); \n        }\n        \n        if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n            if ((_numTypesValid & NR_INT) != 0) {\n                return _numberInt;\n            }\n            if ((_numTypesValid & NR_LONG) != 0) {\n                return _numberLong;\n            }\n            if ((_numTypesValid & NR_BIGINT) != 0) {\n                return _numberBigInt;\n            }\n            \n            return _numberBigDecimal;\n        }\n    \n        \n        if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n            return _numberBigDecimal;\n        }\n        if ((_numTypesValid & NR_DOUBLE) == 0) { \n            _throwInternal();\n        }\n        return _numberDouble;\n    }\n    \n    @Override\n    public NumberType getNumberType() throws IOException {\n        if (_numTypesValid == NR_UNKNOWN) {\n            _parseNumericValue(NR_UNKNOWN); \n        }\n        if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n            if ((_numTypesValid & NR_INT) != 0) {\n                return NumberType.INT;\n            }\n            if ((_numTypesValid & NR_LONG) != 0) {\n                return NumberType.LONG;\n            }\n            return NumberType.BIG_INTEGER;\n        }\n    \n        \n        if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n            return NumberType.BIG_DECIMAL;\n        }\n        return NumberType.DOUBLE;\n    }\n    \n    @Override\n    public int getIntValue() throws IOException {\n        if ((_numTypesValid & NR_INT) == 0) {\n            if (_numTypesValid == NR_UNKNOWN) { \n                return _parseIntValue();\n            }\n            if ((_numTypesValid & NR_INT) == 0) { \n                convertNumberToInt(); \n            }\n        }\n        return _numberInt;\n    }\n    \n    @Override\n    public long getLongValue() throws IOException {\n        if ((_numTypesValid & NR_LONG) == 0) {\n            if (_numTypesValid == NR_UNKNOWN) {\n                _parseNumericValue(NR_LONG);\n            }\n            if ((_numTypesValid & NR_LONG) == 0) {\n                convertNumberToLong();\n            }\n        }\n        return _numberLong;\n    }\n    \n    @Override\n    public BigInteger getBigIntegerValue() throws IOException {\n        if ((_numTypesValid & NR_BIGINT) == 0) {\n            if (_numTypesValid == NR_UNKNOWN) {\n                _parseNumericValue(NR_BIGINT);\n            }\n            if ((_numTypesValid & NR_BIGINT) == 0) {\n                convertNumberToBigInteger();\n            }\n        }\n        return _numberBigInt;\n    }\n    \n    @Override\n    public float getFloatValue() throws IOException {\n        double value = getDoubleValue();\n        \n        \n        return (float) value;\n    }\n    \n    @Override\n    public double getDoubleValue() throws IOException {\n        if ((_numTypesValid & NR_DOUBLE) == 0) {\n            if (_numTypesValid == NR_UNKNOWN) {\n                _parseNumericValue(NR_DOUBLE);\n            }\n            if ((_numTypesValid & NR_DOUBLE) == 0) {\n                convertNumberToDouble();\n            }\n        }\n        return _numberDouble;\n    }\n    \n    @Override\n    public BigDecimal getDecimalValue() throws IOException {\n        if ((_numTypesValid & NR_BIGDECIMAL) == 0) {\n            if (_numTypesValid == NR_UNKNOWN) {\n                _parseNumericValue(NR_BIGDECIMAL);\n            }\n            if ((_numTypesValid & NR_BIGDECIMAL) == 0) {\n                convertNumberToBigDecimal();\n            }\n        }\n        return _numberBigDecimal;\n    }\n\n    \n    \n    \n    protected void _parseNumericValue(int expType) throws IOException {\n        \n        if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n            int len = _intLength;\n            \n            if (len <= 9) { \n                int i = _textBuffer.contentsAsInt(_numberNegative);\n                _numberInt = i;\n                _numTypesValid = NR_INT;\n                return;\n            }\n            if (len <= 18) { \n                long l = _textBuffer.contentsAsLong(_numberNegative);\n                \n                if (len == 10) {\n                    if (_numberNegative) {\n                        if (l >= MIN_INT_L) {\n                            _numberInt = (int) l;\n                            _numTypesValid = NR_INT;\n                            return;\n                        }\n                    } else {\n                        if (l <= MAX_INT_L) {\n                            _numberInt = (int) l;\n                            _numTypesValid = NR_INT;\n                            return;\n                        }\n                    }\n                }\n                _numberLong = l;\n                _numTypesValid = NR_LONG;\n                return;\n            }\n            _parseSlowInt(expType);\n            return;\n        }\n        if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n            _parseSlowFloat(expType);\n            return;\n        }\n        _reportError(\"Current token (%s) not numeric, can not use numeric value accessors\", _currToken);\n    }\n\n    \n    protected int _parseIntValue() throws IOException {\n        \n        if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n            if (_intLength <= 9) {\n                int i = _textBuffer.contentsAsInt(_numberNegative);\n                _numberInt = i;\n                _numTypesValid = NR_INT;\n                return i;\n            }\n        }\n        \n        _parseNumericValue(NR_INT);\n        if ((_numTypesValid & NR_INT) == 0) {\n            convertNumberToInt();\n        }\n        return _numberInt;\n    }\n\n    private void _parseSlowFloat(int expType) throws IOException {\n        \n        try {\n            if (expType == NR_BIGDECIMAL) {\n                _numberBigDecimal = _textBuffer.contentsAsDecimal();\n                _numTypesValid = NR_BIGDECIMAL;\n            } else {\n                \n                _numberDouble = _textBuffer.contentsAsDouble();\n                _numTypesValid = NR_DOUBLE;\n            }\n        } catch (NumberFormatException nex) {\n            \n            _wrapError(\"Malformed numeric value (\"+_longNumberDesc(_textBuffer.contentsAsString())+\")\", nex);\n        }\n    }\n\n    private void _parseSlowInt(int expType) throws IOException {\n        String numStr = _textBuffer.contentsAsString();\n        try {\n            int len = _intLength;\n            char[] buf = _textBuffer.getTextBuffer();\n            int offset = _textBuffer.getTextOffset();\n            if (_numberNegative) {\n                ++offset;\n            }\n            \n            if (NumberInput.inLongRange(buf, offset, len, _numberNegative)) {\n                \n                _numberLong = Long.parseLong(numStr);\n                _numTypesValid = NR_LONG;\n            } else {\n                \n                if ((expType == NR_INT) || (expType == NR_LONG)) {\n                    _reportTooLongIntegral(expType, numStr);\n                }\n                if ((expType == NR_DOUBLE) || (expType == NR_FLOAT)) {\n                    _numberDouble = NumberInput.parseDouble(numStr);\n                    _numTypesValid = NR_DOUBLE;\n                } else {\n                    \n                    _numberBigInt = new BigInteger(numStr);\n                    _numTypesValid = NR_BIGINT;\n                }\n            }\n        } catch (NumberFormatException nex) {\n            \n            _wrapError(\"Malformed numeric value (\"+_longNumberDesc(numStr)+\")\", nex);\n        }\n    }\n\n    \n    protected void _reportTooLongIntegral(int expType, String rawNum) throws IOException {\n        final String numDesc = _longIntegerDesc(rawNum);\n        _reportError(\"Numeric value (%s) out of range of %s\", numDesc,\n                (expType == NR_LONG) ? \"long\" : \"int\");\n    }\n\n        \n    \n    protected void convertNumberToInt() throws IOException {\n        \n        if ((_numTypesValid & NR_LONG) != 0) {\n            \n            int result = (int) _numberLong;\n            if (((long) result) != _numberLong) {\n                _reportError(\"Numeric value (\"+getText()+\") out of range of int\");\n            }\n            _numberInt = result;\n        } else if ((_numTypesValid & NR_BIGINT) != 0) {\n            if (BI_MIN_INT.compareTo(_numberBigInt) > 0 \n                    || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n                reportOverflowInt();\n            }\n            _numberInt = _numberBigInt.intValue();\n        } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n            \n            if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {\n                reportOverflowInt();\n            }\n            _numberInt = (int) _numberDouble;\n        } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n            if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 \n                || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n                reportOverflowInt();\n            }\n            _numberInt = _numberBigDecimal.intValue();\n        } else {\n            _throwInternal();\n        }\n        _numTypesValid |= NR_INT;\n    }\n    \n    protected void convertNumberToLong() throws IOException {\n        if ((_numTypesValid & NR_INT) != 0) {\n            _numberLong = (long) _numberInt;\n        } else if ((_numTypesValid & NR_BIGINT) != 0) {\n            if (BI_MIN_LONG.compareTo(_numberBigInt) > 0 \n                    || BI_MAX_LONG.compareTo(_numberBigInt) < 0) {\n                reportOverflowLong();\n            }\n            _numberLong = _numberBigInt.longValue();\n        } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n            \n            if (_numberDouble < MIN_LONG_D || _numberDouble > MAX_LONG_D) {\n                reportOverflowLong();\n            }\n            _numberLong = (long) _numberDouble;\n        } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n            if (BD_MIN_LONG.compareTo(_numberBigDecimal) > 0 \n                || BD_MAX_LONG.compareTo(_numberBigDecimal) < 0) {\n                reportOverflowLong();\n            }\n            _numberLong = _numberBigDecimal.longValue();\n        } else {\n            _throwInternal();\n        }\n        _numTypesValid |= NR_LONG;\n    }\n    \n    protected void convertNumberToBigInteger() throws IOException {\n        if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n            \n            _numberBigInt = _numberBigDecimal.toBigInteger();\n        } else if ((_numTypesValid & NR_LONG) != 0) {\n            _numberBigInt = BigInteger.valueOf(_numberLong);\n        } else if ((_numTypesValid & NR_INT) != 0) {\n            _numberBigInt = BigInteger.valueOf(_numberInt);\n        } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n            _numberBigInt = BigDecimal.valueOf(_numberDouble).toBigInteger();\n        } else {\n            _throwInternal();\n        }\n        _numTypesValid |= NR_BIGINT;\n    }\n    \n    protected void convertNumberToDouble() throws IOException {\n        \n    \n        if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n            _numberDouble = _numberBigDecimal.doubleValue();\n        } else if ((_numTypesValid & NR_BIGINT) != 0) {\n            _numberDouble = _numberBigInt.doubleValue();\n        } else if ((_numTypesValid & NR_LONG) != 0) {\n            _numberDouble = (double) _numberLong;\n        } else if ((_numTypesValid & NR_INT) != 0) {\n            _numberDouble = (double) _numberInt;\n        } else {\n            _throwInternal();\n        }\n        _numTypesValid |= NR_DOUBLE;\n    }\n    \n    protected void convertNumberToBigDecimal() throws IOException {\n        \n    \n        if ((_numTypesValid & NR_DOUBLE) != 0) {\n            \n            _numberBigDecimal = NumberInput.parseBigDecimal(getText());\n        } else if ((_numTypesValid & NR_BIGINT) != 0) {\n            _numberBigDecimal = new BigDecimal(_numberBigInt);\n        } else if ((_numTypesValid & NR_LONG) != 0) {\n            _numberBigDecimal = BigDecimal.valueOf(_numberLong);\n        } else if ((_numTypesValid & NR_INT) != 0) {\n            _numberBigDecimal = BigDecimal.valueOf(_numberInt);\n        } else {\n            _throwInternal();\n        }\n        _numTypesValid |= NR_BIGDECIMAL;\n    }\n\n    \n\n    protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException {\n        JsonReadContext ctxt = getParsingContext();\n        _reportError(String.format(\n                \"Unexpected close marker '%s': expected '%c' (for %s starting at %s)\",\n                (char) actCh, expCh, ctxt.typeDesc(), ctxt.getStartLocation(_getSourceReference())));\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException {\n        \n        if (isEnabled(Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER)) {\n            return ch;\n        }\n        \n        if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return ch;\n        }\n        _reportError(\"Unrecognized character escape \"+_getCharDesc(ch));\n        return ch;\n    }\n\n    \n    @SuppressWarnings(\"deprecation\")\n    protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException {\n        \n        if (!isEnabled(Feature.ALLOW_UNQUOTED_CONTROL_CHARS) || i > INT_SPACE) {\n            char c = (char) i;\n            String msg = \"Illegal unquoted character (\"+_getCharDesc(c)+\"): has to be escaped using backslash to be included in \"+ctxtDesc;\n            _reportError(msg);\n        }\n    }\n\n    \n\n    \n    protected char _decodeEscaped() throws IOException {\n        throw new UnsupportedOperationException();\n    }\n    \n    protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException {\n        \n        if (ch != '\\\\') {\n            throw reportInvalidBase64Char(b64variant, ch, index);\n        }\n        int unescaped = _decodeEscaped();\n        \n        if (unescaped <= INT_SPACE) {\n            if (index == 0) { \n                return -1;\n            }\n        }\n        \n        int bits = b64variant.decodeBase64Char(unescaped);\n        if (bits < 0) {\n            if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                throw reportInvalidBase64Char(b64variant, unescaped, index);\n            }\n        }\n        return bits;\n    }\n    \n    protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException {\n        if (ch != '\\\\') {\n            throw reportInvalidBase64Char(b64variant, ch, index);\n        }\n        char unescaped = _decodeEscaped();\n        \n        if (unescaped <= INT_SPACE) {\n            if (index == 0) { \n                return -1;\n            }\n        }\n        \n        int bits = b64variant.decodeBase64Char(unescaped);\n        if (bits < 0) {\n            \n            if ((bits != Base64Variant.BASE64_VALUE_PADDING) || (index < 2)) {\n                throw reportInvalidBase64Char(b64variant, unescaped, index);\n            }\n        }\n        return bits;\n    }\n    \n    protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException {\n        return reportInvalidBase64Char(b64variant, ch, bindex, null);\n    }\n\n    \n    protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException {\n        String base;\n        if (ch <= INT_SPACE) {\n            base = String.format(\"Illegal white space character (code 0x%s) as character #%d of 4-char base64 unit: can only used between units\",\n                    Integer.toHexString(ch), (bindex+1));\n        } else if (b64variant.usesPaddingChar(ch)) {\n            base = \"Unexpected padding character ('\"+b64variant.getPaddingChar()+\"') as character #\"+(bindex+1)+\" of 4-char base64 unit: padding only legal as 3rd or 4th character\";\n        } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) {\n            \n            base = \"Illegal character (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n        } else {\n            base = \"Illegal character '\"+((char)ch)+\"' (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n        }\n        if (msg != null) {\n            base = base + \": \" + msg;\n        }\n        return new IllegalArgumentException(base);\n    }\n\n    \n    protected void _handleBase64MissingPadding(Base64Variant b64variant) throws IOException {\n        _reportError(b64variant.missingPaddingMessage());\n    }\n\n    \n\n    \n    protected Object _getSourceReference() {\n        if (JsonParser.Feature.INCLUDE_SOURCE_IN_LOCATION.enabledIn(_features)) {\n            return _ioContext.getSourceReference();\n        }\n        return null;\n    }\n\n    protected static int[] growArrayBy(int[] arr, int more) {\n        if (arr == null) {\n            return new int[more];\n        }\n        return Arrays.copyOf(arr, arr.length + more);\n    }\n    \n    \n\n    @Deprecated \n    protected void loadMoreGuaranteed() throws IOException {\n        if (!loadMore()) { _reportInvalidEOF(); }\n    }\n\n    @Deprecated \n    protected boolean loadMore() throws IOException { return false; }\n\n    \n    protected void _finishString() throws IOException { }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.core.base;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Arrays;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.JsonParser.Feature;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.io.NumberInput;\nimport com.fasterxml.jackson.core.json.DupDetector;\nimport com.fasterxml.jackson.core.json.JsonReadContext;\nimport com.fasterxml.jackson.core.json.PackageVersion;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.core.util.TextBuffer;\n\n\npublic abstract class ParserBase extends ParserMinimalBase { final protected IOContext _ioContext; protected boolean _closed; protected int _inputPtr; protected int _inputEnd; protected long _currInputProcessed; protected int _currInputRow = 1; protected int _currInputRowStart; protected long _tokenInputTotal; protected int _tokenInputRow = 1; protected int _tokenInputCol; protected JsonReadContext _parsingContext; protected JsonToken _nextToken; protected final TextBuffer _textBuffer; protected char[] _nameCopyBuffer; protected boolean _nameCopied; protected ByteArrayBuilder _byteArrayBuilder; protected byte[] _binaryValue; protected int _numTypesValid = NR_UNKNOWN; protected int _numberInt; protected long _numberLong; protected double _numberDouble; protected BigInteger _numberBigInt; protected BigDecimal _numberBigDecimal; protected boolean _numberNegative; protected int _intLength; protected int _fractLength; protected int _expLength; protected ParserBase(IOContext ctxt, int features) {\n        super(features);\n        _ioContext = ctxt;\n        _textBuffer = ctxt.constructTextBuffer();\n        DupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features)\n                ? DupDetector.rootDetector(this) : null;\n        _parsingContext = JsonReadContext.createRootContext(dups);\n    }\n\n    @Override public Version version() { return PackageVersion.VERSION; }\n\n    @Override\n    public Object getCurrentValue() {\n        return _parsingContext.getCurrentValue();\n    }\n\n    @Override\n    public void setCurrentValue(Object v) {\n        _parsingContext.setCurrentValue(v);\n    }\n    \n    \n\n    @Override\n    public JsonParser enable(Feature f) {\n        _features |= f.getMask();\n        if (f == Feature.STRICT_DUPLICATE_DETECTION) { \n            if (_parsingContext.getDupDetector() == null) { \n                _parsingContext = _parsingContext.withDupDetector(DupDetector.rootDetector(this));\n            }\n        }\n        return this;\n    }\n\n    @Override\n    public JsonParser disable(Feature f) {\n        _features &= ~f.getMask();\n        if (f == Feature.STRICT_DUPLICATE_DETECTION) {\n            _parsingContext = _parsingContext.withDupDetector(null);\n        }\n        return this;\n    }\n\n    @Override\n    @Deprecated\n    public JsonParser setFeatureMask(int newMask) {\n        int changes = (_features ^ newMask);\n        if (changes != 0) {\n            _features = newMask;\n            _checkStdFeatureChanges(newMask, changes);\n        }\n        return this;\n    }\n\n    @Override \n    public JsonParser overrideStdFeatures(int values, int mask) {\n        int oldState = _features;\n        int newState = (oldState & ~mask) | (values & mask);\n        int changed = oldState ^ newState;\n        if (changed != 0) {\n            _features = newState;\n            _checkStdFeatureChanges(newState, changed);\n        }\n        return this;\n    }\n\n    \n    protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures) {\n        int f = Feature.STRICT_DUPLICATE_DETECTION.getMask();\n        \n        if ((changedFeatures & f) != 0) {\n            if ((newFeatureFlags & f) != 0) {\n                if (_parsingContext.getDupDetector() == null) {\n                    _parsingContext = _parsingContext.withDupDetector(DupDetector.rootDetector(this));\n                } else { \n                    _parsingContext = _parsingContext.withDupDetector(null);\n                }\n            }\n        }\n    }\n\n    \n    \n    \n    @Override public String getCurrentName() throws IOException {\n        \n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            JsonReadContext parent = _parsingContext.getParent();\n            if (parent != null) {\n                return parent.getCurrentName();\n            }\n        }\n        return _parsingContext.getCurrentName();\n    }\n\n    @Override public void overrideCurrentName(String name) {\n        \n        JsonReadContext ctxt = _parsingContext;\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            ctxt = ctxt.getParent();\n        }\n        \n        try {\n            ctxt.setCurrentName(name);\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    @Override public void close() throws IOException {\n        if (!_closed) {\n            \n            _inputPtr = Math.max(_inputPtr, _inputEnd);\n            _closed = true;\n            try {\n                _closeInput();\n            } finally {\n                \n                \n                _releaseBuffers();\n            }\n        }\n    }\n\n    @Override public boolean isClosed() { return _closed; }\n    @Override public JsonReadContext getParsingContext() { return _parsingContext; }\n\n    \n    @Override\n    public JsonLocation getTokenLocation() {\n        return new JsonLocation(_getSourceReference(),\n                -1L, getTokenCharacterOffset(), \n                getTokenLineNr(),\n                getTokenColumnNr());\n    }\n\n    \n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; \n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr, \n                _currInputRow, col);\n    }\n\n    \n\n    @Override\n    public boolean hasTextCharacters() {\n        if (_currToken == JsonToken.VALUE_STRING) { return true; } \n        if (_currToken == JsonToken.FIELD_NAME) { return _nameCopied; }\n        return false;\n    }\n\n    @SuppressWarnings(\"resource\")\n    @Override \n    public byte[] getBinaryValue(Base64Variant variant) throws IOException {\n        if (_binaryValue == null) {\n            if (_currToken != JsonToken.VALUE_STRING) {\n                _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING, can not access as binary\");\n            }\n            ByteArrayBuilder builder = _getByteArrayBuilder();\n            _decodeBase64(getText(), builder, variant);\n            _binaryValue = builder.toByteArray();\n        }\n        return _binaryValue;\n    }\n\n    \n\n    public long getTokenCharacterOffset() { return _tokenInputTotal; }\n    public int getTokenLineNr() { return _tokenInputRow; }\n    public int getTokenColumnNr() {\n        \n        int col = _tokenInputCol;\n        return (col < 0) ? col : (col + 1);\n    }\n\n    \n\n    protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException {\n        _textBuffer.releaseBuffers();\n        char[] buf = _nameCopyBuffer;\n        if (buf != null) {\n            _nameCopyBuffer = null;\n            _ioContext.releaseNameCopyBuffer(buf);\n        }\n    }\n    \n    \n    @Override\n    protected void _handleEOF() throws JsonParseException {\n        if (!_parsingContext.inRoot()) {\n            String marker = _parsingContext.inArray() ? \"Array\" : \"Object\";\n            _reportInvalidEOF(String.format(\n                    \": expected close marker for %s (start marker at %s)\",\n                    marker,\n                    _parsingContext.getStartLocation(_getSourceReference())),\n                    null);\n        }\n    }\n\n    \n    protected final int _eofAsNextChar() throws JsonParseException {\n        _handleEOF();\n        return -1;\n    }\n\n    \n    \n    public ByteArrayBuilder _getByteArrayBuilder() {\n        if (_byteArrayBuilder == null) {\n            _byteArrayBuilder = new ByteArrayBuilder();\n        } else {\n            _byteArrayBuilder.reset();\n        }\n        return _byteArrayBuilder;\n    }\n\n    \n\n    \n    \n    protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen) {\n        if (fractLen < 1 && expLen < 1) { \n            return resetInt(negative, intLen);\n        }\n        return resetFloat(negative, intLen, fractLen, expLen);\n    }\n        \n    protected final JsonToken resetInt(boolean negative, int intLen) {\n        _numberNegative = negative;\n        _intLength = intLen;\n        _fractLength = 0;\n        _expLength = 0;\n        _numTypesValid = NR_UNKNOWN; \n        return JsonToken.VALUE_NUMBER_INT;\n    }\n    \n    protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen) {\n        _numberNegative = negative;\n        _intLength = intLen;\n        _fractLength = fractLen;\n        _expLength = expLen;\n        _numTypesValid = NR_UNKNOWN; \n        return JsonToken.VALUE_NUMBER_FLOAT;\n    }\n    \n    protected final JsonToken resetAsNaN(String valueStr, double value) {\n        _textBuffer.resetWithString(valueStr);\n        _numberDouble = value;\n        _numTypesValid = NR_DOUBLE;\n        return JsonToken.VALUE_NUMBER_FLOAT;\n    }\n\n    @Override\n    public boolean isNaN() {\n        if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n            if ((_numTypesValid & NR_DOUBLE) != 0) {\n                \n                double d = _numberDouble;\n                return Double.isNaN(d) || Double.isInfinite(d);              \n            }\n        }\n        return false;\n    }\n\n    \n    \n    @Override\n    public Number getNumberValue() throws IOException {\n        if (_numTypesValid == NR_UNKNOWN) {\n            _parseNumericValue(NR_UNKNOWN); \n        }\n        \n        if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n            if ((_numTypesValid & NR_INT) != 0) {\n                return _numberInt;\n            }\n            if ((_numTypesValid & NR_LONG) != 0) {\n                return _numberLong;\n            }\n            if ((_numTypesValid & NR_BIGINT) != 0) {\n                return _numberBigInt;\n            }\n            \n            return _numberBigDecimal;\n        }\n    \n        \n        if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n            return _numberBigDecimal;\n        }\n        if ((_numTypesValid & NR_DOUBLE) == 0) { \n            _throwInternal();\n        }\n        return _numberDouble;\n    }\n    \n    @Override\n    public NumberType getNumberType() throws IOException {\n        if (_numTypesValid == NR_UNKNOWN) {\n            _parseNumericValue(NR_UNKNOWN); \n        }\n        if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n            if ((_numTypesValid & NR_INT) != 0) {\n                return NumberType.INT;\n            }\n            if ((_numTypesValid & NR_LONG) != 0) {\n                return NumberType.LONG;\n            }\n            return NumberType.BIG_INTEGER;\n        }\n    \n        \n        if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n            return NumberType.BIG_DECIMAL;\n        }\n        return NumberType.DOUBLE;\n    }\n    \n    @Override\n    public int getIntValue() throws IOException {\n        if ((_numTypesValid & NR_INT) == 0) {\n            if (_numTypesValid == NR_UNKNOWN) { \n                return _parseIntValue();\n            }\n            if ((_numTypesValid & NR_INT) == 0) { \n                convertNumberToInt(); \n            }\n        }\n        return _numberInt;\n    }\n    \n    @Override\n    public long getLongValue() throws IOException {\n        if ((_numTypesValid & NR_LONG) == 0) {\n            if (_numTypesValid == NR_UNKNOWN) {\n                _parseNumericValue(NR_LONG);\n            }\n            if ((_numTypesValid & NR_LONG) == 0) {\n                convertNumberToLong();\n            }\n        }\n        return _numberLong;\n    }\n    \n    @Override\n    public BigInteger getBigIntegerValue() throws IOException {\n        if ((_numTypesValid & NR_BIGINT) == 0) {\n            if (_numTypesValid == NR_UNKNOWN) {\n                _parseNumericValue(NR_BIGINT);\n            }\n            if ((_numTypesValid & NR_BIGINT) == 0) {\n                convertNumberToBigInteger();\n            }\n        }\n        return _numberBigInt;\n    }\n    \n    @Override\n    public float getFloatValue() throws IOException {\n        double value = getDoubleValue();\n        \n        \n        return (float) value;\n    }\n    \n    @Override\n    public double getDoubleValue() throws IOException {\n        if ((_numTypesValid & NR_DOUBLE) == 0) {\n            if (_numTypesValid == NR_UNKNOWN) {\n                _parseNumericValue(NR_DOUBLE);\n            }\n            if ((_numTypesValid & NR_DOUBLE) == 0) {\n                convertNumberToDouble();\n            }\n        }\n        return _numberDouble;\n    }\n    \n    @Override\n    public BigDecimal getDecimalValue() throws IOException {\n        if ((_numTypesValid & NR_BIGDECIMAL) == 0) {\n            if (_numTypesValid == NR_UNKNOWN) {\n                _parseNumericValue(NR_BIGDECIMAL);\n            }\n            if ((_numTypesValid & NR_BIGDECIMAL) == 0) {\n                convertNumberToBigDecimal();\n            }\n        }\n        return _numberBigDecimal;\n    }\n\n    \n    \n    \n    protected void _parseNumericValue(int expType) throws IOException {\n        \n        if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n            int len = _intLength;\n            \n            if (len <= 9) { \n                int i = _textBuffer.contentsAsInt(_numberNegative);\n                _numberInt = i;\n                _numTypesValid = NR_INT;\n                return;\n            }\n            if (len <= 18) { \n                long l = _textBuffer.contentsAsLong(_numberNegative);\n                \n                if (len == 10) {\n                    if (_numberNegative) {\n                        if (l >= MIN_INT_L) {\n                            _numberInt = (int) l;\n                            _numTypesValid = NR_INT;\n                            return;\n                        }\n                    } else {\n                        if (l <= MAX_INT_L) {\n                            _numberInt = (int) l;\n                            _numTypesValid = NR_INT;\n                            return;\n                        }\n                    }\n                }\n                _numberLong = l;\n                _numTypesValid = NR_LONG;\n                return;\n            }\n            _parseSlowInt(expType);\n            return;\n        }\n        if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n            _parseSlowFloat(expType);\n            return;\n        }\n        _reportError(\"Current token (%s) not numeric, can not use numeric value accessors\", _currToken);\n    }\n\n    \n    protected int _parseIntValue() throws IOException {\n        \n        if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n            if (_intLength <= 9) {\n                int i = _textBuffer.contentsAsInt(_numberNegative);\n                _numberInt = i;\n                _numTypesValid = NR_INT;\n                return i;\n            }\n        }\n        \n        _parseNumericValue(NR_INT);\n        if ((_numTypesValid & NR_INT) == 0) {\n            convertNumberToInt();\n        }\n        return _numberInt;\n    }\n\n    private void _parseSlowFloat(int expType) throws IOException {\n        \n        try {\n            if (expType == NR_BIGDECIMAL) {\n                _numberBigDecimal = _textBuffer.contentsAsDecimal();\n                _numTypesValid = NR_BIGDECIMAL;\n            } else {\n                \n                _numberDouble = _textBuffer.contentsAsDouble();\n                _numTypesValid = NR_DOUBLE;\n            }\n        } catch (NumberFormatException nex) {\n            \n            _wrapError(\"Malformed numeric value (\"+_longNumberDesc(_textBuffer.contentsAsString())+\")\", nex);\n        }\n    }\n\n    private void _parseSlowInt(int expType) throws IOException {\n        String numStr = _textBuffer.contentsAsString();\n        try {\n            int len = _intLength;\n            char[] buf = _textBuffer.getTextBuffer();\n            int offset = _textBuffer.getTextOffset();\n            if (_numberNegative) {\n                ++offset;\n            }\n            \n            if (NumberInput.inLongRange(buf, offset, len, _numberNegative)) {\n                \n                _numberLong = Long.parseLong(numStr);\n                _numTypesValid = NR_LONG;\n            } else {\n                \n                if ((expType == NR_INT) || (expType == NR_LONG)) {\n                    _reportTooLongIntegral(expType, numStr);\n                }\n                if ((expType == NR_DOUBLE) || (expType == NR_FLOAT)) {\n                    _numberDouble = NumberInput.parseDouble(numStr);\n                    _numTypesValid = NR_DOUBLE;\n                } else {\n                    \n                    _numberBigInt = new BigInteger(numStr);\n                    _numTypesValid = NR_BIGINT;\n                }\n            }\n        } catch (NumberFormatException nex) {\n            \n            _wrapError(\"Malformed numeric value (\"+_longNumberDesc(numStr)+\")\", nex);\n        }\n    }\n\n    \n    protected void _reportTooLongIntegral(int expType, String rawNum) throws IOException {\n        if (expType == NR_INT) {\n            reportOverflowInt(rawNum);\n        } else {\n            reportOverflowLong(rawNum);\n        }\n    }\n\n        \n    \n    protected void convertNumberToInt() throws IOException {\n        \n        if ((_numTypesValid & NR_LONG) != 0) {\n            \n            int result = (int) _numberLong;\n            if (((long) result) != _numberLong) {\n                reportOverflowInt(getText(), currentToken());\n            }\n            _numberInt = result;\n        } else if ((_numTypesValid & NR_BIGINT) != 0) {\n            if (BI_MIN_INT.compareTo(_numberBigInt) > 0 \n                    || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n                reportOverflowInt();\n            }\n            _numberInt = _numberBigInt.intValue();\n        } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n            \n            if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {\n                reportOverflowInt();\n            }\n            _numberInt = (int) _numberDouble;\n        } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n            if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 \n                || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n                reportOverflowInt();\n            }\n            _numberInt = _numberBigDecimal.intValue();\n        } else {\n            _throwInternal();\n        }\n        _numTypesValid |= NR_INT;\n    }\n    \n    protected void convertNumberToLong() throws IOException {\n        if ((_numTypesValid & NR_INT) != 0) {\n            _numberLong = (long) _numberInt;\n        } else if ((_numTypesValid & NR_BIGINT) != 0) {\n            if (BI_MIN_LONG.compareTo(_numberBigInt) > 0 \n                    || BI_MAX_LONG.compareTo(_numberBigInt) < 0) {\n                reportOverflowLong();\n            }\n            _numberLong = _numberBigInt.longValue();\n        } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n            \n            if (_numberDouble < MIN_LONG_D || _numberDouble > MAX_LONG_D) {\n                reportOverflowLong();\n            }\n            _numberLong = (long) _numberDouble;\n        } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n            if (BD_MIN_LONG.compareTo(_numberBigDecimal) > 0 \n                || BD_MAX_LONG.compareTo(_numberBigDecimal) < 0) {\n                reportOverflowLong();\n            }\n            _numberLong = _numberBigDecimal.longValue();\n        } else {\n            _throwInternal();\n        }\n        _numTypesValid |= NR_LONG;\n    }\n    \n    protected void convertNumberToBigInteger() throws IOException {\n        if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n            \n            _numberBigInt = _numberBigDecimal.toBigInteger();\n        } else if ((_numTypesValid & NR_LONG) != 0) {\n            _numberBigInt = BigInteger.valueOf(_numberLong);\n        } else if ((_numTypesValid & NR_INT) != 0) {\n            _numberBigInt = BigInteger.valueOf(_numberInt);\n        } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n            _numberBigInt = BigDecimal.valueOf(_numberDouble).toBigInteger();\n        } else {\n            _throwInternal();\n        }\n        _numTypesValid |= NR_BIGINT;\n    }\n    \n    protected void convertNumberToDouble() throws IOException {\n        \n    \n        if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n            _numberDouble = _numberBigDecimal.doubleValue();\n        } else if ((_numTypesValid & NR_BIGINT) != 0) {\n            _numberDouble = _numberBigInt.doubleValue();\n        } else if ((_numTypesValid & NR_LONG) != 0) {\n            _numberDouble = (double) _numberLong;\n        } else if ((_numTypesValid & NR_INT) != 0) {\n            _numberDouble = (double) _numberInt;\n        } else {\n            _throwInternal();\n        }\n        _numTypesValid |= NR_DOUBLE;\n    }\n    \n    protected void convertNumberToBigDecimal() throws IOException {\n        \n    \n        if ((_numTypesValid & NR_DOUBLE) != 0) {\n            \n            _numberBigDecimal = NumberInput.parseBigDecimal(getText());\n        } else if ((_numTypesValid & NR_BIGINT) != 0) {\n            _numberBigDecimal = new BigDecimal(_numberBigInt);\n        } else if ((_numTypesValid & NR_LONG) != 0) {\n            _numberBigDecimal = BigDecimal.valueOf(_numberLong);\n        } else if ((_numTypesValid & NR_INT) != 0) {\n            _numberBigDecimal = BigDecimal.valueOf(_numberInt);\n        } else {\n            _throwInternal();\n        }\n        _numTypesValid |= NR_BIGDECIMAL;\n    }\n\n    \n\n    protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException {\n        JsonReadContext ctxt = getParsingContext();\n        _reportError(String.format(\n                \"Unexpected close marker '%s': expected '%c' (for %s starting at %s)\",\n                (char) actCh, expCh, ctxt.typeDesc(), ctxt.getStartLocation(_getSourceReference())));\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException {\n        \n        if (isEnabled(Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER)) {\n            return ch;\n        }\n        \n        if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return ch;\n        }\n        _reportError(\"Unrecognized character escape \"+_getCharDesc(ch));\n        return ch;\n    }\n\n    \n    @SuppressWarnings(\"deprecation\")\n    protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException {\n        \n        if (!isEnabled(Feature.ALLOW_UNQUOTED_CONTROL_CHARS) || i > INT_SPACE) {\n            char c = (char) i;\n            String msg = \"Illegal unquoted character (\"+_getCharDesc(c)+\"): has to be escaped using backslash to be included in \"+ctxtDesc;\n            _reportError(msg);\n        }\n    }\n\n    \n\n    \n    protected char _decodeEscaped() throws IOException {\n        throw new UnsupportedOperationException();\n    }\n    \n    protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException {\n        \n        if (ch != '\\\\') {\n            throw reportInvalidBase64Char(b64variant, ch, index);\n        }\n        int unescaped = _decodeEscaped();\n        \n        if (unescaped <= INT_SPACE) {\n            if (index == 0) { \n                return -1;\n            }\n        }\n        \n        int bits = b64variant.decodeBase64Char(unescaped);\n        if (bits < 0) {\n            if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                throw reportInvalidBase64Char(b64variant, unescaped, index);\n            }\n        }\n        return bits;\n    }\n    \n    protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException {\n        if (ch != '\\\\') {\n            throw reportInvalidBase64Char(b64variant, ch, index);\n        }\n        char unescaped = _decodeEscaped();\n        \n        if (unescaped <= INT_SPACE) {\n            if (index == 0) { \n                return -1;\n            }\n        }\n        \n        int bits = b64variant.decodeBase64Char(unescaped);\n        if (bits < 0) {\n            \n            if ((bits != Base64Variant.BASE64_VALUE_PADDING) || (index < 2)) {\n                throw reportInvalidBase64Char(b64variant, unescaped, index);\n            }\n        }\n        return bits;\n    }\n    \n    protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException {\n        return reportInvalidBase64Char(b64variant, ch, bindex, null);\n    }\n\n    \n    protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException {\n        String base;\n        if (ch <= INT_SPACE) {\n            base = String.format(\"Illegal white space character (code 0x%s) as character #%d of 4-char base64 unit: can only used between units\",\n                    Integer.toHexString(ch), (bindex+1));\n        } else if (b64variant.usesPaddingChar(ch)) {\n            base = \"Unexpected padding character ('\"+b64variant.getPaddingChar()+\"') as character #\"+(bindex+1)+\" of 4-char base64 unit: padding only legal as 3rd or 4th character\";\n        } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) {\n            \n            base = \"Illegal character (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n        } else {\n            base = \"Illegal character '\"+((char)ch)+\"' (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n        }\n        if (msg != null) {\n            base = base + \": \" + msg;\n        }\n        return new IllegalArgumentException(base);\n    }\n\n    \n    protected void _handleBase64MissingPadding(Base64Variant b64variant) throws IOException {\n        _reportError(b64variant.missingPaddingMessage());\n    }\n\n    \n\n    \n    protected Object _getSourceReference() {\n        if (JsonParser.Feature.INCLUDE_SOURCE_IN_LOCATION.enabledIn(_features)) {\n            return _ioContext.getSourceReference();\n        }\n        return null;\n    }\n\n    protected static int[] growArrayBy(int[] arr, int more) {\n        if (arr == null) {\n            return new int[more];\n        }\n        return Arrays.copyOf(arr, arr.length + more);\n    }\n    \n    \n\n    @Deprecated \n    protected void loadMoreGuaranteed() throws IOException {\n        if (!loadMore()) { _reportInvalidEOF(); }\n    }\n\n    @Deprecated \n    protected boolean loadMore() throws IOException { return false; }\n\n    \n    protected void _finishString() throws IOException { }\n}\n",
      "buggy_signatures": [
        "public Version version()",
        "public Object getCurrentValue()",
        "public void setCurrentValue(Object v)",
        "public JsonParser enable(Feature f)",
        "public JsonParser disable(Feature f)",
        "public JsonParser setFeatureMask(int newMask)",
        "public JsonParser overrideStdFeatures(int values, int mask)",
        "protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures)",
        "public String getCurrentName() throws IOException",
        "public void overrideCurrentName(String name)",
        "public void close() throws IOException",
        "public boolean isClosed()",
        "public JsonReadContext getParsingContext()",
        "public JsonLocation getTokenLocation()",
        "public JsonLocation getCurrentLocation()",
        "public boolean hasTextCharacters()",
        "public byte[] getBinaryValue(Base64Variant variant) throws IOException",
        "public long getTokenCharacterOffset()",
        "public int getTokenLineNr()",
        "public int getTokenColumnNr()",
        "protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException",
        "protected void _handleEOF() throws JsonParseException",
        "protected final int _eofAsNextChar() throws JsonParseException",
        "public ByteArrayBuilder _getByteArrayBuilder()",
        "protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen)",
        "protected final JsonToken resetInt(boolean negative, int intLen)",
        "protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen)",
        "protected final JsonToken resetAsNaN(String valueStr, double value)",
        "public boolean isNaN()",
        "public Number getNumberValue() throws IOException",
        "public NumberType getNumberType() throws IOException",
        "public int getIntValue() throws IOException",
        "public long getLongValue() throws IOException",
        "public BigInteger getBigIntegerValue() throws IOException",
        "public float getFloatValue() throws IOException",
        "public double getDoubleValue() throws IOException",
        "public BigDecimal getDecimalValue() throws IOException",
        "protected void _parseNumericValue(int expType) throws IOException",
        "protected int _parseIntValue() throws IOException",
        "private void _parseSlowFloat(int expType) throws IOException",
        "private void _parseSlowInt(int expType) throws IOException",
        "protected void _reportTooLongIntegral(int expType, String rawNum) throws IOException",
        "protected void convertNumberToInt() throws IOException",
        "protected void convertNumberToLong() throws IOException",
        "protected void convertNumberToBigInteger() throws IOException",
        "protected void convertNumberToDouble() throws IOException",
        "protected void convertNumberToBigDecimal() throws IOException",
        "protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException",
        "protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException",
        "protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException",
        "protected char _decodeEscaped() throws IOException",
        "protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException",
        "protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException",
        "protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException",
        "protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException",
        "protected void _handleBase64MissingPadding(Base64Variant b64variant) throws IOException",
        "protected Object _getSourceReference()",
        "protected static int[] growArrayBy(int[] arr, int more)",
        "protected void loadMoreGuaranteed() throws IOException",
        "protected boolean loadMore() throws IOException",
        "protected void _finishString() throws IOException"
      ],
      "fixed_signatures": [
        "public Version version()",
        "public Object getCurrentValue()",
        "public void setCurrentValue(Object v)",
        "public JsonParser enable(Feature f)",
        "public JsonParser disable(Feature f)",
        "public JsonParser setFeatureMask(int newMask)",
        "public JsonParser overrideStdFeatures(int values, int mask)",
        "protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures)",
        "public String getCurrentName() throws IOException",
        "public void overrideCurrentName(String name)",
        "public void close() throws IOException",
        "public boolean isClosed()",
        "public JsonReadContext getParsingContext()",
        "public JsonLocation getTokenLocation()",
        "public JsonLocation getCurrentLocation()",
        "public boolean hasTextCharacters()",
        "public byte[] getBinaryValue(Base64Variant variant) throws IOException",
        "public long getTokenCharacterOffset()",
        "public int getTokenLineNr()",
        "public int getTokenColumnNr()",
        "protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException",
        "protected void _handleEOF() throws JsonParseException",
        "protected final int _eofAsNextChar() throws JsonParseException",
        "public ByteArrayBuilder _getByteArrayBuilder()",
        "protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen)",
        "protected final JsonToken resetInt(boolean negative, int intLen)",
        "protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen)",
        "protected final JsonToken resetAsNaN(String valueStr, double value)",
        "public boolean isNaN()",
        "public Number getNumberValue() throws IOException",
        "public NumberType getNumberType() throws IOException",
        "public int getIntValue() throws IOException",
        "public long getLongValue() throws IOException",
        "public BigInteger getBigIntegerValue() throws IOException",
        "public float getFloatValue() throws IOException",
        "public double getDoubleValue() throws IOException",
        "public BigDecimal getDecimalValue() throws IOException",
        "protected void _parseNumericValue(int expType) throws IOException",
        "protected int _parseIntValue() throws IOException",
        "private void _parseSlowFloat(int expType) throws IOException",
        "private void _parseSlowInt(int expType) throws IOException",
        "protected void _reportTooLongIntegral(int expType, String rawNum) throws IOException",
        "protected void convertNumberToInt() throws IOException",
        "protected void convertNumberToLong() throws IOException",
        "protected void convertNumberToBigInteger() throws IOException",
        "protected void convertNumberToDouble() throws IOException",
        "protected void convertNumberToBigDecimal() throws IOException",
        "protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException",
        "protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException",
        "protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException",
        "protected char _decodeEscaped() throws IOException",
        "protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException",
        "protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException",
        "protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException",
        "protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException",
        "protected void _handleBase64MissingPadding(Base64Variant b64variant) throws IOException",
        "protected Object _getSourceReference()",
        "protected static int[] growArrayBy(int[] arr, int more)",
        "protected void loadMoreGuaranteed() throws IOException",
        "protected boolean loadMore() throws IOException",
        "protected void _finishString() throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  protected void _reportTooLongIntegral(int expType, String rawNum) throws IOException {\n  final String numDesc = _longIntegerDesc(rawNum);\n  _reportError(\"Numeric value (%s) out of range of %s\", numDesc,\n  (expType == NR_LONG) ? \"long\" : \"int\");\n  }",
          "fixed_method": "  protected void _reportTooLongIntegral(int expType, String rawNum) throws IOException {\n  if (expType == NR_INT) {\n  reportOverflowInt(rawNum);\n  } else {\n  reportOverflowLong(rawNum);\n  }\n  }",
          "diff": [
            "@@ -866,9 +866,11 @@",
            "     // @since 2.9.8\n",
            "     protected void _reportTooLongIntegral(int expType, String rawNum) throws IOException\n",
            "     {\n",
            "-        final String numDesc = _longIntegerDesc(rawNum);\n",
            "-        _reportError(\"Numeric value (%s) out of range of %s\", numDesc,\n",
            "-                (expType == NR_LONG) ? \"long\" : \"int\");\n",
            "+        if (expType == NR_INT) {\n",
            "+            reportOverflowInt(rawNum);\n",
            "+        } else {\n",
            "+            reportOverflowLong(rawNum);\n",
            "+        }\n",
            "     }\n",
            " \n",
            "     /*\n"
          ],
          "changed_lines": 8
        },
        {
          "buggy_method": "  protected void convertNumberToInt() throws IOException {\n  \n  if ((_numTypesValid & NR_LONG) != 0) {\n  \n  int result = (int) _numberLong;\n  if (((long) result) != _numberLong) {\n  _reportError(\"Numeric value (\"+getText()+\") out of range of int\");\n  }\n  _numberInt = result;\n  } else if ((_numTypesValid & NR_BIGINT) != 0) {\n  if (BI_MIN_INT.compareTo(_numberBigInt) > 0 \n  || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n  reportOverflowInt();\n  }\n  _numberInt = _numberBigInt.intValue();\n  } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n  \n  if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {\n  reportOverflowInt();\n  }\n  _numberInt = (int) _numberDouble;\n  } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n  if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 \n  || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n  reportOverflowInt();\n  }\n  _numberInt = _numberBigDecimal.intValue();\n  } else {\n  _throwInternal();\n  }\n  _numTypesValid |= NR_INT;\n  }",
          "fixed_method": "  protected void convertNumberToInt() throws IOException {\n  \n  if ((_numTypesValid & NR_LONG) != 0) {\n  \n  int result = (int) _numberLong;\n  if (((long) result) != _numberLong) {\n  reportOverflowInt(getText(), currentToken());\n  }\n  _numberInt = result;\n  } else if ((_numTypesValid & NR_BIGINT) != 0) {\n  if (BI_MIN_INT.compareTo(_numberBigInt) > 0 \n  || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n  reportOverflowInt();\n  }\n  _numberInt = _numberBigInt.intValue();\n  } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n  \n  if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {\n  reportOverflowInt();\n  }\n  _numberInt = (int) _numberDouble;\n  } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n  if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 \n  || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n  reportOverflowInt();\n  }\n  _numberInt = _numberBigDecimal.intValue();\n  } else {\n  _throwInternal();\n  }\n  _numTypesValid |= NR_INT;\n  }",
          "diff": [
            "@@ -884,7 +886,7 @@",
            "             // Let's verify it's lossless conversion by simple roundtrip\n",
            "             int result = (int) _numberLong;\n",
            "             if (((long) result) != _numberLong) {\n",
            "-                _reportError(\"Numeric value (\"+getText()+\") out of range of int\");\n",
            "+                reportOverflowInt(getText(), currentToken());\n",
            "             }\n",
            "             _numberInt = result;\n",
            "         } else if ((_numTypesValid & NR_BIGINT) != 0) {\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/core/base/ParserMinimalBase.java",
      "buggy_full_code": "package com.fasterxml.jackson.core.base;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.exc.InputCoercionException;\nimport com.fasterxml.jackson.core.io.JsonEOFException;\nimport com.fasterxml.jackson.core.io.NumberInput;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*; public abstract class ParserMinimalBase extends JsonParser { protected final static int INT_TAB = '\\t'; protected final static int INT_LF = '\\n'; protected final static int INT_CR = '\\r'; protected final static int INT_SPACE = 0x0020; protected final static int INT_LBRACKET = '['; protected final static int INT_RBRACKET = ']'; protected final static int INT_LCURLY = '{'; protected final static int INT_RCURLY = '}'; protected final static int INT_QUOTE = '\"'; protected final static int INT_APOS = '\\''; protected final static int INT_BACKSLASH = '\\\\'; protected final static int INT_SLASH = '/'; protected final static int INT_ASTERISK = '*'; protected final static int INT_COLON = ':'; protected final static int INT_COMMA = ','; protected final static int INT_HASH = '#'; protected final static int INT_0 = '0'; protected final static int INT_9 = '9'; protected final static int INT_MINUS = '-'; protected final static int INT_PLUS = '+'; protected final static int INT_PERIOD = '.'; protected final static int INT_e = 'e'; protected final static int INT_E = 'E'; protected final static char CHAR_NULL = '\\0'; protected final static byte[] NO_BYTES = new byte[0]; protected final static int[] NO_INTS = new int[0]; protected final static int NR_UNKNOWN = 0; protected final static int NR_INT = 0x0001; protected final static int NR_LONG = 0x0002; protected final static int NR_BIGINT = 0x0004; protected final static int NR_DOUBLE = 0x008; protected final static int NR_BIGDECIMAL = 0x0010; protected final static int NR_FLOAT = 0x020; protected final static BigInteger BI_MIN_INT = BigInteger.valueOf(Integer.MIN_VALUE); protected final static BigInteger BI_MAX_INT = BigInteger.valueOf(Integer.MAX_VALUE); protected final static BigInteger BI_MIN_LONG = BigInteger.valueOf(Long.MIN_VALUE); protected final static BigInteger BI_MAX_LONG = BigInteger.valueOf(Long.MAX_VALUE); protected final static BigDecimal BD_MIN_LONG = new BigDecimal(BI_MIN_LONG); protected final static BigDecimal BD_MAX_LONG = new BigDecimal(BI_MAX_LONG); protected final static BigDecimal BD_MIN_INT = new BigDecimal(BI_MIN_INT); protected final static BigDecimal BD_MAX_INT = new BigDecimal(BI_MAX_INT); protected final static long MIN_INT_L = (long) Integer.MIN_VALUE; protected final static long MAX_INT_L = (long) Integer.MAX_VALUE; protected final static double MIN_LONG_D = (double) Long.MIN_VALUE; protected final static double MAX_LONG_D = (double) Long.MAX_VALUE; protected final static double MIN_INT_D = (double) Integer.MIN_VALUE; protected final static double MAX_INT_D = (double) Integer.MAX_VALUE; protected final static int MAX_ERROR_TOKEN_LENGTH = 256; protected JsonToken _currToken; protected JsonToken _lastClearedToken; protected ParserMinimalBase() { }\n    protected ParserMinimalBase(int features) { super(features); }\n\n    \n    \n\n    \n\n    \n\n    \n    \n    \n    \n\n    \n\n    @Override public abstract JsonToken nextToken() throws IOException; @Override public JsonToken currentToken() { return _currToken; }\n    @Override public int currentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n    \n    @Override public JsonToken getCurrentToken() { return _currToken; }\n    @Override public int getCurrentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n\n    @Override public boolean hasCurrentToken() { return _currToken != null; }\n    @Override public boolean hasTokenId(int id) {\n        final JsonToken t = _currToken;\n        if (t == null) {\n            return (JsonTokenId.ID_NO_TOKEN == id);\n        }\n        return t.id() == id;\n    }\n\n    @Override public boolean hasToken(JsonToken t) {\n        return (_currToken == t);\n    }\n    \n    @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n    @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n    \n    @Override\n    public JsonToken nextValue() throws IOException {\n        \n        \n        JsonToken t = nextToken();\n        if (t == JsonToken.FIELD_NAME) {\n            t = nextToken();\n        }\n        return t;\n    }\n\n    @Override\n    public JsonParser skipChildren() throws IOException {\n        if (_currToken != JsonToken.START_OBJECT\n            && _currToken != JsonToken.START_ARRAY) {\n            return this;\n        }\n        int open = 1;\n\n        \n        \n        while (true) {\n            JsonToken t = nextToken();\n            if (t == null) {\n                _handleEOF();\n                \n                return this;\n            }\n            if (t.isStructStart()) {\n                ++open;\n            } else if (t.isStructEnd()) {\n                if (--open == 0) {\n                    return this;\n                }\n                \n            } else if (t == JsonToken.NOT_AVAILABLE) {\n                \n                \n                _reportError(\"Not enough content available for `skipChildren()`: non-blocking parser? (%s)\",\n                            getClass().getName());\n            }\n        }\n    }\n\n    \n    protected abstract void _handleEOF() throws JsonParseException; @Override public abstract String getCurrentName() throws IOException; @Override public abstract void close() throws IOException; @Override public abstract boolean isClosed(); @Override public abstract JsonStreamContext getParsingContext(); @Override public void clearCurrentToken() {\n        if (_currToken != null) {\n            _lastClearedToken = _currToken;\n            _currToken = null;\n        }\n    }\n\n    @Override public JsonToken getLastClearedToken() { return _lastClearedToken; }\n\n    @Override public abstract void overrideCurrentName(String name); @Override public abstract String getText() throws IOException; @Override public abstract char[] getTextCharacters() throws IOException; @Override public abstract boolean hasTextCharacters(); @Override public abstract int getTextLength() throws IOException; @Override public abstract int getTextOffset() throws IOException; @Override public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException; @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException {\n        JsonToken t = _currToken;\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText().trim();\n                if (\"true\".equals(str)) {\n                    return true;\n                }\n                if (\"false\".equals(str)) {\n                    return false;\n                }\n                if (_hasTextualNull(str)) {\n                    return false;\n                }\n                break;\n            case ID_NUMBER_INT:\n                return getIntValue() != 0;\n            case ID_TRUE:\n                return true;\n            case ID_FALSE:\n            case ID_NULL:\n                return false;\n            case ID_EMBEDDED_OBJECT:\n                Object value = getEmbeddedObject();\n                if (value instanceof Boolean) {\n                    return (Boolean) value;\n                }\n                break;\n            default:\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public int getValueAsInt() throws IOException {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            return getIntValue();\n        }\n        return getValueAsInt(0);\n    }\n\n    @Override\n    public int getValueAsInt(int defaultValue) throws IOException {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            return getIntValue();\n        }\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText();\n                if (_hasTextualNull(str)) {\n                    return 0;\n                }\n                return NumberInput.parseAsInt(str, defaultValue);\n            case ID_TRUE:\n                return 1;\n            case ID_FALSE:\n                return 0;\n            case ID_NULL:\n                return 0;\n            case ID_EMBEDDED_OBJECT:\n                Object value = getEmbeddedObject();\n                if (value instanceof Number) {\n                    return ((Number) value).intValue();\n                }\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public long getValueAsLong() throws IOException {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            return getLongValue();\n        }\n        return getValueAsLong(0L);\n    }\n    \n    @Override\n    public long getValueAsLong(long defaultValue) throws IOException {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            return getLongValue();\n        }\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText();\n                if (_hasTextualNull(str)) {\n                    return 0L;\n                }\n                return NumberInput.parseAsLong(str, defaultValue);\n            case ID_TRUE:\n                return 1L;\n            case ID_FALSE:\n            case ID_NULL:\n                return 0L;\n            case ID_EMBEDDED_OBJECT:\n                Object value = getEmbeddedObject();\n                if (value instanceof Number) {\n                    return ((Number) value).longValue();\n                }\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public double getValueAsDouble(double defaultValue) throws IOException {\n        JsonToken t = _currToken;\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText();\n                if (_hasTextualNull(str)) {\n                    return 0L;\n                }\n                return NumberInput.parseAsDouble(str, defaultValue);\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return getDoubleValue();\n            case ID_TRUE:\n                return 1.0;\n            case ID_FALSE:\n            case ID_NULL:\n                return 0.0;\n            case ID_EMBEDDED_OBJECT:\n                Object value = this.getEmbeddedObject();\n                if (value instanceof Number) {\n                    return ((Number) value).doubleValue();\n                }\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public String getValueAsString() throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            return getText();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return getValueAsString(null);\n    }\n    \n    @Override\n    public String getValueAsString(String defaultValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            return getText();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) {\n            return defaultValue;\n        }\n        return getText();\n    }\n    \n    \n\n    \n    protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException {\n        try {\n            b64variant.decode(str, builder);\n        } catch (IllegalArgumentException e) {\n            _reportError(e.getMessage());\n        }\n    }\n\n    \n\n    \n    protected boolean _hasTextualNull(String value) { return \"null\".equals(value); }\n\n    \n\n    protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException {\n        String msg = String.format(\"Unexpected character (%s) in numeric value\", _getCharDesc(ch));\n        if (comment != null) {\n            msg += \": \"+comment;\n        }\n        _reportError(msg);\n    }\n\n    \n    protected void reportInvalidNumber(String msg) throws JsonParseException {\n        _reportError(\"Invalid numeric value: \"+msg);\n    }\n\n    \n    protected void reportOverflowInt() throws IOException {\n        reportOverflowInt(getText());\n    }\n\n    \n    protected void reportOverflowInt(String numDesc) throws IOException {\n        _reportError(String.format(\"Numeric value (%s) out of range of int (%d - %s)\",\n                _longIntegerDesc(numDesc), Integer.MIN_VALUE, Integer.MAX_VALUE));\n    }\n\n    \n\n    \n    protected void reportOverflowLong() throws IOException {\n        reportOverflowLong(getText());\n    }\n\n    \n    protected void reportOverflowLong(String numDesc) throws IOException {\n        _reportError(String.format(\"Numeric value (%s) out of range of long (%d - %s)\",\n                _longIntegerDesc(numDesc), Long.MIN_VALUE, Long.MAX_VALUE));\n    }\n\n    \n\n    \n    protected void _reportInputCoercion(String msg, JsonToken inputType, Class<?> targetType) throws InputCoercionException {\n        throw new InputCoercionException(this, msg, inputType, targetType);\n    }\n\n    \n    protected String _longIntegerDesc(String rawNum) {\n        int rawLen = rawNum.length();\n        if (rawLen < 1000) {\n            return rawNum;\n        }\n        if (rawNum.startsWith(\"-\")) {\n            rawLen -= 1;\n        }\n        return String.format(\"[Integer with %d digits]\", rawLen);\n    }\n\n    \n    protected String _longNumberDesc(String rawNum) {\n        int rawLen = rawNum.length();\n        if (rawLen < 1000) {\n            return rawNum;\n        }\n        if (rawNum.startsWith(\"-\")) {\n            rawLen -= 1;\n        }\n        return String.format(\"[number with %d characters]\", rawLen);\n    }\n\n    protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException {\n        if (ch < 0) { \n            _reportInvalidEOF();\n        }\n        String msg = String.format(\"Unexpected character (%s)\", _getCharDesc(ch));\n        if (comment != null) {\n            msg += \": \"+comment;\n        }\n        _reportError(msg);\n    }\n\n    protected void _reportInvalidEOF() throws JsonParseException {\n        _reportInvalidEOF(\" in \"+_currToken, _currToken);\n    }\n\n    \n    protected void _reportInvalidEOFInValue(JsonToken type) throws JsonParseException {\n        String msg;\n        if (type == JsonToken.VALUE_STRING) {\n            msg = \" in a String value\";\n        } else if ((type == JsonToken.VALUE_NUMBER_INT)\n                || (type == JsonToken.VALUE_NUMBER_FLOAT)) {\n            msg = \" in a Number value\";\n        } else {\n            msg = \" in a value\";\n        }\n        _reportInvalidEOF(msg, type);\n    }\n\n    \n    protected void _reportInvalidEOF(String msg, JsonToken currToken) throws JsonParseException {\n        throw new JsonEOFException(this, currToken, \"Unexpected end-of-input\"+msg);\n    }\n\n    \n    @Deprecated \n    protected void _reportInvalidEOFInValue() throws JsonParseException {\n        _reportInvalidEOF(\" in a value\");\n    }\n    \n    \n    @Deprecated \n    protected void _reportInvalidEOF(String msg) throws JsonParseException {\n        throw new JsonEOFException(this, null, \"Unexpected end-of-input\"+msg);\n    }\n    \n    protected void _reportMissingRootWS(int ch) throws JsonParseException {\n        _reportUnexpectedChar(ch, \"Expected space separating root-level values\");\n    }\n    \n    protected void _throwInvalidSpace(int i) throws JsonParseException {\n        char c = (char) i;\n        String msg = \"Illegal character (\"+_getCharDesc(c)+\"): only regular white space (\\\\r, \\\\n, \\\\t) is allowed between tokens\";\n        _reportError(msg);\n    }\n\n    \n\n    protected final static String _getCharDesc(int ch) {\n        char c = (char) ch;\n        if (Character.isISOControl(c)) {\n            return \"(CTRL-CHAR, code \"+ch+\")\";\n        }\n        if (ch > 255) {\n            return \"'\"+c+\"' (code \"+ch+\" / 0x\"+Integer.toHexString(ch)+\")\";\n        }\n        return \"'\"+c+\"' (code \"+ch+\")\";\n    }\n\n    protected final void _reportError(String msg) throws JsonParseException {\n        throw _constructError(msg);\n    }\n\n    \n    protected final void _reportError(String msg, Object arg) throws JsonParseException {\n        throw _constructError(String.format(msg, arg));\n    }\n\n    \n    protected final void _reportError(String msg, Object arg1, Object arg2) throws JsonParseException {\n        throw _constructError(String.format(msg, arg1, arg2));\n    }\n\n    protected final void _wrapError(String msg, Throwable t) throws JsonParseException {\n        throw _constructError(msg, t);\n    }\n\n    protected final void _throwInternal() {\n        VersionUtil.throwInternal();\n    }\n\n    protected final JsonParseException _constructError(String msg, Throwable t) {\n        return new JsonParseException(this, msg, t);\n    }\n\n    protected static byte[] _asciiBytes(String str) {\n        byte[] b = new byte[str.length()];\n        for (int i = 0, len = str.length(); i < len; ++i) {\n            b[i] = (byte) str.charAt(i);\n        }\n        return b;\n    }\n\n    protected static String _ascii(byte[] b) {\n        try {\n            return new String(b, \"US-ASCII\");\n        } catch (IOException e) { \n            throw new RuntimeException(e);\n        }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.core.base;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.exc.InputCoercionException;\nimport com.fasterxml.jackson.core.io.JsonEOFException;\nimport com.fasterxml.jackson.core.io.NumberInput;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*; public abstract class ParserMinimalBase extends JsonParser { protected final static int INT_TAB = '\\t'; protected final static int INT_LF = '\\n'; protected final static int INT_CR = '\\r'; protected final static int INT_SPACE = 0x0020; protected final static int INT_LBRACKET = '['; protected final static int INT_RBRACKET = ']'; protected final static int INT_LCURLY = '{'; protected final static int INT_RCURLY = '}'; protected final static int INT_QUOTE = '\"'; protected final static int INT_APOS = '\\''; protected final static int INT_BACKSLASH = '\\\\'; protected final static int INT_SLASH = '/'; protected final static int INT_ASTERISK = '*'; protected final static int INT_COLON = ':'; protected final static int INT_COMMA = ','; protected final static int INT_HASH = '#'; protected final static int INT_0 = '0'; protected final static int INT_9 = '9'; protected final static int INT_MINUS = '-'; protected final static int INT_PLUS = '+'; protected final static int INT_PERIOD = '.'; protected final static int INT_e = 'e'; protected final static int INT_E = 'E'; protected final static char CHAR_NULL = '\\0'; protected final static byte[] NO_BYTES = new byte[0]; protected final static int[] NO_INTS = new int[0]; protected final static int NR_UNKNOWN = 0; protected final static int NR_INT = 0x0001; protected final static int NR_LONG = 0x0002; protected final static int NR_BIGINT = 0x0004; protected final static int NR_DOUBLE = 0x008; protected final static int NR_BIGDECIMAL = 0x0010; protected final static int NR_FLOAT = 0x020; protected final static BigInteger BI_MIN_INT = BigInteger.valueOf(Integer.MIN_VALUE); protected final static BigInteger BI_MAX_INT = BigInteger.valueOf(Integer.MAX_VALUE); protected final static BigInteger BI_MIN_LONG = BigInteger.valueOf(Long.MIN_VALUE); protected final static BigInteger BI_MAX_LONG = BigInteger.valueOf(Long.MAX_VALUE); protected final static BigDecimal BD_MIN_LONG = new BigDecimal(BI_MIN_LONG); protected final static BigDecimal BD_MAX_LONG = new BigDecimal(BI_MAX_LONG); protected final static BigDecimal BD_MIN_INT = new BigDecimal(BI_MIN_INT); protected final static BigDecimal BD_MAX_INT = new BigDecimal(BI_MAX_INT); protected final static long MIN_INT_L = (long) Integer.MIN_VALUE; protected final static long MAX_INT_L = (long) Integer.MAX_VALUE; protected final static double MIN_LONG_D = (double) Long.MIN_VALUE; protected final static double MAX_LONG_D = (double) Long.MAX_VALUE; protected final static double MIN_INT_D = (double) Integer.MIN_VALUE; protected final static double MAX_INT_D = (double) Integer.MAX_VALUE; protected final static int MAX_ERROR_TOKEN_LENGTH = 256; protected JsonToken _currToken; protected JsonToken _lastClearedToken; protected ParserMinimalBase() { }\n    protected ParserMinimalBase(int features) { super(features); }\n\n    \n    \n\n    \n\n    \n\n    \n    \n    \n    \n\n    \n\n    @Override public abstract JsonToken nextToken() throws IOException; @Override public JsonToken currentToken() { return _currToken; }\n    @Override public int currentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n    \n    @Override public JsonToken getCurrentToken() { return _currToken; }\n    @Override public int getCurrentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n\n    @Override public boolean hasCurrentToken() { return _currToken != null; }\n    @Override public boolean hasTokenId(int id) {\n        final JsonToken t = _currToken;\n        if (t == null) {\n            return (JsonTokenId.ID_NO_TOKEN == id);\n        }\n        return t.id() == id;\n    }\n\n    @Override public boolean hasToken(JsonToken t) {\n        return (_currToken == t);\n    }\n    \n    @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n    @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n    \n    @Override\n    public JsonToken nextValue() throws IOException {\n        \n        \n        JsonToken t = nextToken();\n        if (t == JsonToken.FIELD_NAME) {\n            t = nextToken();\n        }\n        return t;\n    }\n\n    @Override\n    public JsonParser skipChildren() throws IOException {\n        if (_currToken != JsonToken.START_OBJECT\n            && _currToken != JsonToken.START_ARRAY) {\n            return this;\n        }\n        int open = 1;\n\n        \n        \n        while (true) {\n            JsonToken t = nextToken();\n            if (t == null) {\n                _handleEOF();\n                \n                return this;\n            }\n            if (t.isStructStart()) {\n                ++open;\n            } else if (t.isStructEnd()) {\n                if (--open == 0) {\n                    return this;\n                }\n                \n            } else if (t == JsonToken.NOT_AVAILABLE) {\n                \n                \n                _reportError(\"Not enough content available for `skipChildren()`: non-blocking parser? (%s)\",\n                            getClass().getName());\n            }\n        }\n    }\n\n    \n    protected abstract void _handleEOF() throws JsonParseException; @Override public abstract String getCurrentName() throws IOException; @Override public abstract void close() throws IOException; @Override public abstract boolean isClosed(); @Override public abstract JsonStreamContext getParsingContext(); @Override public void clearCurrentToken() {\n        if (_currToken != null) {\n            _lastClearedToken = _currToken;\n            _currToken = null;\n        }\n    }\n\n    @Override public JsonToken getLastClearedToken() { return _lastClearedToken; }\n\n    @Override public abstract void overrideCurrentName(String name); @Override public abstract String getText() throws IOException; @Override public abstract char[] getTextCharacters() throws IOException; @Override public abstract boolean hasTextCharacters(); @Override public abstract int getTextLength() throws IOException; @Override public abstract int getTextOffset() throws IOException; @Override public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException; @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException {\n        JsonToken t = _currToken;\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText().trim();\n                if (\"true\".equals(str)) {\n                    return true;\n                }\n                if (\"false\".equals(str)) {\n                    return false;\n                }\n                if (_hasTextualNull(str)) {\n                    return false;\n                }\n                break;\n            case ID_NUMBER_INT:\n                return getIntValue() != 0;\n            case ID_TRUE:\n                return true;\n            case ID_FALSE:\n            case ID_NULL:\n                return false;\n            case ID_EMBEDDED_OBJECT:\n                Object value = getEmbeddedObject();\n                if (value instanceof Boolean) {\n                    return (Boolean) value;\n                }\n                break;\n            default:\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public int getValueAsInt() throws IOException {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            return getIntValue();\n        }\n        return getValueAsInt(0);\n    }\n\n    @Override\n    public int getValueAsInt(int defaultValue) throws IOException {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            return getIntValue();\n        }\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText();\n                if (_hasTextualNull(str)) {\n                    return 0;\n                }\n                return NumberInput.parseAsInt(str, defaultValue);\n            case ID_TRUE:\n                return 1;\n            case ID_FALSE:\n                return 0;\n            case ID_NULL:\n                return 0;\n            case ID_EMBEDDED_OBJECT:\n                Object value = getEmbeddedObject();\n                if (value instanceof Number) {\n                    return ((Number) value).intValue();\n                }\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public long getValueAsLong() throws IOException {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            return getLongValue();\n        }\n        return getValueAsLong(0L);\n    }\n    \n    @Override\n    public long getValueAsLong(long defaultValue) throws IOException {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            return getLongValue();\n        }\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText();\n                if (_hasTextualNull(str)) {\n                    return 0L;\n                }\n                return NumberInput.parseAsLong(str, defaultValue);\n            case ID_TRUE:\n                return 1L;\n            case ID_FALSE:\n            case ID_NULL:\n                return 0L;\n            case ID_EMBEDDED_OBJECT:\n                Object value = getEmbeddedObject();\n                if (value instanceof Number) {\n                    return ((Number) value).longValue();\n                }\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public double getValueAsDouble(double defaultValue) throws IOException {\n        JsonToken t = _currToken;\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText();\n                if (_hasTextualNull(str)) {\n                    return 0L;\n                }\n                return NumberInput.parseAsDouble(str, defaultValue);\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return getDoubleValue();\n            case ID_TRUE:\n                return 1.0;\n            case ID_FALSE:\n            case ID_NULL:\n                return 0.0;\n            case ID_EMBEDDED_OBJECT:\n                Object value = this.getEmbeddedObject();\n                if (value instanceof Number) {\n                    return ((Number) value).doubleValue();\n                }\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public String getValueAsString() throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            return getText();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return getValueAsString(null);\n    }\n    \n    @Override\n    public String getValueAsString(String defaultValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            return getText();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) {\n            return defaultValue;\n        }\n        return getText();\n    }\n    \n    \n\n    \n    protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException {\n        try {\n            b64variant.decode(str, builder);\n        } catch (IllegalArgumentException e) {\n            _reportError(e.getMessage());\n        }\n    }\n\n    \n\n    \n    protected boolean _hasTextualNull(String value) { return \"null\".equals(value); }\n\n    \n\n    protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException {\n        String msg = String.format(\"Unexpected character (%s) in numeric value\", _getCharDesc(ch));\n        if (comment != null) {\n            msg += \": \"+comment;\n        }\n        _reportError(msg);\n    }\n\n    \n    protected void reportInvalidNumber(String msg) throws JsonParseException {\n        _reportError(\"Invalid numeric value: \"+msg);\n    }\n\n    \n    protected void reportOverflowInt() throws IOException {\n        reportOverflowInt(getText());\n    }\n\n    \n    protected void reportOverflowInt(String numDesc) throws IOException {\n        reportOverflowInt(numDesc, JsonToken.VALUE_NUMBER_INT);\n    }\n\n    \n    protected void reportOverflowInt(String numDesc, JsonToken inputType) throws IOException {\n        _reportInputCoercion(String.format(\"Numeric value (%s) out of range of int (%d - %s)\",\n                _longIntegerDesc(numDesc), Integer.MIN_VALUE, Integer.MAX_VALUE),\n                inputType, Integer.TYPE);\n    }\n\n    \n    protected void reportOverflowLong() throws IOException {\n        reportOverflowLong(getText());\n    }\n\n    \n    protected void reportOverflowLong(String numDesc) throws IOException {\n        reportOverflowLong(numDesc, JsonToken.VALUE_NUMBER_INT);\n    }\n\n    \n    protected void reportOverflowLong(String numDesc, JsonToken inputType) throws IOException {\n        _reportInputCoercion(String.format(\"Numeric value (%s) out of range of long (%d - %s)\",\n                _longIntegerDesc(numDesc), Long.MIN_VALUE, Long.MAX_VALUE),\n                inputType, Long.TYPE);\n    }\n\n    \n    protected void _reportInputCoercion(String msg, JsonToken inputType, Class<?> targetType) throws InputCoercionException {\n        throw new InputCoercionException(this, msg, inputType, targetType);\n    }\n\n    \n    protected String _longIntegerDesc(String rawNum) {\n        int rawLen = rawNum.length();\n        if (rawLen < 1000) {\n            return rawNum;\n        }\n        if (rawNum.startsWith(\"-\")) {\n            rawLen -= 1;\n        }\n        return String.format(\"[Integer with %d digits]\", rawLen);\n    }\n\n    \n    protected String _longNumberDesc(String rawNum) {\n        int rawLen = rawNum.length();\n        if (rawLen < 1000) {\n            return rawNum;\n        }\n        if (rawNum.startsWith(\"-\")) {\n            rawLen -= 1;\n        }\n        return String.format(\"[number with %d characters]\", rawLen);\n    }\n\n    protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException {\n        if (ch < 0) { \n            _reportInvalidEOF();\n        }\n        String msg = String.format(\"Unexpected character (%s)\", _getCharDesc(ch));\n        if (comment != null) {\n            msg += \": \"+comment;\n        }\n        _reportError(msg);\n    }\n\n    protected void _reportInvalidEOF() throws JsonParseException {\n        _reportInvalidEOF(\" in \"+_currToken, _currToken);\n    }\n\n    \n    protected void _reportInvalidEOFInValue(JsonToken type) throws JsonParseException {\n        String msg;\n        if (type == JsonToken.VALUE_STRING) {\n            msg = \" in a String value\";\n        } else if ((type == JsonToken.VALUE_NUMBER_INT)\n                || (type == JsonToken.VALUE_NUMBER_FLOAT)) {\n            msg = \" in a Number value\";\n        } else {\n            msg = \" in a value\";\n        }\n        _reportInvalidEOF(msg, type);\n    }\n\n    \n    protected void _reportInvalidEOF(String msg, JsonToken currToken) throws JsonParseException {\n        throw new JsonEOFException(this, currToken, \"Unexpected end-of-input\"+msg);\n    }\n\n    \n    @Deprecated \n    protected void _reportInvalidEOFInValue() throws JsonParseException {\n        _reportInvalidEOF(\" in a value\");\n    }\n    \n    \n    @Deprecated \n    protected void _reportInvalidEOF(String msg) throws JsonParseException {\n        throw new JsonEOFException(this, null, \"Unexpected end-of-input\"+msg);\n    }\n    \n    protected void _reportMissingRootWS(int ch) throws JsonParseException {\n        _reportUnexpectedChar(ch, \"Expected space separating root-level values\");\n    }\n    \n    protected void _throwInvalidSpace(int i) throws JsonParseException {\n        char c = (char) i;\n        String msg = \"Illegal character (\"+_getCharDesc(c)+\"): only regular white space (\\\\r, \\\\n, \\\\t) is allowed between tokens\";\n        _reportError(msg);\n    }\n\n    \n\n    protected final static String _getCharDesc(int ch) {\n        char c = (char) ch;\n        if (Character.isISOControl(c)) {\n            return \"(CTRL-CHAR, code \"+ch+\")\";\n        }\n        if (ch > 255) {\n            return \"'\"+c+\"' (code \"+ch+\" / 0x\"+Integer.toHexString(ch)+\")\";\n        }\n        return \"'\"+c+\"' (code \"+ch+\")\";\n    }\n\n    protected final void _reportError(String msg) throws JsonParseException {\n        throw _constructError(msg);\n    }\n\n    \n    protected final void _reportError(String msg, Object arg) throws JsonParseException {\n        throw _constructError(String.format(msg, arg));\n    }\n\n    \n    protected final void _reportError(String msg, Object arg1, Object arg2) throws JsonParseException {\n        throw _constructError(String.format(msg, arg1, arg2));\n    }\n\n    protected final void _wrapError(String msg, Throwable t) throws JsonParseException {\n        throw _constructError(msg, t);\n    }\n\n    protected final void _throwInternal() {\n        VersionUtil.throwInternal();\n    }\n\n    protected final JsonParseException _constructError(String msg, Throwable t) {\n        return new JsonParseException(this, msg, t);\n    }\n\n    protected static byte[] _asciiBytes(String str) {\n        byte[] b = new byte[str.length()];\n        for (int i = 0, len = str.length(); i < len; ++i) {\n            b[i] = (byte) str.charAt(i);\n        }\n        return b;\n    }\n\n    protected static String _ascii(byte[] b) {\n        try {\n            return new String(b, \"US-ASCII\");\n        } catch (IOException e) { \n            throw new RuntimeException(e);\n        }\n    }\n}\n",
      "buggy_signatures": [
        "protected ParserMinimalBase(int features)",
        "public abstract JsonToken nextToken() throws IOException; @Override public JsonToken currentToken()",
        "public int currentTokenId()",
        "public JsonToken getCurrentToken()",
        "public int getCurrentTokenId()",
        "public boolean hasCurrentToken()",
        "public boolean hasTokenId(int id)",
        "public boolean hasToken(JsonToken t)",
        "public boolean isExpectedStartArrayToken()",
        "public boolean isExpectedStartObjectToken()",
        "public JsonToken nextValue() throws IOException",
        "public JsonParser skipChildren() throws IOException",
        "protected abstract void _handleEOF() throws JsonParseException; @Override public abstract String getCurrentName() throws IOException; @Override public abstract void close() throws IOException; @Override public abstract boolean isClosed(); @Override public abstract JsonStreamContext getParsingContext(); @Override public void clearCurrentToken()",
        "public JsonToken getLastClearedToken()",
        "public abstract void overrideCurrentName(String name); @Override public abstract String getText() throws IOException; @Override public abstract char[] getTextCharacters() throws IOException; @Override public abstract boolean hasTextCharacters(); @Override public abstract int getTextLength() throws IOException; @Override public abstract int getTextOffset() throws IOException; @Override public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException; @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException",
        "public int getValueAsInt() throws IOException",
        "public int getValueAsInt(int defaultValue) throws IOException",
        "public long getValueAsLong() throws IOException",
        "public long getValueAsLong(long defaultValue) throws IOException",
        "public double getValueAsDouble(double defaultValue) throws IOException",
        "public String getValueAsString() throws IOException",
        "public String getValueAsString(String defaultValue) throws IOException",
        "protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException",
        "protected boolean _hasTextualNull(String value)",
        "protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException",
        "protected void reportInvalidNumber(String msg) throws JsonParseException",
        "protected void reportOverflowInt() throws IOException",
        "protected void reportOverflowInt(String numDesc) throws IOException",
        "protected void reportOverflowLong() throws IOException",
        "protected void reportOverflowLong(String numDesc) throws IOException",
        "protected void _reportInputCoercion(String msg, JsonToken inputType, Class<?> targetType) throws InputCoercionException",
        "protected String _longIntegerDesc(String rawNum)",
        "protected String _longNumberDesc(String rawNum)",
        "protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException",
        "protected void _reportInvalidEOF() throws JsonParseException",
        "protected void _reportInvalidEOFInValue(JsonToken type) throws JsonParseException",
        "protected void _reportInvalidEOF(String msg, JsonToken currToken) throws JsonParseException",
        "protected void _reportInvalidEOFInValue() throws JsonParseException",
        "protected void _reportInvalidEOF(String msg) throws JsonParseException",
        "protected void _reportMissingRootWS(int ch) throws JsonParseException",
        "protected void _throwInvalidSpace(int i) throws JsonParseException",
        "protected final static String _getCharDesc(int ch)",
        "protected final void _reportError(String msg) throws JsonParseException",
        "protected final void _reportError(String msg, Object arg) throws JsonParseException",
        "protected final void _reportError(String msg, Object arg1, Object arg2) throws JsonParseException",
        "protected final void _wrapError(String msg, Throwable t) throws JsonParseException",
        "protected final void _throwInternal()",
        "protected final JsonParseException _constructError(String msg, Throwable t)",
        "protected static byte[] _asciiBytes(String str)",
        "protected static String _ascii(byte[] b)"
      ],
      "fixed_signatures": [
        "protected ParserMinimalBase(int features)",
        "public abstract JsonToken nextToken() throws IOException; @Override public JsonToken currentToken()",
        "public int currentTokenId()",
        "public JsonToken getCurrentToken()",
        "public int getCurrentTokenId()",
        "public boolean hasCurrentToken()",
        "public boolean hasTokenId(int id)",
        "public boolean hasToken(JsonToken t)",
        "public boolean isExpectedStartArrayToken()",
        "public boolean isExpectedStartObjectToken()",
        "public JsonToken nextValue() throws IOException",
        "public JsonParser skipChildren() throws IOException",
        "protected abstract void _handleEOF() throws JsonParseException; @Override public abstract String getCurrentName() throws IOException; @Override public abstract void close() throws IOException; @Override public abstract boolean isClosed(); @Override public abstract JsonStreamContext getParsingContext(); @Override public void clearCurrentToken()",
        "public JsonToken getLastClearedToken()",
        "public abstract void overrideCurrentName(String name); @Override public abstract String getText() throws IOException; @Override public abstract char[] getTextCharacters() throws IOException; @Override public abstract boolean hasTextCharacters(); @Override public abstract int getTextLength() throws IOException; @Override public abstract int getTextOffset() throws IOException; @Override public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException; @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException",
        "public int getValueAsInt() throws IOException",
        "public int getValueAsInt(int defaultValue) throws IOException",
        "public long getValueAsLong() throws IOException",
        "public long getValueAsLong(long defaultValue) throws IOException",
        "public double getValueAsDouble(double defaultValue) throws IOException",
        "public String getValueAsString() throws IOException",
        "public String getValueAsString(String defaultValue) throws IOException",
        "protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException",
        "protected boolean _hasTextualNull(String value)",
        "protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException",
        "protected void reportInvalidNumber(String msg) throws JsonParseException",
        "protected void reportOverflowInt() throws IOException",
        "protected void reportOverflowInt(String numDesc) throws IOException",
        "protected void reportOverflowInt(String numDesc, JsonToken inputType) throws IOException",
        "protected void reportOverflowLong() throws IOException",
        "protected void reportOverflowLong(String numDesc) throws IOException",
        "protected void reportOverflowLong(String numDesc, JsonToken inputType) throws IOException",
        "protected void _reportInputCoercion(String msg, JsonToken inputType, Class<?> targetType) throws InputCoercionException",
        "protected String _longIntegerDesc(String rawNum)",
        "protected String _longNumberDesc(String rawNum)",
        "protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException",
        "protected void _reportInvalidEOF() throws JsonParseException",
        "protected void _reportInvalidEOFInValue(JsonToken type) throws JsonParseException",
        "protected void _reportInvalidEOF(String msg, JsonToken currToken) throws JsonParseException",
        "protected void _reportInvalidEOFInValue() throws JsonParseException",
        "protected void _reportInvalidEOF(String msg) throws JsonParseException",
        "protected void _reportMissingRootWS(int ch) throws JsonParseException",
        "protected void _throwInvalidSpace(int i) throws JsonParseException",
        "protected final static String _getCharDesc(int ch)",
        "protected final void _reportError(String msg) throws JsonParseException",
        "protected final void _reportError(String msg, Object arg) throws JsonParseException",
        "protected final void _reportError(String msg, Object arg1, Object arg2) throws JsonParseException",
        "protected final void _wrapError(String msg, Throwable t) throws JsonParseException",
        "protected final void _throwInternal()",
        "protected final JsonParseException _constructError(String msg, Throwable t)",
        "protected static byte[] _asciiBytes(String str)",
        "protected static String _ascii(byte[] b)"
      ],
      "methods": [
        {
          "buggy_method": "  protected void reportOverflowInt(String numDesc) throws IOException {\n  _reportError(String.format(\"Numeric value (%s) out of range of int (%d - %s)\",\n  _longIntegerDesc(numDesc), Integer.MIN_VALUE, Integer.MAX_VALUE));\n  }",
          "fixed_method": "  protected void reportOverflowInt(String numDesc, JsonToken inputType) throws IOException {\n  _reportInputCoercion(String.format(\"Numeric value (%s) out of range of int (%d - %s)\",\n  _longIntegerDesc(numDesc), Integer.MIN_VALUE, Integer.MAX_VALUE),\n  inputType, Integer.TYPE);\n  }",
          "diff": [
            "@@ -562,11 +562,15 @@",
            " \n",
            "     // @since 2.10\n",
            "     protected void reportOverflowInt(String numDesc) throws IOException {\n",
            "-        _reportError(String.format(\"Numeric value (%s) out of range of int (%d - %s)\",\n",
            "-                _longIntegerDesc(numDesc), Integer.MIN_VALUE, Integer.MAX_VALUE));\n",
            "+        reportOverflowInt(numDesc, JsonToken.VALUE_NUMBER_INT);\n",
            "     }\n",
            " \n",
            "     // @since 2.10\n",
            "+    protected void reportOverflowInt(String numDesc, JsonToken inputType) throws IOException {\n",
            "+        _reportInputCoercion(String.format(\"Numeric value (%s) out of range of int (%d - %s)\",\n",
            "+                _longIntegerDesc(numDesc), Integer.MIN_VALUE, Integer.MAX_VALUE),\n",
            "+                inputType, Integer.TYPE);\n",
            "+    }\n",
            " \n",
            "     /**\n",
            "      * Method called to throw an exception for integral (not floating point) input\n"
          ],
          "changed_lines": 8
        },
        {
          "buggy_method": "  protected void reportOverflowLong(String numDesc) throws IOException {\n  _reportError(String.format(\"Numeric value (%s) out of range of long (%d - %s)\",\n  _longIntegerDesc(numDesc), Long.MIN_VALUE, Long.MAX_VALUE));\n  }",
          "fixed_method": "  protected void reportOverflowLong(String numDesc, JsonToken inputType) throws IOException {\n  _reportInputCoercion(String.format(\"Numeric value (%s) out of range of long (%d - %s)\",\n  _longIntegerDesc(numDesc), Long.MIN_VALUE, Long.MAX_VALUE),\n  inputType, Long.TYPE);\n  }",
          "diff": [
            "@@ -579,11 +583,15 @@",
            " \n",
            "     // @since 2.10\n",
            "     protected void reportOverflowLong(String numDesc) throws IOException {\n",
            "-        _reportError(String.format(\"Numeric value (%s) out of range of long (%d - %s)\",\n",
            "-                _longIntegerDesc(numDesc), Long.MIN_VALUE, Long.MAX_VALUE));\n",
            "+        reportOverflowLong(numDesc, JsonToken.VALUE_NUMBER_INT);\n",
            "     }\n",
            " \n",
            "     // @since 2.10\n",
            "+    protected void reportOverflowLong(String numDesc, JsonToken inputType) throws IOException {\n",
            "+        _reportInputCoercion(String.format(\"Numeric value (%s) out of range of long (%d - %s)\",\n",
            "+                _longIntegerDesc(numDesc), Long.MIN_VALUE, Long.MAX_VALUE),\n",
            "+                inputType, Long.TYPE);\n",
            "+    }\n",
            " \n",
            "     /**\n",
            "      * @since 2.10\n"
          ],
          "changed_lines": 8
        }
      ]
    }
  ]
}
