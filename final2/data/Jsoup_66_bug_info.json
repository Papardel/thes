{
  "bug_id": "66",
  "failed_tests": {
    "org.jsoup.nodes.ElementTest": [
      {
        "methodName": "testNextElementSiblingAfterClone",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "        assertEquals(cloneExpect, cloneNextElementSibling.text());",
        "test_source": "  public void testNextElementSiblingAfterClone() {\n  // via https://github.com/jhy/jsoup/issues/951\n  String html = \"<!DOCTYPE html><html lang=\\\"en\\\"><head></head><body><div>Initial element</div></body></html>\";\n  String expectedText = \"New element\";\n  String cloneExpect = \"New element in clone\";\n\n  Document original = Jsoup.parse(html);\n  Document clone = original.clone();\n\n  Element originalElement = original.body().child(0);\n  originalElement.after(\"<div>\" + expectedText + \"</div>\");\n  Element originalNextElementSibling = originalElement.nextElementSibling();\n  Element originalNextSibling = (Element) originalElement.nextSibling();\n  assertEquals(expectedText, originalNextElementSibling.text());\n  assertEquals(expectedText, originalNextSibling.text());\n\n  Element cloneElement = clone.body().child(0);\n  cloneElement.after(\"<div>\" + cloneExpect + \"</div>\");\n  Element cloneNextElementSibling = cloneElement.nextElementSibling();\n  Element cloneNextSibling = (Element) cloneElement.nextSibling();\n  assertEquals(cloneExpect, cloneNextElementSibling.text());\n  assertEquals(cloneExpect, cloneNextSibling.text());\n  }",
        "stack": [
          "ElementTest.testNextElementSiblingAfterClone line 1235"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/nodes/Element.java",
      "buggy_full_code": "package org.jsoup.nodes;\n\nimport org.jsoup.helper.ChangeNotifyingArrayList;\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.parser.ParseSettings;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.parser.Tag;\nimport org.jsoup.select.Collector;\nimport org.jsoup.select.Elements;\nimport org.jsoup.select.Evaluator;\nimport org.jsoup.select.NodeTraversor;\nimport org.jsoup.select.NodeVisitor;\nimport org.jsoup.select.QueryParser;\nimport org.jsoup.select.Selector;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\n\nimport static org.jsoup.internal.Normalizer.normalize; public class Element extends Node { private static final List<Node> EMPTY_NODES = Collections.emptyList(); private static final Pattern classSplit = Pattern.compile(\"\\\\s+\"); private Tag tag; private WeakReference<List<Element>> shadowChildrenRef; List<Node> childNodes; private Attributes attributes; private String baseUri; public Element(String tag) {\n        this(Tag.valueOf(tag), \"\", new Attributes());\n    }\n\n    \n    public Element(Tag tag, String baseUri, Attributes attributes) {\n        Validate.notNull(tag);\n        Validate.notNull(baseUri);\n        childNodes = EMPTY_NODES;\n        this.baseUri = baseUri;\n        this.attributes = attributes;\n        this.tag = tag;\n    }\n    \n    \n    public Element(Tag tag, String baseUri) {\n        this(tag, baseUri, null);\n    }\n\n    protected List<Node> ensureChildNodes() {\n        if (childNodes == EMPTY_NODES) {\n            childNodes = new NodeList(4);\n        }\n        return childNodes;\n    }\n\n    @Override\n    protected boolean hasAttributes() {\n        return attributes != null;\n    }\n\n    @Override\n    public Attributes attributes() {\n        if (!hasAttributes())\n            attributes = new Attributes();\n        return attributes;\n    }\n\n    @Override\n    public String baseUri() {\n        return baseUri;\n    }\n\n    @Override\n    protected void doSetBaseUri(String baseUri) {\n        this.baseUri = baseUri;\n    }\n\n    @Override\n    public int childNodeSize() {\n        return childNodes.size();\n    }\n\n    @Override\n    public String nodeName() {\n        return tag.getName();\n    }\n\n    \n    public String tagName() {\n        return tag.getName();\n    }\n\n    \n    public Element tagName(String tagName) {\n        Validate.notEmpty(tagName, \"Tag name must not be empty.\");\n        tag = Tag.valueOf(tagName, ParseSettings.preserveCase); \n        return this;\n    }\n\n    \n    public Tag tag() {\n        return tag;\n    }\n    \n    \n    public boolean isBlock() {\n        return tag.isBlock();\n    }\n\n    \n    public String id() {\n        return attributes().getIgnoreCase(\"id\");\n    }\n\n    \n    public Element attr(String attributeKey, String attributeValue) {\n        super.attr(attributeKey, attributeValue);\n        return this;\n    }\n    \n    \n    public Element attr(String attributeKey, boolean attributeValue) {\n        attributes().put(attributeKey, attributeValue);\n        return this;\n    }\n\n    \n    public Map<String, String> dataset() {\n        return attributes().dataset();\n    }\n\n    @Override\n    public final Element parent() {\n        return (Element) parentNode;\n    }\n\n    \n    public Elements parents() {\n        Elements parents = new Elements();\n        accumulateParents(this, parents);\n        return parents;\n    }\n\n    private static void accumulateParents(Element el, Elements parents) {\n        Element parent = el.parent();\n        if (parent != null && !parent.tagName().equals(\"#root\")) {\n            parents.add(parent);\n            accumulateParents(parent, parents);\n        }\n    }\n\n    \n    public Element child(int index) {\n        return childElementsList().get(index);\n    }\n\n    \n    public Elements children() {\n        return new Elements(childElementsList());\n    }\n\n    \n    private List<Element> childElementsList() {\n        List<Element> children;\n        if (shadowChildrenRef == null || (children = shadowChildrenRef.get()) == null) {\n            final int size = childNodes.size();\n            children = new ArrayList<>(size);\n            \n            for (int i = 0; i < size; i++) {\n                final Node node = childNodes.get(i);\n                if (node instanceof Element)\n                    children.add((Element) node);\n            }\n            shadowChildrenRef = new WeakReference<>(children);\n        }\n        return children;\n    }\n\n    \n    @Override\n    void nodelistChanged() {\n        super.nodelistChanged();\n        shadowChildrenRef = null;\n    }\n\n    \n    public List<TextNode> textNodes() {\n        List<TextNode> textNodes = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof TextNode)\n                textNodes.add((TextNode) node);\n        }\n        return Collections.unmodifiableList(textNodes);\n    }\n\n    \n    public List<DataNode> dataNodes() {\n        List<DataNode> dataNodes = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof DataNode)\n                dataNodes.add((DataNode) node);\n        }\n        return Collections.unmodifiableList(dataNodes);\n    }\n\n    \n    public Elements select(String cssQuery) {\n        return Selector.select(cssQuery, this);\n    }\n\n    \n    public Element selectFirst(String cssQuery) {\n        return Selector.selectFirst(cssQuery, this);\n    }\n\n    \n    public boolean is(String cssQuery) {\n        return is(QueryParser.parse(cssQuery));\n    }\n\n    \n    public boolean is(Evaluator evaluator) {\n        return evaluator.matches((Element)this.root(), this);\n    }\n    \n    \n    public Element appendChild(Node child) {\n        Validate.notNull(child);\n\n        \n        reparentChild(child);\n        ensureChildNodes();\n        childNodes.add(child);\n        child.setSiblingIndex(childNodes.size() - 1);\n        return this;\n    }\n\n    \n    public Element appendTo(Element parent) {\n        Validate.notNull(parent);\n        parent.appendChild(this);\n        return this;\n    }\n\n    \n    public Element prependChild(Node child) {\n        Validate.notNull(child);\n        \n        addChildren(0, child);\n        return this;\n    }\n\n\n    \n    public Element insertChildren(int index, Collection<? extends Node> children) {\n        Validate.notNull(children, \"Children collection to be inserted must not be null.\");\n        int currentSize = childNodeSize();\n        if (index < 0) index += currentSize +1; \n        Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n\n        ArrayList<Node> nodes = new ArrayList<>(children);\n        Node[] nodeArray = nodes.toArray(new Node[nodes.size()]);\n        addChildren(index, nodeArray);\n        return this;\n    }\n\n    \n    public Element insertChildren(int index, Node... children) {\n        Validate.notNull(children, \"Children collection to be inserted must not be null.\");\n        int currentSize = childNodeSize();\n        if (index < 0) index += currentSize +1; \n        Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n\n        addChildren(index, children);\n        return this;\n    }\n    \n    \n    public Element appendElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName), baseUri());\n        appendChild(child);\n        return child;\n    }\n    \n    \n    public Element prependElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName), baseUri());\n        prependChild(child);\n        return child;\n    }\n    \n    \n    public Element appendText(String text) {\n        Validate.notNull(text);\n        TextNode node = new TextNode(text);\n        appendChild(node);\n        return this;\n    }\n    \n    \n    public Element prependText(String text) {\n        Validate.notNull(text);\n        TextNode node = new TextNode(text);\n        prependChild(node);\n        return this;\n    }\n    \n    \n    public Element append(String html) {\n        Validate.notNull(html);\n\n        List<Node> nodes = Parser.parseFragment(html, this, baseUri());\n        addChildren(nodes.toArray(new Node[nodes.size()]));\n        return this;\n    }\n    \n    \n    public Element prepend(String html) {\n        Validate.notNull(html);\n        \n        List<Node> nodes = Parser.parseFragment(html, this, baseUri());\n        addChildren(0, nodes.toArray(new Node[nodes.size()]));\n        return this;\n    }\n\n    \n    @Override\n    public Element before(String html) {\n        return (Element) super.before(html);\n    }\n\n    \n    @Override\n    public Element before(Node node) {\n        return (Element) super.before(node);\n    }\n\n    \n    @Override\n    public Element after(String html) {\n        return (Element) super.after(html);\n    }\n\n    \n    @Override\n    public Element after(Node node) {\n        return (Element) super.after(node);\n    }\n\n    \n    public Element empty() {\n        childNodes.clear();\n        return this;\n    }\n\n    \n    @Override\n    public Element wrap(String html) {\n        return (Element) super.wrap(html);\n    }\n\n    \n    public String cssSelector() {\n        if (id().length() > 0)\n            return \"#\" + id();\n\n        \n        String tagName = tagName().replace(':', '|');\n        StringBuilder selector = new StringBuilder(tagName);\n        String classes = StringUtil.join(classNames(), \".\");\n        if (classes.length() > 0)\n            selector.append('.').append(classes);\n\n        if (parent() == null || parent() instanceof Document) \n            return selector.toString();\n\n        selector.insert(0, \" > \");\n        if (parent().select(selector.toString()).size() > 1)\n            selector.append(String.format(\n                \":nth-child(%d)\", elementSiblingIndex() + 1));\n\n        return parent().cssSelector() + selector.toString();\n    }\n\n    \n    public Elements siblingElements() {\n        if (parentNode == null)\n            return new Elements(0);\n\n        List<Element> elements = parent().childElementsList();\n        Elements siblings = new Elements(elements.size() - 1);\n        for (Element el: elements)\n            if (el != this)\n                siblings.add(el);\n        return siblings;\n    }\n\n    \n    public Element nextElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().childElementsList();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }\n\n    \n    public Element previousElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().childElementsList();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }\n\n    \n    public Element firstElementSibling() {\n        \n        List<Element> siblings = parent().childElementsList();\n        return siblings.size() > 1 ? siblings.get(0) : null;\n    }\n    \n    \n    public int elementSiblingIndex() {\n       if (parent() == null) return 0;\n       return indexInList(this, parent().childElementsList());\n    }\n\n    \n    public Element lastElementSibling() {\n        List<Element> siblings = parent().childElementsList();\n        return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;\n    }\n\n    private static <E extends Element> int indexInList(Element search, List<E> elements) {\n        for (int i = 0; i < elements.size(); i++) {\n            if (elements.get(i) == search)\n                return i;\n        }\n        return 0;\n    }\n\n    \n\n    \n    public Elements getElementsByTag(String tagName) {\n        Validate.notEmpty(tagName);\n        tagName = normalize(tagName);\n\n        return Collector.collect(new Evaluator.Tag(tagName), this);\n    }\n\n    \n    public Element getElementById(String id) {\n        Validate.notEmpty(id);\n        \n        Elements elements = Collector.collect(new Evaluator.Id(id), this);\n        if (elements.size() > 0)\n            return elements.get(0);\n        else\n            return null;\n    }\n\n    \n    public Elements getElementsByClass(String className) {\n        Validate.notEmpty(className);\n\n        return Collector.collect(new Evaluator.Class(className), this);\n    }\n\n    \n    public Elements getElementsByAttribute(String key) {\n        Validate.notEmpty(key);\n        key = key.trim();\n\n        return Collector.collect(new Evaluator.Attribute(key), this);\n    }\n\n    \n    public Elements getElementsByAttributeStarting(String keyPrefix) {\n        Validate.notEmpty(keyPrefix);\n        keyPrefix = keyPrefix.trim();\n\n        return Collector.collect(new Evaluator.AttributeStarting(keyPrefix), this);\n    }\n\n    \n    public Elements getElementsByAttributeValue(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValue(key, value), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueNot(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) {\n        return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) {\n        return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueContaining(String key, String match) {\n        return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this);\n    }\n    \n    \n    public Elements getElementsByAttributeValueMatching(String key, Pattern pattern) {\n        return Collector.collect(new Evaluator.AttributeWithValueMatching(key, pattern), this);\n        \n    }\n    \n    \n    public Elements getElementsByAttributeValueMatching(String key, String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsByAttributeValueMatching(key, pattern);\n    }\n    \n    \n    public Elements getElementsByIndexLessThan(int index) {\n        return Collector.collect(new Evaluator.IndexLessThan(index), this);\n    }\n    \n    \n    public Elements getElementsByIndexGreaterThan(int index) {\n        return Collector.collect(new Evaluator.IndexGreaterThan(index), this);\n    }\n    \n    \n    public Elements getElementsByIndexEquals(int index) {\n        return Collector.collect(new Evaluator.IndexEquals(index), this);\n    }\n    \n    \n    public Elements getElementsContainingText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsText(searchText), this);\n    }\n    \n    \n    public Elements getElementsContainingOwnText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsOwnText(searchText), this);\n    }\n    \n    \n    public Elements getElementsMatchingText(Pattern pattern) {\n        return Collector.collect(new Evaluator.Matches(pattern), this);\n    }\n    \n    \n    public Elements getElementsMatchingText(String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsMatchingText(pattern);\n    }\n    \n    \n    public Elements getElementsMatchingOwnText(Pattern pattern) {\n        return Collector.collect(new Evaluator.MatchesOwn(pattern), this);\n    }\n    \n    \n    public Elements getElementsMatchingOwnText(String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsMatchingOwnText(pattern);\n    }\n    \n    \n    public Elements getAllElements() {\n        return Collector.collect(new Evaluator.AllElements(), this);\n    }\n\n    \n    public String text() {\n        final StringBuilder accum = new StringBuilder();\n        NodeTraversor.traverse(new NodeVisitor() {\n            public void head(Node node, int depth) {\n                if (node instanceof TextNode) {\n                    TextNode textNode = (TextNode) node;\n                    appendNormalisedText(accum, textNode);\n                } else if (node instanceof Element) {\n                    Element element = (Element) node;\n                    if (accum.length() > 0 &&\n                        (element.isBlock() || element.tag.getName().equals(\"br\")) &&\n                        !TextNode.lastCharIsWhitespace(accum))\n                        accum.append(' ');\n                }\n            }\n\n            public void tail(Node node, int depth) {\n            }\n        }, this);\n        return accum.toString().trim();\n    }\n\n    \n    public String ownText() {\n        StringBuilder sb = new StringBuilder();\n        ownText(sb);\n        return sb.toString().trim();\n    }\n\n    private void ownText(StringBuilder accum) {\n        for (Node child : childNodes) {\n            if (child instanceof TextNode) {\n                TextNode textNode = (TextNode) child;\n                appendNormalisedText(accum, textNode);\n            } else if (child instanceof Element) {\n                appendWhitespaceIfBr((Element) child, accum);\n            }\n        }\n    }\n\n    private static void appendNormalisedText(StringBuilder accum, TextNode textNode) {\n        String text = textNode.getWholeText();\n\n        if (preserveWhitespace(textNode.parentNode))\n            accum.append(text);\n        else\n            StringUtil.appendNormalisedWhitespace(accum, text, TextNode.lastCharIsWhitespace(accum));\n    }\n\n    private static void appendWhitespaceIfBr(Element element, StringBuilder accum) {\n        if (element.tag.getName().equals(\"br\") && !TextNode.lastCharIsWhitespace(accum))\n            accum.append(\" \");\n    }\n\n    static boolean preserveWhitespace(Node node) {\n        \n        if (node != null && node instanceof Element) {\n            Element element = (Element) node;\n            return element.tag.preserveWhitespace() ||\n                element.parent() != null && element.parent().tag.preserveWhitespace();\n        }\n        return false;\n    }\n\n    \n    public Element text(String text) {\n        Validate.notNull(text);\n\n        empty();\n        TextNode textNode = new TextNode(text);\n        appendChild(textNode);\n\n        return this;\n    }\n\n    \n    public boolean hasText() {\n        for (Node child: childNodes) {\n            if (child instanceof TextNode) {\n                TextNode textNode = (TextNode) child;\n                if (!textNode.isBlank())\n                    return true;\n            } else if (child instanceof Element) {\n                Element el = (Element) child;\n                if (el.hasText())\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    \n    public String data() {\n        StringBuilder sb = new StringBuilder();\n\n        for (Node childNode : childNodes) {\n            if (childNode instanceof DataNode) {\n                DataNode data = (DataNode) childNode;\n                sb.append(data.getWholeData());\n            } else if (childNode instanceof Comment) {\n                Comment comment = (Comment) childNode;\n                sb.append(comment.getData());\n            } else if (childNode instanceof Element) {\n                Element element = (Element) childNode;\n                String elementData = element.data();\n                sb.append(elementData);\n            }\n        }\n        return sb.toString();\n    }   \n\n    \n    public String className() {\n        return attr(\"class\").trim();\n    }\n\n    \n    public Set<String> classNames() {\n    \tString[] names = classSplit.split(className());\n    \tSet<String> classNames = new LinkedHashSet<>(Arrays.asList(names));\n    \tclassNames.remove(\"\"); \n\n        return classNames;\n    }\n\n    \n    public Element classNames(Set<String> classNames) {\n        Validate.notNull(classNames);\n        attributes().put(\"class\", StringUtil.join(classNames, \" \"));\n        return this;\n    }\n\n    \n    \n    public boolean hasClass(String className) {\n        final String classAttr = attributes().getIgnoreCase(\"class\");\n        final int len = classAttr.length();\n        final int wantLen = className.length();\n\n        if (len == 0 || len < wantLen) {\n            return false;\n        }\n\n        \n        if (len == wantLen) {\n            return className.equalsIgnoreCase(classAttr);\n        }\n\n        \n        boolean inClass = false;\n        int start = 0;\n        for (int i = 0; i < len; i++) {\n            if (Character.isWhitespace(classAttr.charAt(i))) {\n                if (inClass) {\n                    \n                    if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                        return true;\n                    }\n                    inClass = false;\n                }\n            } else {\n                if (!inClass) {\n                    \n                    inClass = true;\n                    start = i;\n                }\n            }\n        }\n\n        \n        if (inClass && len - start == wantLen) {\n            return classAttr.regionMatches(true, start, className, 0, wantLen);\n        }\n\n        return false;\n    }\n\n    \n    public Element addClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        classes.add(className);\n        classNames(classes);\n\n        return this;\n    }\n\n    \n    public Element removeClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        classes.remove(className);\n        classNames(classes);\n\n        return this;\n    }\n\n    \n    public Element toggleClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        if (classes.contains(className))\n            classes.remove(className);\n        else\n            classes.add(className);\n        classNames(classes);\n\n        return this;\n    }\n    \n    \n    public String val() {\n        if (tagName().equals(\"textarea\"))\n            return text();\n        else\n            return attr(\"value\");\n    }\n    \n    \n    public Element val(String value) {\n        if (tagName().equals(\"textarea\"))\n            text(value);\n        else\n            attr(\"value\", value);\n        return this;\n    }\n\n    void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException {\n        if (out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline())) {\n            if (accum instanceof StringBuilder) {\n                if (((StringBuilder) accum).length() > 0)\n                    indent(accum, depth, out);\n            } else {\n                indent(accum, depth, out);\n            }\n        }\n        accum.append('<').append(tagName());\n        if (attributes != null) attributes.html(accum, out);\n\n        \n        if (childNodes.isEmpty() && tag.isSelfClosing()) {\n            if (out.syntax() == Document.OutputSettings.Syntax.html && tag.isEmpty())\n                accum.append('>');\n            else\n                accum.append(\" />\"); \n        }\n        else\n            accum.append('>');\n    }\n\n\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        if (!(childNodes.isEmpty() && tag.isSelfClosing())) {\n            if (out.prettyPrint() && (!childNodes.isEmpty() && (\n                    tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode))))\n            )))\n                indent(accum, depth, out);\n            accum.append(\"</\").append(tagName()).append('>');\n        }\n    }\n\n    \n    public String html() {\n        StringBuilder accum = StringUtil.stringBuilder();\n        html(accum);\n        return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();\n    }\n\n    private void html(StringBuilder accum) {\n        for (Node node : childNodes)\n            node.outerHtml(accum);\n    }\n\n    \n    @Override\n    public <T extends Appendable> T html(T appendable) {\n        for (Node node : childNodes)\n            node.outerHtml(appendable);\n\n        return appendable;\n    }\n    \n    \n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n\tpublic String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public Element clone() {\n        return (Element) super.clone();\n    }\n\n    @Override\n    protected Element doClone(Node parent) {\n        Element clone = (Element) super.doClone(parent);\n        clone.attributes = attributes != null ? attributes.clone() : null;\n        clone.baseUri = baseUri;\n        clone.childNodes = new NodeList(childNodes.size());\n        clone.childNodes.addAll(childNodes);\n\n        return clone;\n    }\n\n    private final class NodeList extends ChangeNotifyingArrayList<Node> { NodeList(int initialCapacity) {\n            super(initialCapacity);\n        }\n\n        public void onContentsChanged() {\n            nodelistChanged();\n        }\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.nodes;\n\nimport org.jsoup.helper.ChangeNotifyingArrayList;\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.parser.ParseSettings;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.parser.Tag;\nimport org.jsoup.select.Collector;\nimport org.jsoup.select.Elements;\nimport org.jsoup.select.Evaluator;\nimport org.jsoup.select.NodeTraversor;\nimport org.jsoup.select.NodeVisitor;\nimport org.jsoup.select.QueryParser;\nimport org.jsoup.select.Selector;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\n\nimport static org.jsoup.internal.Normalizer.normalize; public class Element extends Node { private static final List<Node> EMPTY_NODES = Collections.emptyList(); private static final Pattern classSplit = Pattern.compile(\"\\\\s+\"); private Tag tag; private WeakReference<List<Element>> shadowChildrenRef; List<Node> childNodes; private Attributes attributes; private String baseUri; public Element(String tag) {\n        this(Tag.valueOf(tag), \"\", new Attributes());\n    }\n\n    \n    public Element(Tag tag, String baseUri, Attributes attributes) {\n        Validate.notNull(tag);\n        Validate.notNull(baseUri);\n        childNodes = EMPTY_NODES;\n        this.baseUri = baseUri;\n        this.attributes = attributes;\n        this.tag = tag;\n    }\n    \n    \n    public Element(Tag tag, String baseUri) {\n        this(tag, baseUri, null);\n    }\n\n    protected List<Node> ensureChildNodes() {\n        if (childNodes == EMPTY_NODES) {\n            childNodes = new NodeList(this, 4);\n        }\n        return childNodes;\n    }\n\n    @Override\n    protected boolean hasAttributes() {\n        return attributes != null;\n    }\n\n    @Override\n    public Attributes attributes() {\n        if (!hasAttributes())\n            attributes = new Attributes();\n        return attributes;\n    }\n\n    @Override\n    public String baseUri() {\n        return baseUri;\n    }\n\n    @Override\n    protected void doSetBaseUri(String baseUri) {\n        this.baseUri = baseUri;\n    }\n\n    @Override\n    public int childNodeSize() {\n        return childNodes.size();\n    }\n\n    @Override\n    public String nodeName() {\n        return tag.getName();\n    }\n\n    \n    public String tagName() {\n        return tag.getName();\n    }\n\n    \n    public Element tagName(String tagName) {\n        Validate.notEmpty(tagName, \"Tag name must not be empty.\");\n        tag = Tag.valueOf(tagName, ParseSettings.preserveCase); \n        return this;\n    }\n\n    \n    public Tag tag() {\n        return tag;\n    }\n    \n    \n    public boolean isBlock() {\n        return tag.isBlock();\n    }\n\n    \n    public String id() {\n        return attributes().getIgnoreCase(\"id\");\n    }\n\n    \n    public Element attr(String attributeKey, String attributeValue) {\n        super.attr(attributeKey, attributeValue);\n        return this;\n    }\n    \n    \n    public Element attr(String attributeKey, boolean attributeValue) {\n        attributes().put(attributeKey, attributeValue);\n        return this;\n    }\n\n    \n    public Map<String, String> dataset() {\n        return attributes().dataset();\n    }\n\n    @Override\n    public final Element parent() {\n        return (Element) parentNode;\n    }\n\n    \n    public Elements parents() {\n        Elements parents = new Elements();\n        accumulateParents(this, parents);\n        return parents;\n    }\n\n    private static void accumulateParents(Element el, Elements parents) {\n        Element parent = el.parent();\n        if (parent != null && !parent.tagName().equals(\"#root\")) {\n            parents.add(parent);\n            accumulateParents(parent, parents);\n        }\n    }\n\n    \n    public Element child(int index) {\n        return childElementsList().get(index);\n    }\n\n    \n    public Elements children() {\n        return new Elements(childElementsList());\n    }\n\n    \n    private List<Element> childElementsList() {\n        List<Element> children;\n        if (shadowChildrenRef == null || (children = shadowChildrenRef.get()) == null) {\n            final int size = childNodes.size();\n            children = new ArrayList<>(size);\n            \n            for (int i = 0; i < size; i++) {\n                final Node node = childNodes.get(i);\n                if (node instanceof Element)\n                    children.add((Element) node);\n            }\n            shadowChildrenRef = new WeakReference<>(children);\n        }\n        return children;\n    }\n\n    \n    @Override\n    void nodelistChanged() {\n        super.nodelistChanged();\n        shadowChildrenRef = null;\n    }\n\n    \n    public List<TextNode> textNodes() {\n        List<TextNode> textNodes = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof TextNode)\n                textNodes.add((TextNode) node);\n        }\n        return Collections.unmodifiableList(textNodes);\n    }\n\n    \n    public List<DataNode> dataNodes() {\n        List<DataNode> dataNodes = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof DataNode)\n                dataNodes.add((DataNode) node);\n        }\n        return Collections.unmodifiableList(dataNodes);\n    }\n\n    \n    public Elements select(String cssQuery) {\n        return Selector.select(cssQuery, this);\n    }\n\n    \n    public Element selectFirst(String cssQuery) {\n        return Selector.selectFirst(cssQuery, this);\n    }\n\n    \n    public boolean is(String cssQuery) {\n        return is(QueryParser.parse(cssQuery));\n    }\n\n    \n    public boolean is(Evaluator evaluator) {\n        return evaluator.matches((Element)this.root(), this);\n    }\n    \n    \n    public Element appendChild(Node child) {\n        Validate.notNull(child);\n\n        \n        reparentChild(child);\n        ensureChildNodes();\n        childNodes.add(child);\n        child.setSiblingIndex(childNodes.size() - 1);\n        return this;\n    }\n\n    \n    public Element appendTo(Element parent) {\n        Validate.notNull(parent);\n        parent.appendChild(this);\n        return this;\n    }\n\n    \n    public Element prependChild(Node child) {\n        Validate.notNull(child);\n        \n        addChildren(0, child);\n        return this;\n    }\n\n\n    \n    public Element insertChildren(int index, Collection<? extends Node> children) {\n        Validate.notNull(children, \"Children collection to be inserted must not be null.\");\n        int currentSize = childNodeSize();\n        if (index < 0) index += currentSize +1; \n        Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n\n        ArrayList<Node> nodes = new ArrayList<>(children);\n        Node[] nodeArray = nodes.toArray(new Node[nodes.size()]);\n        addChildren(index, nodeArray);\n        return this;\n    }\n\n    \n    public Element insertChildren(int index, Node... children) {\n        Validate.notNull(children, \"Children collection to be inserted must not be null.\");\n        int currentSize = childNodeSize();\n        if (index < 0) index += currentSize +1; \n        Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n\n        addChildren(index, children);\n        return this;\n    }\n    \n    \n    public Element appendElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName), baseUri());\n        appendChild(child);\n        return child;\n    }\n    \n    \n    public Element prependElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName), baseUri());\n        prependChild(child);\n        return child;\n    }\n    \n    \n    public Element appendText(String text) {\n        Validate.notNull(text);\n        TextNode node = new TextNode(text);\n        appendChild(node);\n        return this;\n    }\n    \n    \n    public Element prependText(String text) {\n        Validate.notNull(text);\n        TextNode node = new TextNode(text);\n        prependChild(node);\n        return this;\n    }\n    \n    \n    public Element append(String html) {\n        Validate.notNull(html);\n\n        List<Node> nodes = Parser.parseFragment(html, this, baseUri());\n        addChildren(nodes.toArray(new Node[nodes.size()]));\n        return this;\n    }\n    \n    \n    public Element prepend(String html) {\n        Validate.notNull(html);\n        \n        List<Node> nodes = Parser.parseFragment(html, this, baseUri());\n        addChildren(0, nodes.toArray(new Node[nodes.size()]));\n        return this;\n    }\n\n    \n    @Override\n    public Element before(String html) {\n        return (Element) super.before(html);\n    }\n\n    \n    @Override\n    public Element before(Node node) {\n        return (Element) super.before(node);\n    }\n\n    \n    @Override\n    public Element after(String html) {\n        return (Element) super.after(html);\n    }\n\n    \n    @Override\n    public Element after(Node node) {\n        return (Element) super.after(node);\n    }\n\n    \n    public Element empty() {\n        childNodes.clear();\n        return this;\n    }\n\n    \n    @Override\n    public Element wrap(String html) {\n        return (Element) super.wrap(html);\n    }\n\n    \n    public String cssSelector() {\n        if (id().length() > 0)\n            return \"#\" + id();\n\n        \n        String tagName = tagName().replace(':', '|');\n        StringBuilder selector = new StringBuilder(tagName);\n        String classes = StringUtil.join(classNames(), \".\");\n        if (classes.length() > 0)\n            selector.append('.').append(classes);\n\n        if (parent() == null || parent() instanceof Document) \n            return selector.toString();\n\n        selector.insert(0, \" > \");\n        if (parent().select(selector.toString()).size() > 1)\n            selector.append(String.format(\n                \":nth-child(%d)\", elementSiblingIndex() + 1));\n\n        return parent().cssSelector() + selector.toString();\n    }\n\n    \n    public Elements siblingElements() {\n        if (parentNode == null)\n            return new Elements(0);\n\n        List<Element> elements = parent().childElementsList();\n        Elements siblings = new Elements(elements.size() - 1);\n        for (Element el: elements)\n            if (el != this)\n                siblings.add(el);\n        return siblings;\n    }\n\n    \n    public Element nextElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().childElementsList();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }\n\n    \n    public Element previousElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().childElementsList();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }\n\n    \n    public Element firstElementSibling() {\n        \n        List<Element> siblings = parent().childElementsList();\n        return siblings.size() > 1 ? siblings.get(0) : null;\n    }\n    \n    \n    public int elementSiblingIndex() {\n       if (parent() == null) return 0;\n       return indexInList(this, parent().childElementsList());\n    }\n\n    \n    public Element lastElementSibling() {\n        List<Element> siblings = parent().childElementsList();\n        return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;\n    }\n\n    private static <E extends Element> int indexInList(Element search, List<E> elements) {\n        for (int i = 0; i < elements.size(); i++) {\n            if (elements.get(i) == search)\n                return i;\n        }\n        return 0;\n    }\n\n    \n\n    \n    public Elements getElementsByTag(String tagName) {\n        Validate.notEmpty(tagName);\n        tagName = normalize(tagName);\n\n        return Collector.collect(new Evaluator.Tag(tagName), this);\n    }\n\n    \n    public Element getElementById(String id) {\n        Validate.notEmpty(id);\n        \n        Elements elements = Collector.collect(new Evaluator.Id(id), this);\n        if (elements.size() > 0)\n            return elements.get(0);\n        else\n            return null;\n    }\n\n    \n    public Elements getElementsByClass(String className) {\n        Validate.notEmpty(className);\n\n        return Collector.collect(new Evaluator.Class(className), this);\n    }\n\n    \n    public Elements getElementsByAttribute(String key) {\n        Validate.notEmpty(key);\n        key = key.trim();\n\n        return Collector.collect(new Evaluator.Attribute(key), this);\n    }\n\n    \n    public Elements getElementsByAttributeStarting(String keyPrefix) {\n        Validate.notEmpty(keyPrefix);\n        keyPrefix = keyPrefix.trim();\n\n        return Collector.collect(new Evaluator.AttributeStarting(keyPrefix), this);\n    }\n\n    \n    public Elements getElementsByAttributeValue(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValue(key, value), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueNot(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) {\n        return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) {\n        return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueContaining(String key, String match) {\n        return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this);\n    }\n    \n    \n    public Elements getElementsByAttributeValueMatching(String key, Pattern pattern) {\n        return Collector.collect(new Evaluator.AttributeWithValueMatching(key, pattern), this);\n        \n    }\n    \n    \n    public Elements getElementsByAttributeValueMatching(String key, String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsByAttributeValueMatching(key, pattern);\n    }\n    \n    \n    public Elements getElementsByIndexLessThan(int index) {\n        return Collector.collect(new Evaluator.IndexLessThan(index), this);\n    }\n    \n    \n    public Elements getElementsByIndexGreaterThan(int index) {\n        return Collector.collect(new Evaluator.IndexGreaterThan(index), this);\n    }\n    \n    \n    public Elements getElementsByIndexEquals(int index) {\n        return Collector.collect(new Evaluator.IndexEquals(index), this);\n    }\n    \n    \n    public Elements getElementsContainingText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsText(searchText), this);\n    }\n    \n    \n    public Elements getElementsContainingOwnText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsOwnText(searchText), this);\n    }\n    \n    \n    public Elements getElementsMatchingText(Pattern pattern) {\n        return Collector.collect(new Evaluator.Matches(pattern), this);\n    }\n    \n    \n    public Elements getElementsMatchingText(String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsMatchingText(pattern);\n    }\n    \n    \n    public Elements getElementsMatchingOwnText(Pattern pattern) {\n        return Collector.collect(new Evaluator.MatchesOwn(pattern), this);\n    }\n    \n    \n    public Elements getElementsMatchingOwnText(String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsMatchingOwnText(pattern);\n    }\n    \n    \n    public Elements getAllElements() {\n        return Collector.collect(new Evaluator.AllElements(), this);\n    }\n\n    \n    public String text() {\n        final StringBuilder accum = new StringBuilder();\n        NodeTraversor.traverse(new NodeVisitor() {\n            public void head(Node node, int depth) {\n                if (node instanceof TextNode) {\n                    TextNode textNode = (TextNode) node;\n                    appendNormalisedText(accum, textNode);\n                } else if (node instanceof Element) {\n                    Element element = (Element) node;\n                    if (accum.length() > 0 &&\n                        (element.isBlock() || element.tag.getName().equals(\"br\")) &&\n                        !TextNode.lastCharIsWhitespace(accum))\n                        accum.append(' ');\n                }\n            }\n\n            public void tail(Node node, int depth) {\n            }\n        }, this);\n        return accum.toString().trim();\n    }\n\n    \n    public String ownText() {\n        StringBuilder sb = new StringBuilder();\n        ownText(sb);\n        return sb.toString().trim();\n    }\n\n    private void ownText(StringBuilder accum) {\n        for (Node child : childNodes) {\n            if (child instanceof TextNode) {\n                TextNode textNode = (TextNode) child;\n                appendNormalisedText(accum, textNode);\n            } else if (child instanceof Element) {\n                appendWhitespaceIfBr((Element) child, accum);\n            }\n        }\n    }\n\n    private static void appendNormalisedText(StringBuilder accum, TextNode textNode) {\n        String text = textNode.getWholeText();\n\n        if (preserveWhitespace(textNode.parentNode))\n            accum.append(text);\n        else\n            StringUtil.appendNormalisedWhitespace(accum, text, TextNode.lastCharIsWhitespace(accum));\n    }\n\n    private static void appendWhitespaceIfBr(Element element, StringBuilder accum) {\n        if (element.tag.getName().equals(\"br\") && !TextNode.lastCharIsWhitespace(accum))\n            accum.append(\" \");\n    }\n\n    static boolean preserveWhitespace(Node node) {\n        \n        if (node != null && node instanceof Element) {\n            Element element = (Element) node;\n            return element.tag.preserveWhitespace() ||\n                element.parent() != null && element.parent().tag.preserveWhitespace();\n        }\n        return false;\n    }\n\n    \n    public Element text(String text) {\n        Validate.notNull(text);\n\n        empty();\n        TextNode textNode = new TextNode(text);\n        appendChild(textNode);\n\n        return this;\n    }\n\n    \n    public boolean hasText() {\n        for (Node child: childNodes) {\n            if (child instanceof TextNode) {\n                TextNode textNode = (TextNode) child;\n                if (!textNode.isBlank())\n                    return true;\n            } else if (child instanceof Element) {\n                Element el = (Element) child;\n                if (el.hasText())\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    \n    public String data() {\n        StringBuilder sb = new StringBuilder();\n\n        for (Node childNode : childNodes) {\n            if (childNode instanceof DataNode) {\n                DataNode data = (DataNode) childNode;\n                sb.append(data.getWholeData());\n            } else if (childNode instanceof Comment) {\n                Comment comment = (Comment) childNode;\n                sb.append(comment.getData());\n            } else if (childNode instanceof Element) {\n                Element element = (Element) childNode;\n                String elementData = element.data();\n                sb.append(elementData);\n            }\n        }\n        return sb.toString();\n    }   \n\n    \n    public String className() {\n        return attr(\"class\").trim();\n    }\n\n    \n    public Set<String> classNames() {\n    \tString[] names = classSplit.split(className());\n    \tSet<String> classNames = new LinkedHashSet<>(Arrays.asList(names));\n    \tclassNames.remove(\"\"); \n\n        return classNames;\n    }\n\n    \n    public Element classNames(Set<String> classNames) {\n        Validate.notNull(classNames);\n        attributes().put(\"class\", StringUtil.join(classNames, \" \"));\n        return this;\n    }\n\n    \n    \n    public boolean hasClass(String className) {\n        final String classAttr = attributes().getIgnoreCase(\"class\");\n        final int len = classAttr.length();\n        final int wantLen = className.length();\n\n        if (len == 0 || len < wantLen) {\n            return false;\n        }\n\n        \n        if (len == wantLen) {\n            return className.equalsIgnoreCase(classAttr);\n        }\n\n        \n        boolean inClass = false;\n        int start = 0;\n        for (int i = 0; i < len; i++) {\n            if (Character.isWhitespace(classAttr.charAt(i))) {\n                if (inClass) {\n                    \n                    if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                        return true;\n                    }\n                    inClass = false;\n                }\n            } else {\n                if (!inClass) {\n                    \n                    inClass = true;\n                    start = i;\n                }\n            }\n        }\n\n        \n        if (inClass && len - start == wantLen) {\n            return classAttr.regionMatches(true, start, className, 0, wantLen);\n        }\n\n        return false;\n    }\n\n    \n    public Element addClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        classes.add(className);\n        classNames(classes);\n\n        return this;\n    }\n\n    \n    public Element removeClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        classes.remove(className);\n        classNames(classes);\n\n        return this;\n    }\n\n    \n    public Element toggleClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        if (classes.contains(className))\n            classes.remove(className);\n        else\n            classes.add(className);\n        classNames(classes);\n\n        return this;\n    }\n    \n    \n    public String val() {\n        if (tagName().equals(\"textarea\"))\n            return text();\n        else\n            return attr(\"value\");\n    }\n    \n    \n    public Element val(String value) {\n        if (tagName().equals(\"textarea\"))\n            text(value);\n        else\n            attr(\"value\", value);\n        return this;\n    }\n\n    void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException {\n        if (out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline())) {\n            if (accum instanceof StringBuilder) {\n                if (((StringBuilder) accum).length() > 0)\n                    indent(accum, depth, out);\n            } else {\n                indent(accum, depth, out);\n            }\n        }\n        accum.append('<').append(tagName());\n        if (attributes != null) attributes.html(accum, out);\n\n        \n        if (childNodes.isEmpty() && tag.isSelfClosing()) {\n            if (out.syntax() == Document.OutputSettings.Syntax.html && tag.isEmpty())\n                accum.append('>');\n            else\n                accum.append(\" />\"); \n        }\n        else\n            accum.append('>');\n    }\n\n\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        if (!(childNodes.isEmpty() && tag.isSelfClosing())) {\n            if (out.prettyPrint() && (!childNodes.isEmpty() && (\n                    tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode))))\n            )))\n                indent(accum, depth, out);\n            accum.append(\"</\").append(tagName()).append('>');\n        }\n    }\n\n    \n    public String html() {\n        StringBuilder accum = StringUtil.stringBuilder();\n        html(accum);\n        return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();\n    }\n\n    private void html(StringBuilder accum) {\n        for (Node node : childNodes)\n            node.outerHtml(accum);\n    }\n\n    \n    @Override\n    public <T extends Appendable> T html(T appendable) {\n        for (Node node : childNodes)\n            node.outerHtml(appendable);\n\n        return appendable;\n    }\n    \n    \n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n\tpublic String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public Element clone() {\n        return (Element) super.clone();\n    }\n\n    @Override\n    protected Element doClone(Node parent) {\n        Element clone = (Element) super.doClone(parent);\n        clone.attributes = attributes != null ? attributes.clone() : null;\n        clone.baseUri = baseUri;\n        clone.childNodes = new NodeList(clone, childNodes.size());\n        clone.childNodes.addAll(childNodes);\n\n        return clone;\n    }\n\n    private static final class NodeList extends ChangeNotifyingArrayList<Node> { private final Element owner; NodeList(Element owner, int initialCapacity) {\n            super(initialCapacity);\n            this.owner = owner;\n        }\n\n        public void onContentsChanged() {\n            owner.nodelistChanged();\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public Element(Tag tag, String baseUri, Attributes attributes)",
        "public Element(Tag tag, String baseUri)",
        "protected List<Node> ensureChildNodes()",
        "protected boolean hasAttributes()",
        "public Attributes attributes()",
        "public String baseUri()",
        "protected void doSetBaseUri(String baseUri)",
        "public int childNodeSize()",
        "public String nodeName()",
        "public String tagName()",
        "public Element tagName(String tagName)",
        "public Tag tag()",
        "public boolean isBlock()",
        "public String id()",
        "public Element attr(String attributeKey, String attributeValue)",
        "public Element attr(String attributeKey, boolean attributeValue)",
        "public Map<String, String> dataset()",
        "public final Element parent()",
        "public Elements parents()",
        "private static void accumulateParents(Element el, Elements parents)",
        "public Element child(int index)",
        "public Elements children()",
        "private List<Element> childElementsList()",
        "public List<TextNode> textNodes()",
        "public List<DataNode> dataNodes()",
        "public Elements select(String cssQuery)",
        "public Element selectFirst(String cssQuery)",
        "public boolean is(String cssQuery)",
        "public boolean is(Evaluator evaluator)",
        "public Element appendChild(Node child)",
        "public Element appendTo(Element parent)",
        "public Element prependChild(Node child)",
        "public Element insertChildren(int index, Collection<? extends Node> children)",
        "public Element insertChildren(int index, Node... children)",
        "public Element appendElement(String tagName)",
        "public Element prependElement(String tagName)",
        "public Element appendText(String text)",
        "public Element prependText(String text)",
        "public Element append(String html)",
        "public Element prepend(String html)",
        "public Element before(String html)",
        "public Element before(Node node)",
        "public Element after(String html)",
        "public Element after(Node node)",
        "public Element empty()",
        "public Element wrap(String html)",
        "public String cssSelector()",
        "public Elements siblingElements()",
        "public Element nextElementSibling()",
        "public Element previousElementSibling()",
        "public Element firstElementSibling()",
        "public int elementSiblingIndex()",
        "public Element lastElementSibling()",
        "private static <E extends Element> int indexInList(Element search, List<E> elements)",
        "public Elements getElementsByTag(String tagName)",
        "public Element getElementById(String id)",
        "public Elements getElementsByClass(String className)",
        "public Elements getElementsByAttribute(String key)",
        "public Elements getElementsByAttributeStarting(String keyPrefix)",
        "public Elements getElementsByAttributeValue(String key, String value)",
        "public Elements getElementsByAttributeValueNot(String key, String value)",
        "public Elements getElementsByAttributeValueStarting(String key, String valuePrefix)",
        "public Elements getElementsByAttributeValueEnding(String key, String valueSuffix)",
        "public Elements getElementsByAttributeValueContaining(String key, String match)",
        "public Elements getElementsByAttributeValueMatching(String key, Pattern pattern)",
        "public Elements getElementsByAttributeValueMatching(String key, String regex)",
        "public Elements getElementsByIndexLessThan(int index)",
        "public Elements getElementsByIndexGreaterThan(int index)",
        "public Elements getElementsByIndexEquals(int index)",
        "public Elements getElementsContainingText(String searchText)",
        "public Elements getElementsContainingOwnText(String searchText)",
        "public Elements getElementsMatchingText(Pattern pattern)",
        "public Elements getElementsMatchingText(String regex)",
        "public Elements getElementsMatchingOwnText(Pattern pattern)",
        "public Elements getElementsMatchingOwnText(String regex)",
        "public Elements getAllElements()",
        "public String text()",
        "public void head(Node node, int depth)",
        "public void tail(Node node, int depth)",
        "public String ownText()",
        "private void ownText(StringBuilder accum)",
        "private static void appendNormalisedText(StringBuilder accum, TextNode textNode)",
        "private static void appendWhitespaceIfBr(Element element, StringBuilder accum)",
        "static boolean preserveWhitespace(Node node)",
        "public Element text(String text)",
        "public boolean hasText()",
        "public String data()",
        "public String className()",
        "public Set<String> classNames()",
        "public Element classNames(Set<String> classNames)",
        "public boolean hasClass(String className)",
        "public Element addClass(String className)",
        "public Element removeClass(String className)",
        "public Element toggleClass(String className)",
        "public String val()",
        "public Element val(String value)",
        "public String html()",
        "private void html(StringBuilder accum)",
        "public <T extends Appendable> T html(T appendable)",
        "public Element html(String html)",
        "public String toString()",
        "public Element clone()",
        "protected Element doClone(Node parent)",
        "private final class NodeList extends ChangeNotifyingArrayList<Node> { NodeList(int initialCapacity)",
        "public void onContentsChanged()"
      ],
      "fixed_signatures": [
        "public Element(Tag tag, String baseUri, Attributes attributes)",
        "public Element(Tag tag, String baseUri)",
        "protected List<Node> ensureChildNodes()",
        "protected boolean hasAttributes()",
        "public Attributes attributes()",
        "public String baseUri()",
        "protected void doSetBaseUri(String baseUri)",
        "public int childNodeSize()",
        "public String nodeName()",
        "public String tagName()",
        "public Element tagName(String tagName)",
        "public Tag tag()",
        "public boolean isBlock()",
        "public String id()",
        "public Element attr(String attributeKey, String attributeValue)",
        "public Element attr(String attributeKey, boolean attributeValue)",
        "public Map<String, String> dataset()",
        "public final Element parent()",
        "public Elements parents()",
        "private static void accumulateParents(Element el, Elements parents)",
        "public Element child(int index)",
        "public Elements children()",
        "private List<Element> childElementsList()",
        "public List<TextNode> textNodes()",
        "public List<DataNode> dataNodes()",
        "public Elements select(String cssQuery)",
        "public Element selectFirst(String cssQuery)",
        "public boolean is(String cssQuery)",
        "public boolean is(Evaluator evaluator)",
        "public Element appendChild(Node child)",
        "public Element appendTo(Element parent)",
        "public Element prependChild(Node child)",
        "public Element insertChildren(int index, Collection<? extends Node> children)",
        "public Element insertChildren(int index, Node... children)",
        "public Element appendElement(String tagName)",
        "public Element prependElement(String tagName)",
        "public Element appendText(String text)",
        "public Element prependText(String text)",
        "public Element append(String html)",
        "public Element prepend(String html)",
        "public Element before(String html)",
        "public Element before(Node node)",
        "public Element after(String html)",
        "public Element after(Node node)",
        "public Element empty()",
        "public Element wrap(String html)",
        "public String cssSelector()",
        "public Elements siblingElements()",
        "public Element nextElementSibling()",
        "public Element previousElementSibling()",
        "public Element firstElementSibling()",
        "public int elementSiblingIndex()",
        "public Element lastElementSibling()",
        "private static <E extends Element> int indexInList(Element search, List<E> elements)",
        "public Elements getElementsByTag(String tagName)",
        "public Element getElementById(String id)",
        "public Elements getElementsByClass(String className)",
        "public Elements getElementsByAttribute(String key)",
        "public Elements getElementsByAttributeStarting(String keyPrefix)",
        "public Elements getElementsByAttributeValue(String key, String value)",
        "public Elements getElementsByAttributeValueNot(String key, String value)",
        "public Elements getElementsByAttributeValueStarting(String key, String valuePrefix)",
        "public Elements getElementsByAttributeValueEnding(String key, String valueSuffix)",
        "public Elements getElementsByAttributeValueContaining(String key, String match)",
        "public Elements getElementsByAttributeValueMatching(String key, Pattern pattern)",
        "public Elements getElementsByAttributeValueMatching(String key, String regex)",
        "public Elements getElementsByIndexLessThan(int index)",
        "public Elements getElementsByIndexGreaterThan(int index)",
        "public Elements getElementsByIndexEquals(int index)",
        "public Elements getElementsContainingText(String searchText)",
        "public Elements getElementsContainingOwnText(String searchText)",
        "public Elements getElementsMatchingText(Pattern pattern)",
        "public Elements getElementsMatchingText(String regex)",
        "public Elements getElementsMatchingOwnText(Pattern pattern)",
        "public Elements getElementsMatchingOwnText(String regex)",
        "public Elements getAllElements()",
        "public String text()",
        "public void head(Node node, int depth)",
        "public void tail(Node node, int depth)",
        "public String ownText()",
        "private void ownText(StringBuilder accum)",
        "private static void appendNormalisedText(StringBuilder accum, TextNode textNode)",
        "private static void appendWhitespaceIfBr(Element element, StringBuilder accum)",
        "static boolean preserveWhitespace(Node node)",
        "public Element text(String text)",
        "public boolean hasText()",
        "public String data()",
        "public String className()",
        "public Set<String> classNames()",
        "public Element classNames(Set<String> classNames)",
        "public boolean hasClass(String className)",
        "public Element addClass(String className)",
        "public Element removeClass(String className)",
        "public Element toggleClass(String className)",
        "public String val()",
        "public Element val(String value)",
        "public String html()",
        "private void html(StringBuilder accum)",
        "public <T extends Appendable> T html(T appendable)",
        "public Element html(String html)",
        "public String toString()",
        "public Element clone()",
        "protected Element doClone(Node parent)",
        "private static final class NodeList extends ChangeNotifyingArrayList<Node> { private final Element owner; NodeList(Element owner, int initialCapacity)",
        "public void onContentsChanged()"
      ],
      "methods": [
        {
          "buggy_method": "  protected List<Node> ensureChildNodes() {\n  if (childNodes == EMPTY_NODES) {\n  childNodes = new NodeList(4);\n  }\n  return childNodes;\n  }",
          "fixed_method": "  protected List<Node> ensureChildNodes() {\n  if (childNodes == EMPTY_NODES) {\n  childNodes = new NodeList(this, 4);\n  }\n  return childNodes;\n  }",
          "diff": [
            "@@ -86,7 +86,7 @@",
            " \n",
            "     protected List<Node> ensureChildNodes() {\n",
            "         if (childNodes == EMPTY_NODES) {\n",
            "-            childNodes = new NodeList(4);\n",
            "+            childNodes = new NodeList(this, 4);\n",
            "         }\n",
            "         return childNodes;\n",
            "     }\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  public void onContentsChanged() {\n  nodelistChanged();\n  }",
          "fixed_method": "  protected Element doClone(Node parent) {\n  Element clone = (Element) super.doClone(parent);\n  clone.attributes = attributes != null ? attributes.clone() : null;\n  clone.baseUri = baseUri;\n  clone.childNodes = new NodeList(clone, childNodes.size());\n  clone.childNodes.addAll(childNodes);\n\n  return clone;\n  }",
          "diff": [
            "@@ -1399,19 +1399,22 @@",
            "         Element clone = (Element) super.doClone(parent);\n",
            "         clone.attributes = attributes != null ? attributes.clone() : null;\n",
            "         clone.baseUri = baseUri;\n",
            "-        clone.childNodes = new NodeList(childNodes.size());\n",
            "+        clone.childNodes = new NodeList(clone, childNodes.size());\n",
            "         clone.childNodes.addAll(childNodes);\n",
            " \n",
            "         return clone;\n",
            "     }\n",
            " \n",
            "-    private final class NodeList extends ChangeNotifyingArrayList<Node> {\n",
            "-        NodeList(int initialCapacity) {\n",
            "+    private static final class NodeList extends ChangeNotifyingArrayList<Node> {\n",
            "+        private final Element owner;\n",
            "+\n",
            "+        NodeList(Element owner, int initialCapacity) {\n",
            "             super(initialCapacity);\n",
            "+            this.owner = owner;\n",
            "         }\n",
            " \n",
            "         public void onContentsChanged() {\n",
            "-            nodelistChanged();\n",
            "+            owner.nodelistChanged();\n",
            "         }\n",
            "     }\n",
            " }\n"
          ],
          "changed_lines": 11
        }
      ]
    }
  ]
}
