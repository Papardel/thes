{
  "bug_id": "73",
  "failed_tests": {
    "com.fasterxml.jackson.databind.deser.ReadOrWriteOnlyTest": [
      {
        "methodName": "testReadOnlyAndWriteOnly",
        "error": "com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException",
        "message": "Unrecognized field \"x\" (class com.fasterxml.jackson.databind.deser.ReadOrWriteOnlyTest$ReadXWriteY), not marked as ignorable (one known property: \"y\"])",
        "fail_line": "        ReadXWriteY result = MAPPER.readValue(\"{\\\"x\\\":5, \\\"y\\\":6}\", ReadXWriteY.class);",
        "test_source": "  public void testReadOnlyAndWriteOnly() throws Exception {\n  String json = MAPPER.writeValueAsString(new ReadXWriteY());\n  assertEquals(\"{\\\"x\\\":1}\", json);\n\n  ReadXWriteY result = MAPPER.readValue(\"{\\\"x\\\":5, \\\"y\\\":6}\", ReadXWriteY.class);\n  assertNotNull(result);\n  assertEquals(1, result.x);\n  assertEquals(6, result.y);\n  }",
        "stack": [
          "UnrecognizedPropertyException.from line 63, DeserializationContext.handleUnknownProperty line 834, StdDeserializer.handleUnknownProperty line 1093, BeanDeserializerBase.handleUnknownProperty line 1485, BeanDeserializerBase.handleUnknownVanilla line 1463, BeanDeserializer.vanillaDeserialize line 282, BeanDeserializer.deserialize line 140, ObjectMapper._readMapAndClose line 3798, ObjectMapper.readValue line 2842, ReadOrWriteOnlyTest.testReadOnlyAndWriteOnly line 66"
        ]
      },
      {
        "methodName": "testReadOnly935",
        "error": "com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException",
        "message": "Unrecognized field \"fullName\" (class com.fasterxml.jackson.databind.deser.ReadOrWriteOnlyTest$Pojo935), not marked as ignorable (2 known properties: \"lastName\", \"firstName\"])",
        "fail_line": "        Pojo935 result = MAPPER.readValue(json, Pojo935.class);",
        "test_source": "  public void testReadOnly935() throws Exception {\n  String json = MAPPER.writeValueAsString(new Pojo935());\n  Pojo935 result = MAPPER.readValue(json, Pojo935.class);\n  assertNotNull(result);\n  }",
        "stack": [
          "UnrecognizedPropertyException.from line 63, DeserializationContext.handleUnknownProperty line 834, StdDeserializer.handleUnknownProperty line 1093, BeanDeserializerBase.handleUnknownProperty line 1485, BeanDeserializerBase.handleUnknownVanilla line 1463, BeanDeserializer.vanillaDeserialize line 282, BeanDeserializer.deserialize line 140, ObjectMapper._readMapAndClose line 3798, ObjectMapper.readValue line 2842, ReadOrWriteOnlyTest.testReadOnly935 line 75"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.introspect;\n\nimport java.lang.reflect.Modifier;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.JsonAnySetter;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.util.BeanUtil;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\npublic class POJOPropertiesCollector { protected final MapperConfig<?> _config; protected final boolean _forSerialization; protected final boolean _stdBeanNaming; protected final JavaType _type; protected final AnnotatedClass _classDef; protected final VisibilityChecker<?> _visibilityChecker; protected final AnnotationIntrospector _annotationIntrospector; protected final String _mutatorPrefix; protected boolean _collected; protected LinkedHashMap<String, POJOPropertyBuilder> _properties; protected LinkedList<POJOPropertyBuilder> _creatorProperties ; protected LinkedList<AnnotatedMember> _anyGetters; protected LinkedList<AnnotatedMethod> _anySetters; protected LinkedList<AnnotatedMember> _anySetterField; protected LinkedList<AnnotatedMethod> _jsonValueGetters; protected HashSet<String> _ignoredPropertyNames; protected LinkedHashMap<Object, AnnotatedMember> _injectables; protected POJOPropertiesCollector(MapperConfig<?> config, boolean forSerialization, JavaType type, AnnotatedClass classDef, String mutatorPrefix) {\n        _config = config;\n        _stdBeanNaming = config.isEnabled(MapperFeature.USE_STD_BEAN_NAMING);\n        _forSerialization = forSerialization;\n        _type = type;\n        _classDef = classDef;\n        _mutatorPrefix = (mutatorPrefix == null) ? \"set\" : mutatorPrefix;\n        _annotationIntrospector = config.isAnnotationProcessingEnabled() ?\n                _config.getAnnotationIntrospector() : null;\n        if (_annotationIntrospector == null) {\n            _visibilityChecker = _config.getDefaultVisibilityChecker();\n        } else {\n            _visibilityChecker = _annotationIntrospector.findAutoDetectVisibility(classDef,\n                    _config.getDefaultVisibilityChecker());\n        }\n    }\n\n    \n\n    public MapperConfig<?> getConfig() {\n        return _config;\n    }\n\n    public JavaType getType() {\n        return _type;\n    }\n    \n    public AnnotatedClass getClassDef() {\n        return _classDef;\n    }\n\n    public AnnotationIntrospector getAnnotationIntrospector() {\n        return _annotationIntrospector;\n    }\n    \n    public List<BeanPropertyDefinition> getProperties() {\n        \n        Map<String, POJOPropertyBuilder> props = getPropertyMap();\n        return new ArrayList<BeanPropertyDefinition>(props.values());\n    }\n\n    public Map<Object, AnnotatedMember> getInjectables() {\n        if (!_collected) {\n            collectAll();\n        }\n        return _injectables;\n    }\n    \n    public AnnotatedMethod getJsonValueMethod() {\n        if (!_collected) {\n            collectAll();\n        }\n        \n        if (_jsonValueGetters != null) {\n            if (_jsonValueGetters.size() > 1) {\n                reportProblem(\"Multiple value properties defined (\"+_jsonValueGetters.get(0)+\" vs \"\n                        +_jsonValueGetters.get(1)+\")\");\n            }\n            \n            return _jsonValueGetters.get(0);\n        }\n        return null;\n    }\n\n    public AnnotatedMember getAnyGetter() {\n        if (!_collected) {\n            collectAll();\n        }\n        if (_anyGetters != null) {\n            if (_anyGetters.size() > 1) {\n                reportProblem(\"Multiple 'any-getters' defined (\"+_anyGetters.get(0)+\" vs \"\n                        +_anyGetters.get(1)+\")\");\n            }\n            return _anyGetters.getFirst();\n        }        \n        return null;\n    }\n    \n    public AnnotatedMember getAnySetterField() {\n        if (!_collected) {\n            collectAll();\n        }\n        if (_anySetterField != null) {\n            if (_anySetterField.size() > 1) {\n                reportProblem(\"Multiple 'any-Setters' defined (\"+_anySetters.get(0)+\" vs \"\n                        +_anySetterField.get(1)+\")\");\n            }\n            return _anySetterField.getFirst();\n        }\n        return null;\n    }\n\n    public AnnotatedMethod getAnySetterMethod() {\n        if (!_collected) {\n            collectAll();\n        }\n        if (_anySetters != null) {\n            if (_anySetters.size() > 1) {\n                reportProblem(\"Multiple 'any-setters' defined (\"+_anySetters.get(0)+\" vs \"\n                        +_anySetters.get(1)+\")\");\n            }\n            return _anySetters.getFirst();\n        }\n        return null;\n    }\n\n    \n    public Set<String> getIgnoredPropertyNames() {\n        return _ignoredPropertyNames;\n    }\n\n    \n    public ObjectIdInfo getObjectIdInfo() {\n        if (_annotationIntrospector == null) {\n            return null;\n        }\n        ObjectIdInfo info = _annotationIntrospector.findObjectIdInfo(_classDef);\n        if (info != null) { \n            info = _annotationIntrospector.findObjectReferenceInfo(_classDef, info);\n        }\n        return info;\n    }\n\n    \n    public Class<?> findPOJOBuilderClass() {\n        return _annotationIntrospector.findPOJOBuilder(_classDef);\n    }\n    \n    \n    protected Map<String, POJOPropertyBuilder> getPropertyMap() {\n        if (!_collected) {\n            collectAll();\n        }\n        return _properties;\n    }\n\n    \n\n    \n    @Deprecated\n    public POJOPropertiesCollector collect() {\n        return this;\n    }\n\n    \n    protected void collectAll() {\n        LinkedHashMap<String, POJOPropertyBuilder> props = new LinkedHashMap<String, POJOPropertyBuilder>();\n\n        \n        _addFields(props);\n        _addMethods(props);\n        \n        \n        if (!_classDef.isNonStaticInnerClass()) {\n            _addCreators(props);\n        }\n        _addInjectables(props);\n\n        \n        \n        _removeUnwantedProperties(props);\n\n        \n        for (POJOPropertyBuilder property : props.values()) {\n            property.mergeAnnotations(_forSerialization);\n        }\n        \n        _removeUnwantedAccessor(props);\n\n        \n        _renameProperties(props);\n\n        \n        PropertyNamingStrategy naming = _findNamingStrategy();\n        if (naming != null) {\n            _renameUsing(props, naming);\n        }\n\n        \n        for (POJOPropertyBuilder property : props.values()) {\n            property.trimByVisibility();\n        }\n\n        \n        if (_config.isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME)) {\n            _renameWithWrappers(props);\n        }\n        \n        \n        _sortProperties(props);\n        _properties = props;\n        _collected = true;\n    }\n\n    \n    \n    \n    protected void _addFields(Map<String, POJOPropertyBuilder> props) {\n        final AnnotationIntrospector ai = _annotationIntrospector;\n        \n        final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS);\n        final boolean transientAsIgnoral = _config.isEnabled(MapperFeature.PROPAGATE_TRANSIENT_MARKER);\n        \n        for (AnnotatedField f : _classDef.fields()) {\n            String implName = (ai == null) ? null : ai.findImplicitPropertyName(f);\n            if (implName == null) {\n                implName = f.getName();\n            }\n\n            PropertyName pn;\n\n            if (ai == null) {\n                pn = null;\n            } else if (_forSerialization) {\n                \n                pn = ai.findNameForSerialization(f);\n            } else {\n                pn = ai.findNameForDeserialization(f);\n            }\n            boolean hasName = (pn != null);\n            boolean nameExplicit = hasName;\n\n            if (nameExplicit && pn.isEmpty()) { \n                pn = _propNameFromSimple(implName);\n                nameExplicit = false;\n            }\n            \n            boolean visible = (pn != null);\n            if (!visible) {\n                visible = _visibilityChecker.isFieldVisible(f);\n            }\n            \n            boolean ignored = (ai != null) && ai.hasIgnoreMarker(f);\n\n            \n            if (f.isTransient()) {\n                \n                \n                if (!hasName) {\n                    visible = false;\n                    if (transientAsIgnoral) {\n                        ignored = true;\n                    }\n                }\n            }\n            \n            if (pruneFinalFields && (pn == null) && !ignored && Modifier.isFinal(f.getModifiers())) {\n                continue;\n            }\n\n            \n            if(f.hasAnnotation(JsonAnySetter.class)) {\n            \tif (_anySetterField == null) {\n            \t\t_anySetterField = new LinkedList<AnnotatedMember>();\n            \t}\n            \t_anySetterField.add(f);\n            }\n            _property(props, implName).addField(f, pn, nameExplicit, visible, ignored);\n        }\n    }\n\n    \n    protected void _addCreators(Map<String, POJOPropertyBuilder> props) {\n        \n        if (_annotationIntrospector == null) {\n            return;\n        }\n        for (AnnotatedConstructor ctor : _classDef.getConstructors()) {\n            if (_creatorProperties == null) {\n                _creatorProperties = new LinkedList<POJOPropertyBuilder>();\n            }\n            for (int i = 0, len = ctor.getParameterCount(); i < len; ++i) {\n                _addCreatorParam(props, ctor.getParameter(i));\n            }\n        }\n        for (AnnotatedMethod factory : _classDef.getStaticMethods()) {\n            if (_creatorProperties == null) {\n                _creatorProperties = new LinkedList<POJOPropertyBuilder>();\n            }\n            for (int i = 0, len = factory.getParameterCount(); i < len; ++i) {\n                _addCreatorParam(props, factory.getParameter(i));\n            }\n        }\n    }\n\n    \n    protected void _addCreatorParam(Map<String, POJOPropertyBuilder> props, AnnotatedParameter param) {\n        \n        String impl = _annotationIntrospector.findImplicitPropertyName(param);\n        if (impl == null) {\n            impl = \"\";\n        }\n        PropertyName pn = _annotationIntrospector.findNameForDeserialization(param);\n        boolean expl = (pn != null && !pn.isEmpty());\n        if (!expl) {\n            if (impl.isEmpty()) {\n                \n                return;\n            }\n            \n            if (!_annotationIntrospector.hasCreatorAnnotation(param.getOwner())) {\n                return;\n            }\n            pn = PropertyName.construct(impl);\n        }\n\n        \n        \n\n        \n        POJOPropertyBuilder prop = (expl && impl.isEmpty())\n                ? _property(props, pn) : _property(props, impl);\n        prop.addCtor(param, pn, expl, true, false);\n        _creatorProperties.add(prop);\n    }\n    \n    \n    protected void _addMethods(Map<String, POJOPropertyBuilder> props) {\n        final AnnotationIntrospector ai = _annotationIntrospector;\n        \n        for (AnnotatedMethod m : _classDef.memberMethods()) {\n            \n            int argCount = m.getParameterCount();\n            if (argCount == 0) { \n            \t_addGetterMethod(props, m, ai);\n            } else if (argCount == 1) { \n            \t_addSetterMethod(props, m, ai);\n            } else if (argCount == 2) { \n                if (ai != null  && ai.hasAnySetterAnnotation(m)) {\n                    if (_anySetters == null) {\n                        _anySetters = new LinkedList<AnnotatedMethod>();\n                    }\n                    _anySetters.add(m);\n                }\n            }\n        }\n    }\n\n    protected void _addGetterMethod(Map<String, POJOPropertyBuilder> props, AnnotatedMethod m, AnnotationIntrospector ai) {\n        \n        if (!m.hasReturnType()) {\n            return;\n        }\n        \n        \n        if (ai != null) {\n            if (ai.hasAnyGetterAnnotation(m)) {\n                if (_anyGetters == null) {\n                    _anyGetters = new LinkedList<AnnotatedMember>();\n                }\n                _anyGetters.add(m);\n                return;\n            }\n            \n            if (ai.hasAsValueAnnotation(m)) {\n                if (_jsonValueGetters == null) {\n                    _jsonValueGetters = new LinkedList<AnnotatedMethod>();\n                }\n                _jsonValueGetters.add(m);\n                return;\n            }\n        }\n        String implName; \n        boolean visible;\n\n        PropertyName pn = (ai == null) ? null : ai.findNameForSerialization(m);\n        boolean nameExplicit = (pn != null);\n\n        if (!nameExplicit) { \n            implName = (ai == null) ? null : ai.findImplicitPropertyName(m);\n            if (implName == null) {\n                implName = BeanUtil.okNameForRegularGetter(m, m.getName(), _stdBeanNaming);\n            }\n            if (implName == null) { \n                implName = BeanUtil.okNameForIsGetter(m, m.getName(), _stdBeanNaming);\n                if (implName == null) {\n                    return;\n                }\n                visible = _visibilityChecker.isIsGetterVisible(m);\n            } else {\n                visible = _visibilityChecker.isGetterVisible(m);\n            }\n        } else { \n            \n            implName = (ai == null) ? null : ai.findImplicitPropertyName(m);\n            if (implName == null) {\n                implName = BeanUtil.okNameForGetter(m, _stdBeanNaming);\n            }\n            \n            if (implName == null) {\n                implName = m.getName();\n            }\n            if (pn.isEmpty()) {\n                \n                pn = _propNameFromSimple(implName);\n                nameExplicit = false;\n            }\n            visible = true;\n        }\n        boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m);\n        _property(props, implName).addGetter(m, pn, nameExplicit, visible, ignore);\n    }\n\n    protected void _addSetterMethod(Map<String, POJOPropertyBuilder> props, AnnotatedMethod m, AnnotationIntrospector ai) {\n        String implName; \n        boolean visible;\n        PropertyName pn = (ai == null) ? null : ai.findNameForDeserialization(m);\n        boolean nameExplicit = (pn != null);\n        if (!nameExplicit) { \n            implName = (ai == null) ? null : ai.findImplicitPropertyName(m);\n            if (implName == null) {\n                implName = BeanUtil.okNameForMutator(m, _mutatorPrefix, _stdBeanNaming);\n            }\n            if (implName == null) { \n            \treturn;\n            }\n            visible = _visibilityChecker.isSetterVisible(m);\n        } else { \n            \n            implName = (ai == null) ? null : ai.findImplicitPropertyName(m);\n            if (implName == null) {\n                implName = BeanUtil.okNameForMutator(m, _mutatorPrefix, _stdBeanNaming);\n            }\n            \n            if (implName == null) {\n                implName = m.getName();\n            }\n            if (pn.isEmpty()) {\n                \n                pn = _propNameFromSimple(implName);\n                nameExplicit = false;\n            }\n            visible = true;\n        }\n        boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m);\n        _property(props, implName).addSetter(m, pn, nameExplicit, visible, ignore);\n    }\n    \n    protected void _addInjectables(Map<String, POJOPropertyBuilder> props) {\n        final AnnotationIntrospector ai = _annotationIntrospector;\n        if (ai == null) {\n            return;\n        }\n        \n        \n        for (AnnotatedField f : _classDef.fields()) {\n            _doAddInjectable(ai.findInjectableValueId(f), f);\n        }\n        \n        for (AnnotatedMethod m : _classDef.memberMethods()) {\n            \n            if (m.getParameterCount() != 1) {\n                continue;\n            }\n            _doAddInjectable(ai.findInjectableValueId(m), m);\n        }\n    }\n\n    protected void _doAddInjectable(Object id, AnnotatedMember m) {\n        if (id == null) {\n            return;\n        }\n        if (_injectables == null) {\n            _injectables = new LinkedHashMap<Object, AnnotatedMember>();\n        }\n        AnnotatedMember prev = _injectables.put(id, m);\n        if (prev != null) {\n            String type = id.getClass().getName();\n            throw new IllegalArgumentException(\"Duplicate injectable value with id '\"\n                    +String.valueOf(id)+\"' (of type \"+type+\")\");\n        }\n    }\n\n    private PropertyName _propNameFromSimple(String simpleName) {\n        return PropertyName.construct(simpleName, null);\n    }\n    \n    \n\n    \n    protected void _removeUnwantedProperties(Map<String, POJOPropertyBuilder> props) {\n        Iterator<POJOPropertyBuilder> it = props.values().iterator();\n        while (it.hasNext()) {\n            POJOPropertyBuilder prop = it.next();\n\n            \n            if (!prop.anyVisible()) {\n                it.remove();\n                continue;\n            }\n            \n            if (prop.anyIgnorals()) {\n                \n                if (!prop.isExplicitlyIncluded()) {\n                    it.remove();\n                    _collectIgnorals(prop.getName());\n                    continue;\n                }\n                \n                prop.removeIgnored();\n                if (!_forSerialization && !prop.couldDeserialize()) {\n                    _collectIgnorals(prop.getName());\n                }\n            }\n        }\n    }\n\n    \n    protected void _removeUnwantedAccessor(Map<String, POJOPropertyBuilder> props) {\n        final boolean inferMutators = _config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS);\n        Iterator<POJOPropertyBuilder> it = props.values().iterator();\n\n        while (it.hasNext()) {\n            POJOPropertyBuilder prop = it.next();\n            \n            prop.removeNonVisible(inferMutators);\n        }\n    }\n\n    \n    private void _collectIgnorals(String name) {\n        if (!_forSerialization) {\n            if (_ignoredPropertyNames == null) {\n                _ignoredPropertyNames = new HashSet<String>();\n            }\n            _ignoredPropertyNames.add(name);\n        }\n    }\n\n    \n\n    protected void _renameProperties(Map<String, POJOPropertyBuilder> props) {\n        \n        Iterator<Map.Entry<String,POJOPropertyBuilder>> it = props.entrySet().iterator();\n        LinkedList<POJOPropertyBuilder> renamed = null;\n        while (it.hasNext()) {\n            Map.Entry<String, POJOPropertyBuilder> entry = it.next();\n            POJOPropertyBuilder prop = entry.getValue();\n\n            Collection<PropertyName> l = prop.findExplicitNames();\n\n            \n            if (l.isEmpty()) {\n                continue;\n            }\n            it.remove(); \n            if (renamed == null) {\n                renamed = new LinkedList<POJOPropertyBuilder>();\n            }\n            \n            if (l.size() == 1) {\n                PropertyName n = l.iterator().next();\n                renamed.add(prop.withName(n));\n                continue;\n            }\n            \n            renamed.addAll(prop.explode(l));\n\n            \n        }\n        \n        \n        if (renamed != null) {\n            for (POJOPropertyBuilder prop : renamed) {\n                String name = prop.getName();\n                POJOPropertyBuilder old = props.get(name);\n                if (old == null) {\n                    props.put(name, prop);\n                } else {\n                    old.addAll(prop);\n                }\n                \n                _updateCreatorProperty(prop, _creatorProperties);\n            }\n        }\n    }\n\n    protected void _renameUsing(Map<String, POJOPropertyBuilder> propMap, PropertyNamingStrategy naming) {\n        POJOPropertyBuilder[] props = propMap.values().toArray(new POJOPropertyBuilder[propMap.size()]);\n        propMap.clear();\n        for (POJOPropertyBuilder prop : props) {\n            PropertyName fullName = prop.getFullName();\n            String rename = null;\n            \n            \n            if (!prop.isExplicitlyNamed() || _config.isEnabled(MapperFeature.ALLOW_EXPLICIT_PROPERTY_RENAMING)) {\n                if (_forSerialization) {\n                    if (prop.hasGetter()) {\n                        rename = naming.nameForGetterMethod(_config, prop.getGetter(), fullName.getSimpleName());\n                    } else if (prop.hasField()) {\n                        rename = naming.nameForField(_config, prop.getField(), fullName.getSimpleName());\n                    }\n                } else {\n                    if (prop.hasSetter()) {\n                        rename = naming.nameForSetterMethod(_config, prop.getSetter(), fullName.getSimpleName());\n                    } else if (prop.hasConstructorParameter()) {\n                        rename = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), fullName.getSimpleName());\n                    } else if (prop.hasField()) {\n                        rename = naming.nameForField(_config, prop.getField(), fullName.getSimpleName());\n                    } else if (prop.hasGetter()) {\n                        \n                        rename = naming.nameForGetterMethod(_config, prop.getGetter(), fullName.getSimpleName());\n                    }\n                }\n            }\n            final String simpleName;\n            if (rename != null && !fullName.hasSimpleName(rename)) {\n                prop = prop.withSimpleName(rename);\n                simpleName = rename;\n            } else {\n                simpleName = fullName.getSimpleName();\n            }\n            \n            POJOPropertyBuilder old = propMap.get(simpleName);\n            if (old == null) {\n                propMap.put(simpleName, prop);\n            } else {\n                old.addAll(prop);\n            }\n            \n            _updateCreatorProperty(prop, _creatorProperties);\n        }\n    }\n\n    protected void _renameWithWrappers(Map<String, POJOPropertyBuilder> props) {\n        \n        Iterator<Map.Entry<String,POJOPropertyBuilder>> it = props.entrySet().iterator();\n        LinkedList<POJOPropertyBuilder> renamed = null;\n        while (it.hasNext()) {\n            Map.Entry<String, POJOPropertyBuilder> entry = it.next();\n            POJOPropertyBuilder prop = entry.getValue();\n            AnnotatedMember member = prop.getPrimaryMember();\n            if (member == null) {\n                continue;\n            }\n            PropertyName wrapperName = _annotationIntrospector.findWrapperName(member);\n            \n            \n            \n            if (wrapperName == null || !wrapperName.hasSimpleName()) {\n                continue;\n            }\n            if (!wrapperName.equals(prop.getFullName())) {\n                if (renamed == null) {\n                    renamed = new LinkedList<POJOPropertyBuilder>();\n                }\n                prop = prop.withName(wrapperName);\n                renamed.add(prop);\n                it.remove();\n            }\n        }\n        \n        if (renamed != null) {\n            for (POJOPropertyBuilder prop : renamed) {\n                String name = prop.getName();\n                POJOPropertyBuilder old = props.get(name);\n                if (old == null) {\n                    props.put(name, prop);\n                } else {\n                    old.addAll(prop);\n                }\n            }\n        }\n    }\n\n    \n    \n    \n    protected void _sortProperties(Map<String, POJOPropertyBuilder> props) {\n        \n        AnnotationIntrospector intr = _annotationIntrospector;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically((Annotated) _classDef);\n        boolean sort;\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\n        String[] propertyOrder = (intr == null) ? null : intr.findSerializationPropertyOrder(_classDef);\n        \n        \n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = props.size();\n        Map<String, POJOPropertyBuilder> all;\n        \n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : props.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        \n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { \n                    for (POJOPropertyBuilder prop : props.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            \n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        \n        if (_creatorProperties != null) {\n            \n            Collection<POJOPropertyBuilder> cr;\n            if (sort) {\n                TreeMap<String, POJOPropertyBuilder> sorted =\n                        new TreeMap<String,POJOPropertyBuilder>();\n                for (POJOPropertyBuilder prop : _creatorProperties) {\n                    sorted.put(prop.getName(), prop);\n                }\n                cr = sorted.values();\n            } else {\n                cr = _creatorProperties;\n            }\n            for (POJOPropertyBuilder prop : cr) {\n                \n                \n                String name = prop.getName();\n                if (all.containsKey(name)) {\n                    ordered.put(name, prop);\n                }\n            }\n        }\n        \n        ordered.putAll(all);\n        \n        props.clear();\n        props.putAll(ordered);\n    }        \n\n    \n\n    protected void reportProblem(String msg) {\n        throw new IllegalArgumentException(\"Problem with definition of \"+_classDef+\": \"+msg);\n    }\n\n    protected POJOPropertyBuilder _property(Map<String, POJOPropertyBuilder> props, PropertyName name) {\n        return _property(props, name.getSimpleName());\n    }\n    \n    \n    protected POJOPropertyBuilder _property(Map<String, POJOPropertyBuilder> props, String implName) {\n        POJOPropertyBuilder prop = props.get(implName);\n        if (prop == null) {\n            prop = new POJOPropertyBuilder(_config, _annotationIntrospector, _forSerialization,\n                    PropertyName.construct(implName));\n            props.put(implName, prop);\n        }\n        return prop;\n    }\n\n    private PropertyNamingStrategy _findNamingStrategy() {\n        Object namingDef = (_annotationIntrospector == null)? null\n                : _annotationIntrospector.findNamingStrategy(_classDef);\n        if (namingDef == null) {\n            return _config.getPropertyNamingStrategy();\n        }\n        if (namingDef instanceof PropertyNamingStrategy) {\n            return (PropertyNamingStrategy) namingDef;\n        }\n        \n        if (!(namingDef instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned PropertyNamingStrategy definition of type \"\n                    +namingDef.getClass().getName()+\"; expected type PropertyNamingStrategy or Class<PropertyNamingStrategy> instead\");\n        }\n        Class<?> namingClass = (Class<?>)namingDef;\n        \n        if (namingClass == PropertyNamingStrategy.class) {\n            return null;\n        }\n        \n        if (!PropertyNamingStrategy.class.isAssignableFrom(namingClass)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"\n                    +namingClass.getName()+\"; expected Class<PropertyNamingStrategy>\");\n        }\n        HandlerInstantiator hi = _config.getHandlerInstantiator();\n        if (hi != null) {\n            PropertyNamingStrategy pns = hi.namingStrategyInstance(_config, _classDef, namingClass);\n            if (pns != null) {\n                return pns;\n            }\n        }\n        return (PropertyNamingStrategy) ClassUtil.createInstance(namingClass,\n                    _config.canOverrideAccessModifiers());\n    }\n\n    protected void _updateCreatorProperty(POJOPropertyBuilder prop, List<POJOPropertyBuilder> creatorProperties) {\n        if (creatorProperties != null) {\n            for (int i = 0, len = creatorProperties.size(); i < len; ++i) {\n                if (creatorProperties.get(i).getInternalName().equals(prop.getInternalName())) {\n                    creatorProperties.set(i, prop);\n                    break;\n                }\n            }\n        }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.introspect;\n\nimport java.lang.reflect.Modifier;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.JsonAnySetter;\nimport com.fasterxml.jackson.annotation.JsonProperty.Access;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.util.BeanUtil;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\npublic class POJOPropertiesCollector { protected final MapperConfig<?> _config; protected final boolean _forSerialization; protected final boolean _stdBeanNaming; protected final JavaType _type; protected final AnnotatedClass _classDef; protected final VisibilityChecker<?> _visibilityChecker; protected final AnnotationIntrospector _annotationIntrospector; protected final String _mutatorPrefix; protected boolean _collected; protected LinkedHashMap<String, POJOPropertyBuilder> _properties; protected LinkedList<POJOPropertyBuilder> _creatorProperties ; protected LinkedList<AnnotatedMember> _anyGetters; protected LinkedList<AnnotatedMethod> _anySetters; protected LinkedList<AnnotatedMember> _anySetterField; protected LinkedList<AnnotatedMethod> _jsonValueGetters; protected HashSet<String> _ignoredPropertyNames; protected LinkedHashMap<Object, AnnotatedMember> _injectables; protected POJOPropertiesCollector(MapperConfig<?> config, boolean forSerialization, JavaType type, AnnotatedClass classDef, String mutatorPrefix) {\n        _config = config;\n        _stdBeanNaming = config.isEnabled(MapperFeature.USE_STD_BEAN_NAMING);\n        _forSerialization = forSerialization;\n        _type = type;\n        _classDef = classDef;\n        _mutatorPrefix = (mutatorPrefix == null) ? \"set\" : mutatorPrefix;\n        _annotationIntrospector = config.isAnnotationProcessingEnabled() ?\n                _config.getAnnotationIntrospector() : null;\n        if (_annotationIntrospector == null) {\n            _visibilityChecker = _config.getDefaultVisibilityChecker();\n        } else {\n            _visibilityChecker = _annotationIntrospector.findAutoDetectVisibility(classDef,\n                    _config.getDefaultVisibilityChecker());\n        }\n    }\n\n    \n\n    public MapperConfig<?> getConfig() {\n        return _config;\n    }\n\n    public JavaType getType() {\n        return _type;\n    }\n    \n    public AnnotatedClass getClassDef() {\n        return _classDef;\n    }\n\n    public AnnotationIntrospector getAnnotationIntrospector() {\n        return _annotationIntrospector;\n    }\n    \n    public List<BeanPropertyDefinition> getProperties() {\n        \n        Map<String, POJOPropertyBuilder> props = getPropertyMap();\n        return new ArrayList<BeanPropertyDefinition>(props.values());\n    }\n\n    public Map<Object, AnnotatedMember> getInjectables() {\n        if (!_collected) {\n            collectAll();\n        }\n        return _injectables;\n    }\n    \n    public AnnotatedMethod getJsonValueMethod() {\n        if (!_collected) {\n            collectAll();\n        }\n        \n        if (_jsonValueGetters != null) {\n            if (_jsonValueGetters.size() > 1) {\n                reportProblem(\"Multiple value properties defined (\"+_jsonValueGetters.get(0)+\" vs \"\n                        +_jsonValueGetters.get(1)+\")\");\n            }\n            \n            return _jsonValueGetters.get(0);\n        }\n        return null;\n    }\n\n    public AnnotatedMember getAnyGetter() {\n        if (!_collected) {\n            collectAll();\n        }\n        if (_anyGetters != null) {\n            if (_anyGetters.size() > 1) {\n                reportProblem(\"Multiple 'any-getters' defined (\"+_anyGetters.get(0)+\" vs \"\n                        +_anyGetters.get(1)+\")\");\n            }\n            return _anyGetters.getFirst();\n        }        \n        return null;\n    }\n    \n    public AnnotatedMember getAnySetterField() {\n        if (!_collected) {\n            collectAll();\n        }\n        if (_anySetterField != null) {\n            if (_anySetterField.size() > 1) {\n                reportProblem(\"Multiple 'any-Setters' defined (\"+_anySetters.get(0)+\" vs \"\n                        +_anySetterField.get(1)+\")\");\n            }\n            return _anySetterField.getFirst();\n        }\n        return null;\n    }\n\n    public AnnotatedMethod getAnySetterMethod() {\n        if (!_collected) {\n            collectAll();\n        }\n        if (_anySetters != null) {\n            if (_anySetters.size() > 1) {\n                reportProblem(\"Multiple 'any-setters' defined (\"+_anySetters.get(0)+\" vs \"\n                        +_anySetters.get(1)+\")\");\n            }\n            return _anySetters.getFirst();\n        }\n        return null;\n    }\n\n    \n    public Set<String> getIgnoredPropertyNames() {\n        return _ignoredPropertyNames;\n    }\n\n    \n    public ObjectIdInfo getObjectIdInfo() {\n        if (_annotationIntrospector == null) {\n            return null;\n        }\n        ObjectIdInfo info = _annotationIntrospector.findObjectIdInfo(_classDef);\n        if (info != null) { \n            info = _annotationIntrospector.findObjectReferenceInfo(_classDef, info);\n        }\n        return info;\n    }\n\n    \n    public Class<?> findPOJOBuilderClass() {\n        return _annotationIntrospector.findPOJOBuilder(_classDef);\n    }\n    \n    \n    protected Map<String, POJOPropertyBuilder> getPropertyMap() {\n        if (!_collected) {\n            collectAll();\n        }\n        return _properties;\n    }\n\n    \n\n    \n    @Deprecated\n    public POJOPropertiesCollector collect() {\n        return this;\n    }\n\n    \n    protected void collectAll() {\n        LinkedHashMap<String, POJOPropertyBuilder> props = new LinkedHashMap<String, POJOPropertyBuilder>();\n\n        \n        _addFields(props);\n        _addMethods(props);\n        \n        \n        if (!_classDef.isNonStaticInnerClass()) {\n            _addCreators(props);\n        }\n        _addInjectables(props);\n\n        \n        \n        _removeUnwantedProperties(props);\n\n        \n        for (POJOPropertyBuilder property : props.values()) {\n            property.mergeAnnotations(_forSerialization);\n        }\n        \n        _removeUnwantedAccessor(props);\n\n        \n        _renameProperties(props);\n\n        \n        PropertyNamingStrategy naming = _findNamingStrategy();\n        if (naming != null) {\n            _renameUsing(props, naming);\n        }\n\n        \n        for (POJOPropertyBuilder property : props.values()) {\n            property.trimByVisibility();\n        }\n\n        \n        if (_config.isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME)) {\n            _renameWithWrappers(props);\n        }\n        \n        \n        _sortProperties(props);\n        _properties = props;\n        _collected = true;\n    }\n\n    \n    \n    \n    protected void _addFields(Map<String, POJOPropertyBuilder> props) {\n        final AnnotationIntrospector ai = _annotationIntrospector;\n        \n        final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS);\n        final boolean transientAsIgnoral = _config.isEnabled(MapperFeature.PROPAGATE_TRANSIENT_MARKER);\n        \n        for (AnnotatedField f : _classDef.fields()) {\n            String implName = (ai == null) ? null : ai.findImplicitPropertyName(f);\n            if (implName == null) {\n                implName = f.getName();\n            }\n\n            PropertyName pn;\n\n            if (ai == null) {\n                pn = null;\n            } else if (_forSerialization) {\n                \n                pn = ai.findNameForSerialization(f);\n            } else {\n                pn = ai.findNameForDeserialization(f);\n            }\n            boolean hasName = (pn != null);\n            boolean nameExplicit = hasName;\n\n            if (nameExplicit && pn.isEmpty()) { \n                pn = _propNameFromSimple(implName);\n                nameExplicit = false;\n            }\n            \n            boolean visible = (pn != null);\n            if (!visible) {\n                visible = _visibilityChecker.isFieldVisible(f);\n            }\n            \n            boolean ignored = (ai != null) && ai.hasIgnoreMarker(f);\n\n            \n            if (f.isTransient()) {\n                \n                \n                if (!hasName) {\n                    visible = false;\n                    if (transientAsIgnoral) {\n                        ignored = true;\n                    }\n                }\n            }\n            \n            if (pruneFinalFields && (pn == null) && !ignored && Modifier.isFinal(f.getModifiers())) {\n                continue;\n            }\n\n            \n            if(f.hasAnnotation(JsonAnySetter.class)) {\n            \tif (_anySetterField == null) {\n            \t\t_anySetterField = new LinkedList<AnnotatedMember>();\n            \t}\n            \t_anySetterField.add(f);\n            }\n            _property(props, implName).addField(f, pn, nameExplicit, visible, ignored);\n        }\n    }\n\n    \n    protected void _addCreators(Map<String, POJOPropertyBuilder> props) {\n        \n        if (_annotationIntrospector == null) {\n            return;\n        }\n        for (AnnotatedConstructor ctor : _classDef.getConstructors()) {\n            if (_creatorProperties == null) {\n                _creatorProperties = new LinkedList<POJOPropertyBuilder>();\n            }\n            for (int i = 0, len = ctor.getParameterCount(); i < len; ++i) {\n                _addCreatorParam(props, ctor.getParameter(i));\n            }\n        }\n        for (AnnotatedMethod factory : _classDef.getStaticMethods()) {\n            if (_creatorProperties == null) {\n                _creatorProperties = new LinkedList<POJOPropertyBuilder>();\n            }\n            for (int i = 0, len = factory.getParameterCount(); i < len; ++i) {\n                _addCreatorParam(props, factory.getParameter(i));\n            }\n        }\n    }\n\n    \n    protected void _addCreatorParam(Map<String, POJOPropertyBuilder> props, AnnotatedParameter param) {\n        \n        String impl = _annotationIntrospector.findImplicitPropertyName(param);\n        if (impl == null) {\n            impl = \"\";\n        }\n        PropertyName pn = _annotationIntrospector.findNameForDeserialization(param);\n        boolean expl = (pn != null && !pn.isEmpty());\n        if (!expl) {\n            if (impl.isEmpty()) {\n                \n                return;\n            }\n            \n            if (!_annotationIntrospector.hasCreatorAnnotation(param.getOwner())) {\n                return;\n            }\n            pn = PropertyName.construct(impl);\n        }\n\n        \n        \n\n        \n        POJOPropertyBuilder prop = (expl && impl.isEmpty())\n                ? _property(props, pn) : _property(props, impl);\n        prop.addCtor(param, pn, expl, true, false);\n        _creatorProperties.add(prop);\n    }\n    \n    \n    protected void _addMethods(Map<String, POJOPropertyBuilder> props) {\n        final AnnotationIntrospector ai = _annotationIntrospector;\n        \n        for (AnnotatedMethod m : _classDef.memberMethods()) {\n            \n            int argCount = m.getParameterCount();\n            if (argCount == 0) { \n            \t_addGetterMethod(props, m, ai);\n            } else if (argCount == 1) { \n            \t_addSetterMethod(props, m, ai);\n            } else if (argCount == 2) { \n                if (ai != null  && ai.hasAnySetterAnnotation(m)) {\n                    if (_anySetters == null) {\n                        _anySetters = new LinkedList<AnnotatedMethod>();\n                    }\n                    _anySetters.add(m);\n                }\n            }\n        }\n    }\n\n    protected void _addGetterMethod(Map<String, POJOPropertyBuilder> props, AnnotatedMethod m, AnnotationIntrospector ai) {\n        \n        if (!m.hasReturnType()) {\n            return;\n        }\n        \n        \n        if (ai != null) {\n            if (ai.hasAnyGetterAnnotation(m)) {\n                if (_anyGetters == null) {\n                    _anyGetters = new LinkedList<AnnotatedMember>();\n                }\n                _anyGetters.add(m);\n                return;\n            }\n            \n            if (ai.hasAsValueAnnotation(m)) {\n                if (_jsonValueGetters == null) {\n                    _jsonValueGetters = new LinkedList<AnnotatedMethod>();\n                }\n                _jsonValueGetters.add(m);\n                return;\n            }\n        }\n        String implName; \n        boolean visible;\n\n        PropertyName pn = (ai == null) ? null : ai.findNameForSerialization(m);\n        boolean nameExplicit = (pn != null);\n\n        if (!nameExplicit) { \n            implName = (ai == null) ? null : ai.findImplicitPropertyName(m);\n            if (implName == null) {\n                implName = BeanUtil.okNameForRegularGetter(m, m.getName(), _stdBeanNaming);\n            }\n            if (implName == null) { \n                implName = BeanUtil.okNameForIsGetter(m, m.getName(), _stdBeanNaming);\n                if (implName == null) {\n                    return;\n                }\n                visible = _visibilityChecker.isIsGetterVisible(m);\n            } else {\n                visible = _visibilityChecker.isGetterVisible(m);\n            }\n        } else { \n            \n            implName = (ai == null) ? null : ai.findImplicitPropertyName(m);\n            if (implName == null) {\n                implName = BeanUtil.okNameForGetter(m, _stdBeanNaming);\n            }\n            \n            if (implName == null) {\n                implName = m.getName();\n            }\n            if (pn.isEmpty()) {\n                \n                pn = _propNameFromSimple(implName);\n                nameExplicit = false;\n            }\n            visible = true;\n        }\n        boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m);\n        _property(props, implName).addGetter(m, pn, nameExplicit, visible, ignore);\n    }\n\n    protected void _addSetterMethod(Map<String, POJOPropertyBuilder> props, AnnotatedMethod m, AnnotationIntrospector ai) {\n        String implName; \n        boolean visible;\n        PropertyName pn = (ai == null) ? null : ai.findNameForDeserialization(m);\n        boolean nameExplicit = (pn != null);\n        if (!nameExplicit) { \n            implName = (ai == null) ? null : ai.findImplicitPropertyName(m);\n            if (implName == null) {\n                implName = BeanUtil.okNameForMutator(m, _mutatorPrefix, _stdBeanNaming);\n            }\n            if (implName == null) { \n            \treturn;\n            }\n            visible = _visibilityChecker.isSetterVisible(m);\n        } else { \n            \n            implName = (ai == null) ? null : ai.findImplicitPropertyName(m);\n            if (implName == null) {\n                implName = BeanUtil.okNameForMutator(m, _mutatorPrefix, _stdBeanNaming);\n            }\n            \n            if (implName == null) {\n                implName = m.getName();\n            }\n            if (pn.isEmpty()) {\n                \n                pn = _propNameFromSimple(implName);\n                nameExplicit = false;\n            }\n            visible = true;\n        }\n        boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m);\n        _property(props, implName).addSetter(m, pn, nameExplicit, visible, ignore);\n    }\n    \n    protected void _addInjectables(Map<String, POJOPropertyBuilder> props) {\n        final AnnotationIntrospector ai = _annotationIntrospector;\n        if (ai == null) {\n            return;\n        }\n        \n        \n        for (AnnotatedField f : _classDef.fields()) {\n            _doAddInjectable(ai.findInjectableValueId(f), f);\n        }\n        \n        for (AnnotatedMethod m : _classDef.memberMethods()) {\n            \n            if (m.getParameterCount() != 1) {\n                continue;\n            }\n            _doAddInjectable(ai.findInjectableValueId(m), m);\n        }\n    }\n\n    protected void _doAddInjectable(Object id, AnnotatedMember m) {\n        if (id == null) {\n            return;\n        }\n        if (_injectables == null) {\n            _injectables = new LinkedHashMap<Object, AnnotatedMember>();\n        }\n        AnnotatedMember prev = _injectables.put(id, m);\n        if (prev != null) {\n            String type = id.getClass().getName();\n            throw new IllegalArgumentException(\"Duplicate injectable value with id '\"\n                    +String.valueOf(id)+\"' (of type \"+type+\")\");\n        }\n    }\n\n    private PropertyName _propNameFromSimple(String simpleName) {\n        return PropertyName.construct(simpleName, null);\n    }\n    \n    \n\n    \n    protected void _removeUnwantedProperties(Map<String, POJOPropertyBuilder> props) {\n        Iterator<POJOPropertyBuilder> it = props.values().iterator();\n        while (it.hasNext()) {\n            POJOPropertyBuilder prop = it.next();\n\n            \n            if (!prop.anyVisible()) {\n                it.remove();\n                continue;\n            }\n            \n            if (prop.anyIgnorals()) {\n                \n                if (!prop.isExplicitlyIncluded()) {\n                    it.remove();\n                    _collectIgnorals(prop.getName());\n                    continue;\n                }\n                \n                prop.removeIgnored();\n                if (!_forSerialization && !prop.couldDeserialize()) {\n                    _collectIgnorals(prop.getName());\n                }\n            }\n        }\n    }\n\n    \n    protected void _removeUnwantedAccessor(Map<String, POJOPropertyBuilder> props) {\n        final boolean inferMutators = _config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS);\n        Iterator<POJOPropertyBuilder> it = props.values().iterator();\n\n        while (it.hasNext()) {\n            POJOPropertyBuilder prop = it.next();\n            \n            Access acc = prop.removeNonVisible(inferMutators);\n            if (!_forSerialization && (acc == Access.READ_ONLY)) {\n                _collectIgnorals(prop.getName());\n            }\n        }\n    }\n\n    \n    private void _collectIgnorals(String name) {\n        if (!_forSerialization) {\n            if (_ignoredPropertyNames == null) {\n                _ignoredPropertyNames = new HashSet<String>();\n            }\n            _ignoredPropertyNames.add(name);\n        }\n    }\n\n    \n\n    protected void _renameProperties(Map<String, POJOPropertyBuilder> props) {\n        \n        Iterator<Map.Entry<String,POJOPropertyBuilder>> it = props.entrySet().iterator();\n        LinkedList<POJOPropertyBuilder> renamed = null;\n        while (it.hasNext()) {\n            Map.Entry<String, POJOPropertyBuilder> entry = it.next();\n            POJOPropertyBuilder prop = entry.getValue();\n\n            Collection<PropertyName> l = prop.findExplicitNames();\n\n            \n            if (l.isEmpty()) {\n                continue;\n            }\n            it.remove(); \n            if (renamed == null) {\n                renamed = new LinkedList<POJOPropertyBuilder>();\n            }\n            \n            if (l.size() == 1) {\n                PropertyName n = l.iterator().next();\n                renamed.add(prop.withName(n));\n                continue;\n            }\n            \n            renamed.addAll(prop.explode(l));\n\n            \n        }\n        \n        \n        if (renamed != null) {\n            for (POJOPropertyBuilder prop : renamed) {\n                String name = prop.getName();\n                POJOPropertyBuilder old = props.get(name);\n                if (old == null) {\n                    props.put(name, prop);\n                } else {\n                    old.addAll(prop);\n                }\n                \n                _updateCreatorProperty(prop, _creatorProperties);\n            }\n        }\n    }\n\n    protected void _renameUsing(Map<String, POJOPropertyBuilder> propMap, PropertyNamingStrategy naming) {\n        POJOPropertyBuilder[] props = propMap.values().toArray(new POJOPropertyBuilder[propMap.size()]);\n        propMap.clear();\n        for (POJOPropertyBuilder prop : props) {\n            PropertyName fullName = prop.getFullName();\n            String rename = null;\n            \n            \n            if (!prop.isExplicitlyNamed() || _config.isEnabled(MapperFeature.ALLOW_EXPLICIT_PROPERTY_RENAMING)) {\n                if (_forSerialization) {\n                    if (prop.hasGetter()) {\n                        rename = naming.nameForGetterMethod(_config, prop.getGetter(), fullName.getSimpleName());\n                    } else if (prop.hasField()) {\n                        rename = naming.nameForField(_config, prop.getField(), fullName.getSimpleName());\n                    }\n                } else {\n                    if (prop.hasSetter()) {\n                        rename = naming.nameForSetterMethod(_config, prop.getSetter(), fullName.getSimpleName());\n                    } else if (prop.hasConstructorParameter()) {\n                        rename = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), fullName.getSimpleName());\n                    } else if (prop.hasField()) {\n                        rename = naming.nameForField(_config, prop.getField(), fullName.getSimpleName());\n                    } else if (prop.hasGetter()) {\n                        \n                        rename = naming.nameForGetterMethod(_config, prop.getGetter(), fullName.getSimpleName());\n                    }\n                }\n            }\n            final String simpleName;\n            if (rename != null && !fullName.hasSimpleName(rename)) {\n                prop = prop.withSimpleName(rename);\n                simpleName = rename;\n            } else {\n                simpleName = fullName.getSimpleName();\n            }\n            \n            POJOPropertyBuilder old = propMap.get(simpleName);\n            if (old == null) {\n                propMap.put(simpleName, prop);\n            } else {\n                old.addAll(prop);\n            }\n            \n            _updateCreatorProperty(prop, _creatorProperties);\n        }\n    }\n\n    protected void _renameWithWrappers(Map<String, POJOPropertyBuilder> props) {\n        \n        Iterator<Map.Entry<String,POJOPropertyBuilder>> it = props.entrySet().iterator();\n        LinkedList<POJOPropertyBuilder> renamed = null;\n        while (it.hasNext()) {\n            Map.Entry<String, POJOPropertyBuilder> entry = it.next();\n            POJOPropertyBuilder prop = entry.getValue();\n            AnnotatedMember member = prop.getPrimaryMember();\n            if (member == null) {\n                continue;\n            }\n            PropertyName wrapperName = _annotationIntrospector.findWrapperName(member);\n            \n            \n            \n            if (wrapperName == null || !wrapperName.hasSimpleName()) {\n                continue;\n            }\n            if (!wrapperName.equals(prop.getFullName())) {\n                if (renamed == null) {\n                    renamed = new LinkedList<POJOPropertyBuilder>();\n                }\n                prop = prop.withName(wrapperName);\n                renamed.add(prop);\n                it.remove();\n            }\n        }\n        \n        if (renamed != null) {\n            for (POJOPropertyBuilder prop : renamed) {\n                String name = prop.getName();\n                POJOPropertyBuilder old = props.get(name);\n                if (old == null) {\n                    props.put(name, prop);\n                } else {\n                    old.addAll(prop);\n                }\n            }\n        }\n    }\n\n    \n    \n    \n    protected void _sortProperties(Map<String, POJOPropertyBuilder> props) {\n        \n        AnnotationIntrospector intr = _annotationIntrospector;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically((Annotated) _classDef);\n        boolean sort;\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\n        String[] propertyOrder = (intr == null) ? null : intr.findSerializationPropertyOrder(_classDef);\n        \n        \n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = props.size();\n        Map<String, POJOPropertyBuilder> all;\n        \n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : props.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        \n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { \n                    for (POJOPropertyBuilder prop : props.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            \n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        \n        if (_creatorProperties != null) {\n            \n            Collection<POJOPropertyBuilder> cr;\n            if (sort) {\n                TreeMap<String, POJOPropertyBuilder> sorted =\n                        new TreeMap<String,POJOPropertyBuilder>();\n                for (POJOPropertyBuilder prop : _creatorProperties) {\n                    sorted.put(prop.getName(), prop);\n                }\n                cr = sorted.values();\n            } else {\n                cr = _creatorProperties;\n            }\n            for (POJOPropertyBuilder prop : cr) {\n                \n                \n                String name = prop.getName();\n                if (all.containsKey(name)) {\n                    ordered.put(name, prop);\n                }\n            }\n        }\n        \n        ordered.putAll(all);\n        \n        props.clear();\n        props.putAll(ordered);\n    }        \n\n    \n\n    protected void reportProblem(String msg) {\n        throw new IllegalArgumentException(\"Problem with definition of \"+_classDef+\": \"+msg);\n    }\n\n    protected POJOPropertyBuilder _property(Map<String, POJOPropertyBuilder> props, PropertyName name) {\n        return _property(props, name.getSimpleName());\n    }\n    \n    \n    protected POJOPropertyBuilder _property(Map<String, POJOPropertyBuilder> props, String implName) {\n        POJOPropertyBuilder prop = props.get(implName);\n        if (prop == null) {\n            prop = new POJOPropertyBuilder(_config, _annotationIntrospector, _forSerialization,\n                    PropertyName.construct(implName));\n            props.put(implName, prop);\n        }\n        return prop;\n    }\n\n    private PropertyNamingStrategy _findNamingStrategy() {\n        Object namingDef = (_annotationIntrospector == null)? null\n                : _annotationIntrospector.findNamingStrategy(_classDef);\n        if (namingDef == null) {\n            return _config.getPropertyNamingStrategy();\n        }\n        if (namingDef instanceof PropertyNamingStrategy) {\n            return (PropertyNamingStrategy) namingDef;\n        }\n        \n        if (!(namingDef instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned PropertyNamingStrategy definition of type \"\n                    +namingDef.getClass().getName()+\"; expected type PropertyNamingStrategy or Class<PropertyNamingStrategy> instead\");\n        }\n        Class<?> namingClass = (Class<?>)namingDef;\n        \n        if (namingClass == PropertyNamingStrategy.class) {\n            return null;\n        }\n        \n        if (!PropertyNamingStrategy.class.isAssignableFrom(namingClass)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"\n                    +namingClass.getName()+\"; expected Class<PropertyNamingStrategy>\");\n        }\n        HandlerInstantiator hi = _config.getHandlerInstantiator();\n        if (hi != null) {\n            PropertyNamingStrategy pns = hi.namingStrategyInstance(_config, _classDef, namingClass);\n            if (pns != null) {\n                return pns;\n            }\n        }\n        return (PropertyNamingStrategy) ClassUtil.createInstance(namingClass,\n                    _config.canOverrideAccessModifiers());\n    }\n\n    protected void _updateCreatorProperty(POJOPropertyBuilder prop, List<POJOPropertyBuilder> creatorProperties) {\n        if (creatorProperties != null) {\n            for (int i = 0, len = creatorProperties.size(); i < len; ++i) {\n                if (creatorProperties.get(i).getInternalName().equals(prop.getInternalName())) {\n                    creatorProperties.set(i, prop);\n                    break;\n                }\n            }\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public class POJOPropertiesCollector { protected final MapperConfig<?> _config; protected final boolean _forSerialization; protected final boolean _stdBeanNaming; protected final JavaType _type; protected final AnnotatedClass _classDef; protected final VisibilityChecker<?> _visibilityChecker; protected final AnnotationIntrospector _annotationIntrospector; protected final String _mutatorPrefix; protected boolean _collected; protected LinkedHashMap<String, POJOPropertyBuilder> _properties; protected LinkedList<POJOPropertyBuilder> _creatorProperties ; protected LinkedList<AnnotatedMember> _anyGetters; protected LinkedList<AnnotatedMethod> _anySetters; protected LinkedList<AnnotatedMember> _anySetterField; protected LinkedList<AnnotatedMethod> _jsonValueGetters; protected HashSet<String> _ignoredPropertyNames; protected LinkedHashMap<Object, AnnotatedMember> _injectables; protected POJOPropertiesCollector(MapperConfig<?> config, boolean forSerialization, JavaType type, AnnotatedClass classDef, String mutatorPrefix)",
        "public MapperConfig<?> getConfig()",
        "public JavaType getType()",
        "public AnnotatedClass getClassDef()",
        "public AnnotationIntrospector getAnnotationIntrospector()",
        "public List<BeanPropertyDefinition> getProperties()",
        "public Map<Object, AnnotatedMember> getInjectables()",
        "public AnnotatedMethod getJsonValueMethod()",
        "public AnnotatedMember getAnyGetter()",
        "public AnnotatedMember getAnySetterField()",
        "public AnnotatedMethod getAnySetterMethod()",
        "public Set<String> getIgnoredPropertyNames()",
        "public ObjectIdInfo getObjectIdInfo()",
        "public Class<?> findPOJOBuilderClass()",
        "protected Map<String, POJOPropertyBuilder> getPropertyMap()",
        "public POJOPropertiesCollector collect()",
        "protected void collectAll()",
        "protected void _addFields(Map<String, POJOPropertyBuilder> props)",
        "protected void _addCreators(Map<String, POJOPropertyBuilder> props)",
        "protected void _addCreatorParam(Map<String, POJOPropertyBuilder> props, AnnotatedParameter param)",
        "protected void _addMethods(Map<String, POJOPropertyBuilder> props)",
        "protected void _addGetterMethod(Map<String, POJOPropertyBuilder> props, AnnotatedMethod m, AnnotationIntrospector ai)",
        "protected void _addSetterMethod(Map<String, POJOPropertyBuilder> props, AnnotatedMethod m, AnnotationIntrospector ai)",
        "protected void _addInjectables(Map<String, POJOPropertyBuilder> props)",
        "protected void _doAddInjectable(Object id, AnnotatedMember m)",
        "private PropertyName _propNameFromSimple(String simpleName)",
        "protected void _removeUnwantedProperties(Map<String, POJOPropertyBuilder> props)",
        "protected void _removeUnwantedAccessor(Map<String, POJOPropertyBuilder> props)",
        "private void _collectIgnorals(String name)",
        "protected void _renameProperties(Map<String, POJOPropertyBuilder> props)",
        "protected void _renameUsing(Map<String, POJOPropertyBuilder> propMap, PropertyNamingStrategy naming)",
        "protected void _renameWithWrappers(Map<String, POJOPropertyBuilder> props)",
        "protected void _sortProperties(Map<String, POJOPropertyBuilder> props)",
        "protected void reportProblem(String msg)",
        "protected POJOPropertyBuilder _property(Map<String, POJOPropertyBuilder> props, PropertyName name)",
        "protected POJOPropertyBuilder _property(Map<String, POJOPropertyBuilder> props, String implName)",
        "private PropertyNamingStrategy _findNamingStrategy()",
        "protected void _updateCreatorProperty(POJOPropertyBuilder prop, List<POJOPropertyBuilder> creatorProperties)"
      ],
      "fixed_signatures": [
        "public class POJOPropertiesCollector { protected final MapperConfig<?> _config; protected final boolean _forSerialization; protected final boolean _stdBeanNaming; protected final JavaType _type; protected final AnnotatedClass _classDef; protected final VisibilityChecker<?> _visibilityChecker; protected final AnnotationIntrospector _annotationIntrospector; protected final String _mutatorPrefix; protected boolean _collected; protected LinkedHashMap<String, POJOPropertyBuilder> _properties; protected LinkedList<POJOPropertyBuilder> _creatorProperties ; protected LinkedList<AnnotatedMember> _anyGetters; protected LinkedList<AnnotatedMethod> _anySetters; protected LinkedList<AnnotatedMember> _anySetterField; protected LinkedList<AnnotatedMethod> _jsonValueGetters; protected HashSet<String> _ignoredPropertyNames; protected LinkedHashMap<Object, AnnotatedMember> _injectables; protected POJOPropertiesCollector(MapperConfig<?> config, boolean forSerialization, JavaType type, AnnotatedClass classDef, String mutatorPrefix)",
        "public MapperConfig<?> getConfig()",
        "public JavaType getType()",
        "public AnnotatedClass getClassDef()",
        "public AnnotationIntrospector getAnnotationIntrospector()",
        "public List<BeanPropertyDefinition> getProperties()",
        "public Map<Object, AnnotatedMember> getInjectables()",
        "public AnnotatedMethod getJsonValueMethod()",
        "public AnnotatedMember getAnyGetter()",
        "public AnnotatedMember getAnySetterField()",
        "public AnnotatedMethod getAnySetterMethod()",
        "public Set<String> getIgnoredPropertyNames()",
        "public ObjectIdInfo getObjectIdInfo()",
        "public Class<?> findPOJOBuilderClass()",
        "protected Map<String, POJOPropertyBuilder> getPropertyMap()",
        "public POJOPropertiesCollector collect()",
        "protected void collectAll()",
        "protected void _addFields(Map<String, POJOPropertyBuilder> props)",
        "protected void _addCreators(Map<String, POJOPropertyBuilder> props)",
        "protected void _addCreatorParam(Map<String, POJOPropertyBuilder> props, AnnotatedParameter param)",
        "protected void _addMethods(Map<String, POJOPropertyBuilder> props)",
        "protected void _addGetterMethod(Map<String, POJOPropertyBuilder> props, AnnotatedMethod m, AnnotationIntrospector ai)",
        "protected void _addSetterMethod(Map<String, POJOPropertyBuilder> props, AnnotatedMethod m, AnnotationIntrospector ai)",
        "protected void _addInjectables(Map<String, POJOPropertyBuilder> props)",
        "protected void _doAddInjectable(Object id, AnnotatedMember m)",
        "private PropertyName _propNameFromSimple(String simpleName)",
        "protected void _removeUnwantedProperties(Map<String, POJOPropertyBuilder> props)",
        "protected void _removeUnwantedAccessor(Map<String, POJOPropertyBuilder> props)",
        "private void _collectIgnorals(String name)",
        "protected void _renameProperties(Map<String, POJOPropertyBuilder> props)",
        "protected void _renameUsing(Map<String, POJOPropertyBuilder> propMap, PropertyNamingStrategy naming)",
        "protected void _renameWithWrappers(Map<String, POJOPropertyBuilder> props)",
        "protected void _sortProperties(Map<String, POJOPropertyBuilder> props)",
        "protected void reportProblem(String msg)",
        "protected POJOPropertyBuilder _property(Map<String, POJOPropertyBuilder> props, PropertyName name)",
        "protected POJOPropertyBuilder _property(Map<String, POJOPropertyBuilder> props, String implName)",
        "private PropertyNamingStrategy _findNamingStrategy()",
        "protected void _updateCreatorProperty(POJOPropertyBuilder prop, List<POJOPropertyBuilder> creatorProperties)"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -4,6 +4,7 @@",
            " import java.util.*;\n",
            " \n",
            " import com.fasterxml.jackson.annotation.JsonAnySetter;\n",
            "+import com.fasterxml.jackson.annotation.JsonProperty.Access;\n",
            " import com.fasterxml.jackson.databind.*;\n",
            " import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n",
            " import com.fasterxml.jackson.databind.cfg.MapperConfig;\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  protected void _removeUnwantedAccessor(Map<String, POJOPropertyBuilder> props) {\n  final boolean inferMutators = _config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS);\n  Iterator<POJOPropertyBuilder> it = props.values().iterator();\n\n  while (it.hasNext()) {\n  POJOPropertyBuilder prop = it.next();\n  \n  prop.removeNonVisible(inferMutators);\n  }\n  }",
          "fixed_method": "  protected void _removeUnwantedAccessor(Map<String, POJOPropertyBuilder> props) {\n  final boolean inferMutators = _config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS);\n  Iterator<POJOPropertyBuilder> it = props.values().iterator();\n\n  while (it.hasNext()) {\n  POJOPropertyBuilder prop = it.next();\n  \n  Access acc = prop.removeNonVisible(inferMutators);\n  if (!_forSerialization && (acc == Access.READ_ONLY)) {\n  _collectIgnorals(prop.getName());\n  }\n  }\n  }",
          "diff": [
            "@@ -728,7 +729,10 @@",
            "         while (it.hasNext()) {\n",
            "             POJOPropertyBuilder prop = it.next();\n",
            "             // 26-Jan-2017, tatu: [databind#935]: need to denote removal of\n",
            "-            prop.removeNonVisible(inferMutators);\n",
            "+            Access acc = prop.removeNonVisible(inferMutators);\n",
            "+            if (!_forSerialization && (acc == Access.READ_ONLY)) {\n",
            "+                _collectIgnorals(prop.getName());\n",
            "+            }\n",
            "         }\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 5
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.introspect;\n\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\npublic class POJOPropertyBuilder extends BeanPropertyDefinition implements Comparable<POJOPropertyBuilder> { protected final boolean _forSerialization; protected final MapperConfig<?> _config; protected final AnnotationIntrospector _annotationIntrospector; protected final PropertyName _name; protected final PropertyName _internalName; protected Linked<AnnotatedField> _fields; protected Linked<AnnotatedParameter> _ctorParameters; protected Linked<AnnotatedMethod> _getters; protected Linked<AnnotatedMethod> _setters; public POJOPropertyBuilder(MapperConfig<?> config, AnnotationIntrospector ai, boolean forSerialization, PropertyName internalName) {\n        this(config, ai, forSerialization, internalName, internalName);\n    }\n\n    protected POJOPropertyBuilder(MapperConfig<?> config, AnnotationIntrospector ai, boolean forSerialization, PropertyName internalName, PropertyName name) {\n        _config = config;\n        _annotationIntrospector = ai;\n        _internalName = internalName;\n        _name = name;\n        _forSerialization = forSerialization;\n    }\n\n    public POJOPropertyBuilder(POJOPropertyBuilder src, PropertyName newName) {\n        _config = src._config;\n        _annotationIntrospector = src._annotationIntrospector;\n        _internalName = src._internalName;\n        _name = newName;\n        _fields = src._fields;\n        _ctorParameters = src._ctorParameters;\n        _getters = src._getters;\n        _setters = src._setters;\n        _forSerialization = src._forSerialization;\n    }\n    \n    \n\n    @Override\n    public POJOPropertyBuilder withName(PropertyName newName) {\n        return new POJOPropertyBuilder(this, newName);\n    }\n\n    @Override\n    public POJOPropertyBuilder withSimpleName(String newSimpleName) {\n        PropertyName newName = _name.withSimpleName(newSimpleName);\n        return (newName == _name) ? this : new POJOPropertyBuilder(this, newName);\n    }\n    \n    \n\n    @Override\n    public int compareTo(POJOPropertyBuilder other) {\n        \n        if (_ctorParameters != null) {\n            if (other._ctorParameters == null) {\n                return -1;\n            }\n        } else if (other._ctorParameters != null) {\n            return 1;\n        }\n        \n        return getName().compareTo(other.getName());\n    }\n\n    \n\n    @Override\n    public String getName() {\n        return (_name == null) ? null : _name.getSimpleName();\n    }\n\n    @Override\n    public PropertyName getFullName() {\n        return _name;\n    }\n\n    @Override\n    public boolean hasName(PropertyName name) {\n        return _name.equals(name);\n    }\n\n    @Override\n    public String getInternalName() { return _internalName.getSimpleName(); }\n\n    @Override\n    public PropertyName getWrapperName() {\n        \n        AnnotatedMember member = getPrimaryMember();\n        return (member == null || _annotationIntrospector == null) ? null\n                : _annotationIntrospector.findWrapperName(member);\n    \t\n    }\n\n    @Override\n    public boolean isExplicitlyIncluded() {\n        return _anyExplicits(_fields)\n                || _anyExplicits(_getters)\n                || _anyExplicits(_setters)\n                \n                \n                \n\n                || _anyExplicitNames(_ctorParameters)\n                ;\n    }\n\n    @Override\n    public boolean isExplicitlyNamed() {\n        return _anyExplicitNames(_fields)\n                || _anyExplicitNames(_getters)\n                || _anyExplicitNames(_setters)\n                || _anyExplicitNames(_ctorParameters)\n                ;\n    }\n    \n    \n\n    @Override\n    public boolean hasGetter() { return _getters != null; }\n\n    @Override\n    public boolean hasSetter() { return _setters != null; }\n\n    @Override\n    public boolean hasField() { return _fields != null; }\n\n    @Override\n    public boolean hasConstructorParameter() { return _ctorParameters != null; }\n\n    @Override\n    public boolean couldDeserialize() {\n        return (_ctorParameters != null) || (_setters != null) || (_fields != null);\n    }\n\n    @Override\n    public boolean couldSerialize() {\n        return (_getters != null) || (_fields != null);\n    }\n\n    @Override\n    public AnnotatedMethod getGetter() {\n        \n        Linked<AnnotatedMethod> curr = _getters;\n        if (curr == null) {\n            return null;\n        }\n        Linked<AnnotatedMethod> next = curr.next;\n        if (next == null) {\n            return curr.value;\n        }\n        \n        for (; next != null; next = next.next) {\n            \n            Class<?> currClass = curr.value.getDeclaringClass();\n            Class<?> nextClass = next.value.getDeclaringClass();\n            if (currClass != nextClass) {\n                if (currClass.isAssignableFrom(nextClass)) { \n                    curr = next;\n                    continue;\n                }\n                if (nextClass.isAssignableFrom(currClass)) { \n                    continue;\n                }\n            }\n            \n            int priNext = _getterPriority(next.value);\n            int priCurr = _getterPriority(curr.value);\n\n            if (priNext != priCurr) {\n                if (priNext < priCurr) {\n                    curr = next;\n                }\n                continue;\n            }\n            throw new IllegalArgumentException(\"Conflicting getter definitions for property \\\"\"+getName()+\"\\\": \"\n                    +curr.value.getFullName()+\" vs \"+next.value.getFullName());\n        }\n        \n        _getters = curr.withoutNext();\n        return curr.value;\n    }\n    \n    @Override\n    public AnnotatedMethod getSetter() {\n        \n        Linked<AnnotatedMethod> curr = _setters;\n        if (curr == null) {\n            return null;\n        }\n        Linked<AnnotatedMethod> next = curr.next;\n        if (next == null) {\n            return curr.value;\n        }\n        \n        for (; next != null; next = next.next) {\n            \n            Class<?> currClass = curr.value.getDeclaringClass();\n            Class<?> nextClass = next.value.getDeclaringClass();\n            if (currClass != nextClass) {\n                if (currClass.isAssignableFrom(nextClass)) { \n                    curr = next;\n                    continue;\n                }\n                if (nextClass.isAssignableFrom(currClass)) { \n                    continue;\n                }\n            }\n            AnnotatedMethod nextM = next.value;\n            AnnotatedMethod currM = curr.value;\n\n            \n            int priNext = _setterPriority(nextM);\n            int priCurr = _setterPriority(currM);\n\n            if (priNext != priCurr) {\n                if (priNext < priCurr) {\n                    curr = next;\n                }\n                continue;\n            }\n            \n            if (_annotationIntrospector != null) {\n                AnnotatedMethod pref = _annotationIntrospector.resolveSetterConflict(_config,\n                        currM, nextM);\n                \n                \n                if (pref == currM) {\n                    continue;\n                }\n                if (pref == nextM) {\n                    curr = next;\n                    continue;\n                }\n            }\n            throw new IllegalArgumentException(String.format(\n \"Conflicting setter definitions for property \\\"%s\\\": %s vs %s\",\n getName(), curr.value.getFullName(), next.value.getFullName()));\n        }\n        \n        _setters = curr.withoutNext();\n        return curr.value;\n    }\n\n    @Override\n    public AnnotatedField getField() {\n        if (_fields == null) {\n            return null;\n        }\n        \n        AnnotatedField field = _fields.value;\n        Linked<AnnotatedField> next = _fields.next;\n        for (; next != null; next = next.next) {\n            AnnotatedField nextField = next.value;\n            Class<?> fieldClass = field.getDeclaringClass();\n            Class<?> nextClass = nextField.getDeclaringClass();\n            if (fieldClass != nextClass) {\n                if (fieldClass.isAssignableFrom(nextClass)) { \n                    field = nextField;\n                    continue;\n                }\n                if (nextClass.isAssignableFrom(fieldClass)) { \n                    continue;\n                }\n            }\n            throw new IllegalArgumentException(\"Multiple fields representing property \\\"\"+getName()+\"\\\": \"\n                    +field.getFullName()+\" vs \"+nextField.getFullName());\n        }\n        return field;\n    }\n\n    @Override\n    public AnnotatedParameter getConstructorParameter() {\n        if (_ctorParameters == null) {\n            return null;\n        }\n        \n        Linked<AnnotatedParameter> curr = _ctorParameters;\n        do {\n            if (curr.value.getOwner() instanceof AnnotatedConstructor) {\n                return curr.value;\n            }\n            curr = curr.next;\n        } while (curr != null);\n        return _ctorParameters.value;\n    }\n\n    @Override\n    public Iterator<AnnotatedParameter> getConstructorParameters() {\n        if (_ctorParameters == null) {\n            return ClassUtil.emptyIterator();\n        }\n        return new MemberIterator<AnnotatedParameter>(_ctorParameters);\n    }\n    \n    @Override\n    public AnnotatedMember getAccessor() {\n        AnnotatedMember m = getGetter();\n        if (m == null) {\n            m = getField();\n        }\n        return m;\n    }\n\n    @Override\n    public AnnotatedMember getMutator() {\n        AnnotatedMember m = getConstructorParameter();\n        if (m == null) {\n            m = getSetter();\n            if (m == null) {\n                m = getField();\n            }\n        }\n        return m;\n    }\n\n    @Override\n    public AnnotatedMember getNonConstructorMutator() {\n        AnnotatedMember m = getSetter();\n        if (m == null) {\n            m = getField();\n        }\n        return m;\n    }\n\n    @Override\n    public AnnotatedMember getPrimaryMember() {\n        if (_forSerialization) {\n            return getAccessor();\n        }\n        return getMutator();\n    }\n\n    protected int _getterPriority(AnnotatedMethod m) {\n        final String name = m.getName();\n        \n        if (name.startsWith(\"get\") && name.length() > 3) {\n            \n            return 1;\n        }\n        if (name.startsWith(\"is\") && name.length() > 2) {\n            return 2;\n        }\n        return 3;\n    }\n\n    protected int _setterPriority(AnnotatedMethod m) {\n        final String name = m.getName();\n        if (name.startsWith(\"set\") && name.length() > 3) {\n            \n            return 1;\n        }\n        return 2;\n    }\n\n    \n\n    @Override\n    public Class<?>[] findViews() {\n        return fromMemberAnnotations(new WithMember<Class<?>[]>() {\n            @Override\n            public Class<?>[] withMember(AnnotatedMember member) {\n                return _annotationIntrospector.findViews(member);\n            }\n        });\n    }\n\n    @Override\n    public AnnotationIntrospector.ReferenceProperty findReferenceType() {\n        return fromMemberAnnotations(new WithMember<AnnotationIntrospector.ReferenceProperty>() {\n            @Override\n            public AnnotationIntrospector.ReferenceProperty withMember(AnnotatedMember member) {\n                return _annotationIntrospector.findReferenceType(member);\n            }\n        });\n    }\n\n    @Override\n    public boolean isTypeId() {\n        Boolean b = fromMemberAnnotations(new WithMember<Boolean>() {\n            @Override\n            public Boolean withMember(AnnotatedMember member) {\n                return _annotationIntrospector.isTypeId(member);\n            }\n        });\n        return (b != null) && b.booleanValue();\n    }\n\n    @Override\n    public PropertyMetadata getMetadata() {\n        final Boolean b = _findRequired();\n        final String desc = _findDescription();\n        final Integer idx = _findIndex();\n        final String def = _findDefaultValue();\n        if (b == null && idx == null && def == null) {\n            return (desc == null) ? PropertyMetadata.STD_REQUIRED_OR_OPTIONAL\n                    : PropertyMetadata.STD_REQUIRED_OR_OPTIONAL.withDescription(desc);\n        }\n        return PropertyMetadata.construct(b.booleanValue(), desc, idx, def);\n    }\n\n    protected Boolean _findRequired() {\n       return fromMemberAnnotations(new WithMember<Boolean>() {\n            @Override\n            public Boolean withMember(AnnotatedMember member) {\n                return _annotationIntrospector.hasRequiredMarker(member);\n            }\n        });\n    }\n    \n    protected String _findDescription() {\n        return fromMemberAnnotations(new WithMember<String>() {\n            @Override\n            public String withMember(AnnotatedMember member) {\n                return _annotationIntrospector.findPropertyDescription(member);\n            }\n        });\n    }\n\n    protected Integer _findIndex() {\n        return fromMemberAnnotations(new WithMember<Integer>() {\n            @Override\n            public Integer withMember(AnnotatedMember member) {\n                return _annotationIntrospector.findPropertyIndex(member);\n            }\n        });\n    }\n\n    protected String _findDefaultValue() {\n        return fromMemberAnnotations(new WithMember<String>() {\n            @Override\n            public String withMember(AnnotatedMember member) {\n                return _annotationIntrospector.findPropertyDefaultValue(member);\n            }\n        });\n    }\n    \n    @Override\n    public ObjectIdInfo findObjectIdInfo() {\n        return fromMemberAnnotations(new WithMember<ObjectIdInfo>() {\n            @Override\n            public ObjectIdInfo withMember(AnnotatedMember member) {\n                ObjectIdInfo info = _annotationIntrospector.findObjectIdInfo(member);\n                if (info != null) {\n                    info = _annotationIntrospector.findObjectReferenceInfo(member, info);\n                }\n                return info;\n            }\n        });\n    }\n\n    @Override\n    public JsonInclude.Value findInclusion() {\n        AnnotatedMember a = getAccessor();\n        \n        \n        \n        \n        JsonInclude.Value v = (_annotationIntrospector == null) ?\n                null : _annotationIntrospector.findPropertyInclusion(a);\n        return (v == null) ? JsonInclude.Value.empty() : v;\n    }\n\n    public JsonProperty.Access findAccess() {\n        return fromMemberAnnotationsExcept(new WithMember<JsonProperty.Access>() {\n            @Override\n            public JsonProperty.Access withMember(AnnotatedMember member) {\n                return _annotationIntrospector.findPropertyAccess(member);\n            }\n        }, JsonProperty.Access.AUTO);\n    }\n    \n    \n    \n    public void addField(AnnotatedField a, PropertyName name, boolean explName, boolean visible, boolean ignored) {\n        _fields = new Linked<AnnotatedField>(a, _fields, name, explName, visible, ignored);\n    }\n\n    public void addCtor(AnnotatedParameter a, PropertyName name, boolean explName, boolean visible, boolean ignored) {\n        _ctorParameters = new Linked<AnnotatedParameter>(a, _ctorParameters, name, explName, visible, ignored);\n    }\n\n    public void addGetter(AnnotatedMethod a, PropertyName name, boolean explName, boolean visible, boolean ignored) {\n        _getters = new Linked<AnnotatedMethod>(a, _getters, name, explName, visible, ignored);\n    }\n\n    public void addSetter(AnnotatedMethod a, PropertyName name, boolean explName, boolean visible, boolean ignored) {\n        _setters = new Linked<AnnotatedMethod>(a, _setters, name, explName, visible, ignored);\n    }\n\n    \n    public void addAll(POJOPropertyBuilder src) {\n        _fields = merge(_fields, src._fields);\n        _ctorParameters = merge(_ctorParameters, src._ctorParameters);\n        _getters= merge(_getters, src._getters);\n        _setters = merge(_setters, src._setters);\n    }\n\n    private static <T> Linked<T> merge(Linked<T> chain1, Linked<T> chain2) {\n        if (chain1 == null) {\n            return chain2;\n        }\n        if (chain2 == null) {\n            return chain1;\n        }\n        return chain1.append(chain2);\n    }\n\n    \n\n    \n    public void removeIgnored() {\n        _fields = _removeIgnored(_fields);\n        _getters = _removeIgnored(_getters);\n        _setters = _removeIgnored(_setters);\n        _ctorParameters = _removeIgnored(_ctorParameters);\n    }\n\n    \n    public void removeNonVisible(boolean inferMutators) {\n        \n        JsonProperty.Access acc = findAccess();\n        if (acc == null) {\n            acc = JsonProperty.Access.AUTO;\n        }\n        switch (acc) {\n        case READ_ONLY:\n            \n            _setters = null;\n            _ctorParameters = null;\n            if (!_forSerialization) {\n                _fields = null;\n            }\n            break;\n        case READ_WRITE:\n            \n            break;\n        case WRITE_ONLY:\n            \n            _getters = null;\n            if (_forSerialization) {\n                _fields = null;\n            }\n            break;\n        default:\n        case AUTO: \n            _getters = _removeNonVisible(_getters);\n            _ctorParameters = _removeNonVisible(_ctorParameters);\n    \n            if (!inferMutators || (_getters == null)) {\n                _fields = _removeNonVisible(_fields);\n                _setters = _removeNonVisible(_setters);\n            }\n        }\n    }\n\n    \n    public void removeConstructors() {\n        _ctorParameters = null;\n    }\n    \n    \n    public void trimByVisibility() {\n        _fields = _trimByVisibility(_fields);\n        _getters = _trimByVisibility(_getters);\n        _setters = _trimByVisibility(_setters);\n        _ctorParameters = _trimByVisibility(_ctorParameters);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public void mergeAnnotations(boolean forSerialization) {\n        if (forSerialization) {\n            if (_getters != null) {\n                AnnotationMap ann = _mergeAnnotations(0, _getters, _fields, _ctorParameters, _setters);\n                _getters = _applyAnnotations(_getters, ann);\n            } else if (_fields != null) {\n                AnnotationMap ann = _mergeAnnotations(0, _fields, _ctorParameters, _setters);\n                _fields = _applyAnnotations(_fields, ann);\n            }\n        } else { \n            if (_ctorParameters != null) {\n                AnnotationMap ann = _mergeAnnotations(0, _ctorParameters, _setters, _fields, _getters);\n                _ctorParameters = _applyAnnotations(_ctorParameters, ann);\n            } else if (_setters != null) {\n                AnnotationMap ann = _mergeAnnotations(0, _setters, _fields, _getters);\n                _setters = _applyAnnotations(_setters, ann);\n            } else if (_fields != null) {\n                AnnotationMap ann = _mergeAnnotations(0, _fields, _getters);\n                _fields = _applyAnnotations(_fields, ann);\n            }\n        }\n    }\n\n    private AnnotationMap _mergeAnnotations(int index, Linked<? extends AnnotatedMember>... nodes) {\n        AnnotationMap ann = _getAllAnnotations(nodes[index]);\n        while (++index < nodes.length) {\n            if (nodes[index] != null) {\n              return AnnotationMap.merge(ann, _mergeAnnotations(index, nodes));\n            }\n        }\n        return ann;\n    }\n\n    \n    private <T extends AnnotatedMember> AnnotationMap _getAllAnnotations(Linked<T> node) {\n        AnnotationMap ann = node.value.getAllAnnotations();\n        if (node.next != null) {\n            ann = AnnotationMap.merge(ann, _getAllAnnotations(node.next));\n        }\n        return ann;\n    }\n\n    \n    private <T extends AnnotatedMember> Linked<T> _applyAnnotations(Linked<T> node, AnnotationMap ann) {\n        @SuppressWarnings(\"unchecked\")\n        T value = (T) node.value.withAnnotations(ann);\n        if (node.next != null) {\n            node = node.withNext(_applyAnnotations(node.next, ann));\n        }\n        return node.withValue(value);\n    }\n\n    private <T> Linked<T> _removeIgnored(Linked<T> node) {\n        if (node == null) {\n            return node;\n        }\n        return node.withoutIgnored();\n    }\n\n    private <T> Linked<T> _removeNonVisible(Linked<T> node) {\n        if (node == null) {\n            return node;\n        }\n        return node.withoutNonVisible();\n    }\n\n    private <T> Linked<T> _trimByVisibility(Linked<T> node) {\n        if (node == null) {\n            return node;\n        }\n        return node.trimByVisibility();\n    }\n        \n    \n\n    private <T> boolean _anyExplicits(Linked<T> n) {\n        for (; n != null; n = n.next) {\n            if (n.name != null && n.name.hasSimpleName()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private <T> boolean _anyExplicitNames(Linked<T> n) {\n        for (; n != null; n = n.next) {\n            if (n.name != null && n.isNameExplicit) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean anyVisible() {\n        return _anyVisible(_fields)\n            || _anyVisible(_getters)\n            || _anyVisible(_setters)\n            || _anyVisible(_ctorParameters)\n        ;\n    }\n\n    private <T> boolean _anyVisible(Linked<T> n) {\n        for (; n != null; n = n.next) {\n            if (n.isVisible) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    public boolean anyIgnorals() {\n        return _anyIgnorals(_fields)\n            || _anyIgnorals(_getters)\n            || _anyIgnorals(_setters)\n            || _anyIgnorals(_ctorParameters)\n        ;\n    }\n\n    private <T> boolean _anyIgnorals(Linked<T> n) {\n        for (; n != null; n = n.next) {\n            if (n.isMarkedIgnored) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    public Set<PropertyName> findExplicitNames() {\n        Set<PropertyName> renamed = null;\n        renamed = _findExplicitNames(_fields, renamed);\n        renamed = _findExplicitNames(_getters, renamed);\n        renamed = _findExplicitNames(_setters, renamed);\n        renamed = _findExplicitNames(_ctorParameters, renamed);\n        if (renamed == null) {\n            return Collections.emptySet();\n        }\n        return renamed;\n    }\n\n    \n    public Collection<POJOPropertyBuilder> explode(Collection<PropertyName> newNames) {\n        HashMap<PropertyName,POJOPropertyBuilder> props = new HashMap<PropertyName,POJOPropertyBuilder>();\n        _explode(newNames, props, _fields);\n        _explode(newNames, props, _getters);\n        _explode(newNames, props, _setters);\n        _explode(newNames, props, _ctorParameters);\n        return props.values();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void _explode(Collection<PropertyName> newNames, Map<PropertyName,POJOPropertyBuilder> props, Linked<?> accessors) {\n        final Linked<?> firstAcc = accessors; \n        for (Linked<?> node = accessors; node != null; node = node.next) {\n            PropertyName name = node.name;\n            if (!node.isNameExplicit || name == null) { \n                \n                if (!node.isVisible) {\n                    continue;\n                }\n                \n                throw new IllegalStateException(\"Conflicting/ambiguous property name definitions (implicit name '\"\n                        +_name+\"'): found multiple explicit names: \"\n                        +newNames+\", but also implicit accessor: \"+node);\n            }\n            POJOPropertyBuilder prop = props.get(name);\n            if (prop == null) {\n                prop = new POJOPropertyBuilder(_config, _annotationIntrospector, _forSerialization,\n                        _internalName, name);\n                props.put(name, prop);\n            }\n            \n            if (firstAcc == _fields) {\n                Linked<AnnotatedField> n2 = (Linked<AnnotatedField>) node;\n                prop._fields = n2.withNext(prop._fields);\n            } else if (firstAcc == _getters) {\n                Linked<AnnotatedMethod> n2 = (Linked<AnnotatedMethod>) node;\n                prop._getters = n2.withNext(prop._getters);\n            } else if (firstAcc == _setters) {\n                Linked<AnnotatedMethod> n2 = (Linked<AnnotatedMethod>) node;\n                prop._setters = n2.withNext(prop._setters);\n            } else if (firstAcc == _ctorParameters) {\n                Linked<AnnotatedParameter> n2 = (Linked<AnnotatedParameter>) node;\n                prop._ctorParameters = n2.withNext(prop._ctorParameters);\n            } else {\n                throw new IllegalStateException(\"Internal error: mismatched accessors, property: \"+this);\n            }\n        }\n    }\n    \n    private Set<PropertyName> _findExplicitNames(Linked<? extends AnnotatedMember> node, Set<PropertyName> renamed) {\n        for (; node != null; node = node.next) {\n            \n            if (!node.isNameExplicit || node.name == null) {\n                continue;\n            }\n            if (renamed == null) {\n                renamed = new HashSet<PropertyName>();\n            }\n            renamed.add(node.name);\n        }\n        return renamed;\n    }\n    \n    \n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[Property '\").append(_name)\n          .append(\"'; ctors: \").append(_ctorParameters)\n          .append(\", field(s): \").append(_fields)\n          .append(\", getter(s): \").append(_getters)\n          .append(\", setter(s): \").append(_setters)\n          ;\n        sb.append(\"]\");\n        return sb.toString();\n    }\n    \n    \n\n    \n    protected <T> T fromMemberAnnotations(WithMember<T> func) {\n        T result = null;\n        if (_annotationIntrospector != null) {\n            if (_forSerialization) {\n                if (_getters != null) {\n                    result = func.withMember(_getters.value);\n                }\n            } else {\n                if (_ctorParameters != null) {\n                    result = func.withMember(_ctorParameters.value);\n                }\n                if (result == null && _setters != null) {\n                    result = func.withMember(_setters.value);\n                }\n            }\n            if (result == null && _fields != null) {\n                result = func.withMember(_fields.value);\n            }\n        }\n        return result;\n    }\n\n    protected <T> T fromMemberAnnotationsExcept(WithMember<T> func, T defaultValue) {\n        if (_annotationIntrospector == null) {\n            return null;\n        }\n\n        \n        \n        if (_forSerialization) {\n            if (_getters != null) {\n                T result = func.withMember(_getters.value);\n                if ((result != null) && (result != defaultValue)) {\n                    return result;\n                }\n            }\n            if (_fields != null) {\n                T result = func.withMember(_fields.value);\n                if ((result != null) && (result != defaultValue)) {\n                    return result;\n                }\n            }\n            if (_ctorParameters != null) {\n                T result = func.withMember(_ctorParameters.value);\n                if ((result != null) && (result != defaultValue)) {\n                    return result;\n                }\n            }\n            if (_setters != null) {\n                T result = func.withMember(_setters.value);\n                if ((result != null) && (result != defaultValue)) {\n                    return result;\n                }\n            }\n            return null;\n        }\n        if (_ctorParameters != null) {\n            T result = func.withMember(_ctorParameters.value);\n            if ((result != null) && (result != defaultValue)) {\n                return result;\n            }\n        }\n        if (_setters != null) {\n            T result = func.withMember(_setters.value);\n            if ((result != null) && (result != defaultValue)) {\n                return result;\n            }\n        }\n        if (_fields != null) {\n            T result = func.withMember(_fields.value);\n            if ((result != null) && (result != defaultValue)) {\n                return result;\n            }\n        }\n        if (_getters != null) {\n            T result = func.withMember(_getters.value);\n            if ((result != null) && (result != defaultValue)) {\n                return result;\n            }\n        }\n        return null;\n    }\n    \n    \n\n    private interface WithMember<T> { public T withMember(AnnotatedMember member); } protected static class MemberIterator<T extends AnnotatedMember> implements Iterator<T> {\n        private Linked<T> next; public MemberIterator(Linked<T> first) {\n            next = first;\n        }\n        \n        @Override\n        public boolean hasNext() {\n            return (next != null);\n        }\n\n        @Override\n        public T next() {\n            if (next == null) throw new NoSuchElementException();\n            T result = next.value;\n            next = next.next;\n            return result;\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n        \n    }\n    \n    \n    protected final static class Linked<T> { public final T value; public final Linked<T> next; public final PropertyName name; public final boolean isNameExplicit; public final boolean isVisible; public final boolean isMarkedIgnored; public Linked(T v, Linked<T> n, PropertyName name, boolean explName, boolean visible, boolean ignored) {\n            value = v;\n            next = n;\n            \n            this.name = (name == null || name.isEmpty()) ? null : name;\n\n            if (explName) {\n                if (this.name == null) { \n                    throw new IllegalArgumentException(\"Can not pass true for 'explName' if name is null/empty\");\n                }\n                \n                \n                if (!name.hasSimpleName()) {\n                    explName = false;\n                }\n            }\n            \n            isNameExplicit = explName;\n            isVisible = visible;\n            isMarkedIgnored = ignored;\n        }\n\n        public Linked<T> withoutNext() {\n            if (next == null) {\n                return this;\n            }\n            return new Linked<T>(value, null, name, isNameExplicit, isVisible, isMarkedIgnored);\n        }\n        \n        public Linked<T> withValue(T newValue) {\n            if (newValue == value) {\n                return this;\n            }\n            return new Linked<T>(newValue, next, name, isNameExplicit, isVisible, isMarkedIgnored);\n        }\n        \n        public Linked<T> withNext(Linked<T> newNext) {\n            if (newNext == next) {\n                return this;\n            }\n            return new Linked<T>(value, newNext, name, isNameExplicit, isVisible, isMarkedIgnored);\n        }\n        \n        public Linked<T> withoutIgnored() {\n            if (isMarkedIgnored) {\n                return (next == null) ? null : next.withoutIgnored();\n            }\n            if (next != null) {\n                Linked<T> newNext = next.withoutIgnored();\n                if (newNext != next) {\n                    return withNext(newNext);\n                }\n            }\n            return this;\n        }\n        \n        public Linked<T> withoutNonVisible() {\n            Linked<T> newNext = (next == null) ? null : next.withoutNonVisible();\n            return isVisible ? withNext(newNext) : newNext;\n        }\n\n        \n        protected Linked<T> append(Linked<T> appendable) {\n            if (next == null) {\n                return withNext(appendable);\n            }\n            return withNext(next.append(appendable));\n        }\n\n        public Linked<T> trimByVisibility() {\n            if (next == null) {\n                return this;\n            }\n            Linked<T> newNext = next.trimByVisibility();\n            if (name != null) { \n                if (newNext.name == null) { \n                    return withNext(null);\n                }\n                \n                return withNext(newNext);\n            }\n            if (newNext.name != null) { \n                return newNext;\n            }\n            \n            if (isVisible == newNext.isVisible) { \n                return withNext(newNext);\n            }\n            return isVisible ? withNext(null) : newNext;\n        }\n        \n        @Override\n        public String toString() {\n            String msg = value.toString()+\"[visible=\"+isVisible+\",ignore=\"+isMarkedIgnored\n                    +\",explicitName=\"+isNameExplicit+\"]\";\n            if (next != null) {\n                msg = msg + \", \"+next.toString();\n            }\n            return msg;\n        }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.introspect;\n\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\npublic class POJOPropertyBuilder extends BeanPropertyDefinition implements Comparable<POJOPropertyBuilder> { protected final boolean _forSerialization; protected final MapperConfig<?> _config; protected final AnnotationIntrospector _annotationIntrospector; protected final PropertyName _name; protected final PropertyName _internalName; protected Linked<AnnotatedField> _fields; protected Linked<AnnotatedParameter> _ctorParameters; protected Linked<AnnotatedMethod> _getters; protected Linked<AnnotatedMethod> _setters; public POJOPropertyBuilder(MapperConfig<?> config, AnnotationIntrospector ai, boolean forSerialization, PropertyName internalName) {\n        this(config, ai, forSerialization, internalName, internalName);\n    }\n\n    protected POJOPropertyBuilder(MapperConfig<?> config, AnnotationIntrospector ai, boolean forSerialization, PropertyName internalName, PropertyName name) {\n        _config = config;\n        _annotationIntrospector = ai;\n        _internalName = internalName;\n        _name = name;\n        _forSerialization = forSerialization;\n    }\n\n    public POJOPropertyBuilder(POJOPropertyBuilder src, PropertyName newName) {\n        _config = src._config;\n        _annotationIntrospector = src._annotationIntrospector;\n        _internalName = src._internalName;\n        _name = newName;\n        _fields = src._fields;\n        _ctorParameters = src._ctorParameters;\n        _getters = src._getters;\n        _setters = src._setters;\n        _forSerialization = src._forSerialization;\n    }\n    \n    \n\n    @Override\n    public POJOPropertyBuilder withName(PropertyName newName) {\n        return new POJOPropertyBuilder(this, newName);\n    }\n\n    @Override\n    public POJOPropertyBuilder withSimpleName(String newSimpleName) {\n        PropertyName newName = _name.withSimpleName(newSimpleName);\n        return (newName == _name) ? this : new POJOPropertyBuilder(this, newName);\n    }\n    \n    \n\n    @Override\n    public int compareTo(POJOPropertyBuilder other) {\n        \n        if (_ctorParameters != null) {\n            if (other._ctorParameters == null) {\n                return -1;\n            }\n        } else if (other._ctorParameters != null) {\n            return 1;\n        }\n        \n        return getName().compareTo(other.getName());\n    }\n\n    \n\n    @Override\n    public String getName() {\n        return (_name == null) ? null : _name.getSimpleName();\n    }\n\n    @Override\n    public PropertyName getFullName() {\n        return _name;\n    }\n\n    @Override\n    public boolean hasName(PropertyName name) {\n        return _name.equals(name);\n    }\n\n    @Override\n    public String getInternalName() { return _internalName.getSimpleName(); }\n\n    @Override\n    public PropertyName getWrapperName() {\n        \n        AnnotatedMember member = getPrimaryMember();\n        return (member == null || _annotationIntrospector == null) ? null\n                : _annotationIntrospector.findWrapperName(member);\n    \t\n    }\n\n    @Override\n    public boolean isExplicitlyIncluded() {\n        return _anyExplicits(_fields)\n                || _anyExplicits(_getters)\n                || _anyExplicits(_setters)\n                \n                \n                \n\n                || _anyExplicitNames(_ctorParameters)\n                ;\n    }\n\n    @Override\n    public boolean isExplicitlyNamed() {\n        return _anyExplicitNames(_fields)\n                || _anyExplicitNames(_getters)\n                || _anyExplicitNames(_setters)\n                || _anyExplicitNames(_ctorParameters)\n                ;\n    }\n    \n    \n\n    @Override\n    public boolean hasGetter() { return _getters != null; }\n\n    @Override\n    public boolean hasSetter() { return _setters != null; }\n\n    @Override\n    public boolean hasField() { return _fields != null; }\n\n    @Override\n    public boolean hasConstructorParameter() { return _ctorParameters != null; }\n\n    @Override\n    public boolean couldDeserialize() {\n        return (_ctorParameters != null) || (_setters != null) || (_fields != null);\n    }\n\n    @Override\n    public boolean couldSerialize() {\n        return (_getters != null) || (_fields != null);\n    }\n\n    @Override\n    public AnnotatedMethod getGetter() {\n        \n        Linked<AnnotatedMethod> curr = _getters;\n        if (curr == null) {\n            return null;\n        }\n        Linked<AnnotatedMethod> next = curr.next;\n        if (next == null) {\n            return curr.value;\n        }\n        \n        for (; next != null; next = next.next) {\n            \n            Class<?> currClass = curr.value.getDeclaringClass();\n            Class<?> nextClass = next.value.getDeclaringClass();\n            if (currClass != nextClass) {\n                if (currClass.isAssignableFrom(nextClass)) { \n                    curr = next;\n                    continue;\n                }\n                if (nextClass.isAssignableFrom(currClass)) { \n                    continue;\n                }\n            }\n            \n            int priNext = _getterPriority(next.value);\n            int priCurr = _getterPriority(curr.value);\n\n            if (priNext != priCurr) {\n                if (priNext < priCurr) {\n                    curr = next;\n                }\n                continue;\n            }\n            throw new IllegalArgumentException(\"Conflicting getter definitions for property \\\"\"+getName()+\"\\\": \"\n                    +curr.value.getFullName()+\" vs \"+next.value.getFullName());\n        }\n        \n        _getters = curr.withoutNext();\n        return curr.value;\n    }\n    \n    @Override\n    public AnnotatedMethod getSetter() {\n        \n        Linked<AnnotatedMethod> curr = _setters;\n        if (curr == null) {\n            return null;\n        }\n        Linked<AnnotatedMethod> next = curr.next;\n        if (next == null) {\n            return curr.value;\n        }\n        \n        for (; next != null; next = next.next) {\n            \n            Class<?> currClass = curr.value.getDeclaringClass();\n            Class<?> nextClass = next.value.getDeclaringClass();\n            if (currClass != nextClass) {\n                if (currClass.isAssignableFrom(nextClass)) { \n                    curr = next;\n                    continue;\n                }\n                if (nextClass.isAssignableFrom(currClass)) { \n                    continue;\n                }\n            }\n            AnnotatedMethod nextM = next.value;\n            AnnotatedMethod currM = curr.value;\n\n            \n            int priNext = _setterPriority(nextM);\n            int priCurr = _setterPriority(currM);\n\n            if (priNext != priCurr) {\n                if (priNext < priCurr) {\n                    curr = next;\n                }\n                continue;\n            }\n            \n            if (_annotationIntrospector != null) {\n                AnnotatedMethod pref = _annotationIntrospector.resolveSetterConflict(_config,\n                        currM, nextM);\n                \n                \n                if (pref == currM) {\n                    continue;\n                }\n                if (pref == nextM) {\n                    curr = next;\n                    continue;\n                }\n            }\n            throw new IllegalArgumentException(String.format(\n \"Conflicting setter definitions for property \\\"%s\\\": %s vs %s\",\n getName(), curr.value.getFullName(), next.value.getFullName()));\n        }\n        \n        _setters = curr.withoutNext();\n        return curr.value;\n    }\n\n    @Override\n    public AnnotatedField getField() {\n        if (_fields == null) {\n            return null;\n        }\n        \n        AnnotatedField field = _fields.value;\n        Linked<AnnotatedField> next = _fields.next;\n        for (; next != null; next = next.next) {\n            AnnotatedField nextField = next.value;\n            Class<?> fieldClass = field.getDeclaringClass();\n            Class<?> nextClass = nextField.getDeclaringClass();\n            if (fieldClass != nextClass) {\n                if (fieldClass.isAssignableFrom(nextClass)) { \n                    field = nextField;\n                    continue;\n                }\n                if (nextClass.isAssignableFrom(fieldClass)) { \n                    continue;\n                }\n            }\n            throw new IllegalArgumentException(\"Multiple fields representing property \\\"\"+getName()+\"\\\": \"\n                    +field.getFullName()+\" vs \"+nextField.getFullName());\n        }\n        return field;\n    }\n\n    @Override\n    public AnnotatedParameter getConstructorParameter() {\n        if (_ctorParameters == null) {\n            return null;\n        }\n        \n        Linked<AnnotatedParameter> curr = _ctorParameters;\n        do {\n            if (curr.value.getOwner() instanceof AnnotatedConstructor) {\n                return curr.value;\n            }\n            curr = curr.next;\n        } while (curr != null);\n        return _ctorParameters.value;\n    }\n\n    @Override\n    public Iterator<AnnotatedParameter> getConstructorParameters() {\n        if (_ctorParameters == null) {\n            return ClassUtil.emptyIterator();\n        }\n        return new MemberIterator<AnnotatedParameter>(_ctorParameters);\n    }\n    \n    @Override\n    public AnnotatedMember getAccessor() {\n        AnnotatedMember m = getGetter();\n        if (m == null) {\n            m = getField();\n        }\n        return m;\n    }\n\n    @Override\n    public AnnotatedMember getMutator() {\n        AnnotatedMember m = getConstructorParameter();\n        if (m == null) {\n            m = getSetter();\n            if (m == null) {\n                m = getField();\n            }\n        }\n        return m;\n    }\n\n    @Override\n    public AnnotatedMember getNonConstructorMutator() {\n        AnnotatedMember m = getSetter();\n        if (m == null) {\n            m = getField();\n        }\n        return m;\n    }\n\n    @Override\n    public AnnotatedMember getPrimaryMember() {\n        if (_forSerialization) {\n            return getAccessor();\n        }\n        return getMutator();\n    }\n\n    protected int _getterPriority(AnnotatedMethod m) {\n        final String name = m.getName();\n        \n        if (name.startsWith(\"get\") && name.length() > 3) {\n            \n            return 1;\n        }\n        if (name.startsWith(\"is\") && name.length() > 2) {\n            return 2;\n        }\n        return 3;\n    }\n\n    protected int _setterPriority(AnnotatedMethod m) {\n        final String name = m.getName();\n        if (name.startsWith(\"set\") && name.length() > 3) {\n            \n            return 1;\n        }\n        return 2;\n    }\n\n    \n\n    @Override\n    public Class<?>[] findViews() {\n        return fromMemberAnnotations(new WithMember<Class<?>[]>() {\n            @Override\n            public Class<?>[] withMember(AnnotatedMember member) {\n                return _annotationIntrospector.findViews(member);\n            }\n        });\n    }\n\n    @Override\n    public AnnotationIntrospector.ReferenceProperty findReferenceType() {\n        return fromMemberAnnotations(new WithMember<AnnotationIntrospector.ReferenceProperty>() {\n            @Override\n            public AnnotationIntrospector.ReferenceProperty withMember(AnnotatedMember member) {\n                return _annotationIntrospector.findReferenceType(member);\n            }\n        });\n    }\n\n    @Override\n    public boolean isTypeId() {\n        Boolean b = fromMemberAnnotations(new WithMember<Boolean>() {\n            @Override\n            public Boolean withMember(AnnotatedMember member) {\n                return _annotationIntrospector.isTypeId(member);\n            }\n        });\n        return (b != null) && b.booleanValue();\n    }\n\n    @Override\n    public PropertyMetadata getMetadata() {\n        final Boolean b = _findRequired();\n        final String desc = _findDescription();\n        final Integer idx = _findIndex();\n        final String def = _findDefaultValue();\n        if (b == null && idx == null && def == null) {\n            return (desc == null) ? PropertyMetadata.STD_REQUIRED_OR_OPTIONAL\n                    : PropertyMetadata.STD_REQUIRED_OR_OPTIONAL.withDescription(desc);\n        }\n        return PropertyMetadata.construct(b.booleanValue(), desc, idx, def);\n    }\n\n    protected Boolean _findRequired() {\n       return fromMemberAnnotations(new WithMember<Boolean>() {\n            @Override\n            public Boolean withMember(AnnotatedMember member) {\n                return _annotationIntrospector.hasRequiredMarker(member);\n            }\n        });\n    }\n    \n    protected String _findDescription() {\n        return fromMemberAnnotations(new WithMember<String>() {\n            @Override\n            public String withMember(AnnotatedMember member) {\n                return _annotationIntrospector.findPropertyDescription(member);\n            }\n        });\n    }\n\n    protected Integer _findIndex() {\n        return fromMemberAnnotations(new WithMember<Integer>() {\n            @Override\n            public Integer withMember(AnnotatedMember member) {\n                return _annotationIntrospector.findPropertyIndex(member);\n            }\n        });\n    }\n\n    protected String _findDefaultValue() {\n        return fromMemberAnnotations(new WithMember<String>() {\n            @Override\n            public String withMember(AnnotatedMember member) {\n                return _annotationIntrospector.findPropertyDefaultValue(member);\n            }\n        });\n    }\n    \n    @Override\n    public ObjectIdInfo findObjectIdInfo() {\n        return fromMemberAnnotations(new WithMember<ObjectIdInfo>() {\n            @Override\n            public ObjectIdInfo withMember(AnnotatedMember member) {\n                ObjectIdInfo info = _annotationIntrospector.findObjectIdInfo(member);\n                if (info != null) {\n                    info = _annotationIntrospector.findObjectReferenceInfo(member, info);\n                }\n                return info;\n            }\n        });\n    }\n\n    @Override\n    public JsonInclude.Value findInclusion() {\n        AnnotatedMember a = getAccessor();\n        \n        \n        \n        \n        JsonInclude.Value v = (_annotationIntrospector == null) ?\n                null : _annotationIntrospector.findPropertyInclusion(a);\n        return (v == null) ? JsonInclude.Value.empty() : v;\n    }\n\n    public JsonProperty.Access findAccess() {\n        return fromMemberAnnotationsExcept(new WithMember<JsonProperty.Access>() {\n            @Override\n            public JsonProperty.Access withMember(AnnotatedMember member) {\n                return _annotationIntrospector.findPropertyAccess(member);\n            }\n        }, JsonProperty.Access.AUTO);\n    }\n    \n    \n    \n    public void addField(AnnotatedField a, PropertyName name, boolean explName, boolean visible, boolean ignored) {\n        _fields = new Linked<AnnotatedField>(a, _fields, name, explName, visible, ignored);\n    }\n\n    public void addCtor(AnnotatedParameter a, PropertyName name, boolean explName, boolean visible, boolean ignored) {\n        _ctorParameters = new Linked<AnnotatedParameter>(a, _ctorParameters, name, explName, visible, ignored);\n    }\n\n    public void addGetter(AnnotatedMethod a, PropertyName name, boolean explName, boolean visible, boolean ignored) {\n        _getters = new Linked<AnnotatedMethod>(a, _getters, name, explName, visible, ignored);\n    }\n\n    public void addSetter(AnnotatedMethod a, PropertyName name, boolean explName, boolean visible, boolean ignored) {\n        _setters = new Linked<AnnotatedMethod>(a, _setters, name, explName, visible, ignored);\n    }\n\n    \n    public void addAll(POJOPropertyBuilder src) {\n        _fields = merge(_fields, src._fields);\n        _ctorParameters = merge(_ctorParameters, src._ctorParameters);\n        _getters= merge(_getters, src._getters);\n        _setters = merge(_setters, src._setters);\n    }\n\n    private static <T> Linked<T> merge(Linked<T> chain1, Linked<T> chain2) {\n        if (chain1 == null) {\n            return chain2;\n        }\n        if (chain2 == null) {\n            return chain1;\n        }\n        return chain1.append(chain2);\n    }\n\n    \n\n    \n    public void removeIgnored() {\n        _fields = _removeIgnored(_fields);\n        _getters = _removeIgnored(_getters);\n        _setters = _removeIgnored(_setters);\n        _ctorParameters = _removeIgnored(_ctorParameters);\n    }\n\n    \n    public JsonProperty.Access removeNonVisible(boolean inferMutators) {\n        \n        JsonProperty.Access acc = findAccess();\n        if (acc == null) {\n            acc = JsonProperty.Access.AUTO;\n        }\n        switch (acc) {\n        case READ_ONLY:\n            \n            _setters = null;\n            _ctorParameters = null;\n            if (!_forSerialization) {\n                _fields = null;\n            }\n            break;\n        case READ_WRITE:\n            \n            break;\n        case WRITE_ONLY:\n            \n            _getters = null;\n            if (_forSerialization) {\n                _fields = null;\n            }\n            break;\n        default:\n        case AUTO: \n            _getters = _removeNonVisible(_getters);\n            _ctorParameters = _removeNonVisible(_ctorParameters);\n    \n            if (!inferMutators || (_getters == null)) {\n                _fields = _removeNonVisible(_fields);\n                _setters = _removeNonVisible(_setters);\n            }\n        }\n        return acc;\n    }\n\n    \n    public void removeConstructors() {\n        _ctorParameters = null;\n    }\n    \n    \n    public void trimByVisibility() {\n        _fields = _trimByVisibility(_fields);\n        _getters = _trimByVisibility(_getters);\n        _setters = _trimByVisibility(_setters);\n        _ctorParameters = _trimByVisibility(_ctorParameters);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public void mergeAnnotations(boolean forSerialization) {\n        if (forSerialization) {\n            if (_getters != null) {\n                AnnotationMap ann = _mergeAnnotations(0, _getters, _fields, _ctorParameters, _setters);\n                _getters = _applyAnnotations(_getters, ann);\n            } else if (_fields != null) {\n                AnnotationMap ann = _mergeAnnotations(0, _fields, _ctorParameters, _setters);\n                _fields = _applyAnnotations(_fields, ann);\n            }\n        } else { \n            if (_ctorParameters != null) {\n                AnnotationMap ann = _mergeAnnotations(0, _ctorParameters, _setters, _fields, _getters);\n                _ctorParameters = _applyAnnotations(_ctorParameters, ann);\n            } else if (_setters != null) {\n                AnnotationMap ann = _mergeAnnotations(0, _setters, _fields, _getters);\n                _setters = _applyAnnotations(_setters, ann);\n            } else if (_fields != null) {\n                AnnotationMap ann = _mergeAnnotations(0, _fields, _getters);\n                _fields = _applyAnnotations(_fields, ann);\n            }\n        }\n    }\n\n    private AnnotationMap _mergeAnnotations(int index, Linked<? extends AnnotatedMember>... nodes) {\n        AnnotationMap ann = _getAllAnnotations(nodes[index]);\n        while (++index < nodes.length) {\n            if (nodes[index] != null) {\n              return AnnotationMap.merge(ann, _mergeAnnotations(index, nodes));\n            }\n        }\n        return ann;\n    }\n\n    \n    private <T extends AnnotatedMember> AnnotationMap _getAllAnnotations(Linked<T> node) {\n        AnnotationMap ann = node.value.getAllAnnotations();\n        if (node.next != null) {\n            ann = AnnotationMap.merge(ann, _getAllAnnotations(node.next));\n        }\n        return ann;\n    }\n\n    \n    private <T extends AnnotatedMember> Linked<T> _applyAnnotations(Linked<T> node, AnnotationMap ann) {\n        @SuppressWarnings(\"unchecked\")\n        T value = (T) node.value.withAnnotations(ann);\n        if (node.next != null) {\n            node = node.withNext(_applyAnnotations(node.next, ann));\n        }\n        return node.withValue(value);\n    }\n\n    private <T> Linked<T> _removeIgnored(Linked<T> node) {\n        if (node == null) {\n            return node;\n        }\n        return node.withoutIgnored();\n    }\n\n    private <T> Linked<T> _removeNonVisible(Linked<T> node) {\n        if (node == null) {\n            return node;\n        }\n        return node.withoutNonVisible();\n    }\n\n    private <T> Linked<T> _trimByVisibility(Linked<T> node) {\n        if (node == null) {\n            return node;\n        }\n        return node.trimByVisibility();\n    }\n        \n    \n\n    private <T> boolean _anyExplicits(Linked<T> n) {\n        for (; n != null; n = n.next) {\n            if (n.name != null && n.name.hasSimpleName()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private <T> boolean _anyExplicitNames(Linked<T> n) {\n        for (; n != null; n = n.next) {\n            if (n.name != null && n.isNameExplicit) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean anyVisible() {\n        return _anyVisible(_fields)\n            || _anyVisible(_getters)\n            || _anyVisible(_setters)\n            || _anyVisible(_ctorParameters)\n        ;\n    }\n\n    private <T> boolean _anyVisible(Linked<T> n) {\n        for (; n != null; n = n.next) {\n            if (n.isVisible) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    public boolean anyIgnorals() {\n        return _anyIgnorals(_fields)\n            || _anyIgnorals(_getters)\n            || _anyIgnorals(_setters)\n            || _anyIgnorals(_ctorParameters)\n        ;\n    }\n\n    private <T> boolean _anyIgnorals(Linked<T> n) {\n        for (; n != null; n = n.next) {\n            if (n.isMarkedIgnored) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    public Set<PropertyName> findExplicitNames() {\n        Set<PropertyName> renamed = null;\n        renamed = _findExplicitNames(_fields, renamed);\n        renamed = _findExplicitNames(_getters, renamed);\n        renamed = _findExplicitNames(_setters, renamed);\n        renamed = _findExplicitNames(_ctorParameters, renamed);\n        if (renamed == null) {\n            return Collections.emptySet();\n        }\n        return renamed;\n    }\n\n    \n    public Collection<POJOPropertyBuilder> explode(Collection<PropertyName> newNames) {\n        HashMap<PropertyName,POJOPropertyBuilder> props = new HashMap<PropertyName,POJOPropertyBuilder>();\n        _explode(newNames, props, _fields);\n        _explode(newNames, props, _getters);\n        _explode(newNames, props, _setters);\n        _explode(newNames, props, _ctorParameters);\n        return props.values();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void _explode(Collection<PropertyName> newNames, Map<PropertyName,POJOPropertyBuilder> props, Linked<?> accessors) {\n        final Linked<?> firstAcc = accessors; \n        for (Linked<?> node = accessors; node != null; node = node.next) {\n            PropertyName name = node.name;\n            if (!node.isNameExplicit || name == null) { \n                \n                if (!node.isVisible) {\n                    continue;\n                }\n                \n                throw new IllegalStateException(\"Conflicting/ambiguous property name definitions (implicit name '\"\n                        +_name+\"'): found multiple explicit names: \"\n                        +newNames+\", but also implicit accessor: \"+node);\n            }\n            POJOPropertyBuilder prop = props.get(name);\n            if (prop == null) {\n                prop = new POJOPropertyBuilder(_config, _annotationIntrospector, _forSerialization,\n                        _internalName, name);\n                props.put(name, prop);\n            }\n            \n            if (firstAcc == _fields) {\n                Linked<AnnotatedField> n2 = (Linked<AnnotatedField>) node;\n                prop._fields = n2.withNext(prop._fields);\n            } else if (firstAcc == _getters) {\n                Linked<AnnotatedMethod> n2 = (Linked<AnnotatedMethod>) node;\n                prop._getters = n2.withNext(prop._getters);\n            } else if (firstAcc == _setters) {\n                Linked<AnnotatedMethod> n2 = (Linked<AnnotatedMethod>) node;\n                prop._setters = n2.withNext(prop._setters);\n            } else if (firstAcc == _ctorParameters) {\n                Linked<AnnotatedParameter> n2 = (Linked<AnnotatedParameter>) node;\n                prop._ctorParameters = n2.withNext(prop._ctorParameters);\n            } else {\n                throw new IllegalStateException(\"Internal error: mismatched accessors, property: \"+this);\n            }\n        }\n    }\n    \n    private Set<PropertyName> _findExplicitNames(Linked<? extends AnnotatedMember> node, Set<PropertyName> renamed) {\n        for (; node != null; node = node.next) {\n            \n            if (!node.isNameExplicit || node.name == null) {\n                continue;\n            }\n            if (renamed == null) {\n                renamed = new HashSet<PropertyName>();\n            }\n            renamed.add(node.name);\n        }\n        return renamed;\n    }\n    \n    \n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[Property '\").append(_name)\n          .append(\"'; ctors: \").append(_ctorParameters)\n          .append(\", field(s): \").append(_fields)\n          .append(\", getter(s): \").append(_getters)\n          .append(\", setter(s): \").append(_setters)\n          ;\n        sb.append(\"]\");\n        return sb.toString();\n    }\n    \n    \n\n    \n    protected <T> T fromMemberAnnotations(WithMember<T> func) {\n        T result = null;\n        if (_annotationIntrospector != null) {\n            if (_forSerialization) {\n                if (_getters != null) {\n                    result = func.withMember(_getters.value);\n                }\n            } else {\n                if (_ctorParameters != null) {\n                    result = func.withMember(_ctorParameters.value);\n                }\n                if (result == null && _setters != null) {\n                    result = func.withMember(_setters.value);\n                }\n            }\n            if (result == null && _fields != null) {\n                result = func.withMember(_fields.value);\n            }\n        }\n        return result;\n    }\n\n    protected <T> T fromMemberAnnotationsExcept(WithMember<T> func, T defaultValue) {\n        if (_annotationIntrospector == null) {\n            return null;\n        }\n\n        \n        \n        if (_forSerialization) {\n            if (_getters != null) {\n                T result = func.withMember(_getters.value);\n                if ((result != null) && (result != defaultValue)) {\n                    return result;\n                }\n            }\n            if (_fields != null) {\n                T result = func.withMember(_fields.value);\n                if ((result != null) && (result != defaultValue)) {\n                    return result;\n                }\n            }\n            if (_ctorParameters != null) {\n                T result = func.withMember(_ctorParameters.value);\n                if ((result != null) && (result != defaultValue)) {\n                    return result;\n                }\n            }\n            if (_setters != null) {\n                T result = func.withMember(_setters.value);\n                if ((result != null) && (result != defaultValue)) {\n                    return result;\n                }\n            }\n            return null;\n        }\n        if (_ctorParameters != null) {\n            T result = func.withMember(_ctorParameters.value);\n            if ((result != null) && (result != defaultValue)) {\n                return result;\n            }\n        }\n        if (_setters != null) {\n            T result = func.withMember(_setters.value);\n            if ((result != null) && (result != defaultValue)) {\n                return result;\n            }\n        }\n        if (_fields != null) {\n            T result = func.withMember(_fields.value);\n            if ((result != null) && (result != defaultValue)) {\n                return result;\n            }\n        }\n        if (_getters != null) {\n            T result = func.withMember(_getters.value);\n            if ((result != null) && (result != defaultValue)) {\n                return result;\n            }\n        }\n        return null;\n    }\n    \n    \n\n    private interface WithMember<T> { public T withMember(AnnotatedMember member); } protected static class MemberIterator<T extends AnnotatedMember> implements Iterator<T> {\n        private Linked<T> next; public MemberIterator(Linked<T> first) {\n            next = first;\n        }\n        \n        @Override\n        public boolean hasNext() {\n            return (next != null);\n        }\n\n        @Override\n        public T next() {\n            if (next == null) throw new NoSuchElementException();\n            T result = next.value;\n            next = next.next;\n            return result;\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n        \n    }\n    \n    \n    protected final static class Linked<T> { public final T value; public final Linked<T> next; public final PropertyName name; public final boolean isNameExplicit; public final boolean isVisible; public final boolean isMarkedIgnored; public Linked(T v, Linked<T> n, PropertyName name, boolean explName, boolean visible, boolean ignored) {\n            value = v;\n            next = n;\n            \n            this.name = (name == null || name.isEmpty()) ? null : name;\n\n            if (explName) {\n                if (this.name == null) { \n                    throw new IllegalArgumentException(\"Can not pass true for 'explName' if name is null/empty\");\n                }\n                \n                \n                if (!name.hasSimpleName()) {\n                    explName = false;\n                }\n            }\n            \n            isNameExplicit = explName;\n            isVisible = visible;\n            isMarkedIgnored = ignored;\n        }\n\n        public Linked<T> withoutNext() {\n            if (next == null) {\n                return this;\n            }\n            return new Linked<T>(value, null, name, isNameExplicit, isVisible, isMarkedIgnored);\n        }\n        \n        public Linked<T> withValue(T newValue) {\n            if (newValue == value) {\n                return this;\n            }\n            return new Linked<T>(newValue, next, name, isNameExplicit, isVisible, isMarkedIgnored);\n        }\n        \n        public Linked<T> withNext(Linked<T> newNext) {\n            if (newNext == next) {\n                return this;\n            }\n            return new Linked<T>(value, newNext, name, isNameExplicit, isVisible, isMarkedIgnored);\n        }\n        \n        public Linked<T> withoutIgnored() {\n            if (isMarkedIgnored) {\n                return (next == null) ? null : next.withoutIgnored();\n            }\n            if (next != null) {\n                Linked<T> newNext = next.withoutIgnored();\n                if (newNext != next) {\n                    return withNext(newNext);\n                }\n            }\n            return this;\n        }\n        \n        public Linked<T> withoutNonVisible() {\n            Linked<T> newNext = (next == null) ? null : next.withoutNonVisible();\n            return isVisible ? withNext(newNext) : newNext;\n        }\n\n        \n        protected Linked<T> append(Linked<T> appendable) {\n            if (next == null) {\n                return withNext(appendable);\n            }\n            return withNext(next.append(appendable));\n        }\n\n        public Linked<T> trimByVisibility() {\n            if (next == null) {\n                return this;\n            }\n            Linked<T> newNext = next.trimByVisibility();\n            if (name != null) { \n                if (newNext.name == null) { \n                    return withNext(null);\n                }\n                \n                return withNext(newNext);\n            }\n            if (newNext.name != null) { \n                return newNext;\n            }\n            \n            if (isVisible == newNext.isVisible) { \n                return withNext(newNext);\n            }\n            return isVisible ? withNext(null) : newNext;\n        }\n        \n        @Override\n        public String toString() {\n            String msg = value.toString()+\"[visible=\"+isVisible+\",ignore=\"+isMarkedIgnored\n                    +\",explicitName=\"+isNameExplicit+\"]\";\n            if (next != null) {\n                msg = msg + \", \"+next.toString();\n            }\n            return msg;\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public class POJOPropertyBuilder extends BeanPropertyDefinition implements Comparable<POJOPropertyBuilder> { protected final boolean _forSerialization; protected final MapperConfig<?> _config; protected final AnnotationIntrospector _annotationIntrospector; protected final PropertyName _name; protected final PropertyName _internalName; protected Linked<AnnotatedField> _fields; protected Linked<AnnotatedParameter> _ctorParameters; protected Linked<AnnotatedMethod> _getters; protected Linked<AnnotatedMethod> _setters; public POJOPropertyBuilder(MapperConfig<?> config, AnnotationIntrospector ai, boolean forSerialization, PropertyName internalName)",
        "protected POJOPropertyBuilder(MapperConfig<?> config, AnnotationIntrospector ai, boolean forSerialization, PropertyName internalName, PropertyName name)",
        "public POJOPropertyBuilder(POJOPropertyBuilder src, PropertyName newName)",
        "public POJOPropertyBuilder withName(PropertyName newName)",
        "public POJOPropertyBuilder withSimpleName(String newSimpleName)",
        "public int compareTo(POJOPropertyBuilder other)",
        "public String getName()",
        "public PropertyName getFullName()",
        "public boolean hasName(PropertyName name)",
        "public String getInternalName()",
        "public PropertyName getWrapperName()",
        "public boolean isExplicitlyIncluded()",
        "public boolean isExplicitlyNamed()",
        "public boolean hasGetter()",
        "public boolean hasSetter()",
        "public boolean hasField()",
        "public boolean hasConstructorParameter()",
        "public boolean couldDeserialize()",
        "public boolean couldSerialize()",
        "public AnnotatedMethod getGetter()",
        "public AnnotatedMethod getSetter()",
        "public AnnotatedField getField()",
        "public AnnotatedParameter getConstructorParameter()",
        "public Iterator<AnnotatedParameter> getConstructorParameters()",
        "public AnnotatedMember getAccessor()",
        "public AnnotatedMember getMutator()",
        "public AnnotatedMember getNonConstructorMutator()",
        "public AnnotatedMember getPrimaryMember()",
        "protected int _getterPriority(AnnotatedMethod m)",
        "protected int _setterPriority(AnnotatedMethod m)",
        "public Class<?>[] findViews()",
        "public Class<?>[] withMember(AnnotatedMember member)",
        "public AnnotationIntrospector.ReferenceProperty findReferenceType()",
        "public AnnotationIntrospector.ReferenceProperty withMember(AnnotatedMember member)",
        "public boolean isTypeId()",
        "public Boolean withMember(AnnotatedMember member)",
        "public PropertyMetadata getMetadata()",
        "protected Boolean _findRequired()",
        "public Boolean withMember(AnnotatedMember member)",
        "protected String _findDescription()",
        "public String withMember(AnnotatedMember member)",
        "protected Integer _findIndex()",
        "public Integer withMember(AnnotatedMember member)",
        "protected String _findDefaultValue()",
        "public String withMember(AnnotatedMember member)",
        "public ObjectIdInfo findObjectIdInfo()",
        "public ObjectIdInfo withMember(AnnotatedMember member)",
        "public JsonInclude.Value findInclusion()",
        "public JsonProperty.Access findAccess()",
        "public JsonProperty.Access withMember(AnnotatedMember member)",
        "public void addField(AnnotatedField a, PropertyName name, boolean explName, boolean visible, boolean ignored)",
        "public void addCtor(AnnotatedParameter a, PropertyName name, boolean explName, boolean visible, boolean ignored)",
        "public void addGetter(AnnotatedMethod a, PropertyName name, boolean explName, boolean visible, boolean ignored)",
        "public void addSetter(AnnotatedMethod a, PropertyName name, boolean explName, boolean visible, boolean ignored)",
        "public void addAll(POJOPropertyBuilder src)",
        "private static <T> Linked<T> merge(Linked<T> chain1, Linked<T> chain2)",
        "public void removeIgnored()",
        "public void removeNonVisible(boolean inferMutators)",
        "public void removeConstructors()",
        "public void trimByVisibility()",
        "public void mergeAnnotations(boolean forSerialization)",
        "private AnnotationMap _mergeAnnotations(int index, Linked<? extends AnnotatedMember>... nodes)",
        "private <T extends AnnotatedMember> AnnotationMap _getAllAnnotations(Linked<T> node)",
        "private <T extends AnnotatedMember> Linked<T> _applyAnnotations(Linked<T> node, AnnotationMap ann)",
        "private <T> Linked<T> _removeIgnored(Linked<T> node)",
        "private <T> Linked<T> _removeNonVisible(Linked<T> node)",
        "private <T> Linked<T> _trimByVisibility(Linked<T> node)",
        "private <T> boolean _anyExplicits(Linked<T> n)",
        "private <T> boolean _anyExplicitNames(Linked<T> n)",
        "public boolean anyVisible()",
        "private <T> boolean _anyVisible(Linked<T> n)",
        "public boolean anyIgnorals()",
        "private <T> boolean _anyIgnorals(Linked<T> n)",
        "public Set<PropertyName> findExplicitNames()",
        "public Collection<POJOPropertyBuilder> explode(Collection<PropertyName> newNames)",
        "private void _explode(Collection<PropertyName> newNames, Map<PropertyName,POJOPropertyBuilder> props, Linked<?> accessors)",
        "private Set<PropertyName> _findExplicitNames(Linked<? extends AnnotatedMember> node, Set<PropertyName> renamed)",
        "public String toString()",
        "protected <T> T fromMemberAnnotations(WithMember<T> func)",
        "protected <T> T fromMemberAnnotationsExcept(WithMember<T> func, T defaultValue)",
        "private interface WithMember<T> { public T withMember(AnnotatedMember member); } protected static class MemberIterator<T extends AnnotatedMember> implements Iterator<T>",
        "private Linked<T> next; public MemberIterator(Linked<T> first)",
        "public boolean hasNext()",
        "public T next()",
        "public void remove()",
        "protected final static class Linked<T> { public final T value; public final Linked<T> next; public final PropertyName name; public final boolean isNameExplicit; public final boolean isVisible; public final boolean isMarkedIgnored; public Linked(T v, Linked<T> n, PropertyName name, boolean explName, boolean visible, boolean ignored)",
        "public Linked<T> withoutNext()",
        "public Linked<T> withValue(T newValue)",
        "public Linked<T> withNext(Linked<T> newNext)",
        "public Linked<T> withoutIgnored()",
        "public Linked<T> withoutNonVisible()",
        "protected Linked<T> append(Linked<T> appendable)",
        "public Linked<T> trimByVisibility()",
        "public String toString()"
      ],
      "fixed_signatures": [
        "public class POJOPropertyBuilder extends BeanPropertyDefinition implements Comparable<POJOPropertyBuilder> { protected final boolean _forSerialization; protected final MapperConfig<?> _config; protected final AnnotationIntrospector _annotationIntrospector; protected final PropertyName _name; protected final PropertyName _internalName; protected Linked<AnnotatedField> _fields; protected Linked<AnnotatedParameter> _ctorParameters; protected Linked<AnnotatedMethod> _getters; protected Linked<AnnotatedMethod> _setters; public POJOPropertyBuilder(MapperConfig<?> config, AnnotationIntrospector ai, boolean forSerialization, PropertyName internalName)",
        "protected POJOPropertyBuilder(MapperConfig<?> config, AnnotationIntrospector ai, boolean forSerialization, PropertyName internalName, PropertyName name)",
        "public POJOPropertyBuilder(POJOPropertyBuilder src, PropertyName newName)",
        "public POJOPropertyBuilder withName(PropertyName newName)",
        "public POJOPropertyBuilder withSimpleName(String newSimpleName)",
        "public int compareTo(POJOPropertyBuilder other)",
        "public String getName()",
        "public PropertyName getFullName()",
        "public boolean hasName(PropertyName name)",
        "public String getInternalName()",
        "public PropertyName getWrapperName()",
        "public boolean isExplicitlyIncluded()",
        "public boolean isExplicitlyNamed()",
        "public boolean hasGetter()",
        "public boolean hasSetter()",
        "public boolean hasField()",
        "public boolean hasConstructorParameter()",
        "public boolean couldDeserialize()",
        "public boolean couldSerialize()",
        "public AnnotatedMethod getGetter()",
        "public AnnotatedMethod getSetter()",
        "public AnnotatedField getField()",
        "public AnnotatedParameter getConstructorParameter()",
        "public Iterator<AnnotatedParameter> getConstructorParameters()",
        "public AnnotatedMember getAccessor()",
        "public AnnotatedMember getMutator()",
        "public AnnotatedMember getNonConstructorMutator()",
        "public AnnotatedMember getPrimaryMember()",
        "protected int _getterPriority(AnnotatedMethod m)",
        "protected int _setterPriority(AnnotatedMethod m)",
        "public Class<?>[] findViews()",
        "public Class<?>[] withMember(AnnotatedMember member)",
        "public AnnotationIntrospector.ReferenceProperty findReferenceType()",
        "public AnnotationIntrospector.ReferenceProperty withMember(AnnotatedMember member)",
        "public boolean isTypeId()",
        "public Boolean withMember(AnnotatedMember member)",
        "public PropertyMetadata getMetadata()",
        "protected Boolean _findRequired()",
        "public Boolean withMember(AnnotatedMember member)",
        "protected String _findDescription()",
        "public String withMember(AnnotatedMember member)",
        "protected Integer _findIndex()",
        "public Integer withMember(AnnotatedMember member)",
        "protected String _findDefaultValue()",
        "public String withMember(AnnotatedMember member)",
        "public ObjectIdInfo findObjectIdInfo()",
        "public ObjectIdInfo withMember(AnnotatedMember member)",
        "public JsonInclude.Value findInclusion()",
        "public JsonProperty.Access findAccess()",
        "public JsonProperty.Access withMember(AnnotatedMember member)",
        "public void addField(AnnotatedField a, PropertyName name, boolean explName, boolean visible, boolean ignored)",
        "public void addCtor(AnnotatedParameter a, PropertyName name, boolean explName, boolean visible, boolean ignored)",
        "public void addGetter(AnnotatedMethod a, PropertyName name, boolean explName, boolean visible, boolean ignored)",
        "public void addSetter(AnnotatedMethod a, PropertyName name, boolean explName, boolean visible, boolean ignored)",
        "public void addAll(POJOPropertyBuilder src)",
        "private static <T> Linked<T> merge(Linked<T> chain1, Linked<T> chain2)",
        "public void removeIgnored()",
        "public JsonProperty.Access removeNonVisible(boolean inferMutators)",
        "public void removeConstructors()",
        "public void trimByVisibility()",
        "public void mergeAnnotations(boolean forSerialization)",
        "private AnnotationMap _mergeAnnotations(int index, Linked<? extends AnnotatedMember>... nodes)",
        "private <T extends AnnotatedMember> AnnotationMap _getAllAnnotations(Linked<T> node)",
        "private <T extends AnnotatedMember> Linked<T> _applyAnnotations(Linked<T> node, AnnotationMap ann)",
        "private <T> Linked<T> _removeIgnored(Linked<T> node)",
        "private <T> Linked<T> _removeNonVisible(Linked<T> node)",
        "private <T> Linked<T> _trimByVisibility(Linked<T> node)",
        "private <T> boolean _anyExplicits(Linked<T> n)",
        "private <T> boolean _anyExplicitNames(Linked<T> n)",
        "public boolean anyVisible()",
        "private <T> boolean _anyVisible(Linked<T> n)",
        "public boolean anyIgnorals()",
        "private <T> boolean _anyIgnorals(Linked<T> n)",
        "public Set<PropertyName> findExplicitNames()",
        "public Collection<POJOPropertyBuilder> explode(Collection<PropertyName> newNames)",
        "private void _explode(Collection<PropertyName> newNames, Map<PropertyName,POJOPropertyBuilder> props, Linked<?> accessors)",
        "private Set<PropertyName> _findExplicitNames(Linked<? extends AnnotatedMember> node, Set<PropertyName> renamed)",
        "public String toString()",
        "protected <T> T fromMemberAnnotations(WithMember<T> func)",
        "protected <T> T fromMemberAnnotationsExcept(WithMember<T> func, T defaultValue)",
        "private interface WithMember<T> { public T withMember(AnnotatedMember member); } protected static class MemberIterator<T extends AnnotatedMember> implements Iterator<T>",
        "private Linked<T> next; public MemberIterator(Linked<T> first)",
        "public boolean hasNext()",
        "public T next()",
        "public void remove()",
        "protected final static class Linked<T> { public final T value; public final Linked<T> next; public final PropertyName name; public final boolean isNameExplicit; public final boolean isVisible; public final boolean isMarkedIgnored; public Linked(T v, Linked<T> n, PropertyName name, boolean explName, boolean visible, boolean ignored)",
        "public Linked<T> withoutNext()",
        "public Linked<T> withValue(T newValue)",
        "public Linked<T> withNext(Linked<T> newNext)",
        "public Linked<T> withoutIgnored()",
        "public Linked<T> withoutNonVisible()",
        "protected Linked<T> append(Linked<T> appendable)",
        "public Linked<T> trimByVisibility()",
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "  public void removeNonVisible(boolean inferMutators) {\n  \n  JsonProperty.Access acc = findAccess();\n  if (acc == null) {\n  acc = JsonProperty.Access.AUTO;\n  }\n  switch (acc) {\n  case READ_ONLY:\n  \n  _setters = null;\n  _ctorParameters = null;\n  if (!_forSerialization) {\n  _fields = null;\n  }\n  break;\n  case READ_WRITE:\n  \n  break;\n  case WRITE_ONLY:\n  \n  _getters = null;\n  if (_forSerialization) {\n  _fields = null;\n  }\n  break;\n  default:\n  case AUTO: \n  _getters = _removeNonVisible(_getters);\n  _ctorParameters = _removeNonVisible(_ctorParameters);\n  \n  if (!inferMutators || (_getters == null)) {\n  _fields = _removeNonVisible(_fields);\n  _setters = _removeNonVisible(_setters);\n  }\n  }\n  }",
          "fixed_method": "  public JsonProperty.Access removeNonVisible(boolean inferMutators) {\n  \n  JsonProperty.Access acc = findAccess();\n  if (acc == null) {\n  acc = JsonProperty.Access.AUTO;\n  }\n  switch (acc) {\n  case READ_ONLY:\n  \n  _setters = null;\n  _ctorParameters = null;\n  if (!_forSerialization) {\n  _fields = null;\n  }\n  break;\n  case READ_WRITE:\n  \n  break;\n  case WRITE_ONLY:\n  \n  _getters = null;\n  if (_forSerialization) {\n  _fields = null;\n  }\n  break;\n  default:\n  case AUTO: \n  _getters = _removeNonVisible(_getters);\n  _ctorParameters = _removeNonVisible(_ctorParameters);\n  \n  if (!inferMutators || (_getters == null)) {\n  _fields = _removeNonVisible(_fields);\n  _setters = _removeNonVisible(_setters);\n  }\n  }\n  return acc;\n  }",
          "diff": [
            "@@ -641,7 +641,7 @@",
            "      * @param inferMutators Whether mutators can be \"pulled in\" by visible\n",
            "      *    accessors or not. \n",
            "      */\n",
            "-    public void removeNonVisible(boolean inferMutators)\n",
            "+    public JsonProperty.Access removeNonVisible(boolean inferMutators)\n",
            "     {\n",
            "         /* 07-Jun-2015, tatu: With 2.6, we will allow optional definition\n",
            "          *  of explicit access type for property; if not \"AUTO\", it will\n",
            "@@ -680,6 +680,7 @@",
            "                 _setters = _removeNonVisible(_setters);\n",
            "             }\n",
            "         }\n",
            "+        return acc;\n",
            "     }\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
