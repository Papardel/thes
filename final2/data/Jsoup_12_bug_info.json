{
  "bug_id": "12",
  "failed_tests": {
    "org.jsoup.select.SelectorTest": [
      {
        "methodName": "testByAttributeRegexCombined",
        "error": "org.jsoup.select.Selector$SelectorParseException",
        "message": "Could not parse query '=x|y]': unexpected token at '=x|y]'",
        "fail_line": "        Elements els = doc.select(\"div table[class~=x|y]\");",
        "test_source": "",
        "stack": [
          "Selector.findElements line 187, Selector.select line 113, Selector.select line 84, Selector.combinator line 149, Selector.select line 126, Selector.select line 84, Element.select line 199, SelectorTest.testByAttributeRegexCombined line 129"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/select/Selector.java",
      "buggy_full_code": "package org.jsoup.select;\n\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.parser.TokenQueue;\n\nimport java.util.Collection;\nimport java.util.LinkedHashSet;\n\n\npublic class Selector { private final static String[] combinators = {\",\", \">\", \"+\", \"~\", \" \"}; private final Element root; private final LinkedHashSet<Element> elements; private final String query; private final TokenQueue tq; private Selector(String query, Element root) {\n        Validate.notNull(query);\n        query = query.trim();\n        Validate.notEmpty(query);\n        Validate.notNull(root);\n\n        this.elements = new LinkedHashSet<Element>();\n        this.query = query;\n        this.root = root;\n        this.tq = new TokenQueue(query);\n    }\n\n    \n    public static Elements select(String query, Element root) {\n        return new Selector(query, root).select();\n    }\n\n    \n    public static Elements select(String query, Iterable<Element> roots) {\n        Validate.notEmpty(query);\n        Validate.notNull(roots);\n        LinkedHashSet<Element> elements = new LinkedHashSet<Element>();\n\n        for (Element root : roots) {\n            elements.addAll(select(query, root));\n        }\n        return new Elements(elements);\n    }\n\n    private Elements select() {\n        tq.consumeWhitespace();\n        \n        if (tq.matchesAny(combinators)) { \n            elements.add(root);\n            combinator(tq.consume());\n        } else if (tq.matches(\":has(\")) {\n            elements.addAll(root.getAllElements());\n        } else {\n            addElements(findElements()); \n        }            \n               \n        while (!tq.isEmpty()) {\n            \n            boolean seenWhite = tq.consumeWhitespace();\n            \n            if (tq.matchChomp(\",\")) { \n                while (!tq.isEmpty()) {\n                    String subQuery = tq.chompTo(\",\");\n                    elements.addAll(select(subQuery, root));\n                }\n            } else if (tq.matchesAny(combinators)) {\n                combinator(tq.consume());\n            } else if (seenWhite) {\n                combinator(' ');\n            } else { \n                Elements candidates = findElements(); \n                intersectElements(filterForSelf(elements, candidates));\n            }\n        }\n        return new Elements(elements);\n    }\n    \n    private void combinator(char combinator) {\n        tq.consumeWhitespace();\n        String subQuery = tq.consumeToAny(combinators);\n        \n        Elements output;\n        if (combinator == '>')\n            output = filterForChildren(elements, select(subQuery, elements));\n        else if (combinator == ' ')\n            output = filterForDescendants(elements, select(subQuery, elements));\n        else if (combinator == '+')\n            output = filterForAdjacentSiblings(elements, select(subQuery, root));\n        else if (combinator == '~')\n            output = filterForGeneralSiblings(elements, select(subQuery, root));\n        else\n            throw new IllegalStateException(\"Unknown combinator: \" + combinator);\n        \n        elements.clear(); elements.addAll(output);\n    }\n\n    \n    private Elements findElements() {\n        if (tq.matchChomp(\"#\")) {\n            return byId();\n        } else if (tq.matchChomp(\".\")) {\n            return byClass();\n        } else if (tq.matchesWord()) {\n            return byTag();\n        } else if (tq.matches(\"[\")) {\n            return byAttribute();\n        } else if (tq.matchChomp(\"*\")) {\n            return allElements();\n        } else if (tq.matchChomp(\":lt(\")) {\n            return indexLessThan();\n        } else if (tq.matchChomp(\":gt(\")) {\n            return indexGreaterThan();\n        } else if (tq.matchChomp(\":eq(\")) {\n            return indexEquals();\n        } else if (tq.matches(\":has(\")) {\n            return has();\n        } else if (tq.matches(\":contains(\")) {\n            return contains(false);\n        } else if (tq.matches(\":containsOwn(\")) {\n            return contains(true);\n        } else if (tq.matches(\":matches(\")) {\n            return matches(false);\n        } else if (tq.matches(\":matchesOwn(\")) {\n            return matches(true);\n        } else if (tq.matches(\":not(\")) {\n            return not();\n        } else { \n            throw new SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n        }\n    }\n    \n    private void addElements(Collection<Element> add) {\n        elements.addAll(add);\n    }\n    \n    private void intersectElements(Collection<Element> intersect) {\n        elements.retainAll(intersect);\n    }\n\n    private Elements byId() {\n        String id = tq.consumeCssIdentifier();\n        Validate.notEmpty(id);\n\n        Element found = root.getElementById(id);\n        Elements byId = new Elements();\n        if(found != null)\n            byId.add(found);\n        return byId;\n    }\n\n    private Elements byClass() {\n        String className = tq.consumeCssIdentifier();\n        Validate.notEmpty(className);\n\n        return root.getElementsByClass(className);\n    }\n\n    private Elements byTag() {\n        String tagName = tq.consumeElementSelector();\n        Validate.notEmpty(tagName);\n        \n        \n        if (tagName.contains(\"|\"))\n            tagName = tagName.replace(\"|\", \":\");\n        return root.getElementsByTag(tagName);\n    }\n\n    private Elements byAttribute() {\n        TokenQueue cq = new TokenQueue(tq.chompBalanced('[', ']')); \n        String key = cq.consumeToAny(\"=\", \"!=\", \"^=\", \"$=\", \"*=\", \"~=\"); \n        Validate.notEmpty(key);\n        cq.consumeWhitespace();\n\n        if (cq.isEmpty()) {\n            return key.startsWith(\"^\") ? root.getElementsByAttributeStarting(key.substring(1)) : root.getElementsByAttribute(key);\n        } else {\n            if (cq.matchChomp(\"=\"))\n                return root.getElementsByAttributeValue(key, cq.remainder());\n\n            else if (cq.matchChomp(\"!=\"))\n                return root.getElementsByAttributeValueNot(key, cq.remainder());\n\n            else if (cq.matchChomp(\"^=\"))\n                return root.getElementsByAttributeValueStarting(key, cq.remainder());\n\n            else if (cq.matchChomp(\"$=\"))\n                return root.getElementsByAttributeValueEnding(key, cq.remainder());\n\n            else if (cq.matchChomp(\"*=\"))\n                return root.getElementsByAttributeValueContaining(key, cq.remainder());\n            \n            else if (cq.matchChomp(\"~=\"))\n                return root.getElementsByAttributeValueMatching(key, cq.remainder());\n            \n            else\n                throw new SelectorParseException(\"Could not parse attribute query '%s': unexpected token at '%s'\", query, cq.remainder());\n        }\n    }\n\n    private Elements allElements() {\n        return root.getAllElements();\n    }\n    \n    \n    private Elements indexLessThan() {\n        return root.getElementsByIndexLessThan(consumeIndex());\n    }\n    \n    private Elements indexGreaterThan() {\n        return root.getElementsByIndexGreaterThan(consumeIndex());\n    }\n    \n    private Elements indexEquals() {\n        return root.getElementsByIndexEquals(consumeIndex());\n    }\n\n    private int consumeIndex() {\n        String indexS = tq.chompTo(\")\").trim();\n        Validate.isTrue(StringUtil.isNumeric(indexS), \"Index must be numeric\");\n        return Integer.parseInt(indexS);\n    }\n\n    \n    private Elements has() {\n        tq.consume(\":has\");\n        String subQuery = tq.chompBalanced('(',')');\n        Validate.notEmpty(subQuery, \":has(el) subselect must not be empty\");\n\n        return filterForParentsOfDescendants(elements, select(subQuery, elements));\n    }\n    \n    \n    private Elements contains(boolean own) {\n        tq.consume(own ? \":containsOwn\" : \":contains\");\n        String searchText = TokenQueue.unescape(tq.chompBalanced('(',')'));\n        Validate.notEmpty(searchText, \":contains(text) query must not be empty\");\n        \n        return own ? root.getElementsContainingOwnText(searchText) : root.getElementsContainingText(searchText);\n    }\n    \n    \n    private Elements matches(boolean own) {\n        tq.consume(own? \":matchesOwn\" : \":matches\");\n        String regex = tq.chompBalanced('(', ')'); \n        Validate.notEmpty(regex, \":matches(regex) query must not be empty\");\n        \n        return own ? root.getElementsMatchingOwnText(regex) : root.getElementsMatchingText(regex);\n    }\n\n    \n    private Elements not() {\n        tq.consume(\":not\");\n        String subQuery = tq.chompBalanced('(', ')');\n        Validate.notEmpty(subQuery, \":not(selector) subselect must not be empty\");\n\n        return filterOut(root.getAllElements(), select(subQuery, root));\n    }\n\n    \n    private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates) {\n        Elements children = new Elements();\n        CHILD: for (Element c : candidates) {\n            for (Element p : parents) {\n                if (c.parent() != null && c.parent().equals(p)) {\n                    children.add(c);\n                    continue CHILD;\n                }\n            }\n        }\n        return children;\n    }\n    \n    \n    \n    private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates) {\n        Elements children = new Elements();\n        CHILD: for (Element c : candidates) {\n            for (Element p : parents) {\n                if (c.equals(p)) {\n                    continue CHILD;\n                }\n            }\n            children.add(c);\n        }\n        return children;\n    }\n\n    \n    private static Elements filterForParentsOfDescendants(Collection<Element> parents, Collection<Element> children) {\n        Elements filteredParents = new Elements();\n        for (Element p : parents) {\n            for (Element c : children) {\n                if (c.parents().contains(p)) {\n                    filteredParents.add(p);\n                }\n            }\n        }\n        return filteredParents;\n    }\n    \n    \n    private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates) {\n        Elements siblings = new Elements();\n        SIBLING: for (Element c: candidates) {\n            for (Element e: elements) {\n                if (!e.parent().equals(c.parent()))\n                    continue;\n                Element previousSib = c.previousElementSibling();\n                if (previousSib != null && previousSib.equals(e)) {\n                    siblings.add(c);\n                    continue SIBLING;\n                }\n            }\n        }\n        return siblings;\n    }\n    \n    \n    private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates) {\n        Elements output = new Elements();\n        SIBLING: for (Element c: candidates) {\n            for (Element e: elements) {\n                if (!e.parent().equals(c.parent()))\n                    continue;\n                int ePos = e.elementSiblingIndex();\n                int cPos = c.elementSiblingIndex();\n                if (cPos > ePos) {\n                    output.add(c);\n                    continue SIBLING;\n                }\n            }\n        }\n        return output;\n    }\n    \n    \n    private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates) {\n        Elements children = new Elements();\n        CHILD: for (Element c : candidates) {\n            for (Element p : parents) {\n                if (c.equals(p)) {\n                    children.add(c);\n                    continue CHILD;\n                }\n            }   \n        }\n        return children;\n    }\n\n    \n    static Elements filterOut(Collection<Element> elements, Collection<Element> outs) {\n        Elements output = new Elements();\n        for (Element el: elements) {\n            boolean found = false;\n            for (Element out: outs) {\n                if (el.equals(out)) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found)\n                output.add(el);\n        }\n        return output;\n    }\n\n    public static class SelectorParseException extends IllegalStateException { public SelectorParseException(String msg, Object... params) {\n            super(String.format(msg, params));\n        }\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.select;\n\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.parser.TokenQueue;\n\nimport java.util.Collection;\nimport java.util.LinkedHashSet;\n\n\npublic class Selector { private final static String[] combinators = {\",\", \">\", \"+\", \"~\", \" \"}; private final Element root; private final LinkedHashSet<Element> elements; private final String query; private final TokenQueue tq; private Selector(String query, Element root) {\n        Validate.notNull(query);\n        query = query.trim();\n        Validate.notEmpty(query);\n        Validate.notNull(root);\n\n        this.elements = new LinkedHashSet<Element>();\n        this.query = query;\n        this.root = root;\n        this.tq = new TokenQueue(query);\n    }\n\n    \n    public static Elements select(String query, Element root) {\n        return new Selector(query, root).select();\n    }\n\n    \n    public static Elements select(String query, Iterable<Element> roots) {\n        Validate.notEmpty(query);\n        Validate.notNull(roots);\n        LinkedHashSet<Element> elements = new LinkedHashSet<Element>();\n\n        for (Element root : roots) {\n            elements.addAll(select(query, root));\n        }\n        return new Elements(elements);\n    }\n\n    private Elements select() {\n        tq.consumeWhitespace();\n        \n        if (tq.matchesAny(combinators)) { \n            elements.add(root);\n            combinator(tq.consume());\n        } else if (tq.matches(\":has(\")) {\n            elements.addAll(root.getAllElements());\n        } else {\n            addElements(findElements()); \n        }            \n               \n        while (!tq.isEmpty()) {\n            \n            boolean seenWhite = tq.consumeWhitespace();\n            \n            if (tq.matchChomp(\",\")) { \n                while (!tq.isEmpty()) {\n                    String subQuery = tq.chompTo(\",\");\n                    elements.addAll(select(subQuery, root));\n                }\n            } else if (tq.matchesAny(combinators)) {\n                combinator(tq.consume());\n            } else if (seenWhite) {\n                combinator(' ');\n            } else { \n                Elements candidates = findElements(); \n                intersectElements(filterForSelf(elements, candidates));\n            }\n        }\n        return new Elements(elements);\n    }\n    \n    private void combinator(char combinator) {\n        tq.consumeWhitespace();\n        String subQuery = consumeSubQuery(); \n        \n        Elements output;\n        if (combinator == '>')\n            output = filterForChildren(elements, select(subQuery, elements));\n        else if (combinator == ' ')\n            output = filterForDescendants(elements, select(subQuery, elements));\n        else if (combinator == '+')\n            output = filterForAdjacentSiblings(elements, select(subQuery, root));\n        else if (combinator == '~')\n            output = filterForGeneralSiblings(elements, select(subQuery, root));\n        else\n            throw new IllegalStateException(\"Unknown combinator: \" + combinator);\n        \n        elements.clear(); elements.addAll(output);\n    }\n\n    private String consumeSubQuery() {\n        StringBuilder sq = new StringBuilder();\n        while (!tq.isEmpty()) {\n            if (tq.matches(\"(\"))\n                sq.append(\"(\").append(tq.chompBalanced('(', ')')).append(\")\");\n            else if (tq.matches(\"[\"))\n                sq.append(\"[\").append(tq.chompBalanced('[', ']')).append(\"]\");\n            else if (tq.matchesAny(combinators))\n                break;\n            else\n                sq.append(tq.consume());\n        }\n        return sq.toString();\n    }\n    \n    private Elements findElements() {\n        if (tq.matchChomp(\"#\")) {\n            return byId();\n        } else if (tq.matchChomp(\".\")) {\n            return byClass();\n        } else if (tq.matchesWord()) {\n            return byTag();\n        } else if (tq.matches(\"[\")) {\n            return byAttribute();\n        } else if (tq.matchChomp(\"*\")) {\n            return allElements();\n        } else if (tq.matchChomp(\":lt(\")) {\n            return indexLessThan();\n        } else if (tq.matchChomp(\":gt(\")) {\n            return indexGreaterThan();\n        } else if (tq.matchChomp(\":eq(\")) {\n            return indexEquals();\n        } else if (tq.matches(\":has(\")) {\n            return has();\n        } else if (tq.matches(\":contains(\")) {\n            return contains(false);\n        } else if (tq.matches(\":containsOwn(\")) {\n            return contains(true);\n        } else if (tq.matches(\":matches(\")) {\n            return matches(false);\n        } else if (tq.matches(\":matchesOwn(\")) {\n            return matches(true);\n        } else if (tq.matches(\":not(\")) {\n            return not();\n        } else { \n            throw new SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n        }\n    }\n    \n    private void addElements(Collection<Element> add) {\n        elements.addAll(add);\n    }\n    \n    private void intersectElements(Collection<Element> intersect) {\n        elements.retainAll(intersect);\n    }\n\n    private Elements byId() {\n        String id = tq.consumeCssIdentifier();\n        Validate.notEmpty(id);\n\n        Element found = root.getElementById(id);\n        Elements byId = new Elements();\n        if(found != null)\n            byId.add(found);\n        return byId;\n    }\n\n    private Elements byClass() {\n        String className = tq.consumeCssIdentifier();\n        Validate.notEmpty(className);\n\n        return root.getElementsByClass(className);\n    }\n\n    private Elements byTag() {\n        String tagName = tq.consumeElementSelector();\n        Validate.notEmpty(tagName);\n        \n        \n        if (tagName.contains(\"|\"))\n            tagName = tagName.replace(\"|\", \":\");\n        return root.getElementsByTag(tagName);\n    }\n\n    private Elements byAttribute() {\n        TokenQueue cq = new TokenQueue(tq.chompBalanced('[', ']')); \n        String key = cq.consumeToAny(\"=\", \"!=\", \"^=\", \"$=\", \"*=\", \"~=\"); \n        Validate.notEmpty(key);\n        cq.consumeWhitespace();\n\n        if (cq.isEmpty()) {\n            return key.startsWith(\"^\") ? root.getElementsByAttributeStarting(key.substring(1)) : root.getElementsByAttribute(key);\n        } else {\n            if (cq.matchChomp(\"=\"))\n                return root.getElementsByAttributeValue(key, cq.remainder());\n\n            else if (cq.matchChomp(\"!=\"))\n                return root.getElementsByAttributeValueNot(key, cq.remainder());\n\n            else if (cq.matchChomp(\"^=\"))\n                return root.getElementsByAttributeValueStarting(key, cq.remainder());\n\n            else if (cq.matchChomp(\"$=\"))\n                return root.getElementsByAttributeValueEnding(key, cq.remainder());\n\n            else if (cq.matchChomp(\"*=\"))\n                return root.getElementsByAttributeValueContaining(key, cq.remainder());\n            \n            else if (cq.matchChomp(\"~=\"))\n                return root.getElementsByAttributeValueMatching(key, cq.remainder());\n            \n            else\n                throw new SelectorParseException(\"Could not parse attribute query '%s': unexpected token at '%s'\", query, cq.remainder());\n        }\n    }\n\n    private Elements allElements() {\n        return root.getAllElements();\n    }\n    \n    \n    private Elements indexLessThan() {\n        return root.getElementsByIndexLessThan(consumeIndex());\n    }\n    \n    private Elements indexGreaterThan() {\n        return root.getElementsByIndexGreaterThan(consumeIndex());\n    }\n    \n    private Elements indexEquals() {\n        return root.getElementsByIndexEquals(consumeIndex());\n    }\n\n    private int consumeIndex() {\n        String indexS = tq.chompTo(\")\").trim();\n        Validate.isTrue(StringUtil.isNumeric(indexS), \"Index must be numeric\");\n        return Integer.parseInt(indexS);\n    }\n\n    \n    private Elements has() {\n        tq.consume(\":has\");\n        String subQuery = tq.chompBalanced('(',')');\n        Validate.notEmpty(subQuery, \":has(el) subselect must not be empty\");\n\n        return filterForParentsOfDescendants(elements, select(subQuery, elements));\n    }\n    \n    \n    private Elements contains(boolean own) {\n        tq.consume(own ? \":containsOwn\" : \":contains\");\n        String searchText = TokenQueue.unescape(tq.chompBalanced('(',')'));\n        Validate.notEmpty(searchText, \":contains(text) query must not be empty\");\n        \n        return own ? root.getElementsContainingOwnText(searchText) : root.getElementsContainingText(searchText);\n    }\n    \n    \n    private Elements matches(boolean own) {\n        tq.consume(own? \":matchesOwn\" : \":matches\");\n        String regex = tq.chompBalanced('(', ')'); \n        Validate.notEmpty(regex, \":matches(regex) query must not be empty\");\n        \n        return own ? root.getElementsMatchingOwnText(regex) : root.getElementsMatchingText(regex);\n    }\n\n    \n    private Elements not() {\n        tq.consume(\":not\");\n        String subQuery = tq.chompBalanced('(', ')');\n        Validate.notEmpty(subQuery, \":not(selector) subselect must not be empty\");\n\n        return filterOut(root.getAllElements(), select(subQuery, root));\n    }\n\n    \n    private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates) {\n        Elements children = new Elements();\n        CHILD: for (Element c : candidates) {\n            for (Element p : parents) {\n                if (c.parent() != null && c.parent().equals(p)) {\n                    children.add(c);\n                    continue CHILD;\n                }\n            }\n        }\n        return children;\n    }\n    \n    \n    \n    private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates) {\n        Elements children = new Elements();\n        CHILD: for (Element c : candidates) {\n            for (Element p : parents) {\n                if (c.equals(p)) {\n                    continue CHILD;\n                }\n            }\n            children.add(c);\n        }\n        return children;\n    }\n\n    \n    private static Elements filterForParentsOfDescendants(Collection<Element> parents, Collection<Element> children) {\n        Elements filteredParents = new Elements();\n        for (Element p : parents) {\n            for (Element c : children) {\n                if (c.parents().contains(p)) {\n                    filteredParents.add(p);\n                }\n            }\n        }\n        return filteredParents;\n    }\n    \n    \n    private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates) {\n        Elements siblings = new Elements();\n        SIBLING: for (Element c: candidates) {\n            for (Element e: elements) {\n                if (!e.parent().equals(c.parent()))\n                    continue;\n                Element previousSib = c.previousElementSibling();\n                if (previousSib != null && previousSib.equals(e)) {\n                    siblings.add(c);\n                    continue SIBLING;\n                }\n            }\n        }\n        return siblings;\n    }\n    \n    \n    private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates) {\n        Elements output = new Elements();\n        SIBLING: for (Element c: candidates) {\n            for (Element e: elements) {\n                if (!e.parent().equals(c.parent()))\n                    continue;\n                int ePos = e.elementSiblingIndex();\n                int cPos = c.elementSiblingIndex();\n                if (cPos > ePos) {\n                    output.add(c);\n                    continue SIBLING;\n                }\n            }\n        }\n        return output;\n    }\n    \n    \n    private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates) {\n        Elements children = new Elements();\n        CHILD: for (Element c : candidates) {\n            for (Element p : parents) {\n                if (c.equals(p)) {\n                    children.add(c);\n                    continue CHILD;\n                }\n            }   \n        }\n        return children;\n    }\n\n    \n    static Elements filterOut(Collection<Element> elements, Collection<Element> outs) {\n        Elements output = new Elements();\n        for (Element el: elements) {\n            boolean found = false;\n            for (Element out: outs) {\n                if (el.equals(out)) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found)\n                output.add(el);\n        }\n        return output;\n    }\n\n    public static class SelectorParseException extends IllegalStateException { public SelectorParseException(String msg, Object... params) {\n            super(String.format(msg, params));\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public static Elements select(String query, Element root)",
        "public static Elements select(String query, Iterable<Element> roots)",
        "private Elements select()",
        "private void combinator(char combinator)",
        "private Elements findElements()",
        "private void addElements(Collection<Element> add)",
        "private void intersectElements(Collection<Element> intersect)",
        "private Elements byId()",
        "private Elements byClass()",
        "private Elements byTag()",
        "private Elements byAttribute()",
        "private Elements allElements()",
        "private Elements indexLessThan()",
        "private Elements indexGreaterThan()",
        "private Elements indexEquals()",
        "private int consumeIndex()",
        "private Elements has()",
        "private Elements contains(boolean own)",
        "private Elements matches(boolean own)",
        "private Elements not()",
        "private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates)",
        "private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates)",
        "private static Elements filterForParentsOfDescendants(Collection<Element> parents, Collection<Element> children)",
        "private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates)",
        "private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates)",
        "private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates)",
        "static Elements filterOut(Collection<Element> elements, Collection<Element> outs)",
        "public static class SelectorParseException extends IllegalStateException { public SelectorParseException(String msg, Object... params)"
      ],
      "fixed_signatures": [
        "public static Elements select(String query, Element root)",
        "public static Elements select(String query, Iterable<Element> roots)",
        "private Elements select()",
        "private void combinator(char combinator)",
        "private String consumeSubQuery()",
        "private Elements findElements()",
        "private void addElements(Collection<Element> add)",
        "private void intersectElements(Collection<Element> intersect)",
        "private Elements byId()",
        "private Elements byClass()",
        "private Elements byTag()",
        "private Elements byAttribute()",
        "private Elements allElements()",
        "private Elements indexLessThan()",
        "private Elements indexGreaterThan()",
        "private Elements indexEquals()",
        "private int consumeIndex()",
        "private Elements has()",
        "private Elements contains(boolean own)",
        "private Elements matches(boolean own)",
        "private Elements not()",
        "private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates)",
        "private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates)",
        "private static Elements filterForParentsOfDescendants(Collection<Element> parents, Collection<Element> children)",
        "private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates)",
        "private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates)",
        "private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates)",
        "static Elements filterOut(Collection<Element> elements, Collection<Element> outs)",
        "public static class SelectorParseException extends IllegalStateException { public SelectorParseException(String msg, Object... params)"
      ],
      "methods": [
        {
          "buggy_method": "  private void combinator(char combinator) {\n  tq.consumeWhitespace();\n  String subQuery = tq.consumeToAny(combinators);\n  \n  Elements output;\n  if (combinator == '>')\n  output = filterForChildren(elements, select(subQuery, elements));\n  else if (combinator == ' ')\n  output = filterForDescendants(elements, select(subQuery, elements));\n  else if (combinator == '+')\n  output = filterForAdjacentSiblings(elements, select(subQuery, root));\n  else if (combinator == '~')\n  output = filterForGeneralSiblings(elements, select(subQuery, root));\n  else\n  throw new IllegalStateException(\"Unknown combinator: \" + combinator);\n  \n  elements.clear(); elements.addAll(output);\n  }",
          "fixed_method": "  private void combinator(char combinator) {\n  tq.consumeWhitespace();\n  String subQuery = consumeSubQuery(); \n  \n  Elements output;\n  if (combinator == '>')\n  output = filterForChildren(elements, select(subQuery, elements));\n  else if (combinator == ' ')\n  output = filterForDescendants(elements, select(subQuery, elements));\n  else if (combinator == '+')\n  output = filterForAdjacentSiblings(elements, select(subQuery, root));\n  else if (combinator == '~')\n  output = filterForGeneralSiblings(elements, select(subQuery, root));\n  else\n  throw new IllegalStateException(\"Unknown combinator: \" + combinator);\n  \n  elements.clear(); elements.addAll(output);\n  }",
          "diff": [
            "@@ -136,7 +136,7 @@",
            "     \n",
            "     private void combinator(char combinator) {\n",
            "         tq.consumeWhitespace();\n",
            "-        String subQuery = tq.consumeToAny(combinators);\n",
            "+        String subQuery = consumeSubQuery(); // support multi > childs\n",
            "         \n",
            "         Elements output;\n",
            "         if (combinator == '>')\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  private Elements findElements() {\n  if (tq.matchChomp(\"#\")) {\n  return byId();\n  } else if (tq.matchChomp(\".\")) {\n  return byClass();\n  } else if (tq.matchesWord()) {\n  return byTag();\n  } else if (tq.matches(\"[\")) {\n  return byAttribute();\n  } else if (tq.matchChomp(\"*\")) {\n  return allElements();\n  } else if (tq.matchChomp(\":lt(\")) {\n  return indexLessThan();\n  } else if (tq.matchChomp(\":gt(\")) {\n  return indexGreaterThan();\n  } else if (tq.matchChomp(\":eq(\")) {\n  return indexEquals();\n  } else if (tq.matches(\":has(\")) {\n  return has();\n  } else if (tq.matches(\":contains(\")) {\n  return contains(false);\n  } else if (tq.matches(\":containsOwn(\")) {\n  return contains(true);\n  } else if (tq.matches(\":matches(\")) {\n  return matches(false);\n  } else if (tq.matches(\":matchesOwn(\")) {\n  return matches(true);\n  } else if (tq.matches(\":not(\")) {\n  return not();\n  } else { \n  throw new SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n  }\n  }",
          "fixed_method": "  private String consumeSubQuery() {\n  StringBuilder sq = new StringBuilder();\n  while (!tq.isEmpty()) {\n  if (tq.matches(\"(\"))\n  sq.append(\"(\").append(tq.chompBalanced('(', ')')).append(\")\");\n  else if (tq.matches(\"[\"))\n  sq.append(\"[\").append(tq.chompBalanced('[', ']')).append(\"]\");\n  else if (tq.matchesAny(combinators))\n  break;\n  else\n  sq.append(tq.consume());\n  }\n  return sq.toString();\n  }",
          "diff": [
            "@@ -153,6 +153,20 @@",
            "         elements.clear(); elements.addAll(output);\n",
            "     }\n",
            " \n",
            "+    private String consumeSubQuery() {\n",
            "+        StringBuilder sq = new StringBuilder();\n",
            "+        while (!tq.isEmpty()) {\n",
            "+            if (tq.matches(\"(\"))\n",
            "+                sq.append(\"(\").append(tq.chompBalanced('(', ')')).append(\")\");\n",
            "+            else if (tq.matches(\"[\"))\n",
            "+                sq.append(\"[\").append(tq.chompBalanced('[', ']')).append(\"]\");\n",
            "+            else if (tq.matchesAny(combinators))\n",
            "+                break;\n",
            "+            else\n",
            "+                sq.append(tq.consume());\n",
            "+        }\n",
            "+        return sq.toString();\n",
            "+    }\n",
            "     \n",
            "     private Elements findElements() {\n",
            "         if (tq.matchChomp(\"#\")) {\n"
          ],
          "changed_lines": 14
        }
      ]
    }
  ]
}
