{
  "bug_id": "80",
  "failed_tests": {
    "org.jsoup.parser.XmlTreeBuilderTest": [
      {
        "methodName": "handlesDodgyXmlDecl",
        "error": "java.lang.IndexOutOfBoundsException",
        "message": "Index 0 out of bounds for length 0",
        "fail_line": "        Document doc = Jsoup.parse(xml, \"\", Parser.xmlParser());",
        "test_source": "  public void handlesDodgyXmlDecl() {\n  String xml = \"<?xml version='1.0'><val>One</val>\";\n  Document doc = Jsoup.parse(xml, \"\", Parser.xmlParser());\n  assertEquals(\"One\", doc.select(\"val\").text());\n  }",
        "stack": [
          "Element.child line 254, XmlTreeBuilder.insert line 91, XmlTreeBuilder.process line 49, TreeBuilder.runParser line 52, TreeBuilder.parse line 45, Parser.parseInput line 34, Jsoup.parse line 45, XmlTreeBuilderTest.handlesDodgyXmlDecl line 227"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/parser/XmlTreeBuilder.java",
      "buggy_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.Jsoup;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.*;\n\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.List;\n\n\npublic class XmlTreeBuilder extends TreeBuilder { ParseSettings defaultSettings() {\n        return ParseSettings.preserveCase;\n    }\n\n    Document parse(Reader input, String baseUri) {\n        return parse(input, baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);\n    }\n\n    Document parse(String input, String baseUri) {\n        return parse(new StringReader(input), baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);\n    }\n\n    @Override\n    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        super.initialiseParse(input, baseUri, errors, settings);\n        stack.add(doc); \n        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        \n        switch (token.type) {\n            case StartTag:\n                insert(token.asStartTag());\n                break;\n            case EndTag:\n                popStackToClose(token.asEndTag());\n                break;\n            case Comment:\n                insert(token.asComment());\n                break;\n            case Character:\n                insert(token.asCharacter());\n                break;\n            case Doctype:\n                insert(token.asDoctype());\n                break;\n            case EOF: \n                break;\n            default:\n                Validate.fail(\"Unexpected token type: \" + token.type);\n        }\n        return true;\n    }\n\n    private void insertNode(Node node) {\n        currentElement().appendChild(node);\n    }\n\n    Element insert(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        \n        Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes));\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (!tag.isKnownTag()) \n                tag.setSelfClosing();\n        } else {\n            stack.add(el);\n        }\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData());\n        Node insert = comment;\n        if (commentToken.bogus) { \n            \n            String data = comment.getData();\n            if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n                Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n                    Element el = doc.child(0);\n                    insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(\"!\"));\n                    insert.attributes().addAll(el.attributes());\n            }\n        }\n        insertNode(insert);\n    }\n\n    void insert(Token.Character token) {\n        final String data = token.getData();\n        insertNode(token.isCData() ? new CDataNode(data) : new TextNode(data));\n    }\n\n    void insert(Token.Doctype d) {\n        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier());\n        doctypeNode.setPubSysKey(d.getPubSysKey());\n        insertNode(doctypeNode);\n    }\n\n    \n    private void popStackToClose(Token.EndTag endTag) {\n        String elName = settings.normalizeTag(endTag.tagName);\n        Element firstFound = null;\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                firstFound = next;\n                break;\n            }\n        }\n        if (firstFound == null)\n            return; \n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next == firstFound)\n                break;\n        }\n    }\n\n    List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n        runParser();\n        return doc.childNodes();\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.Jsoup;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.*;\n\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.List;\n\n\npublic class XmlTreeBuilder extends TreeBuilder { ParseSettings defaultSettings() {\n        return ParseSettings.preserveCase;\n    }\n\n    Document parse(Reader input, String baseUri) {\n        return parse(input, baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);\n    }\n\n    Document parse(String input, String baseUri) {\n        return parse(new StringReader(input), baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);\n    }\n\n    @Override\n    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        super.initialiseParse(input, baseUri, errors, settings);\n        stack.add(doc); \n        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        \n        switch (token.type) {\n            case StartTag:\n                insert(token.asStartTag());\n                break;\n            case EndTag:\n                popStackToClose(token.asEndTag());\n                break;\n            case Comment:\n                insert(token.asComment());\n                break;\n            case Character:\n                insert(token.asCharacter());\n                break;\n            case Doctype:\n                insert(token.asDoctype());\n                break;\n            case EOF: \n                break;\n            default:\n                Validate.fail(\"Unexpected token type: \" + token.type);\n        }\n        return true;\n    }\n\n    private void insertNode(Node node) {\n        currentElement().appendChild(node);\n    }\n\n    Element insert(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        \n        Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes));\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (!tag.isKnownTag()) \n                tag.setSelfClosing();\n        } else {\n            stack.add(el);\n        }\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData());\n        Node insert = comment;\n        if (commentToken.bogus) { \n            \n            String data = comment.getData();\n            if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n                Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n                if (doc.childNodeSize() > 0) {\n                    Element el = doc.child(0);\n                    insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(\"!\"));\n                    insert.attributes().addAll(el.attributes());\n                } \n            }\n        }\n        insertNode(insert);\n    }\n\n    void insert(Token.Character token) {\n        final String data = token.getData();\n        insertNode(token.isCData() ? new CDataNode(data) : new TextNode(data));\n    }\n\n    void insert(Token.Doctype d) {\n        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier());\n        doctypeNode.setPubSysKey(d.getPubSysKey());\n        insertNode(doctypeNode);\n    }\n\n    \n    private void popStackToClose(Token.EndTag endTag) {\n        String elName = settings.normalizeTag(endTag.tagName);\n        Element firstFound = null;\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                firstFound = next;\n                break;\n            }\n        }\n        if (firstFound == null)\n            return; \n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next == firstFound)\n                break;\n        }\n    }\n\n    List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n        runParser();\n        return doc.childNodes();\n    }\n}\n",
      "buggy_signatures": [
        "public class XmlTreeBuilder extends TreeBuilder { ParseSettings defaultSettings()",
        "protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings)",
        "protected boolean process(Token token)",
        "private void insertNode(Node node)",
        "private void popStackToClose(Token.EndTag endTag)"
      ],
      "fixed_signatures": [
        "public class XmlTreeBuilder extends TreeBuilder { ParseSettings defaultSettings()",
        "protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings)",
        "protected boolean process(Token token)",
        "private void insertNode(Node node)",
        "private void popStackToClose(Token.EndTag endTag)"
      ],
      "methods": [
        {
          "buggy_method": "  private void insertNode(Node node) {\n  currentElement().appendChild(node);\n  }",
          "fixed_method": "  private void insertNode(Node node) {\n  currentElement().appendChild(node);\n  }",
          "diff": [
            "@@ -88,9 +88,11 @@",
            "             String data = comment.getData();\n",
            "             if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n",
            "                 Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n",
            "+                if (doc.childNodeSize() > 0) {\n",
            "                     Element el = doc.child(0);\n",
            "                     insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(\"!\"));\n",
            "                     insert.attributes().addAll(el.attributes());\n",
            "+                } // else, we couldn't parse it as a decl, so leave as a comment\n",
            "             }\n",
            "         }\n",
            "         insertNode(insert);\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
