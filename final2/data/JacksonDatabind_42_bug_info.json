{
  "bug_id": "42",
  "failed_tests": {
    "com.fasterxml.jackson.databind.deser.TestJdkTypes": [
      {
        "methodName": "testLocale",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected same:<> was not:<null>",
        "fail_line": "        assertSame(Locale.ROOT, loc);",
        "test_source": "  public void testLocale() throws IOException {\n  assertEquals(new Locale(\"en\"), MAPPER.readValue(quote(\"en\"), Locale.class));\n  assertEquals(new Locale(\"es\", \"ES\"), MAPPER.readValue(quote(\"es_ES\"), Locale.class));\n  assertEquals(new Locale(\"FI\", \"fi\", \"savo\"),\n  MAPPER.readValue(quote(\"fi_FI_savo\"), Locale.class));\n  // [databind#1123]\n  Locale loc = MAPPER.readValue(quote(\"\"), Locale.class);\n  assertSame(Locale.ROOT, loc);\n  }",
        "stack": [
          "TestJdkTypes.testLocale line 150"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.Currency;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport java.util.regex.Pattern;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.exc.InvalidFormatException;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\n@SuppressWarnings(\"serial\")\npublic abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T> { public static Class<?>[] types() {\n        return new Class<?>[] {\n            File.class,\n            URL.class,\n            URI.class,\n            Class.class,\n            JavaType.class,\n            Currency.class,\n            Pattern.class,\n            Locale.class,\n            Charset.class,\n            TimeZone.class,\n            InetAddress.class,\n            InetSocketAddress.class,\n        };\n    }\n    \n    \n    \n    protected FromStringDeserializer(Class<?> vc) {\n        super(vc);\n    }\n\n    \n    public static Std findDeserializer(Class<?> rawType) {\n        int kind = 0;\n        if (rawType == File.class) {\n            kind = Std.STD_FILE;\n        } else if (rawType == URL.class) {\n            kind = Std.STD_URL;\n        } else if (rawType == URI.class) {\n            kind = Std.STD_URI;\n        } else if (rawType == Class.class) {\n            kind = Std.STD_CLASS;\n        } else if (rawType == JavaType.class) {\n            kind = Std.STD_JAVA_TYPE;\n        } else if (rawType == Currency.class) {\n            kind = Std.STD_CURRENCY;\n        } else if (rawType == Pattern.class) {\n            kind = Std.STD_PATTERN;\n        } else if (rawType == Locale.class) {\n            kind = Std.STD_LOCALE;\n        } else if (rawType == Charset.class) {\n            kind = Std.STD_CHARSET;\n        } else if (rawType == TimeZone.class) {\n            kind = Std.STD_TIME_ZONE;\n        } else if (rawType == InetAddress.class) {\n            kind = Std.STD_INET_ADDRESS;\n        } else if (rawType == InetSocketAddress.class) {\n            kind = Std.STD_INET_SOCKET_ADDRESS;\n        } else {\n            return null;\n        }\n        return new Std(rawType, kind);\n    }\n    \n    \n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public T deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        \n        if (jp.getCurrentToken() == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n            jp.nextToken();\n            final T value = deserialize(jp, ctxt);\n            if (jp.nextToken() != JsonToken.END_ARRAY) {\n                throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \n                                \"Attempted to unwrap single value array for single '\" + _valueClass.getName() + \"' value but there was more than a single value in the array\");\n            }\n            return value;\n        }\n        \n        String text = jp.getValueAsString();\n        if (text != null) { \n            if (text.length() == 0 || (text = text.trim()).length() == 0) {\n                \n                return _deserializeFromEmptyString();\n            }\n            Exception cause = null;\n            try {\n                T result = _deserialize(text, ctxt);\n                if (result != null) {\n                    return result;\n                }\n            } catch (IllegalArgumentException iae) {\n                cause = iae;\n            }\n            String msg = \"not a valid textual representation\";\n            if (cause != null) {\n                String m2 = cause.getMessage();\n                if (m2 != null) {\n                    msg = msg + \", problem: \"+m2;\n                }\n            }\n            JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n            if (cause != null) {\n                e.initCause(cause);\n            }\n            throw e;\n            \n        }\n        if (jp.getCurrentToken() == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            \n            Object ob = jp.getEmbeddedObject();\n            if (ob == null) {\n                return null;\n            }\n            if (_valueClass.isAssignableFrom(ob.getClass())) {\n                return (T) ob;\n            }\n            return _deserializeEmbedded(ob, ctxt);\n        }\n        throw ctxt.mappingException(_valueClass);\n    }\n        \n    protected abstract T _deserialize(String value, DeserializationContext ctxt) throws IOException; protected T _deserializeEmbedded(Object ob, DeserializationContext ctxt) throws IOException {\n        \n        throw ctxt.mappingException(\"Don't know how to convert embedded Object of type %s into %s\",\n                ob.getClass().getName(), _valueClass.getName());\n    }\n\n    protected T _deserializeFromEmptyString() throws IOException {\n        return null;\n    }\n\n    \n\n    \n    public static class Std extends FromStringDeserializer<Object> { private static final long serialVersionUID = 1; public final static int STD_FILE = 1; public final static int STD_URL = 2; public final static int STD_URI = 3; public final static int STD_CLASS = 4; public final static int STD_JAVA_TYPE = 5; public final static int STD_CURRENCY = 6; public final static int STD_PATTERN = 7; public final static int STD_LOCALE = 8; public final static int STD_CHARSET = 9; public final static int STD_TIME_ZONE = 10; public final static int STD_INET_ADDRESS = 11; public final static int STD_INET_SOCKET_ADDRESS = 12; protected final int _kind; protected Std(Class<?> valueType, int kind) {\n            super(valueType);\n            _kind = kind;\n        }\n\n        @Override\n        protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n            switch (_kind) {\n            case STD_FILE:\n                return new File(value);\n            case STD_URL:\n                return new URL(value);\n            case STD_URI:\n                return URI.create(value);\n            case STD_CLASS:\n                try {\n                    return ctxt.findClass(value);\n                } catch (Exception e) {\n                    throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n                }\n            case STD_JAVA_TYPE:\n                return ctxt.getTypeFactory().constructFromCanonical(value);\n            case STD_CURRENCY:\n                \n                return Currency.getInstance(value);\n            case STD_PATTERN:\n                \n                return Pattern.compile(value);\n            case STD_LOCALE:\n                {\n                    int ix = value.indexOf('_');\n                    if (ix < 0) { \n                        return new Locale(value);\n                    }\n                    String first = value.substring(0, ix);\n                    value = value.substring(ix+1);\n                    ix = value.indexOf('_');\n                    if (ix < 0) { \n                        return new Locale(first, value);\n                    }\n                    String second = value.substring(0, ix);\n                    return new Locale(first, second, value.substring(ix+1));\n                }\n            case STD_CHARSET:\n                return Charset.forName(value);\n            case STD_TIME_ZONE:\n                return TimeZone.getTimeZone(value);\n            case STD_INET_ADDRESS:\n                return InetAddress.getByName(value);\n            case STD_INET_SOCKET_ADDRESS:\n                if (value.startsWith(\"[\")) {\n                    \n\n                    int i = value.lastIndexOf(']');\n                    if (i == -1) {\n                        throw new InvalidFormatException(\"Bracketed IPv6 address must contain closing bracket\",\n                                value, InetSocketAddress.class);\n                    }\n\n                    int j = value.indexOf(':', i);\n                    int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                    return new InetSocketAddress(value.substring(0, i + 1), port);\n                } else {\n                    int ix = value.indexOf(':');\n                    if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                        \n                        int port = Integer.parseInt(value.substring(ix+1));\n                        return new InetSocketAddress(value.substring(0, ix), port);\n                    }\n                    \n                    return new InetSocketAddress(value, 0);\n                }\n            }\n            throw new IllegalArgumentException();\n        }\n\n        @Override\n        protected Object _deserializeFromEmptyString() throws IOException {\n            \n            if (_kind == STD_URI) {\n                return URI.create(\"\");\n            }\n            \n            return super._deserializeFromEmptyString();\n        }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.Currency;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport java.util.regex.Pattern;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.exc.InvalidFormatException;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\n@SuppressWarnings(\"serial\")\npublic abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T> { public static Class<?>[] types() {\n        return new Class<?>[] {\n            File.class,\n            URL.class,\n            URI.class,\n            Class.class,\n            JavaType.class,\n            Currency.class,\n            Pattern.class,\n            Locale.class,\n            Charset.class,\n            TimeZone.class,\n            InetAddress.class,\n            InetSocketAddress.class,\n        };\n    }\n    \n    \n    \n    protected FromStringDeserializer(Class<?> vc) {\n        super(vc);\n    }\n\n    \n    public static Std findDeserializer(Class<?> rawType) {\n        int kind = 0;\n        if (rawType == File.class) {\n            kind = Std.STD_FILE;\n        } else if (rawType == URL.class) {\n            kind = Std.STD_URL;\n        } else if (rawType == URI.class) {\n            kind = Std.STD_URI;\n        } else if (rawType == Class.class) {\n            kind = Std.STD_CLASS;\n        } else if (rawType == JavaType.class) {\n            kind = Std.STD_JAVA_TYPE;\n        } else if (rawType == Currency.class) {\n            kind = Std.STD_CURRENCY;\n        } else if (rawType == Pattern.class) {\n            kind = Std.STD_PATTERN;\n        } else if (rawType == Locale.class) {\n            kind = Std.STD_LOCALE;\n        } else if (rawType == Charset.class) {\n            kind = Std.STD_CHARSET;\n        } else if (rawType == TimeZone.class) {\n            kind = Std.STD_TIME_ZONE;\n        } else if (rawType == InetAddress.class) {\n            kind = Std.STD_INET_ADDRESS;\n        } else if (rawType == InetSocketAddress.class) {\n            kind = Std.STD_INET_SOCKET_ADDRESS;\n        } else {\n            return null;\n        }\n        return new Std(rawType, kind);\n    }\n    \n    \n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public T deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        \n        if (jp.getCurrentToken() == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n            jp.nextToken();\n            final T value = deserialize(jp, ctxt);\n            if (jp.nextToken() != JsonToken.END_ARRAY) {\n                throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \n                                \"Attempted to unwrap single value array for single '\" + _valueClass.getName() + \"' value but there was more than a single value in the array\");\n            }\n            return value;\n        }\n        \n        String text = jp.getValueAsString();\n        if (text != null) { \n            if (text.length() == 0 || (text = text.trim()).length() == 0) {\n                \n                return _deserializeFromEmptyString();\n            }\n            Exception cause = null;\n            try {\n                T result = _deserialize(text, ctxt);\n                if (result != null) {\n                    return result;\n                }\n            } catch (IllegalArgumentException iae) {\n                cause = iae;\n            }\n            String msg = \"not a valid textual representation\";\n            if (cause != null) {\n                String m2 = cause.getMessage();\n                if (m2 != null) {\n                    msg = msg + \", problem: \"+m2;\n                }\n            }\n            JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n            if (cause != null) {\n                e.initCause(cause);\n            }\n            throw e;\n            \n        }\n        if (jp.getCurrentToken() == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            \n            Object ob = jp.getEmbeddedObject();\n            if (ob == null) {\n                return null;\n            }\n            if (_valueClass.isAssignableFrom(ob.getClass())) {\n                return (T) ob;\n            }\n            return _deserializeEmbedded(ob, ctxt);\n        }\n        throw ctxt.mappingException(_valueClass);\n    }\n        \n    protected abstract T _deserialize(String value, DeserializationContext ctxt) throws IOException; protected T _deserializeEmbedded(Object ob, DeserializationContext ctxt) throws IOException {\n        \n        throw ctxt.mappingException(\"Don't know how to convert embedded Object of type %s into %s\",\n                ob.getClass().getName(), _valueClass.getName());\n    }\n\n    protected T _deserializeFromEmptyString() throws IOException {\n        return null;\n    }\n\n    \n\n    \n    public static class Std extends FromStringDeserializer<Object> { private static final long serialVersionUID = 1; public final static int STD_FILE = 1; public final static int STD_URL = 2; public final static int STD_URI = 3; public final static int STD_CLASS = 4; public final static int STD_JAVA_TYPE = 5; public final static int STD_CURRENCY = 6; public final static int STD_PATTERN = 7; public final static int STD_LOCALE = 8; public final static int STD_CHARSET = 9; public final static int STD_TIME_ZONE = 10; public final static int STD_INET_ADDRESS = 11; public final static int STD_INET_SOCKET_ADDRESS = 12; protected final int _kind; protected Std(Class<?> valueType, int kind) {\n            super(valueType);\n            _kind = kind;\n        }\n\n        @Override\n        protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n            switch (_kind) {\n            case STD_FILE:\n                return new File(value);\n            case STD_URL:\n                return new URL(value);\n            case STD_URI:\n                return URI.create(value);\n            case STD_CLASS:\n                try {\n                    return ctxt.findClass(value);\n                } catch (Exception e) {\n                    throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n                }\n            case STD_JAVA_TYPE:\n                return ctxt.getTypeFactory().constructFromCanonical(value);\n            case STD_CURRENCY:\n                \n                return Currency.getInstance(value);\n            case STD_PATTERN:\n                \n                return Pattern.compile(value);\n            case STD_LOCALE:\n                {\n                    int ix = value.indexOf('_');\n                    if (ix < 0) { \n                        return new Locale(value);\n                    }\n                    String first = value.substring(0, ix);\n                    value = value.substring(ix+1);\n                    ix = value.indexOf('_');\n                    if (ix < 0) { \n                        return new Locale(first, value);\n                    }\n                    String second = value.substring(0, ix);\n                    return new Locale(first, second, value.substring(ix+1));\n                }\n            case STD_CHARSET:\n                return Charset.forName(value);\n            case STD_TIME_ZONE:\n                return TimeZone.getTimeZone(value);\n            case STD_INET_ADDRESS:\n                return InetAddress.getByName(value);\n            case STD_INET_SOCKET_ADDRESS:\n                if (value.startsWith(\"[\")) {\n                    \n\n                    int i = value.lastIndexOf(']');\n                    if (i == -1) {\n                        throw new InvalidFormatException(\"Bracketed IPv6 address must contain closing bracket\",\n                                value, InetSocketAddress.class);\n                    }\n\n                    int j = value.indexOf(':', i);\n                    int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                    return new InetSocketAddress(value.substring(0, i + 1), port);\n                } else {\n                    int ix = value.indexOf(':');\n                    if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                        \n                        int port = Integer.parseInt(value.substring(ix+1));\n                        return new InetSocketAddress(value.substring(0, ix), port);\n                    }\n                    \n                    return new InetSocketAddress(value, 0);\n                }\n            }\n            throw new IllegalArgumentException();\n        }\n\n        @Override\n        protected Object _deserializeFromEmptyString() throws IOException {\n            \n            if (_kind == STD_URI) {\n                return URI.create(\"\");\n            }\n            \n            if (_kind == STD_LOCALE) {\n                return Locale.ROOT;\n            }\n            return super._deserializeFromEmptyString();\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T> { public static Class<?>[] types()",
        "protected FromStringDeserializer(Class<?> vc)",
        "public static Std findDeserializer(Class<?> rawType)",
        "public T deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "protected abstract T _deserialize(String value, DeserializationContext ctxt) throws IOException; protected T _deserializeEmbedded(Object ob, DeserializationContext ctxt) throws IOException",
        "protected T _deserializeFromEmptyString() throws IOException",
        "protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException",
        "protected Object _deserializeFromEmptyString() throws IOException"
      ],
      "fixed_signatures": [
        "public abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T> { public static Class<?>[] types()",
        "protected FromStringDeserializer(Class<?> vc)",
        "public static Std findDeserializer(Class<?> rawType)",
        "public T deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "protected abstract T _deserialize(String value, DeserializationContext ctxt) throws IOException; protected T _deserializeEmbedded(Object ob, DeserializationContext ctxt) throws IOException",
        "protected T _deserializeFromEmptyString() throws IOException",
        "protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException",
        "protected Object _deserializeFromEmptyString() throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  protected Object _deserializeFromEmptyString() throws IOException {\n  \n  if (_kind == STD_URI) {\n  return URI.create(\"\");\n  }\n  \n  return super._deserializeFromEmptyString();\n  }",
          "fixed_method": "  protected Object _deserializeFromEmptyString() throws IOException {\n  \n  if (_kind == STD_URI) {\n  return URI.create(\"\");\n  }\n  \n  if (_kind == STD_LOCALE) {\n  return Locale.ROOT;\n  }\n  return super._deserializeFromEmptyString();\n  }",
          "diff": [
            "@@ -281,6 +281,9 @@",
            "                 return URI.create(\"\");\n",
            "             }\n",
            "             // As per [databind#1123], Locale too\n",
            "+            if (_kind == STD_LOCALE) {\n",
            "+                return Locale.ROOT;\n",
            "+            }\n",
            "             return super._deserializeFromEmptyString();\n",
            "         }\n",
            "     }\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
