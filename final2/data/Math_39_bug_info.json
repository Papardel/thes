{
  "bug_id": "39",
  "failed_tests": {
    "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest": [
      {
        "methodName": "testTooLargeFirstStep",
        "error": "junit.framework.AssertionFailedError",
        "message": "",
        "fail_line": "      integ.integrate(equations, start, new double[] { 1.0 }, end, new double[1]);",
        "test_source": "  public void testTooLargeFirstStep() {\n\n  AdaptiveStepsizeIntegrator integ =\n  new DormandPrince853Integrator(0, Double.POSITIVE_INFINITY, Double.NaN, Double.NaN);\n  final double start = 0.0;\n  final double end  = 0.001;\n  FirstOrderDifferentialEquations equations = new FirstOrderDifferentialEquations() {\n\n  public int getDimension() {\n  return 1;\n  }\n\n  public void computeDerivatives(double t, double[] y, double[] yDot) {\n  Assert.assertTrue(t >= FastMath.nextAfter(start, Double.NEGATIVE_INFINITY));\n  Assert.assertTrue(t <= FastMath.nextAfter(end,  Double.POSITIVE_INFINITY));\n  yDot[0] = -100.0 * y[0];\n  }\n\n  };\n\n  integ.setStepSizeControl(0, 1.0, 1.0e-6, 1.0e-8);\n  integ.integrate(equations, start, new double[] { 1.0 }, end, new double[1]);\n\n  }",
        "stack": [
          "DormandPrince853IntegratorTest$3.computeDerivatives line 194, ExpandableStatefulODE.computeDerivatives line 115, AbstractIntegrator.computeDerivatives line 265, EmbeddedRungeKuttaIntegrator.integrate line 262, AbstractIntegrator.integrate line 228, DormandPrince853IntegratorTest.testTooLargeFirstStep line 201"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.ode.nonstiff;\n\nimport org.apache.commons.math.exception.MathIllegalArgumentException;\nimport org.apache.commons.math.exception.MathIllegalStateException;\nimport org.apache.commons.math.ode.ExpandableStatefulODE;\nimport org.apache.commons.math.util.FastMath;\n\n\n\npublic abstract class EmbeddedRungeKuttaIntegrator extends AdaptiveStepsizeIntegrator { private final boolean fsal; private final double[] c; private final double[][] a; private final double[] b; private final RungeKuttaStepInterpolator prototype; private final double exp; private double safety; private double minReduction; private double maxGrowth; protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double scalAbsoluteTolerance, final double scalRelativeTolerance) {\n\n    super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    \n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n\n  }\n\n  \n  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance) {\n\n    super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    \n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n\n  }\n\n  \n  public abstract int getOrder(); public double getSafety() {\n    return safety;\n  }\n\n  \n  public void setSafety(final double safety) {\n    this.safety = safety;\n  }\n\n  \n  @Override\n  public void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    \n    final double[] y0  = equations.getCompleteState();\n    final double[] y = y0.clone();\n    final int stages = c.length + 1;\n    final double[][] yDotK = new double[stages][y.length];\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y.length];\n\n    \n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    \n    stepStart         = equations.getTime();\n    double  hNew      = 0;\n    boolean firstTime = true;\n    initIntegration(equations.getTime(), y0, t);\n\n    \n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      \n      double error = 10;\n      while (error >= 1.0) {\n\n        if (firstTime || !fsal) {\n          \n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale = new double[mainSetDimension];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n              }\n          } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n              }\n          }\n          hNew = initializeStep(forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        \n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        \n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        \n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error >= 1.0) {\n          \n          final double factor =\n              FastMath.min(maxGrowth,\n                           FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      \n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n      System.arraycopy(y, 0, yTmp, 0, y.length);\n\n      if (!isLastStep) {\n\n          \n          interpolator.storeTime(stepStart);\n\n          if (fsal) {\n              \n              System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n          }\n\n          \n          final double factor =\n              FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n          final double  scaledH    = stepSize * factor;\n          final double  nextT      = stepStart + scaledH;\n          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n          hNew = filterStep(scaledH, forward, nextIsLast);\n\n          final double  filteredNextT      = stepStart + hNew;\n          final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n          if (filteredNextIsLast) {\n              hNew = t - stepStart;\n          }\n\n      }\n\n    } while (!isLastStep);\n\n    \n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }\n\n  \n  public double getMinReduction() {\n    return minReduction;\n  }\n\n  \n  public void setMinReduction(final double minReduction) {\n    this.minReduction = minReduction;\n  }\n\n  \n  public double getMaxGrowth() {\n    return maxGrowth;\n  }\n\n  \n  public void setMaxGrowth(final double maxGrowth) {\n    this.maxGrowth = maxGrowth;\n  }\n\n  \n  protected abstract double estimateError(double[][] yDotK,\n                                          double[] y0, double[] y1,\n                                          double h);\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.ode.nonstiff;\n\nimport org.apache.commons.math.exception.MathIllegalArgumentException;\nimport org.apache.commons.math.exception.MathIllegalStateException;\nimport org.apache.commons.math.ode.ExpandableStatefulODE;\nimport org.apache.commons.math.util.FastMath;\n\n\n\npublic abstract class EmbeddedRungeKuttaIntegrator extends AdaptiveStepsizeIntegrator { private final boolean fsal; private final double[] c; private final double[][] a; private final double[] b; private final RungeKuttaStepInterpolator prototype; private final double exp; private double safety; private double minReduction; private double maxGrowth; protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double scalAbsoluteTolerance, final double scalRelativeTolerance) {\n\n    super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    \n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n\n  }\n\n  \n  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance) {\n\n    super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    \n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n\n  }\n\n  \n  public abstract int getOrder(); public double getSafety() {\n    return safety;\n  }\n\n  \n  public void setSafety(final double safety) {\n    this.safety = safety;\n  }\n\n  \n  @Override\n  public void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    \n    final double[] y0  = equations.getCompleteState();\n    final double[] y = y0.clone();\n    final int stages = c.length + 1;\n    final double[][] yDotK = new double[stages][y.length];\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y.length];\n\n    \n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    \n    stepStart         = equations.getTime();\n    double  hNew      = 0;\n    boolean firstTime = true;\n    initIntegration(equations.getTime(), y0, t);\n\n    \n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      \n      double error = 10;\n      while (error >= 1.0) {\n\n        if (firstTime || !fsal) {\n          \n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale = new double[mainSetDimension];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n              }\n          } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n              }\n          }\n          hNew = initializeStep(forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n        if (forward) {\n            if (stepStart + stepSize >= t) {\n                stepSize = t - stepStart;\n            }\n        } else {\n            if (stepStart + stepSize <= t) {\n                stepSize = t - stepStart;\n            }\n        }\n\n        \n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        \n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        \n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error >= 1.0) {\n          \n          final double factor =\n              FastMath.min(maxGrowth,\n                           FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      \n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n      System.arraycopy(y, 0, yTmp, 0, y.length);\n\n      if (!isLastStep) {\n\n          \n          interpolator.storeTime(stepStart);\n\n          if (fsal) {\n              \n              System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n          }\n\n          \n          final double factor =\n              FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n          final double  scaledH    = stepSize * factor;\n          final double  nextT      = stepStart + scaledH;\n          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n          hNew = filterStep(scaledH, forward, nextIsLast);\n\n          final double  filteredNextT      = stepStart + hNew;\n          final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n          if (filteredNextIsLast) {\n              hNew = t - stepStart;\n          }\n\n      }\n\n    } while (!isLastStep);\n\n    \n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }\n\n  \n  public double getMinReduction() {\n    return minReduction;\n  }\n\n  \n  public void setMinReduction(final double minReduction) {\n    this.minReduction = minReduction;\n  }\n\n  \n  public double getMaxGrowth() {\n    return maxGrowth;\n  }\n\n  \n  public void setMaxGrowth(final double maxGrowth) {\n    this.maxGrowth = maxGrowth;\n  }\n\n  \n  protected abstract double estimateError(double[][] yDotK,\n                                          double[] y0, double[] y1,\n                                          double h);\n\n}\n",
      "buggy_signatures": [
        "public abstract class EmbeddedRungeKuttaIntegrator extends AdaptiveStepsizeIntegrator { private final boolean fsal; private final double[] c; private final double[][] a; private final double[] b; private final RungeKuttaStepInterpolator prototype; private final double exp; private double safety; private double minReduction; private double maxGrowth; protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double scalAbsoluteTolerance, final double scalRelativeTolerance)",
        "protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance)",
        "public abstract int getOrder(); public double getSafety()",
        "public void setSafety(final double safety)",
        "public void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException",
        "public double getMinReduction()",
        "public void setMinReduction(final double minReduction)",
        "public double getMaxGrowth()",
        "public void setMaxGrowth(final double maxGrowth)"
      ],
      "fixed_signatures": [
        "public abstract class EmbeddedRungeKuttaIntegrator extends AdaptiveStepsizeIntegrator { private final boolean fsal; private final double[] c; private final double[][] a; private final double[] b; private final RungeKuttaStepInterpolator prototype; private final double exp; private double safety; private double minReduction; private double maxGrowth; protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double scalAbsoluteTolerance, final double scalRelativeTolerance)",
        "protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance)",
        "public abstract int getOrder(); public double getSafety()",
        "public void setSafety(final double safety)",
        "public void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException",
        "public double getMinReduction()",
        "public void setMinReduction(final double minReduction)",
        "public double getMaxGrowth()",
        "public void setMaxGrowth(final double maxGrowth)"
      ],
      "methods": [
        {
          "buggy_method": "  public void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {\n\n  sanityChecks(equations, t);\n  setEquations(equations);\n  final boolean forward = t > equations.getTime();\n\n  \n  final double[] y0  = equations.getCompleteState();\n  final double[] y = y0.clone();\n  final int stages = c.length + 1;\n  final double[][] yDotK = new double[stages][y.length];\n  final double[] yTmp  = y0.clone();\n  final double[] yDotTmp = new double[y.length];\n\n  \n  final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n  interpolator.reinitialize(this, yTmp, yDotK, forward,\n  equations.getPrimaryMapper(), equations.getSecondaryMappers());\n  interpolator.storeTime(equations.getTime());\n\n  \n  stepStart  = equations.getTime();\n  double  hNew  = 0;\n  boolean firstTime = true;\n  initIntegration(equations.getTime(), y0, t);\n\n  \n  isLastStep = false;\n  do {\n\n  interpolator.shift();\n\n  \n  double error = 10;\n  while (error >= 1.0) {\n\n  if (firstTime || !fsal) {\n  \n  computeDerivatives(stepStart, y, yDotK[0]);\n  }\n\n  if (firstTime) {\n  final double[] scale = new double[mainSetDimension];\n  if (vecAbsoluteTolerance == null) {\n  for (int i = 0; i < scale.length; ++i) {\n  scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n  }\n  } else {\n  for (int i = 0; i < scale.length; ++i) {\n  scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n  }\n  }\n  hNew = initializeStep(forward, getOrder(), scale,\n  stepStart, y, yDotK[0], yTmp, yDotK[1]);\n  firstTime = false;\n  }\n\n  stepSize = hNew;\n\n  \n  for (int k = 1; k < stages; ++k) {\n\n  for (int j = 0; j < y0.length; ++j) {\n  double sum = a[k-1][0] * yDotK[0][j];\n  for (int l = 1; l < k; ++l) {\n  sum += a[k-1][l] * yDotK[l][j];\n  }\n  yTmp[j] = y[j] + stepSize * sum;\n  }\n\n  computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n  }\n\n  \n  for (int j = 0; j < y0.length; ++j) {\n  double sum  = b[0] * yDotK[0][j];\n  for (int l = 1; l < stages; ++l) {\n  sum  += b[l] * yDotK[l][j];\n  }\n  yTmp[j] = y[j] + stepSize * sum;\n  }\n\n  \n  error = estimateError(yDotK, y, yTmp, stepSize);\n  if (error >= 1.0) {\n  \n  final double factor =\n  FastMath.min(maxGrowth,\n  FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n  hNew = filterStep(stepSize * factor, forward, false);\n  }\n\n  }\n\n  \n  interpolator.storeTime(stepStart + stepSize);\n  System.arraycopy(yTmp, 0, y, 0, y0.length);\n  System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n  stepStart = acceptStep(interpolator, y, yDotTmp, t);\n  System.arraycopy(y, 0, yTmp, 0, y.length);\n\n  if (!isLastStep) {\n\n  \n  interpolator.storeTime(stepStart);\n\n  if (fsal) {\n  \n  System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n  }\n\n  \n  final double factor =\n  FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n  final double  scaledH  = stepSize * factor;\n  final double  nextT  = stepStart + scaledH;\n  final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n  hNew = filterStep(scaledH, forward, nextIsLast);\n\n  final double  filteredNextT  = stepStart + hNew;\n  final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n  if (filteredNextIsLast) {\n  hNew = t - stepStart;\n  }\n\n  }\n\n  } while (!isLastStep);\n\n  \n  equations.setTime(stepStart);\n  equations.setCompleteState(y);\n\n  resetInternalState();\n\n  }",
          "fixed_method": "  public void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {\n\n  sanityChecks(equations, t);\n  setEquations(equations);\n  final boolean forward = t > equations.getTime();\n\n  \n  final double[] y0  = equations.getCompleteState();\n  final double[] y = y0.clone();\n  final int stages = c.length + 1;\n  final double[][] yDotK = new double[stages][y.length];\n  final double[] yTmp  = y0.clone();\n  final double[] yDotTmp = new double[y.length];\n\n  \n  final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n  interpolator.reinitialize(this, yTmp, yDotK, forward,\n  equations.getPrimaryMapper(), equations.getSecondaryMappers());\n  interpolator.storeTime(equations.getTime());\n\n  \n  stepStart  = equations.getTime();\n  double  hNew  = 0;\n  boolean firstTime = true;\n  initIntegration(equations.getTime(), y0, t);\n\n  \n  isLastStep = false;\n  do {\n\n  interpolator.shift();\n\n  \n  double error = 10;\n  while (error >= 1.0) {\n\n  if (firstTime || !fsal) {\n  \n  computeDerivatives(stepStart, y, yDotK[0]);\n  }\n\n  if (firstTime) {\n  final double[] scale = new double[mainSetDimension];\n  if (vecAbsoluteTolerance == null) {\n  for (int i = 0; i < scale.length; ++i) {\n  scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n  }\n  } else {\n  for (int i = 0; i < scale.length; ++i) {\n  scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n  }\n  }\n  hNew = initializeStep(forward, getOrder(), scale,\n  stepStart, y, yDotK[0], yTmp, yDotK[1]);\n  firstTime = false;\n  }\n\n  stepSize = hNew;\n  if (forward) {\n  if (stepStart + stepSize >= t) {\n  stepSize = t - stepStart;\n  }\n  } else {\n  if (stepStart + stepSize <= t) {\n  stepSize = t - stepStart;\n  }\n  }\n\n  \n  for (int k = 1; k < stages; ++k) {\n\n  for (int j = 0; j < y0.length; ++j) {\n  double sum = a[k-1][0] * yDotK[0][j];\n  for (int l = 1; l < k; ++l) {\n  sum += a[k-1][l] * yDotK[l][j];\n  }\n  yTmp[j] = y[j] + stepSize * sum;\n  }\n\n  computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n  }\n\n  \n  for (int j = 0; j < y0.length; ++j) {\n  double sum  = b[0] * yDotK[0][j];\n  for (int l = 1; l < stages; ++l) {\n  sum  += b[l] * yDotK[l][j];\n  }\n  yTmp[j] = y[j] + stepSize * sum;\n  }\n\n  \n  error = estimateError(yDotK, y, yTmp, stepSize);\n  if (error >= 1.0) {\n  \n  final double factor =\n  FastMath.min(maxGrowth,\n  FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n  hNew = filterStep(stepSize * factor, forward, false);\n  }\n\n  }\n\n  \n  interpolator.storeTime(stepStart + stepSize);\n  System.arraycopy(yTmp, 0, y, 0, y0.length);\n  System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n  stepStart = acceptStep(interpolator, y, yDotTmp, t);\n  System.arraycopy(y, 0, yTmp, 0, y.length);\n\n  if (!isLastStep) {\n\n  \n  interpolator.storeTime(stepStart);\n\n  if (fsal) {\n  \n  System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n  }\n\n  \n  final double factor =\n  FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n  final double  scaledH  = stepSize * factor;\n  final double  nextT  = stepStart + scaledH;\n  final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n  hNew = filterStep(scaledH, forward, nextIsLast);\n\n  final double  filteredNextT  = stepStart + hNew;\n  final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n  if (filteredNextIsLast) {\n  hNew = t - stepStart;\n  }\n\n  }\n\n  } while (!isLastStep);\n\n  \n  equations.setTime(stepStart);\n  equations.setCompleteState(y);\n\n  resetInternalState();\n\n  }",
          "diff": [
            "@@ -247,6 +247,15 @@",
            "         }\n",
            " \n",
            "         stepSize = hNew;\n",
            "+        if (forward) {\n",
            "+            if (stepStart + stepSize >= t) {\n",
            "+                stepSize = t - stepStart;\n",
            "+            }\n",
            "+        } else {\n",
            "+            if (stepStart + stepSize <= t) {\n",
            "+                stepSize = t - stepStart;\n",
            "+            }\n",
            "+        }\n",
            " \n",
            "         // next stages\n",
            "         for (int k = 1; k < stages; ++k) {\n"
          ],
          "changed_lines": 9
        }
      ]
    }
  ]
}
