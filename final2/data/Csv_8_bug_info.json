{
  "bug_id": "8",
  "failed_tests": {
    "org.apache.commons.csv.CSVFormatTest": [
      {
        "methodName": "testDuplicateHeaderElements",
        "error": "java.lang.Exception",
        "message": "Unexpected exception, expected<java.lang.IllegalArgumentException> but was<java.lang.IllegalStateException>",
        "fail_line": "        CSVFormat.DEFAULT.withHeader(\"A\", \"A\").validate();",
        "test_source": "  public void testDuplicateHeaderElements() {\n  CSVFormat.DEFAULT.withHeader(\"A\", \"A\").validate();\n  }",
        "stack": [
          "CSVFormat.validate line 669, CSVFormatTest.testDuplicateHeaderElements line 66"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/csv/CSVFormat.java",
      "buggy_full_code": "\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH; import static org.apache.commons.csv.Constants.COMMA; import static org.apache.commons.csv.Constants.CR; import static org.apache.commons.csv.Constants.CRLF; import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR; import static org.apache.commons.csv.Constants.LF; import static org.apache.commons.csv.Constants.TAB; import java.io.IOException; import java.io.Reader; import java.io.Serializable; import java.io.StringWriter; import java.util.Arrays; import java.util.HashSet; import java.util.Set; public final class CSVFormat implements Serializable { private static final long serialVersionUID = 1L; private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    \n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    \n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, false);\n    }\n\n    \n    private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        this.delimiter = delimiter;\n        this.quoteChar = quoteChar;\n        this.quotePolicy = quotePolicy;\n        this.commentStart = commentStart;\n        this.escape = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        if (header == null) {\n        \tthis.header = null;\n        } else {\n            this.header = header.clone();        \t\n        }\n        this.skipHeaderRecord = skipHeaderRecord;\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (quotePolicy != other.quotePolicy) {\n            return false;\n        }\n        if (quoteChar == null) {\n            if (other.quoteChar != null) {\n                return false;\n            }\n        } else if (!quoteChar.equals(other.quoteChar)) {\n            return false;\n        }\n        if (commentStart == null) {\n            if (other.commentStart != null) {\n                return false;\n            }\n        } else if (!commentStart.equals(other.commentStart)) {\n            return false;\n        }\n        if (escape == null) {\n            if (other.escape != null) {\n                return false;\n            }\n        } else if (!escape.equals(other.escape)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        return true;\n    }\n\n    \n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try {\n            new CSVPrinter(out, this).printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            \n            throw new IllegalStateException(e);\n        }\n    }\n\n    \n    public Character getCommentStart() {\n        return commentStart;\n    }\n\n    \n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    \n    public Character getEscape() {\n        return escape;\n    }\n\n    \n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    \n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    \n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    \n    public String getNullString() {\n        return nullString;\n    }\n\n    \n    public Character getQuoteChar() {\n        return quoteChar;\n    }\n\n    \n    public Quote getQuotePolicy() {\n        return quotePolicy;\n    }\n\n    \n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    \n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quotePolicy == null) ? 0 : quotePolicy.hashCode());\n        result = prime * result + ((quoteChar == null) ? 0 : quoteChar.hashCode());\n        result = prime * result + ((commentStart == null) ? 0 : commentStart.hashCode());\n        result = prime * result + ((escape == null) ? 0 : escape.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        return result;\n    }\n\n    \n    public boolean isCommentingEnabled() {\n        return commentStart != null;\n    }\n\n    \n    public boolean isEscaping() {\n        return escape != null;\n    }\n\n    \n    public boolean isNullHandling() {\n        return nullString != null;\n    }\n\n    \n    public boolean isQuoting() {\n        return quoteChar != null;\n    }\n\n    \n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscaping()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escape).append('>');\n        }\n        if (isQuoting()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteChar).append('>');\n        }\n        if (isCommentingEnabled()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentStart).append('>');\n        }\n        if (isNullHandling()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if(recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    \n    void validate() throws IllegalStateException {\n        if (quoteChar != null && delimiter == quoteChar.charValue()) {\n            throw new IllegalStateException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteChar + \"')\");\n        }\n\n        if (escape != null && delimiter == escape.charValue()) {\n            throw new IllegalStateException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escape + \"')\");\n        }\n\n        if (commentStart != null && delimiter == commentStart.charValue()) {\n            throw new IllegalStateException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentStart + \"')\");\n        }\n\n        if (quoteChar != null && quoteChar.equals(commentStart)) {\n            throw new IllegalStateException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentStart + \"')\");\n        }\n\n        if (escape != null && escape.equals(commentStart)) {\n            throw new IllegalStateException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentStart + \"')\");\n        }\n\n        if (escape == null && quotePolicy == Quote.NONE) {\n            throw new IllegalStateException(\"No quotes mode set but no escape character is set\");\n        }\n\n        if (header != null) {\n            final Set<String> set = new HashSet<String>(header.length);\n            set.addAll(Arrays.asList(header));\n            if (set.size() != header.length) {\n                throw new IllegalStateException(\"The header contains duplicate names: \" + Arrays.toString(header));\n            }\n        }\n    }\n\n    \n    public CSVFormat withCommentStart(final char commentStart) {\n        return withCommentStart(Character.valueOf(commentStart));\n    }\n\n    \n    public CSVFormat withCommentStart(final Character commentStart) {\n        if (isLineBreak(commentStart)) {\n            throw new IllegalArgumentException(\"The comment start character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    \n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    \n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    \n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    \n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    \n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    \n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    \n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    \n    public CSVFormat withQuoteChar(final char quoteChar) {\n        return withQuoteChar(Character.valueOf(quoteChar));\n    }\n\n    \n    public CSVFormat withQuoteChar(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    \n    public CSVFormat withQuotePolicy(final Quote quotePolicy) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    \n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    \n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    \n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH; import static org.apache.commons.csv.Constants.COMMA; import static org.apache.commons.csv.Constants.CR; import static org.apache.commons.csv.Constants.CRLF; import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR; import static org.apache.commons.csv.Constants.LF; import static org.apache.commons.csv.Constants.TAB; import java.io.IOException; import java.io.Reader; import java.io.Serializable; import java.io.StringWriter; import java.util.Arrays; import java.util.HashSet; import java.util.Set; public final class CSVFormat implements Serializable { private static final long serialVersionUID = 1L; private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    \n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    \n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, false);\n    }\n\n    \n    private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        this.delimiter = delimiter;\n        this.quoteChar = quoteChar;\n        this.quotePolicy = quotePolicy;\n        this.commentStart = commentStart;\n        this.escape = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        if (header == null) {\n        \tthis.header = null;\n        } else {\n        \tSet<String> dupCheck = new HashSet<String>();\n        \tfor(String hdr : header) {\n        \t\tif (!dupCheck.add(hdr)) {\n        \t\t\tthrow new IllegalArgumentException(\"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\n        \t\t}\n        \t}\n            this.header = header.clone();        \t\n        }\n        this.skipHeaderRecord = skipHeaderRecord;\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (quotePolicy != other.quotePolicy) {\n            return false;\n        }\n        if (quoteChar == null) {\n            if (other.quoteChar != null) {\n                return false;\n            }\n        } else if (!quoteChar.equals(other.quoteChar)) {\n            return false;\n        }\n        if (commentStart == null) {\n            if (other.commentStart != null) {\n                return false;\n            }\n        } else if (!commentStart.equals(other.commentStart)) {\n            return false;\n        }\n        if (escape == null) {\n            if (other.escape != null) {\n                return false;\n            }\n        } else if (!escape.equals(other.escape)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        return true;\n    }\n\n    \n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try {\n            new CSVPrinter(out, this).printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            \n            throw new IllegalStateException(e);\n        }\n    }\n\n    \n    public Character getCommentStart() {\n        return commentStart;\n    }\n\n    \n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    \n    public Character getEscape() {\n        return escape;\n    }\n\n    \n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    \n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    \n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    \n    public String getNullString() {\n        return nullString;\n    }\n\n    \n    public Character getQuoteChar() {\n        return quoteChar;\n    }\n\n    \n    public Quote getQuotePolicy() {\n        return quotePolicy;\n    }\n\n    \n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    \n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quotePolicy == null) ? 0 : quotePolicy.hashCode());\n        result = prime * result + ((quoteChar == null) ? 0 : quoteChar.hashCode());\n        result = prime * result + ((commentStart == null) ? 0 : commentStart.hashCode());\n        result = prime * result + ((escape == null) ? 0 : escape.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        return result;\n    }\n\n    \n    public boolean isCommentingEnabled() {\n        return commentStart != null;\n    }\n\n    \n    public boolean isEscaping() {\n        return escape != null;\n    }\n\n    \n    public boolean isNullHandling() {\n        return nullString != null;\n    }\n\n    \n    public boolean isQuoting() {\n        return quoteChar != null;\n    }\n\n    \n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscaping()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escape).append('>');\n        }\n        if (isQuoting()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteChar).append('>');\n        }\n        if (isCommentingEnabled()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentStart).append('>');\n        }\n        if (isNullHandling()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if(recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    \n    void validate() throws IllegalStateException {\n        if (quoteChar != null && delimiter == quoteChar.charValue()) {\n            throw new IllegalStateException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteChar + \"')\");\n        }\n\n        if (escape != null && delimiter == escape.charValue()) {\n            throw new IllegalStateException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escape + \"')\");\n        }\n\n        if (commentStart != null && delimiter == commentStart.charValue()) {\n            throw new IllegalStateException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentStart + \"')\");\n        }\n\n        if (quoteChar != null && quoteChar.equals(commentStart)) {\n            throw new IllegalStateException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentStart + \"')\");\n        }\n\n        if (escape != null && escape.equals(commentStart)) {\n            throw new IllegalStateException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentStart + \"')\");\n        }\n\n        if (escape == null && quotePolicy == Quote.NONE) {\n            throw new IllegalStateException(\"No quotes mode set but no escape character is set\");\n        }\n\n    }\n\n    \n    public CSVFormat withCommentStart(final char commentStart) {\n        return withCommentStart(Character.valueOf(commentStart));\n    }\n\n    \n    public CSVFormat withCommentStart(final Character commentStart) {\n        if (isLineBreak(commentStart)) {\n            throw new IllegalArgumentException(\"The comment start character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    \n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    \n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    \n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    \n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    \n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    \n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    \n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    \n    public CSVFormat withQuoteChar(final char quoteChar) {\n        return withQuoteChar(Character.valueOf(quoteChar));\n    }\n\n    \n    public CSVFormat withQuoteChar(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    \n    public CSVFormat withQuotePolicy(final Quote quotePolicy) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    \n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    \n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    \n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n}\n",
      "buggy_signatures": [
        "private static boolean isLineBreak(final Character c)",
        "public static CSVFormat newFormat(final char delimiter)",
        "private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord)",
        "public boolean equals(final Object obj)",
        "public String format(final Object... values)",
        "public Character getCommentStart()",
        "public char getDelimiter()",
        "public Character getEscape()",
        "public String[] getHeader()",
        "public boolean getIgnoreEmptyLines()",
        "public boolean getIgnoreSurroundingSpaces()",
        "public String getNullString()",
        "public Character getQuoteChar()",
        "public Quote getQuotePolicy()",
        "public String getRecordSeparator()",
        "public boolean getSkipHeaderRecord()",
        "public int hashCode()",
        "public boolean isCommentingEnabled()",
        "public boolean isEscaping()",
        "public boolean isNullHandling()",
        "public boolean isQuoting()",
        "public CSVParser parse(final Reader in) throws IOException",
        "public String toString()",
        "public CSVFormat withCommentStart(final char commentStart)",
        "public CSVFormat withCommentStart(final Character commentStart)",
        "public CSVFormat withDelimiter(final char delimiter)",
        "public CSVFormat withEscape(final char escape)",
        "public CSVFormat withEscape(final Character escape)",
        "public CSVFormat withHeader(final String... header)",
        "public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines)",
        "public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces)",
        "public CSVFormat withNullString(final String nullString)",
        "public CSVFormat withQuoteChar(final char quoteChar)",
        "public CSVFormat withQuoteChar(final Character quoteChar)",
        "public CSVFormat withQuotePolicy(final Quote quotePolicy)",
        "public CSVFormat withRecordSeparator(final char recordSeparator)",
        "public CSVFormat withRecordSeparator(final String recordSeparator)",
        "public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord)"
      ],
      "fixed_signatures": [
        "private static boolean isLineBreak(final Character c)",
        "public static CSVFormat newFormat(final char delimiter)",
        "private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord)",
        "public boolean equals(final Object obj)",
        "public String format(final Object... values)",
        "public Character getCommentStart()",
        "public char getDelimiter()",
        "public Character getEscape()",
        "public String[] getHeader()",
        "public boolean getIgnoreEmptyLines()",
        "public boolean getIgnoreSurroundingSpaces()",
        "public String getNullString()",
        "public Character getQuoteChar()",
        "public Quote getQuotePolicy()",
        "public String getRecordSeparator()",
        "public boolean getSkipHeaderRecord()",
        "public int hashCode()",
        "public boolean isCommentingEnabled()",
        "public boolean isEscaping()",
        "public boolean isNullHandling()",
        "public boolean isQuoting()",
        "public CSVParser parse(final Reader in) throws IOException",
        "public String toString()",
        "public CSVFormat withCommentStart(final char commentStart)",
        "public CSVFormat withCommentStart(final Character commentStart)",
        "public CSVFormat withDelimiter(final char delimiter)",
        "public CSVFormat withEscape(final char escape)",
        "public CSVFormat withEscape(final Character escape)",
        "public CSVFormat withHeader(final String... header)",
        "public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines)",
        "public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces)",
        "public CSVFormat withNullString(final String nullString)",
        "public CSVFormat withQuoteChar(final char quoteChar)",
        "public CSVFormat withQuoteChar(final Character quoteChar)",
        "public CSVFormat withQuotePolicy(final Quote quotePolicy)",
        "public CSVFormat withRecordSeparator(final char recordSeparator)",
        "public CSVFormat withRecordSeparator(final String recordSeparator)",
        "public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord)"
      ],
      "methods": [
        {
          "buggy_method": "  private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord) {\n  if (isLineBreak(delimiter)) {\n  throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n  }\n  this.delimiter = delimiter;\n  this.quoteChar = quoteChar;\n  this.quotePolicy = quotePolicy;\n  this.commentStart = commentStart;\n  this.escape = escape;\n  this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n  this.ignoreEmptyLines = ignoreEmptyLines;\n  this.recordSeparator = recordSeparator;\n  this.nullString = nullString;\n  if (header == null) {\n  \tthis.header = null;\n  } else {\n  this.header = header.clone();  \t\n  }\n  this.skipHeaderRecord = skipHeaderRecord;\n  }",
          "fixed_method": "  private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord) {\n  if (isLineBreak(delimiter)) {\n  throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n  }\n  this.delimiter = delimiter;\n  this.quoteChar = quoteChar;\n  this.quotePolicy = quotePolicy;\n  this.commentStart = commentStart;\n  this.escape = escape;\n  this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n  this.ignoreEmptyLines = ignoreEmptyLines;\n  this.recordSeparator = recordSeparator;\n  this.nullString = nullString;\n  if (header == null) {\n  \tthis.header = null;\n  } else {\n  \tSet<String> dupCheck = new HashSet<String>();\n  \tfor(String hdr : header) {\n  \t\tif (!dupCheck.add(hdr)) {\n  \t\t\tthrow new IllegalArgumentException(\"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\n  \t\t}\n  \t}\n  this.header = header.clone();  \t\n  }\n  this.skipHeaderRecord = skipHeaderRecord;\n  }",
          "diff": [
            "@@ -313,6 +313,12 @@",
            "         if (header == null) {\n",
            "         \tthis.header = null;\n",
            "         } else {\n",
            "+        \tSet<String> dupCheck = new HashSet<String>();\n",
            "+        \tfor(String hdr : header) {\n",
            "+        \t\tif (!dupCheck.add(hdr)) {\n",
            "+        \t\t\tthrow new IllegalArgumentException(\"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\n",
            "+        \t\t}\n",
            "+        \t}\n",
            "             this.header = header.clone();        \t\n",
            "         }\n",
            "         this.skipHeaderRecord = skipHeaderRecord;\n"
          ],
          "changed_lines": 6
        },
        {
          "buggy_method": "  public String toString() {\n  final StringBuilder sb = new StringBuilder();\n  sb.append(\"Delimiter=<\").append(delimiter).append('>');\n  if (isEscaping()) {\n  sb.append(' ');\n  sb.append(\"Escape=<\").append(escape).append('>');\n  }\n  if (isQuoting()) {\n  sb.append(' ');\n  sb.append(\"QuoteChar=<\").append(quoteChar).append('>');\n  }\n  if (isCommentingEnabled()) {\n  sb.append(' ');\n  sb.append(\"CommentStart=<\").append(commentStart).append('>');\n  }\n  if (isNullHandling()) {\n  sb.append(' ');\n  sb.append(\"NullString=<\").append(nullString).append('>');\n  }\n  if(recordSeparator != null) {\n  sb.append(' ');\n  sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n  }\n  if (getIgnoreEmptyLines()) {\n  sb.append(\" EmptyLines:ignored\");\n  }\n  if (getIgnoreSurroundingSpaces()) {\n  sb.append(\" SurroundingSpaces:ignored\");\n  }\n  sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n  if (header != null) {\n  sb.append(' ');\n  sb.append(\"Header:\").append(Arrays.toString(header));\n  }\n  return sb.toString();\n  }",
          "fixed_method": "  public String toString() {\n  final StringBuilder sb = new StringBuilder();\n  sb.append(\"Delimiter=<\").append(delimiter).append('>');\n  if (isEscaping()) {\n  sb.append(' ');\n  sb.append(\"Escape=<\").append(escape).append('>');\n  }\n  if (isQuoting()) {\n  sb.append(' ');\n  sb.append(\"QuoteChar=<\").append(quoteChar).append('>');\n  }\n  if (isCommentingEnabled()) {\n  sb.append(' ');\n  sb.append(\"CommentStart=<\").append(commentStart).append('>');\n  }\n  if (isNullHandling()) {\n  sb.append(' ');\n  sb.append(\"NullString=<\").append(nullString).append('>');\n  }\n  if(recordSeparator != null) {\n  sb.append(' ');\n  sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n  }\n  if (getIgnoreEmptyLines()) {\n  sb.append(\" EmptyLines:ignored\");\n  }\n  if (getIgnoreSurroundingSpaces()) {\n  sb.append(\" SurroundingSpaces:ignored\");\n  }\n  sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n  if (header != null) {\n  sb.append(' ');\n  sb.append(\"Header:\").append(Arrays.toString(header));\n  }\n  return sb.toString();\n  }",
          "diff": [
            "@@ -662,13 +668,6 @@",
            "             throw new IllegalStateException(\"No quotes mode set but no escape character is set\");\n",
            "         }\n",
            " \n",
            "-        if (header != null) {\n",
            "-            final Set<String> set = new HashSet<String>(header.length);\n",
            "-            set.addAll(Arrays.asList(header));\n",
            "-            if (set.size() != header.length) {\n",
            "-                throw new IllegalStateException(\"The header contains duplicate names: \" + Arrays.toString(header));\n",
            "-            }\n",
            "-        }\n",
            "     }\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 7
        }
      ]
    }
  ]
}
