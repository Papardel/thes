{
  "bug_id": "59",
  "failed_tests": {
    "com.fasterxml.jackson.databind.jsontype.TypeRefinementForMapTest": [
      {
        "methodName": "testMapKeyRefinement1384",
        "error": "com.fasterxml.jackson.databind.JsonMappingException",
        "message": "Can not find a (Map) Key deserializer for type [simple type, class com.fasterxml.jackson.databind.jsontype.TypeRefinementForMapTest$CompoundKey]",
        "fail_line": "        TestClass testInstance = mapper.readValue(TEST_INSTANCE_SERIALIZED, TestClass.class);",
        "test_source": "  public void testMapKeyRefinement1384() throws Exception {\n  final String TEST_INSTANCE_SERIALIZED =\n  \"{\\\"mapProperty\\\":[\\\"java.util.HashMap\\\",{\\\"Compound|Key\\\":\\\"Value\\\"}]}\";\n  ObjectMapper mapper = new ObjectMapper().enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n\n  TestClass testInstance = mapper.readValue(TEST_INSTANCE_SERIALIZED, TestClass.class);\n  assertEquals(1, testInstance.mapProperty.size());\n  Object key = testInstance.mapProperty.keySet().iterator().next();\n  assertEquals(CompoundKey.class, key.getClass());\n  String testInstanceSerialized = mapper.writeValueAsString(testInstance);\n  assertEquals(TEST_INSTANCE_SERIALIZED, testInstanceSerialized);\n  }",
        "stack": [
          "JsonMappingException.from line 261, DeserializationContext.reportMappingException line 1234, DeserializerCache._handleUnknownKeyDeserializer line 588, DeserializerCache.findKeyDeserializer line 168, DeserializationContext.findKeyDeserializer line 499, MapDeserializer.createContextual line 237, DeserializationContext.handleSecondaryContextualization line 681, DeserializationContext.findContextualValueDeserializer line 445, TypeDeserializerBase._findDeserializer line 188, AsArrayTypeDeserializer._deserialize line 97, AsArrayTypeDeserializer.deserializeTypedFromObject line 61, MapDeserializer.deserializeWithType line 387, SettableBeanProperty.deserialize line 497, BeanDeserializer._deserializeWithErrorWrapping line 511, BeanDeserializer._deserializeUsingPropertyBased line 397, BeanDeserializerBase.deserializeFromObjectUsingNonDefault line 1196, BeanDeserializer.deserializeFromObject line 314, BeanDeserializer.deserialize line 148, ObjectMapper._readMapAndClose line 3789, ObjectMapper.readValue line 2833, TypeRefinementForMapTest.testMapKeyRefinement1384 line 125"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/JavaType.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind;\n\nimport java.lang.reflect.Modifier;\nimport java.util.List;\n\nimport com.fasterxml.jackson.core.type.ResolvedType;\nimport com.fasterxml.jackson.databind.type.TypeBindings;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\n\n\npublic abstract class JavaType extends ResolvedType implements java.io.Serializable, java.lang.reflect.Type { private static final long serialVersionUID = 1; protected final Class<?> _class; protected final int _hash; protected final Object _valueHandler; protected final Object _typeHandler; protected final boolean _asStatic; protected JavaType(Class<?> raw, int additionalHash, Object valueHandler, Object typeHandler, boolean asStatic) {\n        _class = raw;\n        _hash = raw.getName().hashCode() + additionalHash;\n        _valueHandler = valueHandler;\n        _typeHandler = typeHandler;\n        _asStatic = asStatic;\n    }\n\n    \n    protected JavaType(JavaType base) {\n        _class = base._class;\n        _hash = base._hash;\n        _valueHandler = base._valueHandler;\n        _typeHandler = base._typeHandler;\n        _asStatic = base._asStatic;\n    }\n\n    \n    public abstract JavaType withTypeHandler(Object h); public abstract JavaType withContentTypeHandler(Object h); public abstract JavaType withValueHandler(Object h); public abstract JavaType withContentValueHandler(Object h); public abstract JavaType withContentType(JavaType contentType); public abstract JavaType withStaticTyping(); public abstract JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces); @Deprecated public JavaType forcedNarrowBy(Class<?> subclass) {\n        if (subclass == _class) { \n            return this;\n        }\n        JavaType result = _narrow(subclass);\n        \n        if (_valueHandler != result.<Object>getValueHandler()) {\n            result = result.withValueHandler(_valueHandler);\n        }\n        if (_typeHandler != result.<Object>getTypeHandler()) {\n            result = result.withTypeHandler(_typeHandler);\n        }\n        return result;\n    }\n\n    @Deprecated \n    protected abstract JavaType _narrow(Class<?> subclass); @Override public final Class<?> getRawClass() { return _class; }\n\n    \n    @Override\n    public final boolean hasRawClass(Class<?> clz) { return _class == clz; }\n\n    \n    public boolean hasContentType() {\n        return true;\n    }\n\n    \n    public final boolean isTypeOrSubTypeOf(Class<?> clz) {\n        return (_class == clz) || (clz.isAssignableFrom(_class));\n    }\n\n    @Override\n    public boolean isAbstract() {\n        return Modifier.isAbstract(_class.getModifiers());\n    }\n\n    \n    @Override\n    public boolean isConcrete() {\n        int mod = _class.getModifiers();\n        if ((mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0) {\n            return true;\n        }\n        \n        return _class.isPrimitive();\n    }\n\n    @Override\n    public boolean isThrowable() { return Throwable.class.isAssignableFrom(_class); }\n\n    @Override\n    public boolean isArrayType() { return false; }\n\n    @Override\n    public final boolean isEnumType() { return _class.isEnum(); }\n\n    @Override\n    public final boolean isInterface() { return _class.isInterface(); }\n\n    @Override\n    public final boolean isPrimitive() { return _class.isPrimitive(); }\n\n    @Override\n    public final boolean isFinal() { return Modifier.isFinal(_class.getModifiers()); }\n\n    \n    @Override\n    public abstract boolean isContainerType(); @Override public boolean isCollectionLikeType() { return false; }\n\n    \n    @Override\n    public boolean isMapLikeType() { return false; }\n\n    \n    public final boolean isJavaLangObject() { return _class == Object.class; }\n\n    \n    public final boolean useStaticType() { return _asStatic; }\n\n    \n\n    @Override\n    public boolean hasGenericTypes() { return containedTypeCount() > 0; }\n\n    @Override\n    public JavaType getKeyType() { return null; }\n\n    @Override\n    public JavaType getContentType() { return null; }\n\n    @Override \n    public JavaType getReferencedType() { return null; }\n\n    @Override\n    public abstract int containedTypeCount(); @Override public abstract JavaType containedType(int index); @Deprecated @Override public abstract String containedTypeName(int index); @Deprecated @Override public Class<?> getParameterSource() {\n        return null;\n    }\n\n    \n    \n    \n    \n    public JavaType containedTypeOrUnknown(int index) {\n        JavaType t = containedType(index);\n        return (t == null)  ? TypeFactory.unknownType() : t;\n    }\n\n    \n    public abstract TypeBindings getBindings(); public abstract JavaType findSuperType(Class<?> erasedTarget); public abstract JavaType getSuperClass(); public abstract List<JavaType> getInterfaces(); public abstract JavaType[] findTypeParameters(Class<?> expType); @SuppressWarnings(\"unchecked\") public <T> T getValueHandler() { return (T) _valueHandler; }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T getTypeHandler() { return (T) _typeHandler; }\n\n    \n    public Object getContentValueHandler() { return null; }\n\n    \n    public Object getContentTypeHandler() { return null; }    \n\n    \n    public boolean hasValueHandler() { return _valueHandler != null; }\n\n    \n    public boolean hasHandlers() {\n        return (_typeHandler != null) || (_valueHandler != null);\n    }\n    \n    \n    \n    \n\n    \n    public String getGenericSignature() {\n        StringBuilder sb = new StringBuilder(40);\n        getGenericSignature(sb);\n        return sb.toString();        \n    }\n\n    \n    public abstract StringBuilder getGenericSignature(StringBuilder sb); public String getErasedSignature() {\n        StringBuilder sb = new StringBuilder(40);\n        getErasedSignature(sb);\n        return sb.toString();\n    }\n\n    \n    public abstract StringBuilder getErasedSignature(StringBuilder sb); @Override public abstract String toString(); @Override public abstract boolean equals(Object o); @Override public final int hashCode() { return _hash; }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind;\n\nimport java.lang.reflect.Modifier;\nimport java.util.List;\n\nimport com.fasterxml.jackson.core.type.ResolvedType;\nimport com.fasterxml.jackson.databind.type.TypeBindings;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\n\n\npublic abstract class JavaType extends ResolvedType implements java.io.Serializable, java.lang.reflect.Type { private static final long serialVersionUID = 1; protected final Class<?> _class; protected final int _hash; protected final Object _valueHandler; protected final Object _typeHandler; protected final boolean _asStatic; protected JavaType(Class<?> raw, int additionalHash, Object valueHandler, Object typeHandler, boolean asStatic) {\n        _class = raw;\n        _hash = raw.getName().hashCode() + additionalHash;\n        _valueHandler = valueHandler;\n        _typeHandler = typeHandler;\n        _asStatic = asStatic;\n    }\n\n    \n    protected JavaType(JavaType base) {\n        _class = base._class;\n        _hash = base._hash;\n        _valueHandler = base._valueHandler;\n        _typeHandler = base._typeHandler;\n        _asStatic = base._asStatic;\n    }\n\n    \n    public abstract JavaType withTypeHandler(Object h); public abstract JavaType withContentTypeHandler(Object h); public abstract JavaType withValueHandler(Object h); public abstract JavaType withContentValueHandler(Object h); public JavaType withHandlersFrom(JavaType src) {\n        JavaType type = this;\n        Object h = src.getTypeHandler();\n        if (h != _typeHandler) {\n            type = type.withTypeHandler(h);\n        }\n        h = src.getValueHandler();\n        if (h != _valueHandler) {\n            type = type.withValueHandler(h);\n        }\n        return type;\n    }\n\n    \n    public abstract JavaType withContentType(JavaType contentType); public abstract JavaType withStaticTyping(); public abstract JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces); @Deprecated public JavaType forcedNarrowBy(Class<?> subclass) {\n        if (subclass == _class) { \n            return this;\n        }\n        JavaType result = _narrow(subclass);\n        \n        if (_valueHandler != result.<Object>getValueHandler()) {\n            result = result.withValueHandler(_valueHandler);\n        }\n        if (_typeHandler != result.<Object>getTypeHandler()) {\n            result = result.withTypeHandler(_typeHandler);\n        }\n        return result;\n    }\n\n    @Deprecated \n    protected abstract JavaType _narrow(Class<?> subclass); @Override public final Class<?> getRawClass() { return _class; }\n\n    \n    @Override\n    public final boolean hasRawClass(Class<?> clz) { return _class == clz; }\n\n    \n    public boolean hasContentType() {\n        return true;\n    }\n\n    \n    public final boolean isTypeOrSubTypeOf(Class<?> clz) {\n        return (_class == clz) || (clz.isAssignableFrom(_class));\n    }\n\n    @Override\n    public boolean isAbstract() {\n        return Modifier.isAbstract(_class.getModifiers());\n    }\n\n    \n    @Override\n    public boolean isConcrete() {\n        int mod = _class.getModifiers();\n        if ((mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0) {\n            return true;\n        }\n        \n        return _class.isPrimitive();\n    }\n\n    @Override\n    public boolean isThrowable() { return Throwable.class.isAssignableFrom(_class); }\n\n    @Override\n    public boolean isArrayType() { return false; }\n\n    @Override\n    public final boolean isEnumType() { return _class.isEnum(); }\n\n    @Override\n    public final boolean isInterface() { return _class.isInterface(); }\n\n    @Override\n    public final boolean isPrimitive() { return _class.isPrimitive(); }\n\n    @Override\n    public final boolean isFinal() { return Modifier.isFinal(_class.getModifiers()); }\n\n    \n    @Override\n    public abstract boolean isContainerType(); @Override public boolean isCollectionLikeType() { return false; }\n\n    \n    @Override\n    public boolean isMapLikeType() { return false; }\n\n    \n    public final boolean isJavaLangObject() { return _class == Object.class; }\n\n    \n    public final boolean useStaticType() { return _asStatic; }\n\n    \n\n    @Override\n    public boolean hasGenericTypes() { return containedTypeCount() > 0; }\n\n    @Override\n    public JavaType getKeyType() { return null; }\n\n    @Override\n    public JavaType getContentType() { return null; }\n\n    @Override \n    public JavaType getReferencedType() { return null; }\n\n    @Override\n    public abstract int containedTypeCount(); @Override public abstract JavaType containedType(int index); @Deprecated @Override public abstract String containedTypeName(int index); @Deprecated @Override public Class<?> getParameterSource() {\n        return null;\n    }\n\n    \n    \n    \n    \n    public JavaType containedTypeOrUnknown(int index) {\n        JavaType t = containedType(index);\n        return (t == null)  ? TypeFactory.unknownType() : t;\n    }\n\n    \n    public abstract TypeBindings getBindings(); public abstract JavaType findSuperType(Class<?> erasedTarget); public abstract JavaType getSuperClass(); public abstract List<JavaType> getInterfaces(); public abstract JavaType[] findTypeParameters(Class<?> expType); @SuppressWarnings(\"unchecked\") public <T> T getValueHandler() { return (T) _valueHandler; }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T getTypeHandler() { return (T) _typeHandler; }\n\n    \n    public Object getContentValueHandler() { return null; }\n\n    \n    public Object getContentTypeHandler() { return null; }    \n\n    \n    public boolean hasValueHandler() { return _valueHandler != null; }\n\n    \n    public boolean hasHandlers() {\n        return (_typeHandler != null) || (_valueHandler != null);\n    }\n    \n    \n    \n    \n\n    \n    public String getGenericSignature() {\n        StringBuilder sb = new StringBuilder(40);\n        getGenericSignature(sb);\n        return sb.toString();        \n    }\n\n    \n    public abstract StringBuilder getGenericSignature(StringBuilder sb); public String getErasedSignature() {\n        StringBuilder sb = new StringBuilder(40);\n        getErasedSignature(sb);\n        return sb.toString();\n    }\n\n    \n    public abstract StringBuilder getErasedSignature(StringBuilder sb); @Override public abstract String toString(); @Override public abstract boolean equals(Object o); @Override public final int hashCode() { return _hash; }\n}\n",
      "buggy_signatures": [
        "protected JavaType(JavaType base)",
        "public abstract JavaType withTypeHandler(Object h); public abstract JavaType withContentTypeHandler(Object h); public abstract JavaType withValueHandler(Object h); public abstract JavaType withContentValueHandler(Object h); public abstract JavaType withContentType(JavaType contentType); public abstract JavaType withStaticTyping(); public abstract JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces); @Deprecated public JavaType forcedNarrowBy(Class<?> subclass)",
        "protected abstract JavaType _narrow(Class<?> subclass); @Override public final Class<?> getRawClass()",
        "public final boolean hasRawClass(Class<?> clz)",
        "public boolean hasContentType()",
        "public final boolean isTypeOrSubTypeOf(Class<?> clz)",
        "public boolean isAbstract()",
        "public boolean isConcrete()",
        "public boolean isThrowable()",
        "public boolean isArrayType()",
        "public final boolean isEnumType()",
        "public final boolean isInterface()",
        "public final boolean isPrimitive()",
        "public final boolean isFinal()",
        "public abstract boolean isContainerType(); @Override public boolean isCollectionLikeType()",
        "public boolean isMapLikeType()",
        "public final boolean isJavaLangObject()",
        "public final boolean useStaticType()",
        "public boolean hasGenericTypes()",
        "public JavaType getKeyType()",
        "public JavaType getContentType()",
        "public JavaType getReferencedType()",
        "public abstract int containedTypeCount(); @Override public abstract JavaType containedType(int index); @Deprecated @Override public abstract String containedTypeName(int index); @Deprecated @Override public Class<?> getParameterSource()",
        "public JavaType containedTypeOrUnknown(int index)",
        "public abstract TypeBindings getBindings(); public abstract JavaType findSuperType(Class<?> erasedTarget); public abstract JavaType getSuperClass(); public abstract List<JavaType> getInterfaces(); public abstract JavaType[] findTypeParameters(Class<?> expType); @SuppressWarnings(\"unchecked\") public <T> T getValueHandler()",
        "public <T> T getTypeHandler()",
        "public Object getContentValueHandler()",
        "public Object getContentTypeHandler()",
        "public boolean hasValueHandler()",
        "public boolean hasHandlers()",
        "public String getGenericSignature()",
        "public abstract StringBuilder getGenericSignature(StringBuilder sb); public String getErasedSignature()",
        "public abstract StringBuilder getErasedSignature(StringBuilder sb); @Override public abstract String toString(); @Override public abstract boolean equals(Object o); @Override public final int hashCode()"
      ],
      "fixed_signatures": [
        "protected JavaType(JavaType base)",
        "public abstract JavaType withTypeHandler(Object h); public abstract JavaType withContentTypeHandler(Object h); public abstract JavaType withValueHandler(Object h); public abstract JavaType withContentValueHandler(Object h); public JavaType withHandlersFrom(JavaType src)",
        "public abstract JavaType withContentType(JavaType contentType); public abstract JavaType withStaticTyping(); public abstract JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces); @Deprecated public JavaType forcedNarrowBy(Class<?> subclass)",
        "protected abstract JavaType _narrow(Class<?> subclass); @Override public final Class<?> getRawClass()",
        "public final boolean hasRawClass(Class<?> clz)",
        "public boolean hasContentType()",
        "public final boolean isTypeOrSubTypeOf(Class<?> clz)",
        "public boolean isAbstract()",
        "public boolean isConcrete()",
        "public boolean isThrowable()",
        "public boolean isArrayType()",
        "public final boolean isEnumType()",
        "public final boolean isInterface()",
        "public final boolean isPrimitive()",
        "public final boolean isFinal()",
        "public abstract boolean isContainerType(); @Override public boolean isCollectionLikeType()",
        "public boolean isMapLikeType()",
        "public final boolean isJavaLangObject()",
        "public final boolean useStaticType()",
        "public boolean hasGenericTypes()",
        "public JavaType getKeyType()",
        "public JavaType getContentType()",
        "public JavaType getReferencedType()",
        "public abstract int containedTypeCount(); @Override public abstract JavaType containedType(int index); @Deprecated @Override public abstract String containedTypeName(int index); @Deprecated @Override public Class<?> getParameterSource()",
        "public JavaType containedTypeOrUnknown(int index)",
        "public abstract TypeBindings getBindings(); public abstract JavaType findSuperType(Class<?> erasedTarget); public abstract JavaType getSuperClass(); public abstract List<JavaType> getInterfaces(); public abstract JavaType[] findTypeParameters(Class<?> expType); @SuppressWarnings(\"unchecked\") public <T> T getValueHandler()",
        "public <T> T getTypeHandler()",
        "public Object getContentValueHandler()",
        "public Object getContentTypeHandler()",
        "public boolean hasValueHandler()",
        "public boolean hasHandlers()",
        "public String getGenericSignature()",
        "public abstract StringBuilder getGenericSignature(StringBuilder sb); public String getErasedSignature()",
        "public abstract StringBuilder getErasedSignature(StringBuilder sb); @Override public abstract String toString(); @Override public abstract boolean equals(Object o); @Override public final int hashCode()"
      ],
      "methods": [
        {
          "buggy_method": "  public abstract JavaType withContentValueHandler(Object h); /** * Mutant factory method that may be called on structured types * that have a so-called content type (element of arrays, value type * of Maps, referenced type of referential types), * and will construct a new instance that is identical to * this instance, except that it has specified content type, instead of current * one. If content type is already set to given type, <code>this</code> is returned. * If type does not have a content type (which is the case with * <code>SimpleType</code>), {@link IllegalArgumentException}",
          "fixed_method": "  public JavaType withHandlersFrom(JavaType src) {\n  JavaType type = this;\n  Object h = src.getTypeHandler();\n  if (h != _typeHandler) {\n  type = type.withTypeHandler(h);\n  }\n  h = src.getValueHandler();\n  if (h != _valueHandler) {\n  type = type.withValueHandler(h);\n  }\n  return type;\n  }",
          "diff": [
            "@@ -137,6 +137,18 @@",
            "      *\n",
            "      * @since 2.8.4\n",
            "      */\n",
            "+    public JavaType withHandlersFrom(JavaType src) {\n",
            "+        JavaType type = this;\n",
            "+        Object h = src.getTypeHandler();\n",
            "+        if (h != _typeHandler) {\n",
            "+            type = type.withTypeHandler(h);\n",
            "+        }\n",
            "+        h = src.getValueHandler();\n",
            "+        if (h != _valueHandler) {\n",
            "+            type = type.withValueHandler(h);\n",
            "+        }\n",
            "+        return type;\n",
            "+    }\n",
            " \n",
            "     /**\n",
            "      * Mutant factory method that may be called on structured types\n"
          ],
          "changed_lines": 12
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/type/CollectionLikeType.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.type;\n\nimport java.lang.reflect.TypeVariable;\nimport java.util.Collection;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n\npublic class CollectionLikeType extends TypeBase { private static final long serialVersionUID = 1L; protected final JavaType _elementType; protected CollectionLikeType(Class<?> collT, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType elemT, Object valueHandler, Object typeHandler, boolean asStatic) {\n        super(collT, bindings, superClass, superInts,\n                elemT.hashCode(), valueHandler, typeHandler, asStatic);\n        _elementType = elemT;\n    }\n\n    \n    protected CollectionLikeType(TypeBase base, JavaType elemT) {\n        super(base);\n        _elementType = elemT;\n    }\n\n    \n    public static CollectionLikeType construct(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType elemT) {\n        return new CollectionLikeType(rawType, bindings, superClass, superInts, elemT,\n                null, null, false);\n    }\n\n    \n    @Deprecated \n    public static CollectionLikeType construct(Class<?> rawType, JavaType elemT) {\n        \n        \n        TypeVariable<?>[] vars = rawType.getTypeParameters();\n        TypeBindings bindings;\n        if ((vars == null) || (vars.length != 1)) {\n            bindings = TypeBindings.emptyBindings();\n        } else {\n            bindings = TypeBindings.create(rawType, elemT);\n        }\n        return new CollectionLikeType(rawType, bindings,\n                _bogusSuperClass(rawType), null,\n                elemT, null, null, false);\n    }\n\n    \n    public static CollectionLikeType upgradeFrom(JavaType baseType, JavaType elementType) {\n        \n        \n        if (baseType instanceof TypeBase) {\n            return new CollectionLikeType((TypeBase) baseType, elementType);\n        }\n        throw new IllegalArgumentException(\"Can not upgrade from an instance of \"+baseType.getClass());\n    }\n\n    @Override\n    @Deprecated \n    protected JavaType _narrow(Class<?> subclass) {\n        return new CollectionLikeType(subclass, _bindings,\n                _superClass, _superInterfaces, _elementType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        if (_elementType == contentType) {\n            return this;\n        }\n        return new CollectionLikeType(_class, _bindings, _superClass, _superInterfaces,\n                contentType, _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public CollectionLikeType withTypeHandler(Object h) {\n        return new CollectionLikeType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public CollectionLikeType withContentTypeHandler(Object h) {\n        return new CollectionLikeType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType.withTypeHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public CollectionLikeType withValueHandler(Object h) {\n        return new CollectionLikeType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType, h, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public CollectionLikeType withContentValueHandler(Object h) {\n        return new CollectionLikeType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType.withValueHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    \n    @Override\n    public CollectionLikeType withStaticTyping() {\n        if (_asStatic) {\n            return this;\n        }\n        return new CollectionLikeType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType.withStaticTyping(),\n                _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        return new CollectionLikeType(rawType, bindings,\n                superClass, superInterfaces, _elementType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    \n\n    @Override\n    public boolean isContainerType() { return true; }\n\n    @Override\n    public boolean isCollectionLikeType() { return true; }\n\n    @Override\n    public JavaType getContentType() { return _elementType; }\n\n    @Override\n    public Object getContentValueHandler() {\n        return _elementType.getValueHandler();\n    }\n\n    @Override\n    public Object getContentTypeHandler() {\n        return _elementType.getTypeHandler();\n    }    \n\n    @Override\n    public boolean hasHandlers() {\n        return super.hasHandlers() || _elementType.hasHandlers();\n    }\n\n    @Override\n    public StringBuilder getErasedSignature(StringBuilder sb) {\n        return _classSignature(_class, sb, true);\n    }\n    \n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb) {\n        _classSignature(_class, sb, false);\n        sb.append('<');\n        _elementType.getGenericSignature(sb);\n        sb.append(\">;\");\n        return sb;\n    }\n    \n    @Override\n    protected String buildCanonicalName() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n        if (_elementType != null) {\n            sb.append('<');\n            sb.append(_elementType.toCanonical());\n            sb.append('>');\n        }\n        return sb.toString();\n    }\n\n    \n\n    \n    public boolean isTrueCollectionType() {\n        return Collection.class.isAssignableFrom(_class);\n    }\n\n    \n\n    @Override\n    public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        CollectionLikeType other = (CollectionLikeType) o;\n        return  (_class == other._class) && _elementType.equals(other._elementType);\n    }\n\n    @Override\n    public String toString() {\n        return \"[collection-like type; class \"+_class.getName()+\", contains \"+_elementType+\"]\";\n    }\n\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.type;\n\nimport java.lang.reflect.TypeVariable;\nimport java.util.Collection;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n\npublic class CollectionLikeType extends TypeBase { private static final long serialVersionUID = 1L; protected final JavaType _elementType; protected CollectionLikeType(Class<?> collT, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType elemT, Object valueHandler, Object typeHandler, boolean asStatic) {\n        super(collT, bindings, superClass, superInts,\n                elemT.hashCode(), valueHandler, typeHandler, asStatic);\n        _elementType = elemT;\n    }\n\n    \n    protected CollectionLikeType(TypeBase base, JavaType elemT) {\n        super(base);\n        _elementType = elemT;\n    }\n\n    \n    public static CollectionLikeType construct(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType elemT) {\n        return new CollectionLikeType(rawType, bindings, superClass, superInts, elemT,\n                null, null, false);\n    }\n\n    \n    @Deprecated \n    public static CollectionLikeType construct(Class<?> rawType, JavaType elemT) {\n        \n        \n        TypeVariable<?>[] vars = rawType.getTypeParameters();\n        TypeBindings bindings;\n        if ((vars == null) || (vars.length != 1)) {\n            bindings = TypeBindings.emptyBindings();\n        } else {\n            bindings = TypeBindings.create(rawType, elemT);\n        }\n        return new CollectionLikeType(rawType, bindings,\n                _bogusSuperClass(rawType), null,\n                elemT, null, null, false);\n    }\n\n    \n    public static CollectionLikeType upgradeFrom(JavaType baseType, JavaType elementType) {\n        \n        \n        if (baseType instanceof TypeBase) {\n            return new CollectionLikeType((TypeBase) baseType, elementType);\n        }\n        throw new IllegalArgumentException(\"Can not upgrade from an instance of \"+baseType.getClass());\n    }\n\n    @Override\n    @Deprecated \n    protected JavaType _narrow(Class<?> subclass) {\n        return new CollectionLikeType(subclass, _bindings,\n                _superClass, _superInterfaces, _elementType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        if (_elementType == contentType) {\n            return this;\n        }\n        return new CollectionLikeType(_class, _bindings, _superClass, _superInterfaces,\n                contentType, _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public CollectionLikeType withTypeHandler(Object h) {\n        return new CollectionLikeType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public CollectionLikeType withContentTypeHandler(Object h) {\n        return new CollectionLikeType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType.withTypeHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public CollectionLikeType withValueHandler(Object h) {\n        return new CollectionLikeType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType, h, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public CollectionLikeType withContentValueHandler(Object h) {\n        return new CollectionLikeType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType.withValueHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public JavaType withHandlersFrom(JavaType src) {\n        JavaType type = super.withHandlersFrom(src);\n        JavaType srcCt = src.getContentType();\n        if (srcCt != null) {\n            JavaType ct = _elementType.withHandlersFrom(srcCt);\n            if (ct != _elementType) {\n                type = type.withContentType(ct);\n            }\n        }\n        return type;\n    }\n    \n    @Override\n    public CollectionLikeType withStaticTyping() {\n        if (_asStatic) {\n            return this;\n        }\n        return new CollectionLikeType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType.withStaticTyping(),\n                _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        return new CollectionLikeType(rawType, bindings,\n                superClass, superInterfaces, _elementType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    \n\n    @Override\n    public boolean isContainerType() { return true; }\n\n    @Override\n    public boolean isCollectionLikeType() { return true; }\n\n    @Override\n    public JavaType getContentType() { return _elementType; }\n\n    @Override\n    public Object getContentValueHandler() {\n        return _elementType.getValueHandler();\n    }\n\n    @Override\n    public Object getContentTypeHandler() {\n        return _elementType.getTypeHandler();\n    }    \n\n    @Override\n    public boolean hasHandlers() {\n        return super.hasHandlers() || _elementType.hasHandlers();\n    }\n\n    @Override\n    public StringBuilder getErasedSignature(StringBuilder sb) {\n        return _classSignature(_class, sb, true);\n    }\n    \n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb) {\n        _classSignature(_class, sb, false);\n        sb.append('<');\n        _elementType.getGenericSignature(sb);\n        sb.append(\">;\");\n        return sb;\n    }\n    \n    @Override\n    protected String buildCanonicalName() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n        if (_elementType != null) {\n            sb.append('<');\n            sb.append(_elementType.toCanonical());\n            sb.append('>');\n        }\n        return sb.toString();\n    }\n\n    \n\n    \n    public boolean isTrueCollectionType() {\n        return Collection.class.isAssignableFrom(_class);\n    }\n\n    \n\n    @Override\n    public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        CollectionLikeType other = (CollectionLikeType) o;\n        return  (_class == other._class) && _elementType.equals(other._elementType);\n    }\n\n    @Override\n    public String toString() {\n        return \"[collection-like type; class \"+_class.getName()+\", contains \"+_elementType+\"]\";\n    }\n\n}\n",
      "buggy_signatures": [
        "protected CollectionLikeType(TypeBase base, JavaType elemT)",
        "public static CollectionLikeType construct(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType elemT)",
        "public static CollectionLikeType construct(Class<?> rawType, JavaType elemT)",
        "public static CollectionLikeType upgradeFrom(JavaType baseType, JavaType elementType)",
        "protected JavaType _narrow(Class<?> subclass)",
        "public JavaType withContentType(JavaType contentType)",
        "public CollectionLikeType withTypeHandler(Object h)",
        "public CollectionLikeType withContentTypeHandler(Object h)",
        "public CollectionLikeType withValueHandler(Object h)",
        "public CollectionLikeType withContentValueHandler(Object h)",
        "public CollectionLikeType withStaticTyping()",
        "public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "public boolean isContainerType()",
        "public boolean isCollectionLikeType()",
        "public JavaType getContentType()",
        "public Object getContentValueHandler()",
        "public Object getContentTypeHandler()",
        "public boolean hasHandlers()",
        "public StringBuilder getErasedSignature(StringBuilder sb)",
        "public StringBuilder getGenericSignature(StringBuilder sb)",
        "protected String buildCanonicalName()",
        "public boolean isTrueCollectionType()",
        "public boolean equals(Object o)",
        "public String toString()"
      ],
      "fixed_signatures": [
        "protected CollectionLikeType(TypeBase base, JavaType elemT)",
        "public static CollectionLikeType construct(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType elemT)",
        "public static CollectionLikeType construct(Class<?> rawType, JavaType elemT)",
        "public static CollectionLikeType upgradeFrom(JavaType baseType, JavaType elementType)",
        "protected JavaType _narrow(Class<?> subclass)",
        "public JavaType withContentType(JavaType contentType)",
        "public CollectionLikeType withTypeHandler(Object h)",
        "public CollectionLikeType withContentTypeHandler(Object h)",
        "public CollectionLikeType withValueHandler(Object h)",
        "public CollectionLikeType withContentValueHandler(Object h)",
        "public JavaType withHandlersFrom(JavaType src)",
        "public CollectionLikeType withStaticTyping()",
        "public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "public boolean isContainerType()",
        "public boolean isCollectionLikeType()",
        "public JavaType getContentType()",
        "public Object getContentValueHandler()",
        "public Object getContentTypeHandler()",
        "public boolean hasHandlers()",
        "public StringBuilder getErasedSignature(StringBuilder sb)",
        "public StringBuilder getGenericSignature(StringBuilder sb)",
        "protected String buildCanonicalName()",
        "public boolean isTrueCollectionType()",
        "public boolean equals(Object o)",
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "  public CollectionLikeType withStaticTyping() {\n  if (_asStatic) {\n  return this;\n  }\n  return new CollectionLikeType(_class, _bindings,\n  _superClass, _superInterfaces, _elementType.withStaticTyping(),\n  _valueHandler, _typeHandler, true);\n  }",
          "fixed_method": "  public JavaType withHandlersFrom(JavaType src) {\n  JavaType type = super.withHandlersFrom(src);\n  JavaType srcCt = src.getContentType();\n  if (srcCt != null) {\n  JavaType ct = _elementType.withHandlersFrom(srcCt);\n  if (ct != _elementType) {\n  type = type.withContentType(ct);\n  }\n  }\n  return type;\n  }",
          "diff": [
            "@@ -133,6 +133,18 @@",
            "                 _valueHandler, _typeHandler, _asStatic);\n",
            "     }\n",
            " \n",
            "+    @Override\n",
            "+    public JavaType withHandlersFrom(JavaType src) {\n",
            "+        JavaType type = super.withHandlersFrom(src);\n",
            "+        JavaType srcCt = src.getContentType();\n",
            "+        if (srcCt != null) {\n",
            "+            JavaType ct = _elementType.withHandlersFrom(srcCt);\n",
            "+            if (ct != _elementType) {\n",
            "+                type = type.withContentType(ct);\n",
            "+            }\n",
            "+        }\n",
            "+        return type;\n",
            "+    }\n",
            "     \n",
            "     @Override\n",
            "     public CollectionLikeType withStaticTyping() {\n"
          ],
          "changed_lines": 12
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/type/MapLikeType.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.type;\n\nimport java.lang.reflect.TypeVariable;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n\npublic class MapLikeType extends TypeBase { private static final long serialVersionUID = 1L; protected final JavaType _keyType; protected final JavaType _valueType; protected MapLikeType(Class<?> mapType, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType keyT, JavaType valueT, Object valueHandler, Object typeHandler, boolean asStatic) {\n        super(mapType, bindings, superClass, superInts, keyT.hashCode()\n                ^ valueT.hashCode(), valueHandler, typeHandler, asStatic);\n        _keyType = keyT;\n        _valueType = valueT;\n    }\n\n    \n    protected MapLikeType(TypeBase base, JavaType keyT, JavaType valueT) {\n        super(base);\n        _keyType = keyT;\n        _valueType = valueT;\n    }\n\n    \n    public static MapLikeType upgradeFrom(JavaType baseType, JavaType keyT, JavaType valueT) {\n        \n        \n        \n        if (baseType instanceof TypeBase) {\n            return new MapLikeType((TypeBase) baseType, keyT, valueT);\n        }\n        throw new IllegalArgumentException(\n                \"Can not upgrade from an instance of \" + baseType.getClass());\n    }\n\n    @Deprecated\n    \n    public static MapLikeType construct(Class<?> rawType, JavaType keyT, JavaType valueT) {\n        \n        \n        TypeVariable<?>[] vars = rawType.getTypeParameters();\n        TypeBindings bindings;\n        if ((vars == null) || (vars.length != 2)) {\n            bindings = TypeBindings.emptyBindings();\n        } else {\n            bindings = TypeBindings.create(rawType, keyT, valueT);\n        }\n        return new MapLikeType(rawType, bindings, _bogusSuperClass(rawType),\n                null, keyT, valueT, null, null, false);\n    }\n\n    @Deprecated\n    \n    @Override\n    protected JavaType _narrow(Class<?> subclass) {\n        return new MapLikeType(subclass, _bindings, _superClass,\n                _superInterfaces, _keyType, _valueType, _valueHandler,\n                _typeHandler, _asStatic);\n    }\n\n    \n    public MapLikeType withKeyType(JavaType keyType) {\n        if (keyType == _keyType) {\n            return this;\n        }\n        return new MapLikeType(_class, _bindings, _superClass,\n                _superInterfaces, keyType, _valueType, _valueHandler,\n                _typeHandler, _asStatic);\n    }\n\n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        if (_valueType == contentType) {\n            return this;\n        }\n        return new MapLikeType(_class, _bindings, _superClass,\n                _superInterfaces, _keyType, contentType, _valueHandler,\n                _typeHandler, _asStatic);\n    }\n\n    @Override\n    public MapLikeType withTypeHandler(Object h) {\n        return new MapLikeType(_class, _bindings, _superClass,\n                _superInterfaces, _keyType, _valueType, _valueHandler, h,\n                _asStatic);\n    }\n\n    @Override\n    public MapLikeType withContentTypeHandler(Object h) {\n        return new MapLikeType(_class, _bindings, _superClass,\n                _superInterfaces, _keyType, _valueType.withTypeHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public MapLikeType withValueHandler(Object h) {\n        return new MapLikeType(_class, _bindings, _superClass,\n                _superInterfaces, _keyType, _valueType, h, _typeHandler,\n                _asStatic);\n    }\n\n    @Override\n    public MapLikeType withContentValueHandler(Object h) {\n        return new MapLikeType(_class, _bindings, _superClass,\n                _superInterfaces, _keyType, _valueType.withValueHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n        \n\n    @Override\n    public MapLikeType withStaticTyping() {\n        if (_asStatic) {\n            return this;\n        }\n        return new MapLikeType(_class, _bindings, _superClass,\n                _superInterfaces, _keyType, _valueType.withStaticTyping(),\n                _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        return new MapLikeType(rawType, bindings, superClass, superInterfaces,\n                _keyType, _valueType, _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    protected String buildCanonicalName() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n        if (_keyType != null) {\n            sb.append('<');\n            sb.append(_keyType.toCanonical());\n            sb.append(',');\n            sb.append(_valueType.toCanonical());\n            sb.append('>');\n        }\n        return sb.toString();\n    }\n\n    \n\n    @Override\n    public boolean isContainerType() {\n        return true;\n    }\n\n    @Override\n    public boolean isMapLikeType() {\n        return true;\n    }\n\n    @Override\n    public JavaType getKeyType() {\n        return _keyType;\n    }\n\n    @Override\n    public JavaType getContentType() {\n        return _valueType;\n    }\n\n    @Override\n    public Object getContentValueHandler() {\n        return _valueType.getValueHandler();\n    }\n\n    @Override\n    public Object getContentTypeHandler() {\n        return _valueType.getTypeHandler();\n    }\n\n    @Override\n    public boolean hasHandlers() {\n        return super.hasHandlers() || _valueType.hasHandlers()\n                || _keyType.hasHandlers();\n    }\n\n    @Override\n    public StringBuilder getErasedSignature(StringBuilder sb) {\n        return _classSignature(_class, sb, true);\n    }\n\n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb) {\n        _classSignature(_class, sb, false);\n        sb.append('<');\n        _keyType.getGenericSignature(sb);\n        _valueType.getGenericSignature(sb);\n        sb.append(\">;\");\n        return sb;\n    }\n\n    \n\n    public MapLikeType withKeyTypeHandler(Object h) {\n        return new MapLikeType(_class, _bindings, _superClass,\n                _superInterfaces, _keyType.withTypeHandler(h), _valueType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    public MapLikeType withKeyValueHandler(Object h) {\n        return new MapLikeType(_class, _bindings, _superClass,\n                _superInterfaces, _keyType.withValueHandler(h), _valueType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    \n    public boolean isTrueMapType() {\n        return Map.class.isAssignableFrom(_class);\n    }\n\n    \n\n    @Override\n    public String toString() {\n        return String.format(\"[map-like type; class %s, %s -> %s]\",\n                _class.getName(), _keyType, _valueType);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        MapLikeType other = (MapLikeType) o;\n        return (_class == other._class) && _keyType.equals(other._keyType)\n                && _valueType.equals(other._valueType);\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.type;\n\nimport java.lang.reflect.TypeVariable;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n\npublic class MapLikeType extends TypeBase { private static final long serialVersionUID = 1L; protected final JavaType _keyType; protected final JavaType _valueType; protected MapLikeType(Class<?> mapType, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType keyT, JavaType valueT, Object valueHandler, Object typeHandler, boolean asStatic) {\n        super(mapType, bindings, superClass, superInts, keyT.hashCode()\n                ^ valueT.hashCode(), valueHandler, typeHandler, asStatic);\n        _keyType = keyT;\n        _valueType = valueT;\n    }\n\n    \n    protected MapLikeType(TypeBase base, JavaType keyT, JavaType valueT) {\n        super(base);\n        _keyType = keyT;\n        _valueType = valueT;\n    }\n\n    \n    public static MapLikeType upgradeFrom(JavaType baseType, JavaType keyT, JavaType valueT) {\n        \n        \n        \n        if (baseType instanceof TypeBase) {\n            return new MapLikeType((TypeBase) baseType, keyT, valueT);\n        }\n        throw new IllegalArgumentException(\n                \"Can not upgrade from an instance of \" + baseType.getClass());\n    }\n\n    @Deprecated\n    \n    public static MapLikeType construct(Class<?> rawType, JavaType keyT, JavaType valueT) {\n        \n        \n        TypeVariable<?>[] vars = rawType.getTypeParameters();\n        TypeBindings bindings;\n        if ((vars == null) || (vars.length != 2)) {\n            bindings = TypeBindings.emptyBindings();\n        } else {\n            bindings = TypeBindings.create(rawType, keyT, valueT);\n        }\n        return new MapLikeType(rawType, bindings, _bogusSuperClass(rawType),\n                null, keyT, valueT, null, null, false);\n    }\n\n    @Deprecated\n    \n    @Override\n    protected JavaType _narrow(Class<?> subclass) {\n        return new MapLikeType(subclass, _bindings, _superClass,\n                _superInterfaces, _keyType, _valueType, _valueHandler,\n                _typeHandler, _asStatic);\n    }\n\n    \n    public MapLikeType withKeyType(JavaType keyType) {\n        if (keyType == _keyType) {\n            return this;\n        }\n        return new MapLikeType(_class, _bindings, _superClass,\n                _superInterfaces, keyType, _valueType, _valueHandler,\n                _typeHandler, _asStatic);\n    }\n\n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        if (_valueType == contentType) {\n            return this;\n        }\n        return new MapLikeType(_class, _bindings, _superClass,\n                _superInterfaces, _keyType, contentType, _valueHandler,\n                _typeHandler, _asStatic);\n    }\n\n    @Override\n    public MapLikeType withTypeHandler(Object h) {\n        return new MapLikeType(_class, _bindings, _superClass,\n                _superInterfaces, _keyType, _valueType, _valueHandler, h,\n                _asStatic);\n    }\n\n    @Override\n    public MapLikeType withContentTypeHandler(Object h) {\n        return new MapLikeType(_class, _bindings, _superClass,\n                _superInterfaces, _keyType, _valueType.withTypeHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public MapLikeType withValueHandler(Object h) {\n        return new MapLikeType(_class, _bindings, _superClass,\n                _superInterfaces, _keyType, _valueType, h, _typeHandler,\n                _asStatic);\n    }\n\n    @Override\n    public MapLikeType withContentValueHandler(Object h) {\n        return new MapLikeType(_class, _bindings, _superClass,\n                _superInterfaces, _keyType, _valueType.withValueHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public JavaType withHandlersFrom(JavaType src) {\n        JavaType type = super.withHandlersFrom(src);\n        JavaType srcKeyType = src.getKeyType();\n        \n        if (type instanceof MapLikeType) {\n            if (srcKeyType != null) {\n                JavaType ct = _keyType.withHandlersFrom(srcKeyType);\n                if (ct != _keyType) {\n                    type = ((MapLikeType) type).withKeyType(ct);\n                }\n            }\n        }\n        JavaType srcCt = src.getContentType();\n        if (srcCt != null) {\n            JavaType ct = _valueType.withHandlersFrom(srcCt);\n            if (ct != _valueType) {\n                type = type.withContentType(ct);\n            }\n        }\n        return type;\n    }\n\n    @Override\n    public MapLikeType withStaticTyping() {\n        if (_asStatic) {\n            return this;\n        }\n        return new MapLikeType(_class, _bindings, _superClass,\n                _superInterfaces, _keyType, _valueType.withStaticTyping(),\n                _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        return new MapLikeType(rawType, bindings, superClass, superInterfaces,\n                _keyType, _valueType, _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    protected String buildCanonicalName() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n        if (_keyType != null) {\n            sb.append('<');\n            sb.append(_keyType.toCanonical());\n            sb.append(',');\n            sb.append(_valueType.toCanonical());\n            sb.append('>');\n        }\n        return sb.toString();\n    }\n\n    \n\n    @Override\n    public boolean isContainerType() {\n        return true;\n    }\n\n    @Override\n    public boolean isMapLikeType() {\n        return true;\n    }\n\n    @Override\n    public JavaType getKeyType() {\n        return _keyType;\n    }\n\n    @Override\n    public JavaType getContentType() {\n        return _valueType;\n    }\n\n    @Override\n    public Object getContentValueHandler() {\n        return _valueType.getValueHandler();\n    }\n\n    @Override\n    public Object getContentTypeHandler() {\n        return _valueType.getTypeHandler();\n    }\n\n    @Override\n    public boolean hasHandlers() {\n        return super.hasHandlers() || _valueType.hasHandlers()\n                || _keyType.hasHandlers();\n    }\n\n    @Override\n    public StringBuilder getErasedSignature(StringBuilder sb) {\n        return _classSignature(_class, sb, true);\n    }\n\n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb) {\n        _classSignature(_class, sb, false);\n        sb.append('<');\n        _keyType.getGenericSignature(sb);\n        _valueType.getGenericSignature(sb);\n        sb.append(\">;\");\n        return sb;\n    }\n\n    \n\n    public MapLikeType withKeyTypeHandler(Object h) {\n        return new MapLikeType(_class, _bindings, _superClass,\n                _superInterfaces, _keyType.withTypeHandler(h), _valueType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    public MapLikeType withKeyValueHandler(Object h) {\n        return new MapLikeType(_class, _bindings, _superClass,\n                _superInterfaces, _keyType.withValueHandler(h), _valueType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    \n    public boolean isTrueMapType() {\n        return Map.class.isAssignableFrom(_class);\n    }\n\n    \n\n    @Override\n    public String toString() {\n        return String.format(\"[map-like type; class %s, %s -> %s]\",\n                _class.getName(), _keyType, _valueType);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        MapLikeType other = (MapLikeType) o;\n        return (_class == other._class) && _keyType.equals(other._keyType)\n                && _valueType.equals(other._valueType);\n    }\n}\n",
      "buggy_signatures": [
        "protected MapLikeType(TypeBase base, JavaType keyT, JavaType valueT)",
        "public static MapLikeType upgradeFrom(JavaType baseType, JavaType keyT, JavaType valueT)",
        "public static MapLikeType construct(Class<?> rawType, JavaType keyT, JavaType valueT)",
        "protected JavaType _narrow(Class<?> subclass)",
        "public MapLikeType withKeyType(JavaType keyType)",
        "public JavaType withContentType(JavaType contentType)",
        "public MapLikeType withTypeHandler(Object h)",
        "public MapLikeType withContentTypeHandler(Object h)",
        "public MapLikeType withValueHandler(Object h)",
        "public MapLikeType withContentValueHandler(Object h)",
        "public MapLikeType withStaticTyping()",
        "public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected String buildCanonicalName()",
        "public boolean isContainerType()",
        "public boolean isMapLikeType()",
        "public JavaType getKeyType()",
        "public JavaType getContentType()",
        "public Object getContentValueHandler()",
        "public Object getContentTypeHandler()",
        "public boolean hasHandlers()",
        "public StringBuilder getErasedSignature(StringBuilder sb)",
        "public StringBuilder getGenericSignature(StringBuilder sb)",
        "public MapLikeType withKeyTypeHandler(Object h)",
        "public MapLikeType withKeyValueHandler(Object h)",
        "public boolean isTrueMapType()",
        "public String toString()",
        "public boolean equals(Object o)"
      ],
      "fixed_signatures": [
        "protected MapLikeType(TypeBase base, JavaType keyT, JavaType valueT)",
        "public static MapLikeType upgradeFrom(JavaType baseType, JavaType keyT, JavaType valueT)",
        "public static MapLikeType construct(Class<?> rawType, JavaType keyT, JavaType valueT)",
        "protected JavaType _narrow(Class<?> subclass)",
        "public MapLikeType withKeyType(JavaType keyType)",
        "public JavaType withContentType(JavaType contentType)",
        "public MapLikeType withTypeHandler(Object h)",
        "public MapLikeType withContentTypeHandler(Object h)",
        "public MapLikeType withValueHandler(Object h)",
        "public MapLikeType withContentValueHandler(Object h)",
        "public JavaType withHandlersFrom(JavaType src)",
        "public MapLikeType withStaticTyping()",
        "public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected String buildCanonicalName()",
        "public boolean isContainerType()",
        "public boolean isMapLikeType()",
        "public JavaType getKeyType()",
        "public JavaType getContentType()",
        "public Object getContentValueHandler()",
        "public Object getContentTypeHandler()",
        "public boolean hasHandlers()",
        "public StringBuilder getErasedSignature(StringBuilder sb)",
        "public StringBuilder getGenericSignature(StringBuilder sb)",
        "public MapLikeType withKeyTypeHandler(Object h)",
        "public MapLikeType withKeyValueHandler(Object h)",
        "public boolean isTrueMapType()",
        "public String toString()",
        "public boolean equals(Object o)"
      ],
      "methods": [
        {
          "buggy_method": "  public MapLikeType withStaticTyping() {\n  if (_asStatic) {\n  return this;\n  }\n  return new MapLikeType(_class, _bindings, _superClass,\n  _superInterfaces, _keyType, _valueType.withStaticTyping(),\n  _valueHandler, _typeHandler, true);\n  }",
          "fixed_method": "  public JavaType withHandlersFrom(JavaType src) {\n  JavaType type = super.withHandlersFrom(src);\n  JavaType srcKeyType = src.getKeyType();\n  \n  if (type instanceof MapLikeType) {\n  if (srcKeyType != null) {\n  JavaType ct = _keyType.withHandlersFrom(srcKeyType);\n  if (ct != _keyType) {\n  type = ((MapLikeType) type).withKeyType(ct);\n  }\n  }\n  }\n  JavaType srcCt = src.getContentType();\n  if (srcCt != null) {\n  JavaType ct = _valueType.withHandlersFrom(srcCt);\n  if (ct != _valueType) {\n  type = type.withContentType(ct);\n  }\n  }\n  return type;\n  }",
          "diff": [
            "@@ -145,7 +145,28 @@",
            "                 _valueHandler, _typeHandler, _asStatic);\n",
            "     }\n",
            " \n",
            "+    @Override\n",
            "+    public JavaType withHandlersFrom(JavaType src) {\n",
            "+        JavaType type = super.withHandlersFrom(src);\n",
            "+        JavaType srcKeyType = src.getKeyType();\n",
            "         // \"withKeyType()\" not part of JavaType, hence must verify:\n",
            "+        if (type instanceof MapLikeType) {\n",
            "+            if (srcKeyType != null) {\n",
            "+                JavaType ct = _keyType.withHandlersFrom(srcKeyType);\n",
            "+                if (ct != _keyType) {\n",
            "+                    type = ((MapLikeType) type).withKeyType(ct);\n",
            "+                }\n",
            "+            }\n",
            "+        }\n",
            "+        JavaType srcCt = src.getContentType();\n",
            "+        if (srcCt != null) {\n",
            "+            JavaType ct = _valueType.withHandlersFrom(srcCt);\n",
            "+            if (ct != _valueType) {\n",
            "+                type = type.withContentType(ct);\n",
            "+            }\n",
            "+        }\n",
            "+        return type;\n",
            "+    }\n",
            " \n",
            "     @Override\n",
            "     public MapLikeType withStaticTyping() {\n"
          ],
          "changed_lines": 21
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/type/TypeFactory.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.type;\n\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.lang.reflect.*;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.LRUMap;\n\n\n@SuppressWarnings({\"rawtypes\" })\npublic final class TypeFactory implements java.io.Serializable { private static final long serialVersionUID = 1L; private final static JavaType[] NO_TYPES = new JavaType[0]; protected final static TypeFactory instance = new TypeFactory(); protected final static TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings(); private final static Class<?> CLS_STRING = String.class; private final static Class<?> CLS_OBJECT = Object.class; private final static Class<?> CLS_COMPARABLE = Comparable.class; private final static Class<?> CLS_CLASS = Class.class; private final static Class<?> CLS_ENUM = Enum.class; private final static Class<?> CLS_BOOL = Boolean.TYPE; private final static Class<?> CLS_INT = Integer.TYPE; private final static Class<?> CLS_LONG = Long.TYPE; protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(CLS_BOOL); protected final static SimpleType CORE_TYPE_INT = new SimpleType(CLS_INT); protected final static SimpleType CORE_TYPE_LONG = new SimpleType(CLS_LONG); protected final static SimpleType CORE_TYPE_STRING = new SimpleType(CLS_STRING); protected final static SimpleType CORE_TYPE_OBJECT = new SimpleType(CLS_OBJECT); protected final static SimpleType CORE_TYPE_COMPARABLE = new SimpleType(CLS_COMPARABLE); protected final static SimpleType CORE_TYPE_ENUM = new SimpleType(CLS_ENUM); protected final static SimpleType CORE_TYPE_CLASS = new SimpleType(CLS_CLASS); protected final LRUMap<Object,JavaType> _typeCache; protected final TypeModifier[] _modifiers; protected final TypeParser _parser; protected final ClassLoader _classLoader; private TypeFactory() {\n        this(null);\n    }\n\n    \n    protected TypeFactory(LRUMap<Object,JavaType> typeCache) {\n        if (typeCache == null) {\n            typeCache = new LRUMap<Object,JavaType>(16, 200);\n        }\n        _typeCache = typeCache;\n        _parser = new TypeParser(this);\n        _modifiers = null;\n        _classLoader = null;\n    }\n\n    protected TypeFactory(LRUMap<Object,JavaType> typeCache, TypeParser p, TypeModifier[] mods, ClassLoader classLoader) {\n        if (typeCache == null) {\n            typeCache = new LRUMap<Object,JavaType>(16, 200);\n        }\n        _typeCache = typeCache;\n        \n        _parser = p.withFactory(this);\n        _modifiers = mods;\n        _classLoader = classLoader;\n    }\n\n    public TypeFactory withModifier(TypeModifier mod) {\n        LRUMap<Object,JavaType> typeCache = _typeCache;\n        TypeModifier[] mods;\n        if (mod == null) { \n            mods = null;\n            \n            \n            typeCache = null;\n        } else if (_modifiers == null) {\n            mods = new TypeModifier[] { mod };\n        } else {\n            mods = ArrayBuilders.insertInListNoDup(_modifiers, mod);\n        }\n        return new TypeFactory(typeCache, _parser, mods, _classLoader);\n    }\n\n    public TypeFactory withClassLoader(ClassLoader classLoader) {\n        return new TypeFactory(_typeCache, _parser, _modifiers, classLoader);\n    }\n\n    \n    public TypeFactory withCache(LRUMap<Object,JavaType> cache) {\n        return new TypeFactory(cache, _parser, _modifiers, _classLoader);\n    }\n\n    \n    public static TypeFactory defaultInstance() { return instance; }\n\n    \n    public void clearCache() {\n        _typeCache.clear();\n    }\n\n    public ClassLoader getClassLoader() {\n        return _classLoader;\n    }\n    \n    \n    \n    \n    public static JavaType unknownType() {\n        return defaultInstance()._unknownType();\n    }\n\n    \n    public static Class<?> rawClass(Type t) {\n        if (t instanceof Class<?>) {\n            return (Class<?>) t;\n        }\n        \n        return defaultInstance().constructType(t).getRawClass();\n    }\n\n    \n\n    \n    public Class<?> findClass(String className) throws ClassNotFoundException {\n        if (className.indexOf('.') < 0) {\n            Class<?> prim = _findPrimitive(className);\n            if (prim != null) {\n                return prim;\n            }\n        }\n        \n        Throwable prob = null;\n        ClassLoader loader = this.getClassLoader();\n        if (loader == null) {\n            loader = \tThread.currentThread().getContextClassLoader();\n        }\n        if (loader != null) {\n            try {\n                return classForName(className, true, loader);\n            } catch (Exception e) {\n                prob = ClassUtil.getRootCause(e);\n            }\n        }\n        try {\n            return classForName(className);\n        } catch (Exception e) {\n            if (prob == null) {\n                prob = ClassUtil.getRootCause(e);\n            }\n        }\n        if (prob instanceof RuntimeException) {\n            throw (RuntimeException) prob;\n        }\n        throw new ClassNotFoundException(prob.getMessage(), prob);\n    }\n    \n    protected Class<?> classForName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException {\n    \treturn Class.forName(name, true, loader);\n    }\n    \n    protected Class<?> classForName(String name) throws ClassNotFoundException {\n        return Class.forName(name);\n    }\n\n    protected Class<?> _findPrimitive(String className) {\n        if (\"int\".equals(className)) return Integer.TYPE;\n        if (\"long\".equals(className)) return Long.TYPE;\n        if (\"float\".equals(className)) return Float.TYPE;\n        if (\"double\".equals(className)) return Double.TYPE;\n        if (\"boolean\".equals(className)) return Boolean.TYPE;\n        if (\"byte\".equals(className)) return Byte.TYPE;\n        if (\"char\".equals(className)) return Character.TYPE;\n        if (\"short\".equals(className)) return Short.TYPE;\n        if (\"void\".equals(className)) return Void.TYPE;\n        return null;\n    }\n    \n    \n\n    \n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n        \n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == subclass) {\n            return baseType;\n        }\n\n        JavaType newType;\n\n        \n        do { \n            if (rawBase == Object.class) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                break;\n            }\n            if (!rawBase.isAssignableFrom(subclass)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not subtype of %s\", subclass.getName(), baseType));\n            }\n            \n\n            \n            if (baseType.getBindings().isEmpty()) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            \n            if (baseType.isContainerType()) {\n                if (baseType.isMapLikeType()) {\n                    if ((subclass == HashMap.class)\n                            || (subclass == LinkedHashMap.class)\n                            || (subclass == EnumMap.class)\n                            || (subclass == TreeMap.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                        break;\n                    }\n                } else if (baseType.isCollectionLikeType()) {\n                    if ((subclass == ArrayList.class)\n                            || (subclass == LinkedList.class)\n                            || (subclass == HashSet.class)\n                            || (subclass == TreeSet.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getContentType()));\n                        break;\n                    }\n                    \n                    \n                    if (rawBase == EnumSet.class) {\n                        return baseType;\n                    }\n                }\n            }\n            \n            int typeParamCount = subclass.getTypeParameters().length;\n            if (typeParamCount == 0) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            \n            \n\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n            if (baseType.isInterface()) {\n                newType = baseType.refine(subclass, tb, null, new JavaType[] { baseType });\n            } else {\n                newType = baseType.refine(subclass, tb, baseType, NO_TYPES);\n            }\n            \n            if (newType == null) {\n                newType = _fromClass(null, subclass, tb);\n            }\n        } while (false);\n\n        \n        \n        return newType;\n\n        \n        \n        \n    }\n\n    private TypeBindings _bindingsForSubtype(JavaType baseType, int typeParamCount, Class<?> subclass) {\n        \n        \n        int baseCount = baseType.containedTypeCount();\n        if (baseCount == typeParamCount) {\n            if (typeParamCount == 1) {\n                return TypeBindings.create(subclass, baseType.containedType(0));\n            }\n            if (typeParamCount == 2) {\n                return TypeBindings.create(subclass, baseType.containedType(0),\n                        baseType.containedType(1));\n            }\n            List<JavaType> types = new ArrayList<JavaType>(baseCount);\n            for (int i = 0; i < baseCount; ++i) {\n                types.add(baseType.containedType(i));\n            }\n            return TypeBindings.create(subclass, types);\n        }\n        \n        return TypeBindings.emptyBindings();\n    }\n\n    \n    public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass) {\n        \n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == superClass) {\n            return baseType;\n        }\n        JavaType superType = baseType.findSuperType(superClass);\n        if (superType == null) {\n            \n            if (!superClass.isAssignableFrom(rawBase)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not a super-type of %s\", superClass.getName(), baseType));\n            }\n            \n            throw new IllegalArgumentException(String.format(\n                    \"Internal error: class %s not included as super-type for %s\",\n                    superClass.getName(), baseType));\n        }\n        return superType;\n    }\n\n    \n    public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException {\n        return _parser.parse(canonical);\n    }\n\n    \n    public JavaType[] findTypeParameters(JavaType type, Class<?> expType) {\n        JavaType match = type.findSuperType(expType);\n        if (match == null) {\n            return NO_TYPES;\n        }\n        return match.getBindings().typeParameterArray();\n    }\n\n    \n    @Deprecated \n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) {\n        return findTypeParameters(constructType(clz, bindings), expType);\n    }\n    \n    \n    @Deprecated \n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) {\n        return findTypeParameters(constructType(clz), expType);\n    }\n\n    \n    public JavaType moreSpecificType(JavaType type1, JavaType type2) {\n        if (type1 == null) {\n            return type2;\n        }\n        if (type2 == null) {\n            return type1;\n        }\n        Class<?> raw1 = type1.getRawClass();\n        Class<?> raw2 = type2.getRawClass();\n        if (raw1 == raw2) {\n            return type1;\n        }\n        \n        if (raw1.isAssignableFrom(raw2)) {\n            return type2;\n        }\n        return type1;\n    }\n    \n    \n\n    public JavaType constructType(Type type) {\n        return _fromAny(null, type, EMPTY_BINDINGS);\n    }\n\n    public JavaType constructType(Type type, TypeBindings bindings) {\n        return _fromAny(null, type, bindings);\n    }\n    \n    public JavaType constructType(TypeReference<?> typeRef) {\n        \n        return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS);\n\n        \n        \n\n        \n    }\n\n    \n    @Deprecated\n    public JavaType constructType(Type type, Class<?> contextClass) {\n        TypeBindings bindings = (contextClass == null)\n                ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings();\n        return _fromAny(null, type, bindings);\n    }\n\n    \n    @Deprecated\n    public JavaType constructType(Type type, JavaType contextType) {\n        TypeBindings bindings = (contextType == null)\n                ? TypeBindings.emptyBindings() : contextType.getBindings();\n        return _fromAny(null, type, bindings);\n    }\n\n    \n\n    \n    public ArrayType constructArrayType(Class<?> elementType) {\n        return ArrayType.construct(_fromAny(null, elementType, null), null);\n    }\n    \n    \n    public ArrayType constructArrayType(JavaType elementType) {\n        return ArrayType.construct(elementType, null);\n    }\n\n    \n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) {\n        return constructCollectionType(collectionClass,\n                _fromClass(null, elementClass, EMPTY_BINDINGS));\n    }\n\n    \n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) {\n        \n        \n        return (CollectionType) _fromClass(null, collectionClass,\n                TypeBindings.create(collectionClass, elementType));\n    }\n\n    \n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) {\n        return constructCollectionLikeType(collectionClass,\n                _fromClass(null, elementClass, EMPTY_BINDINGS));\n    }\n    \n    \n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) {\n        JavaType type = _fromClass(null, collectionClass,\n                TypeBindings.createIfNeeded(collectionClass, elementType));\n        if (type instanceof CollectionLikeType) {\n            return (CollectionLikeType) type;\n        }\n        return CollectionLikeType.upgradeFrom(type, elementType);\n    }\n\n    \n    public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        JavaType kt, vt;\n        if (mapClass == Properties.class) {\n            kt = vt = CORE_TYPE_STRING;\n        } else {\n            kt = _fromClass(null, keyClass, EMPTY_BINDINGS);\n            vt = _fromClass(null, valueClass, EMPTY_BINDINGS);\n        }\n        return constructMapType(mapClass, kt, vt);\n    }\n\n    \n    public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) {\n        return (MapType) _fromClass(null, mapClass,\n                TypeBindings.create(mapClass, new JavaType[] {\n                        keyType, valueType\n                }));\n    }\n\n    \n    public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        return constructMapLikeType(mapClass,\n                _fromClass(null, keyClass, EMPTY_BINDINGS),\n                _fromClass(null, valueClass, EMPTY_BINDINGS));\n    }\n\n    \n    public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) {\n        \n        \n        JavaType type = _fromClass(null, mapClass,\n                TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType }));\n        if (type instanceof MapLikeType) {\n            return (MapLikeType) type;\n        }\n        return MapLikeType.upgradeFrom(type, keyType, valueType);\n    }\n\n    \n    public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) {\n        return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));\n    }\n\n    \n    @Deprecated\n    public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes) {\n        return constructSimpleType(rawType, parameterTypes);\n    } \n\n    \n    public JavaType constructReferenceType(Class<?> rawType, JavaType referredType) {\n        return ReferenceType.construct(rawType, null, \n                null, null, \n                referredType);\n    }\n\n    \n    @Deprecated \n    public JavaType uncheckedSimpleType(Class<?> cls) {\n        \n        return _constructSimple(cls, EMPTY_BINDINGS, null, null);\n    }\n\n    \n    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n        int len = parameterClasses.length;\n        JavaType[] pt = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            pt[i] = _fromClass(null, parameterClasses[i], null);\n        }\n        return constructParametricType(parametrized, pt);\n    }\n\n    \n    public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes) {\n        return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));\n    }\n\n    \n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes) {\n        return constructParametricType(parametrized, parameterTypes);\n    }\n\n    \n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses) {\n        return constructParametricType(parametrized, parameterClasses);\n    }\n\n    \n\n    \n    public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {\n        return constructCollectionType(collectionClass, unknownType());\n    }\n\n    \n    public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {\n        return constructCollectionLikeType(collectionClass, unknownType());\n    }\n\n    \n    public MapType constructRawMapType(Class<? extends Map> mapClass) {\n        return constructMapType(mapClass, unknownType(), unknownType());\n    }\n\n    \n    public MapLikeType constructRawMapLikeType(Class<?> mapClass) {\n        return constructMapLikeType(mapClass, unknownType(), unknownType());\n    }\n\n    \n\n    private JavaType _mapType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        JavaType kt, vt;\n\n        \n        if (rawClass == Properties.class) {\n            kt = vt = CORE_TYPE_STRING;\n        } else {\n            List<JavaType> typeParams = bindings.getTypeParameters();\n            \n            switch (typeParams.size()) {\n            case 0: \n                kt = vt = _unknownType();\n                break;\n            case 2:\n                kt = typeParams.get(0);\n                vt = typeParams.get(1);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n            }\n        }\n        return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt);\n    }\n\n    private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        List<JavaType> typeParams = bindings.getTypeParameters();\n        \n        JavaType ct;\n        if (typeParams.isEmpty()) {\n            ct = _unknownType();\n        } else if (typeParams.size() == 1) {\n            ct = typeParams.get(0);\n        } else {\n            throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct);\n    }\n\n    private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        List<JavaType> typeParams = bindings.getTypeParameters();\n        \n        JavaType ct;\n        if (typeParams.isEmpty()) {\n            ct = _unknownType();\n        } else if (typeParams.size() == 1) {\n            ct = typeParams.get(0);\n        } else {\n            throw new IllegalArgumentException(\"Strange Reference type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct);\n    }\n\n    \n    protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        if (bindings.isEmpty()) {\n            JavaType result = _findWellKnownSimple(raw);\n            if (result != null) {\n                return result;\n            }\n        }\n        return _newSimpleType(raw, bindings, superClass, superInterfaces);\n    }\n\n    \n    protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        return new SimpleType(raw, bindings, superClass, superInterfaces);\n    }\n\n    protected JavaType _unknownType() {\n        \n        return CORE_TYPE_OBJECT;\n    }\n\n    \n    protected JavaType _findWellKnownSimple(Class<?> clz) {\n        if (clz.isPrimitive()) {\n            if (clz == CLS_BOOL) return CORE_TYPE_BOOL;\n            if (clz == CLS_INT) return CORE_TYPE_INT;\n            if (clz == CLS_LONG) return CORE_TYPE_LONG;\n        } else {\n            if (clz == CLS_STRING) return CORE_TYPE_STRING;\n            if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; \n        }\n        return null;\n    }\n\n    \n\n    \n    protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings) {\n        JavaType resultType;\n\n        \n        if (type instanceof Class<?>) {\n            \n            resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS);\n        }\n        \n        else if (type instanceof ParameterizedType) {\n            resultType = _fromParamType(context, (ParameterizedType) type, bindings);\n        }\n        else if (type instanceof JavaType) { \n            \n            return (JavaType) type;\n        }\n        else if (type instanceof GenericArrayType) {\n            resultType = _fromArrayType(context, (GenericArrayType) type, bindings);\n        }\n        else if (type instanceof TypeVariable<?>) {\n            resultType = _fromVariable(context, (TypeVariable<?>) type, bindings);\n        }\n        else if (type instanceof WildcardType) {\n            resultType = _fromWildcard(context, (WildcardType) type, bindings);\n        } else {\n            \n            throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString()));\n        }\n        \n        if (_modifiers != null) {\n            TypeBindings b = resultType.getBindings();\n            if (b == null) {\n                b = EMPTY_BINDINGS;\n            }\n            for (TypeModifier mod : _modifiers) {\n                JavaType t = mod.modifyType(resultType, type, b, this);\n                if (t == null) {\n                    throw new IllegalStateException(String.format(\n                            \"TypeModifier %s (of type %s) return null for type %s\",\n                            mod, mod.getClass().getName(), resultType));\n                }\n                resultType = t;\n            }\n        }\n        return resultType;\n    }\n\n    \n    protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings) {\n        \n        JavaType result = _findWellKnownSimple(rawType);\n        if (result != null) {\n            return result;\n        }\n        \n        final Object key;\n        if ((bindings == null) || bindings.isEmpty()) {\n            key = rawType;\n        } else {\n            key = bindings.asKey(rawType);\n        }\n        result = _typeCache.get(key); \n        if (result != null) {\n            return result;\n        }\n\n        \n        if (context == null) {\n            context = new ClassStack(rawType);\n        } else {\n            ClassStack prev = context.find(rawType);\n            if (prev != null) {\n                \n                ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS);\n                prev.addSelfReference(selfRef);\n                return selfRef;\n            }\n            \n            context = context.child(rawType);\n        }\n\n        \n        if (rawType.isArray()) {\n            result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings),\n                    bindings);\n        } else {\n            \n            \n            JavaType superClass;\n            JavaType[] superInterfaces;\n\n            if (rawType.isInterface()) {\n                superClass = null;\n                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n            } else {\n                \n                superClass = _resolveSuperClass(context, rawType, bindings);\n                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n            }\n\n            \n            if (rawType == Properties.class) {\n                result = MapType.construct(rawType, bindings, superClass, superInterfaces,\n                        CORE_TYPE_STRING, CORE_TYPE_STRING);\n            }\n            \n            \n            else if (superClass != null) {\n                result = superClass.refine(rawType, bindings, superClass, superInterfaces);\n            }\n            \n            if (result == null) {\n                result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); \n                if (result == null) {\n                    result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces);\n                    if (result == null) {\n                        \n                        result = _newSimpleType(rawType, bindings, superClass, superInterfaces);\n                    }\n                }\n            }\n        }\n        context.resolveSelfReferences(result);\n        \n        \n        if (!result.hasHandlers()) {\n            _typeCache.putIfAbsent(key, result); \n        }\n        return result;\n    }\n\n    protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings) {\n        Type parent = ClassUtil.getGenericSuperclass(rawType);\n        if (parent == null) {\n            return null;\n        }\n        return _fromAny(context, parent, parentBindings);\n    }\n\n    protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings) {\n        Type[] types = ClassUtil.getGenericInterfaces(rawType);\n        if (types == null || types.length == 0) {\n            return NO_TYPES;\n        }\n        int len = types.length;\n        JavaType[] resolved = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            Type type = types[i];\n            resolved[i] = _fromAny(context, type, parentBindings);\n        }\n        return resolved;\n    }\n\n    \n    protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        if (bindings == null) {\n            bindings = TypeBindings.emptyBindings();\n        }\n        \n        \n        if (rawType == Map.class) {\n            return _mapType(rawType, bindings, superClass, superInterfaces);\n        }\n        if (rawType == Collection.class) {\n            return _collectionType(rawType, bindings, superClass, superInterfaces);\n        }\n        \n        if (rawType == AtomicReference.class) {\n            return _referenceType(rawType, bindings, superClass, superInterfaces);\n        }\n        \n        \n        \n        \n        return null;\n    }\n\n    protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        \n        \n        final int intCount = superInterfaces.length;\n\n        for (int i = 0; i < intCount; ++i) {\n            JavaType result = superInterfaces[i].refine(rawType, bindings, superClass, superInterfaces);\n            if (result != null) {\n                return result;\n            }\n        }\n        return null;\n    }\n\n    \n    protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype, TypeBindings parentBindings) {\n        \n        Class<?> rawType = (Class<?>) ptype.getRawType();\n\n        \n        \n        if (rawType == CLS_ENUM) {\n            return CORE_TYPE_ENUM;\n        }\n        if (rawType == CLS_COMPARABLE) {\n            return CORE_TYPE_COMPARABLE;\n        }\n        if (rawType == CLS_CLASS) {\n            return CORE_TYPE_CLASS;\n        }\n\n        \n        \n        \n        Type[] args = ptype.getActualTypeArguments();\n        int paramCount = (args == null) ? 0 : args.length;\n        JavaType[] pt;\n        TypeBindings newBindings;        \n\n        if (paramCount == 0) {\n            newBindings = EMPTY_BINDINGS;\n        } else {\n            pt = new JavaType[paramCount];\n            for (int i = 0; i < paramCount; ++i) {\n                pt[i] = _fromAny(context, args[i], parentBindings);\n            }\n            newBindings = TypeBindings.create(rawType, pt);\n        }\n        return _fromClass(context, rawType, newBindings);\n    }\n\n    protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings) {\n        JavaType elementType = _fromAny(context, type.getGenericComponentType(), bindings);\n        return ArrayType.construct(elementType, bindings);\n    }\n\n    protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings) {\n        \n        final String name = var.getName();\n        JavaType type = bindings.findBoundType(name);\n        if (type != null) {\n            return type;\n        }\n        \n        \n        if (bindings.hasUnbound(name)) {\n            return CORE_TYPE_OBJECT;\n        }\n        bindings = bindings.withUnboundVariable(name);\n\n        Type[] bounds = var.getBounds();\n        return _fromAny(context, bounds[0], bindings);\n    }\n\n    protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings) {\n        \n        return _fromAny(context, type.getUpperBounds()[0], bindings);\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.type;\n\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.lang.reflect.*;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.LRUMap;\n\n\n@SuppressWarnings({\"rawtypes\" })\npublic final class TypeFactory implements java.io.Serializable { private static final long serialVersionUID = 1L; private final static JavaType[] NO_TYPES = new JavaType[0]; protected final static TypeFactory instance = new TypeFactory(); protected final static TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings(); private final static Class<?> CLS_STRING = String.class; private final static Class<?> CLS_OBJECT = Object.class; private final static Class<?> CLS_COMPARABLE = Comparable.class; private final static Class<?> CLS_CLASS = Class.class; private final static Class<?> CLS_ENUM = Enum.class; private final static Class<?> CLS_BOOL = Boolean.TYPE; private final static Class<?> CLS_INT = Integer.TYPE; private final static Class<?> CLS_LONG = Long.TYPE; protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(CLS_BOOL); protected final static SimpleType CORE_TYPE_INT = new SimpleType(CLS_INT); protected final static SimpleType CORE_TYPE_LONG = new SimpleType(CLS_LONG); protected final static SimpleType CORE_TYPE_STRING = new SimpleType(CLS_STRING); protected final static SimpleType CORE_TYPE_OBJECT = new SimpleType(CLS_OBJECT); protected final static SimpleType CORE_TYPE_COMPARABLE = new SimpleType(CLS_COMPARABLE); protected final static SimpleType CORE_TYPE_ENUM = new SimpleType(CLS_ENUM); protected final static SimpleType CORE_TYPE_CLASS = new SimpleType(CLS_CLASS); protected final LRUMap<Object,JavaType> _typeCache; protected final TypeModifier[] _modifiers; protected final TypeParser _parser; protected final ClassLoader _classLoader; private TypeFactory() {\n        this(null);\n    }\n\n    \n    protected TypeFactory(LRUMap<Object,JavaType> typeCache) {\n        if (typeCache == null) {\n            typeCache = new LRUMap<Object,JavaType>(16, 200);\n        }\n        _typeCache = typeCache;\n        _parser = new TypeParser(this);\n        _modifiers = null;\n        _classLoader = null;\n    }\n\n    protected TypeFactory(LRUMap<Object,JavaType> typeCache, TypeParser p, TypeModifier[] mods, ClassLoader classLoader) {\n        if (typeCache == null) {\n            typeCache = new LRUMap<Object,JavaType>(16, 200);\n        }\n        _typeCache = typeCache;\n        \n        _parser = p.withFactory(this);\n        _modifiers = mods;\n        _classLoader = classLoader;\n    }\n\n    public TypeFactory withModifier(TypeModifier mod) {\n        LRUMap<Object,JavaType> typeCache = _typeCache;\n        TypeModifier[] mods;\n        if (mod == null) { \n            mods = null;\n            \n            \n            typeCache = null;\n        } else if (_modifiers == null) {\n            mods = new TypeModifier[] { mod };\n        } else {\n            mods = ArrayBuilders.insertInListNoDup(_modifiers, mod);\n        }\n        return new TypeFactory(typeCache, _parser, mods, _classLoader);\n    }\n\n    public TypeFactory withClassLoader(ClassLoader classLoader) {\n        return new TypeFactory(_typeCache, _parser, _modifiers, classLoader);\n    }\n\n    \n    public TypeFactory withCache(LRUMap<Object,JavaType> cache) {\n        return new TypeFactory(cache, _parser, _modifiers, _classLoader);\n    }\n\n    \n    public static TypeFactory defaultInstance() { return instance; }\n\n    \n    public void clearCache() {\n        _typeCache.clear();\n    }\n\n    public ClassLoader getClassLoader() {\n        return _classLoader;\n    }\n    \n    \n    \n    \n    public static JavaType unknownType() {\n        return defaultInstance()._unknownType();\n    }\n\n    \n    public static Class<?> rawClass(Type t) {\n        if (t instanceof Class<?>) {\n            return (Class<?>) t;\n        }\n        \n        return defaultInstance().constructType(t).getRawClass();\n    }\n\n    \n\n    \n    public Class<?> findClass(String className) throws ClassNotFoundException {\n        if (className.indexOf('.') < 0) {\n            Class<?> prim = _findPrimitive(className);\n            if (prim != null) {\n                return prim;\n            }\n        }\n        \n        Throwable prob = null;\n        ClassLoader loader = this.getClassLoader();\n        if (loader == null) {\n            loader = \tThread.currentThread().getContextClassLoader();\n        }\n        if (loader != null) {\n            try {\n                return classForName(className, true, loader);\n            } catch (Exception e) {\n                prob = ClassUtil.getRootCause(e);\n            }\n        }\n        try {\n            return classForName(className);\n        } catch (Exception e) {\n            if (prob == null) {\n                prob = ClassUtil.getRootCause(e);\n            }\n        }\n        if (prob instanceof RuntimeException) {\n            throw (RuntimeException) prob;\n        }\n        throw new ClassNotFoundException(prob.getMessage(), prob);\n    }\n    \n    protected Class<?> classForName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException {\n    \treturn Class.forName(name, true, loader);\n    }\n    \n    protected Class<?> classForName(String name) throws ClassNotFoundException {\n        return Class.forName(name);\n    }\n\n    protected Class<?> _findPrimitive(String className) {\n        if (\"int\".equals(className)) return Integer.TYPE;\n        if (\"long\".equals(className)) return Long.TYPE;\n        if (\"float\".equals(className)) return Float.TYPE;\n        if (\"double\".equals(className)) return Double.TYPE;\n        if (\"boolean\".equals(className)) return Boolean.TYPE;\n        if (\"byte\".equals(className)) return Byte.TYPE;\n        if (\"char\".equals(className)) return Character.TYPE;\n        if (\"short\".equals(className)) return Short.TYPE;\n        if (\"void\".equals(className)) return Void.TYPE;\n        return null;\n    }\n    \n    \n\n    \n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n        \n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == subclass) {\n            return baseType;\n        }\n\n        JavaType newType;\n\n        \n        do { \n            if (rawBase == Object.class) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                break;\n            }\n            if (!rawBase.isAssignableFrom(subclass)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not subtype of %s\", subclass.getName(), baseType));\n            }\n            \n\n            \n            if (baseType.getBindings().isEmpty()) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            \n            if (baseType.isContainerType()) {\n                if (baseType.isMapLikeType()) {\n                    if ((subclass == HashMap.class)\n                            || (subclass == LinkedHashMap.class)\n                            || (subclass == EnumMap.class)\n                            || (subclass == TreeMap.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                        break;\n                    }\n                } else if (baseType.isCollectionLikeType()) {\n                    if ((subclass == ArrayList.class)\n                            || (subclass == LinkedList.class)\n                            || (subclass == HashSet.class)\n                            || (subclass == TreeSet.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getContentType()));\n                        break;\n                    }\n                    \n                    \n                    if (rawBase == EnumSet.class) {\n                        return baseType;\n                    }\n                }\n            }\n            \n            int typeParamCount = subclass.getTypeParameters().length;\n            if (typeParamCount == 0) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            \n            \n\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n            if (baseType.isInterface()) {\n                newType = baseType.refine(subclass, tb, null, new JavaType[] { baseType });\n            } else {\n                newType = baseType.refine(subclass, tb, baseType, NO_TYPES);\n            }\n            \n            if (newType == null) {\n                newType = _fromClass(null, subclass, tb);\n            }\n        } while (false);\n\n        \n        \n        newType = newType.withHandlersFrom(baseType);\n        return newType;\n\n        \n        \n        \n    }\n\n    private TypeBindings _bindingsForSubtype(JavaType baseType, int typeParamCount, Class<?> subclass) {\n        \n        \n        int baseCount = baseType.containedTypeCount();\n        if (baseCount == typeParamCount) {\n            if (typeParamCount == 1) {\n                return TypeBindings.create(subclass, baseType.containedType(0));\n            }\n            if (typeParamCount == 2) {\n                return TypeBindings.create(subclass, baseType.containedType(0),\n                        baseType.containedType(1));\n            }\n            List<JavaType> types = new ArrayList<JavaType>(baseCount);\n            for (int i = 0; i < baseCount; ++i) {\n                types.add(baseType.containedType(i));\n            }\n            return TypeBindings.create(subclass, types);\n        }\n        \n        return TypeBindings.emptyBindings();\n    }\n\n    \n    public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass) {\n        \n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == superClass) {\n            return baseType;\n        }\n        JavaType superType = baseType.findSuperType(superClass);\n        if (superType == null) {\n            \n            if (!superClass.isAssignableFrom(rawBase)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not a super-type of %s\", superClass.getName(), baseType));\n            }\n            \n            throw new IllegalArgumentException(String.format(\n                    \"Internal error: class %s not included as super-type for %s\",\n                    superClass.getName(), baseType));\n        }\n        return superType;\n    }\n\n    \n    public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException {\n        return _parser.parse(canonical);\n    }\n\n    \n    public JavaType[] findTypeParameters(JavaType type, Class<?> expType) {\n        JavaType match = type.findSuperType(expType);\n        if (match == null) {\n            return NO_TYPES;\n        }\n        return match.getBindings().typeParameterArray();\n    }\n\n    \n    @Deprecated \n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) {\n        return findTypeParameters(constructType(clz, bindings), expType);\n    }\n    \n    \n    @Deprecated \n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) {\n        return findTypeParameters(constructType(clz), expType);\n    }\n\n    \n    public JavaType moreSpecificType(JavaType type1, JavaType type2) {\n        if (type1 == null) {\n            return type2;\n        }\n        if (type2 == null) {\n            return type1;\n        }\n        Class<?> raw1 = type1.getRawClass();\n        Class<?> raw2 = type2.getRawClass();\n        if (raw1 == raw2) {\n            return type1;\n        }\n        \n        if (raw1.isAssignableFrom(raw2)) {\n            return type2;\n        }\n        return type1;\n    }\n    \n    \n\n    public JavaType constructType(Type type) {\n        return _fromAny(null, type, EMPTY_BINDINGS);\n    }\n\n    public JavaType constructType(Type type, TypeBindings bindings) {\n        return _fromAny(null, type, bindings);\n    }\n    \n    public JavaType constructType(TypeReference<?> typeRef) {\n        \n        return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS);\n\n        \n        \n\n        \n    }\n\n    \n    @Deprecated\n    public JavaType constructType(Type type, Class<?> contextClass) {\n        TypeBindings bindings = (contextClass == null)\n                ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings();\n        return _fromAny(null, type, bindings);\n    }\n\n    \n    @Deprecated\n    public JavaType constructType(Type type, JavaType contextType) {\n        TypeBindings bindings = (contextType == null)\n                ? TypeBindings.emptyBindings() : contextType.getBindings();\n        return _fromAny(null, type, bindings);\n    }\n\n    \n\n    \n    public ArrayType constructArrayType(Class<?> elementType) {\n        return ArrayType.construct(_fromAny(null, elementType, null), null);\n    }\n    \n    \n    public ArrayType constructArrayType(JavaType elementType) {\n        return ArrayType.construct(elementType, null);\n    }\n\n    \n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) {\n        return constructCollectionType(collectionClass,\n                _fromClass(null, elementClass, EMPTY_BINDINGS));\n    }\n\n    \n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) {\n        \n        \n        return (CollectionType) _fromClass(null, collectionClass,\n                TypeBindings.create(collectionClass, elementType));\n    }\n\n    \n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) {\n        return constructCollectionLikeType(collectionClass,\n                _fromClass(null, elementClass, EMPTY_BINDINGS));\n    }\n    \n    \n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) {\n        JavaType type = _fromClass(null, collectionClass,\n                TypeBindings.createIfNeeded(collectionClass, elementType));\n        if (type instanceof CollectionLikeType) {\n            return (CollectionLikeType) type;\n        }\n        return CollectionLikeType.upgradeFrom(type, elementType);\n    }\n\n    \n    public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        JavaType kt, vt;\n        if (mapClass == Properties.class) {\n            kt = vt = CORE_TYPE_STRING;\n        } else {\n            kt = _fromClass(null, keyClass, EMPTY_BINDINGS);\n            vt = _fromClass(null, valueClass, EMPTY_BINDINGS);\n        }\n        return constructMapType(mapClass, kt, vt);\n    }\n\n    \n    public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) {\n        return (MapType) _fromClass(null, mapClass,\n                TypeBindings.create(mapClass, new JavaType[] {\n                        keyType, valueType\n                }));\n    }\n\n    \n    public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        return constructMapLikeType(mapClass,\n                _fromClass(null, keyClass, EMPTY_BINDINGS),\n                _fromClass(null, valueClass, EMPTY_BINDINGS));\n    }\n\n    \n    public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) {\n        \n        \n        JavaType type = _fromClass(null, mapClass,\n                TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType }));\n        if (type instanceof MapLikeType) {\n            return (MapLikeType) type;\n        }\n        return MapLikeType.upgradeFrom(type, keyType, valueType);\n    }\n\n    \n    public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) {\n        return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));\n    }\n\n    \n    @Deprecated\n    public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes) {\n        return constructSimpleType(rawType, parameterTypes);\n    } \n\n    \n    public JavaType constructReferenceType(Class<?> rawType, JavaType referredType) {\n        return ReferenceType.construct(rawType, null, \n                null, null, \n                referredType);\n    }\n\n    \n    @Deprecated \n    public JavaType uncheckedSimpleType(Class<?> cls) {\n        \n        return _constructSimple(cls, EMPTY_BINDINGS, null, null);\n    }\n\n    \n    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n        int len = parameterClasses.length;\n        JavaType[] pt = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            pt[i] = _fromClass(null, parameterClasses[i], null);\n        }\n        return constructParametricType(parametrized, pt);\n    }\n\n    \n    public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes) {\n        return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));\n    }\n\n    \n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes) {\n        return constructParametricType(parametrized, parameterTypes);\n    }\n\n    \n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses) {\n        return constructParametricType(parametrized, parameterClasses);\n    }\n\n    \n\n    \n    public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {\n        return constructCollectionType(collectionClass, unknownType());\n    }\n\n    \n    public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {\n        return constructCollectionLikeType(collectionClass, unknownType());\n    }\n\n    \n    public MapType constructRawMapType(Class<? extends Map> mapClass) {\n        return constructMapType(mapClass, unknownType(), unknownType());\n    }\n\n    \n    public MapLikeType constructRawMapLikeType(Class<?> mapClass) {\n        return constructMapLikeType(mapClass, unknownType(), unknownType());\n    }\n\n    \n\n    private JavaType _mapType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        JavaType kt, vt;\n\n        \n        if (rawClass == Properties.class) {\n            kt = vt = CORE_TYPE_STRING;\n        } else {\n            List<JavaType> typeParams = bindings.getTypeParameters();\n            \n            switch (typeParams.size()) {\n            case 0: \n                kt = vt = _unknownType();\n                break;\n            case 2:\n                kt = typeParams.get(0);\n                vt = typeParams.get(1);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n            }\n        }\n        return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt);\n    }\n\n    private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        List<JavaType> typeParams = bindings.getTypeParameters();\n        \n        JavaType ct;\n        if (typeParams.isEmpty()) {\n            ct = _unknownType();\n        } else if (typeParams.size() == 1) {\n            ct = typeParams.get(0);\n        } else {\n            throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct);\n    }\n\n    private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        List<JavaType> typeParams = bindings.getTypeParameters();\n        \n        JavaType ct;\n        if (typeParams.isEmpty()) {\n            ct = _unknownType();\n        } else if (typeParams.size() == 1) {\n            ct = typeParams.get(0);\n        } else {\n            throw new IllegalArgumentException(\"Strange Reference type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct);\n    }\n\n    \n    protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        if (bindings.isEmpty()) {\n            JavaType result = _findWellKnownSimple(raw);\n            if (result != null) {\n                return result;\n            }\n        }\n        return _newSimpleType(raw, bindings, superClass, superInterfaces);\n    }\n\n    \n    protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        return new SimpleType(raw, bindings, superClass, superInterfaces);\n    }\n\n    protected JavaType _unknownType() {\n        \n        return CORE_TYPE_OBJECT;\n    }\n\n    \n    protected JavaType _findWellKnownSimple(Class<?> clz) {\n        if (clz.isPrimitive()) {\n            if (clz == CLS_BOOL) return CORE_TYPE_BOOL;\n            if (clz == CLS_INT) return CORE_TYPE_INT;\n            if (clz == CLS_LONG) return CORE_TYPE_LONG;\n        } else {\n            if (clz == CLS_STRING) return CORE_TYPE_STRING;\n            if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; \n        }\n        return null;\n    }\n\n    \n\n    \n    protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings) {\n        JavaType resultType;\n\n        \n        if (type instanceof Class<?>) {\n            \n            resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS);\n        }\n        \n        else if (type instanceof ParameterizedType) {\n            resultType = _fromParamType(context, (ParameterizedType) type, bindings);\n        }\n        else if (type instanceof JavaType) { \n            \n            return (JavaType) type;\n        }\n        else if (type instanceof GenericArrayType) {\n            resultType = _fromArrayType(context, (GenericArrayType) type, bindings);\n        }\n        else if (type instanceof TypeVariable<?>) {\n            resultType = _fromVariable(context, (TypeVariable<?>) type, bindings);\n        }\n        else if (type instanceof WildcardType) {\n            resultType = _fromWildcard(context, (WildcardType) type, bindings);\n        } else {\n            \n            throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString()));\n        }\n        \n        if (_modifiers != null) {\n            TypeBindings b = resultType.getBindings();\n            if (b == null) {\n                b = EMPTY_BINDINGS;\n            }\n            for (TypeModifier mod : _modifiers) {\n                JavaType t = mod.modifyType(resultType, type, b, this);\n                if (t == null) {\n                    throw new IllegalStateException(String.format(\n                            \"TypeModifier %s (of type %s) return null for type %s\",\n                            mod, mod.getClass().getName(), resultType));\n                }\n                resultType = t;\n            }\n        }\n        return resultType;\n    }\n\n    \n    protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings) {\n        \n        JavaType result = _findWellKnownSimple(rawType);\n        if (result != null) {\n            return result;\n        }\n        \n        final Object key;\n        if ((bindings == null) || bindings.isEmpty()) {\n            key = rawType;\n        } else {\n            key = bindings.asKey(rawType);\n        }\n        result = _typeCache.get(key); \n        if (result != null) {\n            return result;\n        }\n\n        \n        if (context == null) {\n            context = new ClassStack(rawType);\n        } else {\n            ClassStack prev = context.find(rawType);\n            if (prev != null) {\n                \n                ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS);\n                prev.addSelfReference(selfRef);\n                return selfRef;\n            }\n            \n            context = context.child(rawType);\n        }\n\n        \n        if (rawType.isArray()) {\n            result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings),\n                    bindings);\n        } else {\n            \n            \n            JavaType superClass;\n            JavaType[] superInterfaces;\n\n            if (rawType.isInterface()) {\n                superClass = null;\n                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n            } else {\n                \n                superClass = _resolveSuperClass(context, rawType, bindings);\n                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n            }\n\n            \n            if (rawType == Properties.class) {\n                result = MapType.construct(rawType, bindings, superClass, superInterfaces,\n                        CORE_TYPE_STRING, CORE_TYPE_STRING);\n            }\n            \n            \n            else if (superClass != null) {\n                result = superClass.refine(rawType, bindings, superClass, superInterfaces);\n            }\n            \n            if (result == null) {\n                result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); \n                if (result == null) {\n                    result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces);\n                    if (result == null) {\n                        \n                        result = _newSimpleType(rawType, bindings, superClass, superInterfaces);\n                    }\n                }\n            }\n        }\n        context.resolveSelfReferences(result);\n        \n        \n        if (!result.hasHandlers()) {\n            _typeCache.putIfAbsent(key, result); \n        }\n        return result;\n    }\n\n    protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings) {\n        Type parent = ClassUtil.getGenericSuperclass(rawType);\n        if (parent == null) {\n            return null;\n        }\n        return _fromAny(context, parent, parentBindings);\n    }\n\n    protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings) {\n        Type[] types = ClassUtil.getGenericInterfaces(rawType);\n        if (types == null || types.length == 0) {\n            return NO_TYPES;\n        }\n        int len = types.length;\n        JavaType[] resolved = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            Type type = types[i];\n            resolved[i] = _fromAny(context, type, parentBindings);\n        }\n        return resolved;\n    }\n\n    \n    protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        if (bindings == null) {\n            bindings = TypeBindings.emptyBindings();\n        }\n        \n        \n        if (rawType == Map.class) {\n            return _mapType(rawType, bindings, superClass, superInterfaces);\n        }\n        if (rawType == Collection.class) {\n            return _collectionType(rawType, bindings, superClass, superInterfaces);\n        }\n        \n        if (rawType == AtomicReference.class) {\n            return _referenceType(rawType, bindings, superClass, superInterfaces);\n        }\n        \n        \n        \n        \n        return null;\n    }\n\n    protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        \n        \n        final int intCount = superInterfaces.length;\n\n        for (int i = 0; i < intCount; ++i) {\n            JavaType result = superInterfaces[i].refine(rawType, bindings, superClass, superInterfaces);\n            if (result != null) {\n                return result;\n            }\n        }\n        return null;\n    }\n\n    \n    protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype, TypeBindings parentBindings) {\n        \n        Class<?> rawType = (Class<?>) ptype.getRawType();\n\n        \n        \n        if (rawType == CLS_ENUM) {\n            return CORE_TYPE_ENUM;\n        }\n        if (rawType == CLS_COMPARABLE) {\n            return CORE_TYPE_COMPARABLE;\n        }\n        if (rawType == CLS_CLASS) {\n            return CORE_TYPE_CLASS;\n        }\n\n        \n        \n        \n        Type[] args = ptype.getActualTypeArguments();\n        int paramCount = (args == null) ? 0 : args.length;\n        JavaType[] pt;\n        TypeBindings newBindings;        \n\n        if (paramCount == 0) {\n            newBindings = EMPTY_BINDINGS;\n        } else {\n            pt = new JavaType[paramCount];\n            for (int i = 0; i < paramCount; ++i) {\n                pt[i] = _fromAny(context, args[i], parentBindings);\n            }\n            newBindings = TypeBindings.create(rawType, pt);\n        }\n        return _fromClass(context, rawType, newBindings);\n    }\n\n    protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings) {\n        JavaType elementType = _fromAny(context, type.getGenericComponentType(), bindings);\n        return ArrayType.construct(elementType, bindings);\n    }\n\n    protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings) {\n        \n        final String name = var.getName();\n        JavaType type = bindings.findBoundType(name);\n        if (type != null) {\n            return type;\n        }\n        \n        \n        if (bindings.hasUnbound(name)) {\n            return CORE_TYPE_OBJECT;\n        }\n        bindings = bindings.withUnboundVariable(name);\n\n        Type[] bounds = var.getBounds();\n        return _fromAny(context, bounds[0], bindings);\n    }\n\n    protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings) {\n        \n        return _fromAny(context, type.getUpperBounds()[0], bindings);\n    }\n}\n",
      "buggy_signatures": [
        "protected TypeFactory(LRUMap<Object,JavaType> typeCache)",
        "protected TypeFactory(LRUMap<Object,JavaType> typeCache, TypeParser p, TypeModifier[] mods, ClassLoader classLoader)",
        "public TypeFactory withModifier(TypeModifier mod)",
        "public TypeFactory withClassLoader(ClassLoader classLoader)",
        "public TypeFactory withCache(LRUMap<Object,JavaType> cache)",
        "public static TypeFactory defaultInstance()",
        "public void clearCache()",
        "public ClassLoader getClassLoader()",
        "public static JavaType unknownType()",
        "public static Class<?> rawClass(Type t)",
        "public Class<?> findClass(String className) throws ClassNotFoundException",
        "protected Class<?> classForName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException",
        "protected Class<?> classForName(String name) throws ClassNotFoundException",
        "protected Class<?> _findPrimitive(String className)",
        "public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)",
        "private TypeBindings _bindingsForSubtype(JavaType baseType, int typeParamCount, Class<?> subclass)",
        "public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass)",
        "public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException",
        "public JavaType[] findTypeParameters(JavaType type, Class<?> expType)",
        "public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings)",
        "public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType)",
        "public JavaType moreSpecificType(JavaType type1, JavaType type2)",
        "public JavaType constructType(Type type)",
        "public JavaType constructType(Type type, TypeBindings bindings)",
        "public JavaType constructType(TypeReference<?> typeRef)",
        "public JavaType constructType(Type type, Class<?> contextClass)",
        "public JavaType constructType(Type type, JavaType contextType)",
        "public ArrayType constructArrayType(Class<?> elementType)",
        "public ArrayType constructArrayType(JavaType elementType)",
        "public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass)",
        "public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType)",
        "public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass)",
        "public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType)",
        "public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass)",
        "public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType)",
        "public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass)",
        "public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType)",
        "public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes)",
        "public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes)",
        "public JavaType constructReferenceType(Class<?> rawType, JavaType referredType)",
        "public JavaType uncheckedSimpleType(Class<?> cls)",
        "public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses)",
        "public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes)",
        "public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes)",
        "public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses)",
        "public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass)",
        "public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass)",
        "public MapType constructRawMapType(Class<? extends Map> mapClass)",
        "public MapLikeType constructRawMapLikeType(Class<?> mapClass)",
        "private JavaType _mapType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _unknownType()",
        "protected JavaType _findWellKnownSimple(Class<?> clz)",
        "protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings)",
        "protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings)",
        "protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings)",
        "protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings)",
        "protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype, TypeBindings parentBindings)",
        "protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings)",
        "protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings)",
        "protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings)"
      ],
      "fixed_signatures": [
        "protected TypeFactory(LRUMap<Object,JavaType> typeCache)",
        "protected TypeFactory(LRUMap<Object,JavaType> typeCache, TypeParser p, TypeModifier[] mods, ClassLoader classLoader)",
        "public TypeFactory withModifier(TypeModifier mod)",
        "public TypeFactory withClassLoader(ClassLoader classLoader)",
        "public TypeFactory withCache(LRUMap<Object,JavaType> cache)",
        "public static TypeFactory defaultInstance()",
        "public void clearCache()",
        "public ClassLoader getClassLoader()",
        "public static JavaType unknownType()",
        "public static Class<?> rawClass(Type t)",
        "public Class<?> findClass(String className) throws ClassNotFoundException",
        "protected Class<?> classForName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException",
        "protected Class<?> classForName(String name) throws ClassNotFoundException",
        "protected Class<?> _findPrimitive(String className)",
        "public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)",
        "private TypeBindings _bindingsForSubtype(JavaType baseType, int typeParamCount, Class<?> subclass)",
        "public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass)",
        "public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException",
        "public JavaType[] findTypeParameters(JavaType type, Class<?> expType)",
        "public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings)",
        "public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType)",
        "public JavaType moreSpecificType(JavaType type1, JavaType type2)",
        "public JavaType constructType(Type type)",
        "public JavaType constructType(Type type, TypeBindings bindings)",
        "public JavaType constructType(TypeReference<?> typeRef)",
        "public JavaType constructType(Type type, Class<?> contextClass)",
        "public JavaType constructType(Type type, JavaType contextType)",
        "public ArrayType constructArrayType(Class<?> elementType)",
        "public ArrayType constructArrayType(JavaType elementType)",
        "public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass)",
        "public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType)",
        "public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass)",
        "public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType)",
        "public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass)",
        "public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType)",
        "public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass)",
        "public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType)",
        "public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes)",
        "public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes)",
        "public JavaType constructReferenceType(Class<?> rawType, JavaType referredType)",
        "public JavaType uncheckedSimpleType(Class<?> cls)",
        "public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses)",
        "public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes)",
        "public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes)",
        "public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses)",
        "public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass)",
        "public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass)",
        "public MapType constructRawMapType(Class<? extends Map> mapClass)",
        "public MapLikeType constructRawMapLikeType(Class<?> mapClass)",
        "private JavaType _mapType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _unknownType()",
        "protected JavaType _findWellKnownSimple(Class<?> clz)",
        "protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings)",
        "protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings)",
        "protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings)",
        "protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings)",
        "protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype, TypeBindings parentBindings)",
        "protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings)",
        "protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings)",
        "protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings)"
      ],
      "methods": [
        {
          "buggy_method": "  public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n  \n  final Class<?> rawBase = baseType.getRawClass();\n  if (rawBase == subclass) {\n  return baseType;\n  }\n\n  JavaType newType;\n\n  \n  do { \n  if (rawBase == Object.class) {\n  newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n  break;\n  }\n  if (!rawBase.isAssignableFrom(subclass)) {\n  throw new IllegalArgumentException(String.format(\n  \"Class %s not subtype of %s\", subclass.getName(), baseType));\n  }\n  \n\n  \n  if (baseType.getBindings().isEmpty()) {\n  newType = _fromClass(null, subclass, TypeBindings.emptyBindings());  \n  break;\n  }\n  \n  if (baseType.isContainerType()) {\n  if (baseType.isMapLikeType()) {\n  if ((subclass == HashMap.class)\n  || (subclass == LinkedHashMap.class)\n  || (subclass == EnumMap.class)\n  || (subclass == TreeMap.class)) {\n  newType = _fromClass(null, subclass,\n  TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n  break;\n  }\n  } else if (baseType.isCollectionLikeType()) {\n  if ((subclass == ArrayList.class)\n  || (subclass == LinkedList.class)\n  || (subclass == HashSet.class)\n  || (subclass == TreeSet.class)) {\n  newType = _fromClass(null, subclass,\n  TypeBindings.create(subclass, baseType.getContentType()));\n  break;\n  }\n  \n  \n  if (rawBase == EnumSet.class) {\n  return baseType;\n  }\n  }\n  }\n  \n  int typeParamCount = subclass.getTypeParameters().length;\n  if (typeParamCount == 0) {\n  newType = _fromClass(null, subclass, TypeBindings.emptyBindings());  \n  break;\n  }\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n  if (baseType.isInterface()) {\n  newType = baseType.refine(subclass, tb, null, new JavaType[] { baseType });\n  } else {\n  newType = baseType.refine(subclass, tb, baseType, NO_TYPES);\n  }\n  \n  if (newType == null) {\n  newType = _fromClass(null, subclass, tb);\n  }\n  } while (false);\n\n  \n  \n  return newType;\n\n  \n  \n  \n  }",
          "fixed_method": "  public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n  \n  final Class<?> rawBase = baseType.getRawClass();\n  if (rawBase == subclass) {\n  return baseType;\n  }\n\n  JavaType newType;\n\n  \n  do { \n  if (rawBase == Object.class) {\n  newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n  break;\n  }\n  if (!rawBase.isAssignableFrom(subclass)) {\n  throw new IllegalArgumentException(String.format(\n  \"Class %s not subtype of %s\", subclass.getName(), baseType));\n  }\n  \n\n  \n  if (baseType.getBindings().isEmpty()) {\n  newType = _fromClass(null, subclass, TypeBindings.emptyBindings());  \n  break;\n  }\n  \n  if (baseType.isContainerType()) {\n  if (baseType.isMapLikeType()) {\n  if ((subclass == HashMap.class)\n  || (subclass == LinkedHashMap.class)\n  || (subclass == EnumMap.class)\n  || (subclass == TreeMap.class)) {\n  newType = _fromClass(null, subclass,\n  TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n  break;\n  }\n  } else if (baseType.isCollectionLikeType()) {\n  if ((subclass == ArrayList.class)\n  || (subclass == LinkedList.class)\n  || (subclass == HashSet.class)\n  || (subclass == TreeSet.class)) {\n  newType = _fromClass(null, subclass,\n  TypeBindings.create(subclass, baseType.getContentType()));\n  break;\n  }\n  \n  \n  if (rawBase == EnumSet.class) {\n  return baseType;\n  }\n  }\n  }\n  \n  int typeParamCount = subclass.getTypeParameters().length;\n  if (typeParamCount == 0) {\n  newType = _fromClass(null, subclass, TypeBindings.emptyBindings());  \n  break;\n  }\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n  if (baseType.isInterface()) {\n  newType = baseType.refine(subclass, tb, null, new JavaType[] { baseType });\n  } else {\n  newType = baseType.refine(subclass, tb, baseType, NO_TYPES);\n  }\n  \n  if (newType == null) {\n  newType = _fromClass(null, subclass, tb);\n  }\n  } while (false);\n\n  \n  \n  newType = newType.withHandlersFrom(baseType);\n  return newType;\n\n  \n  \n  \n  }",
          "diff": [
            "@@ -425,6 +425,7 @@",
            " \n",
            "         // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get\n",
            "         //   copied as well\n",
            "+        newType = newType.withHandlersFrom(baseType);\n",
            "         return newType;\n",
            " \n",
            "         // 20-Oct-2015, tatu: Old simplistic approach\n"
          ],
          "changed_lines": 1
        }
      ]
    }
  ]
}
