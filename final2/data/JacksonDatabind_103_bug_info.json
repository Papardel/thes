{
  "bug_id": "103",
  "failed_tests": {
    "com.fasterxml.jackson.databind.exc.BasicExceptionTest": [
      {
        "methodName": "testLocationAddition",
        "error": "junit.framework.AssertionFailedError",
        "message": "Should only get one 'at [' marker, got 2, source: Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not one of values excepted for Enum class: [A, B, C]",
        "fail_line": "                fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);",
        "test_source": "  public void testLocationAddition() throws Exception {\n  try {\n  /*Map<?,?> map =*/ MAPPER.readValue(\"{\\\"value\\\":\\\"foo\\\"}\",\n  new TypeReference<Map<ABC, Integer>>() { });\n  fail(\"Should not pass\");\n  } catch (MismatchedInputException e) {\n  String msg = e.getMessage();\n  String[] str = msg.split(\" at \\\\[\");\n  if (str.length != 2) {\n  fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);\n  }\n  }\n  }",
        "stack": [
          "BasicExceptionTest.testLocationAddition line 127"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/DatabindContext.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind;\n\nimport java.lang.reflect.Type;\nimport java.util.Locale;\nimport java.util.TimeZone;\n\nimport com.fasterxml.jackson.annotation.*;\n\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.introspect.Annotated;\nimport com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.Converter;\n\n\npublic abstract class DatabindContext { private final static int MAX_ERROR_STR_LEN = 500; public abstract MapperConfig<?> getConfig(); public abstract AnnotationIntrospector getAnnotationIntrospector(); public abstract boolean isEnabled(MapperFeature feature); public abstract boolean canOverrideAccessModifiers(); public abstract Class<?> getActiveView(); public abstract Locale getLocale(); public abstract TimeZone getTimeZone(); public abstract JsonFormat.Value getDefaultPropertyFormat(Class<?> baseType); public abstract Object getAttribute(Object key); public abstract DatabindContext setAttribute(Object key, Object value); public JavaType constructType(Type type) {\n        if (type == null) {\n            return null;\n        }\n        return getTypeFactory().constructType(type);\n    }\n\n    \n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n        \n        if (baseType.getRawClass() == subclass) {\n            return baseType;\n        }\n        return getConfig().constructSpecializedType(baseType, subclass);\n    }\n\n    \n    public JavaType resolveSubType(JavaType baseType, String subClass) throws JsonMappingException {\n        \n        \n        \n        if (subClass.indexOf('<') > 0) {\n            \n            \n            \n            \n            JavaType t = getTypeFactory().constructFromCanonical(subClass);\n            if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {\n                return t;\n            }\n        } else {\n            Class<?> cls;\n            try {\n                cls =  getTypeFactory().findClass(subClass);\n            } catch (ClassNotFoundException e) { \n                return null;\n            } catch (Exception e) {\n                throw invalidTypeIdException(baseType, subClass, String.format(\n                        \"problem: (%s) %s\",\n                        e.getClass().getName(),\n                        e.getMessage()));\n            }\n            if (baseType.isTypeOrSuperTypeOf(cls)) {\n                return getTypeFactory().constructSpecializedType(baseType, cls);\n            }\n        }\n        throw invalidTypeIdException(baseType, subClass, \"Not a subtype\");\n    }\n\n    \n    protected abstract JsonMappingException invalidTypeIdException(JavaType baseType, String typeId, String extraDesc); public abstract TypeFactory getTypeFactory(); public ObjectIdGenerator<?> objectIdGeneratorInstance(Annotated annotated, ObjectIdInfo objectIdInfo) throws JsonMappingException {\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n        final MapperConfig<?> config = getConfig();\n        HandlerInstantiator hi = config.getHandlerInstantiator();\n        ObjectIdGenerator<?> gen = (hi == null) ? null : hi.objectIdGeneratorInstance(config, annotated, implClass);\n        if (gen == null) {\n            gen = (ObjectIdGenerator<?>) ClassUtil.createInstance(implClass,\n                    config.canOverrideAccessModifiers());\n        }\n        return gen.forScope(objectIdInfo.getScope());\n    }\n\n    public ObjectIdResolver objectIdResolverInstance(Annotated annotated, ObjectIdInfo objectIdInfo) {\n        Class<? extends ObjectIdResolver> implClass = objectIdInfo.getResolverType();\n        final MapperConfig<?> config = getConfig();\n        HandlerInstantiator hi = config.getHandlerInstantiator();\n        ObjectIdResolver resolver = (hi == null) ? null : hi.resolverIdGeneratorInstance(config, annotated, implClass);\n        if (resolver == null) {\n            resolver = ClassUtil.createInstance(implClass, config.canOverrideAccessModifiers());\n        }\n\n        return resolver;\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public Converter<Object,Object> converterInstance(Annotated annotated, Object converterDef) throws JsonMappingException {\n        if (converterDef == null) {\n            return null;\n        }\n        if (converterDef instanceof Converter<?,?>) {\n            return (Converter<Object,Object>) converterDef;\n        }\n        if (!(converterDef instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned Converter definition of type \"\n                    +converterDef.getClass().getName()+\"; expected type Converter or Class<Converter> instead\");\n        }\n        Class<?> converterClass = (Class<?>)converterDef;\n        \n        if (converterClass == Converter.None.class || ClassUtil.isBogusClass(converterClass)) {\n            return null;\n        }\n        if (!Converter.class.isAssignableFrom(converterClass)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"\n                    +converterClass.getName()+\"; expected Class<Converter>\");\n        }\n        final MapperConfig<?> config = getConfig();\n        HandlerInstantiator hi = config.getHandlerInstantiator();\n        Converter<?,?> conv = (hi == null) ? null : hi.converterInstance(config, annotated, converterClass);\n        if (conv == null) {\n            conv = (Converter<?,?>) ClassUtil.createInstance(converterClass,\n                    config.canOverrideAccessModifiers());\n        }\n        return (Converter<Object,Object>) conv;\n    }\n\n    \n\n    \n    public abstract <T> T reportBadDefinition(JavaType type, String msg) throws JsonMappingException; public <T> T reportBadDefinition(Class<?> type, String msg) throws JsonMappingException {\n        return reportBadDefinition(constructType(type), msg);\n    }\n\n    \n\n    \n    protected final String _format(String msg, Object... msgArgs) {\n        if (msgArgs.length > 0) {\n            return String.format(msg, msgArgs);\n        }\n        return msg;\n    }\n\n    \n    protected final String _truncate(String desc) {\n        if (desc == null) {\n            return \"\";\n        }\n        if (desc.length() <= MAX_ERROR_STR_LEN) {\n            return desc;\n        }\n        return desc.substring(0, MAX_ERROR_STR_LEN) + \"]...[\" + desc.substring(desc.length() - MAX_ERROR_STR_LEN);\n    }\n\n    \n    protected String _quotedString(String desc) {\n        if (desc == null) {\n            return \"[N/A]\";\n        }\n        \n        return String.format(\"\\\"%s\\\"\", _truncate(desc));\n    }\n    \n    \n    protected String _colonConcat(String msgBase, String extra) {\n        if (extra == null) {\n            return msgBase;\n        }\n        return msgBase + \": \" + extra;\n    }\n\n    \n    protected String _desc(String desc) {\n        if (desc == null) {\n            return \"[N/A]\";\n        }\n        \n        return _truncate(desc);\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind;\n\nimport java.lang.reflect.Type;\nimport java.util.Locale;\nimport java.util.TimeZone;\n\nimport com.fasterxml.jackson.annotation.*;\n\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.introspect.Annotated;\nimport com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.Converter;\n\n\npublic abstract class DatabindContext { private final static int MAX_ERROR_STR_LEN = 500; public abstract MapperConfig<?> getConfig(); public abstract AnnotationIntrospector getAnnotationIntrospector(); public abstract boolean isEnabled(MapperFeature feature); public abstract boolean canOverrideAccessModifiers(); public abstract Class<?> getActiveView(); public abstract Locale getLocale(); public abstract TimeZone getTimeZone(); public abstract JsonFormat.Value getDefaultPropertyFormat(Class<?> baseType); public abstract Object getAttribute(Object key); public abstract DatabindContext setAttribute(Object key, Object value); public JavaType constructType(Type type) {\n        if (type == null) {\n            return null;\n        }\n        return getTypeFactory().constructType(type);\n    }\n\n    \n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n        \n        if (baseType.getRawClass() == subclass) {\n            return baseType;\n        }\n        return getConfig().constructSpecializedType(baseType, subclass);\n    }\n\n    \n    public JavaType resolveSubType(JavaType baseType, String subClass) throws JsonMappingException {\n        \n        \n        \n        if (subClass.indexOf('<') > 0) {\n            \n            \n            \n            \n            JavaType t = getTypeFactory().constructFromCanonical(subClass);\n            if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {\n                return t;\n            }\n        } else {\n            Class<?> cls;\n            try {\n                cls =  getTypeFactory().findClass(subClass);\n            } catch (ClassNotFoundException e) { \n                return null;\n            } catch (Exception e) {\n                throw invalidTypeIdException(baseType, subClass, String.format(\n                        \"problem: (%s) %s\",\n                        e.getClass().getName(),\n                        ClassUtil.exceptionMessage(e)));\n            }\n            if (baseType.isTypeOrSuperTypeOf(cls)) {\n                return getTypeFactory().constructSpecializedType(baseType, cls);\n            }\n        }\n        throw invalidTypeIdException(baseType, subClass, \"Not a subtype\");\n    }\n\n    \n    protected abstract JsonMappingException invalidTypeIdException(JavaType baseType, String typeId, String extraDesc); public abstract TypeFactory getTypeFactory(); public ObjectIdGenerator<?> objectIdGeneratorInstance(Annotated annotated, ObjectIdInfo objectIdInfo) throws JsonMappingException {\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n        final MapperConfig<?> config = getConfig();\n        HandlerInstantiator hi = config.getHandlerInstantiator();\n        ObjectIdGenerator<?> gen = (hi == null) ? null : hi.objectIdGeneratorInstance(config, annotated, implClass);\n        if (gen == null) {\n            gen = (ObjectIdGenerator<?>) ClassUtil.createInstance(implClass,\n                    config.canOverrideAccessModifiers());\n        }\n        return gen.forScope(objectIdInfo.getScope());\n    }\n\n    public ObjectIdResolver objectIdResolverInstance(Annotated annotated, ObjectIdInfo objectIdInfo) {\n        Class<? extends ObjectIdResolver> implClass = objectIdInfo.getResolverType();\n        final MapperConfig<?> config = getConfig();\n        HandlerInstantiator hi = config.getHandlerInstantiator();\n        ObjectIdResolver resolver = (hi == null) ? null : hi.resolverIdGeneratorInstance(config, annotated, implClass);\n        if (resolver == null) {\n            resolver = ClassUtil.createInstance(implClass, config.canOverrideAccessModifiers());\n        }\n\n        return resolver;\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public Converter<Object,Object> converterInstance(Annotated annotated, Object converterDef) throws JsonMappingException {\n        if (converterDef == null) {\n            return null;\n        }\n        if (converterDef instanceof Converter<?,?>) {\n            return (Converter<Object,Object>) converterDef;\n        }\n        if (!(converterDef instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned Converter definition of type \"\n                    +converterDef.getClass().getName()+\"; expected type Converter or Class<Converter> instead\");\n        }\n        Class<?> converterClass = (Class<?>)converterDef;\n        \n        if (converterClass == Converter.None.class || ClassUtil.isBogusClass(converterClass)) {\n            return null;\n        }\n        if (!Converter.class.isAssignableFrom(converterClass)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"\n                    +converterClass.getName()+\"; expected Class<Converter>\");\n        }\n        final MapperConfig<?> config = getConfig();\n        HandlerInstantiator hi = config.getHandlerInstantiator();\n        Converter<?,?> conv = (hi == null) ? null : hi.converterInstance(config, annotated, converterClass);\n        if (conv == null) {\n            conv = (Converter<?,?>) ClassUtil.createInstance(converterClass,\n                    config.canOverrideAccessModifiers());\n        }\n        return (Converter<Object,Object>) conv;\n    }\n\n    \n\n    \n    public abstract <T> T reportBadDefinition(JavaType type, String msg) throws JsonMappingException; public <T> T reportBadDefinition(Class<?> type, String msg) throws JsonMappingException {\n        return reportBadDefinition(constructType(type), msg);\n    }\n\n    \n\n    \n    protected final String _format(String msg, Object... msgArgs) {\n        if (msgArgs.length > 0) {\n            return String.format(msg, msgArgs);\n        }\n        return msg;\n    }\n\n    \n    protected final String _truncate(String desc) {\n        if (desc == null) {\n            return \"\";\n        }\n        if (desc.length() <= MAX_ERROR_STR_LEN) {\n            return desc;\n        }\n        return desc.substring(0, MAX_ERROR_STR_LEN) + \"]...[\" + desc.substring(desc.length() - MAX_ERROR_STR_LEN);\n    }\n\n    \n    protected String _quotedString(String desc) {\n        if (desc == null) {\n            return \"[N/A]\";\n        }\n        \n        return String.format(\"\\\"%s\\\"\", _truncate(desc));\n    }\n    \n    \n    protected String _colonConcat(String msgBase, String extra) {\n        if (extra == null) {\n            return msgBase;\n        }\n        return msgBase + \": \" + extra;\n    }\n\n    \n    protected String _desc(String desc) {\n        if (desc == null) {\n            return \"[N/A]\";\n        }\n        \n        return _truncate(desc);\n    }\n}\n",
      "buggy_signatures": [
        "public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)",
        "public JavaType resolveSubType(JavaType baseType, String subClass) throws JsonMappingException",
        "protected abstract JsonMappingException invalidTypeIdException(JavaType baseType, String typeId, String extraDesc); public abstract TypeFactory getTypeFactory(); public ObjectIdGenerator<?> objectIdGeneratorInstance(Annotated annotated, ObjectIdInfo objectIdInfo) throws JsonMappingException",
        "public ObjectIdResolver objectIdResolverInstance(Annotated annotated, ObjectIdInfo objectIdInfo)",
        "public Converter<Object,Object> converterInstance(Annotated annotated, Object converterDef) throws JsonMappingException",
        "public abstract <T> T reportBadDefinition(JavaType type, String msg) throws JsonMappingException; public <T> T reportBadDefinition(Class<?> type, String msg) throws JsonMappingException",
        "protected final String _format(String msg, Object... msgArgs)",
        "protected final String _truncate(String desc)",
        "protected String _quotedString(String desc)",
        "protected String _colonConcat(String msgBase, String extra)",
        "protected String _desc(String desc)"
      ],
      "fixed_signatures": [
        "public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)",
        "public JavaType resolveSubType(JavaType baseType, String subClass) throws JsonMappingException",
        "protected abstract JsonMappingException invalidTypeIdException(JavaType baseType, String typeId, String extraDesc); public abstract TypeFactory getTypeFactory(); public ObjectIdGenerator<?> objectIdGeneratorInstance(Annotated annotated, ObjectIdInfo objectIdInfo) throws JsonMappingException",
        "public ObjectIdResolver objectIdResolverInstance(Annotated annotated, ObjectIdInfo objectIdInfo)",
        "public Converter<Object,Object> converterInstance(Annotated annotated, Object converterDef) throws JsonMappingException",
        "public abstract <T> T reportBadDefinition(JavaType type, String msg) throws JsonMappingException; public <T> T reportBadDefinition(Class<?> type, String msg) throws JsonMappingException",
        "protected final String _format(String msg, Object... msgArgs)",
        "protected final String _truncate(String desc)",
        "protected String _quotedString(String desc)",
        "protected String _colonConcat(String msgBase, String extra)",
        "protected String _desc(String desc)"
      ],
      "methods": [
        {
          "buggy_method": "  public JavaType resolveSubType(JavaType baseType, String subClass) throws JsonMappingException {\n  \n  \n  \n  if (subClass.indexOf('<') > 0) {\n  \n  \n  \n  \n  JavaType t = getTypeFactory().constructFromCanonical(subClass);\n  if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {\n  return t;\n  }\n  } else {\n  Class<?> cls;\n  try {\n  cls =  getTypeFactory().findClass(subClass);\n  } catch (ClassNotFoundException e) { \n  return null;\n  } catch (Exception e) {\n  throw invalidTypeIdException(baseType, subClass, String.format(\n  \"problem: (%s) %s\",\n  e.getClass().getName(),\n  e.getMessage()));\n  }\n  if (baseType.isTypeOrSuperTypeOf(cls)) {\n  return getTypeFactory().constructSpecializedType(baseType, cls);\n  }\n  }\n  throw invalidTypeIdException(baseType, subClass, \"Not a subtype\");\n  }",
          "fixed_method": "  public JavaType resolveSubType(JavaType baseType, String subClass) throws JsonMappingException {\n  \n  \n  \n  if (subClass.indexOf('<') > 0) {\n  \n  \n  \n  \n  JavaType t = getTypeFactory().constructFromCanonical(subClass);\n  if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {\n  return t;\n  }\n  } else {\n  Class<?> cls;\n  try {\n  cls =  getTypeFactory().findClass(subClass);\n  } catch (ClassNotFoundException e) { \n  return null;\n  } catch (Exception e) {\n  throw invalidTypeIdException(baseType, subClass, String.format(\n  \"problem: (%s) %s\",\n  e.getClass().getName(),\n  ClassUtil.exceptionMessage(e)));\n  }\n  if (baseType.isTypeOrSuperTypeOf(cls)) {\n  return getTypeFactory().constructSpecializedType(baseType, cls);\n  }\n  }\n  throw invalidTypeIdException(baseType, subClass, \"Not a subtype\");\n  }",
          "diff": [
            "@@ -192,7 +192,7 @@",
            "                 throw invalidTypeIdException(baseType, subClass, String.format(\n",
            "                         \"problem: (%s) %s\",\n",
            "                         e.getClass().getName(),\n",
            "-                        e.getMessage()));\n",
            "+                        ClassUtil.exceptionMessage(e)));\n",
            "             }\n",
            "             if (baseType.isTypeOrSuperTypeOf(cls)) {\n",
            "                 return getTypeFactory().constructSpecializedType(baseType, cls);\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/DeserializationContext.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind;\n\nimport java.io.IOException;\nimport java.text.DateFormat;\nimport java.text.ParseException;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator;\nimport com.fasterxml.jackson.annotation.ObjectIdResolver;\n\nimport com.fasterxml.jackson.core.*;\n\nimport com.fasterxml.jackson.databind.cfg.ContextAttributes;\nimport com.fasterxml.jackson.databind.deser.*;\nimport com.fasterxml.jackson.databind.deser.impl.ObjectIdReader;\nimport com.fasterxml.jackson.databind.deser.impl.ReadableObjectId;\nimport com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer;\nimport com.fasterxml.jackson.databind.exc.MismatchedInputException;\nimport com.fasterxml.jackson.databind.exc.InvalidDefinitionException;\nimport com.fasterxml.jackson.databind.exc.InvalidFormatException;\nimport com.fasterxml.jackson.databind.exc.InvalidTypeIdException;\nimport com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;\nimport com.fasterxml.jackson.databind.introspect.Annotated;\nimport com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\nimport com.fasterxml.jackson.databind.node.JsonNodeFactory;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.*;\n\n\npublic abstract class DeserializationContext extends DatabindContext implements java.io.Serializable { private static final long serialVersionUID = 1L; protected final DeserializerCache _cache; protected final DeserializerFactory _factory; protected final DeserializationConfig _config; protected final int _featureFlags; protected final Class<?> _view; protected transient JsonParser _parser; protected final InjectableValues _injectableValues; protected transient ArrayBuilders _arrayBuilders; protected transient ObjectBuffer _objectBuffer; protected transient DateFormat _dateFormat; protected transient ContextAttributes _attributes; protected LinkedNode<JavaType> _currentType; protected DeserializationContext(DeserializerFactory df) {\n        this(df, null);\n    }\n    \n    protected DeserializationContext(DeserializerFactory df, DeserializerCache cache) {\n        if (df == null) {\n            throw new IllegalArgumentException(\"Cannot pass null DeserializerFactory\");\n        }\n        _factory = df;\n        if (cache == null) {\n            cache = new DeserializerCache();\n        }\n        _cache = cache;\n        _featureFlags = 0;\n        _config = null;\n        _injectableValues = null;\n        _view = null;\n        _attributes = null;\n    }\n\n    protected DeserializationContext(DeserializationContext src, DeserializerFactory factory) {\n        _cache = src._cache;\n        _factory = factory;\n        \n        _config = src._config;\n        _featureFlags = src._featureFlags;\n        _view = src._view;\n        _parser = src._parser;\n        _injectableValues = src._injectableValues;\n        _attributes = src._attributes;\n    }\n\n    \n    protected DeserializationContext(DeserializationContext src, DeserializationConfig config, JsonParser p, InjectableValues injectableValues) {\n        _cache = src._cache;\n        _factory = src._factory;\n        \n        _config = config;\n        _featureFlags = config.getDeserializationFeatures();\n        _view = config.getActiveView();\n        _parser = p;\n        _injectableValues = injectableValues;\n        _attributes = config.getAttributes();\n    }\n\n    \n    protected DeserializationContext(DeserializationContext src) {\n        _cache = new DeserializerCache();\n        _factory = src._factory;\n\n        _config = src._config;\n        _featureFlags = src._featureFlags;\n        _view = src._view;\n        _injectableValues = null;\n    }\n    \n    \n\n    @Override\n    public DeserializationConfig getConfig() { return _config; }\n\n    @Override\n    public final Class<?> getActiveView() { return _view; }\n\n    @Override\n    public final boolean canOverrideAccessModifiers() {\n        return _config.canOverrideAccessModifiers();\n    }\n\n    @Override\n    public final boolean isEnabled(MapperFeature feature) {\n        return _config.isEnabled(feature);\n    }\n\n    @Override\n    public final JsonFormat.Value getDefaultPropertyFormat(Class<?> baseType) {\n        return _config.getDefaultPropertyFormat(baseType);\n    }\n\n    @Override\n    public final AnnotationIntrospector getAnnotationIntrospector() {\n        return _config.getAnnotationIntrospector();\n    }\n\n    @Override\n    public final TypeFactory getTypeFactory() {\n        return _config.getTypeFactory();\n    }\n\n    \n    @Override\n    public Locale getLocale() {\n        return _config.getLocale();\n    }\n\n    \n    @Override\n    public TimeZone getTimeZone() {\n        return _config.getTimeZone();\n    }\n\n    \n\n    @Override\n    public Object getAttribute(Object key) {\n        return _attributes.getAttribute(key);\n    }\n\n    @Override\n    public DeserializationContext setAttribute(Object key, Object value) {\n        _attributes = _attributes.withPerCallAttribute(key, value);\n        return this;\n    }\n\n    \n    public JavaType getContextualType() {\n        return (_currentType == null) ? null : _currentType.value();\n    }\n\n    \n\n    \n    public DeserializerFactory getFactory() {\n        return _factory;\n    }\n    \n    \n    public final boolean isEnabled(DeserializationFeature feat) {\n        \n        return (_featureFlags & feat.getMask()) != 0;\n    }\n\n    \n    public final int getDeserializationFeatures() {\n        return _featureFlags;\n    }\n    \n    \n    public final boolean hasDeserializationFeatures(int featureMask) {\n        return (_featureFlags & featureMask) == featureMask;\n    }\n\n    \n    public final boolean hasSomeOfFeatures(int featureMask) {\n        return (_featureFlags & featureMask) != 0;\n    }\n    \n    \n    public final JsonParser getParser() { return _parser; }\n\n    public final Object findInjectableValue(Object valueId, BeanProperty forProperty, Object beanInstance) throws JsonMappingException {\n        if (_injectableValues == null) {\n            reportBadDefinition(ClassUtil.classOf(valueId), String.format(\n\"No 'injectableValues' configured, cannot inject value with id [%s]\", valueId));\n        }\n        return _injectableValues.findInjectableValue(valueId, this, forProperty, beanInstance);\n    }\n\n    \n    public final Base64Variant getBase64Variant() {\n        return _config.getBase64Variant();\n    }\n\n    \n    public final JsonNodeFactory getNodeFactory() {\n        return _config.getNodeFactory();\n    }\n\n    \n\n    \n    public boolean hasValueDeserializerFor(JavaType type, AtomicReference<Throwable> cause) {\n        try {\n            return _cache.hasValueDeserializerFor(this, _factory, type);\n        } catch (JsonMappingException e) {\n            if (cause != null) {\n                cause.set(e);\n            }\n        } catch (RuntimeException e) {\n            if (cause == null) { \n                throw e;\n            }\n            cause.set(e);\n        }\n        return false;\n    }\n    \n    \n    @SuppressWarnings(\"unchecked\")\n    public final JsonDeserializer<Object> findContextualValueDeserializer(JavaType type, BeanProperty prop) throws JsonMappingException {\n        JsonDeserializer<Object> deser = _cache.findValueDeserializer(this, _factory, type);\n        if (deser != null) {\n            deser = (JsonDeserializer<Object>) handleSecondaryContextualization(deser, prop, type);\n        }\n        return deser;\n    }\n\n    \n    public final JsonDeserializer<Object> findNonContextualValueDeserializer(JavaType type) throws JsonMappingException {\n        return _cache.findValueDeserializer(this, _factory, type);\n    }\n    \n    \n    @SuppressWarnings(\"unchecked\")\n    public final JsonDeserializer<Object> findRootValueDeserializer(JavaType type) throws JsonMappingException {\n        JsonDeserializer<Object> deser = _cache.findValueDeserializer(this,\n                _factory, type);\n        if (deser == null) { \n            return null;\n        }\n        deser = (JsonDeserializer<Object>) handleSecondaryContextualization(deser, null, type);\n        TypeDeserializer typeDeser = _factory.findTypeDeserializer(_config, type);\n        if (typeDeser != null) {\n            \n            typeDeser = typeDeser.forProperty(null);\n            return new TypeWrappedDeserializer(typeDeser, deser);\n        }\n        return deser;\n    }\n\n    \n    public final KeyDeserializer findKeyDeserializer(JavaType keyType, BeanProperty prop) throws JsonMappingException {\n        KeyDeserializer kd = _cache.findKeyDeserializer(this,\n                _factory, keyType);\n        \n        if (kd instanceof ContextualKeyDeserializer) {\n            kd = ((ContextualKeyDeserializer) kd).createContextual(this, prop);\n        }\n        return kd;\n    }\n    \n    \n\n    \n    public abstract ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> generator, ObjectIdResolver resolver); public abstract void checkUnresolvedObjectId() throws UnresolvedForwardReference; public final JavaType constructType(Class<?> cls) {\n        return (cls == null) ? null : _config.constructType(cls);\n    }\n\n    \n    public Class<?> findClass(String className) throws ClassNotFoundException {\n        \n        return getTypeFactory().findClass(className);\n    }\n\n    \n\n    \n    public final ObjectBuffer leaseObjectBuffer() {\n        ObjectBuffer buf = _objectBuffer;\n        if (buf == null) {\n            buf = new ObjectBuffer();\n        } else {\n            _objectBuffer = null;\n        }\n        return buf;\n    }\n\n    \n    public final void returnObjectBuffer(ObjectBuffer buf) {\n        \n        if (_objectBuffer == null\n            || buf.initialCapacity() >= _objectBuffer.initialCapacity()) {\n            _objectBuffer = buf;\n        }\n    }\n\n    \n    public final ArrayBuilders getArrayBuilders() {\n        if (_arrayBuilders == null) {\n            _arrayBuilders = new ArrayBuilders();\n        }\n        return _arrayBuilders;\n    }\n\n    \n\n    public abstract JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException; public abstract KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException; public JsonDeserializer<?> handlePrimaryContextualization(JsonDeserializer<?> deser, BeanProperty prop, JavaType type) throws JsonMappingException {\n        if (deser instanceof ContextualDeserializer) {\n            _currentType = new LinkedNode<JavaType>(type, _currentType);\n            try {\n                deser = ((ContextualDeserializer) deser).createContextual(this, prop);\n            } finally {\n                _currentType = _currentType.next();\n            }\n        }\n        return deser;\n    }\n\n    \n    public JsonDeserializer<?> handleSecondaryContextualization(JsonDeserializer<?> deser, BeanProperty prop, JavaType type) throws JsonMappingException {\n        if (deser instanceof ContextualDeserializer) {\n            _currentType = new LinkedNode<JavaType>(type, _currentType);\n            try {\n                deser = ((ContextualDeserializer) deser).createContextual(this, prop);\n            } finally {\n                _currentType = _currentType.next();\n            }\n        }\n        return deser;\n    }\n\n    \n\n    \n    public Date parseDate(String dateStr) throws IllegalArgumentException {\n        try {\n            DateFormat df = getDateFormat();\n            return df.parse(dateStr);\n        } catch (ParseException e) {\n            throw new IllegalArgumentException(String.format(\n                    \"Failed to parse Date value '%s': %s\", dateStr,\n                    e.getMessage()));\n        }\n    }\n\n    \n    public Calendar constructCalendar(Date d) {\n        \n        Calendar c = Calendar.getInstance(getTimeZone());\n        c.setTime(d);\n        return c;\n    }\n\n    \n\n    \n    public <T> T readValue(JsonParser p, Class<T> type) throws IOException {\n        return readValue(p, getTypeFactory().constructType(type));\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser p, JavaType type) throws IOException {\n        JsonDeserializer<Object> deser = findRootValueDeserializer(type);\n        if (deser == null) {\n            reportBadDefinition(type,\n                    \"Could not find JsonDeserializer for type \"+type);\n        }\n        return (T) deser.deserialize(p, this);\n    }\n\n    \n    public <T> T readPropertyValue(JsonParser p, BeanProperty prop, Class<T> type) throws IOException {\n        return readPropertyValue(p, prop, getTypeFactory().constructType(type));\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readPropertyValue(JsonParser p, BeanProperty prop, JavaType type) throws IOException {\n        JsonDeserializer<Object> deser = findContextualValueDeserializer(type, prop);\n        if (deser == null) {\n            return reportBadDefinition(type, String.format(\n                    \"Could not find JsonDeserializer for type %s (via property %s)\",\n                    type, ClassUtil.nameOf(prop)));\n        }\n        return (T) deser.deserialize(p, this);\n    }\n\n    \n\n    \n    public boolean handleUnknownProperty(JsonParser p, JsonDeserializer<?> deser, Object instanceOrClass, String propName) throws IOException {\n        LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();\n        while (h != null) {\n            \n            if (h.value().handleUnknownProperty(this, p, deser, instanceOrClass, propName)) {\n                return true;\n            }\n            h = h.next();\n        }\n        \n        if (!isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n            p.skipChildren();\n            return true;\n        }\n        \n        Collection<Object> propIds = (deser == null) ? null : deser.getKnownPropertyNames();\n        throw UnrecognizedPropertyException.from(_parser,\n                instanceOrClass, propName, propIds);\n    }\n\n    \n    public Object handleWeirdKey(Class<?> keyClass, String keyValue, String msg, Object... msgArgs) throws IOException {\n        \n        msg = _format(msg, msgArgs);\n        LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();\n        while (h != null) {\n            \n            Object key = h.value().handleWeirdKey(this, keyClass, keyValue, msg);\n            if (key != DeserializationProblemHandler.NOT_HANDLED) {\n                \n                if ((key == null) || keyClass.isInstance(key)) {\n                    return key;\n                }\n                throw weirdStringException(keyValue, keyClass, String.format(\n                        \"DeserializationProblemHandler.handleWeirdStringValue() for type %s returned value of type %s\",\n                        keyClass, key.getClass()));\n            }\n            h = h.next();\n        }\n        throw weirdKeyException(keyClass, keyValue, msg);\n    }\n\n    \n    public Object handleWeirdStringValue(Class<?> targetClass, String value, String msg, Object... msgArgs) throws IOException {\n        \n        msg = _format(msg, msgArgs);\n        LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();\n        while (h != null) {\n            \n            Object instance = h.value().handleWeirdStringValue(this, targetClass, value, msg);\n            if (instance != DeserializationProblemHandler.NOT_HANDLED) {\n                \n                if (_isCompatible(targetClass, instance)) {\n                    return instance;\n                }\n                throw weirdStringException(value, targetClass, String.format(\n                        \"DeserializationProblemHandler.handleWeirdStringValue() for type %s returned value of type %s\",\n                        targetClass, instance.getClass()));\n            }\n            h = h.next();\n        }\n        throw weirdStringException(value, targetClass, msg);\n    }\n\n    \n    public Object handleWeirdNumberValue(Class<?> targetClass, Number value, String msg, Object... msgArgs) throws IOException {\n        msg = _format(msg, msgArgs);\n        LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();\n        while (h != null) {\n            \n            Object key = h.value().handleWeirdNumberValue(this, targetClass, value, msg);\n            if (key != DeserializationProblemHandler.NOT_HANDLED) {\n                \n                if (_isCompatible(targetClass, key)) {\n                    return key;\n                }\n                throw weirdNumberException(value, targetClass, _format(\n                        \"DeserializationProblemHandler.handleWeirdNumberValue() for type %s returned value of type %s\",\n                        targetClass, key.getClass()));\n            }\n            h = h.next();\n        }\n        throw weirdNumberException(value, targetClass, msg);\n    }\n\n    public Object handleWeirdNativeValue(JavaType targetType, Object badValue, JsonParser p) throws IOException {\n        LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();\n        final Class<?> raw = targetType.getRawClass();\n        for (; h != null; h = h.next()) {\n            \n            Object goodValue = h.value().handleWeirdNativeValue(this, targetType, badValue, p);\n            if (goodValue != DeserializationProblemHandler.NOT_HANDLED) {\n                \n                if ((goodValue == null) || raw.isInstance(goodValue)) {\n                    return goodValue;\n                }\n                throw JsonMappingException.from(p, _format(\n\"DeserializationProblemHandler.handleWeirdNativeValue() for type %s returned value of type %s\",\ntargetType, goodValue.getClass()));\n            }\n        }\n        throw weirdNativeValueException(badValue, raw);\n    }\n\n    \n    @SuppressWarnings(\"resource\")\n    public Object handleMissingInstantiator(Class<?> instClass, ValueInstantiator valueInst, JsonParser p, String msg, Object... msgArgs) throws IOException {\n        if (p == null) {\n            p = getParser();\n        }\n        msg = _format(msg, msgArgs);\n        LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();\n        while (h != null) {\n            \n            Object instance = h.value().handleMissingInstantiator(this,\n                    instClass, valueInst, p, msg);\n            if (instance != DeserializationProblemHandler.NOT_HANDLED) {\n                \n                if (_isCompatible(instClass, instance)) {\n                    return instance;\n                }\n                reportBadDefinition(constructType(instClass), String.format(\n\"DeserializationProblemHandler.handleMissingInstantiator() for type %s returned value of type %s\",\n                        instClass, ClassUtil.classNameOf(instance)));\n            }\n            h = h.next();\n        }\n\n        \n        \n        \n        if ((valueInst != null) && !valueInst.canInstantiate()) {\n            msg = String.format(\"Cannot construct instance of %s (no Creators, like default construct, exist): %s\",\n                    ClassUtil.nameOf(instClass), msg);\n            return reportBadDefinition(constructType(instClass), msg);\n        }\n        msg = String.format(\"Cannot construct instance of %s (although at least one Creator exists): %s\",\n                ClassUtil.nameOf(instClass), msg);\n        return reportInputMismatch(instClass, msg);\n    }\n\n    \n    public Object handleInstantiationProblem(Class<?> instClass, Object argument, Throwable t) throws IOException {\n        LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();\n        while (h != null) {\n            \n            Object instance = h.value().handleInstantiationProblem(this, instClass, argument, t);\n            if (instance != DeserializationProblemHandler.NOT_HANDLED) {\n                \n                if (_isCompatible(instClass, instance)) {\n                    return instance;\n                }\n                reportBadDefinition(constructType(instClass), String.format(\n\"DeserializationProblemHandler.handleInstantiationProblem() for type %s returned value of type %s\",\n                        instClass, ClassUtil.classNameOf(instance)));\n            }\n            h = h.next();\n        }\n        \n        ClassUtil.throwIfIOE(t);\n        throw instantiationException(instClass, t);\n    }\n\n    \n    public Object handleUnexpectedToken(Class<?> instClass, JsonParser p) throws IOException {\n        return handleUnexpectedToken(instClass, p.getCurrentToken(), p, null);\n    }\n\n    \n    public Object handleUnexpectedToken(Class<?> instClass, JsonToken t, JsonParser p, String msg, Object... msgArgs) throws IOException {\n        msg = _format(msg, msgArgs);\n        LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();\n        while (h != null) {\n            Object instance = h.value().handleUnexpectedToken(this,\n                    instClass, t, p, msg);\n            if (instance != DeserializationProblemHandler.NOT_HANDLED) {\n                if (_isCompatible(instClass, instance)) {\n                    return instance;\n                }\n                reportBadDefinition(constructType(instClass), String.format(\n                        \"DeserializationProblemHandler.handleUnexpectedToken() for type %s returned value of type %s\",\n                        ClassUtil.nameOf(instClass), ClassUtil.classNameOf(instance)));\n            }\n            h = h.next();\n        }\n        if (msg == null) {\n            if (t == null) {\n                msg = String.format(\"Unexpected end-of-input when binding data into %s\",\n                        ClassUtil.nameOf(instClass));\n            } else {\n                msg = String.format(\"Cannot deserialize instance of %s out of %s token\",\n                        ClassUtil.nameOf(instClass), t);\n            }\n        }\n        reportInputMismatch(instClass, msg);\n        return null; \n    }\n\n    \n    public JavaType handleUnknownTypeId(JavaType baseType, String id, TypeIdResolver idResolver, String extraDesc) throws IOException {\n        LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();\n        while (h != null) {\n            \n            JavaType type = h.value().handleUnknownTypeId(this, baseType, id, idResolver, extraDesc);\n            if (type != null) {\n                if (type.hasRawClass(Void.class)) {\n                    return null;\n                }\n                \n                if (type.isTypeOrSubTypeOf(baseType.getRawClass())) {\n                    return type;\n                }\n                throw invalidTypeIdException(baseType, id,\n                        \"problem handler tried to resolve into non-subtype: \"+type);\n            }\n            h = h.next();\n        }\n        \n        if (!isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) {\n            return null;\n        }\n        throw invalidTypeIdException(baseType, id, extraDesc);\n    }\n\n    \n    public JavaType handleMissingTypeId(JavaType baseType, TypeIdResolver idResolver, String extraDesc) throws IOException {\n        LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();\n        while (h != null) {\n            \n            JavaType type = h.value().handleMissingTypeId(this, baseType, idResolver, extraDesc);\n            if (type != null) {\n                if (type.hasRawClass(Void.class)) {\n                    return null;\n                }\n                \n                if (type.isTypeOrSubTypeOf(baseType.getRawClass())) {\n                    return type;\n                }\n                throw invalidTypeIdException(baseType, null,\n                        \"problem handler tried to resolve into non-subtype: \"+type);\n            }\n            h = h.next();\n        }\n        \n        \n\n\n\n        throw missingTypeIdException(baseType, extraDesc);\n    }\n\n    \n    protected boolean _isCompatible(Class<?> target, Object value) {\n        if ((value == null) || target.isInstance(value)) {\n            return true;\n        }\n        \n        return target.isPrimitive()\n                && ClassUtil.wrapperType(target).isInstance(value);\n    }\n\n    \n\n    \n    public void reportWrongTokenException(JsonDeserializer<?> deser, JsonToken expToken, String msg, Object... msgArgs) throws JsonMappingException {\n        msg = _format(msg, msgArgs);\n        throw wrongTokenException(getParser(), deser.handledType(), expToken, msg);\n    }\n    \n    \n    public void reportWrongTokenException(JavaType targetType, JsonToken expToken, String msg, Object... msgArgs) throws JsonMappingException {\n        msg = _format(msg, msgArgs);\n        throw wrongTokenException(getParser(), targetType, expToken, msg);\n    }\n\n    \n    public void reportWrongTokenException(Class<?> targetType, JsonToken expToken, String msg, Object... msgArgs) throws JsonMappingException {\n        msg = _format(msg, msgArgs);\n        throw wrongTokenException(getParser(), targetType, expToken, msg);\n    }\n\n    \n    public <T> T reportUnresolvedObjectId(ObjectIdReader oidReader, Object bean) throws JsonMappingException {\n        String msg = String.format(\"No Object Id found for an instance of %s, to assign to property '%s'\",\n                ClassUtil.classNameOf(bean), oidReader.propertyName);\n        return reportInputMismatch(oidReader.idProperty, msg);\n    }\n\n    \n    public <T> T reportInputMismatch(BeanProperty prop, String msg, Object... msgArgs) throws JsonMappingException {\n        msg = _format(msg, msgArgs);\n        JavaType type = (prop == null) ? null : prop.getType();\n        throw MismatchedInputException.from(getParser(), type, msg);\n    }\n\n    \n    public <T> T reportInputMismatch(JsonDeserializer<?> src, String msg, Object... msgArgs) throws JsonMappingException {\n        msg = _format(msg, msgArgs);\n        throw MismatchedInputException.from(getParser(), src.handledType(), msg);\n    }\n\n    \n    public <T> T reportInputMismatch(Class<?> targetType, String msg, Object... msgArgs) throws JsonMappingException {\n        msg = _format(msg, msgArgs);\n        throw MismatchedInputException.from(getParser(), targetType, msg);\n    }\n\n    \n    public <T> T reportInputMismatch(JavaType targetType, String msg, Object... msgArgs) throws JsonMappingException {\n        msg = _format(msg, msgArgs);\n        throw MismatchedInputException.from(getParser(), targetType, msg);\n    }\n\n    public <T> T reportTrailingTokens(Class<?> targetType, JsonParser p, JsonToken trailingToken) throws JsonMappingException {\n        throw MismatchedInputException.from(p, targetType, String.format(\n\"Trailing token (of type %s) found after value (bound as %s): not allowed as per `DeserializationFeature.FAIL_ON_TRAILING_TOKENS`\",\ntrailingToken, ClassUtil.nameOf(targetType)\n                ));\n    }\n\n    @Deprecated \n    public void reportWrongTokenException(JsonParser p, JsonToken expToken, String msg, Object... msgArgs) throws JsonMappingException {\n        msg = _format(msg, msgArgs);\n        throw wrongTokenException(p, expToken, msg);\n    }\n    \n    \n    @Deprecated\n    public void reportUnknownProperty(Object instanceOrClass, String fieldName, JsonDeserializer<?> deser) throws JsonMappingException {\n        if (isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n            \n            Collection<Object> propIds = (deser == null) ? null : deser.getKnownPropertyNames();\n            throw UnrecognizedPropertyException.from(_parser,\n                    instanceOrClass, fieldName, propIds);\n        }\n    }\n\n    \n    @Deprecated \n    public void reportMissingContent(String msg, Object... msgArgs) throws JsonMappingException {\n        throw MismatchedInputException.from(getParser(), (JavaType) null, \"No content to map due to end-of-input\");\n    }\n\n    \n    \n    \n    public <T> T reportBadTypeDefinition(BeanDescription bean, String msg, Object... msgArgs) throws JsonMappingException {\n        msg = _format(msg, msgArgs);\n        String beanDesc = ClassUtil.nameOf(bean.getBeanClass());\n        msg = String.format(\"Invalid type definition for type %s: %s\", beanDesc, msg);\n        throw InvalidDefinitionException.from(_parser, msg, bean, null);\n    }\n\n    \n    public <T> T reportBadPropertyDefinition(BeanDescription bean, BeanPropertyDefinition prop, String msg, Object... msgArgs) throws JsonMappingException {\n        msg = _format(msg, msgArgs);\n        String propName = ClassUtil.nameOf(prop);\n        String beanDesc = ClassUtil.nameOf(bean.getBeanClass());\n        msg = String.format(\"Invalid definition for property %s (of type %s): %s\",\n                propName, beanDesc, msg);\n        throw InvalidDefinitionException.from(_parser, msg, bean, prop);\n    }\n\n    @Override\n    public <T> T reportBadDefinition(JavaType type, String msg) throws JsonMappingException {\n        throw InvalidDefinitionException.from(_parser, msg, type);\n    }\n\n    \n    public <T> T reportBadMerge(JsonDeserializer<?> deser) throws JsonMappingException {\n        if (isEnabled(MapperFeature.IGNORE_MERGE_FOR_UNMERGEABLE)) {\n            return null;\n        }\n        JavaType type = constructType(deser.handledType());\n        String msg = String.format(\"Invalid configuration: values of type %s cannot be merged\", type);\n        throw InvalidDefinitionException.from(getParser(), msg, type);\n    }\n\n    \n\n    \n    public JsonMappingException wrongTokenException(JsonParser p, JavaType targetType, JsonToken expToken, String extra) {\n        String msg = String.format(\"Unexpected token (%s), expected %s\",\n                p.getCurrentToken(), expToken);\n        msg = _colonConcat(msg, extra);\n        return MismatchedInputException.from(p, targetType, msg);\n    }\n\n    public JsonMappingException wrongTokenException(JsonParser p, Class<?> targetType, JsonToken expToken, String extra) {\n        String msg = String.format(\"Unexpected token (%s), expected %s\",\n                p.getCurrentToken(), expToken);\n        msg = _colonConcat(msg, extra);\n        return MismatchedInputException.from(p, targetType, msg);\n    }\n    \n    @Deprecated \n    public JsonMappingException wrongTokenException(JsonParser p, JsonToken expToken, String msg) {\n        return wrongTokenException(p, (JavaType) null, expToken, msg);\n    }\n\n    \n    public JsonMappingException weirdKeyException(Class<?> keyClass, String keyValue, String msg) {\n        return InvalidFormatException.from(_parser,\n                String.format(\"Cannot deserialize Map key of type %s from String %s: %s\",\n                        ClassUtil.nameOf(keyClass), _quotedString(keyValue), msg),\n                keyValue, keyClass);\n    }\n\n    \n    public JsonMappingException weirdStringException(String value, Class<?> instClass, String msg) {\n        return InvalidFormatException.from(_parser,\n                String.format(\"Cannot deserialize value of type %s from String %s: %s\",\n                        ClassUtil.nameOf(instClass), _quotedString(value), msg),\n                value, instClass);\n    }\n\n    \n    public JsonMappingException weirdNumberException(Number value, Class<?> instClass, String msg) {\n        return InvalidFormatException.from(_parser,\n                String.format(\"Cannot deserialize value of type %s from number %s: %s\",\n                        ClassUtil.nameOf(instClass), String.valueOf(value), msg),\n                value, instClass);\n    }\n\n    \n    public JsonMappingException weirdNativeValueException(Object value, Class<?> instClass) {\n        return InvalidFormatException.from(_parser, String.format(\n\"Cannot deserialize value of type %s from native value (`JsonToken.VALUE_EMBEDDED_OBJECT`) of type %s: incompatible types\", ClassUtil.nameOf(instClass), ClassUtil.classNameOf(value)), value, instClass); } public JsonMappingException instantiationException(Class<?> instClass, Throwable cause) {\n        \n        final JavaType type = constructType(instClass);\n        String excMsg;\n        if (cause == null) {\n            excMsg = \"N/A\";\n        } else if ((excMsg = cause.getMessage()) == null) {\n            excMsg = ClassUtil.nameOf(cause.getClass());\n        }\n        String msg = String.format(\"Cannot construct instance of %s, problem: %s\",\n                ClassUtil.nameOf(instClass), excMsg);\n        InvalidDefinitionException e = InvalidDefinitionException.from(_parser, msg, type);\n        e.initCause(cause);\n        return e;\n    }\n\n    \n    public JsonMappingException instantiationException(Class<?> instClass, String msg0) {\n        \n        JavaType type = constructType(instClass);\n        String msg = String.format(\"Cannot construct instance of %s: %s\",\n                ClassUtil.nameOf(instClass), msg0);\n        return InvalidDefinitionException.from(_parser, msg, type);\n    }\n\n    @Override\n    public JsonMappingException invalidTypeIdException(JavaType baseType, String typeId, String extraDesc) {\n        String msg = String.format(\"Could not resolve type id '%s' as a subtype of %s\",\n                typeId, baseType);\n        return InvalidTypeIdException.from(_parser, _colonConcat(msg, extraDesc), baseType, typeId);\n    }\n\n    \n    public JsonMappingException missingTypeIdException(JavaType baseType, String extraDesc) {\n        String msg = String.format(\"Missing type id when trying to resolve subtype of %s\",\n                baseType);\n        return InvalidTypeIdException.from(_parser, _colonConcat(msg, extraDesc), baseType, null);\n    }\n\n    \n\n    \n    @Deprecated\n    public JsonMappingException unknownTypeException(JavaType type, String id, String extraDesc) {\n        String msg = String.format(\"Could not resolve type id '%s' into a subtype of %s\",\n                id, type);\n        msg = _colonConcat(msg, extraDesc);\n        return MismatchedInputException.from(_parser, type, msg);\n    }\n\n    \n    @Deprecated\n    public JsonMappingException endOfInputException(Class<?> instClass) {\n        return MismatchedInputException.from(_parser, instClass,\n                \"Unexpected end-of-input when trying to deserialize a \"+instClass.getName());\n    }\n\n    \n    \n    \n    @Deprecated \n    public void reportMappingException(String msg, Object... msgArgs) throws JsonMappingException {\n        throw JsonMappingException.from(getParser(), _format(msg, msgArgs));\n    }\n\n    \n    @Deprecated\n    public JsonMappingException mappingException(String message) {\n        return JsonMappingException.from(getParser(), message);\n    }\n\n    \n    @Deprecated\n    public JsonMappingException mappingException(String msg, Object... msgArgs) {\n        return JsonMappingException.from(getParser(), _format(msg, msgArgs));\n    }\n\n    \n    @Deprecated\n    public JsonMappingException mappingException(Class<?> targetClass) {\n        return mappingException(targetClass, _parser.getCurrentToken());\n    }\n\n    \n    @Deprecated\n    public JsonMappingException mappingException(Class<?> targetClass, JsonToken token) {\n        return JsonMappingException.from(_parser,\n                String.format(\"Cannot deserialize instance of %s out of %s token\",\n                        ClassUtil.nameOf(targetClass), token));\n    }\n\n    \n\n    protected DateFormat getDateFormat() {\n        if (_dateFormat != null) {\n            return _dateFormat;\n        }\n        \n        DateFormat df = _config.getDateFormat();\n        _dateFormat = df = (DateFormat) df.clone();\n        return df;\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind;\n\nimport java.io.IOException;\nimport java.text.DateFormat;\nimport java.text.ParseException;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator;\nimport com.fasterxml.jackson.annotation.ObjectIdResolver;\n\nimport com.fasterxml.jackson.core.*;\n\nimport com.fasterxml.jackson.databind.cfg.ContextAttributes;\nimport com.fasterxml.jackson.databind.deser.*;\nimport com.fasterxml.jackson.databind.deser.impl.ObjectIdReader;\nimport com.fasterxml.jackson.databind.deser.impl.ReadableObjectId;\nimport com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer;\nimport com.fasterxml.jackson.databind.exc.MismatchedInputException;\nimport com.fasterxml.jackson.databind.exc.InvalidDefinitionException;\nimport com.fasterxml.jackson.databind.exc.InvalidFormatException;\nimport com.fasterxml.jackson.databind.exc.InvalidTypeIdException;\nimport com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;\nimport com.fasterxml.jackson.databind.introspect.Annotated;\nimport com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\nimport com.fasterxml.jackson.databind.node.JsonNodeFactory;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.*;\n\n\npublic abstract class DeserializationContext extends DatabindContext implements java.io.Serializable { private static final long serialVersionUID = 1L; protected final DeserializerCache _cache; protected final DeserializerFactory _factory; protected final DeserializationConfig _config; protected final int _featureFlags; protected final Class<?> _view; protected transient JsonParser _parser; protected final InjectableValues _injectableValues; protected transient ArrayBuilders _arrayBuilders; protected transient ObjectBuffer _objectBuffer; protected transient DateFormat _dateFormat; protected transient ContextAttributes _attributes; protected LinkedNode<JavaType> _currentType; protected DeserializationContext(DeserializerFactory df) {\n        this(df, null);\n    }\n    \n    protected DeserializationContext(DeserializerFactory df, DeserializerCache cache) {\n        if (df == null) {\n            throw new IllegalArgumentException(\"Cannot pass null DeserializerFactory\");\n        }\n        _factory = df;\n        if (cache == null) {\n            cache = new DeserializerCache();\n        }\n        _cache = cache;\n        _featureFlags = 0;\n        _config = null;\n        _injectableValues = null;\n        _view = null;\n        _attributes = null;\n    }\n\n    protected DeserializationContext(DeserializationContext src, DeserializerFactory factory) {\n        _cache = src._cache;\n        _factory = factory;\n        \n        _config = src._config;\n        _featureFlags = src._featureFlags;\n        _view = src._view;\n        _parser = src._parser;\n        _injectableValues = src._injectableValues;\n        _attributes = src._attributes;\n    }\n\n    \n    protected DeserializationContext(DeserializationContext src, DeserializationConfig config, JsonParser p, InjectableValues injectableValues) {\n        _cache = src._cache;\n        _factory = src._factory;\n        \n        _config = config;\n        _featureFlags = config.getDeserializationFeatures();\n        _view = config.getActiveView();\n        _parser = p;\n        _injectableValues = injectableValues;\n        _attributes = config.getAttributes();\n    }\n\n    \n    protected DeserializationContext(DeserializationContext src) {\n        _cache = new DeserializerCache();\n        _factory = src._factory;\n\n        _config = src._config;\n        _featureFlags = src._featureFlags;\n        _view = src._view;\n        _injectableValues = null;\n    }\n    \n    \n\n    @Override\n    public DeserializationConfig getConfig() { return _config; }\n\n    @Override\n    public final Class<?> getActiveView() { return _view; }\n\n    @Override\n    public final boolean canOverrideAccessModifiers() {\n        return _config.canOverrideAccessModifiers();\n    }\n\n    @Override\n    public final boolean isEnabled(MapperFeature feature) {\n        return _config.isEnabled(feature);\n    }\n\n    @Override\n    public final JsonFormat.Value getDefaultPropertyFormat(Class<?> baseType) {\n        return _config.getDefaultPropertyFormat(baseType);\n    }\n\n    @Override\n    public final AnnotationIntrospector getAnnotationIntrospector() {\n        return _config.getAnnotationIntrospector();\n    }\n\n    @Override\n    public final TypeFactory getTypeFactory() {\n        return _config.getTypeFactory();\n    }\n\n    \n    @Override\n    public Locale getLocale() {\n        return _config.getLocale();\n    }\n\n    \n    @Override\n    public TimeZone getTimeZone() {\n        return _config.getTimeZone();\n    }\n\n    \n\n    @Override\n    public Object getAttribute(Object key) {\n        return _attributes.getAttribute(key);\n    }\n\n    @Override\n    public DeserializationContext setAttribute(Object key, Object value) {\n        _attributes = _attributes.withPerCallAttribute(key, value);\n        return this;\n    }\n\n    \n    public JavaType getContextualType() {\n        return (_currentType == null) ? null : _currentType.value();\n    }\n\n    \n\n    \n    public DeserializerFactory getFactory() {\n        return _factory;\n    }\n    \n    \n    public final boolean isEnabled(DeserializationFeature feat) {\n        \n        return (_featureFlags & feat.getMask()) != 0;\n    }\n\n    \n    public final int getDeserializationFeatures() {\n        return _featureFlags;\n    }\n    \n    \n    public final boolean hasDeserializationFeatures(int featureMask) {\n        return (_featureFlags & featureMask) == featureMask;\n    }\n\n    \n    public final boolean hasSomeOfFeatures(int featureMask) {\n        return (_featureFlags & featureMask) != 0;\n    }\n    \n    \n    public final JsonParser getParser() { return _parser; }\n\n    public final Object findInjectableValue(Object valueId, BeanProperty forProperty, Object beanInstance) throws JsonMappingException {\n        if (_injectableValues == null) {\n            reportBadDefinition(ClassUtil.classOf(valueId), String.format(\n\"No 'injectableValues' configured, cannot inject value with id [%s]\", valueId));\n        }\n        return _injectableValues.findInjectableValue(valueId, this, forProperty, beanInstance);\n    }\n\n    \n    public final Base64Variant getBase64Variant() {\n        return _config.getBase64Variant();\n    }\n\n    \n    public final JsonNodeFactory getNodeFactory() {\n        return _config.getNodeFactory();\n    }\n\n    \n\n    \n    public boolean hasValueDeserializerFor(JavaType type, AtomicReference<Throwable> cause) {\n        try {\n            return _cache.hasValueDeserializerFor(this, _factory, type);\n        } catch (JsonMappingException e) {\n            if (cause != null) {\n                cause.set(e);\n            }\n        } catch (RuntimeException e) {\n            if (cause == null) { \n                throw e;\n            }\n            cause.set(e);\n        }\n        return false;\n    }\n    \n    \n    @SuppressWarnings(\"unchecked\")\n    public final JsonDeserializer<Object> findContextualValueDeserializer(JavaType type, BeanProperty prop) throws JsonMappingException {\n        JsonDeserializer<Object> deser = _cache.findValueDeserializer(this, _factory, type);\n        if (deser != null) {\n            deser = (JsonDeserializer<Object>) handleSecondaryContextualization(deser, prop, type);\n        }\n        return deser;\n    }\n\n    \n    public final JsonDeserializer<Object> findNonContextualValueDeserializer(JavaType type) throws JsonMappingException {\n        return _cache.findValueDeserializer(this, _factory, type);\n    }\n    \n    \n    @SuppressWarnings(\"unchecked\")\n    public final JsonDeserializer<Object> findRootValueDeserializer(JavaType type) throws JsonMappingException {\n        JsonDeserializer<Object> deser = _cache.findValueDeserializer(this,\n                _factory, type);\n        if (deser == null) { \n            return null;\n        }\n        deser = (JsonDeserializer<Object>) handleSecondaryContextualization(deser, null, type);\n        TypeDeserializer typeDeser = _factory.findTypeDeserializer(_config, type);\n        if (typeDeser != null) {\n            \n            typeDeser = typeDeser.forProperty(null);\n            return new TypeWrappedDeserializer(typeDeser, deser);\n        }\n        return deser;\n    }\n\n    \n    public final KeyDeserializer findKeyDeserializer(JavaType keyType, BeanProperty prop) throws JsonMappingException {\n        KeyDeserializer kd = _cache.findKeyDeserializer(this,\n                _factory, keyType);\n        \n        if (kd instanceof ContextualKeyDeserializer) {\n            kd = ((ContextualKeyDeserializer) kd).createContextual(this, prop);\n        }\n        return kd;\n    }\n    \n    \n\n    \n    public abstract ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> generator, ObjectIdResolver resolver); public abstract void checkUnresolvedObjectId() throws UnresolvedForwardReference; public final JavaType constructType(Class<?> cls) {\n        return (cls == null) ? null : _config.constructType(cls);\n    }\n\n    \n    public Class<?> findClass(String className) throws ClassNotFoundException {\n        \n        return getTypeFactory().findClass(className);\n    }\n\n    \n\n    \n    public final ObjectBuffer leaseObjectBuffer() {\n        ObjectBuffer buf = _objectBuffer;\n        if (buf == null) {\n            buf = new ObjectBuffer();\n        } else {\n            _objectBuffer = null;\n        }\n        return buf;\n    }\n\n    \n    public final void returnObjectBuffer(ObjectBuffer buf) {\n        \n        if (_objectBuffer == null\n            || buf.initialCapacity() >= _objectBuffer.initialCapacity()) {\n            _objectBuffer = buf;\n        }\n    }\n\n    \n    public final ArrayBuilders getArrayBuilders() {\n        if (_arrayBuilders == null) {\n            _arrayBuilders = new ArrayBuilders();\n        }\n        return _arrayBuilders;\n    }\n\n    \n\n    public abstract JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException; public abstract KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException; public JsonDeserializer<?> handlePrimaryContextualization(JsonDeserializer<?> deser, BeanProperty prop, JavaType type) throws JsonMappingException {\n        if (deser instanceof ContextualDeserializer) {\n            _currentType = new LinkedNode<JavaType>(type, _currentType);\n            try {\n                deser = ((ContextualDeserializer) deser).createContextual(this, prop);\n            } finally {\n                _currentType = _currentType.next();\n            }\n        }\n        return deser;\n    }\n\n    \n    public JsonDeserializer<?> handleSecondaryContextualization(JsonDeserializer<?> deser, BeanProperty prop, JavaType type) throws JsonMappingException {\n        if (deser instanceof ContextualDeserializer) {\n            _currentType = new LinkedNode<JavaType>(type, _currentType);\n            try {\n                deser = ((ContextualDeserializer) deser).createContextual(this, prop);\n            } finally {\n                _currentType = _currentType.next();\n            }\n        }\n        return deser;\n    }\n\n    \n\n    \n    public Date parseDate(String dateStr) throws IllegalArgumentException {\n        try {\n            DateFormat df = getDateFormat();\n            return df.parse(dateStr);\n        } catch (ParseException e) {\n            throw new IllegalArgumentException(String.format(\n                    \"Failed to parse Date value '%s': %s\", dateStr,\n                    ClassUtil.exceptionMessage(e)));\n        }\n    }\n\n    \n    public Calendar constructCalendar(Date d) {\n        \n        Calendar c = Calendar.getInstance(getTimeZone());\n        c.setTime(d);\n        return c;\n    }\n\n    \n\n    \n    public <T> T readValue(JsonParser p, Class<T> type) throws IOException {\n        return readValue(p, getTypeFactory().constructType(type));\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser p, JavaType type) throws IOException {\n        JsonDeserializer<Object> deser = findRootValueDeserializer(type);\n        if (deser == null) {\n            reportBadDefinition(type,\n                    \"Could not find JsonDeserializer for type \"+type);\n        }\n        return (T) deser.deserialize(p, this);\n    }\n\n    \n    public <T> T readPropertyValue(JsonParser p, BeanProperty prop, Class<T> type) throws IOException {\n        return readPropertyValue(p, prop, getTypeFactory().constructType(type));\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readPropertyValue(JsonParser p, BeanProperty prop, JavaType type) throws IOException {\n        JsonDeserializer<Object> deser = findContextualValueDeserializer(type, prop);\n        if (deser == null) {\n            return reportBadDefinition(type, String.format(\n                    \"Could not find JsonDeserializer for type %s (via property %s)\",\n                    type, ClassUtil.nameOf(prop)));\n        }\n        return (T) deser.deserialize(p, this);\n    }\n\n    \n\n    \n    public boolean handleUnknownProperty(JsonParser p, JsonDeserializer<?> deser, Object instanceOrClass, String propName) throws IOException {\n        LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();\n        while (h != null) {\n            \n            if (h.value().handleUnknownProperty(this, p, deser, instanceOrClass, propName)) {\n                return true;\n            }\n            h = h.next();\n        }\n        \n        if (!isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n            p.skipChildren();\n            return true;\n        }\n        \n        Collection<Object> propIds = (deser == null) ? null : deser.getKnownPropertyNames();\n        throw UnrecognizedPropertyException.from(_parser,\n                instanceOrClass, propName, propIds);\n    }\n\n    \n    public Object handleWeirdKey(Class<?> keyClass, String keyValue, String msg, Object... msgArgs) throws IOException {\n        \n        msg = _format(msg, msgArgs);\n        LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();\n        while (h != null) {\n            \n            Object key = h.value().handleWeirdKey(this, keyClass, keyValue, msg);\n            if (key != DeserializationProblemHandler.NOT_HANDLED) {\n                \n                if ((key == null) || keyClass.isInstance(key)) {\n                    return key;\n                }\n                throw weirdStringException(keyValue, keyClass, String.format(\n                        \"DeserializationProblemHandler.handleWeirdStringValue() for type %s returned value of type %s\",\n                        keyClass, key.getClass()));\n            }\n            h = h.next();\n        }\n        throw weirdKeyException(keyClass, keyValue, msg);\n    }\n\n    \n    public Object handleWeirdStringValue(Class<?> targetClass, String value, String msg, Object... msgArgs) throws IOException {\n        \n        msg = _format(msg, msgArgs);\n        LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();\n        while (h != null) {\n            \n            Object instance = h.value().handleWeirdStringValue(this, targetClass, value, msg);\n            if (instance != DeserializationProblemHandler.NOT_HANDLED) {\n                \n                if (_isCompatible(targetClass, instance)) {\n                    return instance;\n                }\n                throw weirdStringException(value, targetClass, String.format(\n                        \"DeserializationProblemHandler.handleWeirdStringValue() for type %s returned value of type %s\",\n                        targetClass, instance.getClass()));\n            }\n            h = h.next();\n        }\n        throw weirdStringException(value, targetClass, msg);\n    }\n\n    \n    public Object handleWeirdNumberValue(Class<?> targetClass, Number value, String msg, Object... msgArgs) throws IOException {\n        msg = _format(msg, msgArgs);\n        LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();\n        while (h != null) {\n            \n            Object key = h.value().handleWeirdNumberValue(this, targetClass, value, msg);\n            if (key != DeserializationProblemHandler.NOT_HANDLED) {\n                \n                if (_isCompatible(targetClass, key)) {\n                    return key;\n                }\n                throw weirdNumberException(value, targetClass, _format(\n                        \"DeserializationProblemHandler.handleWeirdNumberValue() for type %s returned value of type %s\",\n                        targetClass, key.getClass()));\n            }\n            h = h.next();\n        }\n        throw weirdNumberException(value, targetClass, msg);\n    }\n\n    public Object handleWeirdNativeValue(JavaType targetType, Object badValue, JsonParser p) throws IOException {\n        LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();\n        final Class<?> raw = targetType.getRawClass();\n        for (; h != null; h = h.next()) {\n            \n            Object goodValue = h.value().handleWeirdNativeValue(this, targetType, badValue, p);\n            if (goodValue != DeserializationProblemHandler.NOT_HANDLED) {\n                \n                if ((goodValue == null) || raw.isInstance(goodValue)) {\n                    return goodValue;\n                }\n                throw JsonMappingException.from(p, _format(\n\"DeserializationProblemHandler.handleWeirdNativeValue() for type %s returned value of type %s\",\ntargetType, goodValue.getClass()));\n            }\n        }\n        throw weirdNativeValueException(badValue, raw);\n    }\n\n    \n    @SuppressWarnings(\"resource\")\n    public Object handleMissingInstantiator(Class<?> instClass, ValueInstantiator valueInst, JsonParser p, String msg, Object... msgArgs) throws IOException {\n        if (p == null) {\n            p = getParser();\n        }\n        msg = _format(msg, msgArgs);\n        LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();\n        while (h != null) {\n            \n            Object instance = h.value().handleMissingInstantiator(this,\n                    instClass, valueInst, p, msg);\n            if (instance != DeserializationProblemHandler.NOT_HANDLED) {\n                \n                if (_isCompatible(instClass, instance)) {\n                    return instance;\n                }\n                reportBadDefinition(constructType(instClass), String.format(\n\"DeserializationProblemHandler.handleMissingInstantiator() for type %s returned value of type %s\",\n                        instClass, ClassUtil.classNameOf(instance)));\n            }\n            h = h.next();\n        }\n\n        \n        \n        \n        if ((valueInst != null) && !valueInst.canInstantiate()) {\n            msg = String.format(\"Cannot construct instance of %s (no Creators, like default construct, exist): %s\",\n                    ClassUtil.nameOf(instClass), msg);\n            return reportBadDefinition(constructType(instClass), msg);\n        }\n        msg = String.format(\"Cannot construct instance of %s (although at least one Creator exists): %s\",\n                ClassUtil.nameOf(instClass), msg);\n        return reportInputMismatch(instClass, msg);\n    }\n\n    \n    public Object handleInstantiationProblem(Class<?> instClass, Object argument, Throwable t) throws IOException {\n        LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();\n        while (h != null) {\n            \n            Object instance = h.value().handleInstantiationProblem(this, instClass, argument, t);\n            if (instance != DeserializationProblemHandler.NOT_HANDLED) {\n                \n                if (_isCompatible(instClass, instance)) {\n                    return instance;\n                }\n                reportBadDefinition(constructType(instClass), String.format(\n\"DeserializationProblemHandler.handleInstantiationProblem() for type %s returned value of type %s\",\n                        instClass, ClassUtil.classNameOf(instance)));\n            }\n            h = h.next();\n        }\n        \n        ClassUtil.throwIfIOE(t);\n        throw instantiationException(instClass, t);\n    }\n\n    \n    public Object handleUnexpectedToken(Class<?> instClass, JsonParser p) throws IOException {\n        return handleUnexpectedToken(instClass, p.getCurrentToken(), p, null);\n    }\n\n    \n    public Object handleUnexpectedToken(Class<?> instClass, JsonToken t, JsonParser p, String msg, Object... msgArgs) throws IOException {\n        msg = _format(msg, msgArgs);\n        LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();\n        while (h != null) {\n            Object instance = h.value().handleUnexpectedToken(this,\n                    instClass, t, p, msg);\n            if (instance != DeserializationProblemHandler.NOT_HANDLED) {\n                if (_isCompatible(instClass, instance)) {\n                    return instance;\n                }\n                reportBadDefinition(constructType(instClass), String.format(\n                        \"DeserializationProblemHandler.handleUnexpectedToken() for type %s returned value of type %s\",\n                        ClassUtil.nameOf(instClass), ClassUtil.classNameOf(instance)));\n            }\n            h = h.next();\n        }\n        if (msg == null) {\n            if (t == null) {\n                msg = String.format(\"Unexpected end-of-input when binding data into %s\",\n                        ClassUtil.nameOf(instClass));\n            } else {\n                msg = String.format(\"Cannot deserialize instance of %s out of %s token\",\n                        ClassUtil.nameOf(instClass), t);\n            }\n        }\n        reportInputMismatch(instClass, msg);\n        return null; \n    }\n\n    \n    public JavaType handleUnknownTypeId(JavaType baseType, String id, TypeIdResolver idResolver, String extraDesc) throws IOException {\n        LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();\n        while (h != null) {\n            \n            JavaType type = h.value().handleUnknownTypeId(this, baseType, id, idResolver, extraDesc);\n            if (type != null) {\n                if (type.hasRawClass(Void.class)) {\n                    return null;\n                }\n                \n                if (type.isTypeOrSubTypeOf(baseType.getRawClass())) {\n                    return type;\n                }\n                throw invalidTypeIdException(baseType, id,\n                        \"problem handler tried to resolve into non-subtype: \"+type);\n            }\n            h = h.next();\n        }\n        \n        if (!isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) {\n            return null;\n        }\n        throw invalidTypeIdException(baseType, id, extraDesc);\n    }\n\n    \n    public JavaType handleMissingTypeId(JavaType baseType, TypeIdResolver idResolver, String extraDesc) throws IOException {\n        LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();\n        while (h != null) {\n            \n            JavaType type = h.value().handleMissingTypeId(this, baseType, idResolver, extraDesc);\n            if (type != null) {\n                if (type.hasRawClass(Void.class)) {\n                    return null;\n                }\n                \n                if (type.isTypeOrSubTypeOf(baseType.getRawClass())) {\n                    return type;\n                }\n                throw invalidTypeIdException(baseType, null,\n                        \"problem handler tried to resolve into non-subtype: \"+type);\n            }\n            h = h.next();\n        }\n        \n        \n\n\n\n        throw missingTypeIdException(baseType, extraDesc);\n    }\n\n    \n    protected boolean _isCompatible(Class<?> target, Object value) {\n        if ((value == null) || target.isInstance(value)) {\n            return true;\n        }\n        \n        return target.isPrimitive()\n                && ClassUtil.wrapperType(target).isInstance(value);\n    }\n\n    \n\n    \n    public void reportWrongTokenException(JsonDeserializer<?> deser, JsonToken expToken, String msg, Object... msgArgs) throws JsonMappingException {\n        msg = _format(msg, msgArgs);\n        throw wrongTokenException(getParser(), deser.handledType(), expToken, msg);\n    }\n    \n    \n    public void reportWrongTokenException(JavaType targetType, JsonToken expToken, String msg, Object... msgArgs) throws JsonMappingException {\n        msg = _format(msg, msgArgs);\n        throw wrongTokenException(getParser(), targetType, expToken, msg);\n    }\n\n    \n    public void reportWrongTokenException(Class<?> targetType, JsonToken expToken, String msg, Object... msgArgs) throws JsonMappingException {\n        msg = _format(msg, msgArgs);\n        throw wrongTokenException(getParser(), targetType, expToken, msg);\n    }\n\n    \n    public <T> T reportUnresolvedObjectId(ObjectIdReader oidReader, Object bean) throws JsonMappingException {\n        String msg = String.format(\"No Object Id found for an instance of %s, to assign to property '%s'\",\n                ClassUtil.classNameOf(bean), oidReader.propertyName);\n        return reportInputMismatch(oidReader.idProperty, msg);\n    }\n\n    \n    public <T> T reportInputMismatch(BeanProperty prop, String msg, Object... msgArgs) throws JsonMappingException {\n        msg = _format(msg, msgArgs);\n        JavaType type = (prop == null) ? null : prop.getType();\n        throw MismatchedInputException.from(getParser(), type, msg);\n    }\n\n    \n    public <T> T reportInputMismatch(JsonDeserializer<?> src, String msg, Object... msgArgs) throws JsonMappingException {\n        msg = _format(msg, msgArgs);\n        throw MismatchedInputException.from(getParser(), src.handledType(), msg);\n    }\n\n    \n    public <T> T reportInputMismatch(Class<?> targetType, String msg, Object... msgArgs) throws JsonMappingException {\n        msg = _format(msg, msgArgs);\n        throw MismatchedInputException.from(getParser(), targetType, msg);\n    }\n\n    \n    public <T> T reportInputMismatch(JavaType targetType, String msg, Object... msgArgs) throws JsonMappingException {\n        msg = _format(msg, msgArgs);\n        throw MismatchedInputException.from(getParser(), targetType, msg);\n    }\n\n    public <T> T reportTrailingTokens(Class<?> targetType, JsonParser p, JsonToken trailingToken) throws JsonMappingException {\n        throw MismatchedInputException.from(p, targetType, String.format(\n\"Trailing token (of type %s) found after value (bound as %s): not allowed as per `DeserializationFeature.FAIL_ON_TRAILING_TOKENS`\",\ntrailingToken, ClassUtil.nameOf(targetType)\n                ));\n    }\n\n    @Deprecated \n    public void reportWrongTokenException(JsonParser p, JsonToken expToken, String msg, Object... msgArgs) throws JsonMappingException {\n        msg = _format(msg, msgArgs);\n        throw wrongTokenException(p, expToken, msg);\n    }\n    \n    \n    @Deprecated\n    public void reportUnknownProperty(Object instanceOrClass, String fieldName, JsonDeserializer<?> deser) throws JsonMappingException {\n        if (isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n            \n            Collection<Object> propIds = (deser == null) ? null : deser.getKnownPropertyNames();\n            throw UnrecognizedPropertyException.from(_parser,\n                    instanceOrClass, fieldName, propIds);\n        }\n    }\n\n    \n    @Deprecated \n    public void reportMissingContent(String msg, Object... msgArgs) throws JsonMappingException {\n        throw MismatchedInputException.from(getParser(), (JavaType) null, \"No content to map due to end-of-input\");\n    }\n\n    \n    \n    \n    public <T> T reportBadTypeDefinition(BeanDescription bean, String msg, Object... msgArgs) throws JsonMappingException {\n        msg = _format(msg, msgArgs);\n        String beanDesc = ClassUtil.nameOf(bean.getBeanClass());\n        msg = String.format(\"Invalid type definition for type %s: %s\", beanDesc, msg);\n        throw InvalidDefinitionException.from(_parser, msg, bean, null);\n    }\n\n    \n    public <T> T reportBadPropertyDefinition(BeanDescription bean, BeanPropertyDefinition prop, String msg, Object... msgArgs) throws JsonMappingException {\n        msg = _format(msg, msgArgs);\n        String propName = ClassUtil.nameOf(prop);\n        String beanDesc = ClassUtil.nameOf(bean.getBeanClass());\n        msg = String.format(\"Invalid definition for property %s (of type %s): %s\",\n                propName, beanDesc, msg);\n        throw InvalidDefinitionException.from(_parser, msg, bean, prop);\n    }\n\n    @Override\n    public <T> T reportBadDefinition(JavaType type, String msg) throws JsonMappingException {\n        throw InvalidDefinitionException.from(_parser, msg, type);\n    }\n\n    \n    public <T> T reportBadMerge(JsonDeserializer<?> deser) throws JsonMappingException {\n        if (isEnabled(MapperFeature.IGNORE_MERGE_FOR_UNMERGEABLE)) {\n            return null;\n        }\n        JavaType type = constructType(deser.handledType());\n        String msg = String.format(\"Invalid configuration: values of type %s cannot be merged\", type);\n        throw InvalidDefinitionException.from(getParser(), msg, type);\n    }\n\n    \n\n    \n    public JsonMappingException wrongTokenException(JsonParser p, JavaType targetType, JsonToken expToken, String extra) {\n        String msg = String.format(\"Unexpected token (%s), expected %s\",\n                p.getCurrentToken(), expToken);\n        msg = _colonConcat(msg, extra);\n        return MismatchedInputException.from(p, targetType, msg);\n    }\n\n    public JsonMappingException wrongTokenException(JsonParser p, Class<?> targetType, JsonToken expToken, String extra) {\n        String msg = String.format(\"Unexpected token (%s), expected %s\",\n                p.getCurrentToken(), expToken);\n        msg = _colonConcat(msg, extra);\n        return MismatchedInputException.from(p, targetType, msg);\n    }\n    \n    @Deprecated \n    public JsonMappingException wrongTokenException(JsonParser p, JsonToken expToken, String msg) {\n        return wrongTokenException(p, (JavaType) null, expToken, msg);\n    }\n\n    \n    public JsonMappingException weirdKeyException(Class<?> keyClass, String keyValue, String msg) {\n        return InvalidFormatException.from(_parser,\n                String.format(\"Cannot deserialize Map key of type %s from String %s: %s\",\n                        ClassUtil.nameOf(keyClass), _quotedString(keyValue), msg),\n                keyValue, keyClass);\n    }\n\n    \n    public JsonMappingException weirdStringException(String value, Class<?> instClass, String msg) {\n        return InvalidFormatException.from(_parser,\n                String.format(\"Cannot deserialize value of type %s from String %s: %s\",\n                        ClassUtil.nameOf(instClass), _quotedString(value), msg),\n                value, instClass);\n    }\n\n    \n    public JsonMappingException weirdNumberException(Number value, Class<?> instClass, String msg) {\n        return InvalidFormatException.from(_parser,\n                String.format(\"Cannot deserialize value of type %s from number %s: %s\",\n                        ClassUtil.nameOf(instClass), String.valueOf(value), msg),\n                value, instClass);\n    }\n\n    \n    public JsonMappingException weirdNativeValueException(Object value, Class<?> instClass) {\n        return InvalidFormatException.from(_parser, String.format(\n\"Cannot deserialize value of type %s from native value (`JsonToken.VALUE_EMBEDDED_OBJECT`) of type %s: incompatible types\", ClassUtil.nameOf(instClass), ClassUtil.classNameOf(value)), value, instClass); } public JsonMappingException instantiationException(Class<?> instClass, Throwable cause) {\n        \n        final JavaType type = constructType(instClass);\n        String excMsg;\n        if (cause == null) {\n            excMsg = \"N/A\";\n        } else if ((excMsg = ClassUtil.exceptionMessage(cause)) == null) {\n            excMsg = ClassUtil.nameOf(cause.getClass());\n        }\n        String msg = String.format(\"Cannot construct instance of %s, problem: %s\",\n                ClassUtil.nameOf(instClass), excMsg);\n        InvalidDefinitionException e = InvalidDefinitionException.from(_parser, msg, type);\n        e.initCause(cause);\n        return e;\n    }\n\n    \n    public JsonMappingException instantiationException(Class<?> instClass, String msg0) {\n        \n        JavaType type = constructType(instClass);\n        String msg = String.format(\"Cannot construct instance of %s: %s\",\n                ClassUtil.nameOf(instClass), msg0);\n        return InvalidDefinitionException.from(_parser, msg, type);\n    }\n\n    @Override\n    public JsonMappingException invalidTypeIdException(JavaType baseType, String typeId, String extraDesc) {\n        String msg = String.format(\"Could not resolve type id '%s' as a subtype of %s\",\n                typeId, baseType);\n        return InvalidTypeIdException.from(_parser, _colonConcat(msg, extraDesc), baseType, typeId);\n    }\n\n    \n    public JsonMappingException missingTypeIdException(JavaType baseType, String extraDesc) {\n        String msg = String.format(\"Missing type id when trying to resolve subtype of %s\",\n                baseType);\n        return InvalidTypeIdException.from(_parser, _colonConcat(msg, extraDesc), baseType, null);\n    }\n\n    \n\n    \n    @Deprecated\n    public JsonMappingException unknownTypeException(JavaType type, String id, String extraDesc) {\n        String msg = String.format(\"Could not resolve type id '%s' into a subtype of %s\",\n                id, type);\n        msg = _colonConcat(msg, extraDesc);\n        return MismatchedInputException.from(_parser, type, msg);\n    }\n\n    \n    @Deprecated\n    public JsonMappingException endOfInputException(Class<?> instClass) {\n        return MismatchedInputException.from(_parser, instClass,\n                \"Unexpected end-of-input when trying to deserialize a \"+instClass.getName());\n    }\n\n    \n    \n    \n    @Deprecated \n    public void reportMappingException(String msg, Object... msgArgs) throws JsonMappingException {\n        throw JsonMappingException.from(getParser(), _format(msg, msgArgs));\n    }\n\n    \n    @Deprecated\n    public JsonMappingException mappingException(String message) {\n        return JsonMappingException.from(getParser(), message);\n    }\n\n    \n    @Deprecated\n    public JsonMappingException mappingException(String msg, Object... msgArgs) {\n        return JsonMappingException.from(getParser(), _format(msg, msgArgs));\n    }\n\n    \n    @Deprecated\n    public JsonMappingException mappingException(Class<?> targetClass) {\n        return mappingException(targetClass, _parser.getCurrentToken());\n    }\n\n    \n    @Deprecated\n    public JsonMappingException mappingException(Class<?> targetClass, JsonToken token) {\n        return JsonMappingException.from(_parser,\n                String.format(\"Cannot deserialize instance of %s out of %s token\",\n                        ClassUtil.nameOf(targetClass), token));\n    }\n\n    \n\n    protected DateFormat getDateFormat() {\n        if (_dateFormat != null) {\n            return _dateFormat;\n        }\n        \n        DateFormat df = _config.getDateFormat();\n        _dateFormat = df = (DateFormat) df.clone();\n        return df;\n    }\n}\n",
      "buggy_signatures": [
        "protected DeserializationContext(DeserializerFactory df, DeserializerCache cache)",
        "protected DeserializationContext(DeserializationContext src, DeserializerFactory factory)",
        "protected DeserializationContext(DeserializationContext src, DeserializationConfig config, JsonParser p, InjectableValues injectableValues)",
        "protected DeserializationContext(DeserializationContext src)",
        "public DeserializationConfig getConfig()",
        "public final Class<?> getActiveView()",
        "public final boolean canOverrideAccessModifiers()",
        "public final boolean isEnabled(MapperFeature feature)",
        "public final JsonFormat.Value getDefaultPropertyFormat(Class<?> baseType)",
        "public final AnnotationIntrospector getAnnotationIntrospector()",
        "public final TypeFactory getTypeFactory()",
        "public Locale getLocale()",
        "public TimeZone getTimeZone()",
        "public Object getAttribute(Object key)",
        "public DeserializationContext setAttribute(Object key, Object value)",
        "public JavaType getContextualType()",
        "public DeserializerFactory getFactory()",
        "public final boolean isEnabled(DeserializationFeature feat)",
        "public final int getDeserializationFeatures()",
        "public final boolean hasDeserializationFeatures(int featureMask)",
        "public final boolean hasSomeOfFeatures(int featureMask)",
        "public final JsonParser getParser()",
        "public final Object findInjectableValue(Object valueId, BeanProperty forProperty, Object beanInstance) throws JsonMappingException",
        "public final Base64Variant getBase64Variant()",
        "public final JsonNodeFactory getNodeFactory()",
        "public boolean hasValueDeserializerFor(JavaType type, AtomicReference<Throwable> cause)",
        "public final JsonDeserializer<Object> findContextualValueDeserializer(JavaType type, BeanProperty prop) throws JsonMappingException",
        "public final JsonDeserializer<Object> findNonContextualValueDeserializer(JavaType type) throws JsonMappingException",
        "public final JsonDeserializer<Object> findRootValueDeserializer(JavaType type) throws JsonMappingException",
        "public final KeyDeserializer findKeyDeserializer(JavaType keyType, BeanProperty prop) throws JsonMappingException",
        "public abstract ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> generator, ObjectIdResolver resolver); public abstract void checkUnresolvedObjectId() throws UnresolvedForwardReference; public final JavaType constructType(Class<?> cls)",
        "public Class<?> findClass(String className) throws ClassNotFoundException",
        "public final ObjectBuffer leaseObjectBuffer()",
        "public final void returnObjectBuffer(ObjectBuffer buf)",
        "public final ArrayBuilders getArrayBuilders()",
        "public abstract JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException; public abstract KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException; public JsonDeserializer<?> handlePrimaryContextualization(JsonDeserializer<?> deser, BeanProperty prop, JavaType type) throws JsonMappingException",
        "public JsonDeserializer<?> handleSecondaryContextualization(JsonDeserializer<?> deser, BeanProperty prop, JavaType type) throws JsonMappingException",
        "public Date parseDate(String dateStr) throws IllegalArgumentException",
        "public Calendar constructCalendar(Date d)",
        "public <T> T readValue(JsonParser p, Class<T> type) throws IOException",
        "public <T> T readValue(JsonParser p, JavaType type) throws IOException",
        "public <T> T readPropertyValue(JsonParser p, BeanProperty prop, Class<T> type) throws IOException",
        "public <T> T readPropertyValue(JsonParser p, BeanProperty prop, JavaType type) throws IOException",
        "public boolean handleUnknownProperty(JsonParser p, JsonDeserializer<?> deser, Object instanceOrClass, String propName) throws IOException",
        "public Object handleWeirdKey(Class<?> keyClass, String keyValue, String msg, Object... msgArgs) throws IOException",
        "public Object handleWeirdStringValue(Class<?> targetClass, String value, String msg, Object... msgArgs) throws IOException",
        "public Object handleWeirdNumberValue(Class<?> targetClass, Number value, String msg, Object... msgArgs) throws IOException",
        "public Object handleWeirdNativeValue(JavaType targetType, Object badValue, JsonParser p) throws IOException",
        "public Object handleMissingInstantiator(Class<?> instClass, ValueInstantiator valueInst, JsonParser p, String msg, Object... msgArgs) throws IOException",
        "public Object handleInstantiationProblem(Class<?> instClass, Object argument, Throwable t) throws IOException",
        "public Object handleUnexpectedToken(Class<?> instClass, JsonParser p) throws IOException",
        "public Object handleUnexpectedToken(Class<?> instClass, JsonToken t, JsonParser p, String msg, Object... msgArgs) throws IOException",
        "public JavaType handleUnknownTypeId(JavaType baseType, String id, TypeIdResolver idResolver, String extraDesc) throws IOException",
        "public JavaType handleMissingTypeId(JavaType baseType, TypeIdResolver idResolver, String extraDesc) throws IOException",
        "protected boolean _isCompatible(Class<?> target, Object value)",
        "public void reportWrongTokenException(JsonDeserializer<?> deser, JsonToken expToken, String msg, Object... msgArgs) throws JsonMappingException",
        "public void reportWrongTokenException(JavaType targetType, JsonToken expToken, String msg, Object... msgArgs) throws JsonMappingException",
        "public void reportWrongTokenException(Class<?> targetType, JsonToken expToken, String msg, Object... msgArgs) throws JsonMappingException",
        "public <T> T reportUnresolvedObjectId(ObjectIdReader oidReader, Object bean) throws JsonMappingException",
        "public <T> T reportInputMismatch(BeanProperty prop, String msg, Object... msgArgs) throws JsonMappingException",
        "public <T> T reportInputMismatch(JsonDeserializer<?> src, String msg, Object... msgArgs) throws JsonMappingException",
        "public <T> T reportInputMismatch(Class<?> targetType, String msg, Object... msgArgs) throws JsonMappingException",
        "public <T> T reportInputMismatch(JavaType targetType, String msg, Object... msgArgs) throws JsonMappingException",
        "public <T> T reportTrailingTokens(Class<?> targetType, JsonParser p, JsonToken trailingToken) throws JsonMappingException",
        "public void reportWrongTokenException(JsonParser p, JsonToken expToken, String msg, Object... msgArgs) throws JsonMappingException",
        "public void reportUnknownProperty(Object instanceOrClass, String fieldName, JsonDeserializer<?> deser) throws JsonMappingException",
        "public void reportMissingContent(String msg, Object... msgArgs) throws JsonMappingException",
        "public <T> T reportBadTypeDefinition(BeanDescription bean, String msg, Object... msgArgs) throws JsonMappingException",
        "public <T> T reportBadPropertyDefinition(BeanDescription bean, BeanPropertyDefinition prop, String msg, Object... msgArgs) throws JsonMappingException",
        "public <T> T reportBadDefinition(JavaType type, String msg) throws JsonMappingException",
        "public <T> T reportBadMerge(JsonDeserializer<?> deser) throws JsonMappingException",
        "public JsonMappingException wrongTokenException(JsonParser p, JavaType targetType, JsonToken expToken, String extra)",
        "public JsonMappingException wrongTokenException(JsonParser p, Class<?> targetType, JsonToken expToken, String extra)",
        "public JsonMappingException wrongTokenException(JsonParser p, JsonToken expToken, String msg)",
        "public JsonMappingException weirdKeyException(Class<?> keyClass, String keyValue, String msg)",
        "public JsonMappingException weirdStringException(String value, Class<?> instClass, String msg)",
        "public JsonMappingException weirdNumberException(Number value, Class<?> instClass, String msg)",
        "public JsonMappingException weirdNativeValueException(Object value, Class<?> instClass)",
        "native value (`JsonToken.VALUE_EMBEDDED_OBJECT`) of type %s: incompatible types\", ClassUtil.nameOf(instClass), ClassUtil.classNameOf(value)), value, instClass); } public JsonMappingException instantiationException(Class<?> instClass, Throwable cause)",
        "public JsonMappingException instantiationException(Class<?> instClass, String msg0)",
        "public JsonMappingException invalidTypeIdException(JavaType baseType, String typeId, String extraDesc)",
        "public JsonMappingException missingTypeIdException(JavaType baseType, String extraDesc)",
        "public JsonMappingException unknownTypeException(JavaType type, String id, String extraDesc)",
        "public JsonMappingException endOfInputException(Class<?> instClass)",
        "public void reportMappingException(String msg, Object... msgArgs) throws JsonMappingException",
        "public JsonMappingException mappingException(String message)",
        "public JsonMappingException mappingException(String msg, Object... msgArgs)",
        "public JsonMappingException mappingException(Class<?> targetClass)",
        "public JsonMappingException mappingException(Class<?> targetClass, JsonToken token)",
        "protected DateFormat getDateFormat()"
      ],
      "fixed_signatures": [
        "protected DeserializationContext(DeserializerFactory df, DeserializerCache cache)",
        "protected DeserializationContext(DeserializationContext src, DeserializerFactory factory)",
        "protected DeserializationContext(DeserializationContext src, DeserializationConfig config, JsonParser p, InjectableValues injectableValues)",
        "protected DeserializationContext(DeserializationContext src)",
        "public DeserializationConfig getConfig()",
        "public final Class<?> getActiveView()",
        "public final boolean canOverrideAccessModifiers()",
        "public final boolean isEnabled(MapperFeature feature)",
        "public final JsonFormat.Value getDefaultPropertyFormat(Class<?> baseType)",
        "public final AnnotationIntrospector getAnnotationIntrospector()",
        "public final TypeFactory getTypeFactory()",
        "public Locale getLocale()",
        "public TimeZone getTimeZone()",
        "public Object getAttribute(Object key)",
        "public DeserializationContext setAttribute(Object key, Object value)",
        "public JavaType getContextualType()",
        "public DeserializerFactory getFactory()",
        "public final boolean isEnabled(DeserializationFeature feat)",
        "public final int getDeserializationFeatures()",
        "public final boolean hasDeserializationFeatures(int featureMask)",
        "public final boolean hasSomeOfFeatures(int featureMask)",
        "public final JsonParser getParser()",
        "public final Object findInjectableValue(Object valueId, BeanProperty forProperty, Object beanInstance) throws JsonMappingException",
        "public final Base64Variant getBase64Variant()",
        "public final JsonNodeFactory getNodeFactory()",
        "public boolean hasValueDeserializerFor(JavaType type, AtomicReference<Throwable> cause)",
        "public final JsonDeserializer<Object> findContextualValueDeserializer(JavaType type, BeanProperty prop) throws JsonMappingException",
        "public final JsonDeserializer<Object> findNonContextualValueDeserializer(JavaType type) throws JsonMappingException",
        "public final JsonDeserializer<Object> findRootValueDeserializer(JavaType type) throws JsonMappingException",
        "public final KeyDeserializer findKeyDeserializer(JavaType keyType, BeanProperty prop) throws JsonMappingException",
        "public abstract ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> generator, ObjectIdResolver resolver); public abstract void checkUnresolvedObjectId() throws UnresolvedForwardReference; public final JavaType constructType(Class<?> cls)",
        "public Class<?> findClass(String className) throws ClassNotFoundException",
        "public final ObjectBuffer leaseObjectBuffer()",
        "public final void returnObjectBuffer(ObjectBuffer buf)",
        "public final ArrayBuilders getArrayBuilders()",
        "public abstract JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException; public abstract KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException; public JsonDeserializer<?> handlePrimaryContextualization(JsonDeserializer<?> deser, BeanProperty prop, JavaType type) throws JsonMappingException",
        "public JsonDeserializer<?> handleSecondaryContextualization(JsonDeserializer<?> deser, BeanProperty prop, JavaType type) throws JsonMappingException",
        "public Date parseDate(String dateStr) throws IllegalArgumentException",
        "public Calendar constructCalendar(Date d)",
        "public <T> T readValue(JsonParser p, Class<T> type) throws IOException",
        "public <T> T readValue(JsonParser p, JavaType type) throws IOException",
        "public <T> T readPropertyValue(JsonParser p, BeanProperty prop, Class<T> type) throws IOException",
        "public <T> T readPropertyValue(JsonParser p, BeanProperty prop, JavaType type) throws IOException",
        "public boolean handleUnknownProperty(JsonParser p, JsonDeserializer<?> deser, Object instanceOrClass, String propName) throws IOException",
        "public Object handleWeirdKey(Class<?> keyClass, String keyValue, String msg, Object... msgArgs) throws IOException",
        "public Object handleWeirdStringValue(Class<?> targetClass, String value, String msg, Object... msgArgs) throws IOException",
        "public Object handleWeirdNumberValue(Class<?> targetClass, Number value, String msg, Object... msgArgs) throws IOException",
        "public Object handleWeirdNativeValue(JavaType targetType, Object badValue, JsonParser p) throws IOException",
        "public Object handleMissingInstantiator(Class<?> instClass, ValueInstantiator valueInst, JsonParser p, String msg, Object... msgArgs) throws IOException",
        "public Object handleInstantiationProblem(Class<?> instClass, Object argument, Throwable t) throws IOException",
        "public Object handleUnexpectedToken(Class<?> instClass, JsonParser p) throws IOException",
        "public Object handleUnexpectedToken(Class<?> instClass, JsonToken t, JsonParser p, String msg, Object... msgArgs) throws IOException",
        "public JavaType handleUnknownTypeId(JavaType baseType, String id, TypeIdResolver idResolver, String extraDesc) throws IOException",
        "public JavaType handleMissingTypeId(JavaType baseType, TypeIdResolver idResolver, String extraDesc) throws IOException",
        "protected boolean _isCompatible(Class<?> target, Object value)",
        "public void reportWrongTokenException(JsonDeserializer<?> deser, JsonToken expToken, String msg, Object... msgArgs) throws JsonMappingException",
        "public void reportWrongTokenException(JavaType targetType, JsonToken expToken, String msg, Object... msgArgs) throws JsonMappingException",
        "public void reportWrongTokenException(Class<?> targetType, JsonToken expToken, String msg, Object... msgArgs) throws JsonMappingException",
        "public <T> T reportUnresolvedObjectId(ObjectIdReader oidReader, Object bean) throws JsonMappingException",
        "public <T> T reportInputMismatch(BeanProperty prop, String msg, Object... msgArgs) throws JsonMappingException",
        "public <T> T reportInputMismatch(JsonDeserializer<?> src, String msg, Object... msgArgs) throws JsonMappingException",
        "public <T> T reportInputMismatch(Class<?> targetType, String msg, Object... msgArgs) throws JsonMappingException",
        "public <T> T reportInputMismatch(JavaType targetType, String msg, Object... msgArgs) throws JsonMappingException",
        "public <T> T reportTrailingTokens(Class<?> targetType, JsonParser p, JsonToken trailingToken) throws JsonMappingException",
        "public void reportWrongTokenException(JsonParser p, JsonToken expToken, String msg, Object... msgArgs) throws JsonMappingException",
        "public void reportUnknownProperty(Object instanceOrClass, String fieldName, JsonDeserializer<?> deser) throws JsonMappingException",
        "public void reportMissingContent(String msg, Object... msgArgs) throws JsonMappingException",
        "public <T> T reportBadTypeDefinition(BeanDescription bean, String msg, Object... msgArgs) throws JsonMappingException",
        "public <T> T reportBadPropertyDefinition(BeanDescription bean, BeanPropertyDefinition prop, String msg, Object... msgArgs) throws JsonMappingException",
        "public <T> T reportBadDefinition(JavaType type, String msg) throws JsonMappingException",
        "public <T> T reportBadMerge(JsonDeserializer<?> deser) throws JsonMappingException",
        "public JsonMappingException wrongTokenException(JsonParser p, JavaType targetType, JsonToken expToken, String extra)",
        "public JsonMappingException wrongTokenException(JsonParser p, Class<?> targetType, JsonToken expToken, String extra)",
        "public JsonMappingException wrongTokenException(JsonParser p, JsonToken expToken, String msg)",
        "public JsonMappingException weirdKeyException(Class<?> keyClass, String keyValue, String msg)",
        "public JsonMappingException weirdStringException(String value, Class<?> instClass, String msg)",
        "public JsonMappingException weirdNumberException(Number value, Class<?> instClass, String msg)",
        "public JsonMappingException weirdNativeValueException(Object value, Class<?> instClass)",
        "native value (`JsonToken.VALUE_EMBEDDED_OBJECT`) of type %s: incompatible types\", ClassUtil.nameOf(instClass), ClassUtil.classNameOf(value)), value, instClass); } public JsonMappingException instantiationException(Class<?> instClass, Throwable cause)",
        "public JsonMappingException instantiationException(Class<?> instClass, String msg0)",
        "public JsonMappingException invalidTypeIdException(JavaType baseType, String typeId, String extraDesc)",
        "public JsonMappingException missingTypeIdException(JavaType baseType, String extraDesc)",
        "public JsonMappingException unknownTypeException(JavaType type, String id, String extraDesc)",
        "public JsonMappingException endOfInputException(Class<?> instClass)",
        "public void reportMappingException(String msg, Object... msgArgs) throws JsonMappingException",
        "public JsonMappingException mappingException(String message)",
        "public JsonMappingException mappingException(String msg, Object... msgArgs)",
        "public JsonMappingException mappingException(Class<?> targetClass)",
        "public JsonMappingException mappingException(Class<?> targetClass, JsonToken token)",
        "protected DateFormat getDateFormat()"
      ],
      "methods": [
        {
          "buggy_method": "  public Date parseDate(String dateStr) throws IllegalArgumentException {\n  try {\n  DateFormat df = getDateFormat();\n  return df.parse(dateStr);\n  } catch (ParseException e) {\n  throw new IllegalArgumentException(String.format(\n  \"Failed to parse Date value '%s': %s\", dateStr,\n  e.getMessage()));\n  }\n  }",
          "fixed_method": "  public Date parseDate(String dateStr) throws IllegalArgumentException {\n  try {\n  DateFormat df = getDateFormat();\n  return df.parse(dateStr);\n  } catch (ParseException e) {\n  throw new IllegalArgumentException(String.format(\n  \"Failed to parse Date value '%s': %s\", dateStr,\n  ClassUtil.exceptionMessage(e)));\n  }\n  }",
          "diff": [
            "@@ -711,7 +711,7 @@",
            "         } catch (ParseException e) {\n",
            "             throw new IllegalArgumentException(String.format(\n",
            "                     \"Failed to parse Date value '%s': %s\", dateStr,\n",
            "-                    e.getMessage()));\n",
            "+                    ClassUtil.exceptionMessage(e)));\n",
            "         }\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  public JsonMappingException instantiationException(Class<?> instClass, Throwable cause) {\n  \n  final JavaType type = constructType(instClass);\n  String excMsg;\n  if (cause == null) {\n  excMsg = \"N/A\";\n  } else if ((excMsg = cause.getMessage()) == null) {\n  excMsg = ClassUtil.nameOf(cause.getClass());\n  }\n  String msg = String.format(\"Cannot construct instance of %s, problem: %s\",\n  ClassUtil.nameOf(instClass), excMsg);\n  InvalidDefinitionException e = InvalidDefinitionException.from(_parser, msg, type);\n  e.initCause(cause);\n  return e;\n  }",
          "fixed_method": "  public JsonMappingException instantiationException(Class<?> instClass, Throwable cause) {\n  \n  final JavaType type = constructType(instClass);\n  String excMsg;\n  if (cause == null) {\n  excMsg = \"N/A\";\n  } else if ((excMsg = ClassUtil.exceptionMessage(cause)) == null) {\n  excMsg = ClassUtil.nameOf(cause.getClass());\n  }\n  String msg = String.format(\"Cannot construct instance of %s, problem: %s\",\n  ClassUtil.nameOf(instClass), excMsg);\n  InvalidDefinitionException e = InvalidDefinitionException.from(_parser, msg, type);\n  e.initCause(cause);\n  return e;\n  }",
          "diff": [
            "@@ -1600,7 +1600,7 @@",
            "         String excMsg;\n",
            "         if (cause == null) {\n",
            "             excMsg = \"N/A\";\n",
            "-        } else if ((excMsg = cause.getMessage()) == null) {\n",
            "+        } else if ((excMsg = ClassUtil.exceptionMessage(cause)) == null) {\n",
            "             excMsg = ClassUtil.nameOf(cause.getClass());\n",
            "         }\n",
            "         String msg = String.format(\"Cannot construct instance of %s, problem: %s\",\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/JsonMappingException.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind;\n\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport com.fasterxml.jackson.core.*;\n\n\npublic class JsonMappingException extends JsonProcessingException { private static final long serialVersionUID = 1L; final static int MAX_REFS_TO_LIST = 1000; public static class Reference implements Serializable { private static final long serialVersionUID = 2L; protected transient Object _from; protected String _fieldName; protected int _index = -1; protected String _desc; protected Reference() { }\n\n        public Reference(Object from) { _from = from; }\n\n        public Reference(Object from, String fieldName) {\n            _from = from;\n            if (fieldName == null) {\n                throw new NullPointerException(\"Cannot pass null fieldName\");\n            }\n            _fieldName = fieldName;\n        }\n\n        public Reference(Object from, int index) {\n            _from = from;\n            _index = index;\n        }\n\n        \n        void setFieldName(String n) { _fieldName = n; }\n        void setIndex(int ix) { _index = ix; }\n        void setDescription(String d) { _desc = d; }\n\n        \n        @JsonIgnore\n        public Object getFrom() { return _from; }\n\n        public String getFieldName() { return _fieldName; }\n        public int getIndex() { return _index; }\n        public String getDescription() {\n            if (_desc == null) {\n                StringBuilder sb = new StringBuilder();\n\n                if (_from == null) { \n                    sb.append(\"UNKNOWN\");\n                } else {\n                    Class<?> cls = (_from instanceof Class<?>) ? (Class<?>)_from : _from.getClass();\n                    \n                    \n                    \n                    \n                    int arrays = 0;\n                    while (cls.isArray()) {\n                        cls = cls.getComponentType();\n                        ++arrays;\n                    }\n                    sb.append(cls.getName());\n                    while (--arrays >= 0) {\n                        sb.append(\"[]\");\n                    }\n                    \n                }\n                sb.append('[');\n                if (_fieldName != null) {\n                    sb.append('\"');\n                    sb.append(_fieldName);\n                    sb.append('\"');\n                } else if (_index >= 0) {\n                    sb.append(_index);\n                } else {\n                    sb.append('?');\n                }\n                sb.append(']');\n                _desc = sb.toString();\n            }\n            return _desc;\n        }\n\n        @Override\n        public String toString() {\n            return getDescription();\n        }\n\n        \n        Object writeReplace() {\n            \n            \n            getDescription();\n            return this;\n        }\n    }\n\n    \n\n    \n    protected LinkedList<Reference> _path; protected transient Closeable _processor; @Deprecated public JsonMappingException(String msg) { super(msg); }\n\n    \n    @Deprecated \n    public JsonMappingException(String msg, Throwable rootCause) { super(msg, rootCause); }\n\n    \n    @Deprecated \n    public JsonMappingException(String msg, JsonLocation loc) { super(msg, loc); }\n\n    \n    @Deprecated \n    public JsonMappingException(String msg, JsonLocation loc, Throwable rootCause) { super(msg, loc, rootCause); }\n\n    \n    public JsonMappingException(Closeable processor, String msg) {\n        super(msg);\n        _processor = processor;\n        if (processor instanceof JsonParser) {\n            \n            \n            \n            _location = ((JsonParser) processor).getTokenLocation();\n        }\n    }\n\n    \n    public JsonMappingException(Closeable processor, String msg, Throwable problem) {\n        super(msg, problem);\n        _processor = processor;\n        if (processor instanceof JsonParser) {\n            _location = ((JsonParser) processor).getTokenLocation();\n        }\n    }\n\n    \n    public JsonMappingException(Closeable processor, String msg, JsonLocation loc) {\n        super(msg, loc);\n        _processor = processor;\n    }\n\n    \n    public static JsonMappingException from(JsonParser p, String msg) {\n        return new JsonMappingException(p, msg);\n    }\n\n    \n    public static JsonMappingException from(JsonParser p, String msg, Throwable problem) {\n        return new JsonMappingException(p, msg, problem);\n    }\n\n    \n    public static JsonMappingException from(JsonGenerator g, String msg) {\n        return new JsonMappingException(g, msg, (Throwable) null);\n    }\n\n    \n    public static JsonMappingException from(JsonGenerator g, String msg, Throwable problem) {\n        return new JsonMappingException(g, msg, problem);\n    }\n\n    \n    public static JsonMappingException from(DeserializationContext ctxt, String msg) {\n        return new JsonMappingException(ctxt.getParser(), msg);\n    }\n\n    \n    public static JsonMappingException from(DeserializationContext ctxt, String msg, Throwable t) {\n        return new JsonMappingException(ctxt.getParser(), msg, t);\n    }\n\n    \n    public static JsonMappingException from(SerializerProvider ctxt, String msg) {\n        return new JsonMappingException(ctxt.getGenerator(), msg);\n    }\n\n    \n    public static JsonMappingException from(SerializerProvider ctxt, String msg, Throwable problem) {\n        \n        return new JsonMappingException(ctxt.getGenerator(), msg, problem);\n    }\n    \n    \n    public static JsonMappingException fromUnexpectedIOE(IOException src) {\n        return new JsonMappingException(null,\n                String.format(\"Unexpected IOException (of type %s): %s\",\n                        src.getClass().getName(),\n                        src.getMessage()));\n    }\n\n    \n    public static JsonMappingException wrapWithPath(Throwable src, Object refFrom, String refFieldName) {\n        return wrapWithPath(src, new Reference(refFrom, refFieldName));\n    }\n\n    \n    public static JsonMappingException wrapWithPath(Throwable src, Object refFrom, int index) {\n        return wrapWithPath(src, new Reference(refFrom, index));\n    }\n\n    \n    @SuppressWarnings(\"resource\")\n    public static JsonMappingException wrapWithPath(Throwable src, Reference ref) {\n        JsonMappingException jme;\n        if (src instanceof JsonMappingException) {\n            jme = (JsonMappingException) src;\n        } else {\n            \n            String msg = src.getMessage();\n            \n            if (msg == null || msg.length() == 0) {\n                msg = \"(was \"+src.getClass().getName()+\")\";\n            }\n            \n            Closeable proc = null;\n            if (src instanceof JsonProcessingException) {\n                Object proc0 = ((JsonProcessingException) src).getProcessor();\n                if (proc0 instanceof Closeable) {\n                    proc = (Closeable) proc0;\n                }\n            }\n            jme = new JsonMappingException(proc, msg, src);\n        }\n        jme.prependPath(ref);\n        return jme;\n    }\n\n    \n\n    \n    public List<Reference> getPath() {\n        if (_path == null) {\n            return Collections.emptyList();\n        }\n        return Collections.unmodifiableList(_path);\n    }\n\n    \n    public String getPathReference() {\n        return getPathReference(new StringBuilder()).toString();\n    }\n\n    public StringBuilder getPathReference(StringBuilder sb) {\n        _appendPathDesc(sb);\n        return sb;\n    }\n    \n    \n    public void prependPath(Object referrer, String fieldName) {\n        Reference ref = new Reference(referrer, fieldName);\n        prependPath(ref);\n    }\n    \n    public void prependPath(Object referrer, int index) {\n        Reference ref = new Reference(referrer, index);\n        prependPath(ref);\n    }\n\n    public void prependPath(Reference r) {\n        if (_path == null) {\n            _path = new LinkedList<Reference>();\n        }\n        \n        if (_path.size() < MAX_REFS_TO_LIST) {\n            _path.addFirst(r);\n        }\n    }\n    \n    \n\n    @Override \n    @JsonIgnore \n    public Object getProcessor() { return _processor; }\n\n    @Override\n    public String getLocalizedMessage() {\n        return _buildMessage();\n    }\n    \n    \n    @Override\n    public String getMessage() {\n        return _buildMessage();\n    }\n\n    protected String _buildMessage() {\n        \n        String msg = super.getMessage();\n        if (_path == null) {\n            return msg;\n        }\n        StringBuilder sb = (msg == null) ? new StringBuilder() : new StringBuilder(msg);\n        \n        sb.append(\" (through reference chain: \");\n        sb = getPathReference(sb);\n        sb.append(')');\n        return sb.toString();\n    }\n\n    @Override\n    public String toString() {\n        return getClass().getName()+\": \"+getMessage();\n    }\n\n    \n\n    protected void _appendPathDesc(StringBuilder sb) {\n        if (_path == null) {\n            return;\n        }\n        Iterator<Reference> it = _path.iterator();\n        while (it.hasNext()) {\n            sb.append(it.next().toString());\n            if (it.hasNext()) {\n                sb.append(\"->\");\n            }\n        }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind;\n\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\npublic class JsonMappingException extends JsonProcessingException { private static final long serialVersionUID = 1L; final static int MAX_REFS_TO_LIST = 1000; public static class Reference implements Serializable { private static final long serialVersionUID = 2L; protected transient Object _from; protected String _fieldName; protected int _index = -1; protected String _desc; protected Reference() { }\n\n        public Reference(Object from) { _from = from; }\n\n        public Reference(Object from, String fieldName) {\n            _from = from;\n            if (fieldName == null) {\n                throw new NullPointerException(\"Cannot pass null fieldName\");\n            }\n            _fieldName = fieldName;\n        }\n\n        public Reference(Object from, int index) {\n            _from = from;\n            _index = index;\n        }\n\n        \n        void setFieldName(String n) { _fieldName = n; }\n        void setIndex(int ix) { _index = ix; }\n        void setDescription(String d) { _desc = d; }\n\n        \n        @JsonIgnore\n        public Object getFrom() { return _from; }\n\n        public String getFieldName() { return _fieldName; }\n        public int getIndex() { return _index; }\n        public String getDescription() {\n            if (_desc == null) {\n                StringBuilder sb = new StringBuilder();\n\n                if (_from == null) { \n                    sb.append(\"UNKNOWN\");\n                } else {\n                    Class<?> cls = (_from instanceof Class<?>) ? (Class<?>)_from : _from.getClass();\n                    \n                    \n                    \n                    \n                    int arrays = 0;\n                    while (cls.isArray()) {\n                        cls = cls.getComponentType();\n                        ++arrays;\n                    }\n                    sb.append(cls.getName());\n                    while (--arrays >= 0) {\n                        sb.append(\"[]\");\n                    }\n                    \n                }\n                sb.append('[');\n                if (_fieldName != null) {\n                    sb.append('\"');\n                    sb.append(_fieldName);\n                    sb.append('\"');\n                } else if (_index >= 0) {\n                    sb.append(_index);\n                } else {\n                    sb.append('?');\n                }\n                sb.append(']');\n                _desc = sb.toString();\n            }\n            return _desc;\n        }\n\n        @Override\n        public String toString() {\n            return getDescription();\n        }\n\n        \n        Object writeReplace() {\n            \n            \n            getDescription();\n            return this;\n        }\n    }\n\n    \n\n    \n    protected LinkedList<Reference> _path; protected transient Closeable _processor; @Deprecated public JsonMappingException(String msg) { super(msg); }\n\n    \n    @Deprecated \n    public JsonMappingException(String msg, Throwable rootCause) { super(msg, rootCause); }\n\n    \n    @Deprecated \n    public JsonMappingException(String msg, JsonLocation loc) { super(msg, loc); }\n\n    \n    @Deprecated \n    public JsonMappingException(String msg, JsonLocation loc, Throwable rootCause) { super(msg, loc, rootCause); }\n\n    \n    public JsonMappingException(Closeable processor, String msg) {\n        super(msg);\n        _processor = processor;\n        if (processor instanceof JsonParser) {\n            \n            \n            \n            _location = ((JsonParser) processor).getTokenLocation();\n        }\n    }\n\n    \n    public JsonMappingException(Closeable processor, String msg, Throwable problem) {\n        super(msg, problem);\n        _processor = processor;\n        if (processor instanceof JsonParser) {\n            _location = ((JsonParser) processor).getTokenLocation();\n        }\n    }\n\n    \n    public JsonMappingException(Closeable processor, String msg, JsonLocation loc) {\n        super(msg, loc);\n        _processor = processor;\n    }\n\n    \n    public static JsonMappingException from(JsonParser p, String msg) {\n        return new JsonMappingException(p, msg);\n    }\n\n    \n    public static JsonMappingException from(JsonParser p, String msg, Throwable problem) {\n        return new JsonMappingException(p, msg, problem);\n    }\n\n    \n    public static JsonMappingException from(JsonGenerator g, String msg) {\n        return new JsonMappingException(g, msg, (Throwable) null);\n    }\n\n    \n    public static JsonMappingException from(JsonGenerator g, String msg, Throwable problem) {\n        return new JsonMappingException(g, msg, problem);\n    }\n\n    \n    public static JsonMappingException from(DeserializationContext ctxt, String msg) {\n        return new JsonMappingException(ctxt.getParser(), msg);\n    }\n\n    \n    public static JsonMappingException from(DeserializationContext ctxt, String msg, Throwable t) {\n        return new JsonMappingException(ctxt.getParser(), msg, t);\n    }\n\n    \n    public static JsonMappingException from(SerializerProvider ctxt, String msg) {\n        return new JsonMappingException(ctxt.getGenerator(), msg);\n    }\n\n    \n    public static JsonMappingException from(SerializerProvider ctxt, String msg, Throwable problem) {\n        \n        return new JsonMappingException(ctxt.getGenerator(), msg, problem);\n    }\n    \n    \n    public static JsonMappingException fromUnexpectedIOE(IOException src) {\n        return new JsonMappingException(null,\n                String.format(\"Unexpected IOException (of type %s): %s\",\n                        src.getClass().getName(),\n                        ClassUtil.exceptionMessage(src)));\n    }\n\n    \n    public static JsonMappingException wrapWithPath(Throwable src, Object refFrom, String refFieldName) {\n        return wrapWithPath(src, new Reference(refFrom, refFieldName));\n    }\n\n    \n    public static JsonMappingException wrapWithPath(Throwable src, Object refFrom, int index) {\n        return wrapWithPath(src, new Reference(refFrom, index));\n    }\n\n    \n    @SuppressWarnings(\"resource\")\n    public static JsonMappingException wrapWithPath(Throwable src, Reference ref) {\n        JsonMappingException jme;\n        if (src instanceof JsonMappingException) {\n            jme = (JsonMappingException) src;\n        } else {\n            \n            String msg = ClassUtil.exceptionMessage(src);\n            \n            if (msg == null || msg.length() == 0) {\n                msg = \"(was \"+src.getClass().getName()+\")\";\n            }\n            \n            Closeable proc = null;\n            if (src instanceof JsonProcessingException) {\n                Object proc0 = ((JsonProcessingException) src).getProcessor();\n                if (proc0 instanceof Closeable) {\n                    proc = (Closeable) proc0;\n                }\n            }\n            jme = new JsonMappingException(proc, msg, src);\n        }\n        jme.prependPath(ref);\n        return jme;\n    }\n\n    \n\n    \n    public List<Reference> getPath() {\n        if (_path == null) {\n            return Collections.emptyList();\n        }\n        return Collections.unmodifiableList(_path);\n    }\n\n    \n    public String getPathReference() {\n        return getPathReference(new StringBuilder()).toString();\n    }\n\n    public StringBuilder getPathReference(StringBuilder sb) {\n        _appendPathDesc(sb);\n        return sb;\n    }\n    \n    \n    public void prependPath(Object referrer, String fieldName) {\n        Reference ref = new Reference(referrer, fieldName);\n        prependPath(ref);\n    }\n    \n    public void prependPath(Object referrer, int index) {\n        Reference ref = new Reference(referrer, index);\n        prependPath(ref);\n    }\n\n    public void prependPath(Reference r) {\n        if (_path == null) {\n            _path = new LinkedList<Reference>();\n        }\n        \n        if (_path.size() < MAX_REFS_TO_LIST) {\n            _path.addFirst(r);\n        }\n    }\n    \n    \n\n    @Override \n    @JsonIgnore \n    public Object getProcessor() { return _processor; }\n\n    @Override\n    public String getLocalizedMessage() {\n        return _buildMessage();\n    }\n    \n    \n    @Override\n    public String getMessage() {\n        return _buildMessage();\n    }\n\n    protected String _buildMessage() {\n        \n        String msg = super.getMessage();\n        if (_path == null) {\n            return msg;\n        }\n        StringBuilder sb = (msg == null) ? new StringBuilder() : new StringBuilder(msg);\n        \n        sb.append(\" (through reference chain: \");\n        sb = getPathReference(sb);\n        sb.append(')');\n        return sb.toString();\n    }\n\n    @Override\n    public String toString() {\n        return getClass().getName()+\": \"+getMessage();\n    }\n\n    \n\n    protected void _appendPathDesc(StringBuilder sb) {\n        if (_path == null) {\n            return;\n        }\n        Iterator<Reference> it = _path.iterator();\n        while (it.hasNext()) {\n            sb.append(it.next().toString());\n            if (it.hasNext()) {\n                sb.append(\"->\");\n            }\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public Reference(Object from)",
        "public Reference(Object from, String fieldName)",
        "public Reference(Object from, int index)",
        "public Object getFrom()",
        "public String getFieldName()",
        "public int getIndex()",
        "public String getDescription()",
        "public String toString()",
        "protected LinkedList<Reference> _path; protected transient Closeable _processor; @Deprecated public JsonMappingException(String msg)",
        "public JsonMappingException(String msg, Throwable rootCause)",
        "public JsonMappingException(String msg, JsonLocation loc)",
        "public JsonMappingException(String msg, JsonLocation loc, Throwable rootCause)",
        "public JsonMappingException(Closeable processor, String msg)",
        "public JsonMappingException(Closeable processor, String msg, Throwable problem)",
        "public JsonMappingException(Closeable processor, String msg, JsonLocation loc)",
        "public static JsonMappingException from(JsonParser p, String msg)",
        "public static JsonMappingException from(JsonParser p, String msg, Throwable problem)",
        "public static JsonMappingException from(JsonGenerator g, String msg)",
        "public static JsonMappingException from(JsonGenerator g, String msg, Throwable problem)",
        "public static JsonMappingException from(DeserializationContext ctxt, String msg)",
        "public static JsonMappingException from(DeserializationContext ctxt, String msg, Throwable t)",
        "public static JsonMappingException from(SerializerProvider ctxt, String msg)",
        "public static JsonMappingException from(SerializerProvider ctxt, String msg, Throwable problem)",
        "public static JsonMappingException fromUnexpectedIOE(IOException src)",
        "public static JsonMappingException wrapWithPath(Throwable src, Object refFrom, String refFieldName)",
        "public static JsonMappingException wrapWithPath(Throwable src, Object refFrom, int index)",
        "public static JsonMappingException wrapWithPath(Throwable src, Reference ref)",
        "public List<Reference> getPath()",
        "public String getPathReference()",
        "public StringBuilder getPathReference(StringBuilder sb)",
        "public void prependPath(Object referrer, String fieldName)",
        "public void prependPath(Object referrer, int index)",
        "public void prependPath(Reference r)",
        "public Object getProcessor()",
        "public String getLocalizedMessage()",
        "public String getMessage()",
        "protected String _buildMessage()",
        "public String toString()",
        "protected void _appendPathDesc(StringBuilder sb)"
      ],
      "fixed_signatures": [
        "public Reference(Object from)",
        "public Reference(Object from, String fieldName)",
        "public Reference(Object from, int index)",
        "public Object getFrom()",
        "public String getFieldName()",
        "public int getIndex()",
        "public String getDescription()",
        "public String toString()",
        "protected LinkedList<Reference> _path; protected transient Closeable _processor; @Deprecated public JsonMappingException(String msg)",
        "public JsonMappingException(String msg, Throwable rootCause)",
        "public JsonMappingException(String msg, JsonLocation loc)",
        "public JsonMappingException(String msg, JsonLocation loc, Throwable rootCause)",
        "public JsonMappingException(Closeable processor, String msg)",
        "public JsonMappingException(Closeable processor, String msg, Throwable problem)",
        "public JsonMappingException(Closeable processor, String msg, JsonLocation loc)",
        "public static JsonMappingException from(JsonParser p, String msg)",
        "public static JsonMappingException from(JsonParser p, String msg, Throwable problem)",
        "public static JsonMappingException from(JsonGenerator g, String msg)",
        "public static JsonMappingException from(JsonGenerator g, String msg, Throwable problem)",
        "public static JsonMappingException from(DeserializationContext ctxt, String msg)",
        "public static JsonMappingException from(DeserializationContext ctxt, String msg, Throwable t)",
        "public static JsonMappingException from(SerializerProvider ctxt, String msg)",
        "public static JsonMappingException from(SerializerProvider ctxt, String msg, Throwable problem)",
        "public static JsonMappingException fromUnexpectedIOE(IOException src)",
        "public static JsonMappingException wrapWithPath(Throwable src, Object refFrom, String refFieldName)",
        "public static JsonMappingException wrapWithPath(Throwable src, Object refFrom, int index)",
        "public static JsonMappingException wrapWithPath(Throwable src, Reference ref)",
        "public List<Reference> getPath()",
        "public String getPathReference()",
        "public StringBuilder getPathReference(StringBuilder sb)",
        "public void prependPath(Object referrer, String fieldName)",
        "public void prependPath(Object referrer, int index)",
        "public void prependPath(Reference r)",
        "public Object getProcessor()",
        "public String getLocalizedMessage()",
        "public String getMessage()",
        "protected String _buildMessage()",
        "public String toString()",
        "protected void _appendPathDesc(StringBuilder sb)"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -7,6 +7,7 @@",
            " \n",
            " import com.fasterxml.jackson.annotation.JsonIgnore;\n",
            " import com.fasterxml.jackson.core.*;\n",
            "+import com.fasterxml.jackson.databind.util.ClassUtil;\n",
            " \n",
            " /**\n",
            "  * Checked exception used to signal fatal problems with mapping of\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  public static JsonMappingException fromUnexpectedIOE(IOException src) {\n  return new JsonMappingException(null,\n  String.format(\"Unexpected IOException (of type %s): %s\",\n  src.getClass().getName(),\n  src.getMessage()));\n  }",
          "fixed_method": "  public static JsonMappingException fromUnexpectedIOE(IOException src) {\n  return new JsonMappingException(null,\n  String.format(\"Unexpected IOException (of type %s): %s\",\n  src.getClass().getName(),\n  ClassUtil.exceptionMessage(src)));\n  }",
          "diff": [
            "@@ -336,7 +337,7 @@",
            "         return new JsonMappingException(null,\n",
            "                 String.format(\"Unexpected IOException (of type %s): %s\",\n",
            "                         src.getClass().getName(),\n",
            "-                        src.getMessage()));\n",
            "+                        ClassUtil.exceptionMessage(src)));\n",
            "     }\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  public static JsonMappingException wrapWithPath(Throwable src, Reference ref) {\n  JsonMappingException jme;\n  if (src instanceof JsonMappingException) {\n  jme = (JsonMappingException) src;\n  } else {\n  \n  String msg = src.getMessage();\n  \n  if (msg == null || msg.length() == 0) {\n  msg = \"(was \"+src.getClass().getName()+\")\";\n  }\n  \n  Closeable proc = null;\n  if (src instanceof JsonProcessingException) {\n  Object proc0 = ((JsonProcessingException) src).getProcessor();\n  if (proc0 instanceof Closeable) {\n  proc = (Closeable) proc0;\n  }\n  }\n  jme = new JsonMappingException(proc, msg, src);\n  }\n  jme.prependPath(ref);\n  return jme;\n  }",
          "fixed_method": "  public static JsonMappingException wrapWithPath(Throwable src, Reference ref) {\n  JsonMappingException jme;\n  if (src instanceof JsonMappingException) {\n  jme = (JsonMappingException) src;\n  } else {\n  \n  String msg = ClassUtil.exceptionMessage(src);\n  \n  if (msg == null || msg.length() == 0) {\n  msg = \"(was \"+src.getClass().getName()+\")\";\n  }\n  \n  Closeable proc = null;\n  if (src instanceof JsonProcessingException) {\n  Object proc0 = ((JsonProcessingException) src).getProcessor();\n  if (proc0 instanceof Closeable) {\n  proc = (Closeable) proc0;\n  }\n  }\n  jme = new JsonMappingException(proc, msg, src);\n  }\n  jme.prependPath(ref);\n  return jme;\n  }",
          "diff": [
            "@@ -377,7 +378,7 @@",
            "             jme = (JsonMappingException) src;\n",
            "         } else {\n",
            "             // [databind#2128]: try to avoid duplication\n",
            "-            String msg = src.getMessage();\n",
            "+            String msg = ClassUtil.exceptionMessage(src);\n",
            "             // Let's use a more meaningful placeholder if all we have is null\n",
            "             if (msg == null || msg.length() == 0) {\n",
            "                 msg = \"(was \"+src.getClass().getName()+\")\";\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/SerializerProvider.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind;\n\nimport java.io.IOException;\nimport java.text.DateFormat;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.databind.cfg.ContextAttributes;\nimport com.fasterxml.jackson.databind.deser.ContextualDeserializer;\nimport com.fasterxml.jackson.databind.exc.InvalidDefinitionException;\nimport com.fasterxml.jackson.databind.exc.InvalidTypeIdException;\nimport com.fasterxml.jackson.databind.introspect.Annotated;\nimport com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.ser.*;\nimport com.fasterxml.jackson.databind.ser.impl.FailingSerializer;\nimport com.fasterxml.jackson.databind.ser.impl.ReadOnlyClassToSerializerMap;\nimport com.fasterxml.jackson.databind.ser.impl.TypeWrappedSerializer;\nimport com.fasterxml.jackson.databind.ser.impl.UnknownSerializer;\nimport com.fasterxml.jackson.databind.ser.impl.WritableObjectId;\nimport com.fasterxml.jackson.databind.ser.std.NullSerializer;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\npublic abstract class SerializerProvider extends DatabindContext { protected final static boolean CACHE_UNKNOWN_MAPPINGS = false; public final static JsonSerializer<Object> DEFAULT_NULL_KEY_SERIALIZER = new FailingSerializer(\"Null key for a Map not allowed in JSON (use a converting NullKeySerializer?)\"); protected final static JsonSerializer<Object> DEFAULT_UNKNOWN_SERIALIZER = new UnknownSerializer(); final protected SerializationConfig _config; final protected Class<?> _serializationView; final protected SerializerFactory _serializerFactory; final protected SerializerCache _serializerCache; protected transient ContextAttributes _attributes; protected JsonSerializer<Object> _unknownTypeSerializer = DEFAULT_UNKNOWN_SERIALIZER; protected JsonSerializer<Object> _keySerializer; protected JsonSerializer<Object> _nullValueSerializer = NullSerializer.instance; protected JsonSerializer<Object> _nullKeySerializer = DEFAULT_NULL_KEY_SERIALIZER; protected final ReadOnlyClassToSerializerMap _knownSerializers; protected DateFormat _dateFormat; protected final boolean _stdNullValueSerializer; public SerializerProvider() {\n        _config = null;\n        _serializerFactory = null;\n        _serializerCache = new SerializerCache();\n        \n        _knownSerializers = null;\n\n        _serializationView = null;\n        _attributes = null;\n\n        \n        _stdNullValueSerializer = true;\n    }\n\n    \n    protected SerializerProvider(SerializerProvider src, SerializationConfig config, SerializerFactory f) {\n        _serializerFactory = f;\n        _config = config;\n\n        _serializerCache = src._serializerCache;\n        _unknownTypeSerializer = src._unknownTypeSerializer;\n        _keySerializer = src._keySerializer;\n        _nullValueSerializer = src._nullValueSerializer;\n        _nullKeySerializer = src._nullKeySerializer;\n\n        _stdNullValueSerializer = (_nullValueSerializer == DEFAULT_NULL_KEY_SERIALIZER);\n\n        _serializationView = config.getActiveView();\n        _attributes = config.getAttributes();\n\n        \n        _knownSerializers = _serializerCache.getReadOnlyLookupMap();\n    }\n\n    \n    protected SerializerProvider(SerializerProvider src) {\n        \n        _config = null;\n        _serializationView = null;\n        _serializerFactory = null;\n        _knownSerializers = null;\n\n        \n        _serializerCache = new SerializerCache();\n\n        _unknownTypeSerializer = src._unknownTypeSerializer;\n        _keySerializer = src._keySerializer;\n        _nullValueSerializer = src._nullValueSerializer;\n        _nullKeySerializer = src._nullKeySerializer;\n\n        _stdNullValueSerializer = src._stdNullValueSerializer;\n    }\n    \n    \n\n    \n    public void setDefaultKeySerializer(JsonSerializer<Object> ks) {\n        if (ks == null) {\n            throw new IllegalArgumentException(\"Cannot pass null JsonSerializer\");\n        }\n        _keySerializer = ks;\n    }\n\n    \n    public void setNullValueSerializer(JsonSerializer<Object> nvs) {\n        if (nvs == null) {\n            throw new IllegalArgumentException(\"Cannot pass null JsonSerializer\");\n        }\n        _nullValueSerializer = nvs;\n    }\n\n    \n    public void setNullKeySerializer(JsonSerializer<Object> nks) {\n        if (nks == null) {\n            throw new IllegalArgumentException(\"Cannot pass null JsonSerializer\");\n        }\n        _nullKeySerializer = nks;\n    }\n        \n    \n\n    \n    @Override\n    public final SerializationConfig getConfig() { return _config; }\n\n    @Override\n    public final AnnotationIntrospector getAnnotationIntrospector() {\n        return _config.getAnnotationIntrospector();\n    }\n\n    @Override\n    public final TypeFactory getTypeFactory() {\n        return _config.getTypeFactory();\n    }\n\n    @Override\n    public final Class<?> getActiveView() { return _serializationView; }\n    \n    \n    @Deprecated\n    public final Class<?> getSerializationView() { return _serializationView; }\n\n    @Override\n    public final boolean canOverrideAccessModifiers() {\n        return _config.canOverrideAccessModifiers();\n    }\n\n    @Override\n    public final boolean isEnabled(MapperFeature feature) {\n        return _config.isEnabled(feature);\n    }\n\n    @Override\n    public final JsonFormat.Value getDefaultPropertyFormat(Class<?> baseType) {\n        return _config.getDefaultPropertyFormat(baseType);\n    }\n\n    \n    public final JsonInclude.Value getDefaultPropertyInclusion(Class<?> baseType) {\n        return _config.getDefaultPropertyInclusion();\n    }\n\n    \n    @Override\n    public Locale getLocale() {\n        return _config.getLocale();\n    }\n\n    \n    @Override\n    public TimeZone getTimeZone() {\n        return _config.getTimeZone();\n    }\n    \n    \n\n    @Override\n    public Object getAttribute(Object key) {\n        return _attributes.getAttribute(key);\n    }\n\n    @Override\n    public SerializerProvider setAttribute(Object key, Object value) {\n        _attributes = _attributes.withPerCallAttribute(key, value);\n        return this;\n    }\n\n    \n\n    \n    public final boolean isEnabled(SerializationFeature feature) {\n        return _config.isEnabled(feature);\n    }\n\n    \n    public final boolean hasSerializationFeatures(int featureMask) {\n        return _config.hasSerializationFeatures(featureMask);\n    }\n    \n    \n    public final FilterProvider getFilterProvider() {\n        return _config.getFilterProvider();\n    }\n\n    \n    public JsonGenerator getGenerator() {\n        return null;\n    }\n    \n    \n\n    \n    public abstract WritableObjectId findObjectId(Object forPojo, ObjectIdGenerator<?> generatorType); @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> findValueSerializer(Class<?> valueType, BeanProperty property) throws JsonMappingException {\n        \n        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n        if (ser == null) {\n            \n            ser = _serializerCache.untypedValueSerializer(valueType);\n            if (ser == null) {\n                \n                ser = _serializerCache.untypedValueSerializer(_config.constructType(valueType));\n                if (ser == null) {\n                    \n                    ser = _createAndCacheUntypedSerializer(valueType);\n                    \n                    if (ser == null) {\n                        ser = getUnknownTypeSerializer(valueType);\n                        \n                        if (CACHE_UNKNOWN_MAPPINGS) {\n                            _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n                        }\n                        return ser;\n                    }\n                }\n            }\n        }\n        \n        return (JsonSerializer<Object>) handleSecondaryContextualization(ser, property);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public JsonSerializer<Object> findValueSerializer(JavaType valueType, BeanProperty property) throws JsonMappingException {\n        if (valueType == null) {\n            reportMappingProblem(\"Null passed for `valueType` of `findValueSerializer()`\");\n        }\n        \n        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n        if (ser == null) {\n            ser = _serializerCache.untypedValueSerializer(valueType);\n            if (ser == null) {\n                ser = _createAndCacheUntypedSerializer(valueType);\n                if (ser == null) {\n                    ser = getUnknownTypeSerializer(valueType.getRawClass());\n                    if (CACHE_UNKNOWN_MAPPINGS) {\n                        _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n                    }\n                    return ser;\n                }\n            }\n        }\n        return (JsonSerializer<Object>) handleSecondaryContextualization(ser, property);\n    }\n\n    \n    public JsonSerializer<Object> findValueSerializer(Class<?> valueType) throws JsonMappingException {\n        \n        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n        if (ser == null) {\n            ser = _serializerCache.untypedValueSerializer(valueType);\n            if (ser == null) {\n                ser = _serializerCache.untypedValueSerializer(_config.constructType(valueType));\n                if (ser == null) {\n                    ser = _createAndCacheUntypedSerializer(valueType);\n                    if (ser == null) {\n                        ser = getUnknownTypeSerializer(valueType);\n                        if (CACHE_UNKNOWN_MAPPINGS) {\n                            _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n                        }\n                    }\n                }\n            }\n        }\n        return ser;\n    }\n\n    \n    public JsonSerializer<Object> findValueSerializer(JavaType valueType) throws JsonMappingException {\n        \n        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n        if (ser == null) {\n            ser = _serializerCache.untypedValueSerializer(valueType);\n            if (ser == null) {\n                ser = _createAndCacheUntypedSerializer(valueType);\n                if (ser == null) {\n                    ser = getUnknownTypeSerializer(valueType.getRawClass());\n                    if (CACHE_UNKNOWN_MAPPINGS) {\n                        _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n                    }\n                }\n            }\n        }\n        return ser;\n    }\n    \n    \n    @SuppressWarnings(\"unchecked\")\n    public JsonSerializer<Object> findPrimaryPropertySerializer(JavaType valueType, BeanProperty property) throws JsonMappingException {\n        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n        if (ser == null) {\n            ser = _serializerCache.untypedValueSerializer(valueType);\n            if (ser == null) {\n                ser = _createAndCacheUntypedSerializer(valueType);\n                if (ser == null) {\n                    ser = getUnknownTypeSerializer(valueType.getRawClass());\n                    \n                    if (CACHE_UNKNOWN_MAPPINGS) {\n                        _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n                    }\n                    return ser;\n                }\n            }\n        }\n        return (JsonSerializer<Object>) handlePrimaryContextualization(ser, property);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public JsonSerializer<Object> findPrimaryPropertySerializer(Class<?> valueType, BeanProperty property) throws JsonMappingException {\n        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n        if (ser == null) {\n            ser = _serializerCache.untypedValueSerializer(valueType);\n            if (ser == null) {\n                ser = _serializerCache.untypedValueSerializer(_config.constructType(valueType));\n                if (ser == null) {\n                    ser = _createAndCacheUntypedSerializer(valueType);\n                    if (ser == null) {\n                        ser = getUnknownTypeSerializer(valueType);\n                        if (CACHE_UNKNOWN_MAPPINGS) {\n                            _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n                        }\n                        return ser;\n                    }\n                }\n            }\n        }\n        return (JsonSerializer<Object>) handlePrimaryContextualization(ser, property);\n    }\n    \n    \n    public JsonSerializer<Object> findTypedValueSerializer(Class<?> valueType, boolean cache, BeanProperty property) throws JsonMappingException {\n        \n        JsonSerializer<Object> ser = _knownSerializers.typedValueSerializer(valueType);\n        if (ser != null) {\n            return ser;\n        }\n        \n        ser = _serializerCache.typedValueSerializer(valueType);\n        if (ser != null) {\n            return ser;\n        }\n\n        \n        ser = findValueSerializer(valueType, property);\n        TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config,\n                _config.constructType(valueType));\n        if (typeSer != null) {\n            typeSer = typeSer.forProperty(property);\n            ser = new TypeWrappedSerializer(typeSer, ser);\n        }\n        if (cache) {\n            _serializerCache.addTypedSerializer(valueType, ser);\n        }\n        return ser;\n    }\n\n    \n    public JsonSerializer<Object> findTypedValueSerializer(JavaType valueType, boolean cache, BeanProperty property) throws JsonMappingException {\n        \n        JsonSerializer<Object> ser = _knownSerializers.typedValueSerializer(valueType);\n        if (ser != null) {\n            return ser;\n        }\n        \n        ser = _serializerCache.typedValueSerializer(valueType);\n        if (ser != null) {\n            return ser;\n        }\n\n        \n        ser = findValueSerializer(valueType, property);\n        TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config, valueType);\n        if (typeSer != null) {\n            typeSer = typeSer.forProperty(property);\n            ser = new TypeWrappedSerializer(typeSer, ser);\n        }\n        if (cache) {\n            _serializerCache.addTypedSerializer(valueType, ser);\n        }\n        return ser;\n    }\n\n    \n    public TypeSerializer findTypeSerializer(JavaType javaType) throws JsonMappingException {\n        return _serializerFactory.createTypeSerializer(_config, javaType);\n    }\n\n    \n    public JsonSerializer<Object> findKeySerializer(JavaType keyType, BeanProperty property) throws JsonMappingException {\n        JsonSerializer<Object> ser = _serializerFactory.createKeySerializer(_config, keyType, _keySerializer);\n        \n        return _handleContextualResolvable(ser, property);\n    }\n\n    \n    public JsonSerializer<Object> findKeySerializer(Class<?> rawKeyType, BeanProperty property) throws JsonMappingException {\n        return findKeySerializer(_config.constructType(rawKeyType), property);\n    }\n\n    \n\n    \n    public JsonSerializer<Object> getDefaultNullKeySerializer() {\n        return _nullKeySerializer;\n    }\n\n    \n    public JsonSerializer<Object> getDefaultNullValueSerializer() {\n        return _nullValueSerializer;\n    }\n    \n    \n    \n    public JsonSerializer<Object> findNullKeySerializer(JavaType serializationType, BeanProperty property) throws JsonMappingException {\n        return _nullKeySerializer;\n    }\n\n    \n    public JsonSerializer<Object> findNullValueSerializer(BeanProperty property) throws JsonMappingException {\n        return _nullValueSerializer;\n    }\n\n    \n    public JsonSerializer<Object> getUnknownTypeSerializer(Class<?> unknownType) {\n        \n        if (unknownType == Object.class) {\n            return _unknownTypeSerializer;\n        }\n        \n        return new UnknownSerializer(unknownType);\n    }\n\n    \n    public boolean isUnknownTypeSerializer(JsonSerializer<?> ser) {\n        if ((ser == _unknownTypeSerializer) || (ser == null)) {\n            return true;\n        }\n        \n        \n        if (isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS)) {\n            if (ser.getClass() == UnknownSerializer.class) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    \n\n    \n    public abstract JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException; public abstract Object includeFilterInstance(BeanPropertyDefinition forProperty, Class<?> filterClass) throws JsonMappingException; public abstract boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException; public JsonSerializer<?> handlePrimaryContextualization(JsonSerializer<?> ser, BeanProperty property) throws JsonMappingException {\n        if (ser != null) {\n            if (ser instanceof ContextualSerializer) {\n                ser = ((ContextualSerializer) ser).createContextual(this, property);\n            }\n        }\n        return ser;\n    }\n\n    \n    public JsonSerializer<?> handleSecondaryContextualization(JsonSerializer<?> ser, BeanProperty property) throws JsonMappingException {\n        if (ser != null) {\n            if (ser instanceof ContextualSerializer) {\n                ser = ((ContextualSerializer) ser).createContextual(this, property);\n            }\n        }\n        return ser;\n    }\n    \n    \n\n    \n    public final void defaultSerializeValue(Object value, JsonGenerator gen) throws IOException {\n        if (value == null) {\n            if (_stdNullValueSerializer) { \n                gen.writeNull();\n            } else {\n                _nullValueSerializer.serialize(null, gen, this);\n            }\n        } else {\n            Class<?> cls = value.getClass();\n            findTypedValueSerializer(cls, true, null).serialize(value, gen, this);\n        }\n    }\n    \n    \n    public final void defaultSerializeField(String fieldName, Object value, JsonGenerator gen) throws IOException {\n        gen.writeFieldName(fieldName);\n        if (value == null) {\n            \n            if (_stdNullValueSerializer) { \n                gen.writeNull();\n            } else {\n                _nullValueSerializer.serialize(null, gen, this);\n            }\n        } else {\n            Class<?> cls = value.getClass();\n            findTypedValueSerializer(cls, true, null).serialize(value, gen, this);\n        }\n    }\n\n    \n    public final void defaultSerializeDateValue(long timestamp, JsonGenerator gen) throws IOException {\n        if (isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)) {\n            gen.writeNumber(timestamp);\n        } else {\n            gen.writeString(_dateFormat().format(new Date(timestamp)));\n        }\n    }\n\n    \n    public final void defaultSerializeDateValue(Date date, JsonGenerator gen) throws IOException {\n        if (isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)) {\n            gen.writeNumber(date.getTime());\n        } else {\n            gen.writeString(_dateFormat().format(date));\n        }\n    }\n\n    \n    public void defaultSerializeDateKey(long timestamp, JsonGenerator gen) throws IOException {\n        if (isEnabled(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS)) {\n            gen.writeFieldName(String.valueOf(timestamp));\n        } else {\n            gen.writeFieldName(_dateFormat().format(new Date(timestamp)));\n        }\n    }\n\n    \n    public void defaultSerializeDateKey(Date date, JsonGenerator gen) throws IOException {\n        if (isEnabled(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS)) {\n            gen.writeFieldName(String.valueOf(date.getTime()));\n        } else {\n            gen.writeFieldName(_dateFormat().format(date));\n        }\n    }\n\n    public final void defaultSerializeNull(JsonGenerator gen) throws IOException {\n        if (_stdNullValueSerializer) { \n            gen.writeNull();\n        } else {\n            _nullValueSerializer.serialize(null, gen, this);\n        }\n    }\n\n    \n\n    \n    public void reportMappingProblem(String message, Object... args) throws JsonMappingException {\n        throw mappingException(message, args);\n    }\n\n    \n    public <T> T reportBadTypeDefinition(BeanDescription bean, String msg, Object... msgArgs) throws JsonMappingException {\n        String beanDesc = \"N/A\";\n        if (bean != null) {\n            beanDesc = ClassUtil.nameOf(bean.getBeanClass());\n        }\n        msg = String.format(\"Invalid type definition for type %s: %s\",\n                beanDesc, _format(msg, msgArgs));\n        throw InvalidDefinitionException.from(getGenerator(), msg, bean, null);\n    }\n\n    \n    public <T> T reportBadPropertyDefinition(BeanDescription bean, BeanPropertyDefinition prop, String message, Object... msgArgs) throws JsonMappingException {\n        message = _format(message, msgArgs);\n        String propName = \"N/A\";\n        if (prop != null) {\n            propName = _quotedString(prop.getName());\n        }\n        String beanDesc = \"N/A\";\n        if (bean != null) {\n            beanDesc = ClassUtil.nameOf(bean.getBeanClass());\n        }\n        message = String.format(\"Invalid definition for property %s (of type %s): %s\",\n                propName, beanDesc, message);\n        throw InvalidDefinitionException.from(getGenerator(), message, bean, prop);\n    }\n\n    @Override\n    public <T> T reportBadDefinition(JavaType type, String msg) throws JsonMappingException {\n        throw InvalidDefinitionException.from(getGenerator(), msg, type);\n    }\n\n    \n    public <T> T reportBadDefinition(JavaType type, String msg, Throwable cause) throws JsonMappingException {\n        InvalidDefinitionException e = InvalidDefinitionException.from(getGenerator(), msg, type);\n        e.initCause(cause);\n        throw e;\n    }\n\n    \n    public <T> T reportBadDefinition(Class<?> raw, String msg, Throwable cause) throws JsonMappingException {\n        InvalidDefinitionException e = InvalidDefinitionException.from(getGenerator(), msg, constructType(raw));\n        e.initCause(cause);\n        throw e;\n    }\n\n    \n    public void reportMappingProblem(Throwable t, String message, Object... msgArgs) throws JsonMappingException {\n        message = _format(message, msgArgs);\n        throw JsonMappingException.from(getGenerator(), message, t);\n    }\n\n    @Override\n    public JsonMappingException invalidTypeIdException(JavaType baseType, String typeId, String extraDesc) {\n        String msg = String.format(\"Could not resolve type id '%s' as a subtype of %s\",\n                typeId, baseType);\n        return InvalidTypeIdException.from(null, _colonConcat(msg, extraDesc), baseType, typeId);\n    }\n\n    \n\n    \n    @Deprecated \n    public JsonMappingException mappingException(String message, Object... msgArgs) {\n        return JsonMappingException.from(getGenerator(), _format(message, msgArgs));\n    }\n\n    \n    @Deprecated \n    protected JsonMappingException mappingException(Throwable t, String message, Object... msgArgs) {\n        return JsonMappingException.from(getGenerator(), _format(message, msgArgs), t);\n    }\n\n    \n\n    protected void _reportIncompatibleRootType(Object value, JavaType rootType) throws IOException {\n        \n        if (rootType.isPrimitive()) {\n            Class<?> wrapperType = ClassUtil.wrapperType(rootType.getRawClass());\n            \n            if (wrapperType.isAssignableFrom(value.getClass())) {\n                return;\n            }\n        }\n        reportBadDefinition(rootType, String.format(\n                \"Incompatible types: declared root type (%s) vs %s\",\n                rootType, ClassUtil.classNameOf(value)));\n    }\n\n    \n    protected JsonSerializer<Object> _findExplicitUntypedSerializer(Class<?> runtimeType) throws JsonMappingException {        \n        \n        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(runtimeType);\n        if (ser == null) {\n            \n            ser = _serializerCache.untypedValueSerializer(runtimeType);\n            if (ser == null) {\n                ser = _createAndCacheUntypedSerializer(runtimeType);\n            }\n        }\n        \n        if (isUnknownTypeSerializer(ser)) {\n            return null;\n        }\n        return ser;\n    }\n\n    \n\n    \n    protected JsonSerializer<Object> _createAndCacheUntypedSerializer(Class<?> rawType) throws JsonMappingException {\n        JavaType fullType = _config.constructType(rawType);\n        JsonSerializer<Object> ser;\n        try {\n            ser = _createUntypedSerializer(fullType);\n        } catch (IllegalArgumentException iae) {\n            \n            \n            ser = null; \n            reportMappingProblem(iae, iae.getMessage());\n        }\n\n        if (ser != null) {\n            \n            _serializerCache.addAndResolveNonTypedSerializer(rawType, fullType, ser, this);\n        }\n        return ser;\n    }\n\n    protected JsonSerializer<Object> _createAndCacheUntypedSerializer(JavaType type) throws JsonMappingException {        \n        JsonSerializer<Object> ser;\n        try {\n            ser = _createUntypedSerializer(type);\n        } catch (IllegalArgumentException iae) {\n            \n            \n            ser = null;\n            reportMappingProblem(iae, iae.getMessage());\n        }\n    \n        if (ser != null) {\n            \n            _serializerCache.addAndResolveNonTypedSerializer(type, ser, this);\n        }\n        return ser;\n    }\n\n    \n    protected JsonSerializer<Object> _createUntypedSerializer(JavaType type) throws JsonMappingException {\n        \n        \n        \n        \n        \n        synchronized (_serializerCache) {\n            \n            return (JsonSerializer<Object>)_serializerFactory.createSerializer(this, type);\n        }\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    protected JsonSerializer<Object> _handleContextualResolvable(JsonSerializer<?> ser, BeanProperty property) throws JsonMappingException {\n        if (ser instanceof ResolvableSerializer) {\n            ((ResolvableSerializer) ser).resolve(this);\n        }\n        return (JsonSerializer<Object>) handleSecondaryContextualization(ser, property);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected JsonSerializer<Object> _handleResolvable(JsonSerializer<?> ser) throws JsonMappingException {\n        if (ser instanceof ResolvableSerializer) {\n            ((ResolvableSerializer) ser).resolve(this);\n        }\n        return (JsonSerializer<Object>) ser;\n    }\n\n    \n\n    protected final DateFormat _dateFormat() {\n        if (_dateFormat != null) {\n            return _dateFormat;\n        }\n        \n        DateFormat df = _config.getDateFormat();\n        _dateFormat = df = (DateFormat) df.clone();\n        \n        \n        \n        return df;\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind;\n\nimport java.io.IOException;\nimport java.text.DateFormat;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.databind.cfg.ContextAttributes;\nimport com.fasterxml.jackson.databind.deser.ContextualDeserializer;\nimport com.fasterxml.jackson.databind.exc.InvalidDefinitionException;\nimport com.fasterxml.jackson.databind.exc.InvalidTypeIdException;\nimport com.fasterxml.jackson.databind.introspect.Annotated;\nimport com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.ser.*;\nimport com.fasterxml.jackson.databind.ser.impl.FailingSerializer;\nimport com.fasterxml.jackson.databind.ser.impl.ReadOnlyClassToSerializerMap;\nimport com.fasterxml.jackson.databind.ser.impl.TypeWrappedSerializer;\nimport com.fasterxml.jackson.databind.ser.impl.UnknownSerializer;\nimport com.fasterxml.jackson.databind.ser.impl.WritableObjectId;\nimport com.fasterxml.jackson.databind.ser.std.NullSerializer;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\npublic abstract class SerializerProvider extends DatabindContext { protected final static boolean CACHE_UNKNOWN_MAPPINGS = false; public final static JsonSerializer<Object> DEFAULT_NULL_KEY_SERIALIZER = new FailingSerializer(\"Null key for a Map not allowed in JSON (use a converting NullKeySerializer?)\"); protected final static JsonSerializer<Object> DEFAULT_UNKNOWN_SERIALIZER = new UnknownSerializer(); final protected SerializationConfig _config; final protected Class<?> _serializationView; final protected SerializerFactory _serializerFactory; final protected SerializerCache _serializerCache; protected transient ContextAttributes _attributes; protected JsonSerializer<Object> _unknownTypeSerializer = DEFAULT_UNKNOWN_SERIALIZER; protected JsonSerializer<Object> _keySerializer; protected JsonSerializer<Object> _nullValueSerializer = NullSerializer.instance; protected JsonSerializer<Object> _nullKeySerializer = DEFAULT_NULL_KEY_SERIALIZER; protected final ReadOnlyClassToSerializerMap _knownSerializers; protected DateFormat _dateFormat; protected final boolean _stdNullValueSerializer; public SerializerProvider() {\n        _config = null;\n        _serializerFactory = null;\n        _serializerCache = new SerializerCache();\n        \n        _knownSerializers = null;\n\n        _serializationView = null;\n        _attributes = null;\n\n        \n        _stdNullValueSerializer = true;\n    }\n\n    \n    protected SerializerProvider(SerializerProvider src, SerializationConfig config, SerializerFactory f) {\n        _serializerFactory = f;\n        _config = config;\n\n        _serializerCache = src._serializerCache;\n        _unknownTypeSerializer = src._unknownTypeSerializer;\n        _keySerializer = src._keySerializer;\n        _nullValueSerializer = src._nullValueSerializer;\n        _nullKeySerializer = src._nullKeySerializer;\n\n        _stdNullValueSerializer = (_nullValueSerializer == DEFAULT_NULL_KEY_SERIALIZER);\n\n        _serializationView = config.getActiveView();\n        _attributes = config.getAttributes();\n\n        \n        _knownSerializers = _serializerCache.getReadOnlyLookupMap();\n    }\n\n    \n    protected SerializerProvider(SerializerProvider src) {\n        \n        _config = null;\n        _serializationView = null;\n        _serializerFactory = null;\n        _knownSerializers = null;\n\n        \n        _serializerCache = new SerializerCache();\n\n        _unknownTypeSerializer = src._unknownTypeSerializer;\n        _keySerializer = src._keySerializer;\n        _nullValueSerializer = src._nullValueSerializer;\n        _nullKeySerializer = src._nullKeySerializer;\n\n        _stdNullValueSerializer = src._stdNullValueSerializer;\n    }\n    \n    \n\n    \n    public void setDefaultKeySerializer(JsonSerializer<Object> ks) {\n        if (ks == null) {\n            throw new IllegalArgumentException(\"Cannot pass null JsonSerializer\");\n        }\n        _keySerializer = ks;\n    }\n\n    \n    public void setNullValueSerializer(JsonSerializer<Object> nvs) {\n        if (nvs == null) {\n            throw new IllegalArgumentException(\"Cannot pass null JsonSerializer\");\n        }\n        _nullValueSerializer = nvs;\n    }\n\n    \n    public void setNullKeySerializer(JsonSerializer<Object> nks) {\n        if (nks == null) {\n            throw new IllegalArgumentException(\"Cannot pass null JsonSerializer\");\n        }\n        _nullKeySerializer = nks;\n    }\n        \n    \n\n    \n    @Override\n    public final SerializationConfig getConfig() { return _config; }\n\n    @Override\n    public final AnnotationIntrospector getAnnotationIntrospector() {\n        return _config.getAnnotationIntrospector();\n    }\n\n    @Override\n    public final TypeFactory getTypeFactory() {\n        return _config.getTypeFactory();\n    }\n\n    @Override\n    public final Class<?> getActiveView() { return _serializationView; }\n    \n    \n    @Deprecated\n    public final Class<?> getSerializationView() { return _serializationView; }\n\n    @Override\n    public final boolean canOverrideAccessModifiers() {\n        return _config.canOverrideAccessModifiers();\n    }\n\n    @Override\n    public final boolean isEnabled(MapperFeature feature) {\n        return _config.isEnabled(feature);\n    }\n\n    @Override\n    public final JsonFormat.Value getDefaultPropertyFormat(Class<?> baseType) {\n        return _config.getDefaultPropertyFormat(baseType);\n    }\n\n    \n    public final JsonInclude.Value getDefaultPropertyInclusion(Class<?> baseType) {\n        return _config.getDefaultPropertyInclusion();\n    }\n\n    \n    @Override\n    public Locale getLocale() {\n        return _config.getLocale();\n    }\n\n    \n    @Override\n    public TimeZone getTimeZone() {\n        return _config.getTimeZone();\n    }\n    \n    \n\n    @Override\n    public Object getAttribute(Object key) {\n        return _attributes.getAttribute(key);\n    }\n\n    @Override\n    public SerializerProvider setAttribute(Object key, Object value) {\n        _attributes = _attributes.withPerCallAttribute(key, value);\n        return this;\n    }\n\n    \n\n    \n    public final boolean isEnabled(SerializationFeature feature) {\n        return _config.isEnabled(feature);\n    }\n\n    \n    public final boolean hasSerializationFeatures(int featureMask) {\n        return _config.hasSerializationFeatures(featureMask);\n    }\n    \n    \n    public final FilterProvider getFilterProvider() {\n        return _config.getFilterProvider();\n    }\n\n    \n    public JsonGenerator getGenerator() {\n        return null;\n    }\n    \n    \n\n    \n    public abstract WritableObjectId findObjectId(Object forPojo, ObjectIdGenerator<?> generatorType); @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> findValueSerializer(Class<?> valueType, BeanProperty property) throws JsonMappingException {\n        \n        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n        if (ser == null) {\n            \n            ser = _serializerCache.untypedValueSerializer(valueType);\n            if (ser == null) {\n                \n                ser = _serializerCache.untypedValueSerializer(_config.constructType(valueType));\n                if (ser == null) {\n                    \n                    ser = _createAndCacheUntypedSerializer(valueType);\n                    \n                    if (ser == null) {\n                        ser = getUnknownTypeSerializer(valueType);\n                        \n                        if (CACHE_UNKNOWN_MAPPINGS) {\n                            _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n                        }\n                        return ser;\n                    }\n                }\n            }\n        }\n        \n        return (JsonSerializer<Object>) handleSecondaryContextualization(ser, property);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public JsonSerializer<Object> findValueSerializer(JavaType valueType, BeanProperty property) throws JsonMappingException {\n        if (valueType == null) {\n            reportMappingProblem(\"Null passed for `valueType` of `findValueSerializer()`\");\n        }\n        \n        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n        if (ser == null) {\n            ser = _serializerCache.untypedValueSerializer(valueType);\n            if (ser == null) {\n                ser = _createAndCacheUntypedSerializer(valueType);\n                if (ser == null) {\n                    ser = getUnknownTypeSerializer(valueType.getRawClass());\n                    if (CACHE_UNKNOWN_MAPPINGS) {\n                        _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n                    }\n                    return ser;\n                }\n            }\n        }\n        return (JsonSerializer<Object>) handleSecondaryContextualization(ser, property);\n    }\n\n    \n    public JsonSerializer<Object> findValueSerializer(Class<?> valueType) throws JsonMappingException {\n        \n        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n        if (ser == null) {\n            ser = _serializerCache.untypedValueSerializer(valueType);\n            if (ser == null) {\n                ser = _serializerCache.untypedValueSerializer(_config.constructType(valueType));\n                if (ser == null) {\n                    ser = _createAndCacheUntypedSerializer(valueType);\n                    if (ser == null) {\n                        ser = getUnknownTypeSerializer(valueType);\n                        if (CACHE_UNKNOWN_MAPPINGS) {\n                            _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n                        }\n                    }\n                }\n            }\n        }\n        return ser;\n    }\n\n    \n    public JsonSerializer<Object> findValueSerializer(JavaType valueType) throws JsonMappingException {\n        \n        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n        if (ser == null) {\n            ser = _serializerCache.untypedValueSerializer(valueType);\n            if (ser == null) {\n                ser = _createAndCacheUntypedSerializer(valueType);\n                if (ser == null) {\n                    ser = getUnknownTypeSerializer(valueType.getRawClass());\n                    if (CACHE_UNKNOWN_MAPPINGS) {\n                        _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n                    }\n                }\n            }\n        }\n        return ser;\n    }\n    \n    \n    @SuppressWarnings(\"unchecked\")\n    public JsonSerializer<Object> findPrimaryPropertySerializer(JavaType valueType, BeanProperty property) throws JsonMappingException {\n        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n        if (ser == null) {\n            ser = _serializerCache.untypedValueSerializer(valueType);\n            if (ser == null) {\n                ser = _createAndCacheUntypedSerializer(valueType);\n                if (ser == null) {\n                    ser = getUnknownTypeSerializer(valueType.getRawClass());\n                    \n                    if (CACHE_UNKNOWN_MAPPINGS) {\n                        _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n                    }\n                    return ser;\n                }\n            }\n        }\n        return (JsonSerializer<Object>) handlePrimaryContextualization(ser, property);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public JsonSerializer<Object> findPrimaryPropertySerializer(Class<?> valueType, BeanProperty property) throws JsonMappingException {\n        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n        if (ser == null) {\n            ser = _serializerCache.untypedValueSerializer(valueType);\n            if (ser == null) {\n                ser = _serializerCache.untypedValueSerializer(_config.constructType(valueType));\n                if (ser == null) {\n                    ser = _createAndCacheUntypedSerializer(valueType);\n                    if (ser == null) {\n                        ser = getUnknownTypeSerializer(valueType);\n                        if (CACHE_UNKNOWN_MAPPINGS) {\n                            _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n                        }\n                        return ser;\n                    }\n                }\n            }\n        }\n        return (JsonSerializer<Object>) handlePrimaryContextualization(ser, property);\n    }\n    \n    \n    public JsonSerializer<Object> findTypedValueSerializer(Class<?> valueType, boolean cache, BeanProperty property) throws JsonMappingException {\n        \n        JsonSerializer<Object> ser = _knownSerializers.typedValueSerializer(valueType);\n        if (ser != null) {\n            return ser;\n        }\n        \n        ser = _serializerCache.typedValueSerializer(valueType);\n        if (ser != null) {\n            return ser;\n        }\n\n        \n        ser = findValueSerializer(valueType, property);\n        TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config,\n                _config.constructType(valueType));\n        if (typeSer != null) {\n            typeSer = typeSer.forProperty(property);\n            ser = new TypeWrappedSerializer(typeSer, ser);\n        }\n        if (cache) {\n            _serializerCache.addTypedSerializer(valueType, ser);\n        }\n        return ser;\n    }\n\n    \n    public JsonSerializer<Object> findTypedValueSerializer(JavaType valueType, boolean cache, BeanProperty property) throws JsonMappingException {\n        \n        JsonSerializer<Object> ser = _knownSerializers.typedValueSerializer(valueType);\n        if (ser != null) {\n            return ser;\n        }\n        \n        ser = _serializerCache.typedValueSerializer(valueType);\n        if (ser != null) {\n            return ser;\n        }\n\n        \n        ser = findValueSerializer(valueType, property);\n        TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config, valueType);\n        if (typeSer != null) {\n            typeSer = typeSer.forProperty(property);\n            ser = new TypeWrappedSerializer(typeSer, ser);\n        }\n        if (cache) {\n            _serializerCache.addTypedSerializer(valueType, ser);\n        }\n        return ser;\n    }\n\n    \n    public TypeSerializer findTypeSerializer(JavaType javaType) throws JsonMappingException {\n        return _serializerFactory.createTypeSerializer(_config, javaType);\n    }\n\n    \n    public JsonSerializer<Object> findKeySerializer(JavaType keyType, BeanProperty property) throws JsonMappingException {\n        JsonSerializer<Object> ser = _serializerFactory.createKeySerializer(_config, keyType, _keySerializer);\n        \n        return _handleContextualResolvable(ser, property);\n    }\n\n    \n    public JsonSerializer<Object> findKeySerializer(Class<?> rawKeyType, BeanProperty property) throws JsonMappingException {\n        return findKeySerializer(_config.constructType(rawKeyType), property);\n    }\n\n    \n\n    \n    public JsonSerializer<Object> getDefaultNullKeySerializer() {\n        return _nullKeySerializer;\n    }\n\n    \n    public JsonSerializer<Object> getDefaultNullValueSerializer() {\n        return _nullValueSerializer;\n    }\n    \n    \n    \n    public JsonSerializer<Object> findNullKeySerializer(JavaType serializationType, BeanProperty property) throws JsonMappingException {\n        return _nullKeySerializer;\n    }\n\n    \n    public JsonSerializer<Object> findNullValueSerializer(BeanProperty property) throws JsonMappingException {\n        return _nullValueSerializer;\n    }\n\n    \n    public JsonSerializer<Object> getUnknownTypeSerializer(Class<?> unknownType) {\n        \n        if (unknownType == Object.class) {\n            return _unknownTypeSerializer;\n        }\n        \n        return new UnknownSerializer(unknownType);\n    }\n\n    \n    public boolean isUnknownTypeSerializer(JsonSerializer<?> ser) {\n        if ((ser == _unknownTypeSerializer) || (ser == null)) {\n            return true;\n        }\n        \n        \n        if (isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS)) {\n            if (ser.getClass() == UnknownSerializer.class) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    \n\n    \n    public abstract JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException; public abstract Object includeFilterInstance(BeanPropertyDefinition forProperty, Class<?> filterClass) throws JsonMappingException; public abstract boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException; public JsonSerializer<?> handlePrimaryContextualization(JsonSerializer<?> ser, BeanProperty property) throws JsonMappingException {\n        if (ser != null) {\n            if (ser instanceof ContextualSerializer) {\n                ser = ((ContextualSerializer) ser).createContextual(this, property);\n            }\n        }\n        return ser;\n    }\n\n    \n    public JsonSerializer<?> handleSecondaryContextualization(JsonSerializer<?> ser, BeanProperty property) throws JsonMappingException {\n        if (ser != null) {\n            if (ser instanceof ContextualSerializer) {\n                ser = ((ContextualSerializer) ser).createContextual(this, property);\n            }\n        }\n        return ser;\n    }\n    \n    \n\n    \n    public final void defaultSerializeValue(Object value, JsonGenerator gen) throws IOException {\n        if (value == null) {\n            if (_stdNullValueSerializer) { \n                gen.writeNull();\n            } else {\n                _nullValueSerializer.serialize(null, gen, this);\n            }\n        } else {\n            Class<?> cls = value.getClass();\n            findTypedValueSerializer(cls, true, null).serialize(value, gen, this);\n        }\n    }\n    \n    \n    public final void defaultSerializeField(String fieldName, Object value, JsonGenerator gen) throws IOException {\n        gen.writeFieldName(fieldName);\n        if (value == null) {\n            \n            if (_stdNullValueSerializer) { \n                gen.writeNull();\n            } else {\n                _nullValueSerializer.serialize(null, gen, this);\n            }\n        } else {\n            Class<?> cls = value.getClass();\n            findTypedValueSerializer(cls, true, null).serialize(value, gen, this);\n        }\n    }\n\n    \n    public final void defaultSerializeDateValue(long timestamp, JsonGenerator gen) throws IOException {\n        if (isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)) {\n            gen.writeNumber(timestamp);\n        } else {\n            gen.writeString(_dateFormat().format(new Date(timestamp)));\n        }\n    }\n\n    \n    public final void defaultSerializeDateValue(Date date, JsonGenerator gen) throws IOException {\n        if (isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)) {\n            gen.writeNumber(date.getTime());\n        } else {\n            gen.writeString(_dateFormat().format(date));\n        }\n    }\n\n    \n    public void defaultSerializeDateKey(long timestamp, JsonGenerator gen) throws IOException {\n        if (isEnabled(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS)) {\n            gen.writeFieldName(String.valueOf(timestamp));\n        } else {\n            gen.writeFieldName(_dateFormat().format(new Date(timestamp)));\n        }\n    }\n\n    \n    public void defaultSerializeDateKey(Date date, JsonGenerator gen) throws IOException {\n        if (isEnabled(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS)) {\n            gen.writeFieldName(String.valueOf(date.getTime()));\n        } else {\n            gen.writeFieldName(_dateFormat().format(date));\n        }\n    }\n\n    public final void defaultSerializeNull(JsonGenerator gen) throws IOException {\n        if (_stdNullValueSerializer) { \n            gen.writeNull();\n        } else {\n            _nullValueSerializer.serialize(null, gen, this);\n        }\n    }\n\n    \n\n    \n    public void reportMappingProblem(String message, Object... args) throws JsonMappingException {\n        throw mappingException(message, args);\n    }\n\n    \n    public <T> T reportBadTypeDefinition(BeanDescription bean, String msg, Object... msgArgs) throws JsonMappingException {\n        String beanDesc = \"N/A\";\n        if (bean != null) {\n            beanDesc = ClassUtil.nameOf(bean.getBeanClass());\n        }\n        msg = String.format(\"Invalid type definition for type %s: %s\",\n                beanDesc, _format(msg, msgArgs));\n        throw InvalidDefinitionException.from(getGenerator(), msg, bean, null);\n    }\n\n    \n    public <T> T reportBadPropertyDefinition(BeanDescription bean, BeanPropertyDefinition prop, String message, Object... msgArgs) throws JsonMappingException {\n        message = _format(message, msgArgs);\n        String propName = \"N/A\";\n        if (prop != null) {\n            propName = _quotedString(prop.getName());\n        }\n        String beanDesc = \"N/A\";\n        if (bean != null) {\n            beanDesc = ClassUtil.nameOf(bean.getBeanClass());\n        }\n        message = String.format(\"Invalid definition for property %s (of type %s): %s\",\n                propName, beanDesc, message);\n        throw InvalidDefinitionException.from(getGenerator(), message, bean, prop);\n    }\n\n    @Override\n    public <T> T reportBadDefinition(JavaType type, String msg) throws JsonMappingException {\n        throw InvalidDefinitionException.from(getGenerator(), msg, type);\n    }\n\n    \n    public <T> T reportBadDefinition(JavaType type, String msg, Throwable cause) throws JsonMappingException {\n        InvalidDefinitionException e = InvalidDefinitionException.from(getGenerator(), msg, type);\n        e.initCause(cause);\n        throw e;\n    }\n\n    \n    public <T> T reportBadDefinition(Class<?> raw, String msg, Throwable cause) throws JsonMappingException {\n        InvalidDefinitionException e = InvalidDefinitionException.from(getGenerator(), msg, constructType(raw));\n        e.initCause(cause);\n        throw e;\n    }\n\n    \n    public void reportMappingProblem(Throwable t, String message, Object... msgArgs) throws JsonMappingException {\n        message = _format(message, msgArgs);\n        throw JsonMappingException.from(getGenerator(), message, t);\n    }\n\n    @Override\n    public JsonMappingException invalidTypeIdException(JavaType baseType, String typeId, String extraDesc) {\n        String msg = String.format(\"Could not resolve type id '%s' as a subtype of %s\",\n                typeId, baseType);\n        return InvalidTypeIdException.from(null, _colonConcat(msg, extraDesc), baseType, typeId);\n    }\n\n    \n\n    \n    @Deprecated \n    public JsonMappingException mappingException(String message, Object... msgArgs) {\n        return JsonMappingException.from(getGenerator(), _format(message, msgArgs));\n    }\n\n    \n    @Deprecated \n    protected JsonMappingException mappingException(Throwable t, String message, Object... msgArgs) {\n        return JsonMappingException.from(getGenerator(), _format(message, msgArgs), t);\n    }\n\n    \n\n    protected void _reportIncompatibleRootType(Object value, JavaType rootType) throws IOException {\n        \n        if (rootType.isPrimitive()) {\n            Class<?> wrapperType = ClassUtil.wrapperType(rootType.getRawClass());\n            \n            if (wrapperType.isAssignableFrom(value.getClass())) {\n                return;\n            }\n        }\n        reportBadDefinition(rootType, String.format(\n                \"Incompatible types: declared root type (%s) vs %s\",\n                rootType, ClassUtil.classNameOf(value)));\n    }\n\n    \n    protected JsonSerializer<Object> _findExplicitUntypedSerializer(Class<?> runtimeType) throws JsonMappingException {        \n        \n        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(runtimeType);\n        if (ser == null) {\n            \n            ser = _serializerCache.untypedValueSerializer(runtimeType);\n            if (ser == null) {\n                ser = _createAndCacheUntypedSerializer(runtimeType);\n            }\n        }\n        \n        if (isUnknownTypeSerializer(ser)) {\n            return null;\n        }\n        return ser;\n    }\n\n    \n\n    \n    protected JsonSerializer<Object> _createAndCacheUntypedSerializer(Class<?> rawType) throws JsonMappingException {\n        JavaType fullType = _config.constructType(rawType);\n        JsonSerializer<Object> ser;\n        try {\n            ser = _createUntypedSerializer(fullType);\n        } catch (IllegalArgumentException iae) {\n            \n            \n            ser = null; \n            reportMappingProblem(iae, ClassUtil.exceptionMessage(iae));\n        }\n\n        if (ser != null) {\n            \n            _serializerCache.addAndResolveNonTypedSerializer(rawType, fullType, ser, this);\n        }\n        return ser;\n    }\n\n    protected JsonSerializer<Object> _createAndCacheUntypedSerializer(JavaType type) throws JsonMappingException {        \n        JsonSerializer<Object> ser;\n        try {\n            ser = _createUntypedSerializer(type);\n        } catch (IllegalArgumentException iae) {\n            \n            \n            ser = null;\n            reportMappingProblem(iae, ClassUtil.exceptionMessage(iae));\n        }\n    \n        if (ser != null) {\n            \n            _serializerCache.addAndResolveNonTypedSerializer(type, ser, this);\n        }\n        return ser;\n    }\n\n    \n    protected JsonSerializer<Object> _createUntypedSerializer(JavaType type) throws JsonMappingException {\n        \n        \n        \n        \n        \n        synchronized (_serializerCache) {\n            \n            return (JsonSerializer<Object>)_serializerFactory.createSerializer(this, type);\n        }\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    protected JsonSerializer<Object> _handleContextualResolvable(JsonSerializer<?> ser, BeanProperty property) throws JsonMappingException {\n        if (ser instanceof ResolvableSerializer) {\n            ((ResolvableSerializer) ser).resolve(this);\n        }\n        return (JsonSerializer<Object>) handleSecondaryContextualization(ser, property);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected JsonSerializer<Object> _handleResolvable(JsonSerializer<?> ser) throws JsonMappingException {\n        if (ser instanceof ResolvableSerializer) {\n            ((ResolvableSerializer) ser).resolve(this);\n        }\n        return (JsonSerializer<Object>) ser;\n    }\n\n    \n\n    protected final DateFormat _dateFormat() {\n        if (_dateFormat != null) {\n            return _dateFormat;\n        }\n        \n        DateFormat df = _config.getDateFormat();\n        _dateFormat = df = (DateFormat) df.clone();\n        \n        \n        \n        return df;\n    }\n}\n",
      "buggy_signatures": [
        "protected SerializerProvider(SerializerProvider src, SerializationConfig config, SerializerFactory f)",
        "protected SerializerProvider(SerializerProvider src)",
        "public void setDefaultKeySerializer(JsonSerializer<Object> ks)",
        "public void setNullValueSerializer(JsonSerializer<Object> nvs)",
        "public void setNullKeySerializer(JsonSerializer<Object> nks)",
        "public final SerializationConfig getConfig()",
        "public final AnnotationIntrospector getAnnotationIntrospector()",
        "public final TypeFactory getTypeFactory()",
        "public final Class<?> getActiveView()",
        "public final Class<?> getSerializationView()",
        "public final boolean canOverrideAccessModifiers()",
        "public final boolean isEnabled(MapperFeature feature)",
        "public final JsonFormat.Value getDefaultPropertyFormat(Class<?> baseType)",
        "public final JsonInclude.Value getDefaultPropertyInclusion(Class<?> baseType)",
        "public Locale getLocale()",
        "public TimeZone getTimeZone()",
        "public Object getAttribute(Object key)",
        "public SerializerProvider setAttribute(Object key, Object value)",
        "public final boolean isEnabled(SerializationFeature feature)",
        "public final boolean hasSerializationFeatures(int featureMask)",
        "public final FilterProvider getFilterProvider()",
        "public JsonGenerator getGenerator()",
        "public abstract WritableObjectId findObjectId(Object forPojo, ObjectIdGenerator<?> generatorType); @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> findValueSerializer(Class<?> valueType, BeanProperty property) throws JsonMappingException",
        "public JsonSerializer<Object> findValueSerializer(JavaType valueType, BeanProperty property) throws JsonMappingException",
        "public JsonSerializer<Object> findValueSerializer(Class<?> valueType) throws JsonMappingException",
        "public JsonSerializer<Object> findValueSerializer(JavaType valueType) throws JsonMappingException",
        "public JsonSerializer<Object> findPrimaryPropertySerializer(JavaType valueType, BeanProperty property) throws JsonMappingException",
        "public JsonSerializer<Object> findPrimaryPropertySerializer(Class<?> valueType, BeanProperty property) throws JsonMappingException",
        "public JsonSerializer<Object> findTypedValueSerializer(Class<?> valueType, boolean cache, BeanProperty property) throws JsonMappingException",
        "public JsonSerializer<Object> findTypedValueSerializer(JavaType valueType, boolean cache, BeanProperty property) throws JsonMappingException",
        "public TypeSerializer findTypeSerializer(JavaType javaType) throws JsonMappingException",
        "public JsonSerializer<Object> findKeySerializer(JavaType keyType, BeanProperty property) throws JsonMappingException",
        "public JsonSerializer<Object> findKeySerializer(Class<?> rawKeyType, BeanProperty property) throws JsonMappingException",
        "public JsonSerializer<Object> getDefaultNullKeySerializer()",
        "public JsonSerializer<Object> getDefaultNullValueSerializer()",
        "public JsonSerializer<Object> findNullKeySerializer(JavaType serializationType, BeanProperty property) throws JsonMappingException",
        "public JsonSerializer<Object> findNullValueSerializer(BeanProperty property) throws JsonMappingException",
        "public JsonSerializer<Object> getUnknownTypeSerializer(Class<?> unknownType)",
        "public boolean isUnknownTypeSerializer(JsonSerializer<?> ser)",
        "public abstract JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException; public abstract Object includeFilterInstance(BeanPropertyDefinition forProperty, Class<?> filterClass) throws JsonMappingException; public abstract boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException; public JsonSerializer<?> handlePrimaryContextualization(JsonSerializer<?> ser, BeanProperty property) throws JsonMappingException",
        "public JsonSerializer<?> handleSecondaryContextualization(JsonSerializer<?> ser, BeanProperty property) throws JsonMappingException",
        "public final void defaultSerializeValue(Object value, JsonGenerator gen) throws IOException",
        "public final void defaultSerializeField(String fieldName, Object value, JsonGenerator gen) throws IOException",
        "public final void defaultSerializeDateValue(long timestamp, JsonGenerator gen) throws IOException",
        "public final void defaultSerializeDateValue(Date date, JsonGenerator gen) throws IOException",
        "public void defaultSerializeDateKey(long timestamp, JsonGenerator gen) throws IOException",
        "public void defaultSerializeDateKey(Date date, JsonGenerator gen) throws IOException",
        "public final void defaultSerializeNull(JsonGenerator gen) throws IOException",
        "public void reportMappingProblem(String message, Object... args) throws JsonMappingException",
        "public <T> T reportBadTypeDefinition(BeanDescription bean, String msg, Object... msgArgs) throws JsonMappingException",
        "public <T> T reportBadPropertyDefinition(BeanDescription bean, BeanPropertyDefinition prop, String message, Object... msgArgs) throws JsonMappingException",
        "public <T> T reportBadDefinition(JavaType type, String msg) throws JsonMappingException",
        "public <T> T reportBadDefinition(JavaType type, String msg, Throwable cause) throws JsonMappingException",
        "public <T> T reportBadDefinition(Class<?> raw, String msg, Throwable cause) throws JsonMappingException",
        "public void reportMappingProblem(Throwable t, String message, Object... msgArgs) throws JsonMappingException",
        "public JsonMappingException invalidTypeIdException(JavaType baseType, String typeId, String extraDesc)",
        "public JsonMappingException mappingException(String message, Object... msgArgs)",
        "protected JsonMappingException mappingException(Throwable t, String message, Object... msgArgs)",
        "protected void _reportIncompatibleRootType(Object value, JavaType rootType) throws IOException",
        "protected JsonSerializer<Object> _findExplicitUntypedSerializer(Class<?> runtimeType) throws JsonMappingException",
        "protected JsonSerializer<Object> _createAndCacheUntypedSerializer(Class<?> rawType) throws JsonMappingException",
        "protected JsonSerializer<Object> _createAndCacheUntypedSerializer(JavaType type) throws JsonMappingException",
        "protected JsonSerializer<Object> _createUntypedSerializer(JavaType type) throws JsonMappingException",
        "synchronized (_serializerCache)",
        "protected JsonSerializer<Object> _handleContextualResolvable(JsonSerializer<?> ser, BeanProperty property) throws JsonMappingException",
        "protected JsonSerializer<Object> _handleResolvable(JsonSerializer<?> ser) throws JsonMappingException",
        "protected final DateFormat _dateFormat()"
      ],
      "fixed_signatures": [
        "protected SerializerProvider(SerializerProvider src, SerializationConfig config, SerializerFactory f)",
        "protected SerializerProvider(SerializerProvider src)",
        "public void setDefaultKeySerializer(JsonSerializer<Object> ks)",
        "public void setNullValueSerializer(JsonSerializer<Object> nvs)",
        "public void setNullKeySerializer(JsonSerializer<Object> nks)",
        "public final SerializationConfig getConfig()",
        "public final AnnotationIntrospector getAnnotationIntrospector()",
        "public final TypeFactory getTypeFactory()",
        "public final Class<?> getActiveView()",
        "public final Class<?> getSerializationView()",
        "public final boolean canOverrideAccessModifiers()",
        "public final boolean isEnabled(MapperFeature feature)",
        "public final JsonFormat.Value getDefaultPropertyFormat(Class<?> baseType)",
        "public final JsonInclude.Value getDefaultPropertyInclusion(Class<?> baseType)",
        "public Locale getLocale()",
        "public TimeZone getTimeZone()",
        "public Object getAttribute(Object key)",
        "public SerializerProvider setAttribute(Object key, Object value)",
        "public final boolean isEnabled(SerializationFeature feature)",
        "public final boolean hasSerializationFeatures(int featureMask)",
        "public final FilterProvider getFilterProvider()",
        "public JsonGenerator getGenerator()",
        "public abstract WritableObjectId findObjectId(Object forPojo, ObjectIdGenerator<?> generatorType); @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> findValueSerializer(Class<?> valueType, BeanProperty property) throws JsonMappingException",
        "public JsonSerializer<Object> findValueSerializer(JavaType valueType, BeanProperty property) throws JsonMappingException",
        "public JsonSerializer<Object> findValueSerializer(Class<?> valueType) throws JsonMappingException",
        "public JsonSerializer<Object> findValueSerializer(JavaType valueType) throws JsonMappingException",
        "public JsonSerializer<Object> findPrimaryPropertySerializer(JavaType valueType, BeanProperty property) throws JsonMappingException",
        "public JsonSerializer<Object> findPrimaryPropertySerializer(Class<?> valueType, BeanProperty property) throws JsonMappingException",
        "public JsonSerializer<Object> findTypedValueSerializer(Class<?> valueType, boolean cache, BeanProperty property) throws JsonMappingException",
        "public JsonSerializer<Object> findTypedValueSerializer(JavaType valueType, boolean cache, BeanProperty property) throws JsonMappingException",
        "public TypeSerializer findTypeSerializer(JavaType javaType) throws JsonMappingException",
        "public JsonSerializer<Object> findKeySerializer(JavaType keyType, BeanProperty property) throws JsonMappingException",
        "public JsonSerializer<Object> findKeySerializer(Class<?> rawKeyType, BeanProperty property) throws JsonMappingException",
        "public JsonSerializer<Object> getDefaultNullKeySerializer()",
        "public JsonSerializer<Object> getDefaultNullValueSerializer()",
        "public JsonSerializer<Object> findNullKeySerializer(JavaType serializationType, BeanProperty property) throws JsonMappingException",
        "public JsonSerializer<Object> findNullValueSerializer(BeanProperty property) throws JsonMappingException",
        "public JsonSerializer<Object> getUnknownTypeSerializer(Class<?> unknownType)",
        "public boolean isUnknownTypeSerializer(JsonSerializer<?> ser)",
        "public abstract JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException; public abstract Object includeFilterInstance(BeanPropertyDefinition forProperty, Class<?> filterClass) throws JsonMappingException; public abstract boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException; public JsonSerializer<?> handlePrimaryContextualization(JsonSerializer<?> ser, BeanProperty property) throws JsonMappingException",
        "public JsonSerializer<?> handleSecondaryContextualization(JsonSerializer<?> ser, BeanProperty property) throws JsonMappingException",
        "public final void defaultSerializeValue(Object value, JsonGenerator gen) throws IOException",
        "public final void defaultSerializeField(String fieldName, Object value, JsonGenerator gen) throws IOException",
        "public final void defaultSerializeDateValue(long timestamp, JsonGenerator gen) throws IOException",
        "public final void defaultSerializeDateValue(Date date, JsonGenerator gen) throws IOException",
        "public void defaultSerializeDateKey(long timestamp, JsonGenerator gen) throws IOException",
        "public void defaultSerializeDateKey(Date date, JsonGenerator gen) throws IOException",
        "public final void defaultSerializeNull(JsonGenerator gen) throws IOException",
        "public void reportMappingProblem(String message, Object... args) throws JsonMappingException",
        "public <T> T reportBadTypeDefinition(BeanDescription bean, String msg, Object... msgArgs) throws JsonMappingException",
        "public <T> T reportBadPropertyDefinition(BeanDescription bean, BeanPropertyDefinition prop, String message, Object... msgArgs) throws JsonMappingException",
        "public <T> T reportBadDefinition(JavaType type, String msg) throws JsonMappingException",
        "public <T> T reportBadDefinition(JavaType type, String msg, Throwable cause) throws JsonMappingException",
        "public <T> T reportBadDefinition(Class<?> raw, String msg, Throwable cause) throws JsonMappingException",
        "public void reportMappingProblem(Throwable t, String message, Object... msgArgs) throws JsonMappingException",
        "public JsonMappingException invalidTypeIdException(JavaType baseType, String typeId, String extraDesc)",
        "public JsonMappingException mappingException(String message, Object... msgArgs)",
        "protected JsonMappingException mappingException(Throwable t, String message, Object... msgArgs)",
        "protected void _reportIncompatibleRootType(Object value, JavaType rootType) throws IOException",
        "protected JsonSerializer<Object> _findExplicitUntypedSerializer(Class<?> runtimeType) throws JsonMappingException",
        "protected JsonSerializer<Object> _createAndCacheUntypedSerializer(Class<?> rawType) throws JsonMappingException",
        "protected JsonSerializer<Object> _createAndCacheUntypedSerializer(JavaType type) throws JsonMappingException",
        "protected JsonSerializer<Object> _createUntypedSerializer(JavaType type) throws JsonMappingException",
        "synchronized (_serializerCache)",
        "protected JsonSerializer<Object> _handleContextualResolvable(JsonSerializer<?> ser, BeanProperty property) throws JsonMappingException",
        "protected JsonSerializer<Object> _handleResolvable(JsonSerializer<?> ser) throws JsonMappingException",
        "protected final DateFormat _dateFormat()"
      ],
      "methods": [
        {
          "buggy_method": "  protected JsonSerializer<Object> _createAndCacheUntypedSerializer(Class<?> rawType) throws JsonMappingException {\n  JavaType fullType = _config.constructType(rawType);\n  JsonSerializer<Object> ser;\n  try {\n  ser = _createUntypedSerializer(fullType);\n  } catch (IllegalArgumentException iae) {\n  \n  \n  ser = null; \n  reportMappingProblem(iae, iae.getMessage());\n  }\n\n  if (ser != null) {\n  \n  _serializerCache.addAndResolveNonTypedSerializer(rawType, fullType, ser, this);\n  }\n  return ser;\n  }",
          "fixed_method": "  protected JsonSerializer<Object> _createAndCacheUntypedSerializer(Class<?> rawType) throws JsonMappingException {\n  JavaType fullType = _config.constructType(rawType);\n  JsonSerializer<Object> ser;\n  try {\n  ser = _createUntypedSerializer(fullType);\n  } catch (IllegalArgumentException iae) {\n  \n  \n  ser = null; \n  reportMappingProblem(iae, ClassUtil.exceptionMessage(iae));\n  }\n\n  if (ser != null) {\n  \n  _serializerCache.addAndResolveNonTypedSerializer(rawType, fullType, ser, this);\n  }\n  return ser;\n  }",
          "diff": [
            "@@ -1338,7 +1338,7 @@",
            "             // We better only expose checked exceptions, since those\n",
            "             // are what caller is expected to handle\n",
            "             ser = null; // doesn't matter but compiler whines otherwise\n",
            "-            reportMappingProblem(iae, iae.getMessage());\n",
            "+            reportMappingProblem(iae, ClassUtil.exceptionMessage(iae));\n",
            "         }\n",
            " \n",
            "         if (ser != null) {\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  protected JsonSerializer<Object> _createAndCacheUntypedSerializer(JavaType type) throws JsonMappingException {  \n  JsonSerializer<Object> ser;\n  try {\n  ser = _createUntypedSerializer(type);\n  } catch (IllegalArgumentException iae) {\n  \n  \n  ser = null;\n  reportMappingProblem(iae, iae.getMessage());\n  }\n  \n  if (ser != null) {\n  \n  _serializerCache.addAndResolveNonTypedSerializer(type, ser, this);\n  }\n  return ser;\n  }",
          "fixed_method": "  protected JsonSerializer<Object> _createAndCacheUntypedSerializer(JavaType type) throws JsonMappingException {  \n  JsonSerializer<Object> ser;\n  try {\n  ser = _createUntypedSerializer(type);\n  } catch (IllegalArgumentException iae) {\n  \n  \n  ser = null;\n  reportMappingProblem(iae, ClassUtil.exceptionMessage(iae));\n  }\n  \n  if (ser != null) {\n  \n  _serializerCache.addAndResolveNonTypedSerializer(type, ser, this);\n  }\n  return ser;\n  }",
          "diff": [
            "@@ -1358,7 +1358,7 @@",
            "             // We better only expose checked exceptions, since those\n",
            "             // are what caller is expected to handle\n",
            "             ser = null;\n",
            "-            reportMappingProblem(iae, iae.getMessage());\n",
            "+            reportMappingProblem(iae, ClassUtil.exceptionMessage(iae));\n",
            "         }\n",
            "     \n",
            "         if (ser != null) {\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.deser;\n\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.JacksonInject;\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonCreator.Mode;\nimport com.fasterxml.jackson.core.JsonLocation;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.deser.impl.CreatorCandidate;\nimport com.fasterxml.jackson.databind.deser.impl.CreatorCollector;\nimport com.fasterxml.jackson.databind.deser.impl.JavaUtilCollectionsDeserializers;\nimport com.fasterxml.jackson.databind.deser.std.*;\nimport com.fasterxml.jackson.databind.exc.InvalidDefinitionException;\nimport com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.*;\n\n\n@SuppressWarnings(\"serial\")\npublic abstract class BasicDeserializerFactory extends DeserializerFactory implements java.io.Serializable { private final static Class<?> CLASS_OBJECT = Object.class; private final static Class<?> CLASS_STRING = String.class; private final static Class<?> CLASS_CHAR_SEQUENCE = CharSequence.class; private final static Class<?> CLASS_ITERABLE = Iterable.class; private final static Class<?> CLASS_MAP_ENTRY = Map.Entry.class; protected final static PropertyName UNWRAPPED_CREATOR_PARAM_NAME = new PropertyName(\"@JsonUnwrapped\"); @SuppressWarnings(\"rawtypes\") final static HashMap<String, Class<? extends Map>> _mapFallbacks = new HashMap<String, Class<? extends Map>>(); static {\n        _mapFallbacks.put(Map.class.getName(), LinkedHashMap.class);\n        _mapFallbacks.put(ConcurrentMap.class.getName(), ConcurrentHashMap.class);\n        _mapFallbacks.put(SortedMap.class.getName(), TreeMap.class);\n\n        _mapFallbacks.put(java.util.NavigableMap.class.getName(), TreeMap.class);\n        _mapFallbacks.put(java.util.concurrent.ConcurrentNavigableMap.class.getName(),\n                java.util.concurrent.ConcurrentSkipListMap.class);\n    }\n\n    \n    @SuppressWarnings(\"rawtypes\")\n    final static HashMap<String, Class<? extends Collection>> _collectionFallbacks = new HashMap<String, Class<? extends Collection>>(); static {\n        _collectionFallbacks.put(Collection.class.getName(), ArrayList.class);\n        _collectionFallbacks.put(List.class.getName(), ArrayList.class);\n        _collectionFallbacks.put(Set.class.getName(), HashSet.class);\n        _collectionFallbacks.put(SortedSet.class.getName(), TreeSet.class);\n        _collectionFallbacks.put(Queue.class.getName(), LinkedList.class);\n\n        \n        \n        _collectionFallbacks.put(\"java.util.Deque\", LinkedList.class);\n        _collectionFallbacks.put(\"java.util.NavigableSet\", TreeSet.class);\n    }\n\n    \n    \n    \n    protected final DeserializerFactoryConfig _factoryConfig; protected BasicDeserializerFactory(DeserializerFactoryConfig config) {\n        _factoryConfig = config;\n    }\n    \n    \n    public DeserializerFactoryConfig getFactoryConfig() {\n        return _factoryConfig;\n    }\n\n    protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); @Override public final DeserializerFactory withAdditionalDeserializers(Deserializers additional) {\n        return withConfig(_factoryConfig.withAdditionalDeserializers(additional));\n    }\n\n    \n    @Override\n    public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional) {\n        return withConfig(_factoryConfig.withAdditionalKeyDeserializers(additional));\n    }\n    \n    \n    @Override\n    public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier) {\n        return withConfig(_factoryConfig.withDeserializerModifier(modifier));\n    }\n\n    \n    @Override\n    public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver) {\n        return withConfig(_factoryConfig.withAbstractTypeResolver(resolver));\n    }\n\n    \n    @Override\n    public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators) {\n        return withConfig(_factoryConfig.withValueInstantiators(instantiators));\n    }\n\n    \n\n    @Override\n    public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException {\n        \n        while (true) {\n            JavaType next = _mapAbstractType2(config, type);\n            if (next == null) {\n                return type;\n            }\n            \n            \n            Class<?> prevCls = type.getRawClass();\n            Class<?> nextCls = next.getRawClass();\n            if ((prevCls == nextCls) || !prevCls.isAssignableFrom(nextCls)) {\n                throw new IllegalArgumentException(\"Invalid abstract type resolution from \"+type+\" to \"+next+\": latter is not a subtype of former\"); } type = next; } } private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) throws JsonMappingException {\n        Class<?> currClass = type.getRawClass();\n        if (_factoryConfig.hasAbstractTypeResolvers()) {\n            for (AbstractTypeResolver resolver : _factoryConfig.abstractTypeResolvers()) {\n                JavaType concrete = resolver.findTypeMapping(config, type);\n                if ((concrete != null) && !concrete.hasRawClass(currClass)) {\n                    return concrete;\n                }\n            }\n        }\n        return null;\n    }\n\n    \n\n    \n    @Override\n    public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n\n        ValueInstantiator instantiator = null;\n        \n        AnnotatedClass ac = beanDesc.getClassInfo();\n        Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac);\n        if (instDef != null) {\n            instantiator = _valueInstantiatorInstance(config, ac, instDef);\n        }\n        if (instantiator == null) {\n            \n            \n            instantiator = _findStdValueInstantiator(config, beanDesc);\n            if (instantiator == null) {\n                instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc);\n            }\n        }\n\n        \n        if (_factoryConfig.hasValueInstantiators()) {\n            for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) {\n                instantiator = insts.findValueInstantiator(config, beanDesc, instantiator);\n                \n                if (instantiator == null) {\n                    ctxt.reportBadTypeDefinition(beanDesc,\n\t\t\t\t\t\t\"Broken registered ValueInstantiators (of type %s): returned null ValueInstantiator\",\n\t\t\t\t\t\tinsts.getClass().getName());\n                }\n            }\n        }\n\n        \n        if (instantiator.getIncompleteParameter() != null) {\n            final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter();\n            final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner();\n            throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()\n                +\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n        }\n\n        return instantiator;\n    }\n\n    private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        Class<?> raw = beanDesc.getBeanClass();\n        if (raw == JsonLocation.class) {\n            return new JsonLocationInstantiator();\n        }\n        \n        if (Collection.class.isAssignableFrom(raw)) {\n            if (Collections.EMPTY_SET.getClass() == raw) {\n                return new ConstantValueInstantiator(Collections.EMPTY_SET);\n            }\n            if (Collections.EMPTY_LIST.getClass() == raw) {\n                return new ConstantValueInstantiator(Collections.EMPTY_LIST);\n            }\n        } else if (Map.class.isAssignableFrom(raw)) {\n            if (Collections.EMPTY_MAP.getClass() == raw) {\n                return new ConstantValueInstantiator(Collections.EMPTY_MAP);\n            }\n        }\n        return null;\n    }\n\n    \n    protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException {\n        CreatorCollector creators = new CreatorCollector(beanDesc, ctxt.getConfig());\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        \n        \n        final DeserializationConfig config = ctxt.getConfig();\n        VisibilityChecker<?> vchecker = config.getDefaultVisibilityChecker(beanDesc.getBeanClass(),\n                beanDesc.getClassInfo());\n\n        \n        \n        Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorDefs = _findCreatorsFromProperties(ctxt,\n                beanDesc);\n        \n        \n        _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n        \n        if (beanDesc.getType().isConcrete()) {\n            _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n        }\n        return creators.constructValueInstantiator(ctxt);\n    }\n\n    protected Map<AnnotatedWithParams,BeanPropertyDefinition[]> _findCreatorsFromProperties(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException {\n        Map<AnnotatedWithParams,BeanPropertyDefinition[]> result = Collections.emptyMap();\n        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {\n            Iterator<AnnotatedParameter> it = propDef.getConstructorParameters();\n            while (it.hasNext()) {\n                AnnotatedParameter param = it.next();\n                AnnotatedWithParams owner = param.getOwner();\n                BeanPropertyDefinition[] defs = result.get(owner);\n                final int index = param.getIndex();\n                \n                if (defs == null) {\n                    if (result.isEmpty()) { \n                        result = new LinkedHashMap<AnnotatedWithParams,BeanPropertyDefinition[]>();\n                    }\n                    defs = new BeanPropertyDefinition[owner.getParameterCount()];\n                    result.put(owner, defs);\n                } else {\n                    if (defs[index] != null) {\n                        ctxt.reportBadTypeDefinition(beanDesc,\n\"Conflict: parameter #%d of %s bound to more than one property; %s vs %s\",\nindex, owner, defs[index], propDef);\n                    }\n                }\n                defs[index] = propDef;\n            }\n        }\n        return result;\n    }\n    \n    public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException {\n        if (instDef == null) {\n            return null;\n        }\n\n        ValueInstantiator inst;\n        \n        if (instDef instanceof ValueInstantiator) {\n            return (ValueInstantiator) instDef;\n        }\n        if (!(instDef instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned key deserializer definition of type \"\n                    +instDef.getClass().getName()\n                    +\"; expected type KeyDeserializer or Class<KeyDeserializer> instead\");\n        }\n        Class<?> instClass = (Class<?>)instDef;\n        if (ClassUtil.isBogusClass(instClass)) {\n            return null;\n        }\n        if (!ValueInstantiator.class.isAssignableFrom(instClass)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+instClass.getName()\n                    +\"; expected Class<ValueInstantiator>\");\n        }\n        HandlerInstantiator hi = config.getHandlerInstantiator();\n        if (hi != null) {\n            inst = hi.valueInstantiatorInstance(config, annotated, instClass);\n            if (inst != null) {\n                return inst;\n            }\n        }\n        return (ValueInstantiator) ClassUtil.createInstance(instClass,\n                config.canOverrideAccessModifiers());\n    }\n\n    \n\n    protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException {\n        \n        \n        \n        final boolean isNonStaticInnerClass = beanDesc.isNonStaticInnerClass();\n        if (isNonStaticInnerClass) {\n            \n            return;\n        }\n\n        \n        \n        \n        AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor();\n        if (defaultCtor != null) {\n            if (!creators.hasDefaultCreator() || _hasCreatorAnnotation(ctxt, defaultCtor)) {\n                creators.setDefaultCreator(defaultCtor);\n            }\n        }\n        \n        List<CreatorCandidate> nonAnnotated = new LinkedList<>();\n        int explCount = 0;\n        for (AnnotatedConstructor ctor : beanDesc.getConstructors()) {\n            JsonCreator.Mode creatorMode = intr.findCreatorAnnotation(ctxt.getConfig(), ctor);\n            if (Mode.DISABLED == creatorMode) {\n                continue;\n            }\n            if (creatorMode == null) {\n                \n                if (vchecker.isCreatorVisible(ctor)) {\n                    nonAnnotated.add(CreatorCandidate.construct(intr, ctor, creatorParams.get(ctor)));\n                }\n                continue;\n            }\n            switch (creatorMode) {\n            case DELEGATING:\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators,\n                        CreatorCandidate.construct(intr, ctor, null));\n                break;\n            case PROPERTIES:\n                _addExplicitPropertyCreator(ctxt, beanDesc, creators,\n                        CreatorCandidate.construct(intr, ctor, creatorParams.get(ctor)));\n                break;\n            default:\n                _addExplicitAnyCreator(ctxt, beanDesc, creators,\n                        CreatorCandidate.construct(intr, ctor, creatorParams.get(ctor)));\n                break;\n            }\n            ++explCount;\n        }\n        \n        if (explCount > 0) { \n            return;\n        }\n        List<AnnotatedWithParams> implicitCtors = null;\n        for (CreatorCandidate candidate : nonAnnotated) {\n            final int argCount = candidate.paramCount();\n            final AnnotatedWithParams ctor = candidate.creator();\n\n            \n            if (argCount == 1) {\n                BeanPropertyDefinition propDef = candidate.propertyDef(0);\n                boolean useProps = _checkIfCreatorPropertyBased(intr, ctor, propDef);\n\n                if (useProps) {\n                    SettableBeanProperty[] properties = new SettableBeanProperty[1];\n                    PropertyName name = candidate.paramName(0);\n                    properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0,\n                            candidate.parameter(0), candidate.injection(0));\n                    creators.addPropertyCreator(ctor, false, properties);\n                } else {\n                     _handleSingleArgumentCreator(creators,\n                            ctor, false,\n                            vchecker.isCreatorVisible(ctor));\n                    \n                    \n                    if (propDef != null) {\n                        ((POJOPropertyBuilder) propDef).removeConstructors();\n                    }\n                }\n                \n                continue;\n            }\n\n            \n            \n            \n\n            int nonAnnotatedParamIndex = -1;\n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            int explicitNameCount = 0;\n            int implicitWithCreatorCount = 0;\n            int injectCount = 0;\n\n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = ctor.getParameter(i);\n                BeanPropertyDefinition propDef = candidate.propertyDef(i);\n                JacksonInject.Value injectId = intr.findInjectableValue(param);\n                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n\n                if (propDef != null && propDef.isExplicitlyNamed()) {\n                    ++explicitNameCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                if (injectId != null) {\n                    ++injectCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    _reportUnwrappedCreatorProperty(ctxt, beanDesc, param);\n                    \n                    continue;\n                }\n                \n                \n                if (nonAnnotatedParamIndex < 0) {\n                    nonAnnotatedParamIndex = i;\n                }\n            }\n\n            final int namedCount = explicitNameCount + implicitWithCreatorCount;\n            \n            if ((explicitNameCount > 0) || (injectCount > 0)) {\n                \n                if ((namedCount + injectCount) == argCount) {\n                    creators.addPropertyCreator(ctor, false, properties);\n                    continue;\n                }\n                if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                    \n                    creators.addDelegatingCreator(ctor, false, properties, 0);\n                    continue;\n                }\n                \n                \n                \n                PropertyName impl = candidate.findImplicitParamName(nonAnnotatedParamIndex);\n                if (impl == null || impl.isEmpty()) {\n                    \n                    \n                    \n                    ctxt.reportBadTypeDefinition(beanDesc,\n\"Argument #%d of constructor %s has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\",\nnonAnnotatedParamIndex, ctor);\n                }\n            }\n            \n            if (!creators.hasDefaultCreator()) {\n                if (implicitCtors == null) {\n                    implicitCtors = new LinkedList<>();\n                }\n                implicitCtors.add(ctor);\n            }\n        }\n        \n        \n        if ((implicitCtors != null) && !creators.hasDelegatingCreator()\n                && !creators.hasPropertyBasedCreator()) {\n            _checkImplicitlyNamedConstructors(ctxt, beanDesc, vchecker, intr,\n                    creators, implicitCtors);\n        }\n    }\n\n    \n    protected void _addExplicitDelegatingCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException {\n        \n        \n\n        int ix = -1;\n        final int argCount = candidate.paramCount();\n        SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n        for (int i = 0; i < argCount; ++i) {\n            AnnotatedParameter param = candidate.parameter(i);\n            JacksonInject.Value injectId = candidate.injection(i);\n            if (injectId != null) {\n                properties[i] = constructCreatorProperty(ctxt, beanDesc, null, i, param, injectId);\n                continue;\n            }\n            if (ix < 0) {\n                ix = i;\n                continue;\n            }\n            \n            ctxt.reportBadTypeDefinition(beanDesc,\n                    \"More than one argument (#%d and #%d) left as delegating for Creator %s: only one allowed\",\n                    ix, i, candidate);\n        }\n        \n        if (ix < 0) {\n            ctxt.reportBadTypeDefinition(beanDesc,\n                    \"No argument left as delegating for Creator %s: exactly one required\", candidate);\n        }\n        \n        \n        if (argCount == 1) {\n            _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n            \n            \n            BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n            if (paramDef != null) {\n                ((POJOPropertyBuilder) paramDef).removeConstructors();\n            }\n            return;\n        }\n        creators.addDelegatingCreator(candidate.creator(), true, properties, ix);\n    }\n\n    \n    protected void _addExplicitPropertyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException {\n        final int paramCount = candidate.paramCount();\n        SettableBeanProperty[] properties = new SettableBeanProperty[paramCount];\n\n        for (int i = 0; i < paramCount; ++i) {\n            JacksonInject.Value injectId = candidate.injection(i);\n            AnnotatedParameter param = candidate.parameter(i);\n            PropertyName name = candidate.paramName(i);\n            if (name == null) {\n                \n                \n                NameTransformer unwrapper = ctxt.getAnnotationIntrospector().findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    _reportUnwrappedCreatorProperty(ctxt, beanDesc, param);\n                    \n                }\n                name = candidate.findImplicitParamName(i);\n                \n                if ((name == null) && (injectId == null)) {\n                    ctxt.reportBadTypeDefinition(beanDesc,\n\"Argument #%d has no property name, is not Injectable: can not use as Creator %s\", i, candidate);\n                }\n            }\n            properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n        }\n        creators.addPropertyCreator(candidate.creator(), true, properties);\n    }\n\n    \n    protected void _addExplicitAnyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException {\n        \n        if (1 != candidate.paramCount()) {\n            \n            \n            int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n            if (oneNotInjected >= 0) {\n                \n                if (candidate.paramName(oneNotInjected) == null) {\n                    _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                    return;\n                }\n            }\n            _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n            return;\n        }\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n\n        \n        boolean useProps = (paramName != null) || (injectId != null);\n        if (!useProps && (paramDef != null)) {\n            \n            \n\n            \n            \n\n            paramName = candidate.paramName(0);\n            useProps = (paramName != null) && paramDef.couldSerialize();\n        }\n        if (useProps) {\n            SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                    constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n            };\n            creators.addPropertyCreator(candidate.creator(), true, properties);\n            return;\n        }\n        _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n\n        \n        \n        if (paramDef != null) {\n            ((POJOPropertyBuilder) paramDef).removeConstructors();\n        }\n    }\n\n    private boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr, AnnotatedWithParams creator, BeanPropertyDefinition propDef) {\n        \n        if (((propDef != null) && propDef.isExplicitlyNamed())\n                || (intr.findInjectableValue(creator.getParameter(0)) != null)) {\n            return true;\n        }\n        if (propDef != null) {\n            \n            \n            String implName = propDef.getName();\n            if (implName != null && !implName.isEmpty()) {\n                if (propDef.couldSerialize()) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n\n    private void _checkImplicitlyNamedConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, List<AnnotatedWithParams> implicitCtors) throws JsonMappingException {\n        AnnotatedWithParams found = null;\n        SettableBeanProperty[] foundProps = null;\n\n        \n        \n        \n\n        main_loop:\n        for (AnnotatedWithParams ctor : implicitCtors) {\n            if (!vchecker.isCreatorVisible(ctor)) {\n                continue;\n            }\n            \n            final int argCount = ctor.getParameterCount();\n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = ctor.getParameter(i);\n                final PropertyName name = _findParamName(param, intr);\n\n                \n                if (name == null || name.isEmpty()) {\n                    continue main_loop;\n                }\n                properties[i] = constructCreatorProperty(ctxt, beanDesc, name, param.getIndex(),\n                        param,  null);\n            }\n            if (found != null) { \n                found = null;\n                break;\n            }\n            found = ctor;\n            foundProps = properties;\n        }\n        \n        if (found != null) {\n            creators.addPropertyCreator(found,  false, foundProps);\n            BasicBeanDescription bbd = (BasicBeanDescription) beanDesc;\n            \n            for (SettableBeanProperty prop : foundProps) {\n                PropertyName pn = prop.getFullName();\n                if (!bbd.hasProperty(pn)) {\n                    BeanPropertyDefinition newDef = SimpleBeanPropertyDefinition.construct(\n                            ctxt.getConfig(), prop.getMember(), pn);\n                    bbd.addProperty(newDef);\n                }\n            }\n        }\n    }\n\n    protected void _addDeserializerFactoryMethods (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException {\n        List<CreatorCandidate> nonAnnotated = new LinkedList<>();\n        int explCount = 0;\n\n        \n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            JsonCreator.Mode creatorMode = intr.findCreatorAnnotation(ctxt.getConfig(), factory);\n            final int argCount = factory.getParameterCount();\n            if (creatorMode == null) {\n                \n                if ((argCount == 1) && vchecker.isCreatorVisible(factory)) {\n                    nonAnnotated.add(CreatorCandidate.construct(intr, factory, null));\n                }\n                continue;\n            }\n            if (creatorMode == Mode.DISABLED) {\n                continue;\n            }\n            \n            \n            if (argCount == 0) {\n                creators.setDefaultCreator(factory);\n                continue;\n            }\n\n            switch (creatorMode) {\n            case DELEGATING:\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators,\n                        CreatorCandidate.construct(intr, factory, null));\n                break;\n            case PROPERTIES:\n                _addExplicitPropertyCreator(ctxt, beanDesc, creators,\n                        CreatorCandidate.construct(intr, factory, creatorParams.get(factory)));\n                break;\n            case DEFAULT:\n            default:\n                _addExplicitAnyCreator(ctxt, beanDesc, creators,\n                        CreatorCandidate.construct(intr, factory, creatorParams.get(factory)));\n                break;\n            }\n            ++explCount;\n        }\n        \n        if (explCount > 0) { \n            return;\n        }\n        \n        for (CreatorCandidate candidate : nonAnnotated) {\n            final int argCount = candidate.paramCount();\n            AnnotatedWithParams factory = candidate.creator();\n            final BeanPropertyDefinition[] propDefs = creatorParams.get(factory);\n            \n            if (argCount != 1) {\n                continue; \n            }\n            BeanPropertyDefinition argDef = candidate.propertyDef(0);\n            boolean useProps = _checkIfCreatorPropertyBased(intr, factory, argDef);\n            if (!useProps) { \n                 _handleSingleArgumentCreator(creators,\n                        factory, false, vchecker.isCreatorVisible(factory));\n                \n                \n                if (argDef != null) {\n                    ((POJOPropertyBuilder) argDef).removeConstructors();\n                }\n                continue;\n            }\n            AnnotatedParameter nonAnnotatedParam = null;            \n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            int implicitNameCount = 0;\n            int explicitNameCount = 0;\n            int injectCount = 0;\n            \n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = factory.getParameter(i);\n                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i];\n                JacksonInject.Value injectable = intr.findInjectableValue(param);\n                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n\n                if (propDef != null && propDef.isExplicitlyNamed()) {\n                    ++explicitNameCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectable);\n                    continue;\n                }\n                if (injectable != null) {\n                    ++injectCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectable);\n                    continue;\n                }\n                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    _reportUnwrappedCreatorProperty(ctxt, beanDesc, param);\n                    \n                    continue;\n                }\n                \n                \n                \n                \n                if (nonAnnotatedParam == null) {\n                    nonAnnotatedParam = param;\n                }\n            }\n            final int namedCount = explicitNameCount + implicitNameCount;\n            \n            \n            if (explicitNameCount > 0 || injectCount > 0) {\n                \n                if ((namedCount + injectCount) == argCount) {\n                    creators.addPropertyCreator(factory, false, properties);\n                } else if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                    \n                    creators.addDelegatingCreator(factory, false, properties, 0);\n                } else { \n                    ctxt.reportBadTypeDefinition(beanDesc,\n\"Argument #%d of factory method %s has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\",\n                    nonAnnotatedParam.getIndex(), factory);\n                }\n            }\n        }\n    }\n\n    protected boolean _handleSingleArgumentCreator(CreatorCollector creators, AnnotatedWithParams ctor, boolean isCreator, boolean isVisible) {\n        \n        Class<?> type = ctor.getRawParameterType(0);\n        if (type == String.class || type == CLASS_CHAR_SEQUENCE) {\n            if (isCreator || isVisible) {\n                creators.addStringCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == int.class || type == Integer.class) {\n            if (isCreator || isVisible) {\n                creators.addIntCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == long.class || type == Long.class) {\n            if (isCreator || isVisible) {\n                creators.addLongCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == double.class || type == Double.class) {\n            if (isCreator || isVisible) {\n                creators.addDoubleCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == boolean.class || type == Boolean.class) {\n            if (isCreator || isVisible) {\n                creators.addBooleanCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        \n        if (isCreator) {\n            creators.addDelegatingCreator(ctor, isCreator, null, 0);\n            return true;\n        }\n        return false;\n    }\n\n    \n    \n    protected void _reportUnwrappedCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedParameter param) throws JsonMappingException {\n        ctxt.reportBadDefinition(beanDesc.getType(), String.format(\n                \"Cannot define Creator parameter %d as `@JsonUnwrapped`: combination not yet supported\",\n                param.getIndex()));\n    }\n\n    \n    protected SettableBeanProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, PropertyName name, int index, AnnotatedParameter param, JacksonInject.Value injectable) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        PropertyMetadata metadata;\n        {\n            if (intr == null) {\n                metadata = PropertyMetadata.STD_REQUIRED_OR_OPTIONAL;\n            } else {\n                Boolean b = intr.hasRequiredMarker(param);\n                String desc = intr.findPropertyDescription(param);\n                Integer idx = intr.findPropertyIndex(param);\n                String def = intr.findPropertyDefaultValue(param);\n                metadata = PropertyMetadata.construct(b, desc, idx, def);\n            }\n        }\n        JavaType type = resolveMemberAndTypeAnnotations(ctxt, param, param.getType());\n        BeanProperty.Std property = new BeanProperty.Std(name, type,\n                intr.findWrapperName(param), param, metadata);\n        \n        TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler();\n        \n        if (typeDeser == null) {\n            typeDeser = findTypeDeserializer(config, type);\n        }\n        \n        \n\n        Object injectableValueId = (injectable == null) ? null : injectable.getId();\n        \n        SettableBeanProperty prop = new CreatorProperty(name, type, property.getWrapperName(),\n                typeDeser, beanDesc.getClassAnnotations(), param, index, injectableValueId,\n                metadata);\n        JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, param);\n        if (deser == null) {\n            deser = type.getValueHandler();\n        }\n        if (deser != null) {\n            \n            deser = ctxt.handlePrimaryContextualization(deser, prop, type);\n            prop = prop.withValueDeserializer(deser);\n        }\n        return prop;\n    }\n\n    private PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr) {\n        if (param != null && intr != null) {\n            PropertyName name = intr.findNameForDeserialization(param);\n            if (name != null) {\n                return name;\n            }\n            \n            \n\n            String str = intr.findImplicitPropertyName(param);\n            if (str != null && !str.isEmpty()) {\n                return PropertyName.construct(str);\n            }\n        }\n        return null;\n    }\n\n    \n        \n    @Override\n    public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        JavaType elemType = type.getContentType();\n        \n        \n        JsonDeserializer<Object> contentDeser = elemType.getValueHandler();\n        \n        TypeDeserializer elemTypeDeser = elemType.getTypeHandler();\n        \n        if (elemTypeDeser == null) {\n            elemTypeDeser = findTypeDeserializer(config, elemType);\n        }\n        \n        JsonDeserializer<?>  deser = _findCustomArrayDeserializer(type,\n                config, beanDesc, elemTypeDeser, contentDeser);\n        if (deser == null) {\n            if (contentDeser == null) {\n                Class<?> raw = elemType.getRawClass();\n                if (elemType.isPrimitive()) {\n                    return PrimitiveArrayDeserializers.forType(raw);\n                }\n                if (raw == String.class) {\n                    return StringArrayDeserializer.instance;\n                }\n            }\n            deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser);\n        }\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    \n\n    @Override\n    public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException {\n        JavaType contentType = type.getContentType();\n        \n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        \n        JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type,\n                config, beanDesc, contentTypeDeser, contentDeser);\n        if (deser == null) {\n            Class<?> collectionClass = type.getRawClass();\n            if (contentDeser == null) { \n                \n                if (EnumSet.class.isAssignableFrom(collectionClass)) {\n                    deser = new EnumSetDeserializer(contentType, null);\n                }\n            }\n        }\n\n        \n        if (deser == null) {\n            if (type.isInterface() || type.isAbstract()) {\n                CollectionType implType = _mapAbstractCollectionType(type, config);\n                if (implType == null) {\n                    \n                    if (type.getTypeHandler() == null) {\n                        throw new IllegalArgumentException(\"Cannot find a deserializer for non-concrete Collection type \"+type);\n                    }\n                    deser = AbstractDeserializer.constructForNonPOJO(beanDesc);\n                } else {\n                    type = implType;\n                    \n                    beanDesc = config.introspectForCreation(type);\n                }\n            }\n            if (deser == null) {\n                ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n                if (!inst.canCreateUsingDefault()) {\n                    \n                    if (type.hasRawClass(ArrayBlockingQueue.class)) {\n                        return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst);\n                    }\n                    \n                    deser = JavaUtilCollectionsDeserializers.findForCollection(ctxt, type);\n                    if (deser != null) {\n                        return deser;\n                    }\n                }\n                \n                if (contentType.hasRawClass(String.class)) {\n                    \n                    deser = new StringCollectionDeserializer(type, contentDeser, inst);\n                } else {\n                    deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst);\n                }\n            }\n        }\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config) {\n        Class<?> collectionClass = type.getRawClass();\n        collectionClass = _collectionFallbacks.get(collectionClass.getName());\n        if (collectionClass == null) {\n            return null;\n        }\n        return (CollectionType) config.constructSpecializedType(type, collectionClass);\n    }\n    \n    \n    @Override\n    public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException {\n        JavaType contentType = type.getContentType();\n        \n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomCollectionLikeDeserializer(type, config, beanDesc,\n                contentTypeDeser, contentDeser);\n        if (deser != null) {\n            \n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyCollectionLikeDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    \n\n    @Override\n    public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        JavaType keyType = type.getKeyType();\n        JavaType contentType = type.getContentType();\n        \n        \n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();\n\n        \n        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n\n        \n        JsonDeserializer<?> deser = _findCustomMapDeserializer(type, config, beanDesc,\n                keyDes, contentTypeDeser, contentDeser);\n\n        if (deser == null) {\n            \n            Class<?> mapClass = type.getRawClass();\n            if (EnumMap.class.isAssignableFrom(mapClass)) {\n                ValueInstantiator inst;\n\n                \n                \n                if (mapClass == EnumMap.class) {\n                    inst = null;\n                } else {\n                    inst = findValueInstantiator(ctxt, beanDesc);\n                }\n                Class<?> kt = keyType.getRawClass();\n                if (kt == null || !kt.isEnum()) {\n                    throw new IllegalArgumentException(\"Cannot construct EnumMap; generic (key) type not available\");\n                }\n                deser = new EnumMapDeserializer(type, inst, null,\n                        contentDeser, contentTypeDeser, null);\n            }\n\n            \n    \n            \n            if (deser == null) {\n                if (type.isInterface() || type.isAbstract()) {\n                    @SuppressWarnings(\"rawtypes\")\n                    Class<? extends Map> fallback = _mapFallbacks.get(mapClass.getName());\n                    if (fallback != null) {\n                        mapClass = fallback;\n                        type = (MapType) config.constructSpecializedType(type, mapClass);\n                        \n                        beanDesc = config.introspectForCreation(type);\n                    } else {\n                        \n                        if (type.getTypeHandler() == null) {\n                            throw new IllegalArgumentException(\"Cannot find a deserializer for non-concrete Map type \"+type);\n                        }\n                        deser = AbstractDeserializer.constructForNonPOJO(beanDesc);\n                    }\n                } else {\n                    \n                    deser = JavaUtilCollectionsDeserializers.findForMap(ctxt, type);\n                    if (deser != null) {\n                        return deser;\n                    }\n                }\n                if (deser == null) {\n                    ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n                    \n                    \n                    \n                    \n                    MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser);\n                    JsonIgnoreProperties.Value ignorals = config.getDefaultPropertyIgnorals(Map.class,\n                            beanDesc.getClassInfo());\n                    Set<String> ignored = (ignorals == null) ? null\n                            : ignorals.findIgnoredForDeserialization();\n                    md.setIgnorableProperties(ignored);\n                    deser = md;\n                }\n            }\n        }\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyMapDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    \n    @Override\n    public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException {\n        JavaType keyType = type.getKeyType();\n        JavaType contentType = type.getContentType();\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        \n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();\n        \n        \n        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n        \n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomMapLikeDeserializer(type, config,\n                beanDesc, keyDes, contentTypeDeser, contentDeser);\n        if (deser != null) {\n            \n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyMapLikeDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    \n    \n    \n    @Override\n    public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        final Class<?> enumClass = type.getRawClass();\n        \n        JsonDeserializer<?> deser = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n\n        if (deser == null) {\n            ValueInstantiator valueInstantiator = _constructDefaultValueInstantiator(ctxt, beanDesc);\n            SettableBeanProperty[] creatorProps = (valueInstantiator == null) ? null\n                    : valueInstantiator.getFromObjectArguments(ctxt.getConfig());\n            \n            for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n                if (_hasCreatorAnnotation(ctxt, factory)) {\n                    if (factory.getParameterCount() == 0) { \n                        deser = EnumDeserializer.deserializerForNoArgsCreator(config, enumClass, factory);\n                        break;\n                    }\n                    Class<?> returnType = factory.getRawReturnType();\n                    \n                    if (returnType.isAssignableFrom(enumClass)) {\n                        deser = EnumDeserializer.deserializerForCreator(config, enumClass, factory, valueInstantiator, creatorProps);\n                        break;\n                    }\n                }\n            }\n           \n            \n            if (deser == null) {\n                deser = new EnumDeserializer(constructEnumResolver(enumClass,\n                        config, beanDesc.findJsonValueAccessor()),\n                        config.isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_ENUMS));\n            }\n        }\n\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyEnumDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    @Override\n    public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException {\n        @SuppressWarnings(\"unchecked\")\n        Class<? extends JsonNode> nodeClass = (Class<? extends JsonNode>) nodeType.getRawClass();\n        \n        JsonDeserializer<?> custom = _findCustomTreeNodeDeserializer(nodeClass, config,\n                beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        return JsonNodeDeserializer.getDeserializer(nodeClass);\n    }\n\n    @Override\n    public JsonDeserializer<?> createReferenceDeserializer(DeserializationContext ctxt, ReferenceType type, BeanDescription beanDesc) throws JsonMappingException {\n        JavaType contentType = type.getContentType();\n        \n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        if (contentTypeDeser == null) { \n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomReferenceDeserializer(type, config, beanDesc,\n                contentTypeDeser, contentDeser);\n\n        if (deser == null) {\n            \n            if (type.isTypeOrSubTypeOf(AtomicReference.class)) {\n                Class<?> rawType = type.getRawClass();\n                ValueInstantiator inst;\n                if (rawType == AtomicReference.class) {\n                    inst = null;\n                } else {\n                    \n                    inst = findValueInstantiator(ctxt, beanDesc);\n                }\n                return new AtomicReferenceDeserializer(type, inst, contentTypeDeser, contentDeser);\n            }\n        }\n        if (deser != null) {\n            \n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyReferenceDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    \n\n    @Override\n    public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n        BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n        AnnotatedClass ac = bean.getClassInfo();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n\n        \n        \n        Collection<NamedType> subtypes = null;\n        if (b == null) {\n            b = config.getDefaultTyper(baseType);\n            if (b == null) {\n                return null;\n            }\n        } else {\n            subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n        }\n        \n        \n        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n            JavaType defaultType = mapAbstractType(config, baseType);\n            if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n                b = b.defaultImpl(defaultType.getRawClass());\n            }\n        }\n        \n        \n        try {\n            return b.buildTypeDeserializer(config, baseType, subtypes);\n        } catch (IllegalArgumentException e0) {\n            InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null,\n                    e0.getMessage(), baseType);\n            e.initCause(e0);\n            throw e;\n        }\n    }\n\n    \n    protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        return OptionalHandlerFactory.instance.findDeserializer(type, ctxt.getConfig(), beanDesc);\n    }\n    \n    \n    \n    @Override\n    public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        KeyDeserializer deser = null;\n        if (_factoryConfig.hasKeyDeserializers()) {\n            BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n            for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n                deser = d.findKeyDeserializer(type, config, beanDesc);\n                if (deser != null) {\n                    break;\n                }\n            }\n        }\n        \n        if (deser == null) {\n            if (type.isEnumType()) {\n                deser = _createEnumKeyDeserializer(ctxt, type);\n            } else {\n                deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n            }\n        }\n        \n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyKeyDeserializer(config, type, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        Class<?> enumClass = type.getRawClass();\n\n        BeanDescription beanDesc = config.introspect(type);\n        \n        KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n            return des;\n        } else {\n            \n            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n            if (custom != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n            }\n            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n            if (valueDesForKey != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);\n            }\n        }\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueAccessor());\n        \n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (_hasCreatorAnnotation(ctxt, factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n                    Class<?> returnType = factory.getRawReturnType();\n                    \n                    if (returnType.isAssignableFrom(enumClass)) {\n                        \n                        if (factory.getRawParameterType(0) != String.class) {\n                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n                        }\n                        if (config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(factory.getMember(),\n                                    ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                        }\n                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                    }\n                }\n                throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n                        +enumClass.getName()+\")\");\n            }\n        }\n        \n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }\n\n    \n\n    \n    public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, annotated, baseType);        \n        \n        if (b == null) {\n            return findTypeDeserializer(config, baseType);\n        }\n        \n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(\n                config, annotated, baseType);\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    }\n    \n        \n    public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, propertyEntity, containerType);        \n        JavaType contentType = containerType.getContentType();\n        \n        if (b == null) {\n            return findTypeDeserializer(config, contentType);\n        }\n        \n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(\n                config, propertyEntity, contentType);\n        return b.buildTypeDeserializer(config, contentType, subtypes);\n    }\n\n    \n    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        Class<?> rawType = type.getRawClass();\n        \n        if (rawType == CLASS_OBJECT) {\n            \n            DeserializationConfig config = ctxt.getConfig();\n            JavaType lt, mt;\n            \n            if (_factoryConfig.hasAbstractTypeResolvers()) {\n                lt = _findRemappedType(config, List.class);\n                mt = _findRemappedType(config, Map.class);\n            } else {\n                lt = mt = null;\n            }\n            return new UntypedObjectDeserializer(lt, mt);\n        }\n        if (rawType == CLASS_STRING || rawType == CLASS_CHAR_SEQUENCE) {\n            return StringDeserializer.instance;\n        }\n        if (rawType == CLASS_ITERABLE) {\n            \n            TypeFactory tf = ctxt.getTypeFactory();\n            JavaType[] tps = tf.findTypeParameters(type, CLASS_ITERABLE);\n            JavaType elemType = (tps == null || tps.length != 1) ? TypeFactory.unknownType() : tps[0];\n            CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n            \n            return createCollectionDeserializer(ctxt, ct, beanDesc);\n        }\n        if (rawType == CLASS_MAP_ENTRY) {\n            \n            JavaType kt = type.containedTypeOrUnknown(0);\n            JavaType vt = type.containedTypeOrUnknown(1);\n            TypeDeserializer vts = (TypeDeserializer) vt.getTypeHandler();\n            if (vts == null) {\n                vts = findTypeDeserializer(ctxt.getConfig(), vt);\n            }\n            JsonDeserializer<Object> valueDeser = vt.getValueHandler();\n            KeyDeserializer keyDes = (KeyDeserializer) kt.getValueHandler();\n            return new MapEntryDeserializer(type, keyDes, valueDeser, vts);\n        }\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            \n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n            }\n            if (deser != null) {\n                return deser;\n            }\n        }\n        \n        if (rawType == TokenBuffer.class) {\n            return new TokenBufferDeserializer();\n        }\n        JsonDeserializer<?> deser = findOptionalStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n        return JdkDeserializers.find(rawType, clsName);\n    }\n\n    protected JavaType _findRemappedType(DeserializationConfig config, Class<?> rawType) throws JsonMappingException {\n        JavaType type = mapAbstractType(config, config.constructType(rawType));\n        return (type == null || type.hasRawClass(rawType)) ? null : type;\n    }\n\n    \n\n    protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomReferenceDeserializer(ReferenceType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer contentTypeDeserializer, JsonDeserializer<?> contentDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findReferenceDeserializer(type, config, beanDesc,\n                    contentTypeDeserializer, contentDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findBeanDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return (JsonDeserializer<Object>) deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findArrayDeserializer(type, config,\n                    beanDesc, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findCollectionDeserializer(type, config, beanDesc,\n                    elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findCollectionLikeDeserializer(type, config, beanDesc,\n                    elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findMapDeserializer(type, config, beanDesc,\n                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findMapLikeDeserializer(type, config, beanDesc,\n                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    \n    \n    \n    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n            Object deserDef = intr.findDeserializer(ann);\n            if (deserDef != null) {\n                return ctxt.deserializerInstance(ann, deserDef);\n            }\n        }\n        return null;\n    }\n\n    \n    protected KeyDeserializer findKeyDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n            Object deserDef = intr.findKeyDeserializer(ann);\n            if (deserDef != null) {\n                return ctxt.keyDeserializerInstance(ann, deserDef);\n            }\n        }\n        return null;\n    }\n\n    \n    protected JsonDeserializer<Object> findContentDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n            Object deserDef = intr.findContentDeserializer(ann);\n            if (deserDef != null) {\n                return ctxt.deserializerInstance(ann, deserDef);\n            }\n        }\n        return null;\n    }\n    \n    \n    protected JavaType resolveMemberAndTypeAnnotations(DeserializationContext ctxt, AnnotatedMember member, JavaType type) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr == null) {\n            return type;\n        }\n\n        \n        \n\n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            if (keyType != null) {\n                Object kdDef = intr.findKeyDeserializer(member);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); \n                }\n            }\n        }\n\n        if (type.hasContentType()) { \n            Object cdDef = intr.findContentDeserializer(member);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef);\n            if (cd != null) {\n                type = type.withContentValueHandler(cd);\n            }\n            TypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(\n                    ctxt.getConfig(), type, (AnnotatedMember) member);            \t\n            if (contentTypeDeser != null) {\n                type = type.withContentTypeHandler(contentTypeDeser);\n            }\n        }\n        TypeDeserializer valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(),\n                    type, (AnnotatedMember) member);\n        if (valueTypeDeser != null) {\n            type = type.withTypeHandler(valueTypeDeser);\n        }\n\n        \n\n        \n        \n        \n        type = intr.refineDeserializationType(ctxt.getConfig(), member, type);\n        return type;\n    }\n\n    protected EnumResolver constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMember jsonValueAccessor) {\n        if (jsonValueAccessor != null) {\n            if (config.canOverrideAccessModifiers()) {\n                ClassUtil.checkAndFixAccess(jsonValueAccessor.getMember(),\n                        config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n            return EnumResolver.constructUnsafeUsingMethod(enumClass,\n                    jsonValueAccessor, config.getAnnotationIntrospector());\n        }\n        \n        \n        return EnumResolver.constructUnsafe(enumClass, config.getAnnotationIntrospector());\n    }\n\n    \n    protected boolean _hasCreatorAnnotation(DeserializationContext ctxt, Annotated ann) {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n            JsonCreator.Mode mode = intr.findCreatorAnnotation(ctxt.getConfig(), ann);\n            return (mode != null) && (mode != JsonCreator.Mode.DISABLED); \n        }\n        return false;\n    }\n    \n    \n    \n    \n    @Deprecated\n    protected JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr == null) {\n            return type;\n        }\n        return intr.refineDeserializationType(ctxt.getConfig(), a, type);\n    }\n\n    \n    @Deprecated \n    protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException {\n        return resolveMemberAndTypeAnnotations(ctxt, member, type);\n    }\n\n    \n    @Deprecated \n    protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType) {\n        if (enumType == null) {\n            return null;\n        }\n        BeanDescription beanDesc = config.introspect(enumType);\n        return beanDesc.findJsonValueMethod();\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.deser;\n\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.JacksonInject;\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonCreator.Mode;\nimport com.fasterxml.jackson.core.JsonLocation;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.deser.impl.CreatorCandidate;\nimport com.fasterxml.jackson.databind.deser.impl.CreatorCollector;\nimport com.fasterxml.jackson.databind.deser.impl.JavaUtilCollectionsDeserializers;\nimport com.fasterxml.jackson.databind.deser.std.*;\nimport com.fasterxml.jackson.databind.exc.InvalidDefinitionException;\nimport com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.*;\n\n\n@SuppressWarnings(\"serial\")\npublic abstract class BasicDeserializerFactory extends DeserializerFactory implements java.io.Serializable { private final static Class<?> CLASS_OBJECT = Object.class; private final static Class<?> CLASS_STRING = String.class; private final static Class<?> CLASS_CHAR_SEQUENCE = CharSequence.class; private final static Class<?> CLASS_ITERABLE = Iterable.class; private final static Class<?> CLASS_MAP_ENTRY = Map.Entry.class; protected final static PropertyName UNWRAPPED_CREATOR_PARAM_NAME = new PropertyName(\"@JsonUnwrapped\"); @SuppressWarnings(\"rawtypes\") final static HashMap<String, Class<? extends Map>> _mapFallbacks = new HashMap<String, Class<? extends Map>>(); static {\n        _mapFallbacks.put(Map.class.getName(), LinkedHashMap.class);\n        _mapFallbacks.put(ConcurrentMap.class.getName(), ConcurrentHashMap.class);\n        _mapFallbacks.put(SortedMap.class.getName(), TreeMap.class);\n\n        _mapFallbacks.put(java.util.NavigableMap.class.getName(), TreeMap.class);\n        _mapFallbacks.put(java.util.concurrent.ConcurrentNavigableMap.class.getName(),\n                java.util.concurrent.ConcurrentSkipListMap.class);\n    }\n\n    \n    @SuppressWarnings(\"rawtypes\")\n    final static HashMap<String, Class<? extends Collection>> _collectionFallbacks = new HashMap<String, Class<? extends Collection>>(); static {\n        _collectionFallbacks.put(Collection.class.getName(), ArrayList.class);\n        _collectionFallbacks.put(List.class.getName(), ArrayList.class);\n        _collectionFallbacks.put(Set.class.getName(), HashSet.class);\n        _collectionFallbacks.put(SortedSet.class.getName(), TreeSet.class);\n        _collectionFallbacks.put(Queue.class.getName(), LinkedList.class);\n\n        \n        \n        _collectionFallbacks.put(\"java.util.Deque\", LinkedList.class);\n        _collectionFallbacks.put(\"java.util.NavigableSet\", TreeSet.class);\n    }\n\n    \n    \n    \n    protected final DeserializerFactoryConfig _factoryConfig; protected BasicDeserializerFactory(DeserializerFactoryConfig config) {\n        _factoryConfig = config;\n    }\n    \n    \n    public DeserializerFactoryConfig getFactoryConfig() {\n        return _factoryConfig;\n    }\n\n    protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); @Override public final DeserializerFactory withAdditionalDeserializers(Deserializers additional) {\n        return withConfig(_factoryConfig.withAdditionalDeserializers(additional));\n    }\n\n    \n    @Override\n    public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional) {\n        return withConfig(_factoryConfig.withAdditionalKeyDeserializers(additional));\n    }\n    \n    \n    @Override\n    public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier) {\n        return withConfig(_factoryConfig.withDeserializerModifier(modifier));\n    }\n\n    \n    @Override\n    public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver) {\n        return withConfig(_factoryConfig.withAbstractTypeResolver(resolver));\n    }\n\n    \n    @Override\n    public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators) {\n        return withConfig(_factoryConfig.withValueInstantiators(instantiators));\n    }\n\n    \n\n    @Override\n    public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException {\n        \n        while (true) {\n            JavaType next = _mapAbstractType2(config, type);\n            if (next == null) {\n                return type;\n            }\n            \n            \n            Class<?> prevCls = type.getRawClass();\n            Class<?> nextCls = next.getRawClass();\n            if ((prevCls == nextCls) || !prevCls.isAssignableFrom(nextCls)) {\n                throw new IllegalArgumentException(\"Invalid abstract type resolution from \"+type+\" to \"+next+\": latter is not a subtype of former\"); } type = next; } } private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) throws JsonMappingException {\n        Class<?> currClass = type.getRawClass();\n        if (_factoryConfig.hasAbstractTypeResolvers()) {\n            for (AbstractTypeResolver resolver : _factoryConfig.abstractTypeResolvers()) {\n                JavaType concrete = resolver.findTypeMapping(config, type);\n                if ((concrete != null) && !concrete.hasRawClass(currClass)) {\n                    return concrete;\n                }\n            }\n        }\n        return null;\n    }\n\n    \n\n    \n    @Override\n    public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n\n        ValueInstantiator instantiator = null;\n        \n        AnnotatedClass ac = beanDesc.getClassInfo();\n        Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac);\n        if (instDef != null) {\n            instantiator = _valueInstantiatorInstance(config, ac, instDef);\n        }\n        if (instantiator == null) {\n            \n            \n            instantiator = _findStdValueInstantiator(config, beanDesc);\n            if (instantiator == null) {\n                instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc);\n            }\n        }\n\n        \n        if (_factoryConfig.hasValueInstantiators()) {\n            for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) {\n                instantiator = insts.findValueInstantiator(config, beanDesc, instantiator);\n                \n                if (instantiator == null) {\n                    ctxt.reportBadTypeDefinition(beanDesc,\n\t\t\t\t\t\t\"Broken registered ValueInstantiators (of type %s): returned null ValueInstantiator\",\n\t\t\t\t\t\tinsts.getClass().getName());\n                }\n            }\n        }\n\n        \n        if (instantiator.getIncompleteParameter() != null) {\n            final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter();\n            final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner();\n            throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()\n                +\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n        }\n\n        return instantiator;\n    }\n\n    private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        Class<?> raw = beanDesc.getBeanClass();\n        if (raw == JsonLocation.class) {\n            return new JsonLocationInstantiator();\n        }\n        \n        if (Collection.class.isAssignableFrom(raw)) {\n            if (Collections.EMPTY_SET.getClass() == raw) {\n                return new ConstantValueInstantiator(Collections.EMPTY_SET);\n            }\n            if (Collections.EMPTY_LIST.getClass() == raw) {\n                return new ConstantValueInstantiator(Collections.EMPTY_LIST);\n            }\n        } else if (Map.class.isAssignableFrom(raw)) {\n            if (Collections.EMPTY_MAP.getClass() == raw) {\n                return new ConstantValueInstantiator(Collections.EMPTY_MAP);\n            }\n        }\n        return null;\n    }\n\n    \n    protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException {\n        CreatorCollector creators = new CreatorCollector(beanDesc, ctxt.getConfig());\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        \n        \n        final DeserializationConfig config = ctxt.getConfig();\n        VisibilityChecker<?> vchecker = config.getDefaultVisibilityChecker(beanDesc.getBeanClass(),\n                beanDesc.getClassInfo());\n\n        \n        \n        Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorDefs = _findCreatorsFromProperties(ctxt,\n                beanDesc);\n        \n        \n        _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n        \n        if (beanDesc.getType().isConcrete()) {\n            _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n        }\n        return creators.constructValueInstantiator(ctxt);\n    }\n\n    protected Map<AnnotatedWithParams,BeanPropertyDefinition[]> _findCreatorsFromProperties(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException {\n        Map<AnnotatedWithParams,BeanPropertyDefinition[]> result = Collections.emptyMap();\n        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {\n            Iterator<AnnotatedParameter> it = propDef.getConstructorParameters();\n            while (it.hasNext()) {\n                AnnotatedParameter param = it.next();\n                AnnotatedWithParams owner = param.getOwner();\n                BeanPropertyDefinition[] defs = result.get(owner);\n                final int index = param.getIndex();\n                \n                if (defs == null) {\n                    if (result.isEmpty()) { \n                        result = new LinkedHashMap<AnnotatedWithParams,BeanPropertyDefinition[]>();\n                    }\n                    defs = new BeanPropertyDefinition[owner.getParameterCount()];\n                    result.put(owner, defs);\n                } else {\n                    if (defs[index] != null) {\n                        ctxt.reportBadTypeDefinition(beanDesc,\n\"Conflict: parameter #%d of %s bound to more than one property; %s vs %s\",\nindex, owner, defs[index], propDef);\n                    }\n                }\n                defs[index] = propDef;\n            }\n        }\n        return result;\n    }\n    \n    public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException {\n        if (instDef == null) {\n            return null;\n        }\n\n        ValueInstantiator inst;\n        \n        if (instDef instanceof ValueInstantiator) {\n            return (ValueInstantiator) instDef;\n        }\n        if (!(instDef instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned key deserializer definition of type \"\n                    +instDef.getClass().getName()\n                    +\"; expected type KeyDeserializer or Class<KeyDeserializer> instead\");\n        }\n        Class<?> instClass = (Class<?>)instDef;\n        if (ClassUtil.isBogusClass(instClass)) {\n            return null;\n        }\n        if (!ValueInstantiator.class.isAssignableFrom(instClass)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+instClass.getName()\n                    +\"; expected Class<ValueInstantiator>\");\n        }\n        HandlerInstantiator hi = config.getHandlerInstantiator();\n        if (hi != null) {\n            inst = hi.valueInstantiatorInstance(config, annotated, instClass);\n            if (inst != null) {\n                return inst;\n            }\n        }\n        return (ValueInstantiator) ClassUtil.createInstance(instClass,\n                config.canOverrideAccessModifiers());\n    }\n\n    \n\n    protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException {\n        \n        \n        \n        final boolean isNonStaticInnerClass = beanDesc.isNonStaticInnerClass();\n        if (isNonStaticInnerClass) {\n            \n            return;\n        }\n\n        \n        \n        \n        AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor();\n        if (defaultCtor != null) {\n            if (!creators.hasDefaultCreator() || _hasCreatorAnnotation(ctxt, defaultCtor)) {\n                creators.setDefaultCreator(defaultCtor);\n            }\n        }\n        \n        List<CreatorCandidate> nonAnnotated = new LinkedList<>();\n        int explCount = 0;\n        for (AnnotatedConstructor ctor : beanDesc.getConstructors()) {\n            JsonCreator.Mode creatorMode = intr.findCreatorAnnotation(ctxt.getConfig(), ctor);\n            if (Mode.DISABLED == creatorMode) {\n                continue;\n            }\n            if (creatorMode == null) {\n                \n                if (vchecker.isCreatorVisible(ctor)) {\n                    nonAnnotated.add(CreatorCandidate.construct(intr, ctor, creatorParams.get(ctor)));\n                }\n                continue;\n            }\n            switch (creatorMode) {\n            case DELEGATING:\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators,\n                        CreatorCandidate.construct(intr, ctor, null));\n                break;\n            case PROPERTIES:\n                _addExplicitPropertyCreator(ctxt, beanDesc, creators,\n                        CreatorCandidate.construct(intr, ctor, creatorParams.get(ctor)));\n                break;\n            default:\n                _addExplicitAnyCreator(ctxt, beanDesc, creators,\n                        CreatorCandidate.construct(intr, ctor, creatorParams.get(ctor)));\n                break;\n            }\n            ++explCount;\n        }\n        \n        if (explCount > 0) { \n            return;\n        }\n        List<AnnotatedWithParams> implicitCtors = null;\n        for (CreatorCandidate candidate : nonAnnotated) {\n            final int argCount = candidate.paramCount();\n            final AnnotatedWithParams ctor = candidate.creator();\n\n            \n            if (argCount == 1) {\n                BeanPropertyDefinition propDef = candidate.propertyDef(0);\n                boolean useProps = _checkIfCreatorPropertyBased(intr, ctor, propDef);\n\n                if (useProps) {\n                    SettableBeanProperty[] properties = new SettableBeanProperty[1];\n                    PropertyName name = candidate.paramName(0);\n                    properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0,\n                            candidate.parameter(0), candidate.injection(0));\n                    creators.addPropertyCreator(ctor, false, properties);\n                } else {\n                     _handleSingleArgumentCreator(creators,\n                            ctor, false,\n                            vchecker.isCreatorVisible(ctor));\n                    \n                    \n                    if (propDef != null) {\n                        ((POJOPropertyBuilder) propDef).removeConstructors();\n                    }\n                }\n                \n                continue;\n            }\n\n            \n            \n            \n\n            int nonAnnotatedParamIndex = -1;\n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            int explicitNameCount = 0;\n            int implicitWithCreatorCount = 0;\n            int injectCount = 0;\n\n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = ctor.getParameter(i);\n                BeanPropertyDefinition propDef = candidate.propertyDef(i);\n                JacksonInject.Value injectId = intr.findInjectableValue(param);\n                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n\n                if (propDef != null && propDef.isExplicitlyNamed()) {\n                    ++explicitNameCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                if (injectId != null) {\n                    ++injectCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    _reportUnwrappedCreatorProperty(ctxt, beanDesc, param);\n                    \n                    continue;\n                }\n                \n                \n                if (nonAnnotatedParamIndex < 0) {\n                    nonAnnotatedParamIndex = i;\n                }\n            }\n\n            final int namedCount = explicitNameCount + implicitWithCreatorCount;\n            \n            if ((explicitNameCount > 0) || (injectCount > 0)) {\n                \n                if ((namedCount + injectCount) == argCount) {\n                    creators.addPropertyCreator(ctor, false, properties);\n                    continue;\n                }\n                if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                    \n                    creators.addDelegatingCreator(ctor, false, properties, 0);\n                    continue;\n                }\n                \n                \n                \n                PropertyName impl = candidate.findImplicitParamName(nonAnnotatedParamIndex);\n                if (impl == null || impl.isEmpty()) {\n                    \n                    \n                    \n                    ctxt.reportBadTypeDefinition(beanDesc,\n\"Argument #%d of constructor %s has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\",\nnonAnnotatedParamIndex, ctor);\n                }\n            }\n            \n            if (!creators.hasDefaultCreator()) {\n                if (implicitCtors == null) {\n                    implicitCtors = new LinkedList<>();\n                }\n                implicitCtors.add(ctor);\n            }\n        }\n        \n        \n        if ((implicitCtors != null) && !creators.hasDelegatingCreator()\n                && !creators.hasPropertyBasedCreator()) {\n            _checkImplicitlyNamedConstructors(ctxt, beanDesc, vchecker, intr,\n                    creators, implicitCtors);\n        }\n    }\n\n    \n    protected void _addExplicitDelegatingCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException {\n        \n        \n\n        int ix = -1;\n        final int argCount = candidate.paramCount();\n        SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n        for (int i = 0; i < argCount; ++i) {\n            AnnotatedParameter param = candidate.parameter(i);\n            JacksonInject.Value injectId = candidate.injection(i);\n            if (injectId != null) {\n                properties[i] = constructCreatorProperty(ctxt, beanDesc, null, i, param, injectId);\n                continue;\n            }\n            if (ix < 0) {\n                ix = i;\n                continue;\n            }\n            \n            ctxt.reportBadTypeDefinition(beanDesc,\n                    \"More than one argument (#%d and #%d) left as delegating for Creator %s: only one allowed\",\n                    ix, i, candidate);\n        }\n        \n        if (ix < 0) {\n            ctxt.reportBadTypeDefinition(beanDesc,\n                    \"No argument left as delegating for Creator %s: exactly one required\", candidate);\n        }\n        \n        \n        if (argCount == 1) {\n            _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n            \n            \n            BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n            if (paramDef != null) {\n                ((POJOPropertyBuilder) paramDef).removeConstructors();\n            }\n            return;\n        }\n        creators.addDelegatingCreator(candidate.creator(), true, properties, ix);\n    }\n\n    \n    protected void _addExplicitPropertyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException {\n        final int paramCount = candidate.paramCount();\n        SettableBeanProperty[] properties = new SettableBeanProperty[paramCount];\n\n        for (int i = 0; i < paramCount; ++i) {\n            JacksonInject.Value injectId = candidate.injection(i);\n            AnnotatedParameter param = candidate.parameter(i);\n            PropertyName name = candidate.paramName(i);\n            if (name == null) {\n                \n                \n                NameTransformer unwrapper = ctxt.getAnnotationIntrospector().findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    _reportUnwrappedCreatorProperty(ctxt, beanDesc, param);\n                    \n                }\n                name = candidate.findImplicitParamName(i);\n                \n                if ((name == null) && (injectId == null)) {\n                    ctxt.reportBadTypeDefinition(beanDesc,\n\"Argument #%d has no property name, is not Injectable: can not use as Creator %s\", i, candidate);\n                }\n            }\n            properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n        }\n        creators.addPropertyCreator(candidate.creator(), true, properties);\n    }\n\n    \n    protected void _addExplicitAnyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException {\n        \n        if (1 != candidate.paramCount()) {\n            \n            \n            int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n            if (oneNotInjected >= 0) {\n                \n                if (candidate.paramName(oneNotInjected) == null) {\n                    _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                    return;\n                }\n            }\n            _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n            return;\n        }\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n\n        \n        boolean useProps = (paramName != null) || (injectId != null);\n        if (!useProps && (paramDef != null)) {\n            \n            \n\n            \n            \n\n            paramName = candidate.paramName(0);\n            useProps = (paramName != null) && paramDef.couldSerialize();\n        }\n        if (useProps) {\n            SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                    constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n            };\n            creators.addPropertyCreator(candidate.creator(), true, properties);\n            return;\n        }\n        _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n\n        \n        \n        if (paramDef != null) {\n            ((POJOPropertyBuilder) paramDef).removeConstructors();\n        }\n    }\n\n    private boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr, AnnotatedWithParams creator, BeanPropertyDefinition propDef) {\n        \n        if (((propDef != null) && propDef.isExplicitlyNamed())\n                || (intr.findInjectableValue(creator.getParameter(0)) != null)) {\n            return true;\n        }\n        if (propDef != null) {\n            \n            \n            String implName = propDef.getName();\n            if (implName != null && !implName.isEmpty()) {\n                if (propDef.couldSerialize()) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n\n    private void _checkImplicitlyNamedConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, List<AnnotatedWithParams> implicitCtors) throws JsonMappingException {\n        AnnotatedWithParams found = null;\n        SettableBeanProperty[] foundProps = null;\n\n        \n        \n        \n\n        main_loop:\n        for (AnnotatedWithParams ctor : implicitCtors) {\n            if (!vchecker.isCreatorVisible(ctor)) {\n                continue;\n            }\n            \n            final int argCount = ctor.getParameterCount();\n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = ctor.getParameter(i);\n                final PropertyName name = _findParamName(param, intr);\n\n                \n                if (name == null || name.isEmpty()) {\n                    continue main_loop;\n                }\n                properties[i] = constructCreatorProperty(ctxt, beanDesc, name, param.getIndex(),\n                        param,  null);\n            }\n            if (found != null) { \n                found = null;\n                break;\n            }\n            found = ctor;\n            foundProps = properties;\n        }\n        \n        if (found != null) {\n            creators.addPropertyCreator(found,  false, foundProps);\n            BasicBeanDescription bbd = (BasicBeanDescription) beanDesc;\n            \n            for (SettableBeanProperty prop : foundProps) {\n                PropertyName pn = prop.getFullName();\n                if (!bbd.hasProperty(pn)) {\n                    BeanPropertyDefinition newDef = SimpleBeanPropertyDefinition.construct(\n                            ctxt.getConfig(), prop.getMember(), pn);\n                    bbd.addProperty(newDef);\n                }\n            }\n        }\n    }\n\n    protected void _addDeserializerFactoryMethods (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException {\n        List<CreatorCandidate> nonAnnotated = new LinkedList<>();\n        int explCount = 0;\n\n        \n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            JsonCreator.Mode creatorMode = intr.findCreatorAnnotation(ctxt.getConfig(), factory);\n            final int argCount = factory.getParameterCount();\n            if (creatorMode == null) {\n                \n                if ((argCount == 1) && vchecker.isCreatorVisible(factory)) {\n                    nonAnnotated.add(CreatorCandidate.construct(intr, factory, null));\n                }\n                continue;\n            }\n            if (creatorMode == Mode.DISABLED) {\n                continue;\n            }\n            \n            \n            if (argCount == 0) {\n                creators.setDefaultCreator(factory);\n                continue;\n            }\n\n            switch (creatorMode) {\n            case DELEGATING:\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators,\n                        CreatorCandidate.construct(intr, factory, null));\n                break;\n            case PROPERTIES:\n                _addExplicitPropertyCreator(ctxt, beanDesc, creators,\n                        CreatorCandidate.construct(intr, factory, creatorParams.get(factory)));\n                break;\n            case DEFAULT:\n            default:\n                _addExplicitAnyCreator(ctxt, beanDesc, creators,\n                        CreatorCandidate.construct(intr, factory, creatorParams.get(factory)));\n                break;\n            }\n            ++explCount;\n        }\n        \n        if (explCount > 0) { \n            return;\n        }\n        \n        for (CreatorCandidate candidate : nonAnnotated) {\n            final int argCount = candidate.paramCount();\n            AnnotatedWithParams factory = candidate.creator();\n            final BeanPropertyDefinition[] propDefs = creatorParams.get(factory);\n            \n            if (argCount != 1) {\n                continue; \n            }\n            BeanPropertyDefinition argDef = candidate.propertyDef(0);\n            boolean useProps = _checkIfCreatorPropertyBased(intr, factory, argDef);\n            if (!useProps) { \n                 _handleSingleArgumentCreator(creators,\n                        factory, false, vchecker.isCreatorVisible(factory));\n                \n                \n                if (argDef != null) {\n                    ((POJOPropertyBuilder) argDef).removeConstructors();\n                }\n                continue;\n            }\n            AnnotatedParameter nonAnnotatedParam = null;            \n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            int implicitNameCount = 0;\n            int explicitNameCount = 0;\n            int injectCount = 0;\n            \n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = factory.getParameter(i);\n                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i];\n                JacksonInject.Value injectable = intr.findInjectableValue(param);\n                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n\n                if (propDef != null && propDef.isExplicitlyNamed()) {\n                    ++explicitNameCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectable);\n                    continue;\n                }\n                if (injectable != null) {\n                    ++injectCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectable);\n                    continue;\n                }\n                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    _reportUnwrappedCreatorProperty(ctxt, beanDesc, param);\n                    \n                    continue;\n                }\n                \n                \n                \n                \n                if (nonAnnotatedParam == null) {\n                    nonAnnotatedParam = param;\n                }\n            }\n            final int namedCount = explicitNameCount + implicitNameCount;\n            \n            \n            if (explicitNameCount > 0 || injectCount > 0) {\n                \n                if ((namedCount + injectCount) == argCount) {\n                    creators.addPropertyCreator(factory, false, properties);\n                } else if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                    \n                    creators.addDelegatingCreator(factory, false, properties, 0);\n                } else { \n                    ctxt.reportBadTypeDefinition(beanDesc,\n\"Argument #%d of factory method %s has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\",\n                    nonAnnotatedParam.getIndex(), factory);\n                }\n            }\n        }\n    }\n\n    protected boolean _handleSingleArgumentCreator(CreatorCollector creators, AnnotatedWithParams ctor, boolean isCreator, boolean isVisible) {\n        \n        Class<?> type = ctor.getRawParameterType(0);\n        if (type == String.class || type == CLASS_CHAR_SEQUENCE) {\n            if (isCreator || isVisible) {\n                creators.addStringCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == int.class || type == Integer.class) {\n            if (isCreator || isVisible) {\n                creators.addIntCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == long.class || type == Long.class) {\n            if (isCreator || isVisible) {\n                creators.addLongCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == double.class || type == Double.class) {\n            if (isCreator || isVisible) {\n                creators.addDoubleCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == boolean.class || type == Boolean.class) {\n            if (isCreator || isVisible) {\n                creators.addBooleanCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        \n        if (isCreator) {\n            creators.addDelegatingCreator(ctor, isCreator, null, 0);\n            return true;\n        }\n        return false;\n    }\n\n    \n    \n    protected void _reportUnwrappedCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedParameter param) throws JsonMappingException {\n        ctxt.reportBadDefinition(beanDesc.getType(), String.format(\n                \"Cannot define Creator parameter %d as `@JsonUnwrapped`: combination not yet supported\",\n                param.getIndex()));\n    }\n\n    \n    protected SettableBeanProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, PropertyName name, int index, AnnotatedParameter param, JacksonInject.Value injectable) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        PropertyMetadata metadata;\n        {\n            if (intr == null) {\n                metadata = PropertyMetadata.STD_REQUIRED_OR_OPTIONAL;\n            } else {\n                Boolean b = intr.hasRequiredMarker(param);\n                String desc = intr.findPropertyDescription(param);\n                Integer idx = intr.findPropertyIndex(param);\n                String def = intr.findPropertyDefaultValue(param);\n                metadata = PropertyMetadata.construct(b, desc, idx, def);\n            }\n        }\n        JavaType type = resolveMemberAndTypeAnnotations(ctxt, param, param.getType());\n        BeanProperty.Std property = new BeanProperty.Std(name, type,\n                intr.findWrapperName(param), param, metadata);\n        \n        TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler();\n        \n        if (typeDeser == null) {\n            typeDeser = findTypeDeserializer(config, type);\n        }\n        \n        \n\n        Object injectableValueId = (injectable == null) ? null : injectable.getId();\n        \n        SettableBeanProperty prop = new CreatorProperty(name, type, property.getWrapperName(),\n                typeDeser, beanDesc.getClassAnnotations(), param, index, injectableValueId,\n                metadata);\n        JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, param);\n        if (deser == null) {\n            deser = type.getValueHandler();\n        }\n        if (deser != null) {\n            \n            deser = ctxt.handlePrimaryContextualization(deser, prop, type);\n            prop = prop.withValueDeserializer(deser);\n        }\n        return prop;\n    }\n\n    private PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr) {\n        if (param != null && intr != null) {\n            PropertyName name = intr.findNameForDeserialization(param);\n            if (name != null) {\n                return name;\n            }\n            \n            \n\n            String str = intr.findImplicitPropertyName(param);\n            if (str != null && !str.isEmpty()) {\n                return PropertyName.construct(str);\n            }\n        }\n        return null;\n    }\n\n    \n        \n    @Override\n    public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        JavaType elemType = type.getContentType();\n        \n        \n        JsonDeserializer<Object> contentDeser = elemType.getValueHandler();\n        \n        TypeDeserializer elemTypeDeser = elemType.getTypeHandler();\n        \n        if (elemTypeDeser == null) {\n            elemTypeDeser = findTypeDeserializer(config, elemType);\n        }\n        \n        JsonDeserializer<?>  deser = _findCustomArrayDeserializer(type,\n                config, beanDesc, elemTypeDeser, contentDeser);\n        if (deser == null) {\n            if (contentDeser == null) {\n                Class<?> raw = elemType.getRawClass();\n                if (elemType.isPrimitive()) {\n                    return PrimitiveArrayDeserializers.forType(raw);\n                }\n                if (raw == String.class) {\n                    return StringArrayDeserializer.instance;\n                }\n            }\n            deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser);\n        }\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    \n\n    @Override\n    public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException {\n        JavaType contentType = type.getContentType();\n        \n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        \n        JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type,\n                config, beanDesc, contentTypeDeser, contentDeser);\n        if (deser == null) {\n            Class<?> collectionClass = type.getRawClass();\n            if (contentDeser == null) { \n                \n                if (EnumSet.class.isAssignableFrom(collectionClass)) {\n                    deser = new EnumSetDeserializer(contentType, null);\n                }\n            }\n        }\n\n        \n        if (deser == null) {\n            if (type.isInterface() || type.isAbstract()) {\n                CollectionType implType = _mapAbstractCollectionType(type, config);\n                if (implType == null) {\n                    \n                    if (type.getTypeHandler() == null) {\n                        throw new IllegalArgumentException(\"Cannot find a deserializer for non-concrete Collection type \"+type);\n                    }\n                    deser = AbstractDeserializer.constructForNonPOJO(beanDesc);\n                } else {\n                    type = implType;\n                    \n                    beanDesc = config.introspectForCreation(type);\n                }\n            }\n            if (deser == null) {\n                ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n                if (!inst.canCreateUsingDefault()) {\n                    \n                    if (type.hasRawClass(ArrayBlockingQueue.class)) {\n                        return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst);\n                    }\n                    \n                    deser = JavaUtilCollectionsDeserializers.findForCollection(ctxt, type);\n                    if (deser != null) {\n                        return deser;\n                    }\n                }\n                \n                if (contentType.hasRawClass(String.class)) {\n                    \n                    deser = new StringCollectionDeserializer(type, contentDeser, inst);\n                } else {\n                    deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst);\n                }\n            }\n        }\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config) {\n        Class<?> collectionClass = type.getRawClass();\n        collectionClass = _collectionFallbacks.get(collectionClass.getName());\n        if (collectionClass == null) {\n            return null;\n        }\n        return (CollectionType) config.constructSpecializedType(type, collectionClass);\n    }\n    \n    \n    @Override\n    public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException {\n        JavaType contentType = type.getContentType();\n        \n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomCollectionLikeDeserializer(type, config, beanDesc,\n                contentTypeDeser, contentDeser);\n        if (deser != null) {\n            \n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyCollectionLikeDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    \n\n    @Override\n    public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        JavaType keyType = type.getKeyType();\n        JavaType contentType = type.getContentType();\n        \n        \n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();\n\n        \n        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n\n        \n        JsonDeserializer<?> deser = _findCustomMapDeserializer(type, config, beanDesc,\n                keyDes, contentTypeDeser, contentDeser);\n\n        if (deser == null) {\n            \n            Class<?> mapClass = type.getRawClass();\n            if (EnumMap.class.isAssignableFrom(mapClass)) {\n                ValueInstantiator inst;\n\n                \n                \n                if (mapClass == EnumMap.class) {\n                    inst = null;\n                } else {\n                    inst = findValueInstantiator(ctxt, beanDesc);\n                }\n                Class<?> kt = keyType.getRawClass();\n                if (kt == null || !kt.isEnum()) {\n                    throw new IllegalArgumentException(\"Cannot construct EnumMap; generic (key) type not available\");\n                }\n                deser = new EnumMapDeserializer(type, inst, null,\n                        contentDeser, contentTypeDeser, null);\n            }\n\n            \n    \n            \n            if (deser == null) {\n                if (type.isInterface() || type.isAbstract()) {\n                    @SuppressWarnings(\"rawtypes\")\n                    Class<? extends Map> fallback = _mapFallbacks.get(mapClass.getName());\n                    if (fallback != null) {\n                        mapClass = fallback;\n                        type = (MapType) config.constructSpecializedType(type, mapClass);\n                        \n                        beanDesc = config.introspectForCreation(type);\n                    } else {\n                        \n                        if (type.getTypeHandler() == null) {\n                            throw new IllegalArgumentException(\"Cannot find a deserializer for non-concrete Map type \"+type);\n                        }\n                        deser = AbstractDeserializer.constructForNonPOJO(beanDesc);\n                    }\n                } else {\n                    \n                    deser = JavaUtilCollectionsDeserializers.findForMap(ctxt, type);\n                    if (deser != null) {\n                        return deser;\n                    }\n                }\n                if (deser == null) {\n                    ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n                    \n                    \n                    \n                    \n                    MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser);\n                    JsonIgnoreProperties.Value ignorals = config.getDefaultPropertyIgnorals(Map.class,\n                            beanDesc.getClassInfo());\n                    Set<String> ignored = (ignorals == null) ? null\n                            : ignorals.findIgnoredForDeserialization();\n                    md.setIgnorableProperties(ignored);\n                    deser = md;\n                }\n            }\n        }\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyMapDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    \n    @Override\n    public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException {\n        JavaType keyType = type.getKeyType();\n        JavaType contentType = type.getContentType();\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        \n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();\n        \n        \n        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n        \n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomMapLikeDeserializer(type, config,\n                beanDesc, keyDes, contentTypeDeser, contentDeser);\n        if (deser != null) {\n            \n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyMapLikeDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    \n    \n    \n    @Override\n    public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        final Class<?> enumClass = type.getRawClass();\n        \n        JsonDeserializer<?> deser = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n\n        if (deser == null) {\n            ValueInstantiator valueInstantiator = _constructDefaultValueInstantiator(ctxt, beanDesc);\n            SettableBeanProperty[] creatorProps = (valueInstantiator == null) ? null\n                    : valueInstantiator.getFromObjectArguments(ctxt.getConfig());\n            \n            for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n                if (_hasCreatorAnnotation(ctxt, factory)) {\n                    if (factory.getParameterCount() == 0) { \n                        deser = EnumDeserializer.deserializerForNoArgsCreator(config, enumClass, factory);\n                        break;\n                    }\n                    Class<?> returnType = factory.getRawReturnType();\n                    \n                    if (returnType.isAssignableFrom(enumClass)) {\n                        deser = EnumDeserializer.deserializerForCreator(config, enumClass, factory, valueInstantiator, creatorProps);\n                        break;\n                    }\n                }\n            }\n           \n            \n            if (deser == null) {\n                deser = new EnumDeserializer(constructEnumResolver(enumClass,\n                        config, beanDesc.findJsonValueAccessor()),\n                        config.isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_ENUMS));\n            }\n        }\n\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyEnumDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    @Override\n    public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException {\n        @SuppressWarnings(\"unchecked\")\n        Class<? extends JsonNode> nodeClass = (Class<? extends JsonNode>) nodeType.getRawClass();\n        \n        JsonDeserializer<?> custom = _findCustomTreeNodeDeserializer(nodeClass, config,\n                beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        return JsonNodeDeserializer.getDeserializer(nodeClass);\n    }\n\n    @Override\n    public JsonDeserializer<?> createReferenceDeserializer(DeserializationContext ctxt, ReferenceType type, BeanDescription beanDesc) throws JsonMappingException {\n        JavaType contentType = type.getContentType();\n        \n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        if (contentTypeDeser == null) { \n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomReferenceDeserializer(type, config, beanDesc,\n                contentTypeDeser, contentDeser);\n\n        if (deser == null) {\n            \n            if (type.isTypeOrSubTypeOf(AtomicReference.class)) {\n                Class<?> rawType = type.getRawClass();\n                ValueInstantiator inst;\n                if (rawType == AtomicReference.class) {\n                    inst = null;\n                } else {\n                    \n                    inst = findValueInstantiator(ctxt, beanDesc);\n                }\n                return new AtomicReferenceDeserializer(type, inst, contentTypeDeser, contentDeser);\n            }\n        }\n        if (deser != null) {\n            \n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyReferenceDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    \n\n    @Override\n    public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n        BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n        AnnotatedClass ac = bean.getClassInfo();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n\n        \n        \n        Collection<NamedType> subtypes = null;\n        if (b == null) {\n            b = config.getDefaultTyper(baseType);\n            if (b == null) {\n                return null;\n            }\n        } else {\n            subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n        }\n        \n        \n        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n            JavaType defaultType = mapAbstractType(config, baseType);\n            if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n                b = b.defaultImpl(defaultType.getRawClass());\n            }\n        }\n        \n        \n        try {\n            return b.buildTypeDeserializer(config, baseType, subtypes);\n        } catch (IllegalArgumentException e0) {\n            InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null,\n                    ClassUtil.exceptionMessage(e0), baseType);\n            e.initCause(e0);\n            throw e;\n        }\n    }\n\n    \n    protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        return OptionalHandlerFactory.instance.findDeserializer(type, ctxt.getConfig(), beanDesc);\n    }\n    \n    \n    \n    @Override\n    public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        KeyDeserializer deser = null;\n        if (_factoryConfig.hasKeyDeserializers()) {\n            BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n            for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n                deser = d.findKeyDeserializer(type, config, beanDesc);\n                if (deser != null) {\n                    break;\n                }\n            }\n        }\n        \n        if (deser == null) {\n            if (type.isEnumType()) {\n                deser = _createEnumKeyDeserializer(ctxt, type);\n            } else {\n                deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n            }\n        }\n        \n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyKeyDeserializer(config, type, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        Class<?> enumClass = type.getRawClass();\n\n        BeanDescription beanDesc = config.introspect(type);\n        \n        KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n            return des;\n        } else {\n            \n            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n            if (custom != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n            }\n            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n            if (valueDesForKey != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);\n            }\n        }\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueAccessor());\n        \n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (_hasCreatorAnnotation(ctxt, factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n                    Class<?> returnType = factory.getRawReturnType();\n                    \n                    if (returnType.isAssignableFrom(enumClass)) {\n                        \n                        if (factory.getRawParameterType(0) != String.class) {\n                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n                        }\n                        if (config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(factory.getMember(),\n                                    ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                        }\n                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                    }\n                }\n                throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n                        +enumClass.getName()+\")\");\n            }\n        }\n        \n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }\n\n    \n\n    \n    public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, annotated, baseType);        \n        \n        if (b == null) {\n            return findTypeDeserializer(config, baseType);\n        }\n        \n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(\n                config, annotated, baseType);\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    }\n    \n        \n    public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, propertyEntity, containerType);        \n        JavaType contentType = containerType.getContentType();\n        \n        if (b == null) {\n            return findTypeDeserializer(config, contentType);\n        }\n        \n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(\n                config, propertyEntity, contentType);\n        return b.buildTypeDeserializer(config, contentType, subtypes);\n    }\n\n    \n    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        Class<?> rawType = type.getRawClass();\n        \n        if (rawType == CLASS_OBJECT) {\n            \n            DeserializationConfig config = ctxt.getConfig();\n            JavaType lt, mt;\n            \n            if (_factoryConfig.hasAbstractTypeResolvers()) {\n                lt = _findRemappedType(config, List.class);\n                mt = _findRemappedType(config, Map.class);\n            } else {\n                lt = mt = null;\n            }\n            return new UntypedObjectDeserializer(lt, mt);\n        }\n        if (rawType == CLASS_STRING || rawType == CLASS_CHAR_SEQUENCE) {\n            return StringDeserializer.instance;\n        }\n        if (rawType == CLASS_ITERABLE) {\n            \n            TypeFactory tf = ctxt.getTypeFactory();\n            JavaType[] tps = tf.findTypeParameters(type, CLASS_ITERABLE);\n            JavaType elemType = (tps == null || tps.length != 1) ? TypeFactory.unknownType() : tps[0];\n            CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n            \n            return createCollectionDeserializer(ctxt, ct, beanDesc);\n        }\n        if (rawType == CLASS_MAP_ENTRY) {\n            \n            JavaType kt = type.containedTypeOrUnknown(0);\n            JavaType vt = type.containedTypeOrUnknown(1);\n            TypeDeserializer vts = (TypeDeserializer) vt.getTypeHandler();\n            if (vts == null) {\n                vts = findTypeDeserializer(ctxt.getConfig(), vt);\n            }\n            JsonDeserializer<Object> valueDeser = vt.getValueHandler();\n            KeyDeserializer keyDes = (KeyDeserializer) kt.getValueHandler();\n            return new MapEntryDeserializer(type, keyDes, valueDeser, vts);\n        }\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            \n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n            }\n            if (deser != null) {\n                return deser;\n            }\n        }\n        \n        if (rawType == TokenBuffer.class) {\n            return new TokenBufferDeserializer();\n        }\n        JsonDeserializer<?> deser = findOptionalStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n        return JdkDeserializers.find(rawType, clsName);\n    }\n\n    protected JavaType _findRemappedType(DeserializationConfig config, Class<?> rawType) throws JsonMappingException {\n        JavaType type = mapAbstractType(config, config.constructType(rawType));\n        return (type == null || type.hasRawClass(rawType)) ? null : type;\n    }\n\n    \n\n    protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomReferenceDeserializer(ReferenceType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer contentTypeDeserializer, JsonDeserializer<?> contentDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findReferenceDeserializer(type, config, beanDesc,\n                    contentTypeDeserializer, contentDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findBeanDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return (JsonDeserializer<Object>) deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findArrayDeserializer(type, config,\n                    beanDesc, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findCollectionDeserializer(type, config, beanDesc,\n                    elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findCollectionLikeDeserializer(type, config, beanDesc,\n                    elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findMapDeserializer(type, config, beanDesc,\n                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findMapLikeDeserializer(type, config, beanDesc,\n                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    \n    \n    \n    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n            Object deserDef = intr.findDeserializer(ann);\n            if (deserDef != null) {\n                return ctxt.deserializerInstance(ann, deserDef);\n            }\n        }\n        return null;\n    }\n\n    \n    protected KeyDeserializer findKeyDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n            Object deserDef = intr.findKeyDeserializer(ann);\n            if (deserDef != null) {\n                return ctxt.keyDeserializerInstance(ann, deserDef);\n            }\n        }\n        return null;\n    }\n\n    \n    protected JsonDeserializer<Object> findContentDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n            Object deserDef = intr.findContentDeserializer(ann);\n            if (deserDef != null) {\n                return ctxt.deserializerInstance(ann, deserDef);\n            }\n        }\n        return null;\n    }\n    \n    \n    protected JavaType resolveMemberAndTypeAnnotations(DeserializationContext ctxt, AnnotatedMember member, JavaType type) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr == null) {\n            return type;\n        }\n\n        \n        \n\n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            if (keyType != null) {\n                Object kdDef = intr.findKeyDeserializer(member);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); \n                }\n            }\n        }\n\n        if (type.hasContentType()) { \n            Object cdDef = intr.findContentDeserializer(member);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef);\n            if (cd != null) {\n                type = type.withContentValueHandler(cd);\n            }\n            TypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(\n                    ctxt.getConfig(), type, (AnnotatedMember) member);            \t\n            if (contentTypeDeser != null) {\n                type = type.withContentTypeHandler(contentTypeDeser);\n            }\n        }\n        TypeDeserializer valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(),\n                    type, (AnnotatedMember) member);\n        if (valueTypeDeser != null) {\n            type = type.withTypeHandler(valueTypeDeser);\n        }\n\n        \n\n        \n        \n        \n        type = intr.refineDeserializationType(ctxt.getConfig(), member, type);\n        return type;\n    }\n\n    protected EnumResolver constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMember jsonValueAccessor) {\n        if (jsonValueAccessor != null) {\n            if (config.canOverrideAccessModifiers()) {\n                ClassUtil.checkAndFixAccess(jsonValueAccessor.getMember(),\n                        config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n            return EnumResolver.constructUnsafeUsingMethod(enumClass,\n                    jsonValueAccessor, config.getAnnotationIntrospector());\n        }\n        \n        \n        return EnumResolver.constructUnsafe(enumClass, config.getAnnotationIntrospector());\n    }\n\n    \n    protected boolean _hasCreatorAnnotation(DeserializationContext ctxt, Annotated ann) {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n            JsonCreator.Mode mode = intr.findCreatorAnnotation(ctxt.getConfig(), ann);\n            return (mode != null) && (mode != JsonCreator.Mode.DISABLED); \n        }\n        return false;\n    }\n    \n    \n    \n    \n    @Deprecated\n    protected JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr == null) {\n            return type;\n        }\n        return intr.refineDeserializationType(ctxt.getConfig(), a, type);\n    }\n\n    \n    @Deprecated \n    protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException {\n        return resolveMemberAndTypeAnnotations(ctxt, member, type);\n    }\n\n    \n    @Deprecated \n    protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType) {\n        if (enumType == null) {\n            return null;\n        }\n        BeanDescription beanDesc = config.introspect(enumType);\n        return beanDesc.findJsonValueMethod();\n    }\n}\n",
      "buggy_signatures": [
        "protected final DeserializerFactoryConfig _factoryConfig; protected BasicDeserializerFactory(DeserializerFactoryConfig config)",
        "public DeserializerFactoryConfig getFactoryConfig()",
        "protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); @Override public final DeserializerFactory withAdditionalDeserializers(Deserializers additional)",
        "public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional)",
        "public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier)",
        "public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver)",
        "public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators)",
        "public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException",
        "public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException",
        "private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException",
        "protected Map<AnnotatedWithParams,BeanPropertyDefinition[]> _findCreatorsFromProperties(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException",
        "public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException",
        "protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException",
        "protected void _addExplicitDelegatingCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException",
        "protected void _addExplicitPropertyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException",
        "private boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr, AnnotatedWithParams creator, BeanPropertyDefinition propDef)",
        "private void _checkImplicitlyNamedConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, List<AnnotatedWithParams> implicitCtors) throws JsonMappingException",
        "protected void _addDeserializerFactoryMethods (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException",
        "protected boolean _handleSingleArgumentCreator(CreatorCollector creators, AnnotatedWithParams ctor, boolean isCreator, boolean isVisible)",
        "protected void _reportUnwrappedCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedParameter param) throws JsonMappingException",
        "protected SettableBeanProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, PropertyName name, int index, AnnotatedParameter param, JacksonInject.Value injectable) throws JsonMappingException",
        "private PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr)",
        "public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config)",
        "public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createReferenceDeserializer(DeserializationContext ctxt, ReferenceType type, BeanDescription beanDesc) throws JsonMappingException",
        "public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException",
        "protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException",
        "private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException",
        "public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException",
        "public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException",
        "public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected JavaType _findRemappedType(DeserializationConfig config, Class<?> rawType) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomReferenceDeserializer(ReferenceType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer contentTypeDeserializer, JsonDeserializer<?> contentDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException",
        "protected KeyDeserializer findKeyDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException",
        "protected JsonDeserializer<Object> findContentDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException",
        "protected JavaType resolveMemberAndTypeAnnotations(DeserializationContext ctxt, AnnotatedMember member, JavaType type) throws JsonMappingException",
        "protected EnumResolver constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMember jsonValueAccessor)",
        "protected boolean _hasCreatorAnnotation(DeserializationContext ctxt, Annotated ann)",
        "protected JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException",
        "protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException",
        "protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType)"
      ],
      "fixed_signatures": [
        "protected final DeserializerFactoryConfig _factoryConfig; protected BasicDeserializerFactory(DeserializerFactoryConfig config)",
        "public DeserializerFactoryConfig getFactoryConfig()",
        "protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); @Override public final DeserializerFactory withAdditionalDeserializers(Deserializers additional)",
        "public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional)",
        "public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier)",
        "public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver)",
        "public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators)",
        "public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException",
        "public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException",
        "private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException",
        "protected Map<AnnotatedWithParams,BeanPropertyDefinition[]> _findCreatorsFromProperties(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException",
        "public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException",
        "protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException",
        "protected void _addExplicitDelegatingCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException",
        "protected void _addExplicitPropertyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException",
        "private boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr, AnnotatedWithParams creator, BeanPropertyDefinition propDef)",
        "private void _checkImplicitlyNamedConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, List<AnnotatedWithParams> implicitCtors) throws JsonMappingException",
        "protected void _addDeserializerFactoryMethods (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException",
        "protected boolean _handleSingleArgumentCreator(CreatorCollector creators, AnnotatedWithParams ctor, boolean isCreator, boolean isVisible)",
        "protected void _reportUnwrappedCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedParameter param) throws JsonMappingException",
        "protected SettableBeanProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, PropertyName name, int index, AnnotatedParameter param, JacksonInject.Value injectable) throws JsonMappingException",
        "private PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr)",
        "public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config)",
        "public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createReferenceDeserializer(DeserializationContext ctxt, ReferenceType type, BeanDescription beanDesc) throws JsonMappingException",
        "public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException",
        "protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException",
        "private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException",
        "public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException",
        "public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException",
        "public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected JavaType _findRemappedType(DeserializationConfig config, Class<?> rawType) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomReferenceDeserializer(ReferenceType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer contentTypeDeserializer, JsonDeserializer<?> contentDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException",
        "protected KeyDeserializer findKeyDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException",
        "protected JsonDeserializer<Object> findContentDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException",
        "protected JavaType resolveMemberAndTypeAnnotations(DeserializationContext ctxt, AnnotatedMember member, JavaType type) throws JsonMappingException",
        "protected EnumResolver constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMember jsonValueAccessor)",
        "protected boolean _hasCreatorAnnotation(DeserializationContext ctxt, Annotated ann)",
        "protected JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException",
        "protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException",
        "protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType)"
      ],
      "methods": [
        {
          "buggy_method": "  public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n  BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n  AnnotatedClass ac = bean.getClassInfo();\n  AnnotationIntrospector ai = config.getAnnotationIntrospector();\n  TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n\n  \n  \n  Collection<NamedType> subtypes = null;\n  if (b == null) {\n  b = config.getDefaultTyper(baseType);\n  if (b == null) {\n  return null;\n  }\n  } else {\n  subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n  }\n  \n  \n  if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n  JavaType defaultType = mapAbstractType(config, baseType);\n  if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n  b = b.defaultImpl(defaultType.getRawClass());\n  }\n  }\n  \n  \n  try {\n  return b.buildTypeDeserializer(config, baseType, subtypes);\n  } catch (IllegalArgumentException e0) {\n  InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null,\n  e0.getMessage(), baseType);\n  e.initCause(e0);\n  throw e;\n  }\n  }",
          "fixed_method": "  public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n  BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n  AnnotatedClass ac = bean.getClassInfo();\n  AnnotationIntrospector ai = config.getAnnotationIntrospector();\n  TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n\n  \n  \n  Collection<NamedType> subtypes = null;\n  if (b == null) {\n  b = config.getDefaultTyper(baseType);\n  if (b == null) {\n  return null;\n  }\n  } else {\n  subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n  }\n  \n  \n  if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n  JavaType defaultType = mapAbstractType(config, baseType);\n  if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n  b = b.defaultImpl(defaultType.getRawClass());\n  }\n  }\n  \n  \n  try {\n  return b.buildTypeDeserializer(config, baseType, subtypes);\n  } catch (IllegalArgumentException e0) {\n  InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null,\n  ClassUtil.exceptionMessage(e0), baseType);\n  e.initCause(e0);\n  throw e;\n  }\n  }",
          "diff": [
            "@@ -1586,7 +1586,7 @@",
            "             return b.buildTypeDeserializer(config, baseType, subtypes);\n",
            "         } catch (IllegalArgumentException e0) {\n",
            "             InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null,\n",
            "-                    e0.getMessage(), baseType);\n",
            "+                    ClassUtil.exceptionMessage(e0), baseType);\n",
            "             e.initCause(e0);\n",
            "             throw e;\n",
            "         }\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.deser;\n\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\nimport com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\nimport com.fasterxml.jackson.databind.deser.impl.*;\nimport com.fasterxml.jackson.databind.deser.std.ThrowableDeserializer;\nimport com.fasterxml.jackson.databind.exc.InvalidDefinitionException;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.impl.SubTypeValidator;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.SimpleBeanPropertyDefinition;\n\n\npublic class BeanDeserializerFactory extends BasicDeserializerFactory implements java.io.Serializable { private static final long serialVersionUID = 1; private final static Class<?>[] INIT_CAUSE_PARAMS = new Class<?>[] { Throwable.class }; public final static BeanDeserializerFactory instance = new BeanDeserializerFactory( new DeserializerFactoryConfig()); public BeanDeserializerFactory(DeserializerFactoryConfig config) {\n        super(config);\n    }\n    \n    \n    @Override\n    public DeserializerFactory withConfig(DeserializerFactoryConfig config) {\n        if (_factoryConfig == config) {\n            return this;\n        }\n        \n        ClassUtil.verifyMustOverride(BeanDeserializerFactory.class, this, \"withConfig\");\n        return new BeanDeserializerFactory(config);\n    }\n    \n    \n\n    \n    @Override\n    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        \n        if (type.isThrowable()) {\n            return buildThrowableDeserializer(ctxt, type, beanDesc);\n        }\n        \n        \n\n        \n        \n        if (type.isAbstract() && !type.isPrimitive() && !type.isEnumType()) {\n            \n            JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n            if (concreteType != null) {\n                \n                beanDesc = config.introspect(concreteType);\n                return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n            }\n        }\n        \n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n\n        \n        if (!isPotentialBeanType(type.getRawClass())) {\n            return null;\n        }\n        \n        _validateSubType(ctxt, type, beanDesc);\n        \n        return buildBeanDeserializer(ctxt, type, beanDesc);\n    }\n\n    @Override\n    public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException {\n        \n        JavaType builderType = ctxt.constructType(builderClass);\n        BeanDescription builderDesc = ctxt.getConfig().introspectForBuilder(builderType);\n        return buildBuilderBasedDeserializer(ctxt, valueType, builderDesc);\n    }\n\n    \n    protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        \n        \n        JsonDeserializer<?> deser = findDefaultDeserializer(ctxt, type, beanDesc);\n        \n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyDeserializer(ctxt.getConfig(), beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n    \n    protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        \n        for (AbstractTypeResolver r : _factoryConfig.abstractTypeResolvers()) {\n            JavaType concrete = r.resolveAbstractType(ctxt.getConfig(), beanDesc);\n            if (concrete != null) {\n                return concrete;\n            }\n        }\n        return null;\n    }\n\n    \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        \n        ValueInstantiator valueInstantiator;\n        \n        try {\n            valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n        } catch (NoClassDefFoundError error) {\n            return new ErrorThrowingDeserializer(error);\n        } catch (IllegalArgumentException e) {\n            \n            \n            \n            throw InvalidDefinitionException.from(ctxt.getParser(),\n                    e.getMessage(),\n                    beanDesc, null);\n        }\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n        builder.setValueInstantiator(valueInstantiator);\n         \n        addBeanProps(ctxt, beanDesc, builder);\n        addObjectIdReader(ctxt, beanDesc, builder);\n\n        \n        addBackReferenceProperties(ctxt, beanDesc, builder);\n        addInjectables(ctxt, beanDesc, builder);\n        \n        final DeserializationConfig config = ctxt.getConfig();\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer;\n\n        if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n            deserializer = builder.buildAbstract();\n        } else {\n            deserializer = builder.build();\n        }\n        \n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }\n    \n    \n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> buildBuilderBasedDeserializer( DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n        \n        ValueInstantiator valueInstantiator;\n        try {\n            valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n        } catch (NoClassDefFoundError error) {\n            return new ErrorThrowingDeserializer(error);\n        } catch (IllegalArgumentException e) {\n            \n            \n            \n            throw InvalidDefinitionException.from(ctxt.getParser(),\n                    e.getMessage(),\n                    builderDesc, null);\n        }\n        final DeserializationConfig config = ctxt.getConfig();\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n        builder.setValueInstantiator(valueInstantiator);\n         \n        addBeanProps(ctxt, builderDesc, builder);\n        addObjectIdReader(ctxt, builderDesc, builder);\n        \n        \n        addBackReferenceProperties(ctxt, builderDesc, builder);\n        addInjectables(ctxt, builderDesc, builder);\n\n        JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n        final String buildMethodName = (builderConfig == null) ?\n                JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n        \n        \n        AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n        if (buildMethod != null) { \n            if (config.canOverrideAccessModifiers()) {\n            \tClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n        }\n        builder.setPOJOBuilder(buildMethod, builderConfig);\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, builderDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer = builder.buildBuilderBased(\n        \t\tvalueType, buildMethodName);\n\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }\n    \n    protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return;\n        }\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n        JavaType idType;\n        SettableBeanProperty idProp;\n        ObjectIdGenerator<?> gen;\n\n        ObjectIdResolver resolver = ctxt.objectIdResolverInstance(beanDesc.getClassInfo(), objectIdInfo);\n\n        \n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { \n            PropertyName propName = objectIdInfo.getPropertyName();\n            idProp = builder.findProperty(propName);\n            if (idProp == null) {\n                throw new IllegalArgumentException(\"Invalid Object Id definition for \"\n                        +beanDesc.getBeanClass().getName()+\": cannot find property with name '\"+propName+\"'\");\n            }\n            idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope());\n        } else {\n            JavaType type = ctxt.constructType(implClass);\n            idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n            idProp = null;\n            gen = ctxt.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        }\n        \n        JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType);\n        builder.setObjectIdReader(ObjectIdReader.construct(idType,\n                objectIdInfo.getPropertyName(), gen, deser, idProp, resolver));\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n        builder.setValueInstantiator(findValueInstantiator(ctxt, beanDesc));\n\n        addBeanProps(ctxt, beanDesc, builder);\n        \n\n        \n        \n        AnnotatedMethod am = beanDesc.findMethod(\"initCause\", INIT_CAUSE_PARAMS);\n        if (am != null) { \n            SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), am,\n                    new PropertyName(\"cause\"));\n            SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, propDef,\n                    am.getParameterType(0));\n            if (prop != null) {\n                \n                \n                builder.addOrReplaceProperty(prop, true);\n            }\n        }\n\n        \n        builder.addIgnorable(\"localizedMessage\");\n        \n        builder.addIgnorable(\"suppressed\");\n        \n        \n        \n\n\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer = builder.build();\n        \n        \n        if (deserializer instanceof BeanDeserializer) {\n            deserializer = new ThrowableDeserializer((BeanDeserializer) deserializer);\n        }\n\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }\n\n    \n\n    \n    protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc) {\n        return new BeanDeserializerBuilder(beanDesc, ctxt);\n    }\n    \n    \n    protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n        final boolean isConcrete = !beanDesc.getType().isAbstract();\n        final SettableBeanProperty[] creatorProps = isConcrete\n                ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n                : null;\n        final boolean hasCreatorProps = (creatorProps != null);\n\n        \n        \n        \n        \n        JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n                .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                        beanDesc.getClassInfo());\n        Set<String> ignored;\n        if (ignorals != null) {\n            boolean ignoreAny = ignorals.getIgnoreUnknown();\n            builder.setIgnoreUnknownProperties(ignoreAny);\n            \n            ignored = ignorals.findIgnoredForDeserialization();\n            for (String propName : ignored) {\n                builder.addIgnorable(propName);\n            }\n        } else {\n            ignored = Collections.emptySet();\n        }\n\n        \n        AnnotatedMember anySetter = beanDesc.findAnySetterAccessor();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        } else {\n            \n            \n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    \n                    \n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n\n        \n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n\n        \n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            \n            \n            \n            \n            if (propDef.hasSetter()) {\n                AnnotatedMethod setter = propDef.getSetter();\n                JavaType propertyType = setter.getParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                AnnotatedField field = propDef.getField();\n                JavaType propertyType = field.getType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else {\n                \n                AnnotatedMethod getter = propDef.getGetter();\n                if (getter != null) {\n                    if (useGettersAsSetters && _isSetterlessType(getter.getRawType())) {\n                        \n                        \n                        if (builder.hasIgnorable(propDef.getName())) {\n                            ;\n                        } else {\n                            prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                        }\n                    } else if (!propDef.hasConstructorParameter()) {\n                        PropertyMetadata md = propDef.getMetadata();\n                        \n                        \n                        \n                        \n                        if (md.getMergeInfo() != null) {\n                            prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                        }\n                    }\n                }\n            }\n\n            \n            \n            if (hasCreatorProps && propDef.hasConstructorParameter()) {\n                \n                \n                final String name = propDef.getName();\n                CreatorProperty cprop = null;\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                            cprop = (CreatorProperty) cp;\n                            break;\n                        }\n                    }\n                }\n                if (cprop == null) {\n                    List<String> n = new ArrayList<>();\n                    for (SettableBeanProperty cp : creatorProps) {\n                        n.add(cp.getName());\n                    }\n                    ctxt.reportBadPropertyDefinition(beanDesc, propDef,\n                            \"Could not find creator property with name '%s' (known Creator properties: %s)\",\n                            name, n);\n                    continue;\n                }\n                if (prop != null) {\n                    cprop.setFallbackSetter(prop);\n                }\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    views = beanDesc.findDefaultViews();\n                }\n                cprop.setViews(views);\n                builder.addCreatorProperty(cprop);\n                continue;\n            }\n            if (prop != null) {\n                \n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    views = beanDesc.findDefaultViews();\n                }\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }\n\n    private boolean _isSetterlessType(Class<?> rawType) {\n        \n        \n        \n        return Collection.class.isAssignableFrom(rawType)\n                || Map.class.isAssignableFrom(rawType);\n    }\n\n    \n    protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException {\n        ArrayList<BeanPropertyDefinition> result = new ArrayList<BeanPropertyDefinition>(\n                Math.max(4, propDefsIn.size()));\n        HashMap<Class<?>,Boolean> ignoredTypes = new HashMap<Class<?>,Boolean>();\n        \n        for (BeanPropertyDefinition property : propDefsIn) {\n            String name = property.getName();\n            if (ignored.contains(name)) { \n                continue;\n            }\n            if (!property.hasConstructorParameter()) { \n                Class<?> rawPropertyType = property.getRawPrimaryType();\n                \n                if ((rawPropertyType != null)\n                        && isIgnorableType(ctxt.getConfig(), property, rawPropertyType, ignoredTypes)) {\n                    \n                    builder.addIgnorable(name);\n                    continue;\n                }\n            }\n            result.add(property);\n        }\n        return result;\n    }\n\n    \n    protected void addBackReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n        \n        List<BeanPropertyDefinition> refProps = beanDesc.findBackReferences();\n        if (refProps != null) {\n            for (BeanPropertyDefinition refProp : refProps) {\n                \n                String refName = refProp.findReferenceName();\n                builder.addBackReferenceProperty(refName, constructSettableProperty(ctxt,\n                        beanDesc, refProp, refProp.getPrimaryType()));\n            }\n        }\n    }\n\n    @Deprecated \n    protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n        addBackReferenceProperties(ctxt, beanDesc, builder);\n    }\n\n    \n    protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n        Map<Object, AnnotatedMember> raw = beanDesc.findInjectables();\n        if (raw != null) {\n            for (Map.Entry<Object, AnnotatedMember> entry : raw.entrySet()) {\n                AnnotatedMember m = entry.getValue();\n                builder.addInjectable(PropertyName.construct(m.getName()),\n                        m.getType(),\n                        beanDesc.getClassAnnotations(), m, entry.getKey());\n            }\n        }\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMember mutator) throws JsonMappingException {\n        \n        BeanProperty prop;\n        JavaType keyType;\n        JavaType valueType;\n\n        if (mutator instanceof AnnotatedMethod) {\n            \n            AnnotatedMethod am = (AnnotatedMethod) mutator;\n            keyType = am.getParameterType(0);\n            valueType = am.getParameterType(1);\n            valueType = resolveMemberAndTypeAnnotations(ctxt, mutator, valueType);\n            prop = new BeanProperty.Std(PropertyName.construct(mutator.getName()),\n                    valueType, null, mutator,\n                    PropertyMetadata.STD_OPTIONAL);\n\n        } else if (mutator instanceof AnnotatedField) {\n            AnnotatedField af = (AnnotatedField) mutator;\n            \n            JavaType mapType = af.getType();\n            mapType = resolveMemberAndTypeAnnotations(ctxt, mutator, mapType);\n            keyType = mapType.getKeyType();\n            valueType = mapType.getContentType();\n            prop = new BeanProperty.Std(PropertyName.construct(mutator.getName()),\n                    mapType, null, mutator, PropertyMetadata.STD_OPTIONAL);\n        } else {\n            return ctxt.reportBadDefinition(beanDesc.getType(), String.format(\n                    \"Unrecognized mutator type for any setter: %s\", mutator.getClass()));\n        }\n        \n        \n        KeyDeserializer keyDeser = findKeyDeserializerFromAnnotation(ctxt, mutator);\n        if (keyDeser == null) {\n            keyDeser = keyType.getValueHandler();\n        }\n        if (keyDeser == null) {\n            keyDeser = ctxt.findKeyDeserializer(keyType, prop);\n        } else {\n            if (keyDeser instanceof ContextualKeyDeserializer) {\n                keyDeser = ((ContextualKeyDeserializer) keyDeser)\n                        .createContextual(ctxt, prop);\n            }\n        }\n        JsonDeserializer<Object> deser = findContentDeserializerFromAnnotation(ctxt, mutator);\n        if (deser == null) {\n            deser = valueType.getValueHandler();\n        }\n        if (deser != null) {\n            \n            deser = (JsonDeserializer<Object>) ctxt.handlePrimaryContextualization(deser, prop, valueType);\n        }\n        TypeDeserializer typeDeser = valueType.getTypeHandler();\n        return new SettableAnyProperty(prop, mutator, valueType,\n                keyDeser, deser, typeDeser);\n    }\n\n    \n    protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, JavaType propType0) throws JsonMappingException {\n        \n        AnnotatedMember mutator = propDef.getNonConstructorMutator();\n        \n        \n        \n        if (mutator == null) {\n            ctxt.reportBadPropertyDefinition(beanDesc, propDef, \"No non-constructor mutator available\");\n        }\n        JavaType type = resolveMemberAndTypeAnnotations(ctxt, mutator, propType0);\n        \n        TypeDeserializer typeDeser = type.getTypeHandler();\n        SettableBeanProperty prop;\n        if (mutator instanceof AnnotatedMethod) {\n            prop = new MethodProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n        } else {\n            \n            prop = new FieldProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n        }\n        JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, mutator);\n        if (deser == null) {\n            deser = type.getValueHandler();\n        }\n        if (deser != null) {\n            deser = ctxt.handlePrimaryContextualization(deser, prop, type);\n            prop = prop.withValueDeserializer(deser);\n        }\n        \n        AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n        if (ref != null && ref.isManagedReference()) {\n            prop.setManagedReferenceName(ref.getName());\n        }\n        ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n        if (objectIdInfo != null){\n            prop.setObjectIdInfo(objectIdInfo);\n        }\n        return prop;\n    }\n\n    \n    protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException {\n        final AnnotatedMethod getter = propDef.getGetter();\n        JavaType type = resolveMemberAndTypeAnnotations(ctxt, getter, getter.getType());\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        SettableBeanProperty prop = new SetterlessProperty(propDef, type, typeDeser,\n                beanDesc.getClassAnnotations(), getter);\n        JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, getter);\n        if (deser == null) {\n            deser = type.getValueHandler();\n        }\n        if (deser != null) {\n            deser = ctxt.handlePrimaryContextualization(deser, prop, type);\n            prop = prop.withValueDeserializer(deser);\n        }\n        return prop;\n    }\n\n    \n\n    \n    protected boolean isPotentialBeanType(Class<?> type) {\n        String typeStr = ClassUtil.canBeABeanType(type);\n        if (typeStr != null) {\n            throw new IllegalArgumentException(\"Cannot deserialize Class \"+type.getName()+\" (of type \"+typeStr+\") as a Bean\");\n        }\n        if (ClassUtil.isProxyType(type)) {\n            throw new IllegalArgumentException(\"Cannot deserialize Proxy class \"+type.getName()+\" as a Bean\");\n        }\n        \n        typeStr = ClassUtil.isLocalType(type, true);\n        if (typeStr != null) {\n            throw new IllegalArgumentException(\"Cannot deserialize Class \"+type.getName()+\" (of type \"+typeStr+\") as a Bean\");\n        }\n        return true;\n    }\n\n    \n    protected boolean isIgnorableType(DeserializationConfig config, BeanPropertyDefinition propDef, Class<?> type, Map<Class<?>,Boolean> ignoredTypes) {\n        Boolean status = ignoredTypes.get(type);\n        if (status != null) {\n            return status.booleanValue();\n        }\n        \n        if ((type == String.class) || type.isPrimitive()) {\n            status = Boolean.FALSE;\n        } else {\n            \n            status = config.getConfigOverride(type).getIsIgnoredType();\n            if (status == null) {\n                BeanDescription desc = config.introspectClassAnnotations(type);\n                status = config.getAnnotationIntrospector().isIgnorableType(desc.getClassInfo());\n                \n                if (status == null) {\n                    status = Boolean.FALSE;\n                }\n            }\n        }\n        ignoredTypes.put(type, status);\n        return status.booleanValue();\n    }\n\n    \n    protected void _validateSubType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        SubTypeValidator.instance().validateSubType(ctxt, type, beanDesc);\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.deser;\n\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\nimport com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\nimport com.fasterxml.jackson.databind.deser.impl.*;\nimport com.fasterxml.jackson.databind.deser.std.ThrowableDeserializer;\nimport com.fasterxml.jackson.databind.exc.InvalidDefinitionException;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.impl.SubTypeValidator;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.SimpleBeanPropertyDefinition;\n\n\npublic class BeanDeserializerFactory extends BasicDeserializerFactory implements java.io.Serializable { private static final long serialVersionUID = 1; private final static Class<?>[] INIT_CAUSE_PARAMS = new Class<?>[] { Throwable.class }; public final static BeanDeserializerFactory instance = new BeanDeserializerFactory( new DeserializerFactoryConfig()); public BeanDeserializerFactory(DeserializerFactoryConfig config) {\n        super(config);\n    }\n    \n    \n    @Override\n    public DeserializerFactory withConfig(DeserializerFactoryConfig config) {\n        if (_factoryConfig == config) {\n            return this;\n        }\n        \n        ClassUtil.verifyMustOverride(BeanDeserializerFactory.class, this, \"withConfig\");\n        return new BeanDeserializerFactory(config);\n    }\n    \n    \n\n    \n    @Override\n    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        \n        if (type.isThrowable()) {\n            return buildThrowableDeserializer(ctxt, type, beanDesc);\n        }\n        \n        \n\n        \n        \n        if (type.isAbstract() && !type.isPrimitive() && !type.isEnumType()) {\n            \n            JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n            if (concreteType != null) {\n                \n                beanDesc = config.introspect(concreteType);\n                return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n            }\n        }\n        \n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n\n        \n        if (!isPotentialBeanType(type.getRawClass())) {\n            return null;\n        }\n        \n        _validateSubType(ctxt, type, beanDesc);\n        \n        return buildBeanDeserializer(ctxt, type, beanDesc);\n    }\n\n    @Override\n    public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException {\n        \n        JavaType builderType = ctxt.constructType(builderClass);\n        BeanDescription builderDesc = ctxt.getConfig().introspectForBuilder(builderType);\n        return buildBuilderBasedDeserializer(ctxt, valueType, builderDesc);\n    }\n\n    \n    protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        \n        \n        JsonDeserializer<?> deser = findDefaultDeserializer(ctxt, type, beanDesc);\n        \n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyDeserializer(ctxt.getConfig(), beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n    \n    protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        \n        for (AbstractTypeResolver r : _factoryConfig.abstractTypeResolvers()) {\n            JavaType concrete = r.resolveAbstractType(ctxt.getConfig(), beanDesc);\n            if (concrete != null) {\n                return concrete;\n            }\n        }\n        return null;\n    }\n\n    \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        \n        ValueInstantiator valueInstantiator;\n        \n        try {\n            valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n        } catch (NoClassDefFoundError error) {\n            return new ErrorThrowingDeserializer(error);\n        } catch (IllegalArgumentException e) {\n            \n            \n            \n            throw InvalidDefinitionException.from(ctxt.getParser(),\n                    ClassUtil.exceptionMessage(e),\n                    beanDesc, null);\n        }\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n        builder.setValueInstantiator(valueInstantiator);\n         \n        addBeanProps(ctxt, beanDesc, builder);\n        addObjectIdReader(ctxt, beanDesc, builder);\n\n        \n        addBackReferenceProperties(ctxt, beanDesc, builder);\n        addInjectables(ctxt, beanDesc, builder);\n        \n        final DeserializationConfig config = ctxt.getConfig();\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer;\n\n        if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n            deserializer = builder.buildAbstract();\n        } else {\n            deserializer = builder.build();\n        }\n        \n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }\n    \n    \n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> buildBuilderBasedDeserializer( DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n        \n        ValueInstantiator valueInstantiator;\n        try {\n            valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n        } catch (NoClassDefFoundError error) {\n            return new ErrorThrowingDeserializer(error);\n        } catch (IllegalArgumentException e) {\n            \n            \n            \n            throw InvalidDefinitionException.from(ctxt.getParser(),\n                    ClassUtil.exceptionMessage(e),\n                    builderDesc, null);\n        }\n        final DeserializationConfig config = ctxt.getConfig();\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n        builder.setValueInstantiator(valueInstantiator);\n         \n        addBeanProps(ctxt, builderDesc, builder);\n        addObjectIdReader(ctxt, builderDesc, builder);\n        \n        \n        addBackReferenceProperties(ctxt, builderDesc, builder);\n        addInjectables(ctxt, builderDesc, builder);\n\n        JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n        final String buildMethodName = (builderConfig == null) ?\n                JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n        \n        \n        AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n        if (buildMethod != null) { \n            if (config.canOverrideAccessModifiers()) {\n            \tClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n        }\n        builder.setPOJOBuilder(buildMethod, builderConfig);\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, builderDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer = builder.buildBuilderBased(\n        \t\tvalueType, buildMethodName);\n\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }\n    \n    protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return;\n        }\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n        JavaType idType;\n        SettableBeanProperty idProp;\n        ObjectIdGenerator<?> gen;\n\n        ObjectIdResolver resolver = ctxt.objectIdResolverInstance(beanDesc.getClassInfo(), objectIdInfo);\n\n        \n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { \n            PropertyName propName = objectIdInfo.getPropertyName();\n            idProp = builder.findProperty(propName);\n            if (idProp == null) {\n                throw new IllegalArgumentException(\"Invalid Object Id definition for \"\n                        +beanDesc.getBeanClass().getName()+\": cannot find property with name '\"+propName+\"'\");\n            }\n            idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope());\n        } else {\n            JavaType type = ctxt.constructType(implClass);\n            idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n            idProp = null;\n            gen = ctxt.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        }\n        \n        JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType);\n        builder.setObjectIdReader(ObjectIdReader.construct(idType,\n                objectIdInfo.getPropertyName(), gen, deser, idProp, resolver));\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n        builder.setValueInstantiator(findValueInstantiator(ctxt, beanDesc));\n\n        addBeanProps(ctxt, beanDesc, builder);\n        \n\n        \n        \n        AnnotatedMethod am = beanDesc.findMethod(\"initCause\", INIT_CAUSE_PARAMS);\n        if (am != null) { \n            SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), am,\n                    new PropertyName(\"cause\"));\n            SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, propDef,\n                    am.getParameterType(0));\n            if (prop != null) {\n                \n                \n                builder.addOrReplaceProperty(prop, true);\n            }\n        }\n\n        \n        builder.addIgnorable(\"localizedMessage\");\n        \n        builder.addIgnorable(\"suppressed\");\n        \n        \n        \n\n\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer = builder.build();\n        \n        \n        if (deserializer instanceof BeanDeserializer) {\n            deserializer = new ThrowableDeserializer((BeanDeserializer) deserializer);\n        }\n\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }\n\n    \n\n    \n    protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc) {\n        return new BeanDeserializerBuilder(beanDesc, ctxt);\n    }\n    \n    \n    protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n        final boolean isConcrete = !beanDesc.getType().isAbstract();\n        final SettableBeanProperty[] creatorProps = isConcrete\n                ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n                : null;\n        final boolean hasCreatorProps = (creatorProps != null);\n\n        \n        \n        \n        \n        JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n                .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                        beanDesc.getClassInfo());\n        Set<String> ignored;\n        if (ignorals != null) {\n            boolean ignoreAny = ignorals.getIgnoreUnknown();\n            builder.setIgnoreUnknownProperties(ignoreAny);\n            \n            ignored = ignorals.findIgnoredForDeserialization();\n            for (String propName : ignored) {\n                builder.addIgnorable(propName);\n            }\n        } else {\n            ignored = Collections.emptySet();\n        }\n\n        \n        AnnotatedMember anySetter = beanDesc.findAnySetterAccessor();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        } else {\n            \n            \n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    \n                    \n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n\n        \n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n\n        \n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            \n            \n            \n            \n            if (propDef.hasSetter()) {\n                AnnotatedMethod setter = propDef.getSetter();\n                JavaType propertyType = setter.getParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                AnnotatedField field = propDef.getField();\n                JavaType propertyType = field.getType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else {\n                \n                AnnotatedMethod getter = propDef.getGetter();\n                if (getter != null) {\n                    if (useGettersAsSetters && _isSetterlessType(getter.getRawType())) {\n                        \n                        \n                        if (builder.hasIgnorable(propDef.getName())) {\n                            ;\n                        } else {\n                            prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                        }\n                    } else if (!propDef.hasConstructorParameter()) {\n                        PropertyMetadata md = propDef.getMetadata();\n                        \n                        \n                        \n                        \n                        if (md.getMergeInfo() != null) {\n                            prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                        }\n                    }\n                }\n            }\n\n            \n            \n            if (hasCreatorProps && propDef.hasConstructorParameter()) {\n                \n                \n                final String name = propDef.getName();\n                CreatorProperty cprop = null;\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                            cprop = (CreatorProperty) cp;\n                            break;\n                        }\n                    }\n                }\n                if (cprop == null) {\n                    List<String> n = new ArrayList<>();\n                    for (SettableBeanProperty cp : creatorProps) {\n                        n.add(cp.getName());\n                    }\n                    ctxt.reportBadPropertyDefinition(beanDesc, propDef,\n                            \"Could not find creator property with name '%s' (known Creator properties: %s)\",\n                            name, n);\n                    continue;\n                }\n                if (prop != null) {\n                    cprop.setFallbackSetter(prop);\n                }\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    views = beanDesc.findDefaultViews();\n                }\n                cprop.setViews(views);\n                builder.addCreatorProperty(cprop);\n                continue;\n            }\n            if (prop != null) {\n                \n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    views = beanDesc.findDefaultViews();\n                }\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }\n\n    private boolean _isSetterlessType(Class<?> rawType) {\n        \n        \n        \n        return Collection.class.isAssignableFrom(rawType)\n                || Map.class.isAssignableFrom(rawType);\n    }\n\n    \n    protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException {\n        ArrayList<BeanPropertyDefinition> result = new ArrayList<BeanPropertyDefinition>(\n                Math.max(4, propDefsIn.size()));\n        HashMap<Class<?>,Boolean> ignoredTypes = new HashMap<Class<?>,Boolean>();\n        \n        for (BeanPropertyDefinition property : propDefsIn) {\n            String name = property.getName();\n            if (ignored.contains(name)) { \n                continue;\n            }\n            if (!property.hasConstructorParameter()) { \n                Class<?> rawPropertyType = property.getRawPrimaryType();\n                \n                if ((rawPropertyType != null)\n                        && isIgnorableType(ctxt.getConfig(), property, rawPropertyType, ignoredTypes)) {\n                    \n                    builder.addIgnorable(name);\n                    continue;\n                }\n            }\n            result.add(property);\n        }\n        return result;\n    }\n\n    \n    protected void addBackReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n        \n        List<BeanPropertyDefinition> refProps = beanDesc.findBackReferences();\n        if (refProps != null) {\n            for (BeanPropertyDefinition refProp : refProps) {\n                \n                String refName = refProp.findReferenceName();\n                builder.addBackReferenceProperty(refName, constructSettableProperty(ctxt,\n                        beanDesc, refProp, refProp.getPrimaryType()));\n            }\n        }\n    }\n\n    @Deprecated \n    protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n        addBackReferenceProperties(ctxt, beanDesc, builder);\n    }\n\n    \n    protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n        Map<Object, AnnotatedMember> raw = beanDesc.findInjectables();\n        if (raw != null) {\n            for (Map.Entry<Object, AnnotatedMember> entry : raw.entrySet()) {\n                AnnotatedMember m = entry.getValue();\n                builder.addInjectable(PropertyName.construct(m.getName()),\n                        m.getType(),\n                        beanDesc.getClassAnnotations(), m, entry.getKey());\n            }\n        }\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMember mutator) throws JsonMappingException {\n        \n        BeanProperty prop;\n        JavaType keyType;\n        JavaType valueType;\n\n        if (mutator instanceof AnnotatedMethod) {\n            \n            AnnotatedMethod am = (AnnotatedMethod) mutator;\n            keyType = am.getParameterType(0);\n            valueType = am.getParameterType(1);\n            valueType = resolveMemberAndTypeAnnotations(ctxt, mutator, valueType);\n            prop = new BeanProperty.Std(PropertyName.construct(mutator.getName()),\n                    valueType, null, mutator,\n                    PropertyMetadata.STD_OPTIONAL);\n\n        } else if (mutator instanceof AnnotatedField) {\n            AnnotatedField af = (AnnotatedField) mutator;\n            \n            JavaType mapType = af.getType();\n            mapType = resolveMemberAndTypeAnnotations(ctxt, mutator, mapType);\n            keyType = mapType.getKeyType();\n            valueType = mapType.getContentType();\n            prop = new BeanProperty.Std(PropertyName.construct(mutator.getName()),\n                    mapType, null, mutator, PropertyMetadata.STD_OPTIONAL);\n        } else {\n            return ctxt.reportBadDefinition(beanDesc.getType(), String.format(\n                    \"Unrecognized mutator type for any setter: %s\", mutator.getClass()));\n        }\n        \n        \n        KeyDeserializer keyDeser = findKeyDeserializerFromAnnotation(ctxt, mutator);\n        if (keyDeser == null) {\n            keyDeser = keyType.getValueHandler();\n        }\n        if (keyDeser == null) {\n            keyDeser = ctxt.findKeyDeserializer(keyType, prop);\n        } else {\n            if (keyDeser instanceof ContextualKeyDeserializer) {\n                keyDeser = ((ContextualKeyDeserializer) keyDeser)\n                        .createContextual(ctxt, prop);\n            }\n        }\n        JsonDeserializer<Object> deser = findContentDeserializerFromAnnotation(ctxt, mutator);\n        if (deser == null) {\n            deser = valueType.getValueHandler();\n        }\n        if (deser != null) {\n            \n            deser = (JsonDeserializer<Object>) ctxt.handlePrimaryContextualization(deser, prop, valueType);\n        }\n        TypeDeserializer typeDeser = valueType.getTypeHandler();\n        return new SettableAnyProperty(prop, mutator, valueType,\n                keyDeser, deser, typeDeser);\n    }\n\n    \n    protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, JavaType propType0) throws JsonMappingException {\n        \n        AnnotatedMember mutator = propDef.getNonConstructorMutator();\n        \n        \n        \n        if (mutator == null) {\n            ctxt.reportBadPropertyDefinition(beanDesc, propDef, \"No non-constructor mutator available\");\n        }\n        JavaType type = resolveMemberAndTypeAnnotations(ctxt, mutator, propType0);\n        \n        TypeDeserializer typeDeser = type.getTypeHandler();\n        SettableBeanProperty prop;\n        if (mutator instanceof AnnotatedMethod) {\n            prop = new MethodProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n        } else {\n            \n            prop = new FieldProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n        }\n        JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, mutator);\n        if (deser == null) {\n            deser = type.getValueHandler();\n        }\n        if (deser != null) {\n            deser = ctxt.handlePrimaryContextualization(deser, prop, type);\n            prop = prop.withValueDeserializer(deser);\n        }\n        \n        AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n        if (ref != null && ref.isManagedReference()) {\n            prop.setManagedReferenceName(ref.getName());\n        }\n        ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n        if (objectIdInfo != null){\n            prop.setObjectIdInfo(objectIdInfo);\n        }\n        return prop;\n    }\n\n    \n    protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException {\n        final AnnotatedMethod getter = propDef.getGetter();\n        JavaType type = resolveMemberAndTypeAnnotations(ctxt, getter, getter.getType());\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        SettableBeanProperty prop = new SetterlessProperty(propDef, type, typeDeser,\n                beanDesc.getClassAnnotations(), getter);\n        JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, getter);\n        if (deser == null) {\n            deser = type.getValueHandler();\n        }\n        if (deser != null) {\n            deser = ctxt.handlePrimaryContextualization(deser, prop, type);\n            prop = prop.withValueDeserializer(deser);\n        }\n        return prop;\n    }\n\n    \n\n    \n    protected boolean isPotentialBeanType(Class<?> type) {\n        String typeStr = ClassUtil.canBeABeanType(type);\n        if (typeStr != null) {\n            throw new IllegalArgumentException(\"Cannot deserialize Class \"+type.getName()+\" (of type \"+typeStr+\") as a Bean\");\n        }\n        if (ClassUtil.isProxyType(type)) {\n            throw new IllegalArgumentException(\"Cannot deserialize Proxy class \"+type.getName()+\" as a Bean\");\n        }\n        \n        typeStr = ClassUtil.isLocalType(type, true);\n        if (typeStr != null) {\n            throw new IllegalArgumentException(\"Cannot deserialize Class \"+type.getName()+\" (of type \"+typeStr+\") as a Bean\");\n        }\n        return true;\n    }\n\n    \n    protected boolean isIgnorableType(DeserializationConfig config, BeanPropertyDefinition propDef, Class<?> type, Map<Class<?>,Boolean> ignoredTypes) {\n        Boolean status = ignoredTypes.get(type);\n        if (status != null) {\n            return status.booleanValue();\n        }\n        \n        if ((type == String.class) || type.isPrimitive()) {\n            status = Boolean.FALSE;\n        } else {\n            \n            status = config.getConfigOverride(type).getIsIgnoredType();\n            if (status == null) {\n                BeanDescription desc = config.introspectClassAnnotations(type);\n                status = config.getAnnotationIntrospector().isIgnorableType(desc.getClassInfo());\n                \n                if (status == null) {\n                    status = Boolean.FALSE;\n                }\n            }\n        }\n        ignoredTypes.put(type, status);\n        return status.booleanValue();\n    }\n\n    \n    protected void _validateSubType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        SubTypeValidator.instance().validateSubType(ctxt, type, beanDesc);\n    }\n}\n",
      "buggy_signatures": [
        "public DeserializerFactory withConfig(DeserializerFactoryConfig config)",
        "public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException",
        "protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<Object> buildBuilderBasedDeserializer( DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException",
        "protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException",
        "public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc)",
        "protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException",
        "private boolean _isSetterlessType(Class<?> rawType)",
        "protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException",
        "protected void addBackReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException",
        "protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException",
        "protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException",
        "protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMember mutator) throws JsonMappingException",
        "protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, JavaType propType0) throws JsonMappingException",
        "protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException",
        "protected boolean isPotentialBeanType(Class<?> type)",
        "protected boolean isIgnorableType(DeserializationConfig config, BeanPropertyDefinition propDef, Class<?> type, Map<Class<?>,Boolean> ignoredTypes)",
        "protected void _validateSubType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException"
      ],
      "fixed_signatures": [
        "public DeserializerFactory withConfig(DeserializerFactoryConfig config)",
        "public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException",
        "protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<Object> buildBuilderBasedDeserializer( DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException",
        "protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException",
        "public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc)",
        "protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException",
        "private boolean _isSetterlessType(Class<?> rawType)",
        "protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException",
        "protected void addBackReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException",
        "protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException",
        "protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException",
        "protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMember mutator) throws JsonMappingException",
        "protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, JavaType propType0) throws JsonMappingException",
        "protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException",
        "protected boolean isPotentialBeanType(Class<?> type)",
        "protected boolean isIgnorableType(DeserializationConfig config, BeanPropertyDefinition propDef, Class<?> type, Map<Class<?>,Boolean> ignoredTypes)",
        "protected void _validateSubType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException"
      ],
      "methods": [
        {
          "buggy_method": "  public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n  \n  ValueInstantiator valueInstantiator;\n  \n  try {\n  valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n  } catch (NoClassDefFoundError error) {\n  return new ErrorThrowingDeserializer(error);\n  } catch (IllegalArgumentException e) {\n  \n  \n  \n  throw InvalidDefinitionException.from(ctxt.getParser(),\n  e.getMessage(),\n  beanDesc, null);\n  }\n  BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n  builder.setValueInstantiator(valueInstantiator);\n  \n  addBeanProps(ctxt, beanDesc, builder);\n  addObjectIdReader(ctxt, beanDesc, builder);\n\n  \n  addBackReferenceProperties(ctxt, beanDesc, builder);\n  addInjectables(ctxt, beanDesc, builder);\n  \n  final DeserializationConfig config = ctxt.getConfig();\n  if (_factoryConfig.hasDeserializerModifiers()) {\n  for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n  builder = mod.updateBuilder(config, beanDesc, builder);\n  }\n  }\n  JsonDeserializer<?> deserializer;\n\n  if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n  deserializer = builder.buildAbstract();\n  } else {\n  deserializer = builder.build();\n  }\n  \n  \n  if (_factoryConfig.hasDeserializerModifiers()) {\n  for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n  deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n  }\n  }\n  return (JsonDeserializer<Object>) deserializer;\n  }",
          "fixed_method": "  public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n  \n  ValueInstantiator valueInstantiator;\n  \n  try {\n  valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n  } catch (NoClassDefFoundError error) {\n  return new ErrorThrowingDeserializer(error);\n  } catch (IllegalArgumentException e) {\n  \n  \n  \n  throw InvalidDefinitionException.from(ctxt.getParser(),\n  ClassUtil.exceptionMessage(e),\n  beanDesc, null);\n  }\n  BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n  builder.setValueInstantiator(valueInstantiator);\n  \n  addBeanProps(ctxt, beanDesc, builder);\n  addObjectIdReader(ctxt, beanDesc, builder);\n\n  \n  addBackReferenceProperties(ctxt, beanDesc, builder);\n  addInjectables(ctxt, beanDesc, builder);\n  \n  final DeserializationConfig config = ctxt.getConfig();\n  if (_factoryConfig.hasDeserializerModifiers()) {\n  for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n  builder = mod.updateBuilder(config, beanDesc, builder);\n  }\n  }\n  JsonDeserializer<?> deserializer;\n\n  if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n  deserializer = builder.buildAbstract();\n  } else {\n  deserializer = builder.build();\n  }\n  \n  \n  if (_factoryConfig.hasDeserializerModifiers()) {\n  for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n  deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n  }\n  }\n  return (JsonDeserializer<Object>) deserializer;\n  }",
          "diff": [
            "@@ -219,7 +219,7 @@",
            "             //   to throw proper exception, it doesn't actually have reference to this\n",
            "             //   instance so...\n",
            "             throw InvalidDefinitionException.from(ctxt.getParser(),\n",
            "-                    e.getMessage(),\n",
            "+                    ClassUtil.exceptionMessage(e),\n",
            "                     beanDesc, null);\n",
            "         }\n",
            "         BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  protected JsonDeserializer<Object> buildBuilderBasedDeserializer( DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n  \n  ValueInstantiator valueInstantiator;\n  try {\n  valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n  } catch (NoClassDefFoundError error) {\n  return new ErrorThrowingDeserializer(error);\n  } catch (IllegalArgumentException e) {\n  \n  \n  \n  throw InvalidDefinitionException.from(ctxt.getParser(),\n  e.getMessage(),\n  builderDesc, null);\n  }\n  final DeserializationConfig config = ctxt.getConfig();\n  BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n  builder.setValueInstantiator(valueInstantiator);\n  \n  addBeanProps(ctxt, builderDesc, builder);\n  addObjectIdReader(ctxt, builderDesc, builder);\n  \n  \n  addBackReferenceProperties(ctxt, builderDesc, builder);\n  addInjectables(ctxt, builderDesc, builder);\n\n  JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n  final String buildMethodName = (builderConfig == null) ?\n  JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n  \n  \n  AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n  if (buildMethod != null) { \n  if (config.canOverrideAccessModifiers()) {\n  \tClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n  }\n  }\n  builder.setPOJOBuilder(buildMethod, builderConfig);\n  \n  if (_factoryConfig.hasDeserializerModifiers()) {\n  for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n  builder = mod.updateBuilder(config, builderDesc, builder);\n  }\n  }\n  JsonDeserializer<?> deserializer = builder.buildBuilderBased(\n  \t\tvalueType, buildMethodName);\n\n  \n  if (_factoryConfig.hasDeserializerModifiers()) {\n  for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n  deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n  }\n  }\n  return (JsonDeserializer<Object>) deserializer;\n  }",
          "fixed_method": "  protected JsonDeserializer<Object> buildBuilderBasedDeserializer( DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n  \n  ValueInstantiator valueInstantiator;\n  try {\n  valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n  } catch (NoClassDefFoundError error) {\n  return new ErrorThrowingDeserializer(error);\n  } catch (IllegalArgumentException e) {\n  \n  \n  \n  throw InvalidDefinitionException.from(ctxt.getParser(),\n  ClassUtil.exceptionMessage(e),\n  builderDesc, null);\n  }\n  final DeserializationConfig config = ctxt.getConfig();\n  BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n  builder.setValueInstantiator(valueInstantiator);\n  \n  addBeanProps(ctxt, builderDesc, builder);\n  addObjectIdReader(ctxt, builderDesc, builder);\n  \n  \n  addBackReferenceProperties(ctxt, builderDesc, builder);\n  addInjectables(ctxt, builderDesc, builder);\n\n  JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n  final String buildMethodName = (builderConfig == null) ?\n  JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n  \n  \n  AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n  if (buildMethod != null) { \n  if (config.canOverrideAccessModifiers()) {\n  \tClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n  }\n  }\n  builder.setPOJOBuilder(buildMethod, builderConfig);\n  \n  if (_factoryConfig.hasDeserializerModifiers()) {\n  for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n  builder = mod.updateBuilder(config, builderDesc, builder);\n  }\n  }\n  JsonDeserializer<?> deserializer = builder.buildBuilderBased(\n  \t\tvalueType, buildMethodName);\n\n  \n  if (_factoryConfig.hasDeserializerModifiers()) {\n  for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n  deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n  }\n  }\n  return (JsonDeserializer<Object>) deserializer;\n  }",
          "diff": [
            "@@ -278,7 +278,7 @@",
            "             //   to throw proper exception, it doesn't actually have reference to this\n",
            "             //   instance so...\n",
            "             throw InvalidDefinitionException.from(ctxt.getParser(),\n",
            "-                    e.getMessage(),\n",
            "+                    ClassUtil.exceptionMessage(e),\n",
            "                     builderDesc, null);\n",
            "         }\n",
            "         final DeserializationConfig config = ctxt.getConfig();\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/deser/DeserializerCache.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.deser;\n\nimport java.util.HashMap;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer;\nimport com.fasterxml.jackson.databind.introspect.Annotated;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.Converter;\n\n\npublic final class DeserializerCache implements java.io.Serializable { private static final long serialVersionUID = 1L; final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _cachedDeserializers = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.75f, 4); final protected HashMap<JavaType, JsonDeserializer<Object>> _incompleteDeserializers = new HashMap<JavaType, JsonDeserializer<Object>>(8); public DeserializerCache() { }\n\n    \n\n    Object writeReplace() {\n        \n        _incompleteDeserializers.clear();\n        \n        return this;\n    }\n    \n    \n\n    \n    public int cachedDeserializersCount() {\n        return _cachedDeserializers.size();\n    }\n\n    \n    public void flushCachedDeserializers() {\n        _cachedDeserializers.clear();       \n    }\n\n    \n\n    \n    public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType propertyType) throws JsonMappingException {\n        JsonDeserializer<Object> deser = _findCachedDeserializer(propertyType);\n        if (deser == null) {\n            \n            deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType);\n            if (deser == null) {\n                \n                deser = _handleUnknownValueDeserializer(ctxt, propertyType);\n            }\n        }\n        return deser;\n    }\n\n    \n    public KeyDeserializer findKeyDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n        KeyDeserializer kd = factory.createKeyDeserializer(ctxt, type);\n        if (kd == null) { \n            return _handleUnknownKeyDeserializer(ctxt, type);\n        }\n        \n        if (kd instanceof ResolvableDeserializer) {\n            ((ResolvableDeserializer) kd).resolve(ctxt);\n        }\n        return kd;\n    }\n\n    \n    public boolean hasValueDeserializerFor(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n        \n        JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n        if (deser == null) {\n            deser = _createAndCacheValueDeserializer(ctxt, factory, type);\n        }\n        return (deser != null);\n    }\n\n    \n\n    protected JsonDeserializer<Object> _findCachedDeserializer(JavaType type) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"Null JavaType passed\");\n        }\n        if (_hasCustomHandlers(type)) {\n            return null;\n        }\n        return _cachedDeserializers.get(type);\n    }\n\n    \n    protected JsonDeserializer<Object> _createAndCacheValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n        \n        synchronized (_incompleteDeserializers) {\n            \n            JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n            if (deser != null) {\n                return deser;\n            }\n            int count = _incompleteDeserializers.size();\n            \n            if (count > 0) {\n                deser = _incompleteDeserializers.get(type);\n                if (deser != null) {\n                    return deser;\n                }\n            }\n            \n            try {\n                return _createAndCache2(ctxt, factory, type);\n            } finally {\n                \n                if (count == 0 && _incompleteDeserializers.size() > 0) {\n                    _incompleteDeserializers.clear();\n                }\n            }\n        }\n    }\n\n    \n    protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n        JsonDeserializer<Object> deser;\n        try {\n            deser = _createDeserializer(ctxt, factory, type);\n        } catch (IllegalArgumentException iae) {\n            \n            \n            throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n        }\n        if (deser == null) {\n            return null;\n        }\n        \n        \n        boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n\n        \n        \n        \n        if (deser instanceof ResolvableDeserializer) {\n            _incompleteDeserializers.put(type, deser);\n            ((ResolvableDeserializer)deser).resolve(ctxt);\n            _incompleteDeserializers.remove(type);\n        }\n        if (addToCache) {\n            _cachedDeserializers.put(type, deser);\n        }\n        return deser;\n    }\n\n    \n    \n    \n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n\n        \n        if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) {\n            type = factory.mapAbstractType(config, type);\n        }\n        BeanDescription beanDesc = config.introspect(type);\n        \n        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt,\n                beanDesc.getClassInfo());\n        if (deser != null) {\n            return deser;\n        }\n\n        \n        JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type);\n        if (newType != type) {\n            type = newType;\n            beanDesc = config.introspect(newType);\n        }\n\n        \n        Class<?> builder = beanDesc.findPOJOBuilder();\n        if (builder != null) {\n            return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(\n            \t\tctxt, type, beanDesc, builder);\n        }\n\n        \n        Converter<Object,Object> conv = beanDesc.findDeserializationConverter();\n        if (conv == null) { \n            return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc);\n        }\n        \n        JavaType delegateType = conv.getInputType(ctxt.getTypeFactory());\n        \n        if (!delegateType.hasRawClass(type.getRawClass())) {\n            beanDesc = config.introspect(delegateType);\n        }\n        return new StdDelegatingDeserializer<Object>(conv, delegateType,\n                _createDeserializer2(ctxt, factory, delegateType, beanDesc));\n    }\n\n    protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        if (type.isEnumType()) {\n            return factory.createEnumDeserializer(ctxt, type, beanDesc);\n        }\n        if (type.isContainerType()) {\n            if (type.isArrayType()) {\n                return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc);\n            }\n            if (type.isMapLikeType()) {\n                \n                \n                \n                \n                \n                JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n                if ((format == null) || format.getShape() != JsonFormat.Shape.OBJECT) {\n                    MapLikeType mlt = (MapLikeType) type;\n                    if (mlt.isTrueMapType()) {\n                        return factory.createMapDeserializer(ctxt,(MapType) mlt, beanDesc);\n                    }\n                    return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc);\n                }\n            }\n            if (type.isCollectionLikeType()) {\n                \n                JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n                if ((format == null) || format.getShape() != JsonFormat.Shape.OBJECT) {\n                    CollectionLikeType clt = (CollectionLikeType) type;\n                    if (clt.isTrueCollectionType()) {\n                        return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc);\n                    }\n                    return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc);\n                }\n            }\n        }\n        if (type.isReferenceType()) {\n            return factory.createReferenceDeserializer(ctxt, (ReferenceType) type, beanDesc);\n        }\n        if (JsonNode.class.isAssignableFrom(type.getRawClass())) {\n            return factory.createTreeDeserializer(config, type, beanDesc);\n        }\n        return factory.createBeanDeserializer(ctxt, type, beanDesc);\n    }\n\n    \n    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException {\n        Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann);\n        if (deserDef == null) {\n            return null;\n        }\n        JsonDeserializer<Object> deser = ctxt.deserializerInstance(ann, deserDef);\n        \n        return findConvertingDeserializer(ctxt, ann, deser);\n    }\n\n    \n    protected JsonDeserializer<Object> findConvertingDeserializer(DeserializationContext ctxt, Annotated a, JsonDeserializer<Object> deser) throws JsonMappingException {\n        Converter<Object,Object> conv = findConverter(ctxt, a);\n        if (conv == null) {\n            return deser;\n        }\n        JavaType delegateType = conv.getInputType(ctxt.getTypeFactory());\n        return (JsonDeserializer<Object>) new StdDelegatingDeserializer<Object>(conv, delegateType, deser);\n    }\n\n    protected Converter<Object,Object> findConverter(DeserializationContext ctxt, Annotated a) throws JsonMappingException {\n        Object convDef = ctxt.getAnnotationIntrospector().findDeserializationConverter(a);\n        if (convDef == null) {\n            return null;\n        }\n        return ctxt.converterInstance(a, convDef);\n    }    \n    \n    private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr == null) {\n            return type;\n        }\n\n        \n\n        \n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            \n            \n            \n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                if (kdDef != null) {\n                    KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                    if (kd != null) {\n                        type = ((MapLikeType) type).withKeyValueHandler(kd);\n                        keyType = type.getKeyType(); \n                    }\n                }\n            }            \n        }\n        JavaType contentType = type.getContentType();\n        if (contentType != null) {\n            if (contentType.getValueHandler() == null) { \n                Object cdDef = intr.findContentDeserializer(a);\n                if (cdDef != null) {\n                    JsonDeserializer<?> cd = null;\n                    if (cdDef instanceof JsonDeserializer<?>) {\n                        cdDef = (JsonDeserializer<?>) cdDef;\n                    } else {\n                        Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                        if (cdClass != null) {\n                            cd = ctxt.deserializerInstance(a, cdClass);\n                        }\n                    }\n                    if (cd != null) {\n                        type = type.withContentValueHandler(cd);\n                    }\n                }\n            }\n        }\n\n        \n        \n        type = intr.refineDeserializationType(ctxt.getConfig(), a, type);\n        \n        return type;\n    }\n\n    \n\n    \n    private boolean _hasCustomHandlers(JavaType t) {\n        if (t.isContainerType()) {\n            \n            JavaType ct = t.getContentType();\n            if (ct != null) {\n                if ((ct.getValueHandler() != null) || (ct.getTypeHandler() != null)) {\n                    return true;\n                }\n            }\n            \n            if (t.isMapLikeType()) {\n                JavaType kt = t.getKeyType();\n                if (kt.getValueHandler() != null) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) {\n        if (src == null) {\n            return null;\n        }\n        if (!(src instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\");\n        }\n        Class<?> cls = (Class<?>) src;\n        if (cls == noneClass || ClassUtil.isBogusClass(cls)) {\n            return null;\n        }\n        return cls;\n    }\n\n    \n\n    protected JsonDeserializer<Object> _handleUnknownValueDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        \n        Class<?> rawClass = type.getRawClass();\n        if (!ClassUtil.isConcrete(rawClass)) {\n            return ctxt.reportBadDefinition(type, \"Cannot find a Value deserializer for abstract type \"+type); } return ctxt.reportBadDefinition(type, \"Cannot find a Value deserializer for type \"+type); } protected KeyDeserializer _handleUnknownKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        return ctxt.reportBadDefinition(type, \"Cannot find a (Map) Key deserializer for type \"+type);\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.deser;\n\nimport java.util.HashMap;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer;\nimport com.fasterxml.jackson.databind.introspect.Annotated;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.Converter;\n\n\npublic final class DeserializerCache implements java.io.Serializable { private static final long serialVersionUID = 1L; final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _cachedDeserializers = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.75f, 4); final protected HashMap<JavaType, JsonDeserializer<Object>> _incompleteDeserializers = new HashMap<JavaType, JsonDeserializer<Object>>(8); public DeserializerCache() { }\n\n    \n\n    Object writeReplace() {\n        \n        _incompleteDeserializers.clear();\n        \n        return this;\n    }\n    \n    \n\n    \n    public int cachedDeserializersCount() {\n        return _cachedDeserializers.size();\n    }\n\n    \n    public void flushCachedDeserializers() {\n        _cachedDeserializers.clear();       \n    }\n\n    \n\n    \n    public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType propertyType) throws JsonMappingException {\n        JsonDeserializer<Object> deser = _findCachedDeserializer(propertyType);\n        if (deser == null) {\n            \n            deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType);\n            if (deser == null) {\n                \n                deser = _handleUnknownValueDeserializer(ctxt, propertyType);\n            }\n        }\n        return deser;\n    }\n\n    \n    public KeyDeserializer findKeyDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n        KeyDeserializer kd = factory.createKeyDeserializer(ctxt, type);\n        if (kd == null) { \n            return _handleUnknownKeyDeserializer(ctxt, type);\n        }\n        \n        if (kd instanceof ResolvableDeserializer) {\n            ((ResolvableDeserializer) kd).resolve(ctxt);\n        }\n        return kd;\n    }\n\n    \n    public boolean hasValueDeserializerFor(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n        \n        JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n        if (deser == null) {\n            deser = _createAndCacheValueDeserializer(ctxt, factory, type);\n        }\n        return (deser != null);\n    }\n\n    \n\n    protected JsonDeserializer<Object> _findCachedDeserializer(JavaType type) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"Null JavaType passed\");\n        }\n        if (_hasCustomHandlers(type)) {\n            return null;\n        }\n        return _cachedDeserializers.get(type);\n    }\n\n    \n    protected JsonDeserializer<Object> _createAndCacheValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n        \n        synchronized (_incompleteDeserializers) {\n            \n            JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n            if (deser != null) {\n                return deser;\n            }\n            int count = _incompleteDeserializers.size();\n            \n            if (count > 0) {\n                deser = _incompleteDeserializers.get(type);\n                if (deser != null) {\n                    return deser;\n                }\n            }\n            \n            try {\n                return _createAndCache2(ctxt, factory, type);\n            } finally {\n                \n                if (count == 0 && _incompleteDeserializers.size() > 0) {\n                    _incompleteDeserializers.clear();\n                }\n            }\n        }\n    }\n\n    \n    protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n        JsonDeserializer<Object> deser;\n        try {\n            deser = _createDeserializer(ctxt, factory, type);\n        } catch (IllegalArgumentException iae) {\n            \n            \n            throw JsonMappingException.from(ctxt, ClassUtil.exceptionMessage(iae), iae);\n        }\n        if (deser == null) {\n            return null;\n        }\n        \n        \n        boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n\n        \n        \n        \n        if (deser instanceof ResolvableDeserializer) {\n            _incompleteDeserializers.put(type, deser);\n            ((ResolvableDeserializer)deser).resolve(ctxt);\n            _incompleteDeserializers.remove(type);\n        }\n        if (addToCache) {\n            _cachedDeserializers.put(type, deser);\n        }\n        return deser;\n    }\n\n    \n    \n    \n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n\n        \n        if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) {\n            type = factory.mapAbstractType(config, type);\n        }\n        BeanDescription beanDesc = config.introspect(type);\n        \n        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt,\n                beanDesc.getClassInfo());\n        if (deser != null) {\n            return deser;\n        }\n\n        \n        JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type);\n        if (newType != type) {\n            type = newType;\n            beanDesc = config.introspect(newType);\n        }\n\n        \n        Class<?> builder = beanDesc.findPOJOBuilder();\n        if (builder != null) {\n            return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(\n            \t\tctxt, type, beanDesc, builder);\n        }\n\n        \n        Converter<Object,Object> conv = beanDesc.findDeserializationConverter();\n        if (conv == null) { \n            return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc);\n        }\n        \n        JavaType delegateType = conv.getInputType(ctxt.getTypeFactory());\n        \n        if (!delegateType.hasRawClass(type.getRawClass())) {\n            beanDesc = config.introspect(delegateType);\n        }\n        return new StdDelegatingDeserializer<Object>(conv, delegateType,\n                _createDeserializer2(ctxt, factory, delegateType, beanDesc));\n    }\n\n    protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        if (type.isEnumType()) {\n            return factory.createEnumDeserializer(ctxt, type, beanDesc);\n        }\n        if (type.isContainerType()) {\n            if (type.isArrayType()) {\n                return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc);\n            }\n            if (type.isMapLikeType()) {\n                \n                \n                \n                \n                \n                JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n                if ((format == null) || format.getShape() != JsonFormat.Shape.OBJECT) {\n                    MapLikeType mlt = (MapLikeType) type;\n                    if (mlt.isTrueMapType()) {\n                        return factory.createMapDeserializer(ctxt,(MapType) mlt, beanDesc);\n                    }\n                    return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc);\n                }\n            }\n            if (type.isCollectionLikeType()) {\n                \n                JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n                if ((format == null) || format.getShape() != JsonFormat.Shape.OBJECT) {\n                    CollectionLikeType clt = (CollectionLikeType) type;\n                    if (clt.isTrueCollectionType()) {\n                        return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc);\n                    }\n                    return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc);\n                }\n            }\n        }\n        if (type.isReferenceType()) {\n            return factory.createReferenceDeserializer(ctxt, (ReferenceType) type, beanDesc);\n        }\n        if (JsonNode.class.isAssignableFrom(type.getRawClass())) {\n            return factory.createTreeDeserializer(config, type, beanDesc);\n        }\n        return factory.createBeanDeserializer(ctxt, type, beanDesc);\n    }\n\n    \n    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException {\n        Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann);\n        if (deserDef == null) {\n            return null;\n        }\n        JsonDeserializer<Object> deser = ctxt.deserializerInstance(ann, deserDef);\n        \n        return findConvertingDeserializer(ctxt, ann, deser);\n    }\n\n    \n    protected JsonDeserializer<Object> findConvertingDeserializer(DeserializationContext ctxt, Annotated a, JsonDeserializer<Object> deser) throws JsonMappingException {\n        Converter<Object,Object> conv = findConverter(ctxt, a);\n        if (conv == null) {\n            return deser;\n        }\n        JavaType delegateType = conv.getInputType(ctxt.getTypeFactory());\n        return (JsonDeserializer<Object>) new StdDelegatingDeserializer<Object>(conv, delegateType, deser);\n    }\n\n    protected Converter<Object,Object> findConverter(DeserializationContext ctxt, Annotated a) throws JsonMappingException {\n        Object convDef = ctxt.getAnnotationIntrospector().findDeserializationConverter(a);\n        if (convDef == null) {\n            return null;\n        }\n        return ctxt.converterInstance(a, convDef);\n    }    \n    \n    private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr == null) {\n            return type;\n        }\n\n        \n\n        \n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            \n            \n            \n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                if (kdDef != null) {\n                    KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                    if (kd != null) {\n                        type = ((MapLikeType) type).withKeyValueHandler(kd);\n                        keyType = type.getKeyType(); \n                    }\n                }\n            }            \n        }\n        JavaType contentType = type.getContentType();\n        if (contentType != null) {\n            if (contentType.getValueHandler() == null) { \n                Object cdDef = intr.findContentDeserializer(a);\n                if (cdDef != null) {\n                    JsonDeserializer<?> cd = null;\n                    if (cdDef instanceof JsonDeserializer<?>) {\n                        cdDef = (JsonDeserializer<?>) cdDef;\n                    } else {\n                        Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                        if (cdClass != null) {\n                            cd = ctxt.deserializerInstance(a, cdClass);\n                        }\n                    }\n                    if (cd != null) {\n                        type = type.withContentValueHandler(cd);\n                    }\n                }\n            }\n        }\n\n        \n        \n        type = intr.refineDeserializationType(ctxt.getConfig(), a, type);\n        \n        return type;\n    }\n\n    \n\n    \n    private boolean _hasCustomHandlers(JavaType t) {\n        if (t.isContainerType()) {\n            \n            JavaType ct = t.getContentType();\n            if (ct != null) {\n                if ((ct.getValueHandler() != null) || (ct.getTypeHandler() != null)) {\n                    return true;\n                }\n            }\n            \n            if (t.isMapLikeType()) {\n                JavaType kt = t.getKeyType();\n                if (kt.getValueHandler() != null) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) {\n        if (src == null) {\n            return null;\n        }\n        if (!(src instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\");\n        }\n        Class<?> cls = (Class<?>) src;\n        if (cls == noneClass || ClassUtil.isBogusClass(cls)) {\n            return null;\n        }\n        return cls;\n    }\n\n    \n\n    protected JsonDeserializer<Object> _handleUnknownValueDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        \n        Class<?> rawClass = type.getRawClass();\n        if (!ClassUtil.isConcrete(rawClass)) {\n            return ctxt.reportBadDefinition(type, \"Cannot find a Value deserializer for abstract type \"+type); } return ctxt.reportBadDefinition(type, \"Cannot find a Value deserializer for type \"+type); } protected KeyDeserializer _handleUnknownKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        return ctxt.reportBadDefinition(type, \"Cannot find a (Map) Key deserializer for type \"+type);\n    }\n}\n",
      "buggy_signatures": [
        "public int cachedDeserializersCount()",
        "public void flushCachedDeserializers()",
        "public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType propertyType) throws JsonMappingException",
        "public KeyDeserializer findKeyDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException",
        "public boolean hasValueDeserializerFor(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException",
        "protected JsonDeserializer<Object> _findCachedDeserializer(JavaType type)",
        "protected JsonDeserializer<Object> _createAndCacheValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException",
        "synchronized (_incompleteDeserializers)",
        "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException",
        "protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException",
        "protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException",
        "protected JsonDeserializer<Object> findConvertingDeserializer(DeserializationContext ctxt, Annotated a, JsonDeserializer<Object> deser) throws JsonMappingException",
        "protected Converter<Object,Object> findConverter(DeserializationContext ctxt, Annotated a) throws JsonMappingException",
        "private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException",
        "private boolean _hasCustomHandlers(JavaType t)",
        "private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass)",
        "protected JsonDeserializer<Object> _handleUnknownValueDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException",
        "abstract type \"+type); } return ctxt.reportBadDefinition(type, \"Cannot find a Value deserializer for type \"+type); } protected KeyDeserializer _handleUnknownKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException"
      ],
      "fixed_signatures": [
        "public int cachedDeserializersCount()",
        "public void flushCachedDeserializers()",
        "public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType propertyType) throws JsonMappingException",
        "public KeyDeserializer findKeyDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException",
        "public boolean hasValueDeserializerFor(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException",
        "protected JsonDeserializer<Object> _findCachedDeserializer(JavaType type)",
        "protected JsonDeserializer<Object> _createAndCacheValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException",
        "synchronized (_incompleteDeserializers)",
        "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException",
        "protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException",
        "protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException",
        "protected JsonDeserializer<Object> findConvertingDeserializer(DeserializationContext ctxt, Annotated a, JsonDeserializer<Object> deser) throws JsonMappingException",
        "protected Converter<Object,Object> findConverter(DeserializationContext ctxt, Annotated a) throws JsonMappingException",
        "private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException",
        "private boolean _hasCustomHandlers(JavaType t)",
        "private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass)",
        "protected JsonDeserializer<Object> _handleUnknownValueDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException",
        "abstract type \"+type); } return ctxt.reportBadDefinition(type, \"Cannot find a Value deserializer for type \"+type); } protected KeyDeserializer _handleUnknownKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException"
      ],
      "methods": [
        {
          "buggy_method": "  protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n  JsonDeserializer<Object> deser;\n  try {\n  deser = _createDeserializer(ctxt, factory, type);\n  } catch (IllegalArgumentException iae) {\n  \n  \n  throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n  }\n  if (deser == null) {\n  return null;\n  }\n  \n  \n  boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n\n  \n  \n  \n  if (deser instanceof ResolvableDeserializer) {\n  _incompleteDeserializers.put(type, deser);\n  ((ResolvableDeserializer)deser).resolve(ctxt);\n  _incompleteDeserializers.remove(type);\n  }\n  if (addToCache) {\n  _cachedDeserializers.put(type, deser);\n  }\n  return deser;\n  }",
          "fixed_method": "  protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n  JsonDeserializer<Object> deser;\n  try {\n  deser = _createDeserializer(ctxt, factory, type);\n  } catch (IllegalArgumentException iae) {\n  \n  \n  throw JsonMappingException.from(ctxt, ClassUtil.exceptionMessage(iae), iae);\n  }\n  if (deser == null) {\n  return null;\n  }\n  \n  \n  boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n\n  \n  \n  \n  if (deser instanceof ResolvableDeserializer) {\n  _incompleteDeserializers.put(type, deser);\n  ((ResolvableDeserializer)deser).resolve(ctxt);\n  _incompleteDeserializers.remove(type);\n  }\n  if (addToCache) {\n  _cachedDeserializers.put(type, deser);\n  }\n  return deser;\n  }",
          "diff": [
            "@@ -265,7 +265,7 @@",
            "         } catch (IllegalArgumentException iae) {\n",
            "             // We better only expose checked exceptions, since those\n",
            "             // are what caller is expected to handle\n",
            "-            throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n",
            "+            throw JsonMappingException.from(ctxt, ClassUtil.exceptionMessage(iae), iae);\n",
            "         }\n",
            "         if (deser == null) {\n",
            "             return null;\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/deser/SettableAnyProperty.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.deser;\n\nimport java.io.IOException;\nimport java.util.Map;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedField;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMember;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\npublic class SettableAnyProperty implements java.io.Serializable { private static final long serialVersionUID = 1L; protected final BeanProperty _property; final protected AnnotatedMember _setter; final boolean _setterIsField; protected final JavaType _type; protected JsonDeserializer<Object> _valueDeserializer; protected final TypeDeserializer _valueTypeDeserializer; protected final KeyDeserializer _keyDeserializer; public SettableAnyProperty(BeanProperty property, AnnotatedMember setter, JavaType type, KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser, TypeDeserializer typeDeser) {\n        _property = property;\n        _setter = setter;\n        _type = type;\n        _valueDeserializer = valueDeser;\n        _valueTypeDeserializer = typeDeser;\n        _keyDeserializer = keyDeser;\n        _setterIsField = setter instanceof AnnotatedField;\n    }\n\n    @Deprecated \n    public SettableAnyProperty(BeanProperty property, AnnotatedMember setter, JavaType type, JsonDeserializer<Object> valueDeser, TypeDeserializer typeDeser) {\n        this(property, setter, type, null, valueDeser, typeDeser);\n    }\n\n    public SettableAnyProperty withValueDeserializer(JsonDeserializer<Object> deser) {\n        return new SettableAnyProperty(_property, _setter, _type,\n                _keyDeserializer, deser, _valueTypeDeserializer);\n    }\n\n    public void fixAccess(DeserializationConfig config) {\n        _setter.fixAccess(\n                config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n    }\n\n    \n\n    \n    Object readResolve() {\n        \n        if (_setter == null || _setter.getAnnotated() == null) {\n            throw new IllegalArgumentException(\"Missing method (broken JDK (de)serialization?)\");\n        }\n        return this;\n    }\n    \n    \n\n    public BeanProperty getProperty() { return _property; }\n    \n    public boolean hasValueDeserializer() { return (_valueDeserializer != null); }\n\n    public JavaType getType() { return _type; }\n\n    \n    \n    \n    public final void deserializeAndSet(JsonParser p, DeserializationContext ctxt, Object instance, String propName) throws IOException {\n        try {\n            Object key = (_keyDeserializer == null) ? propName\n                    : _keyDeserializer.deserializeKey(propName, ctxt);\n            set(instance, key, deserialize(p, ctxt));\n        } catch (UnresolvedForwardReference reference) {\n            if (!(_valueDeserializer.getObjectIdReader() != null)) {\n                throw JsonMappingException.from(p, \"Unresolved forward reference but no identity info.\", reference);\n            }\n            AnySetterReferring referring = new AnySetterReferring(this, reference,\n                    _type.getRawClass(), instance, propName);\n            reference.getRoid().appendReferring(referring);\n        }\n    }\n\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n        JsonToken t = p.getCurrentToken();\n        if (t == JsonToken.VALUE_NULL) {\n            return _valueDeserializer.getNullValue(ctxt);\n        }\n        if (_valueTypeDeserializer != null) {\n            return _valueDeserializer.deserializeWithType(p, ctxt, _valueTypeDeserializer);\n        }\n        return _valueDeserializer.deserialize(p, ctxt);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public void set(Object instance, Object propName, Object value) throws IOException {\n        try {\n            \n            if (_setterIsField) {\n                AnnotatedField field = (AnnotatedField) _setter;\n                Map<Object,Object> val = (Map<Object,Object>) field.getValue(instance);\n                \n                if (val != null) {\n                    \n                    val.put(propName, value);\n                }\n            } else {\n                \n                ((AnnotatedMethod) _setter).callOnWith(instance, propName, value);\n            }\n        } catch (Exception e) {\n            _throwAsIOE(e, propName, value);\n        }\n    }\n\n    \n\n    \n    protected void _throwAsIOE(Exception e, Object propName, Object value) throws IOException {\n        if (e instanceof IllegalArgumentException) {\n            String actType = ClassUtil.classNameOf(value);\n            StringBuilder msg = new StringBuilder(\"Problem deserializing \\\"any\\\" property '\").append(propName);\n            msg.append(\"' of class \"+getClassName()+\" (expected type: \").append(_type);\n            msg.append(\"; actual type: \").append(actType).append(\")\");\n            String origMsg = e.getMessage();\n            if (origMsg != null) {\n                msg.append(\", problem: \").append(origMsg);\n            } else {\n                msg.append(\" (no error message provided)\");\n            }\n            throw new JsonMappingException(null, msg.toString(), e);\n        }\n        ClassUtil.throwIfIOE(e);\n        ClassUtil.throwIfRTE(e);\n        \n        Throwable t = ClassUtil.getRootCause(e);\n        throw new JsonMappingException(null, t.getMessage(), t);\n    }\n\n    private String getClassName() { return _setter.getDeclaringClass().getName(); }\n\n    @Override public String toString() { return \"[any property on class \"+getClassName()+\"]\"; }\n\n    private static class AnySetterReferring extends Referring { private final SettableAnyProperty _parent; private final Object _pojo; private final String _propName; public AnySetterReferring(SettableAnyProperty parent, UnresolvedForwardReference reference, Class<?> type, Object instance, String propName) {\n            super(reference, type);\n            _parent = parent;\n            _pojo = instance;\n            _propName = propName;\n        }\n\n        @Override\n        public void handleResolvedForwardReference(Object id, Object value) throws IOException {\n            if (!hasId(id)) {\n                throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id.toString()\n                        + \"] that wasn't previously registered.\");\n            }\n            _parent.set(_pojo, _propName, value);\n        }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.deser;\n\nimport java.io.IOException;\nimport java.util.Map;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedField;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMember;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\npublic class SettableAnyProperty implements java.io.Serializable { private static final long serialVersionUID = 1L; protected final BeanProperty _property; final protected AnnotatedMember _setter; final boolean _setterIsField; protected final JavaType _type; protected JsonDeserializer<Object> _valueDeserializer; protected final TypeDeserializer _valueTypeDeserializer; protected final KeyDeserializer _keyDeserializer; public SettableAnyProperty(BeanProperty property, AnnotatedMember setter, JavaType type, KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser, TypeDeserializer typeDeser) {\n        _property = property;\n        _setter = setter;\n        _type = type;\n        _valueDeserializer = valueDeser;\n        _valueTypeDeserializer = typeDeser;\n        _keyDeserializer = keyDeser;\n        _setterIsField = setter instanceof AnnotatedField;\n    }\n\n    @Deprecated \n    public SettableAnyProperty(BeanProperty property, AnnotatedMember setter, JavaType type, JsonDeserializer<Object> valueDeser, TypeDeserializer typeDeser) {\n        this(property, setter, type, null, valueDeser, typeDeser);\n    }\n\n    public SettableAnyProperty withValueDeserializer(JsonDeserializer<Object> deser) {\n        return new SettableAnyProperty(_property, _setter, _type,\n                _keyDeserializer, deser, _valueTypeDeserializer);\n    }\n\n    public void fixAccess(DeserializationConfig config) {\n        _setter.fixAccess(\n                config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n    }\n\n    \n\n    \n    Object readResolve() {\n        \n        if (_setter == null || _setter.getAnnotated() == null) {\n            throw new IllegalArgumentException(\"Missing method (broken JDK (de)serialization?)\");\n        }\n        return this;\n    }\n    \n    \n\n    public BeanProperty getProperty() { return _property; }\n    \n    public boolean hasValueDeserializer() { return (_valueDeserializer != null); }\n\n    public JavaType getType() { return _type; }\n\n    \n    \n    \n    public final void deserializeAndSet(JsonParser p, DeserializationContext ctxt, Object instance, String propName) throws IOException {\n        try {\n            Object key = (_keyDeserializer == null) ? propName\n                    : _keyDeserializer.deserializeKey(propName, ctxt);\n            set(instance, key, deserialize(p, ctxt));\n        } catch (UnresolvedForwardReference reference) {\n            if (!(_valueDeserializer.getObjectIdReader() != null)) {\n                throw JsonMappingException.from(p, \"Unresolved forward reference but no identity info.\", reference);\n            }\n            AnySetterReferring referring = new AnySetterReferring(this, reference,\n                    _type.getRawClass(), instance, propName);\n            reference.getRoid().appendReferring(referring);\n        }\n    }\n\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n        JsonToken t = p.getCurrentToken();\n        if (t == JsonToken.VALUE_NULL) {\n            return _valueDeserializer.getNullValue(ctxt);\n        }\n        if (_valueTypeDeserializer != null) {\n            return _valueDeserializer.deserializeWithType(p, ctxt, _valueTypeDeserializer);\n        }\n        return _valueDeserializer.deserialize(p, ctxt);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public void set(Object instance, Object propName, Object value) throws IOException {\n        try {\n            \n            if (_setterIsField) {\n                AnnotatedField field = (AnnotatedField) _setter;\n                Map<Object,Object> val = (Map<Object,Object>) field.getValue(instance);\n                \n                if (val != null) {\n                    \n                    val.put(propName, value);\n                }\n            } else {\n                \n                ((AnnotatedMethod) _setter).callOnWith(instance, propName, value);\n            }\n        } catch (Exception e) {\n            _throwAsIOE(e, propName, value);\n        }\n    }\n\n    \n\n    \n    protected void _throwAsIOE(Exception e, Object propName, Object value) throws IOException {\n        if (e instanceof IllegalArgumentException) {\n            String actType = ClassUtil.classNameOf(value);\n            StringBuilder msg = new StringBuilder(\"Problem deserializing \\\"any\\\" property '\").append(propName);\n            msg.append(\"' of class \"+getClassName()+\" (expected type: \").append(_type);\n            msg.append(\"; actual type: \").append(actType).append(\")\");\n            String origMsg = ClassUtil.exceptionMessage(e);\n            if (origMsg != null) {\n                msg.append(\", problem: \").append(origMsg);\n            } else {\n                msg.append(\" (no error message provided)\");\n            }\n            throw new JsonMappingException(null, msg.toString(), e);\n        }\n        ClassUtil.throwIfIOE(e);\n        ClassUtil.throwIfRTE(e);\n        \n        Throwable t = ClassUtil.getRootCause(e);\n        throw new JsonMappingException(null, ClassUtil.exceptionMessage(t), t);\n    }\n\n    private String getClassName() { return _setter.getDeclaringClass().getName(); }\n\n    @Override public String toString() { return \"[any property on class \"+getClassName()+\"]\"; }\n\n    private static class AnySetterReferring extends Referring { private final SettableAnyProperty _parent; private final Object _pojo; private final String _propName; public AnySetterReferring(SettableAnyProperty parent, UnresolvedForwardReference reference, Class<?> type, Object instance, String propName) {\n            super(reference, type);\n            _parent = parent;\n            _pojo = instance;\n            _propName = propName;\n        }\n\n        @Override\n        public void handleResolvedForwardReference(Object id, Object value) throws IOException {\n            if (!hasId(id)) {\n                throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id.toString()\n                        + \"] that wasn't previously registered.\");\n            }\n            _parent.set(_pojo, _propName, value);\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public SettableAnyProperty(BeanProperty property, AnnotatedMember setter, JavaType type, JsonDeserializer<Object> valueDeser, TypeDeserializer typeDeser)",
        "public SettableAnyProperty withValueDeserializer(JsonDeserializer<Object> deser)",
        "public void fixAccess(DeserializationConfig config)",
        "public BeanProperty getProperty()",
        "public boolean hasValueDeserializer()",
        "public JavaType getType()",
        "public final void deserializeAndSet(JsonParser p, DeserializationContext ctxt, Object instance, String propName) throws IOException",
        "public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public void set(Object instance, Object propName, Object value) throws IOException",
        "protected void _throwAsIOE(Exception e, Object propName, Object value) throws IOException",
        "private String getClassName()",
        "public String toString()",
        "private static class AnySetterReferring extends Referring { private final SettableAnyProperty _parent; private final Object _pojo; private final String _propName; public AnySetterReferring(SettableAnyProperty parent, UnresolvedForwardReference reference, Class<?> type, Object instance, String propName)",
        "public void handleResolvedForwardReference(Object id, Object value) throws IOException"
      ],
      "fixed_signatures": [
        "public SettableAnyProperty(BeanProperty property, AnnotatedMember setter, JavaType type, JsonDeserializer<Object> valueDeser, TypeDeserializer typeDeser)",
        "public SettableAnyProperty withValueDeserializer(JsonDeserializer<Object> deser)",
        "public void fixAccess(DeserializationConfig config)",
        "public BeanProperty getProperty()",
        "public boolean hasValueDeserializer()",
        "public JavaType getType()",
        "public final void deserializeAndSet(JsonParser p, DeserializationContext ctxt, Object instance, String propName) throws IOException",
        "public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public void set(Object instance, Object propName, Object value) throws IOException",
        "protected void _throwAsIOE(Exception e, Object propName, Object value) throws IOException",
        "private String getClassName()",
        "public String toString()",
        "private static class AnySetterReferring extends Referring { private final SettableAnyProperty _parent; private final Object _pojo; private final String _propName; public AnySetterReferring(SettableAnyProperty parent, UnresolvedForwardReference reference, Class<?> type, Object instance, String propName)",
        "public void handleResolvedForwardReference(Object id, Object value) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  protected void _throwAsIOE(Exception e, Object propName, Object value) throws IOException {\n  if (e instanceof IllegalArgumentException) {\n  String actType = ClassUtil.classNameOf(value);\n  StringBuilder msg = new StringBuilder(\"Problem deserializing \\\"any\\\" property '\").append(propName);\n  msg.append(\"' of class \"+getClassName()+\" (expected type: \").append(_type);\n  msg.append(\"; actual type: \").append(actType).append(\")\");\n  String origMsg = e.getMessage();\n  if (origMsg != null) {\n  msg.append(\", problem: \").append(origMsg);\n  } else {\n  msg.append(\" (no error message provided)\");\n  }\n  throw new JsonMappingException(null, msg.toString(), e);\n  }\n  ClassUtil.throwIfIOE(e);\n  ClassUtil.throwIfRTE(e);\n  \n  Throwable t = ClassUtil.getRootCause(e);\n  throw new JsonMappingException(null, t.getMessage(), t);\n  }",
          "fixed_method": "  protected void _throwAsIOE(Exception e, Object propName, Object value) throws IOException {\n  if (e instanceof IllegalArgumentException) {\n  String actType = ClassUtil.classNameOf(value);\n  StringBuilder msg = new StringBuilder(\"Problem deserializing \\\"any\\\" property '\").append(propName);\n  msg.append(\"' of class \"+getClassName()+\" (expected type: \").append(_type);\n  msg.append(\"; actual type: \").append(actType).append(\")\");\n  String origMsg = ClassUtil.exceptionMessage(e);\n  if (origMsg != null) {\n  msg.append(\", problem: \").append(origMsg);\n  } else {\n  msg.append(\" (no error message provided)\");\n  }\n  throw new JsonMappingException(null, msg.toString(), e);\n  }\n  ClassUtil.throwIfIOE(e);\n  ClassUtil.throwIfRTE(e);\n  \n  Throwable t = ClassUtil.getRootCause(e);\n  throw new JsonMappingException(null, ClassUtil.exceptionMessage(t), t);\n  }",
          "diff": [
            "@@ -199,7 +199,7 @@",
            "             StringBuilder msg = new StringBuilder(\"Problem deserializing \\\"any\\\" property '\").append(propName);\n",
            "             msg.append(\"' of class \"+getClassName()+\" (expected type: \").append(_type);\n",
            "             msg.append(\"; actual type: \").append(actType).append(\")\");\n",
            "-            String origMsg = e.getMessage();\n",
            "+            String origMsg = ClassUtil.exceptionMessage(e);\n",
            "             if (origMsg != null) {\n",
            "                 msg.append(\", problem: \").append(origMsg);\n",
            "             } else {\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  private String getClassName() { return _setter.getDeclaringClass().getName(); }",
          "fixed_method": "  private String getClassName() { return _setter.getDeclaringClass().getName(); }",
          "diff": [
            "@@ -211,7 +211,7 @@",
            "         ClassUtil.throwIfRTE(e);\n",
            "         // let's wrap the innermost problem\n",
            "         Throwable t = ClassUtil.getRootCause(e);\n",
            "-        throw new JsonMappingException(null, t.getMessage(), t);\n",
            "+        throw new JsonMappingException(null, ClassUtil.exceptionMessage(t), t);\n",
            "     }\n",
            " \n",
            "     private String getClassName() { return _setter.getDeclaringClass().getName(); }\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/deser/SettableBeanProperty.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.deser;\n\nimport java.io.IOException;\nimport java.lang.annotation.Annotation;\n\nimport com.fasterxml.jackson.core.*;\n\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.deser.impl.FailingDeserializer;\nimport com.fasterxml.jackson.databind.deser.impl.NullsConstantProvider;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.util.Annotations;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.ViewMatcher;\n\n\n@SuppressWarnings(\"serial\")\npublic abstract class SettableBeanProperty extends ConcreteBeanPropertyBase implements java.io.Serializable { protected static final JsonDeserializer<Object> MISSING_VALUE_DESERIALIZER = new FailingDeserializer( \"No _valueDeserializer assigned\"); protected final PropertyName _propName; protected final JavaType _type; protected final PropertyName _wrapperName; protected final transient Annotations _contextAnnotations; protected final JsonDeserializer<Object> _valueDeserializer; protected final TypeDeserializer _valueTypeDeserializer; protected final NullValueProvider _nullProvider; protected String _managedReferenceName; protected ObjectIdInfo _objectIdInfo; protected ViewMatcher _viewMatcher; protected int _propertyIndex = -1; protected SettableBeanProperty(BeanPropertyDefinition propDef, JavaType type, TypeDeserializer typeDeser, Annotations contextAnnotations) {\n        this(propDef.getFullName(), type, propDef.getWrapperName(), typeDeser,\n                contextAnnotations, propDef.getMetadata());\n    }\n\n    protected SettableBeanProperty(PropertyName propName, JavaType type, PropertyName wrapper, TypeDeserializer typeDeser, Annotations contextAnnotations, PropertyMetadata metadata) {\n        super(metadata);\n        \n        \n        \n        \n        \n        if (propName == null) {\n            _propName = PropertyName.NO_NAME;\n        } else {\n            _propName = propName.internSimpleName();\n        }\n        _type = type;\n        _wrapperName = wrapper;\n        _contextAnnotations = contextAnnotations;\n        _viewMatcher = null;\n\n        \n        if (typeDeser != null) {\n            typeDeser = typeDeser.forProperty(this);\n        }\n        _valueTypeDeserializer = typeDeser;\n        _valueDeserializer = MISSING_VALUE_DESERIALIZER;\n        _nullProvider = MISSING_VALUE_DESERIALIZER;\n    }\n\n    \n    protected SettableBeanProperty(PropertyName propName, JavaType type, PropertyMetadata metadata, JsonDeserializer<Object> valueDeser) {\n        super(metadata);\n        \n        if (propName == null) {\n            _propName = PropertyName.NO_NAME;\n        } else {\n            _propName = propName.internSimpleName();\n        }\n        _type = type;\n        _wrapperName = null;\n        _contextAnnotations = null;\n        _viewMatcher = null;\n        _valueTypeDeserializer = null;\n        _valueDeserializer = valueDeser;\n        \n        _nullProvider = valueDeser;\n    }\n\n    \n    protected SettableBeanProperty(SettableBeanProperty src) {\n        super(src);\n        _propName = src._propName;\n        _type = src._type;\n        _wrapperName = src._wrapperName;\n        _contextAnnotations = src._contextAnnotations;\n        _valueDeserializer = src._valueDeserializer;\n        _valueTypeDeserializer = src._valueTypeDeserializer;\n        _managedReferenceName = src._managedReferenceName;\n        _propertyIndex = src._propertyIndex;\n        _viewMatcher = src._viewMatcher;\n        _nullProvider = src._nullProvider;\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    protected SettableBeanProperty(SettableBeanProperty src, JsonDeserializer<?> deser, NullValueProvider nuller) {\n        super(src);\n        _propName = src._propName;\n        _type = src._type;\n        _wrapperName = src._wrapperName;\n        _contextAnnotations = src._contextAnnotations;\n        _valueTypeDeserializer = src._valueTypeDeserializer;\n        _managedReferenceName = src._managedReferenceName;\n        _propertyIndex = src._propertyIndex;\n\n        if (deser == null) {\n            _valueDeserializer = MISSING_VALUE_DESERIALIZER;\n        } else {\n            _valueDeserializer = (JsonDeserializer<Object>) deser;\n        }\n        _viewMatcher = src._viewMatcher;\n        \n        if (nuller == MISSING_VALUE_DESERIALIZER) {\n            nuller = _valueDeserializer;\n        }\n        _nullProvider = nuller;\n    }\n\n    \n    protected SettableBeanProperty(SettableBeanProperty src, PropertyName newName) {\n        super(src);\n        _propName = newName;\n        _type = src._type;\n        _wrapperName = src._wrapperName;\n        _contextAnnotations = src._contextAnnotations;\n        _valueDeserializer = src._valueDeserializer;\n        _valueTypeDeserializer = src._valueTypeDeserializer;\n        _managedReferenceName = src._managedReferenceName;\n        _propertyIndex = src._propertyIndex;\n        _viewMatcher = src._viewMatcher;\n        _nullProvider = src._nullProvider;\n    }\n\n    \n    public abstract SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser); public abstract SettableBeanProperty withName(PropertyName newName); public SettableBeanProperty withSimpleName(String simpleName) {\n        PropertyName n = (_propName == null)\n                ? new PropertyName(simpleName) : _propName.withSimpleName(simpleName);\n        return (n == _propName) ? this : withName(n);\n    }\n\n    \n    public abstract SettableBeanProperty withNullProvider(NullValueProvider nva); public void setManagedReferenceName(String n) {\n        _managedReferenceName = n;\n    }\n\n    public void setObjectIdInfo(ObjectIdInfo objectIdInfo) {\n        _objectIdInfo = objectIdInfo;\n    }\n\n    public void setViews(Class<?>[] views) {\n        if (views == null) {\n            _viewMatcher = null;\n        } else {\n            _viewMatcher = ViewMatcher.construct(views);\n        }\n    }\n\n    \n    public void assignIndex(int index) {\n        if (_propertyIndex != -1) {\n            throw new IllegalStateException(\"Property '\"+getName()+\"' already had index (\"+_propertyIndex+\"), trying to assign \"+index);\n        }\n        _propertyIndex = index;\n    }\n\n    \n    public void fixAccess(DeserializationConfig config) {\n        ;\n    }\n\n    \n    public void markAsIgnorable() { }\n\n    \n    public boolean isIgnorable() { return false; }\n\n    \n    \n    @Override\n    public final String getName() {\n        return _propName.getSimpleName();\n    }\n\n    @Override\n    public PropertyName getFullName() {\n        return _propName;\n    }\n\n    @Override\n    public JavaType getType() { return _type; }\n\n    @Override\n    public PropertyName getWrapperName() {\n        return _wrapperName;\n    }\n    \n    @Override\n    public abstract AnnotatedMember getMember(); @Override public abstract <A extends Annotation> A getAnnotation(Class<A> acls); @Override public <A extends Annotation> A getContextAnnotation(Class<A> acls) {\n        return _contextAnnotations.get(acls);\n    }\n\n    @Override\n    public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor, SerializerProvider provider) throws JsonMappingException {\n        if (isRequired()) {\n            objectVisitor.property(this); \n        } else {\n            objectVisitor.optionalProperty(this);\n        }\n    }\n\n    \n\n    protected Class<?> getDeclaringClass() {\n        return getMember().getDeclaringClass();\n    }\n\n    public String getManagedReferenceName() { return _managedReferenceName; }\n\n    public ObjectIdInfo getObjectIdInfo() { return _objectIdInfo; }\n\n    public boolean hasValueDeserializer() {\n        return (_valueDeserializer != null) && (_valueDeserializer != MISSING_VALUE_DESERIALIZER);\n    }\n\n    public boolean hasValueTypeDeserializer() { return (_valueTypeDeserializer != null); }\n\n    public JsonDeserializer<Object> getValueDeserializer() {\n        JsonDeserializer<Object> deser = _valueDeserializer;\n        if (deser == MISSING_VALUE_DESERIALIZER) {\n            return null;\n        }\n        return deser;\n    }\n\n    public TypeDeserializer getValueTypeDeserializer() { return _valueTypeDeserializer; }\n\n    \n    public NullValueProvider getNullValueProvider() { return _nullProvider; }\n\n    public boolean visibleInView(Class<?> activeView) {\n        return (_viewMatcher == null) || _viewMatcher.isVisibleForView(activeView);\n    }\n\n    public boolean hasViews() { return _viewMatcher != null; }\n    \n    \n    public int getPropertyIndex() { return _propertyIndex; }\n\n    \n    public int getCreatorIndex() {\n        \n        throw new IllegalStateException(String.format(\n                \"Internal error: no creator index for property '%s' (of type %s)\",\n                this.getName(), getClass().getName()));\n    }\n\n    \n    public Object getInjectableValueId() { return null; }\n    \n    \n\n    \n    public abstract void deserializeAndSet(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException; public abstract Object deserializeSetAndReturn(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException; public abstract void set(Object instance, Object value) throws IOException; public abstract Object setAndReturn(Object instance, Object value) throws IOException; public final Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n        if (p.hasToken(JsonToken.VALUE_NULL)) {\n            return _nullProvider.getNullValue(ctxt);\n        }\n        if (_valueTypeDeserializer != null) {\n            return _valueDeserializer.deserializeWithType(p, ctxt, _valueTypeDeserializer);\n        }\n        \n        Object value =  _valueDeserializer.deserialize(p, ctxt);\n        if (value == null) {\n            value = _nullProvider.getNullValue(ctxt);\n        }\n        return value;\n    }\n\n    \n    public final Object deserializeWith(JsonParser p, DeserializationContext ctxt, Object toUpdate) throws IOException {\n        \n        \n        if (p.hasToken(JsonToken.VALUE_NULL)) {\n            \n            if (NullsConstantProvider.isSkipper(_nullProvider)) {\n                return toUpdate;\n            }\n            return _nullProvider.getNullValue(ctxt);\n        }\n        \n        if (_valueTypeDeserializer != null) {\n            ctxt.reportBadDefinition(getType(),\n                    String.format(\"Cannot merge polymorphic property '%s'\",\n                            getName()));\n\n        }\n        \n        Object value = _valueDeserializer.deserialize(p, ctxt, toUpdate);\n        if (value == null) {\n            if (NullsConstantProvider.isSkipper(_nullProvider)) {\n                return toUpdate;\n            }\n            value = _nullProvider.getNullValue(ctxt);\n        }\n        return value;\n    }\n\n    \n\n    \n    protected void _throwAsIOE(JsonParser p, Exception e, Object value) throws IOException {\n        if (e instanceof IllegalArgumentException) {\n            String actType = ClassUtil.classNameOf(value);\n            StringBuilder msg = new StringBuilder(\"Problem deserializing property '\")\n                    .append(getName())\n                    .append(\"' (expected type: \")\n                    .append(getType())\n                    .append(\"; actual type: \")\n                    .append(actType).append(\")\");\n            String origMsg = e.getMessage();\n            if (origMsg != null) {\n                msg.append(\", problem: \")\n                    .append(origMsg);\n            } else {\n                msg.append(\" (no error message provided)\");\n            }\n            throw JsonMappingException.from(p, msg.toString(), e);\n        }\n        _throwAsIOE(p, e);\n    }\n    \n    \n    protected IOException _throwAsIOE(JsonParser p, Exception e) throws IOException {\n        ClassUtil.throwIfIOE(e);\n        ClassUtil.throwIfRTE(e);\n        \n        Throwable th = ClassUtil.getRootCause(e);\n        throw JsonMappingException.from(p, th.getMessage(), th);\n    }\n\n    @Deprecated \n    protected IOException _throwAsIOE(Exception e) throws IOException {\n        return _throwAsIOE((JsonParser) null, e);\n    }\n\n    \n    \n    protected void _throwAsIOE(Exception e, Object value) throws IOException {\n        _throwAsIOE((JsonParser) null, e, value);\n    }\n\n    @Override public String toString() { return \"[property '\"+getName()+\"']\"; }\n\n    \n\n    \n    public static abstract class Delegating extends SettableBeanProperty { protected final SettableBeanProperty delegate; protected Delegating(SettableBeanProperty d) {\n            super(d);\n            delegate = d;\n        }\n\n        \n        protected abstract SettableBeanProperty withDelegate(SettableBeanProperty d); protected SettableBeanProperty _with(SettableBeanProperty newDelegate) {\n            if (newDelegate == delegate) {\n                return this;\n            }\n            return withDelegate(newDelegate);\n        }\n        \n        @Override\n        public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {\n            return _with(delegate.withValueDeserializer(deser));\n        }\n\n        @Override\n        public SettableBeanProperty withName(PropertyName newName) {\n            return _with(delegate.withName(newName));\n        }\n\n        @Override\n        public SettableBeanProperty withNullProvider(NullValueProvider nva) {\n            return _with(delegate.withNullProvider(nva));\n        }\n\n        @Override\n        public void assignIndex(int index) {\n            delegate.assignIndex(index);\n        }\n\n        @Override\n        public void fixAccess(DeserializationConfig config) {\n            delegate.fixAccess(config);\n        }\n\n        \n\n        @Override\n        protected Class<?> getDeclaringClass() { return delegate.getDeclaringClass(); }\n\n        @Override\n        public String getManagedReferenceName() { return delegate.getManagedReferenceName(); }\n\n        @Override\n        public ObjectIdInfo getObjectIdInfo() { return delegate.getObjectIdInfo(); }\n\n        @Override\n        public boolean hasValueDeserializer() { return delegate.hasValueDeserializer(); }\n\n        @Override\n        public boolean hasValueTypeDeserializer() { return delegate.hasValueTypeDeserializer(); }\n        \n        @Override\n        public JsonDeserializer<Object> getValueDeserializer() { return delegate.getValueDeserializer(); }\n\n        @Override\n        public TypeDeserializer getValueTypeDeserializer() { return delegate.getValueTypeDeserializer(); }\n\n        @Override\n        public boolean visibleInView(Class<?> activeView) { return delegate.visibleInView(activeView); }\n\n        @Override\n        public boolean hasViews() { return delegate.hasViews(); }\n\n        @Override\n        public int getPropertyIndex() { return delegate.getPropertyIndex(); }\n\n        @Override\n        public int getCreatorIndex() { return delegate.getCreatorIndex(); }\n\n        @Override\n        public Object getInjectableValueId() { return delegate.getInjectableValueId(); }\n\n        @Override\n        public AnnotatedMember getMember() {\n            return delegate.getMember();\n        }\n\n        @Override\n        public <A extends Annotation> A getAnnotation(Class<A> acls) {\n            return delegate.getAnnotation(acls);\n        }\n\n        \n\n        public SettableBeanProperty getDelegate() {\n            return delegate;\n        }\n\n        \n\n        @Override\n        public void deserializeAndSet(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException {\n            delegate.deserializeAndSet(p, ctxt, instance);\n        }\n\n        @Override\n        public Object deserializeSetAndReturn(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException {\n            return delegate.deserializeSetAndReturn(p, ctxt, instance);\n        }\n\n        @Override\n        public void set(Object instance, Object value) throws IOException {\n            delegate.set(instance, value);\n        }\n\n        @Override\n        public Object setAndReturn(Object instance, Object value) throws IOException {\n            return delegate.setAndReturn(instance, value);\n        }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.deser;\n\nimport java.io.IOException;\nimport java.lang.annotation.Annotation;\n\nimport com.fasterxml.jackson.core.*;\n\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.deser.impl.FailingDeserializer;\nimport com.fasterxml.jackson.databind.deser.impl.NullsConstantProvider;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.util.Annotations;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.ViewMatcher;\n\n\n@SuppressWarnings(\"serial\")\npublic abstract class SettableBeanProperty extends ConcreteBeanPropertyBase implements java.io.Serializable { protected static final JsonDeserializer<Object> MISSING_VALUE_DESERIALIZER = new FailingDeserializer( \"No _valueDeserializer assigned\"); protected final PropertyName _propName; protected final JavaType _type; protected final PropertyName _wrapperName; protected final transient Annotations _contextAnnotations; protected final JsonDeserializer<Object> _valueDeserializer; protected final TypeDeserializer _valueTypeDeserializer; protected final NullValueProvider _nullProvider; protected String _managedReferenceName; protected ObjectIdInfo _objectIdInfo; protected ViewMatcher _viewMatcher; protected int _propertyIndex = -1; protected SettableBeanProperty(BeanPropertyDefinition propDef, JavaType type, TypeDeserializer typeDeser, Annotations contextAnnotations) {\n        this(propDef.getFullName(), type, propDef.getWrapperName(), typeDeser,\n                contextAnnotations, propDef.getMetadata());\n    }\n\n    protected SettableBeanProperty(PropertyName propName, JavaType type, PropertyName wrapper, TypeDeserializer typeDeser, Annotations contextAnnotations, PropertyMetadata metadata) {\n        super(metadata);\n        \n        \n        \n        \n        \n        if (propName == null) {\n            _propName = PropertyName.NO_NAME;\n        } else {\n            _propName = propName.internSimpleName();\n        }\n        _type = type;\n        _wrapperName = wrapper;\n        _contextAnnotations = contextAnnotations;\n        _viewMatcher = null;\n\n        \n        if (typeDeser != null) {\n            typeDeser = typeDeser.forProperty(this);\n        }\n        _valueTypeDeserializer = typeDeser;\n        _valueDeserializer = MISSING_VALUE_DESERIALIZER;\n        _nullProvider = MISSING_VALUE_DESERIALIZER;\n    }\n\n    \n    protected SettableBeanProperty(PropertyName propName, JavaType type, PropertyMetadata metadata, JsonDeserializer<Object> valueDeser) {\n        super(metadata);\n        \n        if (propName == null) {\n            _propName = PropertyName.NO_NAME;\n        } else {\n            _propName = propName.internSimpleName();\n        }\n        _type = type;\n        _wrapperName = null;\n        _contextAnnotations = null;\n        _viewMatcher = null;\n        _valueTypeDeserializer = null;\n        _valueDeserializer = valueDeser;\n        \n        _nullProvider = valueDeser;\n    }\n\n    \n    protected SettableBeanProperty(SettableBeanProperty src) {\n        super(src);\n        _propName = src._propName;\n        _type = src._type;\n        _wrapperName = src._wrapperName;\n        _contextAnnotations = src._contextAnnotations;\n        _valueDeserializer = src._valueDeserializer;\n        _valueTypeDeserializer = src._valueTypeDeserializer;\n        _managedReferenceName = src._managedReferenceName;\n        _propertyIndex = src._propertyIndex;\n        _viewMatcher = src._viewMatcher;\n        _nullProvider = src._nullProvider;\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    protected SettableBeanProperty(SettableBeanProperty src, JsonDeserializer<?> deser, NullValueProvider nuller) {\n        super(src);\n        _propName = src._propName;\n        _type = src._type;\n        _wrapperName = src._wrapperName;\n        _contextAnnotations = src._contextAnnotations;\n        _valueTypeDeserializer = src._valueTypeDeserializer;\n        _managedReferenceName = src._managedReferenceName;\n        _propertyIndex = src._propertyIndex;\n\n        if (deser == null) {\n            _valueDeserializer = MISSING_VALUE_DESERIALIZER;\n        } else {\n            _valueDeserializer = (JsonDeserializer<Object>) deser;\n        }\n        _viewMatcher = src._viewMatcher;\n        \n        if (nuller == MISSING_VALUE_DESERIALIZER) {\n            nuller = _valueDeserializer;\n        }\n        _nullProvider = nuller;\n    }\n\n    \n    protected SettableBeanProperty(SettableBeanProperty src, PropertyName newName) {\n        super(src);\n        _propName = newName;\n        _type = src._type;\n        _wrapperName = src._wrapperName;\n        _contextAnnotations = src._contextAnnotations;\n        _valueDeserializer = src._valueDeserializer;\n        _valueTypeDeserializer = src._valueTypeDeserializer;\n        _managedReferenceName = src._managedReferenceName;\n        _propertyIndex = src._propertyIndex;\n        _viewMatcher = src._viewMatcher;\n        _nullProvider = src._nullProvider;\n    }\n\n    \n    public abstract SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser); public abstract SettableBeanProperty withName(PropertyName newName); public SettableBeanProperty withSimpleName(String simpleName) {\n        PropertyName n = (_propName == null)\n                ? new PropertyName(simpleName) : _propName.withSimpleName(simpleName);\n        return (n == _propName) ? this : withName(n);\n    }\n\n    \n    public abstract SettableBeanProperty withNullProvider(NullValueProvider nva); public void setManagedReferenceName(String n) {\n        _managedReferenceName = n;\n    }\n\n    public void setObjectIdInfo(ObjectIdInfo objectIdInfo) {\n        _objectIdInfo = objectIdInfo;\n    }\n\n    public void setViews(Class<?>[] views) {\n        if (views == null) {\n            _viewMatcher = null;\n        } else {\n            _viewMatcher = ViewMatcher.construct(views);\n        }\n    }\n\n    \n    public void assignIndex(int index) {\n        if (_propertyIndex != -1) {\n            throw new IllegalStateException(\"Property '\"+getName()+\"' already had index (\"+_propertyIndex+\"), trying to assign \"+index);\n        }\n        _propertyIndex = index;\n    }\n\n    \n    public void fixAccess(DeserializationConfig config) {\n        ;\n    }\n\n    \n    public void markAsIgnorable() { }\n\n    \n    public boolean isIgnorable() { return false; }\n\n    \n    \n    @Override\n    public final String getName() {\n        return _propName.getSimpleName();\n    }\n\n    @Override\n    public PropertyName getFullName() {\n        return _propName;\n    }\n\n    @Override\n    public JavaType getType() { return _type; }\n\n    @Override\n    public PropertyName getWrapperName() {\n        return _wrapperName;\n    }\n    \n    @Override\n    public abstract AnnotatedMember getMember(); @Override public abstract <A extends Annotation> A getAnnotation(Class<A> acls); @Override public <A extends Annotation> A getContextAnnotation(Class<A> acls) {\n        return _contextAnnotations.get(acls);\n    }\n\n    @Override\n    public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor, SerializerProvider provider) throws JsonMappingException {\n        if (isRequired()) {\n            objectVisitor.property(this); \n        } else {\n            objectVisitor.optionalProperty(this);\n        }\n    }\n\n    \n\n    protected Class<?> getDeclaringClass() {\n        return getMember().getDeclaringClass();\n    }\n\n    public String getManagedReferenceName() { return _managedReferenceName; }\n\n    public ObjectIdInfo getObjectIdInfo() { return _objectIdInfo; }\n\n    public boolean hasValueDeserializer() {\n        return (_valueDeserializer != null) && (_valueDeserializer != MISSING_VALUE_DESERIALIZER);\n    }\n\n    public boolean hasValueTypeDeserializer() { return (_valueTypeDeserializer != null); }\n\n    public JsonDeserializer<Object> getValueDeserializer() {\n        JsonDeserializer<Object> deser = _valueDeserializer;\n        if (deser == MISSING_VALUE_DESERIALIZER) {\n            return null;\n        }\n        return deser;\n    }\n\n    public TypeDeserializer getValueTypeDeserializer() { return _valueTypeDeserializer; }\n\n    \n    public NullValueProvider getNullValueProvider() { return _nullProvider; }\n\n    public boolean visibleInView(Class<?> activeView) {\n        return (_viewMatcher == null) || _viewMatcher.isVisibleForView(activeView);\n    }\n\n    public boolean hasViews() { return _viewMatcher != null; }\n    \n    \n    public int getPropertyIndex() { return _propertyIndex; }\n\n    \n    public int getCreatorIndex() {\n        \n        throw new IllegalStateException(String.format(\n                \"Internal error: no creator index for property '%s' (of type %s)\",\n                this.getName(), getClass().getName()));\n    }\n\n    \n    public Object getInjectableValueId() { return null; }\n    \n    \n\n    \n    public abstract void deserializeAndSet(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException; public abstract Object deserializeSetAndReturn(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException; public abstract void set(Object instance, Object value) throws IOException; public abstract Object setAndReturn(Object instance, Object value) throws IOException; public final Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n        if (p.hasToken(JsonToken.VALUE_NULL)) {\n            return _nullProvider.getNullValue(ctxt);\n        }\n        if (_valueTypeDeserializer != null) {\n            return _valueDeserializer.deserializeWithType(p, ctxt, _valueTypeDeserializer);\n        }\n        \n        Object value =  _valueDeserializer.deserialize(p, ctxt);\n        if (value == null) {\n            value = _nullProvider.getNullValue(ctxt);\n        }\n        return value;\n    }\n\n    \n    public final Object deserializeWith(JsonParser p, DeserializationContext ctxt, Object toUpdate) throws IOException {\n        \n        \n        if (p.hasToken(JsonToken.VALUE_NULL)) {\n            \n            if (NullsConstantProvider.isSkipper(_nullProvider)) {\n                return toUpdate;\n            }\n            return _nullProvider.getNullValue(ctxt);\n        }\n        \n        if (_valueTypeDeserializer != null) {\n            ctxt.reportBadDefinition(getType(),\n                    String.format(\"Cannot merge polymorphic property '%s'\",\n                            getName()));\n\n        }\n        \n        Object value = _valueDeserializer.deserialize(p, ctxt, toUpdate);\n        if (value == null) {\n            if (NullsConstantProvider.isSkipper(_nullProvider)) {\n                return toUpdate;\n            }\n            value = _nullProvider.getNullValue(ctxt);\n        }\n        return value;\n    }\n\n    \n\n    \n    protected void _throwAsIOE(JsonParser p, Exception e, Object value) throws IOException {\n        if (e instanceof IllegalArgumentException) {\n            String actType = ClassUtil.classNameOf(value);\n            StringBuilder msg = new StringBuilder(\"Problem deserializing property '\")\n                    .append(getName())\n                    .append(\"' (expected type: \")\n                    .append(getType())\n                    .append(\"; actual type: \")\n                    .append(actType).append(\")\");\n            String origMsg = ClassUtil.exceptionMessage(e);\n            if (origMsg != null) {\n                msg.append(\", problem: \")\n                    .append(origMsg);\n            } else {\n                msg.append(\" (no error message provided)\");\n            }\n            throw JsonMappingException.from(p, msg.toString(), e);\n        }\n        _throwAsIOE(p, e);\n    }\n    \n    \n    protected IOException _throwAsIOE(JsonParser p, Exception e) throws IOException {\n        ClassUtil.throwIfIOE(e);\n        ClassUtil.throwIfRTE(e);\n        \n        Throwable th = ClassUtil.getRootCause(e);\n        throw JsonMappingException.from(p, ClassUtil.exceptionMessage(th), th);\n    }\n\n    @Deprecated \n    protected IOException _throwAsIOE(Exception e) throws IOException {\n        return _throwAsIOE((JsonParser) null, e);\n    }\n\n    \n    \n    protected void _throwAsIOE(Exception e, Object value) throws IOException {\n        _throwAsIOE((JsonParser) null, e, value);\n    }\n\n    @Override public String toString() { return \"[property '\"+getName()+\"']\"; }\n\n    \n\n    \n    public static abstract class Delegating extends SettableBeanProperty { protected final SettableBeanProperty delegate; protected Delegating(SettableBeanProperty d) {\n            super(d);\n            delegate = d;\n        }\n\n        \n        protected abstract SettableBeanProperty withDelegate(SettableBeanProperty d); protected SettableBeanProperty _with(SettableBeanProperty newDelegate) {\n            if (newDelegate == delegate) {\n                return this;\n            }\n            return withDelegate(newDelegate);\n        }\n        \n        @Override\n        public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {\n            return _with(delegate.withValueDeserializer(deser));\n        }\n\n        @Override\n        public SettableBeanProperty withName(PropertyName newName) {\n            return _with(delegate.withName(newName));\n        }\n\n        @Override\n        public SettableBeanProperty withNullProvider(NullValueProvider nva) {\n            return _with(delegate.withNullProvider(nva));\n        }\n\n        @Override\n        public void assignIndex(int index) {\n            delegate.assignIndex(index);\n        }\n\n        @Override\n        public void fixAccess(DeserializationConfig config) {\n            delegate.fixAccess(config);\n        }\n\n        \n\n        @Override\n        protected Class<?> getDeclaringClass() { return delegate.getDeclaringClass(); }\n\n        @Override\n        public String getManagedReferenceName() { return delegate.getManagedReferenceName(); }\n\n        @Override\n        public ObjectIdInfo getObjectIdInfo() { return delegate.getObjectIdInfo(); }\n\n        @Override\n        public boolean hasValueDeserializer() { return delegate.hasValueDeserializer(); }\n\n        @Override\n        public boolean hasValueTypeDeserializer() { return delegate.hasValueTypeDeserializer(); }\n        \n        @Override\n        public JsonDeserializer<Object> getValueDeserializer() { return delegate.getValueDeserializer(); }\n\n        @Override\n        public TypeDeserializer getValueTypeDeserializer() { return delegate.getValueTypeDeserializer(); }\n\n        @Override\n        public boolean visibleInView(Class<?> activeView) { return delegate.visibleInView(activeView); }\n\n        @Override\n        public boolean hasViews() { return delegate.hasViews(); }\n\n        @Override\n        public int getPropertyIndex() { return delegate.getPropertyIndex(); }\n\n        @Override\n        public int getCreatorIndex() { return delegate.getCreatorIndex(); }\n\n        @Override\n        public Object getInjectableValueId() { return delegate.getInjectableValueId(); }\n\n        @Override\n        public AnnotatedMember getMember() {\n            return delegate.getMember();\n        }\n\n        @Override\n        public <A extends Annotation> A getAnnotation(Class<A> acls) {\n            return delegate.getAnnotation(acls);\n        }\n\n        \n\n        public SettableBeanProperty getDelegate() {\n            return delegate;\n        }\n\n        \n\n        @Override\n        public void deserializeAndSet(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException {\n            delegate.deserializeAndSet(p, ctxt, instance);\n        }\n\n        @Override\n        public Object deserializeSetAndReturn(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException {\n            return delegate.deserializeSetAndReturn(p, ctxt, instance);\n        }\n\n        @Override\n        public void set(Object instance, Object value) throws IOException {\n            delegate.set(instance, value);\n        }\n\n        @Override\n        public Object setAndReturn(Object instance, Object value) throws IOException {\n            return delegate.setAndReturn(instance, value);\n        }\n    }\n}\n",
      "buggy_signatures": [
        "protected SettableBeanProperty(PropertyName propName, JavaType type, PropertyName wrapper, TypeDeserializer typeDeser, Annotations contextAnnotations, PropertyMetadata metadata)",
        "protected SettableBeanProperty(PropertyName propName, JavaType type, PropertyMetadata metadata, JsonDeserializer<Object> valueDeser)",
        "protected SettableBeanProperty(SettableBeanProperty src)",
        "protected SettableBeanProperty(SettableBeanProperty src, JsonDeserializer<?> deser, NullValueProvider nuller)",
        "protected SettableBeanProperty(SettableBeanProperty src, PropertyName newName)",
        "public abstract SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser); public abstract SettableBeanProperty withName(PropertyName newName); public SettableBeanProperty withSimpleName(String simpleName)",
        "public abstract SettableBeanProperty withNullProvider(NullValueProvider nva); public void setManagedReferenceName(String n)",
        "public void setObjectIdInfo(ObjectIdInfo objectIdInfo)",
        "public void setViews(Class<?>[] views)",
        "public void assignIndex(int index)",
        "public void fixAccess(DeserializationConfig config)",
        "public void markAsIgnorable()",
        "public boolean isIgnorable()",
        "public final String getName()",
        "public PropertyName getFullName()",
        "public JavaType getType()",
        "public PropertyName getWrapperName()",
        "public abstract AnnotatedMember getMember(); @Override public abstract <A extends Annotation> A getAnnotation(Class<A> acls); @Override public <A extends Annotation> A getContextAnnotation(Class<A> acls)",
        "public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor, SerializerProvider provider) throws JsonMappingException",
        "protected Class<?> getDeclaringClass()",
        "public String getManagedReferenceName()",
        "public ObjectIdInfo getObjectIdInfo()",
        "public boolean hasValueDeserializer()",
        "public boolean hasValueTypeDeserializer()",
        "public JsonDeserializer<Object> getValueDeserializer()",
        "public TypeDeserializer getValueTypeDeserializer()",
        "public NullValueProvider getNullValueProvider()",
        "public boolean visibleInView(Class<?> activeView)",
        "public boolean hasViews()",
        "public int getPropertyIndex()",
        "public int getCreatorIndex()",
        "public Object getInjectableValueId()",
        "public abstract void deserializeAndSet(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException; public abstract Object deserializeSetAndReturn(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException; public abstract void set(Object instance, Object value) throws IOException; public abstract Object setAndReturn(Object instance, Object value) throws IOException; public final Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public final Object deserializeWith(JsonParser p, DeserializationContext ctxt, Object toUpdate) throws IOException",
        "protected void _throwAsIOE(JsonParser p, Exception e, Object value) throws IOException",
        "protected IOException _throwAsIOE(JsonParser p, Exception e) throws IOException",
        "protected IOException _throwAsIOE(Exception e) throws IOException",
        "protected void _throwAsIOE(Exception e, Object value) throws IOException",
        "public String toString()",
        "public static abstract class Delegating extends SettableBeanProperty { protected final SettableBeanProperty delegate; protected Delegating(SettableBeanProperty d)",
        "protected abstract SettableBeanProperty withDelegate(SettableBeanProperty d); protected SettableBeanProperty _with(SettableBeanProperty newDelegate)",
        "public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser)",
        "public SettableBeanProperty withName(PropertyName newName)",
        "public SettableBeanProperty withNullProvider(NullValueProvider nva)",
        "public void assignIndex(int index)",
        "public void fixAccess(DeserializationConfig config)",
        "protected Class<?> getDeclaringClass()",
        "public String getManagedReferenceName()",
        "public ObjectIdInfo getObjectIdInfo()",
        "public boolean hasValueDeserializer()",
        "public boolean hasValueTypeDeserializer()",
        "public JsonDeserializer<Object> getValueDeserializer()",
        "public TypeDeserializer getValueTypeDeserializer()",
        "public boolean visibleInView(Class<?> activeView)",
        "public boolean hasViews()",
        "public int getPropertyIndex()",
        "public int getCreatorIndex()",
        "public Object getInjectableValueId()",
        "public AnnotatedMember getMember()",
        "public <A extends Annotation> A getAnnotation(Class<A> acls)",
        "public SettableBeanProperty getDelegate()",
        "public void deserializeAndSet(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException",
        "public Object deserializeSetAndReturn(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException",
        "public void set(Object instance, Object value) throws IOException",
        "public Object setAndReturn(Object instance, Object value) throws IOException"
      ],
      "fixed_signatures": [
        "protected SettableBeanProperty(PropertyName propName, JavaType type, PropertyName wrapper, TypeDeserializer typeDeser, Annotations contextAnnotations, PropertyMetadata metadata)",
        "protected SettableBeanProperty(PropertyName propName, JavaType type, PropertyMetadata metadata, JsonDeserializer<Object> valueDeser)",
        "protected SettableBeanProperty(SettableBeanProperty src)",
        "protected SettableBeanProperty(SettableBeanProperty src, JsonDeserializer<?> deser, NullValueProvider nuller)",
        "protected SettableBeanProperty(SettableBeanProperty src, PropertyName newName)",
        "public abstract SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser); public abstract SettableBeanProperty withName(PropertyName newName); public SettableBeanProperty withSimpleName(String simpleName)",
        "public abstract SettableBeanProperty withNullProvider(NullValueProvider nva); public void setManagedReferenceName(String n)",
        "public void setObjectIdInfo(ObjectIdInfo objectIdInfo)",
        "public void setViews(Class<?>[] views)",
        "public void assignIndex(int index)",
        "public void fixAccess(DeserializationConfig config)",
        "public void markAsIgnorable()",
        "public boolean isIgnorable()",
        "public final String getName()",
        "public PropertyName getFullName()",
        "public JavaType getType()",
        "public PropertyName getWrapperName()",
        "public abstract AnnotatedMember getMember(); @Override public abstract <A extends Annotation> A getAnnotation(Class<A> acls); @Override public <A extends Annotation> A getContextAnnotation(Class<A> acls)",
        "public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor, SerializerProvider provider) throws JsonMappingException",
        "protected Class<?> getDeclaringClass()",
        "public String getManagedReferenceName()",
        "public ObjectIdInfo getObjectIdInfo()",
        "public boolean hasValueDeserializer()",
        "public boolean hasValueTypeDeserializer()",
        "public JsonDeserializer<Object> getValueDeserializer()",
        "public TypeDeserializer getValueTypeDeserializer()",
        "public NullValueProvider getNullValueProvider()",
        "public boolean visibleInView(Class<?> activeView)",
        "public boolean hasViews()",
        "public int getPropertyIndex()",
        "public int getCreatorIndex()",
        "public Object getInjectableValueId()",
        "public abstract void deserializeAndSet(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException; public abstract Object deserializeSetAndReturn(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException; public abstract void set(Object instance, Object value) throws IOException; public abstract Object setAndReturn(Object instance, Object value) throws IOException; public final Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public final Object deserializeWith(JsonParser p, DeserializationContext ctxt, Object toUpdate) throws IOException",
        "protected void _throwAsIOE(JsonParser p, Exception e, Object value) throws IOException",
        "protected IOException _throwAsIOE(JsonParser p, Exception e) throws IOException",
        "protected IOException _throwAsIOE(Exception e) throws IOException",
        "protected void _throwAsIOE(Exception e, Object value) throws IOException",
        "public String toString()",
        "public static abstract class Delegating extends SettableBeanProperty { protected final SettableBeanProperty delegate; protected Delegating(SettableBeanProperty d)",
        "protected abstract SettableBeanProperty withDelegate(SettableBeanProperty d); protected SettableBeanProperty _with(SettableBeanProperty newDelegate)",
        "public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser)",
        "public SettableBeanProperty withName(PropertyName newName)",
        "public SettableBeanProperty withNullProvider(NullValueProvider nva)",
        "public void assignIndex(int index)",
        "public void fixAccess(DeserializationConfig config)",
        "protected Class<?> getDeclaringClass()",
        "public String getManagedReferenceName()",
        "public ObjectIdInfo getObjectIdInfo()",
        "public boolean hasValueDeserializer()",
        "public boolean hasValueTypeDeserializer()",
        "public JsonDeserializer<Object> getValueDeserializer()",
        "public TypeDeserializer getValueTypeDeserializer()",
        "public boolean visibleInView(Class<?> activeView)",
        "public boolean hasViews()",
        "public int getPropertyIndex()",
        "public int getCreatorIndex()",
        "public Object getInjectableValueId()",
        "public AnnotatedMember getMember()",
        "public <A extends Annotation> A getAnnotation(Class<A> acls)",
        "public SettableBeanProperty getDelegate()",
        "public void deserializeAndSet(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException",
        "public Object deserializeSetAndReturn(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException",
        "public void set(Object instance, Object value) throws IOException",
        "public Object setAndReturn(Object instance, Object value) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  protected void _throwAsIOE(JsonParser p, Exception e, Object value) throws IOException {\n  if (e instanceof IllegalArgumentException) {\n  String actType = ClassUtil.classNameOf(value);\n  StringBuilder msg = new StringBuilder(\"Problem deserializing property '\")\n  .append(getName())\n  .append(\"' (expected type: \")\n  .append(getType())\n  .append(\"; actual type: \")\n  .append(actType).append(\")\");\n  String origMsg = e.getMessage();\n  if (origMsg != null) {\n  msg.append(\", problem: \")\n  .append(origMsg);\n  } else {\n  msg.append(\" (no error message provided)\");\n  }\n  throw JsonMappingException.from(p, msg.toString(), e);\n  }\n  _throwAsIOE(p, e);\n  }",
          "fixed_method": "  protected void _throwAsIOE(JsonParser p, Exception e, Object value) throws IOException {\n  if (e instanceof IllegalArgumentException) {\n  String actType = ClassUtil.classNameOf(value);\n  StringBuilder msg = new StringBuilder(\"Problem deserializing property '\")\n  .append(getName())\n  .append(\"' (expected type: \")\n  .append(getType())\n  .append(\"; actual type: \")\n  .append(actType).append(\")\");\n  String origMsg = ClassUtil.exceptionMessage(e);\n  if (origMsg != null) {\n  msg.append(\", problem: \")\n  .append(origMsg);\n  } else {\n  msg.append(\" (no error message provided)\");\n  }\n  throw JsonMappingException.from(p, msg.toString(), e);\n  }\n  _throwAsIOE(p, e);\n  }",
          "diff": [
            "@@ -587,7 +587,7 @@",
            "                     .append(getType())\n",
            "                     .append(\"; actual type: \")\n",
            "                     .append(actType).append(\")\");\n",
            "-            String origMsg = e.getMessage();\n",
            "+            String origMsg = ClassUtil.exceptionMessage(e);\n",
            "             if (origMsg != null) {\n",
            "                 msg.append(\", problem: \")\n",
            "                     .append(origMsg);\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  protected IOException _throwAsIOE(JsonParser p, Exception e) throws IOException {\n  ClassUtil.throwIfIOE(e);\n  ClassUtil.throwIfRTE(e);\n  \n  Throwable th = ClassUtil.getRootCause(e);\n  throw JsonMappingException.from(p, th.getMessage(), th);\n  }",
          "fixed_method": "  protected IOException _throwAsIOE(JsonParser p, Exception e) throws IOException {\n  ClassUtil.throwIfIOE(e);\n  ClassUtil.throwIfRTE(e);\n  \n  Throwable th = ClassUtil.getRootCause(e);\n  throw JsonMappingException.from(p, ClassUtil.exceptionMessage(th), th);\n  }",
          "diff": [
            "@@ -608,7 +608,7 @@",
            "         ClassUtil.throwIfRTE(e);\n",
            "         // let's wrap the innermost problem\n",
            "         Throwable th = ClassUtil.getRootCause(e);\n",
            "-        throw JsonMappingException.from(p, th.getMessage(), th);\n",
            "+        throw JsonMappingException.from(p, ClassUtil.exceptionMessage(th), th);\n",
            "     }\n",
            " \n",
            "     @Deprecated // since 2.7\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/deser/std/StdDeserializer.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.Nulls;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.NumberInput;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.deser.BeanDeserializerBase;\nimport com.fasterxml.jackson.databind.deser.NullValueProvider;\nimport com.fasterxml.jackson.databind.deser.SettableBeanProperty;\nimport com.fasterxml.jackson.databind.deser.ValueInstantiator;\nimport com.fasterxml.jackson.databind.deser.impl.NullsAsEmptyProvider;\nimport com.fasterxml.jackson.databind.deser.impl.NullsConstantProvider;\nimport com.fasterxml.jackson.databind.deser.impl.NullsFailProvider;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMember;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.util.AccessPattern;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.Converter;\n\n\npublic abstract class StdDeserializer<T> extends JsonDeserializer<T> implements java.io.Serializable { private static final long serialVersionUID = 1L; protected final static int F_MASK_INT_COERCIONS = DeserializationFeature.USE_BIG_INTEGER_FOR_INTS.getMask() | DeserializationFeature.USE_LONG_FOR_INTS.getMask(); protected final static int F_MASK_ACCEPT_ARRAYS = DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS.getMask() | DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT.getMask(); final protected Class<?> _valueClass; protected StdDeserializer(Class<?> vc) {\n        _valueClass = vc;\n    }\n\n    protected StdDeserializer(JavaType valueType) {\n        \n        _valueClass = (valueType == null) ? Object.class : valueType.getRawClass();\n    }\n\n    \n    protected StdDeserializer(StdDeserializer<?> src) {\n        _valueClass = src._valueClass;\n    }\n\n    \n    \n    @Override\n    public Class<?> handledType() { return _valueClass; }\n    \n    \n\n    \n    @Deprecated\n    public final Class<?> getValueClass() { return _valueClass; }\n\n    \n    public JavaType getValueType() { return null; }\n\n    \n    protected boolean isDefaultDeserializer(JsonDeserializer<?> deserializer) {\n        return ClassUtil.isJacksonStdImpl(deserializer);\n    }\n\n    protected boolean isDefaultKeyDeserializer(KeyDeserializer keyDeser) {\n        return ClassUtil.isJacksonStdImpl(keyDeser);\n    }\n    \n    \n    \n    \n    @Override\n    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n        return typeDeserializer.deserializeTypedFromAny(p, ctxt);\n    }\n\n    \n\n    protected final boolean _parseBooleanPrimitive(JsonParser p, DeserializationContext ctxt) throws IOException {\n        JsonToken t = p.getCurrentToken();\n        if (t == JsonToken.VALUE_TRUE) return true;\n        if (t == JsonToken.VALUE_FALSE) return false;\n        if (t == JsonToken.VALUE_NULL) {\n            _verifyNullForPrimitive(ctxt);\n            return false;\n        }\n\n        \n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return _parseBooleanFromInt(p, ctxt);\n        }\n        \n        if (t == JsonToken.VALUE_STRING) {\n            String text = p.getText().trim();\n            \n            if (\"true\".equals(text) || \"True\".equals(text)) {\n                return true;\n            }\n            if (\"false\".equals(text) || \"False\".equals(text)) {\n                return false;\n            }\n            if (_isEmptyOrTextualNull(text)) {\n                _verifyNullForPrimitiveCoercion(ctxt, text);\n                return false;\n            }\n            Boolean b = (Boolean) ctxt.handleWeirdStringValue(_valueClass, text,\n                    \"only \\\"true\\\" or \\\"false\\\" recognized\");\n            return Boolean.TRUE.equals(b);\n        }\n        \n        if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n            p.nextToken();\n            final boolean parsed = _parseBooleanPrimitive(p, ctxt);\n            _verifyEndArrayForSingle(p, ctxt);\n            return parsed;            \n        }\n        \n        return ((Boolean) ctxt.handleUnexpectedToken(_valueClass, p)).booleanValue();\n    }\n\n    protected boolean _parseBooleanFromInt(JsonParser p, DeserializationContext ctxt) throws IOException {\n        \n        \n        \n        \n        _verifyNumberForScalarCoercion(ctxt, p);\n        \n        \n        return !\"0\".equals(p.getText());\n    }\n\n    protected final byte _parseBytePrimitive(JsonParser p, DeserializationContext ctxt) throws IOException {\n        int value = _parseIntPrimitive(p, ctxt);\n        \n        if (_byteOverflow(value)) {\n            Number v = (Number) ctxt.handleWeirdStringValue(_valueClass, String.valueOf(value),\n                    \"overflow, value cannot be represented as 8-bit value\");\n            return _nonNullNumber(v).byteValue();\n        }\n        return (byte) value;\n    }\n\n    protected final short _parseShortPrimitive(JsonParser p, DeserializationContext ctxt) throws IOException {\n        int value = _parseIntPrimitive(p, ctxt);\n        \n        if (_shortOverflow(value)) {\n            Number v = (Number) ctxt.handleWeirdStringValue(_valueClass, String.valueOf(value),\n                    \"overflow, value cannot be represented as 16-bit value\");\n            return _nonNullNumber(v).shortValue();\n        }\n        return (short) value;\n    }\n\n    protected final int _parseIntPrimitive(JsonParser p, DeserializationContext ctxt) throws IOException {\n        if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {\n            return p.getIntValue();\n        }\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_STRING:\n            String text = p.getText().trim();\n            if (_isEmptyOrTextualNull(text)) {\n                _verifyNullForPrimitiveCoercion(ctxt, text);\n                return 0;\n            }\n            return _parseIntPrimitive(ctxt, text);\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {\n                _failDoubleToIntCoercion(p, ctxt, \"int\");\n            }\n            return p.getValueAsInt();\n        case JsonTokenId.ID_NULL:\n            _verifyNullForPrimitive(ctxt);\n            return 0;\n        case JsonTokenId.ID_START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                p.nextToken();\n                final int parsed = _parseIntPrimitive(p, ctxt);\n                _verifyEndArrayForSingle(p, ctxt);\n                return parsed;            \n            }\n            break;\n        default:\n        }\n        \n        return ((Number) ctxt.handleUnexpectedToken(_valueClass, p)).intValue();\n    }\n\n    \n    protected final int _parseIntPrimitive(DeserializationContext ctxt, String text) throws IOException {\n        try {\n            if (text.length() > 9) {\n                long l = Long.parseLong(text);\n                if (_intOverflow(l)) {\n                    Number v = (Number) ctxt.handleWeirdStringValue(_valueClass, text,\n                        \"Overflow: numeric value (%s) out of range of int (%d -%d)\",\n                        text, Integer.MIN_VALUE, Integer.MAX_VALUE);\n                    return _nonNullNumber(v).intValue();\n                }\n                return (int) l;\n            }\n            return NumberInput.parseInt(text);\n        } catch (IllegalArgumentException iae) {\n            Number v = (Number) ctxt.handleWeirdStringValue(_valueClass, text,\n                    \"not a valid int value\");\n            return _nonNullNumber(v).intValue();\n        }\n    }\n    \n    protected final long _parseLongPrimitive(JsonParser p, DeserializationContext ctxt) throws IOException {\n        if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {\n            return p.getLongValue();\n        }\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_STRING:\n            String text = p.getText().trim();\n            if (_isEmptyOrTextualNull(text)) {\n                _verifyNullForPrimitiveCoercion(ctxt, text);\n                return 0L;\n            }\n            return _parseLongPrimitive(ctxt, text);\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {\n                _failDoubleToIntCoercion(p, ctxt, \"long\");\n            }\n            return p.getValueAsLong();\n        case JsonTokenId.ID_NULL:\n            _verifyNullForPrimitive(ctxt);\n            return 0L;\n        case JsonTokenId.ID_START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                p.nextToken();\n                final long parsed = _parseLongPrimitive(p, ctxt);\n                _verifyEndArrayForSingle(p, ctxt);\n                return parsed;\n            }\n            break;\n        }\n        return ((Number) ctxt.handleUnexpectedToken(_valueClass, p)).longValue();\n    }\n\n    \n    protected final long _parseLongPrimitive(DeserializationContext ctxt, String text) throws IOException {\n        try {\n            return NumberInput.parseLong(text);\n        } catch (IllegalArgumentException iae) { }\n        {\n            Number v = (Number) ctxt.handleWeirdStringValue(_valueClass, text,\n                    \"not a valid long value\");\n            return _nonNullNumber(v).longValue();\n        }\n    }\n\n    protected final float _parseFloatPrimitive(JsonParser p, DeserializationContext ctxt) throws IOException {\n        if (p.hasToken(JsonToken.VALUE_NUMBER_FLOAT)) {\n            return p.getFloatValue();\n        }\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_STRING:\n            String text = p.getText().trim();\n            if (_isEmptyOrTextualNull(text)) {\n                _verifyNullForPrimitiveCoercion(ctxt, text);\n                return 0.0f;\n            }\n            return _parseFloatPrimitive(ctxt, text);\n        case JsonTokenId.ID_NUMBER_INT:\n            return p.getFloatValue();\n        case JsonTokenId.ID_NULL:\n            _verifyNullForPrimitive(ctxt);\n            return 0.0f;\n        case JsonTokenId.ID_START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                p.nextToken();\n                final float parsed = _parseFloatPrimitive(p, ctxt);\n                _verifyEndArrayForSingle(p, ctxt);\n                return parsed;            \n            }\n            break;\n        }\n        \n        return ((Number) ctxt.handleUnexpectedToken(_valueClass, p)).floatValue();\n    }\n\n    \n    protected final float _parseFloatPrimitive(DeserializationContext ctxt, String text) throws IOException {\n        switch (text.charAt(0)) {\n        case 'I':\n            if (_isPosInf(text)) {\n                return Float.POSITIVE_INFINITY;\n            }\n            break;\n        case 'N':\n            if (_isNaN(text)) { return Float.NaN; }\n            break;\n        case '-':\n            if (_isNegInf(text)) {\n                return Float.NEGATIVE_INFINITY;\n            }\n            break;\n        }\n        try {\n            return Float.parseFloat(text);\n        } catch (IllegalArgumentException iae) { }\n        Number v = (Number) ctxt.handleWeirdStringValue(_valueClass, text,\n                \"not a valid float value\");\n        return _nonNullNumber(v).floatValue();\n    }\n\n    protected final double _parseDoublePrimitive(JsonParser p, DeserializationContext ctxt) throws IOException {\n        if (p.hasToken(JsonToken.VALUE_NUMBER_FLOAT)) {\n            return p.getDoubleValue();\n        }\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_STRING:\n            String text = p.getText().trim();\n            if (_isEmptyOrTextualNull(text)) {\n                _verifyNullForPrimitiveCoercion(ctxt, text);\n                return 0.0;\n            }\n            return _parseDoublePrimitive(ctxt, text);\n        case JsonTokenId.ID_NUMBER_INT:\n            return p.getDoubleValue();\n        case JsonTokenId.ID_NULL:\n            _verifyNullForPrimitive(ctxt);\n            return 0.0;\n        case JsonTokenId.ID_START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                p.nextToken();\n                final double parsed = _parseDoublePrimitive(p, ctxt);\n                _verifyEndArrayForSingle(p, ctxt);\n                return parsed;            \n            }\n            break;\n        }\n        \n        return ((Number) ctxt.handleUnexpectedToken(_valueClass, p)).doubleValue();\n    }\n\n    \n    protected final double _parseDoublePrimitive(DeserializationContext ctxt, String text) throws IOException {\n        switch (text.charAt(0)) {\n        case 'I':\n            if (_isPosInf(text)) {\n                return Double.POSITIVE_INFINITY;\n            }\n            break;\n        case 'N':\n            if (_isNaN(text)) {\n                return Double.NaN;\n            }\n            break;\n        case '-':\n            if (_isNegInf(text)) {\n                return Double.NEGATIVE_INFINITY;\n            }\n            break;\n        }\n        try {\n            return parseDouble(text);\n        } catch (IllegalArgumentException iae) { }\n        Number v = (Number) ctxt.handleWeirdStringValue(_valueClass, text, \n                \"not a valid double value (as String to convert)\");\n        return _nonNullNumber(v).doubleValue();\n    }\n\n    protected java.util.Date _parseDate(JsonParser p, DeserializationContext ctxt) throws IOException {\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_STRING:\n            return _parseDate(p.getText().trim(), ctxt);\n        case JsonTokenId.ID_NUMBER_INT:\n            {\n                long ts;\n                try {\n                    ts = p.getLongValue();\n                } catch (JsonParseException e) {\n                    Number v = (Number) ctxt.handleWeirdNumberValue(_valueClass, p.getNumberValue(),\n                            \"not a valid 64-bit long for creating `java.util.Date`\");\n                    ts = v.longValue();\n                }\n                return new java.util.Date(ts);\n            }\n        case JsonTokenId.ID_NULL:\n            return (java.util.Date) getNullValue(ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            return _parseDateFromArray(p, ctxt);\n        }\n        return (java.util.Date) ctxt.handleUnexpectedToken(_valueClass, p);\n    }\n\n    \n    protected java.util.Date _parseDateFromArray(JsonParser p, DeserializationContext ctxt) throws IOException {\n        JsonToken t;\n        if (ctxt.hasSomeOfFeatures(F_MASK_ACCEPT_ARRAYS)) {\n            t = p.nextToken();\n            if (t == JsonToken.END_ARRAY) {\n                if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {\n                    return (java.util.Date) getNullValue(ctxt);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                final Date parsed = _parseDate(p, ctxt);\n                _verifyEndArrayForSingle(p, ctxt);\n                return parsed;            \n            }\n        } else {\n            t = p.getCurrentToken();\n        }\n        return (java.util.Date) ctxt.handleUnexpectedToken(_valueClass, t, p, null);\n    }\n\n    \n    protected java.util.Date _parseDate(String value, DeserializationContext ctxt) throws IOException {\n        try {\n            \n            if (_isEmptyOrTextualNull(value)) {\n                return (java.util.Date) getNullValue(ctxt);\n            }\n            return ctxt.parseDate(value);\n        } catch (IllegalArgumentException iae) {\n            return (java.util.Date) ctxt.handleWeirdStringValue(_valueClass, value,\n                    \"not a valid representation (error: %s)\",\n                    iae.getMessage());\n        }\n    }\n\n    \n    protected final static double parseDouble(String numStr) throws NumberFormatException {\n        \n        if (NumberInput.NASTY_SMALL_DOUBLE.equals(numStr)) {\n            return Double.MIN_NORMAL; \n        }\n        return Double.parseDouble(numStr);\n    }\n    \n    \n    protected final String _parseString(JsonParser p, DeserializationContext ctxt) throws IOException {\n        JsonToken t = p.getCurrentToken();\n        if (t == JsonToken.VALUE_STRING) {\n            return p.getText();\n        }\n        \n        \n        \n        String value = p.getValueAsString();\n        if (value != null) {\n            return value;\n        }\n        return (String) ctxt.handleUnexpectedToken(String.class, p);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    protected T _deserializeFromEmpty(JsonParser p, DeserializationContext ctxt) throws IOException {\n        JsonToken t = p.getCurrentToken();\n        if (t == JsonToken.START_ARRAY) {\n            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {\n                t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    return null;\n                }\n                return (T) ctxt.handleUnexpectedToken(handledType(), p);\n            }\n        } else if (t == JsonToken.VALUE_STRING) {\n            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n                String str = p.getText().trim();\n                if (str.isEmpty()) {\n                    return null;\n                }\n            }\n        }\n        return (T) ctxt.handleUnexpectedToken(handledType(), p);\n    }\n\n    \n    protected boolean _hasTextualNull(String value) {\n        return \"null\".equals(value);\n    }\n\n    \n    protected boolean _isEmptyOrTextualNull(String value) {\n        return value.isEmpty() || \"null\".equals(value);\n    }\n    \n    protected final boolean _isNegInf(String text) {\n        return \"-Infinity\".equals(text) || \"-INF\".equals(text);\n    }\n\n    protected final boolean _isPosInf(String text) {\n        return \"Infinity\".equals(text) || \"INF\".equals(text);\n    }\n\n    protected final boolean _isNaN(String text) { return \"NaN\".equals(text); }\n\n    \n\n    \n    protected T _deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException {\n        JsonToken t;\n        if (ctxt.hasSomeOfFeatures(F_MASK_ACCEPT_ARRAYS)) {\n            t = p.nextToken();\n            if (t == JsonToken.END_ARRAY) {\n                if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {\n                    return getNullValue(ctxt);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                final T parsed = deserialize(p, ctxt);\n                if (p.nextToken() != JsonToken.END_ARRAY) {\n                    handleMissingEndArrayForSingle(p, ctxt);\n                }\n                return parsed;            \n            }\n        } else {\n            t = p.getCurrentToken();\n        }\n        @SuppressWarnings(\"unchecked\")\n        T result = (T) ctxt.handleUnexpectedToken(_valueClass, t, p, null);\n        return result;\n    }\n\n    \n    protected T _deserializeWrappedValue(JsonParser p, DeserializationContext ctxt) throws IOException {\n        \n        \n        if (p.hasToken(JsonToken.START_ARRAY)) {\n            String msg = String.format(\n\"Cannot deserialize instance of %s out of %s token: nested Arrays not allowed with %s\",\n                    ClassUtil.nameOf(_valueClass), JsonToken.START_ARRAY,\n                    \"DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS\");\n            @SuppressWarnings(\"unchecked\")\n            T result = (T) ctxt.handleUnexpectedToken(_valueClass, p.getCurrentToken(), p, msg);\n            return result;\n        }\n        return (T) deserialize(p, ctxt);\n    }\n\n    \n\n    protected void _failDoubleToIntCoercion(JsonParser p, DeserializationContext ctxt, String type) throws IOException {\n        ctxt.reportInputMismatch(handledType(),\n\"Cannot coerce a floating-point value ('%s') into %s (enable `DeserializationFeature.ACCEPT_FLOAT_AS_INT` to allow)\",\n                p.getValueAsString(), type);\n    }\n\n    \n    protected Object _coerceIntegral(JsonParser p, DeserializationContext ctxt) throws IOException {\n        int feats = ctxt.getDeserializationFeatures();\n        if (DeserializationFeature.USE_BIG_INTEGER_FOR_INTS.enabledIn(feats)) {\n            return p.getBigIntegerValue();\n        }\n        if (DeserializationFeature.USE_LONG_FOR_INTS.enabledIn(feats)) {\n            return p.getLongValue();\n        }\n        return p.getBigIntegerValue(); \n    }\n\n    \n    protected Object _coerceNullToken(DeserializationContext ctxt, boolean isPrimitive) throws JsonMappingException {\n        if (isPrimitive) {\n            _verifyNullForPrimitive(ctxt);\n        }\n        return getNullValue(ctxt);\n    }\n\n    \n    protected Object _coerceTextualNull(DeserializationContext ctxt, boolean isPrimitive) throws JsonMappingException {\n        Enum<?> feat;\n        boolean enable;\n\n        if (!ctxt.isEnabled(MapperFeature.ALLOW_COERCION_OF_SCALARS)) {\n            feat = MapperFeature.ALLOW_COERCION_OF_SCALARS;\n            enable = true;\n        } else if (isPrimitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n            feat = DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES;\n            enable = false;\n        } else {\n            return getNullValue(ctxt);\n        }\n        _reportFailedNullCoerce(ctxt, enable, feat, \"String \\\"null\\\"\");\n        return null;\n    }\n\n    \n    protected Object _coerceEmptyString(DeserializationContext ctxt, boolean isPrimitive) throws JsonMappingException {\n        Enum<?> feat;\n        boolean enable;\n\n        if (!ctxt.isEnabled(MapperFeature.ALLOW_COERCION_OF_SCALARS)) {\n            feat = MapperFeature.ALLOW_COERCION_OF_SCALARS;\n            enable = true;\n        } else if (isPrimitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n            feat = DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES;\n            enable = false;\n        } else {\n            return getNullValue(ctxt);\n        }\n        _reportFailedNullCoerce(ctxt, enable, feat, \"empty String (\\\"\\\")\");\n        return null;\n    }\n\n    \n    protected final void _verifyNullForPrimitive(DeserializationContext ctxt) throws JsonMappingException {\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n            ctxt.reportInputMismatch(this,\n\"Cannot coerce `null` %s (disable `DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES` to allow)\",\n                    _coercedTypeDesc());\n        }\n    }\n\n    \n    \n    protected final void _verifyNullForPrimitiveCoercion(DeserializationContext ctxt, String str) throws JsonMappingException {\n        Enum<?> feat;\n        boolean enable;\n\n        if (!ctxt.isEnabled(MapperFeature.ALLOW_COERCION_OF_SCALARS)) {\n            feat = MapperFeature.ALLOW_COERCION_OF_SCALARS;\n            enable = true;\n        } else if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n            feat = DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES;\n            enable = false;\n        } else {\n            return;\n        }\n        String strDesc = str.isEmpty() ? \"empty String (\\\"\\\")\" : String.format(\"String \\\"%s\\\"\", str);\n        _reportFailedNullCoerce(ctxt, enable, feat, strDesc);\n    }\n\n    \n    \n    protected final void _verifyNullForScalarCoercion(DeserializationContext ctxt, String str) throws JsonMappingException {\n        if (!ctxt.isEnabled(MapperFeature.ALLOW_COERCION_OF_SCALARS)) {\n            String strDesc = str.isEmpty() ? \"empty String (\\\"\\\")\" : String.format(\"String \\\"%s\\\"\", str);\n            _reportFailedNullCoerce(ctxt, true, MapperFeature.ALLOW_COERCION_OF_SCALARS, strDesc);\n        }\n    }\n\n    \n    protected void _verifyStringForScalarCoercion(DeserializationContext ctxt, String str) throws JsonMappingException {\n        MapperFeature feat = MapperFeature.ALLOW_COERCION_OF_SCALARS;\n        if (!ctxt.isEnabled(feat)) {\n            ctxt.reportInputMismatch(this, \"Cannot coerce String \\\"%s\\\" %s (enable `%s.%s` to allow)\",\n                str, _coercedTypeDesc(), feat.getClass().getSimpleName(), feat.name());\n        }\n    }\n\n    \n    protected void _verifyNumberForScalarCoercion(DeserializationContext ctxt, JsonParser p) throws IOException {\n        MapperFeature feat = MapperFeature.ALLOW_COERCION_OF_SCALARS;\n        if (!ctxt.isEnabled(feat)) {\n            \n            \n            String valueDesc = p.getText();\n            ctxt.reportInputMismatch(this, \"Cannot coerce Number (%s) %s (enable `%s.%s` to allow)\",\n                valueDesc, _coercedTypeDesc(), feat.getClass().getSimpleName(), feat.name());\n        }\n    }\n    \n    protected void _reportFailedNullCoerce(DeserializationContext ctxt, boolean state, Enum<?> feature, String inputDesc) throws JsonMappingException {\n        String enableDesc = state ? \"enable\" : \"disable\";\n        ctxt.reportInputMismatch(this, \"Cannot coerce %s to Null value %s (%s `%s.%s` to allow)\",\n            inputDesc, _coercedTypeDesc(), enableDesc, feature.getClass().getSimpleName(), feature.name());\n    }\n    \n    \n    protected String _coercedTypeDesc() {\n        boolean structured;\n        String typeDesc;\n\n        JavaType t = getValueType();\n        if ((t != null) && !t.isPrimitive()) {\n            structured = (t.isContainerType() || t.isReferenceType());\n            \n            typeDesc = \"'\"+t.toString()+\"'\";\n        } else {\n            Class<?> cls = handledType();\n            structured = cls.isArray() || Collection.class.isAssignableFrom(cls)\n                || Map.class.isAssignableFrom(cls);\n            typeDesc = ClassUtil.nameOf(cls);\n        }\n        if (structured) {\n            return \"as content of type \"+typeDesc;\n        }\n        return \"for type \"+typeDesc;\n    }\n\n    \n\n    \n    protected JsonDeserializer<Object> findDeserializer(DeserializationContext ctxt, JavaType type, BeanProperty property) throws JsonMappingException {\n        return ctxt.findContextualValueDeserializer(type, property);\n    }\n\n    \n    protected final boolean _isIntNumber(String text) {\n        final int len = text.length();\n        if (len > 0) {\n            char c = text.charAt(0);\n            \n            int i = (c == '-' || c == '+') ? 1 : 0;\n            for (; i < len; ++i) {\n                int ch = text.charAt(i);\n                if (ch > '9' || ch < '0') {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    \n\n    \n    protected JsonDeserializer<?> findConvertingContentDeserializer(DeserializationContext ctxt, BeanProperty prop, JsonDeserializer<?> existingDeserializer) throws JsonMappingException {\n        final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (_neitherNull(intr, prop)) {\n            AnnotatedMember member = prop.getMember();\n            if (member != null) {\n                Object convDef = intr.findDeserializationContentConverter(member);\n                if (convDef != null) {\n                    Converter<Object,Object> conv = ctxt.converterInstance(prop.getMember(), convDef);\n                    JavaType delegateType = conv.getInputType(ctxt.getTypeFactory());\n                    if (existingDeserializer == null) {\n                        existingDeserializer = ctxt.findContextualValueDeserializer(delegateType, prop);\n                    }\n                    return new StdDelegatingDeserializer<Object>(conv, delegateType, existingDeserializer);\n                }\n            }\n        }\n        return existingDeserializer;\n    }\n\n    \n    \n    \n    protected JsonFormat.Value findFormatOverrides(DeserializationContext ctxt, BeanProperty prop, Class<?> typeForDefaults) {\n        if (prop != null) {\n            return prop.findPropertyFormat(ctxt.getConfig(), typeForDefaults);\n        }\n        \n        return ctxt.getDefaultPropertyFormat(typeForDefaults);\n    }\n\n    \n    protected Boolean findFormatFeature(DeserializationContext ctxt, BeanProperty prop, Class<?> typeForDefaults, JsonFormat.Feature feat) {\n        JsonFormat.Value format = findFormatOverrides(ctxt, prop, typeForDefaults);\n        if (format != null) {\n            return format.getFeature(feat);\n        }\n        return null;\n    }\n\n    \n    protected final NullValueProvider findValueNullProvider(DeserializationContext ctxt, SettableBeanProperty prop, PropertyMetadata propMetadata) throws JsonMappingException {\n        if (prop != null) {\n            return _findNullProvider(ctxt, prop, propMetadata.getValueNulls(),\n                    prop.getValueDeserializer());\n        }\n        return null;\n    }\n\n    \n    protected NullValueProvider findContentNullProvider(DeserializationContext ctxt, BeanProperty prop, JsonDeserializer<?> valueDeser) throws JsonMappingException {\n        final Nulls nulls = findContentNullStyle(ctxt, prop);\n        if (nulls == Nulls.SKIP) {\n            return NullsConstantProvider.skipper();\n        }\n        NullValueProvider prov = _findNullProvider(ctxt, prop, nulls, valueDeser);\n        if (prov != null) {\n            return prov;\n        }\n        return valueDeser;\n    }\n\n    protected Nulls findContentNullStyle(DeserializationContext ctxt, BeanProperty prop) throws JsonMappingException {\n        if (prop != null) {\n            return prop.getMetadata().getContentNulls();\n        }\n        return null;\n    }\n\n    \n    protected final NullValueProvider _findNullProvider(DeserializationContext ctxt, BeanProperty prop, Nulls nulls, JsonDeserializer<?> valueDeser) throws JsonMappingException {\n        if (nulls == Nulls.FAIL) {\n            if (prop == null) {\n                return NullsFailProvider.constructForRootValue(ctxt.constructType(valueDeser.handledType()));\n            }\n            return NullsFailProvider.constructForProperty(prop);\n        }\n        if (nulls == Nulls.AS_EMPTY) {\n            \n            \n            if (valueDeser == null) {\n                return null;\n            }\n\n            \n            \n            \n            if (valueDeser instanceof BeanDeserializerBase) {\n                ValueInstantiator vi = ((BeanDeserializerBase) valueDeser).getValueInstantiator();\n                if (!vi.canCreateUsingDefault()) {\n                    final JavaType type = prop.getType();\n                    ctxt.reportBadDefinition(type,\n                            String.format(\"Cannot create empty instance of %s, no default Creator\", type));\n                }\n            }\n            \n            {\n                AccessPattern access = valueDeser.getEmptyAccessPattern();\n                if (access == AccessPattern.ALWAYS_NULL) {\n                    return NullsConstantProvider.nuller();\n                }\n                if (access == AccessPattern.CONSTANT) {\n                    return NullsConstantProvider.forValue(valueDeser.getEmptyValue(ctxt));\n                }\n            }\n            return new NullsAsEmptyProvider(valueDeser);\n        }\n        if (nulls == Nulls.SKIP) {\n            return NullsConstantProvider.skipper();\n        }\n        return null;\n    }\n\n    \n\n    \n    protected void handleUnknownProperty(JsonParser p, DeserializationContext ctxt, Object instanceOrClass, String propName) throws IOException {\n        if (instanceOrClass == null) {\n            instanceOrClass = handledType();\n        }\n        \n        if (ctxt.handleUnknownProperty(p, this, instanceOrClass, propName)) {\n            return;\n        }\n        \n        p.skipChildren();\n    }\n\n    protected void handleMissingEndArrayForSingle(JsonParser p, DeserializationContext ctxt) throws IOException {\n        ctxt.reportWrongTokenException(this, JsonToken.END_ARRAY, \n\"Attempted to unwrap '%s' value from an array (with `DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS`) but it contains more than one value\",\nhandledType().getName());\n        \n        \n    }\n\n    protected void _verifyEndArrayForSingle(JsonParser p, DeserializationContext ctxt) throws IOException {\n        JsonToken t = p.nextToken();\n        if (t != JsonToken.END_ARRAY) {\n            handleMissingEndArrayForSingle(p, ctxt);\n        }            \n    }\n\n    \n\n    \n    protected final static boolean _neitherNull(Object a, Object b) {\n        return (a != null) && (b != null);\n    }\n\n    \n    protected final boolean _byteOverflow(int value) {\n        \n        \n        return (value < Byte.MIN_VALUE || value > 255);\n    }\n    \n    \n    protected final boolean _shortOverflow(int value) {\n        return (value < Short.MIN_VALUE || value > Short.MAX_VALUE);\n    }\n\n    \n    protected final boolean _intOverflow(long value) {\n        return (value < Integer.MIN_VALUE || value > Integer.MAX_VALUE);\n    }\n\n    \n    protected Number _nonNullNumber(Number n) {\n        if (n == null) {\n            n = Integer.valueOf(0);\n        }\n        return n;\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.Nulls;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.NumberInput;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.deser.BeanDeserializerBase;\nimport com.fasterxml.jackson.databind.deser.NullValueProvider;\nimport com.fasterxml.jackson.databind.deser.SettableBeanProperty;\nimport com.fasterxml.jackson.databind.deser.ValueInstantiator;\nimport com.fasterxml.jackson.databind.deser.impl.NullsAsEmptyProvider;\nimport com.fasterxml.jackson.databind.deser.impl.NullsConstantProvider;\nimport com.fasterxml.jackson.databind.deser.impl.NullsFailProvider;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMember;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.util.AccessPattern;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.Converter;\n\n\npublic abstract class StdDeserializer<T> extends JsonDeserializer<T> implements java.io.Serializable { private static final long serialVersionUID = 1L; protected final static int F_MASK_INT_COERCIONS = DeserializationFeature.USE_BIG_INTEGER_FOR_INTS.getMask() | DeserializationFeature.USE_LONG_FOR_INTS.getMask(); protected final static int F_MASK_ACCEPT_ARRAYS = DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS.getMask() | DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT.getMask(); final protected Class<?> _valueClass; protected StdDeserializer(Class<?> vc) {\n        _valueClass = vc;\n    }\n\n    protected StdDeserializer(JavaType valueType) {\n        \n        _valueClass = (valueType == null) ? Object.class : valueType.getRawClass();\n    }\n\n    \n    protected StdDeserializer(StdDeserializer<?> src) {\n        _valueClass = src._valueClass;\n    }\n\n    \n    \n    @Override\n    public Class<?> handledType() { return _valueClass; }\n    \n    \n\n    \n    @Deprecated\n    public final Class<?> getValueClass() { return _valueClass; }\n\n    \n    public JavaType getValueType() { return null; }\n\n    \n    protected boolean isDefaultDeserializer(JsonDeserializer<?> deserializer) {\n        return ClassUtil.isJacksonStdImpl(deserializer);\n    }\n\n    protected boolean isDefaultKeyDeserializer(KeyDeserializer keyDeser) {\n        return ClassUtil.isJacksonStdImpl(keyDeser);\n    }\n    \n    \n    \n    \n    @Override\n    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n        return typeDeserializer.deserializeTypedFromAny(p, ctxt);\n    }\n\n    \n\n    protected final boolean _parseBooleanPrimitive(JsonParser p, DeserializationContext ctxt) throws IOException {\n        JsonToken t = p.getCurrentToken();\n        if (t == JsonToken.VALUE_TRUE) return true;\n        if (t == JsonToken.VALUE_FALSE) return false;\n        if (t == JsonToken.VALUE_NULL) {\n            _verifyNullForPrimitive(ctxt);\n            return false;\n        }\n\n        \n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return _parseBooleanFromInt(p, ctxt);\n        }\n        \n        if (t == JsonToken.VALUE_STRING) {\n            String text = p.getText().trim();\n            \n            if (\"true\".equals(text) || \"True\".equals(text)) {\n                return true;\n            }\n            if (\"false\".equals(text) || \"False\".equals(text)) {\n                return false;\n            }\n            if (_isEmptyOrTextualNull(text)) {\n                _verifyNullForPrimitiveCoercion(ctxt, text);\n                return false;\n            }\n            Boolean b = (Boolean) ctxt.handleWeirdStringValue(_valueClass, text,\n                    \"only \\\"true\\\" or \\\"false\\\" recognized\");\n            return Boolean.TRUE.equals(b);\n        }\n        \n        if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n            p.nextToken();\n            final boolean parsed = _parseBooleanPrimitive(p, ctxt);\n            _verifyEndArrayForSingle(p, ctxt);\n            return parsed;            \n        }\n        \n        return ((Boolean) ctxt.handleUnexpectedToken(_valueClass, p)).booleanValue();\n    }\n\n    protected boolean _parseBooleanFromInt(JsonParser p, DeserializationContext ctxt) throws IOException {\n        \n        \n        \n        \n        _verifyNumberForScalarCoercion(ctxt, p);\n        \n        \n        return !\"0\".equals(p.getText());\n    }\n\n    protected final byte _parseBytePrimitive(JsonParser p, DeserializationContext ctxt) throws IOException {\n        int value = _parseIntPrimitive(p, ctxt);\n        \n        if (_byteOverflow(value)) {\n            Number v = (Number) ctxt.handleWeirdStringValue(_valueClass, String.valueOf(value),\n                    \"overflow, value cannot be represented as 8-bit value\");\n            return _nonNullNumber(v).byteValue();\n        }\n        return (byte) value;\n    }\n\n    protected final short _parseShortPrimitive(JsonParser p, DeserializationContext ctxt) throws IOException {\n        int value = _parseIntPrimitive(p, ctxt);\n        \n        if (_shortOverflow(value)) {\n            Number v = (Number) ctxt.handleWeirdStringValue(_valueClass, String.valueOf(value),\n                    \"overflow, value cannot be represented as 16-bit value\");\n            return _nonNullNumber(v).shortValue();\n        }\n        return (short) value;\n    }\n\n    protected final int _parseIntPrimitive(JsonParser p, DeserializationContext ctxt) throws IOException {\n        if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {\n            return p.getIntValue();\n        }\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_STRING:\n            String text = p.getText().trim();\n            if (_isEmptyOrTextualNull(text)) {\n                _verifyNullForPrimitiveCoercion(ctxt, text);\n                return 0;\n            }\n            return _parseIntPrimitive(ctxt, text);\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {\n                _failDoubleToIntCoercion(p, ctxt, \"int\");\n            }\n            return p.getValueAsInt();\n        case JsonTokenId.ID_NULL:\n            _verifyNullForPrimitive(ctxt);\n            return 0;\n        case JsonTokenId.ID_START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                p.nextToken();\n                final int parsed = _parseIntPrimitive(p, ctxt);\n                _verifyEndArrayForSingle(p, ctxt);\n                return parsed;            \n            }\n            break;\n        default:\n        }\n        \n        return ((Number) ctxt.handleUnexpectedToken(_valueClass, p)).intValue();\n    }\n\n    \n    protected final int _parseIntPrimitive(DeserializationContext ctxt, String text) throws IOException {\n        try {\n            if (text.length() > 9) {\n                long l = Long.parseLong(text);\n                if (_intOverflow(l)) {\n                    Number v = (Number) ctxt.handleWeirdStringValue(_valueClass, text,\n                        \"Overflow: numeric value (%s) out of range of int (%d -%d)\",\n                        text, Integer.MIN_VALUE, Integer.MAX_VALUE);\n                    return _nonNullNumber(v).intValue();\n                }\n                return (int) l;\n            }\n            return NumberInput.parseInt(text);\n        } catch (IllegalArgumentException iae) {\n            Number v = (Number) ctxt.handleWeirdStringValue(_valueClass, text,\n                    \"not a valid int value\");\n            return _nonNullNumber(v).intValue();\n        }\n    }\n    \n    protected final long _parseLongPrimitive(JsonParser p, DeserializationContext ctxt) throws IOException {\n        if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {\n            return p.getLongValue();\n        }\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_STRING:\n            String text = p.getText().trim();\n            if (_isEmptyOrTextualNull(text)) {\n                _verifyNullForPrimitiveCoercion(ctxt, text);\n                return 0L;\n            }\n            return _parseLongPrimitive(ctxt, text);\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {\n                _failDoubleToIntCoercion(p, ctxt, \"long\");\n            }\n            return p.getValueAsLong();\n        case JsonTokenId.ID_NULL:\n            _verifyNullForPrimitive(ctxt);\n            return 0L;\n        case JsonTokenId.ID_START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                p.nextToken();\n                final long parsed = _parseLongPrimitive(p, ctxt);\n                _verifyEndArrayForSingle(p, ctxt);\n                return parsed;\n            }\n            break;\n        }\n        return ((Number) ctxt.handleUnexpectedToken(_valueClass, p)).longValue();\n    }\n\n    \n    protected final long _parseLongPrimitive(DeserializationContext ctxt, String text) throws IOException {\n        try {\n            return NumberInput.parseLong(text);\n        } catch (IllegalArgumentException iae) { }\n        {\n            Number v = (Number) ctxt.handleWeirdStringValue(_valueClass, text,\n                    \"not a valid long value\");\n            return _nonNullNumber(v).longValue();\n        }\n    }\n\n    protected final float _parseFloatPrimitive(JsonParser p, DeserializationContext ctxt) throws IOException {\n        if (p.hasToken(JsonToken.VALUE_NUMBER_FLOAT)) {\n            return p.getFloatValue();\n        }\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_STRING:\n            String text = p.getText().trim();\n            if (_isEmptyOrTextualNull(text)) {\n                _verifyNullForPrimitiveCoercion(ctxt, text);\n                return 0.0f;\n            }\n            return _parseFloatPrimitive(ctxt, text);\n        case JsonTokenId.ID_NUMBER_INT:\n            return p.getFloatValue();\n        case JsonTokenId.ID_NULL:\n            _verifyNullForPrimitive(ctxt);\n            return 0.0f;\n        case JsonTokenId.ID_START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                p.nextToken();\n                final float parsed = _parseFloatPrimitive(p, ctxt);\n                _verifyEndArrayForSingle(p, ctxt);\n                return parsed;            \n            }\n            break;\n        }\n        \n        return ((Number) ctxt.handleUnexpectedToken(_valueClass, p)).floatValue();\n    }\n\n    \n    protected final float _parseFloatPrimitive(DeserializationContext ctxt, String text) throws IOException {\n        switch (text.charAt(0)) {\n        case 'I':\n            if (_isPosInf(text)) {\n                return Float.POSITIVE_INFINITY;\n            }\n            break;\n        case 'N':\n            if (_isNaN(text)) { return Float.NaN; }\n            break;\n        case '-':\n            if (_isNegInf(text)) {\n                return Float.NEGATIVE_INFINITY;\n            }\n            break;\n        }\n        try {\n            return Float.parseFloat(text);\n        } catch (IllegalArgumentException iae) { }\n        Number v = (Number) ctxt.handleWeirdStringValue(_valueClass, text,\n                \"not a valid float value\");\n        return _nonNullNumber(v).floatValue();\n    }\n\n    protected final double _parseDoublePrimitive(JsonParser p, DeserializationContext ctxt) throws IOException {\n        if (p.hasToken(JsonToken.VALUE_NUMBER_FLOAT)) {\n            return p.getDoubleValue();\n        }\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_STRING:\n            String text = p.getText().trim();\n            if (_isEmptyOrTextualNull(text)) {\n                _verifyNullForPrimitiveCoercion(ctxt, text);\n                return 0.0;\n            }\n            return _parseDoublePrimitive(ctxt, text);\n        case JsonTokenId.ID_NUMBER_INT:\n            return p.getDoubleValue();\n        case JsonTokenId.ID_NULL:\n            _verifyNullForPrimitive(ctxt);\n            return 0.0;\n        case JsonTokenId.ID_START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                p.nextToken();\n                final double parsed = _parseDoublePrimitive(p, ctxt);\n                _verifyEndArrayForSingle(p, ctxt);\n                return parsed;            \n            }\n            break;\n        }\n        \n        return ((Number) ctxt.handleUnexpectedToken(_valueClass, p)).doubleValue();\n    }\n\n    \n    protected final double _parseDoublePrimitive(DeserializationContext ctxt, String text) throws IOException {\n        switch (text.charAt(0)) {\n        case 'I':\n            if (_isPosInf(text)) {\n                return Double.POSITIVE_INFINITY;\n            }\n            break;\n        case 'N':\n            if (_isNaN(text)) {\n                return Double.NaN;\n            }\n            break;\n        case '-':\n            if (_isNegInf(text)) {\n                return Double.NEGATIVE_INFINITY;\n            }\n            break;\n        }\n        try {\n            return parseDouble(text);\n        } catch (IllegalArgumentException iae) { }\n        Number v = (Number) ctxt.handleWeirdStringValue(_valueClass, text, \n                \"not a valid double value (as String to convert)\");\n        return _nonNullNumber(v).doubleValue();\n    }\n\n    protected java.util.Date _parseDate(JsonParser p, DeserializationContext ctxt) throws IOException {\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_STRING:\n            return _parseDate(p.getText().trim(), ctxt);\n        case JsonTokenId.ID_NUMBER_INT:\n            {\n                long ts;\n                try {\n                    ts = p.getLongValue();\n                } catch (JsonParseException e) {\n                    Number v = (Number) ctxt.handleWeirdNumberValue(_valueClass, p.getNumberValue(),\n                            \"not a valid 64-bit long for creating `java.util.Date`\");\n                    ts = v.longValue();\n                }\n                return new java.util.Date(ts);\n            }\n        case JsonTokenId.ID_NULL:\n            return (java.util.Date) getNullValue(ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            return _parseDateFromArray(p, ctxt);\n        }\n        return (java.util.Date) ctxt.handleUnexpectedToken(_valueClass, p);\n    }\n\n    \n    protected java.util.Date _parseDateFromArray(JsonParser p, DeserializationContext ctxt) throws IOException {\n        JsonToken t;\n        if (ctxt.hasSomeOfFeatures(F_MASK_ACCEPT_ARRAYS)) {\n            t = p.nextToken();\n            if (t == JsonToken.END_ARRAY) {\n                if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {\n                    return (java.util.Date) getNullValue(ctxt);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                final Date parsed = _parseDate(p, ctxt);\n                _verifyEndArrayForSingle(p, ctxt);\n                return parsed;            \n            }\n        } else {\n            t = p.getCurrentToken();\n        }\n        return (java.util.Date) ctxt.handleUnexpectedToken(_valueClass, t, p, null);\n    }\n\n    \n    protected java.util.Date _parseDate(String value, DeserializationContext ctxt) throws IOException {\n        try {\n            \n            if (_isEmptyOrTextualNull(value)) {\n                return (java.util.Date) getNullValue(ctxt);\n            }\n            return ctxt.parseDate(value);\n        } catch (IllegalArgumentException iae) {\n            return (java.util.Date) ctxt.handleWeirdStringValue(_valueClass, value,\n                    \"not a valid representation (error: %s)\",\n                    ClassUtil.exceptionMessage(iae));\n        }\n    }\n\n    \n    protected final static double parseDouble(String numStr) throws NumberFormatException {\n        \n        if (NumberInput.NASTY_SMALL_DOUBLE.equals(numStr)) {\n            return Double.MIN_NORMAL; \n        }\n        return Double.parseDouble(numStr);\n    }\n    \n    \n    protected final String _parseString(JsonParser p, DeserializationContext ctxt) throws IOException {\n        JsonToken t = p.getCurrentToken();\n        if (t == JsonToken.VALUE_STRING) {\n            return p.getText();\n        }\n        \n        \n        \n        String value = p.getValueAsString();\n        if (value != null) {\n            return value;\n        }\n        return (String) ctxt.handleUnexpectedToken(String.class, p);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    protected T _deserializeFromEmpty(JsonParser p, DeserializationContext ctxt) throws IOException {\n        JsonToken t = p.getCurrentToken();\n        if (t == JsonToken.START_ARRAY) {\n            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {\n                t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    return null;\n                }\n                return (T) ctxt.handleUnexpectedToken(handledType(), p);\n            }\n        } else if (t == JsonToken.VALUE_STRING) {\n            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n                String str = p.getText().trim();\n                if (str.isEmpty()) {\n                    return null;\n                }\n            }\n        }\n        return (T) ctxt.handleUnexpectedToken(handledType(), p);\n    }\n\n    \n    protected boolean _hasTextualNull(String value) {\n        return \"null\".equals(value);\n    }\n\n    \n    protected boolean _isEmptyOrTextualNull(String value) {\n        return value.isEmpty() || \"null\".equals(value);\n    }\n    \n    protected final boolean _isNegInf(String text) {\n        return \"-Infinity\".equals(text) || \"-INF\".equals(text);\n    }\n\n    protected final boolean _isPosInf(String text) {\n        return \"Infinity\".equals(text) || \"INF\".equals(text);\n    }\n\n    protected final boolean _isNaN(String text) { return \"NaN\".equals(text); }\n\n    \n\n    \n    protected T _deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException {\n        JsonToken t;\n        if (ctxt.hasSomeOfFeatures(F_MASK_ACCEPT_ARRAYS)) {\n            t = p.nextToken();\n            if (t == JsonToken.END_ARRAY) {\n                if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {\n                    return getNullValue(ctxt);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                final T parsed = deserialize(p, ctxt);\n                if (p.nextToken() != JsonToken.END_ARRAY) {\n                    handleMissingEndArrayForSingle(p, ctxt);\n                }\n                return parsed;            \n            }\n        } else {\n            t = p.getCurrentToken();\n        }\n        @SuppressWarnings(\"unchecked\")\n        T result = (T) ctxt.handleUnexpectedToken(_valueClass, t, p, null);\n        return result;\n    }\n\n    \n    protected T _deserializeWrappedValue(JsonParser p, DeserializationContext ctxt) throws IOException {\n        \n        \n        if (p.hasToken(JsonToken.START_ARRAY)) {\n            String msg = String.format(\n\"Cannot deserialize instance of %s out of %s token: nested Arrays not allowed with %s\",\n                    ClassUtil.nameOf(_valueClass), JsonToken.START_ARRAY,\n                    \"DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS\");\n            @SuppressWarnings(\"unchecked\")\n            T result = (T) ctxt.handleUnexpectedToken(_valueClass, p.getCurrentToken(), p, msg);\n            return result;\n        }\n        return (T) deserialize(p, ctxt);\n    }\n\n    \n\n    protected void _failDoubleToIntCoercion(JsonParser p, DeserializationContext ctxt, String type) throws IOException {\n        ctxt.reportInputMismatch(handledType(),\n\"Cannot coerce a floating-point value ('%s') into %s (enable `DeserializationFeature.ACCEPT_FLOAT_AS_INT` to allow)\",\n                p.getValueAsString(), type);\n    }\n\n    \n    protected Object _coerceIntegral(JsonParser p, DeserializationContext ctxt) throws IOException {\n        int feats = ctxt.getDeserializationFeatures();\n        if (DeserializationFeature.USE_BIG_INTEGER_FOR_INTS.enabledIn(feats)) {\n            return p.getBigIntegerValue();\n        }\n        if (DeserializationFeature.USE_LONG_FOR_INTS.enabledIn(feats)) {\n            return p.getLongValue();\n        }\n        return p.getBigIntegerValue(); \n    }\n\n    \n    protected Object _coerceNullToken(DeserializationContext ctxt, boolean isPrimitive) throws JsonMappingException {\n        if (isPrimitive) {\n            _verifyNullForPrimitive(ctxt);\n        }\n        return getNullValue(ctxt);\n    }\n\n    \n    protected Object _coerceTextualNull(DeserializationContext ctxt, boolean isPrimitive) throws JsonMappingException {\n        Enum<?> feat;\n        boolean enable;\n\n        if (!ctxt.isEnabled(MapperFeature.ALLOW_COERCION_OF_SCALARS)) {\n            feat = MapperFeature.ALLOW_COERCION_OF_SCALARS;\n            enable = true;\n        } else if (isPrimitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n            feat = DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES;\n            enable = false;\n        } else {\n            return getNullValue(ctxt);\n        }\n        _reportFailedNullCoerce(ctxt, enable, feat, \"String \\\"null\\\"\");\n        return null;\n    }\n\n    \n    protected Object _coerceEmptyString(DeserializationContext ctxt, boolean isPrimitive) throws JsonMappingException {\n        Enum<?> feat;\n        boolean enable;\n\n        if (!ctxt.isEnabled(MapperFeature.ALLOW_COERCION_OF_SCALARS)) {\n            feat = MapperFeature.ALLOW_COERCION_OF_SCALARS;\n            enable = true;\n        } else if (isPrimitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n            feat = DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES;\n            enable = false;\n        } else {\n            return getNullValue(ctxt);\n        }\n        _reportFailedNullCoerce(ctxt, enable, feat, \"empty String (\\\"\\\")\");\n        return null;\n    }\n\n    \n    protected final void _verifyNullForPrimitive(DeserializationContext ctxt) throws JsonMappingException {\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n            ctxt.reportInputMismatch(this,\n\"Cannot coerce `null` %s (disable `DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES` to allow)\",\n                    _coercedTypeDesc());\n        }\n    }\n\n    \n    \n    protected final void _verifyNullForPrimitiveCoercion(DeserializationContext ctxt, String str) throws JsonMappingException {\n        Enum<?> feat;\n        boolean enable;\n\n        if (!ctxt.isEnabled(MapperFeature.ALLOW_COERCION_OF_SCALARS)) {\n            feat = MapperFeature.ALLOW_COERCION_OF_SCALARS;\n            enable = true;\n        } else if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n            feat = DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES;\n            enable = false;\n        } else {\n            return;\n        }\n        String strDesc = str.isEmpty() ? \"empty String (\\\"\\\")\" : String.format(\"String \\\"%s\\\"\", str);\n        _reportFailedNullCoerce(ctxt, enable, feat, strDesc);\n    }\n\n    \n    \n    protected final void _verifyNullForScalarCoercion(DeserializationContext ctxt, String str) throws JsonMappingException {\n        if (!ctxt.isEnabled(MapperFeature.ALLOW_COERCION_OF_SCALARS)) {\n            String strDesc = str.isEmpty() ? \"empty String (\\\"\\\")\" : String.format(\"String \\\"%s\\\"\", str);\n            _reportFailedNullCoerce(ctxt, true, MapperFeature.ALLOW_COERCION_OF_SCALARS, strDesc);\n        }\n    }\n\n    \n    protected void _verifyStringForScalarCoercion(DeserializationContext ctxt, String str) throws JsonMappingException {\n        MapperFeature feat = MapperFeature.ALLOW_COERCION_OF_SCALARS;\n        if (!ctxt.isEnabled(feat)) {\n            ctxt.reportInputMismatch(this, \"Cannot coerce String \\\"%s\\\" %s (enable `%s.%s` to allow)\",\n                str, _coercedTypeDesc(), feat.getClass().getSimpleName(), feat.name());\n        }\n    }\n\n    \n    protected void _verifyNumberForScalarCoercion(DeserializationContext ctxt, JsonParser p) throws IOException {\n        MapperFeature feat = MapperFeature.ALLOW_COERCION_OF_SCALARS;\n        if (!ctxt.isEnabled(feat)) {\n            \n            \n            String valueDesc = p.getText();\n            ctxt.reportInputMismatch(this, \"Cannot coerce Number (%s) %s (enable `%s.%s` to allow)\",\n                valueDesc, _coercedTypeDesc(), feat.getClass().getSimpleName(), feat.name());\n        }\n    }\n    \n    protected void _reportFailedNullCoerce(DeserializationContext ctxt, boolean state, Enum<?> feature, String inputDesc) throws JsonMappingException {\n        String enableDesc = state ? \"enable\" : \"disable\";\n        ctxt.reportInputMismatch(this, \"Cannot coerce %s to Null value %s (%s `%s.%s` to allow)\",\n            inputDesc, _coercedTypeDesc(), enableDesc, feature.getClass().getSimpleName(), feature.name());\n    }\n    \n    \n    protected String _coercedTypeDesc() {\n        boolean structured;\n        String typeDesc;\n\n        JavaType t = getValueType();\n        if ((t != null) && !t.isPrimitive()) {\n            structured = (t.isContainerType() || t.isReferenceType());\n            \n            typeDesc = \"'\"+t.toString()+\"'\";\n        } else {\n            Class<?> cls = handledType();\n            structured = cls.isArray() || Collection.class.isAssignableFrom(cls)\n                || Map.class.isAssignableFrom(cls);\n            typeDesc = ClassUtil.nameOf(cls);\n        }\n        if (structured) {\n            return \"as content of type \"+typeDesc;\n        }\n        return \"for type \"+typeDesc;\n    }\n\n    \n\n    \n    protected JsonDeserializer<Object> findDeserializer(DeserializationContext ctxt, JavaType type, BeanProperty property) throws JsonMappingException {\n        return ctxt.findContextualValueDeserializer(type, property);\n    }\n\n    \n    protected final boolean _isIntNumber(String text) {\n        final int len = text.length();\n        if (len > 0) {\n            char c = text.charAt(0);\n            \n            int i = (c == '-' || c == '+') ? 1 : 0;\n            for (; i < len; ++i) {\n                int ch = text.charAt(i);\n                if (ch > '9' || ch < '0') {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    \n\n    \n    protected JsonDeserializer<?> findConvertingContentDeserializer(DeserializationContext ctxt, BeanProperty prop, JsonDeserializer<?> existingDeserializer) throws JsonMappingException {\n        final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (_neitherNull(intr, prop)) {\n            AnnotatedMember member = prop.getMember();\n            if (member != null) {\n                Object convDef = intr.findDeserializationContentConverter(member);\n                if (convDef != null) {\n                    Converter<Object,Object> conv = ctxt.converterInstance(prop.getMember(), convDef);\n                    JavaType delegateType = conv.getInputType(ctxt.getTypeFactory());\n                    if (existingDeserializer == null) {\n                        existingDeserializer = ctxt.findContextualValueDeserializer(delegateType, prop);\n                    }\n                    return new StdDelegatingDeserializer<Object>(conv, delegateType, existingDeserializer);\n                }\n            }\n        }\n        return existingDeserializer;\n    }\n\n    \n    \n    \n    protected JsonFormat.Value findFormatOverrides(DeserializationContext ctxt, BeanProperty prop, Class<?> typeForDefaults) {\n        if (prop != null) {\n            return prop.findPropertyFormat(ctxt.getConfig(), typeForDefaults);\n        }\n        \n        return ctxt.getDefaultPropertyFormat(typeForDefaults);\n    }\n\n    \n    protected Boolean findFormatFeature(DeserializationContext ctxt, BeanProperty prop, Class<?> typeForDefaults, JsonFormat.Feature feat) {\n        JsonFormat.Value format = findFormatOverrides(ctxt, prop, typeForDefaults);\n        if (format != null) {\n            return format.getFeature(feat);\n        }\n        return null;\n    }\n\n    \n    protected final NullValueProvider findValueNullProvider(DeserializationContext ctxt, SettableBeanProperty prop, PropertyMetadata propMetadata) throws JsonMappingException {\n        if (prop != null) {\n            return _findNullProvider(ctxt, prop, propMetadata.getValueNulls(),\n                    prop.getValueDeserializer());\n        }\n        return null;\n    }\n\n    \n    protected NullValueProvider findContentNullProvider(DeserializationContext ctxt, BeanProperty prop, JsonDeserializer<?> valueDeser) throws JsonMappingException {\n        final Nulls nulls = findContentNullStyle(ctxt, prop);\n        if (nulls == Nulls.SKIP) {\n            return NullsConstantProvider.skipper();\n        }\n        NullValueProvider prov = _findNullProvider(ctxt, prop, nulls, valueDeser);\n        if (prov != null) {\n            return prov;\n        }\n        return valueDeser;\n    }\n\n    protected Nulls findContentNullStyle(DeserializationContext ctxt, BeanProperty prop) throws JsonMappingException {\n        if (prop != null) {\n            return prop.getMetadata().getContentNulls();\n        }\n        return null;\n    }\n\n    \n    protected final NullValueProvider _findNullProvider(DeserializationContext ctxt, BeanProperty prop, Nulls nulls, JsonDeserializer<?> valueDeser) throws JsonMappingException {\n        if (nulls == Nulls.FAIL) {\n            if (prop == null) {\n                return NullsFailProvider.constructForRootValue(ctxt.constructType(valueDeser.handledType()));\n            }\n            return NullsFailProvider.constructForProperty(prop);\n        }\n        if (nulls == Nulls.AS_EMPTY) {\n            \n            \n            if (valueDeser == null) {\n                return null;\n            }\n\n            \n            \n            \n            if (valueDeser instanceof BeanDeserializerBase) {\n                ValueInstantiator vi = ((BeanDeserializerBase) valueDeser).getValueInstantiator();\n                if (!vi.canCreateUsingDefault()) {\n                    final JavaType type = prop.getType();\n                    ctxt.reportBadDefinition(type,\n                            String.format(\"Cannot create empty instance of %s, no default Creator\", type));\n                }\n            }\n            \n            {\n                AccessPattern access = valueDeser.getEmptyAccessPattern();\n                if (access == AccessPattern.ALWAYS_NULL) {\n                    return NullsConstantProvider.nuller();\n                }\n                if (access == AccessPattern.CONSTANT) {\n                    return NullsConstantProvider.forValue(valueDeser.getEmptyValue(ctxt));\n                }\n            }\n            return new NullsAsEmptyProvider(valueDeser);\n        }\n        if (nulls == Nulls.SKIP) {\n            return NullsConstantProvider.skipper();\n        }\n        return null;\n    }\n\n    \n\n    \n    protected void handleUnknownProperty(JsonParser p, DeserializationContext ctxt, Object instanceOrClass, String propName) throws IOException {\n        if (instanceOrClass == null) {\n            instanceOrClass = handledType();\n        }\n        \n        if (ctxt.handleUnknownProperty(p, this, instanceOrClass, propName)) {\n            return;\n        }\n        \n        p.skipChildren();\n    }\n\n    protected void handleMissingEndArrayForSingle(JsonParser p, DeserializationContext ctxt) throws IOException {\n        ctxt.reportWrongTokenException(this, JsonToken.END_ARRAY, \n\"Attempted to unwrap '%s' value from an array (with `DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS`) but it contains more than one value\",\nhandledType().getName());\n        \n        \n    }\n\n    protected void _verifyEndArrayForSingle(JsonParser p, DeserializationContext ctxt) throws IOException {\n        JsonToken t = p.nextToken();\n        if (t != JsonToken.END_ARRAY) {\n            handleMissingEndArrayForSingle(p, ctxt);\n        }            \n    }\n\n    \n\n    \n    protected final static boolean _neitherNull(Object a, Object b) {\n        return (a != null) && (b != null);\n    }\n\n    \n    protected final boolean _byteOverflow(int value) {\n        \n        \n        return (value < Byte.MIN_VALUE || value > 255);\n    }\n    \n    \n    protected final boolean _shortOverflow(int value) {\n        return (value < Short.MIN_VALUE || value > Short.MAX_VALUE);\n    }\n\n    \n    protected final boolean _intOverflow(long value) {\n        return (value < Integer.MIN_VALUE || value > Integer.MAX_VALUE);\n    }\n\n    \n    protected Number _nonNullNumber(Number n) {\n        if (n == null) {\n            n = Integer.valueOf(0);\n        }\n        return n;\n    }\n}\n",
      "buggy_signatures": [
        "protected StdDeserializer(JavaType valueType)",
        "protected StdDeserializer(StdDeserializer<?> src)",
        "public Class<?> handledType()",
        "public final Class<?> getValueClass()",
        "public JavaType getValueType()",
        "protected boolean isDefaultDeserializer(JsonDeserializer<?> deserializer)",
        "protected boolean isDefaultKeyDeserializer(KeyDeserializer keyDeser)",
        "public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException",
        "protected final boolean _parseBooleanPrimitive(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected boolean _parseBooleanFromInt(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected final byte _parseBytePrimitive(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected final short _parseShortPrimitive(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected final int _parseIntPrimitive(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected final int _parseIntPrimitive(DeserializationContext ctxt, String text) throws IOException",
        "protected final long _parseLongPrimitive(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected final long _parseLongPrimitive(DeserializationContext ctxt, String text) throws IOException",
        "protected final float _parseFloatPrimitive(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected final float _parseFloatPrimitive(DeserializationContext ctxt, String text) throws IOException",
        "protected final double _parseDoublePrimitive(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected final double _parseDoublePrimitive(DeserializationContext ctxt, String text) throws IOException",
        "protected java.util.Date _parseDate(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected java.util.Date _parseDateFromArray(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected java.util.Date _parseDate(String value, DeserializationContext ctxt) throws IOException",
        "protected final static double parseDouble(String numStr) throws NumberFormatException",
        "protected final String _parseString(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected T _deserializeFromEmpty(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected boolean _hasTextualNull(String value)",
        "protected boolean _isEmptyOrTextualNull(String value)",
        "protected final boolean _isNegInf(String text)",
        "protected final boolean _isPosInf(String text)",
        "protected final boolean _isNaN(String text)",
        "protected T _deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected T _deserializeWrappedValue(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected void _failDoubleToIntCoercion(JsonParser p, DeserializationContext ctxt, String type) throws IOException",
        "protected Object _coerceIntegral(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected Object _coerceNullToken(DeserializationContext ctxt, boolean isPrimitive) throws JsonMappingException",
        "protected Object _coerceTextualNull(DeserializationContext ctxt, boolean isPrimitive) throws JsonMappingException",
        "protected Object _coerceEmptyString(DeserializationContext ctxt, boolean isPrimitive) throws JsonMappingException",
        "protected final void _verifyNullForPrimitive(DeserializationContext ctxt) throws JsonMappingException",
        "protected final void _verifyNullForPrimitiveCoercion(DeserializationContext ctxt, String str) throws JsonMappingException",
        "protected final void _verifyNullForScalarCoercion(DeserializationContext ctxt, String str) throws JsonMappingException",
        "protected void _verifyStringForScalarCoercion(DeserializationContext ctxt, String str) throws JsonMappingException",
        "protected void _verifyNumberForScalarCoercion(DeserializationContext ctxt, JsonParser p) throws IOException",
        "protected void _reportFailedNullCoerce(DeserializationContext ctxt, boolean state, Enum<?> feature, String inputDesc) throws JsonMappingException",
        "protected String _coercedTypeDesc()",
        "protected JsonDeserializer<Object> findDeserializer(DeserializationContext ctxt, JavaType type, BeanProperty property) throws JsonMappingException",
        "protected final boolean _isIntNumber(String text)",
        "protected JsonDeserializer<?> findConvertingContentDeserializer(DeserializationContext ctxt, BeanProperty prop, JsonDeserializer<?> existingDeserializer) throws JsonMappingException",
        "protected JsonFormat.Value findFormatOverrides(DeserializationContext ctxt, BeanProperty prop, Class<?> typeForDefaults)",
        "protected Boolean findFormatFeature(DeserializationContext ctxt, BeanProperty prop, Class<?> typeForDefaults, JsonFormat.Feature feat)",
        "protected final NullValueProvider findValueNullProvider(DeserializationContext ctxt, SettableBeanProperty prop, PropertyMetadata propMetadata) throws JsonMappingException",
        "protected NullValueProvider findContentNullProvider(DeserializationContext ctxt, BeanProperty prop, JsonDeserializer<?> valueDeser) throws JsonMappingException",
        "protected Nulls findContentNullStyle(DeserializationContext ctxt, BeanProperty prop) throws JsonMappingException",
        "protected final NullValueProvider _findNullProvider(DeserializationContext ctxt, BeanProperty prop, Nulls nulls, JsonDeserializer<?> valueDeser) throws JsonMappingException",
        "protected void handleUnknownProperty(JsonParser p, DeserializationContext ctxt, Object instanceOrClass, String propName) throws IOException",
        "protected void handleMissingEndArrayForSingle(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected void _verifyEndArrayForSingle(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected final static boolean _neitherNull(Object a, Object b)",
        "protected final boolean _byteOverflow(int value)",
        "protected final boolean _shortOverflow(int value)",
        "protected final boolean _intOverflow(long value)",
        "protected Number _nonNullNumber(Number n)"
      ],
      "fixed_signatures": [
        "protected StdDeserializer(JavaType valueType)",
        "protected StdDeserializer(StdDeserializer<?> src)",
        "public Class<?> handledType()",
        "public final Class<?> getValueClass()",
        "public JavaType getValueType()",
        "protected boolean isDefaultDeserializer(JsonDeserializer<?> deserializer)",
        "protected boolean isDefaultKeyDeserializer(KeyDeserializer keyDeser)",
        "public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException",
        "protected final boolean _parseBooleanPrimitive(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected boolean _parseBooleanFromInt(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected final byte _parseBytePrimitive(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected final short _parseShortPrimitive(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected final int _parseIntPrimitive(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected final int _parseIntPrimitive(DeserializationContext ctxt, String text) throws IOException",
        "protected final long _parseLongPrimitive(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected final long _parseLongPrimitive(DeserializationContext ctxt, String text) throws IOException",
        "protected final float _parseFloatPrimitive(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected final float _parseFloatPrimitive(DeserializationContext ctxt, String text) throws IOException",
        "protected final double _parseDoublePrimitive(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected final double _parseDoublePrimitive(DeserializationContext ctxt, String text) throws IOException",
        "protected java.util.Date _parseDate(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected java.util.Date _parseDateFromArray(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected java.util.Date _parseDate(String value, DeserializationContext ctxt) throws IOException",
        "protected final static double parseDouble(String numStr) throws NumberFormatException",
        "protected final String _parseString(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected T _deserializeFromEmpty(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected boolean _hasTextualNull(String value)",
        "protected boolean _isEmptyOrTextualNull(String value)",
        "protected final boolean _isNegInf(String text)",
        "protected final boolean _isPosInf(String text)",
        "protected final boolean _isNaN(String text)",
        "protected T _deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected T _deserializeWrappedValue(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected void _failDoubleToIntCoercion(JsonParser p, DeserializationContext ctxt, String type) throws IOException",
        "protected Object _coerceIntegral(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected Object _coerceNullToken(DeserializationContext ctxt, boolean isPrimitive) throws JsonMappingException",
        "protected Object _coerceTextualNull(DeserializationContext ctxt, boolean isPrimitive) throws JsonMappingException",
        "protected Object _coerceEmptyString(DeserializationContext ctxt, boolean isPrimitive) throws JsonMappingException",
        "protected final void _verifyNullForPrimitive(DeserializationContext ctxt) throws JsonMappingException",
        "protected final void _verifyNullForPrimitiveCoercion(DeserializationContext ctxt, String str) throws JsonMappingException",
        "protected final void _verifyNullForScalarCoercion(DeserializationContext ctxt, String str) throws JsonMappingException",
        "protected void _verifyStringForScalarCoercion(DeserializationContext ctxt, String str) throws JsonMappingException",
        "protected void _verifyNumberForScalarCoercion(DeserializationContext ctxt, JsonParser p) throws IOException",
        "protected void _reportFailedNullCoerce(DeserializationContext ctxt, boolean state, Enum<?> feature, String inputDesc) throws JsonMappingException",
        "protected String _coercedTypeDesc()",
        "protected JsonDeserializer<Object> findDeserializer(DeserializationContext ctxt, JavaType type, BeanProperty property) throws JsonMappingException",
        "protected final boolean _isIntNumber(String text)",
        "protected JsonDeserializer<?> findConvertingContentDeserializer(DeserializationContext ctxt, BeanProperty prop, JsonDeserializer<?> existingDeserializer) throws JsonMappingException",
        "protected JsonFormat.Value findFormatOverrides(DeserializationContext ctxt, BeanProperty prop, Class<?> typeForDefaults)",
        "protected Boolean findFormatFeature(DeserializationContext ctxt, BeanProperty prop, Class<?> typeForDefaults, JsonFormat.Feature feat)",
        "protected final NullValueProvider findValueNullProvider(DeserializationContext ctxt, SettableBeanProperty prop, PropertyMetadata propMetadata) throws JsonMappingException",
        "protected NullValueProvider findContentNullProvider(DeserializationContext ctxt, BeanProperty prop, JsonDeserializer<?> valueDeser) throws JsonMappingException",
        "protected Nulls findContentNullStyle(DeserializationContext ctxt, BeanProperty prop) throws JsonMappingException",
        "protected final NullValueProvider _findNullProvider(DeserializationContext ctxt, BeanProperty prop, Nulls nulls, JsonDeserializer<?> valueDeser) throws JsonMappingException",
        "protected void handleUnknownProperty(JsonParser p, DeserializationContext ctxt, Object instanceOrClass, String propName) throws IOException",
        "protected void handleMissingEndArrayForSingle(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected void _verifyEndArrayForSingle(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected final static boolean _neitherNull(Object a, Object b)",
        "protected final boolean _byteOverflow(int value)",
        "protected final boolean _shortOverflow(int value)",
        "protected final boolean _intOverflow(long value)",
        "protected Number _nonNullNumber(Number n)"
      ],
      "methods": [
        {
          "buggy_method": "  protected java.util.Date _parseDate(String value, DeserializationContext ctxt) throws IOException {\n  try {\n  \n  if (_isEmptyOrTextualNull(value)) {\n  return (java.util.Date) getNullValue(ctxt);\n  }\n  return ctxt.parseDate(value);\n  } catch (IllegalArgumentException iae) {\n  return (java.util.Date) ctxt.handleWeirdStringValue(_valueClass, value,\n  \"not a valid representation (error: %s)\",\n  iae.getMessage());\n  }\n  }",
          "fixed_method": "  protected java.util.Date _parseDate(String value, DeserializationContext ctxt) throws IOException {\n  try {\n  \n  if (_isEmptyOrTextualNull(value)) {\n  return (java.util.Date) getNullValue(ctxt);\n  }\n  return ctxt.parseDate(value);\n  } catch (IllegalArgumentException iae) {\n  return (java.util.Date) ctxt.handleWeirdStringValue(_valueClass, value,\n  \"not a valid representation (error: %s)\",\n  ClassUtil.exceptionMessage(iae));\n  }\n  }",
          "diff": [
            "@@ -523,7 +523,7 @@",
            "         } catch (IllegalArgumentException iae) {\n",
            "             return (java.util.Date) ctxt.handleWeirdStringValue(_valueClass, value,\n",
            "                     \"not a valid representation (error: %s)\",\n",
            "-                    iae.getMessage());\n",
            "+                    ClassUtil.exceptionMessage(iae));\n",
            "         }\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.core.io.NumberInput;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.EnumResolver;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n\n@JacksonStdImpl\npublic class StdKeyDeserializer extends KeyDeserializer implements java.io.Serializable { private static final long serialVersionUID = 1L; public final static int TYPE_BOOLEAN = 1; public final static int TYPE_BYTE = 2; public final static int TYPE_SHORT = 3; public final static int TYPE_CHAR = 4; public final static int TYPE_INT = 5; public final static int TYPE_LONG = 6; public final static int TYPE_FLOAT = 7; public final static int TYPE_DOUBLE = 8; public final static int TYPE_LOCALE = 9; public final static int TYPE_DATE = 10; public final static int TYPE_CALENDAR = 11; public final static int TYPE_UUID = 12; public final static int TYPE_URI = 13; public final static int TYPE_URL = 14; public final static int TYPE_CLASS = 15; public final static int TYPE_CURRENCY = 16; public final static int TYPE_BYTE_ARRAY = 17; final protected int _kind; final protected Class<?> _keyClass; protected final FromStringDeserializer<?> _deser; protected StdKeyDeserializer(int kind, Class<?> cls) {\n        this(kind, cls, null);\n    }\n\n    protected StdKeyDeserializer(int kind, Class<?> cls, FromStringDeserializer<?> deser) {\n        _kind = kind;\n        _keyClass = cls;\n        _deser = deser;\n    }\n\n    public static StdKeyDeserializer forType(Class<?> raw) {\n        int kind;\n\n        \n        if (raw == String.class || raw == Object.class || raw == CharSequence.class) {\n            return StringKD.forType(raw);\n        } else if (raw == UUID.class) {\n            kind = TYPE_UUID;\n        } else if (raw == Integer.class) {\n            kind = TYPE_INT;\n        } else if (raw == Long.class) {\n            kind = TYPE_LONG;\n        } else if (raw == Date.class) {\n            kind = TYPE_DATE;\n        } else if (raw == Calendar.class) {\n            kind = TYPE_CALENDAR;\n        \n        } else if (raw == Boolean.class) {\n            kind = TYPE_BOOLEAN;\n        } else if (raw == Byte.class) {\n            kind = TYPE_BYTE;\n        } else if (raw == Character.class) {\n            kind = TYPE_CHAR;\n        } else if (raw == Short.class) {\n            kind = TYPE_SHORT;\n        } else if (raw == Float.class) {\n            kind = TYPE_FLOAT;\n        } else if (raw == Double.class) {\n            kind = TYPE_DOUBLE;\n        } else if (raw == URI.class) {\n            kind = TYPE_URI;\n        } else if (raw == URL.class) {\n            kind = TYPE_URL;\n        } else if (raw == Class.class) {\n            kind = TYPE_CLASS;\n        } else if (raw == Locale.class) {\n            FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class);\n            return new StdKeyDeserializer(TYPE_LOCALE, raw, deser);\n        } else if (raw == Currency.class) {\n            FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class);\n            return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser);\n        } else if (raw == byte[].class) {\n            kind = TYPE_BYTE_ARRAY;\n        } else {\n            return null;\n        }\n        return new StdKeyDeserializer(kind, raw);\n    }\n\n    @Override\n    public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n        if (key == null) { \n            return null;\n        }\n        try {\n            Object result = _parse(key, ctxt);\n            if (result != null) {\n                return result;\n            }\n        } catch (Exception re) {\n            return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\",\n                    re.getClass().getName(),\n                    re.getMessage());\n        }\n        if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            return null;\n        }\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n    }\n\n    public Class<?> getKeyClass() { return _keyClass; }\n\n    protected Object _parse(String key, DeserializationContext ctxt) throws Exception {\n        switch (_kind) {\n        case TYPE_BOOLEAN:\n            if (\"true\".equals(key)) {\n                return Boolean.TRUE;\n            }\n            if (\"false\".equals(key)) {\n                return Boolean.FALSE;\n            }\n            return ctxt.handleWeirdKey(_keyClass, key, \"value not 'true' or 'false'\");\n        case TYPE_BYTE:\n            {\n                int value = _parseInt(key);\n                \n                if (value < Byte.MIN_VALUE || value > 255) {\n                    return ctxt.handleWeirdKey(_keyClass, key, \"overflow, value cannot be represented as 8-bit value\");\n                }\n                return Byte.valueOf((byte) value);\n            }\n        case TYPE_SHORT:\n            {\n                int value = _parseInt(key);\n                if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {\n                    return ctxt.handleWeirdKey(_keyClass, key, \"overflow, value cannot be represented as 16-bit value\");\n                    \n                }\n                return Short.valueOf((short) value);\n            }\n        case TYPE_CHAR:\n            if (key.length() == 1) {\n                return Character.valueOf(key.charAt(0));\n            }\n            return ctxt.handleWeirdKey(_keyClass, key, \"can only convert 1-character Strings\");\n        case TYPE_INT:\n            return _parseInt(key);\n\n        case TYPE_LONG:\n            return _parseLong(key);\n\n        case TYPE_FLOAT:\n            \n            return Float.valueOf((float) _parseDouble(key));\n        case TYPE_DOUBLE:\n            return _parseDouble(key);\n        case TYPE_LOCALE:\n            try {\n                return _deser._deserialize(key, ctxt);\n            } catch (IllegalArgumentException e) {\n                return _weirdKey(ctxt, key, e);\n            }\n        case TYPE_CURRENCY:\n            try {\n                return _deser._deserialize(key, ctxt);\n            } catch (IllegalArgumentException e) {\n                return _weirdKey(ctxt, key, e);\n            }\n        case TYPE_DATE:\n            return ctxt.parseDate(key);\n        case TYPE_CALENDAR:\n            return ctxt.constructCalendar(ctxt.parseDate(key));\n        case TYPE_UUID:\n            try {\n                return UUID.fromString(key);\n            } catch (Exception e) {\n                return _weirdKey(ctxt, key, e);\n            }\n        case TYPE_URI:\n            try {\n                return URI.create(key);\n            } catch (Exception e) {\n                return _weirdKey(ctxt, key, e);\n            }\n        case TYPE_URL:\n            try {\n                return new URL(key);\n            } catch (MalformedURLException e) {\n                return _weirdKey(ctxt, key, e);\n            }\n        case TYPE_CLASS:\n            try {\n                return ctxt.findClass(key);\n            } catch (Exception e) {\n                return ctxt.handleWeirdKey(_keyClass, key, \"unable to parse key as Class\");\n            }\n        case TYPE_BYTE_ARRAY:\n            try {\n                return ctxt.getConfig().getBase64Variant().decode(key);\n            } catch (IllegalArgumentException e) {\n                return _weirdKey(ctxt, key, e);\n            }\n        default:\n            throw new IllegalStateException(\"Internal error: unknown key type \"+_keyClass);\n        }\n    }\n\n    \n\n    protected int _parseInt(String key) throws IllegalArgumentException {\n        return Integer.parseInt(key);\n    }\n\n    protected long _parseLong(String key) throws IllegalArgumentException {\n        return Long.parseLong(key);\n    }\n\n    protected double _parseDouble(String key) throws IllegalArgumentException {\n        return NumberInput.parseDouble(key);\n    }\n\n    \n    protected Object _weirdKey(DeserializationContext ctxt, String key, Exception e) throws IOException {\n        return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\",\n                e.getMessage());\n    }\n\n    \n\n    @JacksonStdImpl\n    final static class StringKD extends StdKeyDeserializer { private static final long serialVersionUID = 1L; private final static StringKD sString = new StringKD(String.class); private final static StringKD sObject = new StringKD(Object.class); private StringKD(Class<?> nominalType) { super(-1, nominalType); }\n\n        public static StringKD forType(Class<?> nominalType) {\n            if (nominalType == String.class) {\n                return sString;\n            }\n            if (nominalType == Object.class) {\n                return sObject;\n            }\n            return new StringKD(nominalType);\n        }\n\n        @Override\n        public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n            return key;\n        }\n    }    \n\n    \n\n    \n    final static class DelegatingKD extends KeyDeserializer implements java.io.Serializable { private static final long serialVersionUID = 1L; final protected Class<?> _keyClass; protected final JsonDeserializer<?> _delegate; protected DelegatingKD(Class<?> cls, JsonDeserializer<?> deser) {\n            _keyClass = cls;\n            _delegate = deser;\n        }\n\n        @SuppressWarnings(\"resource\")\n        @Override\n        public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n            if (key == null) { \n                return null;\n            }\n            TokenBuffer tb = new TokenBuffer(ctxt.getParser(), ctxt);\n            tb.writeString(key);\n            try {\n                \n                JsonParser p = tb.asParser();\n                p.nextToken();\n                Object result = _delegate.deserialize(p, ctxt);\n                if (result != null) {\n                    return result;\n                }\n                return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n            } catch (Exception re) {\n                return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation: %s\", re.getMessage());\n            }\n        }\n\n        public Class<?> getKeyClass() { return _keyClass; }\n    }\n     \n    @JacksonStdImpl\n    final static class EnumKD extends StdKeyDeserializer { private static final long serialVersionUID = 1L; protected final EnumResolver _byNameResolver; protected final AnnotatedMethod _factory; protected EnumResolver _byToStringResolver; protected final Enum<?> _enumDefaultValue; protected EnumKD(EnumResolver er, AnnotatedMethod factory) {\n            super(-1, er.getEnumClass());\n            _byNameResolver = er;\n            _factory = factory;\n            _enumDefaultValue = er.getDefaultValue();\n        }\n\n        @Override\n        public Object _parse(String key, DeserializationContext ctxt) throws IOException {\n            if (_factory != null) {\n                try {\n                    return _factory.call1(key);\n                } catch (Exception e) {\n                    ClassUtil.unwrapAndThrowAsIAE(e);\n                }\n            }\n            EnumResolver res = ctxt.isEnabled(DeserializationFeature.READ_ENUMS_USING_TO_STRING)\n                    ? _getToStringResolver(ctxt) : _byNameResolver;\n            Enum<?> e = res.findEnum(key);\n            if (e == null) {\n                if ((_enumDefaultValue != null)\n                        && ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n                    e = _enumDefaultValue;\n                } else if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n                    return ctxt.handleWeirdKey(_keyClass, key, \"not one of values excepted for Enum class: %s\",\n                        res.getEnumIds());\n                }\n                \n            }\n            return e;\n        }\n\n        private EnumResolver _getToStringResolver(DeserializationContext ctxt) {\n            EnumResolver res = _byToStringResolver;\n            if (res == null) {\n                synchronized (this) {\n                    res = EnumResolver.constructUnsafeUsingToString(_byNameResolver.getEnumClass(),\n                            ctxt.getAnnotationIntrospector());\n                }\n            }\n            return res;\n        }\n    }\n    \n    \n    final static class StringCtorKeyDeserializer extends StdKeyDeserializer { private static final long serialVersionUID = 1L; protected final Constructor<?> _ctor; public StringCtorKeyDeserializer(Constructor<?> ctor) {\n            super(-1, ctor.getDeclaringClass());\n            _ctor = ctor;\n        }\n\n        @Override\n        public Object _parse(String key, DeserializationContext ctxt) throws Exception {\n            return _ctor.newInstance(key);\n        }\n    }\n\n    \n    final static class StringFactoryKeyDeserializer extends StdKeyDeserializer { private static final long serialVersionUID = 1L; final Method _factoryMethod; public StringFactoryKeyDeserializer(Method fm) {\n            super(-1, fm.getDeclaringClass());\n            _factoryMethod = fm;\n        }\n\n        @Override\n        public Object _parse(String key, DeserializationContext ctxt) throws Exception {\n            return _factoryMethod.invoke(null, key);\n        }\n    }\n}\n\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.core.io.NumberInput;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.EnumResolver;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n\n@JacksonStdImpl\npublic class StdKeyDeserializer extends KeyDeserializer implements java.io.Serializable { private static final long serialVersionUID = 1L; public final static int TYPE_BOOLEAN = 1; public final static int TYPE_BYTE = 2; public final static int TYPE_SHORT = 3; public final static int TYPE_CHAR = 4; public final static int TYPE_INT = 5; public final static int TYPE_LONG = 6; public final static int TYPE_FLOAT = 7; public final static int TYPE_DOUBLE = 8; public final static int TYPE_LOCALE = 9; public final static int TYPE_DATE = 10; public final static int TYPE_CALENDAR = 11; public final static int TYPE_UUID = 12; public final static int TYPE_URI = 13; public final static int TYPE_URL = 14; public final static int TYPE_CLASS = 15; public final static int TYPE_CURRENCY = 16; public final static int TYPE_BYTE_ARRAY = 17; final protected int _kind; final protected Class<?> _keyClass; protected final FromStringDeserializer<?> _deser; protected StdKeyDeserializer(int kind, Class<?> cls) {\n        this(kind, cls, null);\n    }\n\n    protected StdKeyDeserializer(int kind, Class<?> cls, FromStringDeserializer<?> deser) {\n        _kind = kind;\n        _keyClass = cls;\n        _deser = deser;\n    }\n\n    public static StdKeyDeserializer forType(Class<?> raw) {\n        int kind;\n\n        \n        if (raw == String.class || raw == Object.class || raw == CharSequence.class) {\n            return StringKD.forType(raw);\n        } else if (raw == UUID.class) {\n            kind = TYPE_UUID;\n        } else if (raw == Integer.class) {\n            kind = TYPE_INT;\n        } else if (raw == Long.class) {\n            kind = TYPE_LONG;\n        } else if (raw == Date.class) {\n            kind = TYPE_DATE;\n        } else if (raw == Calendar.class) {\n            kind = TYPE_CALENDAR;\n        \n        } else if (raw == Boolean.class) {\n            kind = TYPE_BOOLEAN;\n        } else if (raw == Byte.class) {\n            kind = TYPE_BYTE;\n        } else if (raw == Character.class) {\n            kind = TYPE_CHAR;\n        } else if (raw == Short.class) {\n            kind = TYPE_SHORT;\n        } else if (raw == Float.class) {\n            kind = TYPE_FLOAT;\n        } else if (raw == Double.class) {\n            kind = TYPE_DOUBLE;\n        } else if (raw == URI.class) {\n            kind = TYPE_URI;\n        } else if (raw == URL.class) {\n            kind = TYPE_URL;\n        } else if (raw == Class.class) {\n            kind = TYPE_CLASS;\n        } else if (raw == Locale.class) {\n            FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class);\n            return new StdKeyDeserializer(TYPE_LOCALE, raw, deser);\n        } else if (raw == Currency.class) {\n            FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class);\n            return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser);\n        } else if (raw == byte[].class) {\n            kind = TYPE_BYTE_ARRAY;\n        } else {\n            return null;\n        }\n        return new StdKeyDeserializer(kind, raw);\n    }\n\n    @Override\n    public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n        if (key == null) { \n            return null;\n        }\n        try {\n            Object result = _parse(key, ctxt);\n            if (result != null) {\n                return result;\n            }\n        } catch (Exception re) {\n            return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\",\n                    re.getClass().getName(),\n                    ClassUtil.exceptionMessage(re));\n        }\n        if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            return null;\n        }\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n    }\n\n    public Class<?> getKeyClass() { return _keyClass; }\n\n    protected Object _parse(String key, DeserializationContext ctxt) throws Exception {\n        switch (_kind) {\n        case TYPE_BOOLEAN:\n            if (\"true\".equals(key)) {\n                return Boolean.TRUE;\n            }\n            if (\"false\".equals(key)) {\n                return Boolean.FALSE;\n            }\n            return ctxt.handleWeirdKey(_keyClass, key, \"value not 'true' or 'false'\");\n        case TYPE_BYTE:\n            {\n                int value = _parseInt(key);\n                \n                if (value < Byte.MIN_VALUE || value > 255) {\n                    return ctxt.handleWeirdKey(_keyClass, key, \"overflow, value cannot be represented as 8-bit value\");\n                }\n                return Byte.valueOf((byte) value);\n            }\n        case TYPE_SHORT:\n            {\n                int value = _parseInt(key);\n                if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {\n                    return ctxt.handleWeirdKey(_keyClass, key, \"overflow, value cannot be represented as 16-bit value\");\n                    \n                }\n                return Short.valueOf((short) value);\n            }\n        case TYPE_CHAR:\n            if (key.length() == 1) {\n                return Character.valueOf(key.charAt(0));\n            }\n            return ctxt.handleWeirdKey(_keyClass, key, \"can only convert 1-character Strings\");\n        case TYPE_INT:\n            return _parseInt(key);\n\n        case TYPE_LONG:\n            return _parseLong(key);\n\n        case TYPE_FLOAT:\n            \n            return Float.valueOf((float) _parseDouble(key));\n        case TYPE_DOUBLE:\n            return _parseDouble(key);\n        case TYPE_LOCALE:\n            try {\n                return _deser._deserialize(key, ctxt);\n            } catch (IllegalArgumentException e) {\n                return _weirdKey(ctxt, key, e);\n            }\n        case TYPE_CURRENCY:\n            try {\n                return _deser._deserialize(key, ctxt);\n            } catch (IllegalArgumentException e) {\n                return _weirdKey(ctxt, key, e);\n            }\n        case TYPE_DATE:\n            return ctxt.parseDate(key);\n        case TYPE_CALENDAR:\n            return ctxt.constructCalendar(ctxt.parseDate(key));\n        case TYPE_UUID:\n            try {\n                return UUID.fromString(key);\n            } catch (Exception e) {\n                return _weirdKey(ctxt, key, e);\n            }\n        case TYPE_URI:\n            try {\n                return URI.create(key);\n            } catch (Exception e) {\n                return _weirdKey(ctxt, key, e);\n            }\n        case TYPE_URL:\n            try {\n                return new URL(key);\n            } catch (MalformedURLException e) {\n                return _weirdKey(ctxt, key, e);\n            }\n        case TYPE_CLASS:\n            try {\n                return ctxt.findClass(key);\n            } catch (Exception e) {\n                return ctxt.handleWeirdKey(_keyClass, key, \"unable to parse key as Class\");\n            }\n        case TYPE_BYTE_ARRAY:\n            try {\n                return ctxt.getConfig().getBase64Variant().decode(key);\n            } catch (IllegalArgumentException e) {\n                return _weirdKey(ctxt, key, e);\n            }\n        default:\n            throw new IllegalStateException(\"Internal error: unknown key type \"+_keyClass);\n        }\n    }\n\n    \n\n    protected int _parseInt(String key) throws IllegalArgumentException {\n        return Integer.parseInt(key);\n    }\n\n    protected long _parseLong(String key) throws IllegalArgumentException {\n        return Long.parseLong(key);\n    }\n\n    protected double _parseDouble(String key) throws IllegalArgumentException {\n        return NumberInput.parseDouble(key);\n    }\n\n    \n    protected Object _weirdKey(DeserializationContext ctxt, String key, Exception e) throws IOException {\n        return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\",\n                ClassUtil.exceptionMessage(e));\n    }\n\n    \n\n    @JacksonStdImpl\n    final static class StringKD extends StdKeyDeserializer { private static final long serialVersionUID = 1L; private final static StringKD sString = new StringKD(String.class); private final static StringKD sObject = new StringKD(Object.class); private StringKD(Class<?> nominalType) { super(-1, nominalType); }\n\n        public static StringKD forType(Class<?> nominalType) {\n            if (nominalType == String.class) {\n                return sString;\n            }\n            if (nominalType == Object.class) {\n                return sObject;\n            }\n            return new StringKD(nominalType);\n        }\n\n        @Override\n        public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n            return key;\n        }\n    }    \n\n    \n\n    \n    final static class DelegatingKD extends KeyDeserializer implements java.io.Serializable { private static final long serialVersionUID = 1L; final protected Class<?> _keyClass; protected final JsonDeserializer<?> _delegate; protected DelegatingKD(Class<?> cls, JsonDeserializer<?> deser) {\n            _keyClass = cls;\n            _delegate = deser;\n        }\n\n        @SuppressWarnings(\"resource\")\n        @Override\n        public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n            if (key == null) { \n                return null;\n            }\n            TokenBuffer tb = new TokenBuffer(ctxt.getParser(), ctxt);\n            tb.writeString(key);\n            try {\n                \n                JsonParser p = tb.asParser();\n                p.nextToken();\n                Object result = _delegate.deserialize(p, ctxt);\n                if (result != null) {\n                    return result;\n                }\n                return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n            } catch (Exception re) {\n                return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation: %s\", re.getMessage());\n            }\n        }\n\n        public Class<?> getKeyClass() { return _keyClass; }\n    }\n     \n    @JacksonStdImpl\n    final static class EnumKD extends StdKeyDeserializer { private static final long serialVersionUID = 1L; protected final EnumResolver _byNameResolver; protected final AnnotatedMethod _factory; protected EnumResolver _byToStringResolver; protected final Enum<?> _enumDefaultValue; protected EnumKD(EnumResolver er, AnnotatedMethod factory) {\n            super(-1, er.getEnumClass());\n            _byNameResolver = er;\n            _factory = factory;\n            _enumDefaultValue = er.getDefaultValue();\n        }\n\n        @Override\n        public Object _parse(String key, DeserializationContext ctxt) throws IOException {\n            if (_factory != null) {\n                try {\n                    return _factory.call1(key);\n                } catch (Exception e) {\n                    ClassUtil.unwrapAndThrowAsIAE(e);\n                }\n            }\n            EnumResolver res = ctxt.isEnabled(DeserializationFeature.READ_ENUMS_USING_TO_STRING)\n                    ? _getToStringResolver(ctxt) : _byNameResolver;\n            Enum<?> e = res.findEnum(key);\n            if (e == null) {\n                if ((_enumDefaultValue != null)\n                        && ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n                    e = _enumDefaultValue;\n                } else if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n                    return ctxt.handleWeirdKey(_keyClass, key, \"not one of values excepted for Enum class: %s\",\n                        res.getEnumIds());\n                }\n                \n            }\n            return e;\n        }\n\n        private EnumResolver _getToStringResolver(DeserializationContext ctxt) {\n            EnumResolver res = _byToStringResolver;\n            if (res == null) {\n                synchronized (this) {\n                    res = EnumResolver.constructUnsafeUsingToString(_byNameResolver.getEnumClass(),\n                            ctxt.getAnnotationIntrospector());\n                }\n            }\n            return res;\n        }\n    }\n    \n    \n    final static class StringCtorKeyDeserializer extends StdKeyDeserializer { private static final long serialVersionUID = 1L; protected final Constructor<?> _ctor; public StringCtorKeyDeserializer(Constructor<?> ctor) {\n            super(-1, ctor.getDeclaringClass());\n            _ctor = ctor;\n        }\n\n        @Override\n        public Object _parse(String key, DeserializationContext ctxt) throws Exception {\n            return _ctor.newInstance(key);\n        }\n    }\n\n    \n    final static class StringFactoryKeyDeserializer extends StdKeyDeserializer { private static final long serialVersionUID = 1L; final Method _factoryMethod; public StringFactoryKeyDeserializer(Method fm) {\n            super(-1, fm.getDeclaringClass());\n            _factoryMethod = fm;\n        }\n\n        @Override\n        public Object _parse(String key, DeserializationContext ctxt) throws Exception {\n            return _factoryMethod.invoke(null, key);\n        }\n    }\n}\n\n",
      "buggy_signatures": [
        "protected StdKeyDeserializer(int kind, Class<?> cls, FromStringDeserializer<?> deser)",
        "public static StdKeyDeserializer forType(Class<?> raw)",
        "public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException",
        "public Class<?> getKeyClass()",
        "protected Object _parse(String key, DeserializationContext ctxt) throws Exception",
        "protected int _parseInt(String key) throws IllegalArgumentException",
        "protected long _parseLong(String key) throws IllegalArgumentException",
        "protected double _parseDouble(String key) throws IllegalArgumentException",
        "protected Object _weirdKey(DeserializationContext ctxt, String key, Exception e) throws IOException",
        "public static StringKD forType(Class<?> nominalType)",
        "public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException",
        "public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException",
        "public Class<?> getKeyClass()",
        "public Object _parse(String key, DeserializationContext ctxt) throws IOException",
        "private EnumResolver _getToStringResolver(DeserializationContext ctxt)",
        "synchronized (this)",
        "public Object _parse(String key, DeserializationContext ctxt) throws Exception",
        "public Object _parse(String key, DeserializationContext ctxt) throws Exception"
      ],
      "fixed_signatures": [
        "protected StdKeyDeserializer(int kind, Class<?> cls, FromStringDeserializer<?> deser)",
        "public static StdKeyDeserializer forType(Class<?> raw)",
        "public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException",
        "public Class<?> getKeyClass()",
        "protected Object _parse(String key, DeserializationContext ctxt) throws Exception",
        "protected int _parseInt(String key) throws IllegalArgumentException",
        "protected long _parseLong(String key) throws IllegalArgumentException",
        "protected double _parseDouble(String key) throws IllegalArgumentException",
        "protected Object _weirdKey(DeserializationContext ctxt, String key, Exception e) throws IOException",
        "public static StringKD forType(Class<?> nominalType)",
        "public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException",
        "public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException",
        "public Class<?> getKeyClass()",
        "public Object _parse(String key, DeserializationContext ctxt) throws IOException",
        "private EnumResolver _getToStringResolver(DeserializationContext ctxt)",
        "synchronized (this)",
        "public Object _parse(String key, DeserializationContext ctxt) throws Exception",
        "public Object _parse(String key, DeserializationContext ctxt) throws Exception"
      ],
      "methods": [
        {
          "buggy_method": "  public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n  if (key == null) { \n  return null;\n  }\n  try {\n  Object result = _parse(key, ctxt);\n  if (result != null) {\n  return result;\n  }\n  } catch (Exception re) {\n  return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\",\n  re.getClass().getName(),\n  re.getMessage());\n  }\n  if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n  return null;\n  }\n  return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n  }",
          "fixed_method": "  public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n  if (key == null) { \n  return null;\n  }\n  try {\n  Object result = _parse(key, ctxt);\n  if (result != null) {\n  return result;\n  }\n  } catch (Exception re) {\n  return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\",\n  re.getClass().getName(),\n  ClassUtil.exceptionMessage(re));\n  }\n  if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n  return null;\n  }\n  return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n  }",
          "diff": [
            "@@ -132,7 +132,7 @@",
            "         } catch (Exception re) {\n",
            "             return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\",\n",
            "                     re.getClass().getName(),\n",
            "-                    re.getMessage());\n",
            "+                    ClassUtil.exceptionMessage(re));\n",
            "         }\n",
            "         if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n",
            "             return null;\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  protected Object _weirdKey(DeserializationContext ctxt, String key, Exception e) throws IOException {\n  return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\",\n  e.getMessage());\n  }",
          "fixed_method": "  protected Object _weirdKey(DeserializationContext ctxt, String key, Exception e) throws IOException {\n  return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\",\n  ClassUtil.exceptionMessage(e));\n  }",
          "diff": [
            "@@ -259,7 +259,7 @@",
            "     // @since 2.9\n",
            "     protected Object _weirdKey(DeserializationContext ctxt, String key, Exception e) throws IOException {\n",
            "         return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\",\n",
            "-                e.getMessage());\n",
            "+                ClassUtil.exceptionMessage(e));\n",
            "     }\n",
            " \n",
            "     /*\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\n\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.deser.*;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedParameter;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedWithParams;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\n@JacksonStdImpl\npublic class StdValueInstantiator extends ValueInstantiator implements java.io.Serializable { private static final long serialVersionUID = 1L; protected final String _valueTypeDesc; protected final Class<?> _valueClass; protected AnnotatedWithParams _defaultCreator; protected AnnotatedWithParams _withArgsCreator; protected SettableBeanProperty[] _constructorArguments; protected JavaType _delegateType; protected AnnotatedWithParams _delegateCreator; protected SettableBeanProperty[] _delegateArguments; protected JavaType _arrayDelegateType; protected AnnotatedWithParams _arrayDelegateCreator; protected SettableBeanProperty[] _arrayDelegateArguments; protected AnnotatedWithParams _fromStringCreator; protected AnnotatedWithParams _fromIntCreator; protected AnnotatedWithParams _fromLongCreator; protected AnnotatedWithParams _fromDoubleCreator; protected AnnotatedWithParams _fromBooleanCreator; protected AnnotatedParameter _incompleteParameter; @Deprecated public StdValueInstantiator(DeserializationConfig config, Class<?> valueType) {\n        _valueTypeDesc = ClassUtil.nameOf(valueType);\n        _valueClass = (valueType == null) ? Object.class : valueType;\n    }\n\n    public StdValueInstantiator(DeserializationConfig config, JavaType valueType) {\n        _valueTypeDesc = (valueType == null) ? \"UNKNOWN TYPE\" : valueType.toString();\n        _valueClass = (valueType == null) ? Object.class : valueType.getRawClass();\n    }\n\n    \n    protected StdValueInstantiator(StdValueInstantiator src) {\n        _valueTypeDesc = src._valueTypeDesc;\n        _valueClass = src._valueClass;\n\n        _defaultCreator = src._defaultCreator;\n\n        _constructorArguments = src._constructorArguments;\n        _withArgsCreator = src._withArgsCreator;\n\n        _delegateType = src._delegateType;\n        _delegateCreator = src._delegateCreator;\n        _delegateArguments = src._delegateArguments;\n\n        _arrayDelegateType = src._arrayDelegateType;\n        _arrayDelegateCreator = src._arrayDelegateCreator;\n        _arrayDelegateArguments = src._arrayDelegateArguments;\n        \n        _fromStringCreator = src._fromStringCreator;\n        _fromIntCreator = src._fromIntCreator;\n        _fromLongCreator = src._fromLongCreator;\n        _fromDoubleCreator = src._fromDoubleCreator;\n        _fromBooleanCreator = src._fromBooleanCreator;\n    }\n\n    \n    public void configureFromObjectSettings(AnnotatedWithParams defaultCreator, AnnotatedWithParams delegateCreator, JavaType delegateType, SettableBeanProperty[] delegateArgs, AnnotatedWithParams withArgsCreator, SettableBeanProperty[] constructorArgs) {\n        _defaultCreator = defaultCreator;\n        _delegateCreator = delegateCreator;\n        _delegateType = delegateType;\n        _delegateArguments = delegateArgs;\n        _withArgsCreator = withArgsCreator;\n        _constructorArguments = constructorArgs;\n    }\n\n    public void configureFromArraySettings( AnnotatedWithParams arrayDelegateCreator, JavaType arrayDelegateType, SettableBeanProperty[] arrayDelegateArgs) {\n        _arrayDelegateCreator = arrayDelegateCreator;\n        _arrayDelegateType = arrayDelegateType;\n        _arrayDelegateArguments = arrayDelegateArgs;\n    }\n\n    public void configureFromStringCreator(AnnotatedWithParams creator) {\n        _fromStringCreator = creator;\n    }\n\n    public void configureFromIntCreator(AnnotatedWithParams creator) {\n        _fromIntCreator = creator;\n    }\n\n    public void configureFromLongCreator(AnnotatedWithParams creator) {\n        _fromLongCreator = creator;\n    }\n\n    public void configureFromDoubleCreator(AnnotatedWithParams creator) {\n        _fromDoubleCreator = creator;\n    }\n\n    public void configureFromBooleanCreator(AnnotatedWithParams creator) {\n        _fromBooleanCreator = creator;\n    }\n\n    public void configureIncompleteParameter(AnnotatedParameter parameter) {\n        _incompleteParameter = parameter;\n    }\n    \n    \n\n    @Override\n    public String getValueTypeDesc() {\n        return _valueTypeDesc;\n    }\n\n    @Override\n    public Class<?> getValueClass() {\n        return _valueClass;\n    }\n\n    @Override\n    public boolean canCreateFromString() {\n        return (_fromStringCreator != null);\n    }\n\n    @Override\n    public boolean canCreateFromInt() {\n        return (_fromIntCreator != null);\n    }\n\n    @Override\n    public boolean canCreateFromLong() {\n        return (_fromLongCreator != null);\n    }\n\n    @Override\n    public boolean canCreateFromDouble() {\n        return (_fromDoubleCreator != null);\n    }\n\n    @Override\n    public boolean canCreateFromBoolean() {\n        return (_fromBooleanCreator != null);\n    }\n\n    @Override\n    public boolean canCreateUsingDefault() {\n        return (_defaultCreator != null);\n    }\n\n    @Override\n    public boolean canCreateUsingDelegate() {\n        return (_delegateType != null);\n    }\n\n    @Override\n    public boolean canCreateUsingArrayDelegate() {\n        return (_arrayDelegateType != null);\n    }\n\n    @Override\n    public boolean canCreateFromObjectWith() {\n        return (_withArgsCreator != null);\n    }\n\n    @Override\n    public boolean canInstantiate() {\n        return canCreateUsingDefault()\n                || canCreateUsingDelegate() || canCreateUsingArrayDelegate()\n                || canCreateFromObjectWith() || canCreateFromString()\n                || canCreateFromInt() || canCreateFromLong()\n                || canCreateFromDouble() || canCreateFromBoolean();\n    }\n\n    @Override\n    public JavaType getDelegateType(DeserializationConfig config) {\n        return _delegateType;\n    }\n\n    @Override\n    public JavaType getArrayDelegateType(DeserializationConfig config) {\n        return _arrayDelegateType;\n    }\n\n    @Override\n    public SettableBeanProperty[] getFromObjectArguments(DeserializationConfig config) {\n        return _constructorArguments;\n    }\n    \n    \n    \n    @Override\n    public Object createUsingDefault(DeserializationContext ctxt) throws IOException {\n        if (_defaultCreator == null) { \n            return super.createUsingDefault(ctxt);\n        }\n        try {\n            return _defaultCreator.call();\n        } catch (Exception e) { \n            return ctxt.handleInstantiationProblem(_valueClass, null, rewrapCtorProblem(ctxt, e));\n        }\n    }\n\n    @Override\n    public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) throws IOException {\n        if (_withArgsCreator == null) { \n            return super.createFromObjectWith(ctxt, args);\n        }\n        try {\n            return _withArgsCreator.call(args);\n        } catch (Exception e) { \n            return ctxt.handleInstantiationProblem(_valueClass, args, rewrapCtorProblem(ctxt, e));\n        }\n    }\n\n    @Override\n    public Object createUsingDelegate(DeserializationContext ctxt, Object delegate) throws IOException {\n        \n        if (_delegateCreator == null) {\n            if (_arrayDelegateCreator != null) {\n                return _createUsingDelegate(_arrayDelegateCreator, _arrayDelegateArguments, ctxt, delegate);\n            }\n        }\n        return _createUsingDelegate(_delegateCreator, _delegateArguments, ctxt, delegate);\n    }\n\n    @Override\n    public Object createUsingArrayDelegate(DeserializationContext ctxt, Object delegate) throws IOException {\n        if (_arrayDelegateCreator == null) {\n            if (_delegateCreator != null) { \n                \n                return createUsingDelegate(ctxt, delegate);\n            }\n        }\n        return _createUsingDelegate(_arrayDelegateCreator, _arrayDelegateArguments, ctxt, delegate);\n    }\n\n    \n\n    @Override\n    public Object createFromString(DeserializationContext ctxt, String value) throws IOException {\n        if (_fromStringCreator == null) {\n            return _createFromStringFallbacks(ctxt, value);\n        }\n        try {\n            return _fromStringCreator.call1(value);\n        } catch (Throwable t) {\n            return ctxt.handleInstantiationProblem(_fromStringCreator.getDeclaringClass(),\n                    value, rewrapCtorProblem(ctxt, t));\n        }\n    }\n    \n    @Override\n    public Object createFromInt(DeserializationContext ctxt, int value) throws IOException {\n        \n        if (_fromIntCreator != null) {\n            Object arg = Integer.valueOf(value);\n            try {\n                return _fromIntCreator.call1(arg);\n            } catch (Throwable t0) {\n                return ctxt.handleInstantiationProblem(_fromIntCreator.getDeclaringClass(),\n                        arg, rewrapCtorProblem(ctxt, t0));\n            }\n        }\n        \n        if (_fromLongCreator != null) {\n            Object arg = Long.valueOf(value);\n            try {\n                return _fromLongCreator.call1(arg);\n            } catch (Throwable t0) {\n                return ctxt.handleInstantiationProblem(_fromLongCreator.getDeclaringClass(),\n                        arg, rewrapCtorProblem(ctxt, t0));\n            }\n        }\n        return super.createFromInt(ctxt, value);\n    }\n\n    @Override\n    public Object createFromLong(DeserializationContext ctxt, long value) throws IOException {\n        if (_fromLongCreator == null) {\n            return super.createFromLong(ctxt, value);\n        }\n        Object arg = Long.valueOf(value);\n        try {\n            return _fromLongCreator.call1(arg);\n        } catch (Throwable t0) {\n            return ctxt.handleInstantiationProblem(_fromLongCreator.getDeclaringClass(),\n                    arg, rewrapCtorProblem(ctxt, t0));\n        }\n    }\n\n    @Override\n    public Object createFromDouble(DeserializationContext ctxt, double value) throws IOException {\n        if (_fromDoubleCreator == null) {\n            return super.createFromDouble(ctxt, value);\n        }\n        Object arg = Double.valueOf(value);\n        try {\n            return _fromDoubleCreator.call1(arg);\n        } catch (Throwable t0) {\n            return ctxt.handleInstantiationProblem(_fromDoubleCreator.getDeclaringClass(),\n                    arg, rewrapCtorProblem(ctxt, t0));\n        }\n    }\n\n    @Override\n    public Object createFromBoolean(DeserializationContext ctxt, boolean value) throws IOException {\n        if (_fromBooleanCreator == null) {\n            return super.createFromBoolean(ctxt, value);\n        }\n        final Boolean arg = Boolean.valueOf(value);\n        try {\n            return _fromBooleanCreator.call1(arg);\n        } catch (Throwable t0) {\n            return ctxt.handleInstantiationProblem(_fromBooleanCreator.getDeclaringClass(),\n                    arg, rewrapCtorProblem(ctxt, t0));\n        }\n    }\n    \n    \n\n    @Override\n    public AnnotatedWithParams getDelegateCreator() {\n        return _delegateCreator;\n    }\n\n    @Override\n    public AnnotatedWithParams getArrayDelegateCreator() {\n        return _arrayDelegateCreator;\n    }\n\n    @Override\n    public AnnotatedWithParams getDefaultCreator() {\n        return _defaultCreator;\n    }\n\n    @Override\n    public AnnotatedWithParams getWithArgsCreator() {\n        return _withArgsCreator;\n    }\n\n    @Override\n    public AnnotatedParameter getIncompleteParameter() {\n        return _incompleteParameter;\n    }\n\n    \n\n    \n    @Deprecated \n    protected JsonMappingException wrapException(Throwable t) {\n        \n        \n        for (Throwable curr = t; curr != null; curr = curr.getCause()) {\n            if (curr instanceof JsonMappingException) {\n                return (JsonMappingException) curr;\n            }\n        }\n        return new JsonMappingException(null,\n                \"Instantiation of \"+getValueTypeDesc()+\" value failed: \"+t.getMessage(), t);\n    }\n\n    \n    protected JsonMappingException unwrapAndWrapException(DeserializationContext ctxt, Throwable t) {\n        \n        \n        for (Throwable curr = t; curr != null; curr = curr.getCause()) {\n            if (curr instanceof JsonMappingException) {\n                return (JsonMappingException) curr;\n            }\n        }\n        return ctxt.instantiationException(getValueClass(), t);\n    }\n\n    \n    protected JsonMappingException wrapAsJsonMappingException(DeserializationContext ctxt, Throwable t) {\n        \n        if (t instanceof JsonMappingException) {\n            return (JsonMappingException) t;\n        }\n        return ctxt.instantiationException(getValueClass(), t);\n    }\n\n    \n    protected JsonMappingException rewrapCtorProblem(DeserializationContext ctxt, Throwable t) {\n        \n        \n        if ((t instanceof ExceptionInInitializerError) \n                || (t instanceof InvocationTargetException) \n                ) {\n            Throwable cause = t.getCause();\n            if (cause != null) {\n                t = cause;\n            }\n        }\n        return wrapAsJsonMappingException(ctxt, t);\n    }\n\n    \n\n    private Object _createUsingDelegate(AnnotatedWithParams delegateCreator, SettableBeanProperty[] delegateArguments, DeserializationContext ctxt, Object delegate) throws IOException {\n        if (delegateCreator == null) { \n            throw new IllegalStateException(\"No delegate constructor for \"+getValueTypeDesc());\n        }\n        try {\n            \n            if (delegateArguments == null) {\n                return delegateCreator.call1(delegate);\n            }\n            \n            final int len = delegateArguments.length;\n            Object[] args = new Object[len];\n            for (int i = 0; i < len; ++i) {\n                SettableBeanProperty prop = delegateArguments[i];\n                if (prop == null) { \n                    args[i] = delegate;\n                } else { \n                    args[i] = ctxt.findInjectableValue(prop.getInjectableValueId(), prop, null);\n                }\n            }\n            \n            return delegateCreator.call(args);\n        } catch (Throwable t) {\n            throw rewrapCtorProblem(ctxt, t);\n        }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\n\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.deser.*;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedParameter;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedWithParams;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\n@JacksonStdImpl\npublic class StdValueInstantiator extends ValueInstantiator implements java.io.Serializable { private static final long serialVersionUID = 1L; protected final String _valueTypeDesc; protected final Class<?> _valueClass; protected AnnotatedWithParams _defaultCreator; protected AnnotatedWithParams _withArgsCreator; protected SettableBeanProperty[] _constructorArguments; protected JavaType _delegateType; protected AnnotatedWithParams _delegateCreator; protected SettableBeanProperty[] _delegateArguments; protected JavaType _arrayDelegateType; protected AnnotatedWithParams _arrayDelegateCreator; protected SettableBeanProperty[] _arrayDelegateArguments; protected AnnotatedWithParams _fromStringCreator; protected AnnotatedWithParams _fromIntCreator; protected AnnotatedWithParams _fromLongCreator; protected AnnotatedWithParams _fromDoubleCreator; protected AnnotatedWithParams _fromBooleanCreator; protected AnnotatedParameter _incompleteParameter; @Deprecated public StdValueInstantiator(DeserializationConfig config, Class<?> valueType) {\n        _valueTypeDesc = ClassUtil.nameOf(valueType);\n        _valueClass = (valueType == null) ? Object.class : valueType;\n    }\n\n    public StdValueInstantiator(DeserializationConfig config, JavaType valueType) {\n        _valueTypeDesc = (valueType == null) ? \"UNKNOWN TYPE\" : valueType.toString();\n        _valueClass = (valueType == null) ? Object.class : valueType.getRawClass();\n    }\n\n    \n    protected StdValueInstantiator(StdValueInstantiator src) {\n        _valueTypeDesc = src._valueTypeDesc;\n        _valueClass = src._valueClass;\n\n        _defaultCreator = src._defaultCreator;\n\n        _constructorArguments = src._constructorArguments;\n        _withArgsCreator = src._withArgsCreator;\n\n        _delegateType = src._delegateType;\n        _delegateCreator = src._delegateCreator;\n        _delegateArguments = src._delegateArguments;\n\n        _arrayDelegateType = src._arrayDelegateType;\n        _arrayDelegateCreator = src._arrayDelegateCreator;\n        _arrayDelegateArguments = src._arrayDelegateArguments;\n        \n        _fromStringCreator = src._fromStringCreator;\n        _fromIntCreator = src._fromIntCreator;\n        _fromLongCreator = src._fromLongCreator;\n        _fromDoubleCreator = src._fromDoubleCreator;\n        _fromBooleanCreator = src._fromBooleanCreator;\n    }\n\n    \n    public void configureFromObjectSettings(AnnotatedWithParams defaultCreator, AnnotatedWithParams delegateCreator, JavaType delegateType, SettableBeanProperty[] delegateArgs, AnnotatedWithParams withArgsCreator, SettableBeanProperty[] constructorArgs) {\n        _defaultCreator = defaultCreator;\n        _delegateCreator = delegateCreator;\n        _delegateType = delegateType;\n        _delegateArguments = delegateArgs;\n        _withArgsCreator = withArgsCreator;\n        _constructorArguments = constructorArgs;\n    }\n\n    public void configureFromArraySettings( AnnotatedWithParams arrayDelegateCreator, JavaType arrayDelegateType, SettableBeanProperty[] arrayDelegateArgs) {\n        _arrayDelegateCreator = arrayDelegateCreator;\n        _arrayDelegateType = arrayDelegateType;\n        _arrayDelegateArguments = arrayDelegateArgs;\n    }\n\n    public void configureFromStringCreator(AnnotatedWithParams creator) {\n        _fromStringCreator = creator;\n    }\n\n    public void configureFromIntCreator(AnnotatedWithParams creator) {\n        _fromIntCreator = creator;\n    }\n\n    public void configureFromLongCreator(AnnotatedWithParams creator) {\n        _fromLongCreator = creator;\n    }\n\n    public void configureFromDoubleCreator(AnnotatedWithParams creator) {\n        _fromDoubleCreator = creator;\n    }\n\n    public void configureFromBooleanCreator(AnnotatedWithParams creator) {\n        _fromBooleanCreator = creator;\n    }\n\n    public void configureIncompleteParameter(AnnotatedParameter parameter) {\n        _incompleteParameter = parameter;\n    }\n    \n    \n\n    @Override\n    public String getValueTypeDesc() {\n        return _valueTypeDesc;\n    }\n\n    @Override\n    public Class<?> getValueClass() {\n        return _valueClass;\n    }\n\n    @Override\n    public boolean canCreateFromString() {\n        return (_fromStringCreator != null);\n    }\n\n    @Override\n    public boolean canCreateFromInt() {\n        return (_fromIntCreator != null);\n    }\n\n    @Override\n    public boolean canCreateFromLong() {\n        return (_fromLongCreator != null);\n    }\n\n    @Override\n    public boolean canCreateFromDouble() {\n        return (_fromDoubleCreator != null);\n    }\n\n    @Override\n    public boolean canCreateFromBoolean() {\n        return (_fromBooleanCreator != null);\n    }\n\n    @Override\n    public boolean canCreateUsingDefault() {\n        return (_defaultCreator != null);\n    }\n\n    @Override\n    public boolean canCreateUsingDelegate() {\n        return (_delegateType != null);\n    }\n\n    @Override\n    public boolean canCreateUsingArrayDelegate() {\n        return (_arrayDelegateType != null);\n    }\n\n    @Override\n    public boolean canCreateFromObjectWith() {\n        return (_withArgsCreator != null);\n    }\n\n    @Override\n    public boolean canInstantiate() {\n        return canCreateUsingDefault()\n                || canCreateUsingDelegate() || canCreateUsingArrayDelegate()\n                || canCreateFromObjectWith() || canCreateFromString()\n                || canCreateFromInt() || canCreateFromLong()\n                || canCreateFromDouble() || canCreateFromBoolean();\n    }\n\n    @Override\n    public JavaType getDelegateType(DeserializationConfig config) {\n        return _delegateType;\n    }\n\n    @Override\n    public JavaType getArrayDelegateType(DeserializationConfig config) {\n        return _arrayDelegateType;\n    }\n\n    @Override\n    public SettableBeanProperty[] getFromObjectArguments(DeserializationConfig config) {\n        return _constructorArguments;\n    }\n    \n    \n    \n    @Override\n    public Object createUsingDefault(DeserializationContext ctxt) throws IOException {\n        if (_defaultCreator == null) { \n            return super.createUsingDefault(ctxt);\n        }\n        try {\n            return _defaultCreator.call();\n        } catch (Exception e) { \n            return ctxt.handleInstantiationProblem(_valueClass, null, rewrapCtorProblem(ctxt, e));\n        }\n    }\n\n    @Override\n    public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) throws IOException {\n        if (_withArgsCreator == null) { \n            return super.createFromObjectWith(ctxt, args);\n        }\n        try {\n            return _withArgsCreator.call(args);\n        } catch (Exception e) { \n            return ctxt.handleInstantiationProblem(_valueClass, args, rewrapCtorProblem(ctxt, e));\n        }\n    }\n\n    @Override\n    public Object createUsingDelegate(DeserializationContext ctxt, Object delegate) throws IOException {\n        \n        if (_delegateCreator == null) {\n            if (_arrayDelegateCreator != null) {\n                return _createUsingDelegate(_arrayDelegateCreator, _arrayDelegateArguments, ctxt, delegate);\n            }\n        }\n        return _createUsingDelegate(_delegateCreator, _delegateArguments, ctxt, delegate);\n    }\n\n    @Override\n    public Object createUsingArrayDelegate(DeserializationContext ctxt, Object delegate) throws IOException {\n        if (_arrayDelegateCreator == null) {\n            if (_delegateCreator != null) { \n                \n                return createUsingDelegate(ctxt, delegate);\n            }\n        }\n        return _createUsingDelegate(_arrayDelegateCreator, _arrayDelegateArguments, ctxt, delegate);\n    }\n\n    \n\n    @Override\n    public Object createFromString(DeserializationContext ctxt, String value) throws IOException {\n        if (_fromStringCreator == null) {\n            return _createFromStringFallbacks(ctxt, value);\n        }\n        try {\n            return _fromStringCreator.call1(value);\n        } catch (Throwable t) {\n            return ctxt.handleInstantiationProblem(_fromStringCreator.getDeclaringClass(),\n                    value, rewrapCtorProblem(ctxt, t));\n        }\n    }\n    \n    @Override\n    public Object createFromInt(DeserializationContext ctxt, int value) throws IOException {\n        \n        if (_fromIntCreator != null) {\n            Object arg = Integer.valueOf(value);\n            try {\n                return _fromIntCreator.call1(arg);\n            } catch (Throwable t0) {\n                return ctxt.handleInstantiationProblem(_fromIntCreator.getDeclaringClass(),\n                        arg, rewrapCtorProblem(ctxt, t0));\n            }\n        }\n        \n        if (_fromLongCreator != null) {\n            Object arg = Long.valueOf(value);\n            try {\n                return _fromLongCreator.call1(arg);\n            } catch (Throwable t0) {\n                return ctxt.handleInstantiationProblem(_fromLongCreator.getDeclaringClass(),\n                        arg, rewrapCtorProblem(ctxt, t0));\n            }\n        }\n        return super.createFromInt(ctxt, value);\n    }\n\n    @Override\n    public Object createFromLong(DeserializationContext ctxt, long value) throws IOException {\n        if (_fromLongCreator == null) {\n            return super.createFromLong(ctxt, value);\n        }\n        Object arg = Long.valueOf(value);\n        try {\n            return _fromLongCreator.call1(arg);\n        } catch (Throwable t0) {\n            return ctxt.handleInstantiationProblem(_fromLongCreator.getDeclaringClass(),\n                    arg, rewrapCtorProblem(ctxt, t0));\n        }\n    }\n\n    @Override\n    public Object createFromDouble(DeserializationContext ctxt, double value) throws IOException {\n        if (_fromDoubleCreator == null) {\n            return super.createFromDouble(ctxt, value);\n        }\n        Object arg = Double.valueOf(value);\n        try {\n            return _fromDoubleCreator.call1(arg);\n        } catch (Throwable t0) {\n            return ctxt.handleInstantiationProblem(_fromDoubleCreator.getDeclaringClass(),\n                    arg, rewrapCtorProblem(ctxt, t0));\n        }\n    }\n\n    @Override\n    public Object createFromBoolean(DeserializationContext ctxt, boolean value) throws IOException {\n        if (_fromBooleanCreator == null) {\n            return super.createFromBoolean(ctxt, value);\n        }\n        final Boolean arg = Boolean.valueOf(value);\n        try {\n            return _fromBooleanCreator.call1(arg);\n        } catch (Throwable t0) {\n            return ctxt.handleInstantiationProblem(_fromBooleanCreator.getDeclaringClass(),\n                    arg, rewrapCtorProblem(ctxt, t0));\n        }\n    }\n    \n    \n\n    @Override\n    public AnnotatedWithParams getDelegateCreator() {\n        return _delegateCreator;\n    }\n\n    @Override\n    public AnnotatedWithParams getArrayDelegateCreator() {\n        return _arrayDelegateCreator;\n    }\n\n    @Override\n    public AnnotatedWithParams getDefaultCreator() {\n        return _defaultCreator;\n    }\n\n    @Override\n    public AnnotatedWithParams getWithArgsCreator() {\n        return _withArgsCreator;\n    }\n\n    @Override\n    public AnnotatedParameter getIncompleteParameter() {\n        return _incompleteParameter;\n    }\n\n    \n\n    \n    @Deprecated \n    protected JsonMappingException wrapException(Throwable t) {\n        \n        \n        for (Throwable curr = t; curr != null; curr = curr.getCause()) {\n            if (curr instanceof JsonMappingException) {\n                return (JsonMappingException) curr;\n            }\n        }\n        return new JsonMappingException(null,\n                \"Instantiation of \"+getValueTypeDesc()+\" value failed: \"+ClassUtil.exceptionMessage(t), t);\n    }\n\n    \n    protected JsonMappingException unwrapAndWrapException(DeserializationContext ctxt, Throwable t) {\n        \n        \n        for (Throwable curr = t; curr != null; curr = curr.getCause()) {\n            if (curr instanceof JsonMappingException) {\n                return (JsonMappingException) curr;\n            }\n        }\n        return ctxt.instantiationException(getValueClass(), t);\n    }\n\n    \n    protected JsonMappingException wrapAsJsonMappingException(DeserializationContext ctxt, Throwable t) {\n        \n        if (t instanceof JsonMappingException) {\n            return (JsonMappingException) t;\n        }\n        return ctxt.instantiationException(getValueClass(), t);\n    }\n\n    \n    protected JsonMappingException rewrapCtorProblem(DeserializationContext ctxt, Throwable t) {\n        \n        \n        if ((t instanceof ExceptionInInitializerError) \n                || (t instanceof InvocationTargetException) \n                ) {\n            Throwable cause = t.getCause();\n            if (cause != null) {\n                t = cause;\n            }\n        }\n        return wrapAsJsonMappingException(ctxt, t);\n    }\n\n    \n\n    private Object _createUsingDelegate(AnnotatedWithParams delegateCreator, SettableBeanProperty[] delegateArguments, DeserializationContext ctxt, Object delegate) throws IOException {\n        if (delegateCreator == null) { \n            throw new IllegalStateException(\"No delegate constructor for \"+getValueTypeDesc());\n        }\n        try {\n            \n            if (delegateArguments == null) {\n                return delegateCreator.call1(delegate);\n            }\n            \n            final int len = delegateArguments.length;\n            Object[] args = new Object[len];\n            for (int i = 0; i < len; ++i) {\n                SettableBeanProperty prop = delegateArguments[i];\n                if (prop == null) { \n                    args[i] = delegate;\n                } else { \n                    args[i] = ctxt.findInjectableValue(prop.getInjectableValueId(), prop, null);\n                }\n            }\n            \n            return delegateCreator.call(args);\n        } catch (Throwable t) {\n            throw rewrapCtorProblem(ctxt, t);\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public StdValueInstantiator(DeserializationConfig config, JavaType valueType)",
        "protected StdValueInstantiator(StdValueInstantiator src)",
        "public void configureFromObjectSettings(AnnotatedWithParams defaultCreator, AnnotatedWithParams delegateCreator, JavaType delegateType, SettableBeanProperty[] delegateArgs, AnnotatedWithParams withArgsCreator, SettableBeanProperty[] constructorArgs)",
        "public void configureFromArraySettings( AnnotatedWithParams arrayDelegateCreator, JavaType arrayDelegateType, SettableBeanProperty[] arrayDelegateArgs)",
        "public void configureFromStringCreator(AnnotatedWithParams creator)",
        "public void configureFromIntCreator(AnnotatedWithParams creator)",
        "public void configureFromLongCreator(AnnotatedWithParams creator)",
        "public void configureFromDoubleCreator(AnnotatedWithParams creator)",
        "public void configureFromBooleanCreator(AnnotatedWithParams creator)",
        "public void configureIncompleteParameter(AnnotatedParameter parameter)",
        "public String getValueTypeDesc()",
        "public Class<?> getValueClass()",
        "public boolean canCreateFromString()",
        "public boolean canCreateFromInt()",
        "public boolean canCreateFromLong()",
        "public boolean canCreateFromDouble()",
        "public boolean canCreateFromBoolean()",
        "public boolean canCreateUsingDefault()",
        "public boolean canCreateUsingDelegate()",
        "public boolean canCreateUsingArrayDelegate()",
        "public boolean canCreateFromObjectWith()",
        "public boolean canInstantiate()",
        "public JavaType getDelegateType(DeserializationConfig config)",
        "public JavaType getArrayDelegateType(DeserializationConfig config)",
        "public SettableBeanProperty[] getFromObjectArguments(DeserializationConfig config)",
        "public Object createUsingDefault(DeserializationContext ctxt) throws IOException",
        "public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) throws IOException",
        "public Object createUsingDelegate(DeserializationContext ctxt, Object delegate) throws IOException",
        "public Object createUsingArrayDelegate(DeserializationContext ctxt, Object delegate) throws IOException",
        "public Object createFromString(DeserializationContext ctxt, String value) throws IOException",
        "public Object createFromInt(DeserializationContext ctxt, int value) throws IOException",
        "public Object createFromLong(DeserializationContext ctxt, long value) throws IOException",
        "public Object createFromDouble(DeserializationContext ctxt, double value) throws IOException",
        "public Object createFromBoolean(DeserializationContext ctxt, boolean value) throws IOException",
        "public AnnotatedWithParams getDelegateCreator()",
        "public AnnotatedWithParams getArrayDelegateCreator()",
        "public AnnotatedWithParams getDefaultCreator()",
        "public AnnotatedWithParams getWithArgsCreator()",
        "public AnnotatedParameter getIncompleteParameter()",
        "protected JsonMappingException wrapException(Throwable t)",
        "protected JsonMappingException unwrapAndWrapException(DeserializationContext ctxt, Throwable t)",
        "protected JsonMappingException wrapAsJsonMappingException(DeserializationContext ctxt, Throwable t)",
        "protected JsonMappingException rewrapCtorProblem(DeserializationContext ctxt, Throwable t)",
        "private Object _createUsingDelegate(AnnotatedWithParams delegateCreator, SettableBeanProperty[] delegateArguments, DeserializationContext ctxt, Object delegate) throws IOException"
      ],
      "fixed_signatures": [
        "public StdValueInstantiator(DeserializationConfig config, JavaType valueType)",
        "protected StdValueInstantiator(StdValueInstantiator src)",
        "public void configureFromObjectSettings(AnnotatedWithParams defaultCreator, AnnotatedWithParams delegateCreator, JavaType delegateType, SettableBeanProperty[] delegateArgs, AnnotatedWithParams withArgsCreator, SettableBeanProperty[] constructorArgs)",
        "public void configureFromArraySettings( AnnotatedWithParams arrayDelegateCreator, JavaType arrayDelegateType, SettableBeanProperty[] arrayDelegateArgs)",
        "public void configureFromStringCreator(AnnotatedWithParams creator)",
        "public void configureFromIntCreator(AnnotatedWithParams creator)",
        "public void configureFromLongCreator(AnnotatedWithParams creator)",
        "public void configureFromDoubleCreator(AnnotatedWithParams creator)",
        "public void configureFromBooleanCreator(AnnotatedWithParams creator)",
        "public void configureIncompleteParameter(AnnotatedParameter parameter)",
        "public String getValueTypeDesc()",
        "public Class<?> getValueClass()",
        "public boolean canCreateFromString()",
        "public boolean canCreateFromInt()",
        "public boolean canCreateFromLong()",
        "public boolean canCreateFromDouble()",
        "public boolean canCreateFromBoolean()",
        "public boolean canCreateUsingDefault()",
        "public boolean canCreateUsingDelegate()",
        "public boolean canCreateUsingArrayDelegate()",
        "public boolean canCreateFromObjectWith()",
        "public boolean canInstantiate()",
        "public JavaType getDelegateType(DeserializationConfig config)",
        "public JavaType getArrayDelegateType(DeserializationConfig config)",
        "public SettableBeanProperty[] getFromObjectArguments(DeserializationConfig config)",
        "public Object createUsingDefault(DeserializationContext ctxt) throws IOException",
        "public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) throws IOException",
        "public Object createUsingDelegate(DeserializationContext ctxt, Object delegate) throws IOException",
        "public Object createUsingArrayDelegate(DeserializationContext ctxt, Object delegate) throws IOException",
        "public Object createFromString(DeserializationContext ctxt, String value) throws IOException",
        "public Object createFromInt(DeserializationContext ctxt, int value) throws IOException",
        "public Object createFromLong(DeserializationContext ctxt, long value) throws IOException",
        "public Object createFromDouble(DeserializationContext ctxt, double value) throws IOException",
        "public Object createFromBoolean(DeserializationContext ctxt, boolean value) throws IOException",
        "public AnnotatedWithParams getDelegateCreator()",
        "public AnnotatedWithParams getArrayDelegateCreator()",
        "public AnnotatedWithParams getDefaultCreator()",
        "public AnnotatedWithParams getWithArgsCreator()",
        "public AnnotatedParameter getIncompleteParameter()",
        "protected JsonMappingException wrapException(Throwable t)",
        "protected JsonMappingException unwrapAndWrapException(DeserializationContext ctxt, Throwable t)",
        "protected JsonMappingException wrapAsJsonMappingException(DeserializationContext ctxt, Throwable t)",
        "protected JsonMappingException rewrapCtorProblem(DeserializationContext ctxt, Throwable t)",
        "private Object _createUsingDelegate(AnnotatedWithParams delegateCreator, SettableBeanProperty[] delegateArguments, DeserializationContext ctxt, Object delegate) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  protected JsonMappingException wrapException(Throwable t) {\n  \n  \n  for (Throwable curr = t; curr != null; curr = curr.getCause()) {\n  if (curr instanceof JsonMappingException) {\n  return (JsonMappingException) curr;\n  }\n  }\n  return new JsonMappingException(null,\n  \"Instantiation of \"+getValueTypeDesc()+\" value failed: \"+t.getMessage(), t);\n  }",
          "fixed_method": "  protected JsonMappingException wrapException(Throwable t) {\n  \n  \n  for (Throwable curr = t; curr != null; curr = curr.getCause()) {\n  if (curr instanceof JsonMappingException) {\n  return (JsonMappingException) curr;\n  }\n  }\n  return new JsonMappingException(null,\n  \"Instantiation of \"+getValueTypeDesc()+\" value failed: \"+ClassUtil.exceptionMessage(t), t);\n  }",
          "diff": [
            "@@ -453,7 +453,7 @@",
            "             }\n",
            "         }\n",
            "         return new JsonMappingException(null,\n",
            "-                \"Instantiation of \"+getValueTypeDesc()+\" value failed: \"+t.getMessage(), t);\n",
            "+                \"Instantiation of \"+getValueTypeDesc()+\" value failed: \"+ClassUtil.exceptionMessage(t), t);\n",
            "     }\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.introspect;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.JsonInclude;\n\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.type.TypeBindings;\nimport com.fasterxml.jackson.databind.util.Annotations;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.Converter;\n\n\npublic class BasicBeanDescription extends BeanDescription { private final static Class<?>[] NO_VIEWS = new Class<?>[0]; final protected POJOPropertiesCollector _propCollector; final protected MapperConfig<?> _config; final protected AnnotationIntrospector _annotationIntrospector; final protected AnnotatedClass _classInfo; protected Class<?>[] _defaultViews; protected boolean _defaultViewsResolved; protected List<BeanPropertyDefinition> _properties; protected ObjectIdInfo _objectIdInfo; protected BasicBeanDescription(POJOPropertiesCollector coll, JavaType type, AnnotatedClass classDef) {\n        super(type);\n        _propCollector = coll;\n        _config = coll.getConfig();\n        \n        if (_config == null) {\n            _annotationIntrospector = null;\n        } else {\n            _annotationIntrospector = _config.getAnnotationIntrospector();\n        }\n        _classInfo = classDef;\n    }\n\n    \n    protected BasicBeanDescription(MapperConfig<?> config, JavaType type, AnnotatedClass classDef, List<BeanPropertyDefinition> props) {\n        super(type);\n        _propCollector = null;\n        _config = config;\n        \n        if (_config == null) {\n            _annotationIntrospector = null;\n        } else {\n            _annotationIntrospector = _config.getAnnotationIntrospector();\n        }\n        _classInfo = classDef;\n        _properties = props;\n    }\n    \n    protected BasicBeanDescription(POJOPropertiesCollector coll) {\n        this(coll, coll.getType(), coll.getClassDef());\n        _objectIdInfo = coll.getObjectIdInfo();\n    }\n\n    \n    public static BasicBeanDescription forDeserialization(POJOPropertiesCollector coll) {\n        return new BasicBeanDescription(coll);\n    }\n\n    \n    public static BasicBeanDescription forSerialization(POJOPropertiesCollector coll) {\n        return new BasicBeanDescription(coll);\n    }\n\n    \n    public static BasicBeanDescription forOtherUse(MapperConfig<?> config, JavaType type, AnnotatedClass ac) {\n        return new BasicBeanDescription(config, type,\n                ac, Collections.<BeanPropertyDefinition>emptyList());\n    }\n\n    protected List<BeanPropertyDefinition> _properties() {\n        if (_properties == null) {\n            _properties = _propCollector.getProperties();\n        }\n        return _properties;\n    }\n\n    \n\n    \n    public boolean removeProperty(String propName) {\n        Iterator<BeanPropertyDefinition> it = _properties().iterator();\n        while (it.hasNext()) {\n            BeanPropertyDefinition prop = it.next();\n            if (prop.getName().equals(propName)) {\n                it.remove();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean addProperty(BeanPropertyDefinition def) {\n        \n        if (hasProperty(def.getFullName())) {\n            return false;\n        }\n        _properties().add(def);\n        return true;\n    }\n    \n    \n    public boolean hasProperty(PropertyName name) {\n        return findProperty(name) != null;\n    }\n    \n    \n    public BeanPropertyDefinition findProperty(PropertyName name) {\n        for (BeanPropertyDefinition prop : _properties()) {\n            if (prop.hasName(name)) {\n                return prop;\n            }\n        }\n        return null;\n    }\n    \n    \n\n    @Override\n    public AnnotatedClass getClassInfo() { return _classInfo; }\n\n    @Override\n    public ObjectIdInfo getObjectIdInfo() { return  _objectIdInfo; }\n\n    @Override\n    public List<BeanPropertyDefinition> findProperties() {\n        return _properties();\n    }\n\n    @Override\n    @Deprecated \n    public AnnotatedMethod findJsonValueMethod() {\n        return (_propCollector == null) ? null\n                : _propCollector.getJsonValueMethod();\n    }\n\n    @Override \n    public AnnotatedMember findJsonValueAccessor() {\n        return (_propCollector == null) ? null\n                : _propCollector.getJsonValueAccessor();\n    }\n \n    @Override\n    public Set<String> getIgnoredPropertyNames() {\n        Set<String> ign = (_propCollector == null) ? null\n                : _propCollector.getIgnoredPropertyNames();\n        if (ign == null) {\n            return Collections.emptySet();\n        }\n        return ign;\n    }\n\n    @Override\n    public boolean hasKnownClassAnnotations() {\n        return _classInfo.hasAnnotations();\n    }\n\n    @Override\n    public Annotations getClassAnnotations() {\n        return _classInfo.getAnnotations();\n    }\n\n    @Override\n    @Deprecated \n    public TypeBindings bindingsForBeanType() {\n        return _type.getBindings();\n    }\n\n    @Override\n    @Deprecated \n    public JavaType resolveType(java.lang.reflect.Type jdkType) {\n        if (jdkType == null) {\n            return null;\n        }\n        return _config.getTypeFactory().constructType(jdkType, _type.getBindings());\n    }\n\n    @Override\n    public AnnotatedConstructor findDefaultConstructor() {\n        return _classInfo.getDefaultConstructor();\n    }\n\n    @Override\n    public AnnotatedMember findAnySetterAccessor() throws IllegalArgumentException {\n        if (_propCollector != null) {\n            AnnotatedMethod anyMethod = _propCollector.getAnySetterMethod();\n            if (anyMethod != null) {\n                \n                \n    \n                \n                Class<?> type = anyMethod.getRawParameterType(0);\n                if ((type != String.class) && (type != Object.class)) {\n                    throw new IllegalArgumentException(String.format(\n\"Invalid 'any-setter' annotation on method '%s()': first argument not of type String or Object, but %s\",\nanyMethod.getName(), type.getName()));\n                }\n                return anyMethod;\n            }\n            AnnotatedMember anyField = _propCollector.getAnySetterField();\n            if (anyField != null) {\n                \n                \n                Class<?> type = anyField.getRawType();\n                if (!Map.class.isAssignableFrom(type)) {\n                    throw new IllegalArgumentException(String.format(\n\"Invalid 'any-setter' annotation on field '%s': type is not instance of java.util.Map\",\nanyField.getName()));\n                }\n                return anyField;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Map<Object, AnnotatedMember> findInjectables() {\n        if (_propCollector != null) {\n            return _propCollector.getInjectables();\n        }\n        return Collections.emptyMap();\n    }\n\n    @Override\n    public List<AnnotatedConstructor> getConstructors() {\n        return _classInfo.getConstructors();\n    }\n\n    @Override\n    public Object instantiateBean(boolean fixAccess) {\n        AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n        if (ac == null) {\n            return null;\n        }\n        if (fixAccess) {\n            ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n        try {\n            return ac.getAnnotated().newInstance();\n        } catch (Exception e) {\n            Throwable t = e;\n            while (t.getCause() != null) {\n                t = t.getCause();\n            }\n            ClassUtil.throwIfError(t);\n            ClassUtil.throwIfRTE(t);\n            throw new IllegalArgumentException(\"Failed to instantiate bean of type \"\n                    +_classInfo.getAnnotated().getName()+\": (\"+t.getClass().getName()+\") \"\n                    +t.getMessage(), t);\n        }\n    }\n\n    \n\n    @Override\n    public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes) {\n        return _classInfo.findMethod(name, paramTypes);\n    }\n\n    \n\n    @Override\n    public JsonFormat.Value findExpectedFormat(JsonFormat.Value defValue) {\n        \n        \n        if (_annotationIntrospector != null) {\n            JsonFormat.Value v = _annotationIntrospector.findFormat(_classInfo);\n            if (v != null) {\n                if (defValue == null) {\n                    defValue = v;\n                } else {\n                    defValue = defValue.withOverrides(v);\n                }\n            }\n        }\n        JsonFormat.Value v = _config.getDefaultPropertyFormat(_classInfo.getRawType());\n        if (v != null) {\n            if (defValue == null) {\n                defValue = v;\n            } else {\n                defValue = defValue.withOverrides(v);\n            }\n        }\n        return defValue;\n    }\n\n    @Override \n    public Class<?>[] findDefaultViews() {\n        if (!_defaultViewsResolved) {\n            _defaultViewsResolved = true;\n            Class<?>[] def = (_annotationIntrospector == null) ? null\n                    : _annotationIntrospector.findViews(_classInfo);\n            \n            if (def == null) {\n                if (!_config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                    def = NO_VIEWS;\n                }\n            }\n            _defaultViews = def;\n        }\n        return _defaultViews;\n    }\n\n    \n\n    @Override\n    public Converter<Object,Object> findSerializationConverter() {\n        if (_annotationIntrospector == null) {\n            return null;\n        }\n        return _createConverter(_annotationIntrospector.findSerializationConverter(_classInfo));\n    }\n\n    \n    @Override\n    public JsonInclude.Value findPropertyInclusion(JsonInclude.Value defValue) {\n        if (_annotationIntrospector != null) {\n            JsonInclude.Value incl = _annotationIntrospector.findPropertyInclusion(_classInfo);\n            if (incl != null) {\n                return (defValue == null) ? incl : defValue.withOverrides(incl);\n            }\n        }\n        return defValue;\n    }\n\n    \n    @Override\n    public AnnotatedMember findAnyGetter() throws IllegalArgumentException {\n        AnnotatedMember anyGetter = (_propCollector == null) ? null\n                : _propCollector.getAnyGetter();\n        if (anyGetter != null) {\n            \n            Class<?> type = anyGetter.getRawType();\n            if (!Map.class.isAssignableFrom(type)) {\n                throw new IllegalArgumentException(\"Invalid 'any-getter' annotation on method \"+anyGetter.getName()+\"(): return type is not instance of java.util.Map\");\n            }\n        }\n        return anyGetter;\n    }\n\n    @Override\n    public List<BeanPropertyDefinition> findBackReferences() {\n        List<BeanPropertyDefinition> result = null;\n        HashSet<String> names = null;\n        for (BeanPropertyDefinition property : _properties()) {\n            AnnotationIntrospector.ReferenceProperty refDef = property.findReferenceType();\n            if ((refDef == null) || !refDef.isBackReference()) {\n                continue;\n            }\n            final String refName = refDef.getName();\n            if (result == null) {\n                result = new ArrayList<BeanPropertyDefinition>();\n                names = new HashSet<>();\n                names.add(refName);\n            } else {\n                if (!names.add(refName)) {\n                    throw new IllegalArgumentException(\"Multiple back-reference properties with name '\"+refName+\"'\");\n                }\n            }\n            result.add(property);\n        }\n        return result;\n    }\n\n    @Deprecated \n    @Override\n    public Map<String,AnnotatedMember> findBackReferenceProperties() {\n        List<BeanPropertyDefinition> props = findBackReferences();\n        if (props == null) {\n            return null;\n        }\n        Map<String,AnnotatedMember> result = new HashMap<>();\n        for (BeanPropertyDefinition prop : props) {\n            result.put(prop.getName(), prop.getMutator());\n        }\n        return result;\n    }\n\n    \n\n    @Override\n    public List<AnnotatedMethod> getFactoryMethods() {\n        \n        List<AnnotatedMethod> candidates = _classInfo.getFactoryMethods();\n        if (candidates.isEmpty()) {\n            return candidates;\n        }\n        List<AnnotatedMethod> result = null;\n        for (AnnotatedMethod am : candidates) {\n            if (isFactoryMethod(am)) {\n                if (result == null) {\n                    result = new ArrayList<AnnotatedMethod>();\n                }\n                result.add(am);\n            }\n        }\n        if (result == null) {\n            return Collections.emptyList();\n        }\n        return result;\n    }\n\n    @Override\n    public Constructor<?> findSingleArgConstructor(Class<?>... argTypes) {\n        for (AnnotatedConstructor ac : _classInfo.getConstructors()) {\n            \n            \n            if (ac.getParameterCount() == 1) {\n                Class<?> actArg = ac.getRawParameterType(0);\n                for (Class<?> expArg : argTypes) {\n                    if (expArg == actArg) {\n                        return ac.getAnnotated();\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Method findFactoryMethod(Class<?>... expArgTypes) {\n        \n        for (AnnotatedMethod am : _classInfo.getFactoryMethods()) {\n            \n            if (isFactoryMethod(am) && am.getParameterCount() == 1) {\n                \n                Class<?> actualArgType = am.getRawParameterType(0);\n                for (Class<?> expArgType : expArgTypes) {\n                    \n                    if (actualArgType.isAssignableFrom(expArgType)) {\n                        return am.getAnnotated();\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    protected boolean isFactoryMethod(AnnotatedMethod am) {\n        \n        \n        Class<?> rt = am.getRawReturnType();\n        if (!getBeanClass().isAssignableFrom(rt)) {\n            return false;\n        }\n        \n        JsonCreator.Mode mode = _annotationIntrospector.findCreatorAnnotation(_config, am);\n        if ((mode != null) && (mode != JsonCreator.Mode.DISABLED)) {\n            return true;\n        }\n        final String name = am.getName();\n        \n        if (\"valueOf\".equals(name)) {\n            if (am.getParameterCount() == 1) {\n                return true;\n            }\n        }\n        \n        if (\"fromString\".equals(name)) {\n            if (am.getParameterCount() == 1) {\n                Class<?> cls = am.getRawParameterType(0);\n                if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    \n    @Deprecated \n    protected PropertyName _findCreatorPropertyName(AnnotatedParameter param) {\n        PropertyName name = _annotationIntrospector.findNameForDeserialization(param);\n        if (name == null || name.isEmpty()) {\n            String str = _annotationIntrospector.findImplicitPropertyName(param);\n            if (str != null && !str.isEmpty()) {\n                name = PropertyName.construct(str);\n            }\n        }\n        return name;\n    }\n\n    \n\n    @Override\n    public Class<?> findPOJOBuilder() {\n        return (_annotationIntrospector == null) ?\n    \t\t\tnull : _annotationIntrospector.findPOJOBuilder(_classInfo);\n    }\n\n    @Override\n    public JsonPOJOBuilder.Value findPOJOBuilderConfig() {\n        return (_annotationIntrospector == null) ?\n                null : _annotationIntrospector.findPOJOBuilderConfig(_classInfo);\n    }\n\n    @Override\n    public Converter<Object,Object> findDeserializationConverter() {\n        if (_annotationIntrospector == null) {\n            return null;\n        }\n        return _createConverter(_annotationIntrospector.findDeserializationConverter(_classInfo));\n    }\n\n    @Override\n    public String findClassDescription() {\n        return (_annotationIntrospector == null) ?\n                null : _annotationIntrospector.findClassDescription(_classInfo);\n    }\n\n    \n\n    \n    @Deprecated\n    public LinkedHashMap<String,AnnotatedField> _findPropertyFields( Collection<String> ignoredProperties, boolean forSerialization) {\n        LinkedHashMap<String,AnnotatedField> results = new LinkedHashMap<String,AnnotatedField>();\n        for (BeanPropertyDefinition property : _properties()) {\n            AnnotatedField f = property.getField();\n            if (f != null) {\n                String name = property.getName();\n                if (ignoredProperties != null) {\n                    if (ignoredProperties.contains(name)) {\n                        continue;\n                    }\n                }\n                results.put(name, f);\n            }\n        }\n        return results;\n    }\n\n    \n    \n    @SuppressWarnings(\"unchecked\")\n    protected Converter<Object,Object> _createConverter(Object converterDef) {\n        if (converterDef == null) {\n            return null;\n        }\n        if (converterDef instanceof Converter<?,?>) {\n            return (Converter<Object,Object>) converterDef;\n        }\n        if (!(converterDef instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned Converter definition of type \"\n                    +converterDef.getClass().getName()+\"; expected type Converter or Class<Converter> instead\");\n        }\n        Class<?> converterClass = (Class<?>)converterDef;\n        \n        if (converterClass == Converter.None.class || ClassUtil.isBogusClass(converterClass)) {\n            return null;\n        }\n        if (!Converter.class.isAssignableFrom(converterClass)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"\n                    +converterClass.getName()+\"; expected Class<Converter>\");\n        }\n        HandlerInstantiator hi = _config.getHandlerInstantiator();\n        Converter<?,?> conv = (hi == null) ? null : hi.converterInstance(_config, _classInfo, converterClass);\n        if (conv == null) {\n            conv = (Converter<?,?>) ClassUtil.createInstance(converterClass,\n                    _config.canOverrideAccessModifiers());\n        }\n        return (Converter<Object,Object>) conv;\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.introspect;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.JsonInclude;\n\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.type.TypeBindings;\nimport com.fasterxml.jackson.databind.util.Annotations;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.Converter;\n\n\npublic class BasicBeanDescription extends BeanDescription { private final static Class<?>[] NO_VIEWS = new Class<?>[0]; final protected POJOPropertiesCollector _propCollector; final protected MapperConfig<?> _config; final protected AnnotationIntrospector _annotationIntrospector; final protected AnnotatedClass _classInfo; protected Class<?>[] _defaultViews; protected boolean _defaultViewsResolved; protected List<BeanPropertyDefinition> _properties; protected ObjectIdInfo _objectIdInfo; protected BasicBeanDescription(POJOPropertiesCollector coll, JavaType type, AnnotatedClass classDef) {\n        super(type);\n        _propCollector = coll;\n        _config = coll.getConfig();\n        \n        if (_config == null) {\n            _annotationIntrospector = null;\n        } else {\n            _annotationIntrospector = _config.getAnnotationIntrospector();\n        }\n        _classInfo = classDef;\n    }\n\n    \n    protected BasicBeanDescription(MapperConfig<?> config, JavaType type, AnnotatedClass classDef, List<BeanPropertyDefinition> props) {\n        super(type);\n        _propCollector = null;\n        _config = config;\n        \n        if (_config == null) {\n            _annotationIntrospector = null;\n        } else {\n            _annotationIntrospector = _config.getAnnotationIntrospector();\n        }\n        _classInfo = classDef;\n        _properties = props;\n    }\n    \n    protected BasicBeanDescription(POJOPropertiesCollector coll) {\n        this(coll, coll.getType(), coll.getClassDef());\n        _objectIdInfo = coll.getObjectIdInfo();\n    }\n\n    \n    public static BasicBeanDescription forDeserialization(POJOPropertiesCollector coll) {\n        return new BasicBeanDescription(coll);\n    }\n\n    \n    public static BasicBeanDescription forSerialization(POJOPropertiesCollector coll) {\n        return new BasicBeanDescription(coll);\n    }\n\n    \n    public static BasicBeanDescription forOtherUse(MapperConfig<?> config, JavaType type, AnnotatedClass ac) {\n        return new BasicBeanDescription(config, type,\n                ac, Collections.<BeanPropertyDefinition>emptyList());\n    }\n\n    protected List<BeanPropertyDefinition> _properties() {\n        if (_properties == null) {\n            _properties = _propCollector.getProperties();\n        }\n        return _properties;\n    }\n\n    \n\n    \n    public boolean removeProperty(String propName) {\n        Iterator<BeanPropertyDefinition> it = _properties().iterator();\n        while (it.hasNext()) {\n            BeanPropertyDefinition prop = it.next();\n            if (prop.getName().equals(propName)) {\n                it.remove();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean addProperty(BeanPropertyDefinition def) {\n        \n        if (hasProperty(def.getFullName())) {\n            return false;\n        }\n        _properties().add(def);\n        return true;\n    }\n    \n    \n    public boolean hasProperty(PropertyName name) {\n        return findProperty(name) != null;\n    }\n    \n    \n    public BeanPropertyDefinition findProperty(PropertyName name) {\n        for (BeanPropertyDefinition prop : _properties()) {\n            if (prop.hasName(name)) {\n                return prop;\n            }\n        }\n        return null;\n    }\n    \n    \n\n    @Override\n    public AnnotatedClass getClassInfo() { return _classInfo; }\n\n    @Override\n    public ObjectIdInfo getObjectIdInfo() { return  _objectIdInfo; }\n\n    @Override\n    public List<BeanPropertyDefinition> findProperties() {\n        return _properties();\n    }\n\n    @Override\n    @Deprecated \n    public AnnotatedMethod findJsonValueMethod() {\n        return (_propCollector == null) ? null\n                : _propCollector.getJsonValueMethod();\n    }\n\n    @Override \n    public AnnotatedMember findJsonValueAccessor() {\n        return (_propCollector == null) ? null\n                : _propCollector.getJsonValueAccessor();\n    }\n \n    @Override\n    public Set<String> getIgnoredPropertyNames() {\n        Set<String> ign = (_propCollector == null) ? null\n                : _propCollector.getIgnoredPropertyNames();\n        if (ign == null) {\n            return Collections.emptySet();\n        }\n        return ign;\n    }\n\n    @Override\n    public boolean hasKnownClassAnnotations() {\n        return _classInfo.hasAnnotations();\n    }\n\n    @Override\n    public Annotations getClassAnnotations() {\n        return _classInfo.getAnnotations();\n    }\n\n    @Override\n    @Deprecated \n    public TypeBindings bindingsForBeanType() {\n        return _type.getBindings();\n    }\n\n    @Override\n    @Deprecated \n    public JavaType resolveType(java.lang.reflect.Type jdkType) {\n        if (jdkType == null) {\n            return null;\n        }\n        return _config.getTypeFactory().constructType(jdkType, _type.getBindings());\n    }\n\n    @Override\n    public AnnotatedConstructor findDefaultConstructor() {\n        return _classInfo.getDefaultConstructor();\n    }\n\n    @Override\n    public AnnotatedMember findAnySetterAccessor() throws IllegalArgumentException {\n        if (_propCollector != null) {\n            AnnotatedMethod anyMethod = _propCollector.getAnySetterMethod();\n            if (anyMethod != null) {\n                \n                \n    \n                \n                Class<?> type = anyMethod.getRawParameterType(0);\n                if ((type != String.class) && (type != Object.class)) {\n                    throw new IllegalArgumentException(String.format(\n\"Invalid 'any-setter' annotation on method '%s()': first argument not of type String or Object, but %s\",\nanyMethod.getName(), type.getName()));\n                }\n                return anyMethod;\n            }\n            AnnotatedMember anyField = _propCollector.getAnySetterField();\n            if (anyField != null) {\n                \n                \n                Class<?> type = anyField.getRawType();\n                if (!Map.class.isAssignableFrom(type)) {\n                    throw new IllegalArgumentException(String.format(\n\"Invalid 'any-setter' annotation on field '%s': type is not instance of java.util.Map\",\nanyField.getName()));\n                }\n                return anyField;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Map<Object, AnnotatedMember> findInjectables() {\n        if (_propCollector != null) {\n            return _propCollector.getInjectables();\n        }\n        return Collections.emptyMap();\n    }\n\n    @Override\n    public List<AnnotatedConstructor> getConstructors() {\n        return _classInfo.getConstructors();\n    }\n\n    @Override\n    public Object instantiateBean(boolean fixAccess) {\n        AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n        if (ac == null) {\n            return null;\n        }\n        if (fixAccess) {\n            ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n        try {\n            return ac.getAnnotated().newInstance();\n        } catch (Exception e) {\n            Throwable t = e;\n            while (t.getCause() != null) {\n                t = t.getCause();\n            }\n            ClassUtil.throwIfError(t);\n            ClassUtil.throwIfRTE(t);\n            throw new IllegalArgumentException(\"Failed to instantiate bean of type \"\n                    +_classInfo.getAnnotated().getName()+\": (\"+t.getClass().getName()+\") \"\n                    +ClassUtil.exceptionMessage(t), t);\n        }\n    }\n\n    \n\n    @Override\n    public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes) {\n        return _classInfo.findMethod(name, paramTypes);\n    }\n\n    \n\n    @Override\n    public JsonFormat.Value findExpectedFormat(JsonFormat.Value defValue) {\n        \n        \n        if (_annotationIntrospector != null) {\n            JsonFormat.Value v = _annotationIntrospector.findFormat(_classInfo);\n            if (v != null) {\n                if (defValue == null) {\n                    defValue = v;\n                } else {\n                    defValue = defValue.withOverrides(v);\n                }\n            }\n        }\n        JsonFormat.Value v = _config.getDefaultPropertyFormat(_classInfo.getRawType());\n        if (v != null) {\n            if (defValue == null) {\n                defValue = v;\n            } else {\n                defValue = defValue.withOverrides(v);\n            }\n        }\n        return defValue;\n    }\n\n    @Override \n    public Class<?>[] findDefaultViews() {\n        if (!_defaultViewsResolved) {\n            _defaultViewsResolved = true;\n            Class<?>[] def = (_annotationIntrospector == null) ? null\n                    : _annotationIntrospector.findViews(_classInfo);\n            \n            if (def == null) {\n                if (!_config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                    def = NO_VIEWS;\n                }\n            }\n            _defaultViews = def;\n        }\n        return _defaultViews;\n    }\n\n    \n\n    @Override\n    public Converter<Object,Object> findSerializationConverter() {\n        if (_annotationIntrospector == null) {\n            return null;\n        }\n        return _createConverter(_annotationIntrospector.findSerializationConverter(_classInfo));\n    }\n\n    \n    @Override\n    public JsonInclude.Value findPropertyInclusion(JsonInclude.Value defValue) {\n        if (_annotationIntrospector != null) {\n            JsonInclude.Value incl = _annotationIntrospector.findPropertyInclusion(_classInfo);\n            if (incl != null) {\n                return (defValue == null) ? incl : defValue.withOverrides(incl);\n            }\n        }\n        return defValue;\n    }\n\n    \n    @Override\n    public AnnotatedMember findAnyGetter() throws IllegalArgumentException {\n        AnnotatedMember anyGetter = (_propCollector == null) ? null\n                : _propCollector.getAnyGetter();\n        if (anyGetter != null) {\n            \n            Class<?> type = anyGetter.getRawType();\n            if (!Map.class.isAssignableFrom(type)) {\n                throw new IllegalArgumentException(\"Invalid 'any-getter' annotation on method \"+anyGetter.getName()+\"(): return type is not instance of java.util.Map\");\n            }\n        }\n        return anyGetter;\n    }\n\n    @Override\n    public List<BeanPropertyDefinition> findBackReferences() {\n        List<BeanPropertyDefinition> result = null;\n        HashSet<String> names = null;\n        for (BeanPropertyDefinition property : _properties()) {\n            AnnotationIntrospector.ReferenceProperty refDef = property.findReferenceType();\n            if ((refDef == null) || !refDef.isBackReference()) {\n                continue;\n            }\n            final String refName = refDef.getName();\n            if (result == null) {\n                result = new ArrayList<BeanPropertyDefinition>();\n                names = new HashSet<>();\n                names.add(refName);\n            } else {\n                if (!names.add(refName)) {\n                    throw new IllegalArgumentException(\"Multiple back-reference properties with name '\"+refName+\"'\");\n                }\n            }\n            result.add(property);\n        }\n        return result;\n    }\n\n    @Deprecated \n    @Override\n    public Map<String,AnnotatedMember> findBackReferenceProperties() {\n        List<BeanPropertyDefinition> props = findBackReferences();\n        if (props == null) {\n            return null;\n        }\n        Map<String,AnnotatedMember> result = new HashMap<>();\n        for (BeanPropertyDefinition prop : props) {\n            result.put(prop.getName(), prop.getMutator());\n        }\n        return result;\n    }\n\n    \n\n    @Override\n    public List<AnnotatedMethod> getFactoryMethods() {\n        \n        List<AnnotatedMethod> candidates = _classInfo.getFactoryMethods();\n        if (candidates.isEmpty()) {\n            return candidates;\n        }\n        List<AnnotatedMethod> result = null;\n        for (AnnotatedMethod am : candidates) {\n            if (isFactoryMethod(am)) {\n                if (result == null) {\n                    result = new ArrayList<AnnotatedMethod>();\n                }\n                result.add(am);\n            }\n        }\n        if (result == null) {\n            return Collections.emptyList();\n        }\n        return result;\n    }\n\n    @Override\n    public Constructor<?> findSingleArgConstructor(Class<?>... argTypes) {\n        for (AnnotatedConstructor ac : _classInfo.getConstructors()) {\n            \n            \n            if (ac.getParameterCount() == 1) {\n                Class<?> actArg = ac.getRawParameterType(0);\n                for (Class<?> expArg : argTypes) {\n                    if (expArg == actArg) {\n                        return ac.getAnnotated();\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Method findFactoryMethod(Class<?>... expArgTypes) {\n        \n        for (AnnotatedMethod am : _classInfo.getFactoryMethods()) {\n            \n            if (isFactoryMethod(am) && am.getParameterCount() == 1) {\n                \n                Class<?> actualArgType = am.getRawParameterType(0);\n                for (Class<?> expArgType : expArgTypes) {\n                    \n                    if (actualArgType.isAssignableFrom(expArgType)) {\n                        return am.getAnnotated();\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    protected boolean isFactoryMethod(AnnotatedMethod am) {\n        \n        \n        Class<?> rt = am.getRawReturnType();\n        if (!getBeanClass().isAssignableFrom(rt)) {\n            return false;\n        }\n        \n        JsonCreator.Mode mode = _annotationIntrospector.findCreatorAnnotation(_config, am);\n        if ((mode != null) && (mode != JsonCreator.Mode.DISABLED)) {\n            return true;\n        }\n        final String name = am.getName();\n        \n        if (\"valueOf\".equals(name)) {\n            if (am.getParameterCount() == 1) {\n                return true;\n            }\n        }\n        \n        if (\"fromString\".equals(name)) {\n            if (am.getParameterCount() == 1) {\n                Class<?> cls = am.getRawParameterType(0);\n                if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    \n    @Deprecated \n    protected PropertyName _findCreatorPropertyName(AnnotatedParameter param) {\n        PropertyName name = _annotationIntrospector.findNameForDeserialization(param);\n        if (name == null || name.isEmpty()) {\n            String str = _annotationIntrospector.findImplicitPropertyName(param);\n            if (str != null && !str.isEmpty()) {\n                name = PropertyName.construct(str);\n            }\n        }\n        return name;\n    }\n\n    \n\n    @Override\n    public Class<?> findPOJOBuilder() {\n        return (_annotationIntrospector == null) ?\n    \t\t\tnull : _annotationIntrospector.findPOJOBuilder(_classInfo);\n    }\n\n    @Override\n    public JsonPOJOBuilder.Value findPOJOBuilderConfig() {\n        return (_annotationIntrospector == null) ?\n                null : _annotationIntrospector.findPOJOBuilderConfig(_classInfo);\n    }\n\n    @Override\n    public Converter<Object,Object> findDeserializationConverter() {\n        if (_annotationIntrospector == null) {\n            return null;\n        }\n        return _createConverter(_annotationIntrospector.findDeserializationConverter(_classInfo));\n    }\n\n    @Override\n    public String findClassDescription() {\n        return (_annotationIntrospector == null) ?\n                null : _annotationIntrospector.findClassDescription(_classInfo);\n    }\n\n    \n\n    \n    @Deprecated\n    public LinkedHashMap<String,AnnotatedField> _findPropertyFields( Collection<String> ignoredProperties, boolean forSerialization) {\n        LinkedHashMap<String,AnnotatedField> results = new LinkedHashMap<String,AnnotatedField>();\n        for (BeanPropertyDefinition property : _properties()) {\n            AnnotatedField f = property.getField();\n            if (f != null) {\n                String name = property.getName();\n                if (ignoredProperties != null) {\n                    if (ignoredProperties.contains(name)) {\n                        continue;\n                    }\n                }\n                results.put(name, f);\n            }\n        }\n        return results;\n    }\n\n    \n    \n    @SuppressWarnings(\"unchecked\")\n    protected Converter<Object,Object> _createConverter(Object converterDef) {\n        if (converterDef == null) {\n            return null;\n        }\n        if (converterDef instanceof Converter<?,?>) {\n            return (Converter<Object,Object>) converterDef;\n        }\n        if (!(converterDef instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned Converter definition of type \"\n                    +converterDef.getClass().getName()+\"; expected type Converter or Class<Converter> instead\");\n        }\n        Class<?> converterClass = (Class<?>)converterDef;\n        \n        if (converterClass == Converter.None.class || ClassUtil.isBogusClass(converterClass)) {\n            return null;\n        }\n        if (!Converter.class.isAssignableFrom(converterClass)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"\n                    +converterClass.getName()+\"; expected Class<Converter>\");\n        }\n        HandlerInstantiator hi = _config.getHandlerInstantiator();\n        Converter<?,?> conv = (hi == null) ? null : hi.converterInstance(_config, _classInfo, converterClass);\n        if (conv == null) {\n            conv = (Converter<?,?>) ClassUtil.createInstance(converterClass,\n                    _config.canOverrideAccessModifiers());\n        }\n        return (Converter<Object,Object>) conv;\n    }\n}\n",
      "buggy_signatures": [
        "protected BasicBeanDescription(MapperConfig<?> config, JavaType type, AnnotatedClass classDef, List<BeanPropertyDefinition> props)",
        "protected BasicBeanDescription(POJOPropertiesCollector coll)",
        "public static BasicBeanDescription forDeserialization(POJOPropertiesCollector coll)",
        "public static BasicBeanDescription forSerialization(POJOPropertiesCollector coll)",
        "public static BasicBeanDescription forOtherUse(MapperConfig<?> config, JavaType type, AnnotatedClass ac)",
        "protected List<BeanPropertyDefinition> _properties()",
        "public boolean removeProperty(String propName)",
        "public boolean addProperty(BeanPropertyDefinition def)",
        "public boolean hasProperty(PropertyName name)",
        "public BeanPropertyDefinition findProperty(PropertyName name)",
        "public AnnotatedClass getClassInfo()",
        "public ObjectIdInfo getObjectIdInfo()",
        "public List<BeanPropertyDefinition> findProperties()",
        "public AnnotatedMethod findJsonValueMethod()",
        "public AnnotatedMember findJsonValueAccessor()",
        "public Set<String> getIgnoredPropertyNames()",
        "public boolean hasKnownClassAnnotations()",
        "public Annotations getClassAnnotations()",
        "public TypeBindings bindingsForBeanType()",
        "public JavaType resolveType(java.lang.reflect.Type jdkType)",
        "public AnnotatedConstructor findDefaultConstructor()",
        "public AnnotatedMember findAnySetterAccessor() throws IllegalArgumentException",
        "public Map<Object, AnnotatedMember> findInjectables()",
        "public List<AnnotatedConstructor> getConstructors()",
        "public Object instantiateBean(boolean fixAccess)",
        "public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes)",
        "public JsonFormat.Value findExpectedFormat(JsonFormat.Value defValue)",
        "public Class<?>[] findDefaultViews()",
        "public Converter<Object,Object> findSerializationConverter()",
        "public JsonInclude.Value findPropertyInclusion(JsonInclude.Value defValue)",
        "public AnnotatedMember findAnyGetter() throws IllegalArgumentException",
        "public List<BeanPropertyDefinition> findBackReferences()",
        "public Map<String,AnnotatedMember> findBackReferenceProperties()",
        "public List<AnnotatedMethod> getFactoryMethods()",
        "public Constructor<?> findSingleArgConstructor(Class<?>... argTypes)",
        "public Method findFactoryMethod(Class<?>... expArgTypes)",
        "protected boolean isFactoryMethod(AnnotatedMethod am)",
        "protected PropertyName _findCreatorPropertyName(AnnotatedParameter param)",
        "public Class<?> findPOJOBuilder()",
        "public JsonPOJOBuilder.Value findPOJOBuilderConfig()",
        "public Converter<Object,Object> findDeserializationConverter()",
        "public String findClassDescription()",
        "public LinkedHashMap<String,AnnotatedField> _findPropertyFields( Collection<String> ignoredProperties, boolean forSerialization)",
        "protected Converter<Object,Object> _createConverter(Object converterDef)"
      ],
      "fixed_signatures": [
        "protected BasicBeanDescription(MapperConfig<?> config, JavaType type, AnnotatedClass classDef, List<BeanPropertyDefinition> props)",
        "protected BasicBeanDescription(POJOPropertiesCollector coll)",
        "public static BasicBeanDescription forDeserialization(POJOPropertiesCollector coll)",
        "public static BasicBeanDescription forSerialization(POJOPropertiesCollector coll)",
        "public static BasicBeanDescription forOtherUse(MapperConfig<?> config, JavaType type, AnnotatedClass ac)",
        "protected List<BeanPropertyDefinition> _properties()",
        "public boolean removeProperty(String propName)",
        "public boolean addProperty(BeanPropertyDefinition def)",
        "public boolean hasProperty(PropertyName name)",
        "public BeanPropertyDefinition findProperty(PropertyName name)",
        "public AnnotatedClass getClassInfo()",
        "public ObjectIdInfo getObjectIdInfo()",
        "public List<BeanPropertyDefinition> findProperties()",
        "public AnnotatedMethod findJsonValueMethod()",
        "public AnnotatedMember findJsonValueAccessor()",
        "public Set<String> getIgnoredPropertyNames()",
        "public boolean hasKnownClassAnnotations()",
        "public Annotations getClassAnnotations()",
        "public TypeBindings bindingsForBeanType()",
        "public JavaType resolveType(java.lang.reflect.Type jdkType)",
        "public AnnotatedConstructor findDefaultConstructor()",
        "public AnnotatedMember findAnySetterAccessor() throws IllegalArgumentException",
        "public Map<Object, AnnotatedMember> findInjectables()",
        "public List<AnnotatedConstructor> getConstructors()",
        "public Object instantiateBean(boolean fixAccess)",
        "public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes)",
        "public JsonFormat.Value findExpectedFormat(JsonFormat.Value defValue)",
        "public Class<?>[] findDefaultViews()",
        "public Converter<Object,Object> findSerializationConverter()",
        "public JsonInclude.Value findPropertyInclusion(JsonInclude.Value defValue)",
        "public AnnotatedMember findAnyGetter() throws IllegalArgumentException",
        "public List<BeanPropertyDefinition> findBackReferences()",
        "public Map<String,AnnotatedMember> findBackReferenceProperties()",
        "public List<AnnotatedMethod> getFactoryMethods()",
        "public Constructor<?> findSingleArgConstructor(Class<?>... argTypes)",
        "public Method findFactoryMethod(Class<?>... expArgTypes)",
        "protected boolean isFactoryMethod(AnnotatedMethod am)",
        "protected PropertyName _findCreatorPropertyName(AnnotatedParameter param)",
        "public Class<?> findPOJOBuilder()",
        "public JsonPOJOBuilder.Value findPOJOBuilderConfig()",
        "public Converter<Object,Object> findDeserializationConverter()",
        "public String findClassDescription()",
        "public LinkedHashMap<String,AnnotatedField> _findPropertyFields( Collection<String> ignoredProperties, boolean forSerialization)",
        "protected Converter<Object,Object> _createConverter(Object converterDef)"
      ],
      "methods": [
        {
          "buggy_method": "  public Object instantiateBean(boolean fixAccess) {\n  AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n  if (ac == null) {\n  return null;\n  }\n  if (fixAccess) {\n  ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n  }\n  try {\n  return ac.getAnnotated().newInstance();\n  } catch (Exception e) {\n  Throwable t = e;\n  while (t.getCause() != null) {\n  t = t.getCause();\n  }\n  ClassUtil.throwIfError(t);\n  ClassUtil.throwIfRTE(t);\n  throw new IllegalArgumentException(\"Failed to instantiate bean of type \"\n  +_classInfo.getAnnotated().getName()+\": (\"+t.getClass().getName()+\") \"\n  +t.getMessage(), t);\n  }\n  }",
          "fixed_method": "  public Object instantiateBean(boolean fixAccess) {\n  AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n  if (ac == null) {\n  return null;\n  }\n  if (fixAccess) {\n  ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n  }\n  try {\n  return ac.getAnnotated().newInstance();\n  } catch (Exception e) {\n  Throwable t = e;\n  while (t.getCause() != null) {\n  t = t.getCause();\n  }\n  ClassUtil.throwIfError(t);\n  ClassUtil.throwIfRTE(t);\n  throw new IllegalArgumentException(\"Failed to instantiate bean of type \"\n  +_classInfo.getAnnotated().getName()+\": (\"+t.getClass().getName()+\") \"\n  +ClassUtil.exceptionMessage(t), t);\n  }\n  }",
          "diff": [
            "@@ -361,7 +361,7 @@",
            "             ClassUtil.throwIfRTE(t);\n",
            "             throw new IllegalArgumentException(\"Failed to instantiate bean of type \"\n",
            "                     +_classInfo.getAnnotated().getName()+\": (\"+t.getClass().getName()+\") \"\n",
            "-                    +t.getMessage(), t);\n",
            "+                    +ClassUtil.exceptionMessage(t), t);\n",
            "         }\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.ser;\n\nimport java.io.IOException;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.introspect.Annotated;\nimport com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\nimport com.fasterxml.jackson.databind.jsonschema.SchemaAware;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.fasterxml.jackson.databind.ser.impl.WritableObjectId;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\npublic abstract class DefaultSerializerProvider extends SerializerProvider implements java.io.Serializable { private static final long serialVersionUID = 1L; protected transient Map<Object, WritableObjectId> _seenObjectIds; protected transient ArrayList<ObjectIdGenerator<?>> _objectIdGenerators; protected transient JsonGenerator _generator; protected DefaultSerializerProvider() { super(); }\n\n    protected DefaultSerializerProvider(SerializerProvider src, SerializationConfig config,SerializerFactory f) {\n        super(src, config, f);\n    }\n\n    protected DefaultSerializerProvider(DefaultSerializerProvider src) {\n        super(src);\n    }\n\n    \n    public abstract DefaultSerializerProvider createInstance(SerializationConfig config, SerializerFactory jsf); public DefaultSerializerProvider copy() {\n        throw new IllegalStateException(\"DefaultSerializerProvider sub-class not overriding copy()\");\n    }\n\n    \n    \n    @Override\n    public JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException {\n        if (serDef == null) {\n            return null;\n        }\n        JsonSerializer<?> ser;\n        \n        if (serDef instanceof JsonSerializer) {\n            ser = (JsonSerializer<?>) serDef;\n        } else {\n            \n            \n            if (!(serDef instanceof Class)) {\n                reportBadDefinition(annotated.getType(),\n                        \"AnnotationIntrospector returned serializer definition of type \"\n                        +serDef.getClass().getName()+\"; expected type JsonSerializer or Class<JsonSerializer> instead\");\n            }\n            Class<?> serClass = (Class<?>)serDef;\n            \n            if (serClass == JsonSerializer.None.class || ClassUtil.isBogusClass(serClass)) {\n                return null;\n            }\n            if (!JsonSerializer.class.isAssignableFrom(serClass)) {\n                reportBadDefinition(annotated.getType(),\n                        \"AnnotationIntrospector returned Class \"\n                        +serClass.getName()+\"; expected Class<JsonSerializer>\");\n            }\n            HandlerInstantiator hi = _config.getHandlerInstantiator();\n            ser = (hi == null) ? null : hi.serializerInstance(_config, annotated, serClass);\n            if (ser == null) {\n                ser = (JsonSerializer<?>) ClassUtil.createInstance(serClass,\n                        _config.canOverrideAccessModifiers());\n            }\n        }\n        return (JsonSerializer<Object>) _handleResolvable(ser);\n    }\n\n    @Override\n    public Object includeFilterInstance(BeanPropertyDefinition forProperty, Class<?> filterClass) {\n        if (filterClass == null) {\n            return null;\n        }\n        HandlerInstantiator hi = _config.getHandlerInstantiator();\n        Object filter = (hi == null) ? null : hi.includeFilterInstance(_config, forProperty, filterClass);\n        if (filter == null) {\n            filter = ClassUtil.createInstance(filterClass,\n                    _config.canOverrideAccessModifiers());\n        }\n        return filter;\n    }\n\n    @Override\n    public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException {\n        if (filter == null) {\n            return true;\n        }\n        \n        \n        try {\n            return filter.equals(null);\n        } catch (Throwable t) {\n            String msg = String.format(\n\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\",\nfilter.getClass().getName(), t.getClass().getName(), t.getMessage());\n            reportBadDefinition(filter.getClass(), msg, t);\n            return false; \n        }\n    }\n\n    \n    \n    @Override\n    public WritableObjectId findObjectId(Object forPojo, ObjectIdGenerator<?> generatorType) {\n        if (_seenObjectIds == null) {\n            _seenObjectIds = _createObjectIdMap();\n        } else {\n            WritableObjectId oid = _seenObjectIds.get(forPojo);\n            if (oid != null) {\n                return oid;\n            }\n        }\n        \n        ObjectIdGenerator<?> generator = null;\n        \n        if (_objectIdGenerators == null) {\n            _objectIdGenerators = new ArrayList<ObjectIdGenerator<?>>(8);\n        } else {\n            for (int i = 0, len = _objectIdGenerators.size(); i < len; ++i) {\n                ObjectIdGenerator<?> gen = _objectIdGenerators.get(i);\n                if (gen.canUseFor(generatorType)) {\n                    generator = gen;\n                    break;\n                }\n            }\n        }\n        if (generator == null) {\n            generator = generatorType.newForSerialization(this);\n            _objectIdGenerators.add(generator);\n        }\n        WritableObjectId oid = new WritableObjectId(generator);\n        _seenObjectIds.put(forPojo, oid);\n        return oid;\n    }\n\n    \n    protected Map<Object,WritableObjectId> _createObjectIdMap() {\n        \n        if (isEnabled(SerializationFeature.USE_EQUALITY_FOR_OBJECT_ID)) {\n            return new HashMap<Object,WritableObjectId>();\n        }\n        return new IdentityHashMap<Object,WritableObjectId>();\n    }\n\n    \n\n    \n    public boolean hasSerializerFor(Class<?> cls, AtomicReference<Throwable> cause) {\n        \n        \n        \n        if (cls == Object.class) {\n            if (!_config.isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS)) {\n                return true;\n            }\n        }\n        \n        try {\n            JsonSerializer<?> ser = _findExplicitUntypedSerializer(cls);\n            return (ser != null);\n        } catch (JsonMappingException e) {\n            if (cause != null) {\n                cause.set(e);\n            }\n        } catch (RuntimeException e) {\n            if (cause == null) { \n                throw e;\n            }\n            cause.set(e);\n        }\n        return false;\n    }\n\n    \n    @Override\n    public JsonGenerator getGenerator() {\n        return _generator;\n    }\n\n    \n    \n    \n    public void serializeValue(JsonGenerator gen, Object value) throws IOException {\n        _generator = gen;\n        if (value == null) {\n            _serializeNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        \n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        PropertyName rootName = _config.getFullRootName();\n        if (rootName == null) { \n            if (_config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE)) {\n                _serialize(gen, value, ser, _config.findRootName(cls));\n                return;\n            }\n        } else if (!rootName.isEmpty()) {\n            _serialize(gen, value, ser, rootName);\n            return;\n        }\n        _serialize(gen, value, ser);\n    }\n\n    \n    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType) throws IOException {\n        _generator = gen;\n        if (value == null) {\n            _serializeNull(gen);\n            return;\n        }\n        \n        if (!rootType.getRawClass().isAssignableFrom(value.getClass())) {\n            _reportIncompatibleRootType(value, rootType);\n        }\n        \n        JsonSerializer<Object> ser = findTypedValueSerializer(rootType, true, null);\n        PropertyName rootName = _config.getFullRootName();\n        if (rootName == null) { \n            if (_config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE)) {\n                _serialize(gen, value, ser, _config.findRootName(rootType));\n                return;\n            }\n        } else if (!rootName.isEmpty()) {\n            _serialize(gen, value, ser, rootName);\n            return;\n        }\n        _serialize(gen, value, ser);\n    }\n\n    \n    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType, JsonSerializer<Object> ser) throws IOException {\n        _generator = gen;\n        if (value == null) {\n            _serializeNull(gen);\n            return;\n        }\n        \n        if ((rootType != null) && !rootType.getRawClass().isAssignableFrom(value.getClass())) {\n            _reportIncompatibleRootType(value, rootType);\n        }\n        \n        if (ser == null) {\n            ser = findTypedValueSerializer(rootType, true, null);\n        }\n        PropertyName rootName = _config.getFullRootName();\n        if (rootName == null) { \n            if (_config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE)) {\n                rootName = (rootType == null)\n                        ? _config.findRootName(value.getClass())\n                        : _config.findRootName(rootType);\n                _serialize(gen, value, ser, rootName);\n                return;\n            }\n        } else if (!rootName.isEmpty()) {\n            _serialize(gen, value, ser, rootName);\n            return;\n        }\n        _serialize(gen, value, ser);\n    }\n\n    \n    public void serializePolymorphic(JsonGenerator gen, Object value, JavaType rootType, JsonSerializer<Object> valueSer, TypeSerializer typeSer) throws IOException {\n        _generator = gen;\n        if (value == null) {\n            _serializeNull(gen);\n            return;\n        }\n        \n        if ((rootType != null) && !rootType.getRawClass().isAssignableFrom(value.getClass())) {\n            _reportIncompatibleRootType(value, rootType);\n        }\n        \n        if (valueSer == null) {\n            if ((rootType != null) && rootType.isContainerType()) {\n                valueSer = findValueSerializer(rootType, null);\n            } else {\n                valueSer = findValueSerializer(value.getClass(), null);\n            }\n        }\n\n        final boolean wrap;\n        PropertyName rootName = _config.getFullRootName();\n        if (rootName == null) {\n            wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n            if (wrap) {\n                gen.writeStartObject();\n                PropertyName pname = _config.findRootName(value.getClass());\n                gen.writeFieldName(pname.simpleAsEncoded(_config));\n            }\n        } else if (rootName.isEmpty()) {\n            wrap = false;\n        } else {\n            wrap = true;\n            gen.writeStartObject();\n            gen.writeFieldName(rootName.getSimpleName());\n        }\n        try {\n            valueSer.serializeWithType(value, gen, this, typeSer);\n            if (wrap) {\n                gen.writeEndObject();\n            }\n        } catch (Exception e) {\n            throw _wrapAsIOE(gen, e);\n        }\n    }\n\n    private final void _serialize(JsonGenerator gen, Object value, JsonSerializer<Object> ser, PropertyName rootName) throws IOException {\n        try {\n            gen.writeStartObject();\n            gen.writeFieldName(rootName.simpleAsEncoded(_config));\n            ser.serialize(value, gen, this);\n            gen.writeEndObject();\n        } catch (Exception e) {\n            throw _wrapAsIOE(gen, e);\n        }\n    }\n\n    private final void _serialize(JsonGenerator gen, Object value, JsonSerializer<Object> ser) throws IOException {\n        try {\n            ser.serialize(value, gen, this);\n        } catch (Exception e) {\n            throw _wrapAsIOE(gen, e);\n        }\n    }\n\n    \n    protected void _serializeNull(JsonGenerator gen) throws IOException {\n        JsonSerializer<Object> ser = getDefaultNullValueSerializer();\n        try {\n            ser.serialize(null, gen, this);\n        } catch (Exception e) {\n            throw _wrapAsIOE(gen, e);\n        }\n    }\n\n    private IOException _wrapAsIOE(JsonGenerator g, Exception e) {\n        if (e instanceof IOException) {\n            return (IOException) e;\n        }\n        String msg = e.getMessage();\n        if (msg == null) {\n            msg = \"[no message for \"+e.getClass().getName()+\"]\";\n        }\n        return new JsonMappingException(g, msg, e);\n    }\n\n    \n\n    \n    public int cachedSerializersCount() {\n        return _serializerCache.size();\n    }\n\n    \n    public void flushCachedSerializers() {\n        _serializerCache.flush();\n    }\n\n    \n\n    \n    public void acceptJsonFormatVisitor(JavaType javaType, JsonFormatVisitorWrapper visitor) throws JsonMappingException {\n        if (javaType == null) {\n            throw new IllegalArgumentException(\"A class must be provided\");\n        }\n        \n        visitor.setProvider(this);\n        findValueSerializer(javaType, null).acceptJsonFormatVisitor(visitor, javaType);\n    }\n\n    \n    @Deprecated \n    public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> type) throws JsonMappingException {\n        \n        JsonSerializer<Object> ser = findValueSerializer(type, null);\n        JsonNode schemaNode = (ser instanceof SchemaAware) ?\n                ((SchemaAware) ser).getSchema(this, null) : com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode();\n        if (!(schemaNode instanceof ObjectNode)) {\n            throw new IllegalArgumentException(\"Class \" + type.getName()\n                    +\" would not be serialized as a JSON object and therefore has no schema\");\n        }\n        return new com.fasterxml.jackson.databind.jsonschema.JsonSchema((ObjectNode) schemaNode);\n    }\n    \n    \n    \n\n    \n    public final static class Impl extends DefaultSerializerProvider { private static final long serialVersionUID = 1L; public Impl() { super(); }\n        public Impl(Impl src) { super(src); }\n\n        protected Impl(SerializerProvider src, SerializationConfig config, SerializerFactory f) {\n            super(src, config, f);\n        }\n\n        @Override\n        public DefaultSerializerProvider copy() {\n            if (getClass() != Impl.class) {\n                return super.copy();\n            }\n            return new Impl(this);\n        }\n        \n        @Override\n        public Impl createInstance(SerializationConfig config, SerializerFactory jsf) {\n            return new Impl(this, config, jsf);\n        }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.ser;\n\nimport java.io.IOException;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.introspect.Annotated;\nimport com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\nimport com.fasterxml.jackson.databind.jsonschema.SchemaAware;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.fasterxml.jackson.databind.ser.impl.WritableObjectId;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\npublic abstract class DefaultSerializerProvider extends SerializerProvider implements java.io.Serializable { private static final long serialVersionUID = 1L; protected transient Map<Object, WritableObjectId> _seenObjectIds; protected transient ArrayList<ObjectIdGenerator<?>> _objectIdGenerators; protected transient JsonGenerator _generator; protected DefaultSerializerProvider() { super(); }\n\n    protected DefaultSerializerProvider(SerializerProvider src, SerializationConfig config,SerializerFactory f) {\n        super(src, config, f);\n    }\n\n    protected DefaultSerializerProvider(DefaultSerializerProvider src) {\n        super(src);\n    }\n\n    \n    public abstract DefaultSerializerProvider createInstance(SerializationConfig config, SerializerFactory jsf); public DefaultSerializerProvider copy() {\n        throw new IllegalStateException(\"DefaultSerializerProvider sub-class not overriding copy()\");\n    }\n\n    \n    \n    @Override\n    public JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException {\n        if (serDef == null) {\n            return null;\n        }\n        JsonSerializer<?> ser;\n        \n        if (serDef instanceof JsonSerializer) {\n            ser = (JsonSerializer<?>) serDef;\n        } else {\n            \n            \n            if (!(serDef instanceof Class)) {\n                reportBadDefinition(annotated.getType(),\n                        \"AnnotationIntrospector returned serializer definition of type \"\n                        +serDef.getClass().getName()+\"; expected type JsonSerializer or Class<JsonSerializer> instead\");\n            }\n            Class<?> serClass = (Class<?>)serDef;\n            \n            if (serClass == JsonSerializer.None.class || ClassUtil.isBogusClass(serClass)) {\n                return null;\n            }\n            if (!JsonSerializer.class.isAssignableFrom(serClass)) {\n                reportBadDefinition(annotated.getType(),\n                        \"AnnotationIntrospector returned Class \"\n                        +serClass.getName()+\"; expected Class<JsonSerializer>\");\n            }\n            HandlerInstantiator hi = _config.getHandlerInstantiator();\n            ser = (hi == null) ? null : hi.serializerInstance(_config, annotated, serClass);\n            if (ser == null) {\n                ser = (JsonSerializer<?>) ClassUtil.createInstance(serClass,\n                        _config.canOverrideAccessModifiers());\n            }\n        }\n        return (JsonSerializer<Object>) _handleResolvable(ser);\n    }\n\n    @Override\n    public Object includeFilterInstance(BeanPropertyDefinition forProperty, Class<?> filterClass) {\n        if (filterClass == null) {\n            return null;\n        }\n        HandlerInstantiator hi = _config.getHandlerInstantiator();\n        Object filter = (hi == null) ? null : hi.includeFilterInstance(_config, forProperty, filterClass);\n        if (filter == null) {\n            filter = ClassUtil.createInstance(filterClass,\n                    _config.canOverrideAccessModifiers());\n        }\n        return filter;\n    }\n\n    @Override\n    public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException {\n        if (filter == null) {\n            return true;\n        }\n        \n        \n        try {\n            return filter.equals(null);\n        } catch (Throwable t) {\n            String msg = String.format(\n\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\",\nfilter.getClass().getName(), t.getClass().getName(), ClassUtil.exceptionMessage(t));\n            reportBadDefinition(filter.getClass(), msg, t);\n            return false; \n        }\n    }\n\n    \n    \n    @Override\n    public WritableObjectId findObjectId(Object forPojo, ObjectIdGenerator<?> generatorType) {\n        if (_seenObjectIds == null) {\n            _seenObjectIds = _createObjectIdMap();\n        } else {\n            WritableObjectId oid = _seenObjectIds.get(forPojo);\n            if (oid != null) {\n                return oid;\n            }\n        }\n        \n        ObjectIdGenerator<?> generator = null;\n        \n        if (_objectIdGenerators == null) {\n            _objectIdGenerators = new ArrayList<ObjectIdGenerator<?>>(8);\n        } else {\n            for (int i = 0, len = _objectIdGenerators.size(); i < len; ++i) {\n                ObjectIdGenerator<?> gen = _objectIdGenerators.get(i);\n                if (gen.canUseFor(generatorType)) {\n                    generator = gen;\n                    break;\n                }\n            }\n        }\n        if (generator == null) {\n            generator = generatorType.newForSerialization(this);\n            _objectIdGenerators.add(generator);\n        }\n        WritableObjectId oid = new WritableObjectId(generator);\n        _seenObjectIds.put(forPojo, oid);\n        return oid;\n    }\n\n    \n    protected Map<Object,WritableObjectId> _createObjectIdMap() {\n        \n        if (isEnabled(SerializationFeature.USE_EQUALITY_FOR_OBJECT_ID)) {\n            return new HashMap<Object,WritableObjectId>();\n        }\n        return new IdentityHashMap<Object,WritableObjectId>();\n    }\n\n    \n\n    \n    public boolean hasSerializerFor(Class<?> cls, AtomicReference<Throwable> cause) {\n        \n        \n        \n        if (cls == Object.class) {\n            if (!_config.isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS)) {\n                return true;\n            }\n        }\n        \n        try {\n            JsonSerializer<?> ser = _findExplicitUntypedSerializer(cls);\n            return (ser != null);\n        } catch (JsonMappingException e) {\n            if (cause != null) {\n                cause.set(e);\n            }\n        } catch (RuntimeException e) {\n            if (cause == null) { \n                throw e;\n            }\n            cause.set(e);\n        }\n        return false;\n    }\n\n    \n    @Override\n    public JsonGenerator getGenerator() {\n        return _generator;\n    }\n\n    \n    \n    \n    public void serializeValue(JsonGenerator gen, Object value) throws IOException {\n        _generator = gen;\n        if (value == null) {\n            _serializeNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        \n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        PropertyName rootName = _config.getFullRootName();\n        if (rootName == null) { \n            if (_config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE)) {\n                _serialize(gen, value, ser, _config.findRootName(cls));\n                return;\n            }\n        } else if (!rootName.isEmpty()) {\n            _serialize(gen, value, ser, rootName);\n            return;\n        }\n        _serialize(gen, value, ser);\n    }\n\n    \n    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType) throws IOException {\n        _generator = gen;\n        if (value == null) {\n            _serializeNull(gen);\n            return;\n        }\n        \n        if (!rootType.getRawClass().isAssignableFrom(value.getClass())) {\n            _reportIncompatibleRootType(value, rootType);\n        }\n        \n        JsonSerializer<Object> ser = findTypedValueSerializer(rootType, true, null);\n        PropertyName rootName = _config.getFullRootName();\n        if (rootName == null) { \n            if (_config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE)) {\n                _serialize(gen, value, ser, _config.findRootName(rootType));\n                return;\n            }\n        } else if (!rootName.isEmpty()) {\n            _serialize(gen, value, ser, rootName);\n            return;\n        }\n        _serialize(gen, value, ser);\n    }\n\n    \n    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType, JsonSerializer<Object> ser) throws IOException {\n        _generator = gen;\n        if (value == null) {\n            _serializeNull(gen);\n            return;\n        }\n        \n        if ((rootType != null) && !rootType.getRawClass().isAssignableFrom(value.getClass())) {\n            _reportIncompatibleRootType(value, rootType);\n        }\n        \n        if (ser == null) {\n            ser = findTypedValueSerializer(rootType, true, null);\n        }\n        PropertyName rootName = _config.getFullRootName();\n        if (rootName == null) { \n            if (_config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE)) {\n                rootName = (rootType == null)\n                        ? _config.findRootName(value.getClass())\n                        : _config.findRootName(rootType);\n                _serialize(gen, value, ser, rootName);\n                return;\n            }\n        } else if (!rootName.isEmpty()) {\n            _serialize(gen, value, ser, rootName);\n            return;\n        }\n        _serialize(gen, value, ser);\n    }\n\n    \n    public void serializePolymorphic(JsonGenerator gen, Object value, JavaType rootType, JsonSerializer<Object> valueSer, TypeSerializer typeSer) throws IOException {\n        _generator = gen;\n        if (value == null) {\n            _serializeNull(gen);\n            return;\n        }\n        \n        if ((rootType != null) && !rootType.getRawClass().isAssignableFrom(value.getClass())) {\n            _reportIncompatibleRootType(value, rootType);\n        }\n        \n        if (valueSer == null) {\n            if ((rootType != null) && rootType.isContainerType()) {\n                valueSer = findValueSerializer(rootType, null);\n            } else {\n                valueSer = findValueSerializer(value.getClass(), null);\n            }\n        }\n\n        final boolean wrap;\n        PropertyName rootName = _config.getFullRootName();\n        if (rootName == null) {\n            wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n            if (wrap) {\n                gen.writeStartObject();\n                PropertyName pname = _config.findRootName(value.getClass());\n                gen.writeFieldName(pname.simpleAsEncoded(_config));\n            }\n        } else if (rootName.isEmpty()) {\n            wrap = false;\n        } else {\n            wrap = true;\n            gen.writeStartObject();\n            gen.writeFieldName(rootName.getSimpleName());\n        }\n        try {\n            valueSer.serializeWithType(value, gen, this, typeSer);\n            if (wrap) {\n                gen.writeEndObject();\n            }\n        } catch (Exception e) {\n            throw _wrapAsIOE(gen, e);\n        }\n    }\n\n    private final void _serialize(JsonGenerator gen, Object value, JsonSerializer<Object> ser, PropertyName rootName) throws IOException {\n        try {\n            gen.writeStartObject();\n            gen.writeFieldName(rootName.simpleAsEncoded(_config));\n            ser.serialize(value, gen, this);\n            gen.writeEndObject();\n        } catch (Exception e) {\n            throw _wrapAsIOE(gen, e);\n        }\n    }\n\n    private final void _serialize(JsonGenerator gen, Object value, JsonSerializer<Object> ser) throws IOException {\n        try {\n            ser.serialize(value, gen, this);\n        } catch (Exception e) {\n            throw _wrapAsIOE(gen, e);\n        }\n    }\n\n    \n    protected void _serializeNull(JsonGenerator gen) throws IOException {\n        JsonSerializer<Object> ser = getDefaultNullValueSerializer();\n        try {\n            ser.serialize(null, gen, this);\n        } catch (Exception e) {\n            throw _wrapAsIOE(gen, e);\n        }\n    }\n\n    private IOException _wrapAsIOE(JsonGenerator g, Exception e) {\n        if (e instanceof IOException) {\n            return (IOException) e;\n        }\n        String msg = ClassUtil.exceptionMessage(e);\n        if (msg == null) {\n            msg = \"[no message for \"+e.getClass().getName()+\"]\";\n        }\n        return new JsonMappingException(g, msg, e);\n    }\n\n    \n\n    \n    public int cachedSerializersCount() {\n        return _serializerCache.size();\n    }\n\n    \n    public void flushCachedSerializers() {\n        _serializerCache.flush();\n    }\n\n    \n\n    \n    public void acceptJsonFormatVisitor(JavaType javaType, JsonFormatVisitorWrapper visitor) throws JsonMappingException {\n        if (javaType == null) {\n            throw new IllegalArgumentException(\"A class must be provided\");\n        }\n        \n        visitor.setProvider(this);\n        findValueSerializer(javaType, null).acceptJsonFormatVisitor(visitor, javaType);\n    }\n\n    \n    @Deprecated \n    public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> type) throws JsonMappingException {\n        \n        JsonSerializer<Object> ser = findValueSerializer(type, null);\n        JsonNode schemaNode = (ser instanceof SchemaAware) ?\n                ((SchemaAware) ser).getSchema(this, null) : com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode();\n        if (!(schemaNode instanceof ObjectNode)) {\n            throw new IllegalArgumentException(\"Class \" + type.getName()\n                    +\" would not be serialized as a JSON object and therefore has no schema\");\n        }\n        return new com.fasterxml.jackson.databind.jsonschema.JsonSchema((ObjectNode) schemaNode);\n    }\n    \n    \n    \n\n    \n    public final static class Impl extends DefaultSerializerProvider { private static final long serialVersionUID = 1L; public Impl() { super(); }\n        public Impl(Impl src) { super(src); }\n\n        protected Impl(SerializerProvider src, SerializationConfig config, SerializerFactory f) {\n            super(src, config, f);\n        }\n\n        @Override\n        public DefaultSerializerProvider copy() {\n            if (getClass() != Impl.class) {\n                return super.copy();\n            }\n            return new Impl(this);\n        }\n        \n        @Override\n        public Impl createInstance(SerializationConfig config, SerializerFactory jsf) {\n            return new Impl(this, config, jsf);\n        }\n    }\n}\n",
      "buggy_signatures": [
        "protected DefaultSerializerProvider(SerializerProvider src, SerializationConfig config,SerializerFactory f)",
        "protected DefaultSerializerProvider(DefaultSerializerProvider src)",
        "public abstract DefaultSerializerProvider createInstance(SerializationConfig config, SerializerFactory jsf); public DefaultSerializerProvider copy()",
        "public JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException",
        "public Object includeFilterInstance(BeanPropertyDefinition forProperty, Class<?> filterClass)",
        "public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException",
        "public WritableObjectId findObjectId(Object forPojo, ObjectIdGenerator<?> generatorType)",
        "protected Map<Object,WritableObjectId> _createObjectIdMap()",
        "public boolean hasSerializerFor(Class<?> cls, AtomicReference<Throwable> cause)",
        "public JsonGenerator getGenerator()",
        "public void serializeValue(JsonGenerator gen, Object value) throws IOException",
        "public void serializeValue(JsonGenerator gen, Object value, JavaType rootType) throws IOException",
        "public void serializeValue(JsonGenerator gen, Object value, JavaType rootType, JsonSerializer<Object> ser) throws IOException",
        "public void serializePolymorphic(JsonGenerator gen, Object value, JavaType rootType, JsonSerializer<Object> valueSer, TypeSerializer typeSer) throws IOException",
        "private final void _serialize(JsonGenerator gen, Object value, JsonSerializer<Object> ser, PropertyName rootName) throws IOException",
        "private final void _serialize(JsonGenerator gen, Object value, JsonSerializer<Object> ser) throws IOException",
        "protected void _serializeNull(JsonGenerator gen) throws IOException",
        "private IOException _wrapAsIOE(JsonGenerator g, Exception e)",
        "public int cachedSerializersCount()",
        "public void flushCachedSerializers()",
        "public void acceptJsonFormatVisitor(JavaType javaType, JsonFormatVisitorWrapper visitor) throws JsonMappingException",
        "public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> type) throws JsonMappingException",
        "public Impl(Impl src)",
        "protected Impl(SerializerProvider src, SerializationConfig config, SerializerFactory f)",
        "public DefaultSerializerProvider copy()",
        "public Impl createInstance(SerializationConfig config, SerializerFactory jsf)"
      ],
      "fixed_signatures": [
        "protected DefaultSerializerProvider(SerializerProvider src, SerializationConfig config,SerializerFactory f)",
        "protected DefaultSerializerProvider(DefaultSerializerProvider src)",
        "public abstract DefaultSerializerProvider createInstance(SerializationConfig config, SerializerFactory jsf); public DefaultSerializerProvider copy()",
        "public JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException",
        "public Object includeFilterInstance(BeanPropertyDefinition forProperty, Class<?> filterClass)",
        "public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException",
        "public WritableObjectId findObjectId(Object forPojo, ObjectIdGenerator<?> generatorType)",
        "protected Map<Object,WritableObjectId> _createObjectIdMap()",
        "public boolean hasSerializerFor(Class<?> cls, AtomicReference<Throwable> cause)",
        "public JsonGenerator getGenerator()",
        "public void serializeValue(JsonGenerator gen, Object value) throws IOException",
        "public void serializeValue(JsonGenerator gen, Object value, JavaType rootType) throws IOException",
        "public void serializeValue(JsonGenerator gen, Object value, JavaType rootType, JsonSerializer<Object> ser) throws IOException",
        "public void serializePolymorphic(JsonGenerator gen, Object value, JavaType rootType, JsonSerializer<Object> valueSer, TypeSerializer typeSer) throws IOException",
        "private final void _serialize(JsonGenerator gen, Object value, JsonSerializer<Object> ser, PropertyName rootName) throws IOException",
        "private final void _serialize(JsonGenerator gen, Object value, JsonSerializer<Object> ser) throws IOException",
        "protected void _serializeNull(JsonGenerator gen) throws IOException",
        "private IOException _wrapAsIOE(JsonGenerator g, Exception e)",
        "public int cachedSerializersCount()",
        "public void flushCachedSerializers()",
        "public void acceptJsonFormatVisitor(JavaType javaType, JsonFormatVisitorWrapper visitor) throws JsonMappingException",
        "public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> type) throws JsonMappingException",
        "public Impl(Impl src)",
        "protected Impl(SerializerProvider src, SerializationConfig config, SerializerFactory f)",
        "public DefaultSerializerProvider copy()",
        "public Impl createInstance(SerializationConfig config, SerializerFactory jsf)"
      ],
      "methods": [
        {
          "buggy_method": "  public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException {\n  if (filter == null) {\n  return true;\n  }\n  \n  \n  try {\n  return filter.equals(null);\n  } catch (Throwable t) {\n  String msg = String.format(\n\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\",\nfilter.getClass().getName(), t.getClass().getName(), t.getMessage());\n  reportBadDefinition(filter.getClass(), msg, t);\n  return false; \n  }\n  }",
          "fixed_method": "  public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException {\n  if (filter == null) {\n  return true;\n  }\n  \n  \n  try {\n  return filter.equals(null);\n  } catch (Throwable t) {\n  String msg = String.format(\n\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\",\nfilter.getClass().getName(), t.getClass().getName(), ClassUtil.exceptionMessage(t));\n  reportBadDefinition(filter.getClass(), msg, t);\n  return false; \n  }\n  }",
          "diff": [
            "@@ -168,7 +168,7 @@",
            "         } catch (Throwable t) {\n",
            "             String msg = String.format(\n",
            " \"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\",\n",
            "-filter.getClass().getName(), t.getClass().getName(), t.getMessage());\n",
            "+filter.getClass().getName(), t.getClass().getName(), ClassUtil.exceptionMessage(t));\n",
            "             reportBadDefinition(filter.getClass(), msg, t);\n",
            "             return false; // never gets here\n",
            "         }\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  private IOException _wrapAsIOE(JsonGenerator g, Exception e) {\n  if (e instanceof IOException) {\n  return (IOException) e;\n  }\n  String msg = e.getMessage();\n  if (msg == null) {\n  msg = \"[no message for \"+e.getClass().getName()+\"]\";\n  }\n  return new JsonMappingException(g, msg, e);\n  }",
          "fixed_method": "  private IOException _wrapAsIOE(JsonGenerator g, Exception e) {\n  if (e instanceof IOException) {\n  return (IOException) e;\n  }\n  String msg = ClassUtil.exceptionMessage(e);\n  if (msg == null) {\n  msg = \"[no message for \"+e.getClass().getName()+\"]\";\n  }\n  return new JsonMappingException(g, msg, e);\n  }",
          "diff": [
            "@@ -502,7 +502,7 @@",
            "         if (e instanceof IOException) {\n",
            "             return (IOException) e;\n",
            "         }\n",
            "-        String msg = e.getMessage();\n",
            "+        String msg = ClassUtil.exceptionMessage(e);\n",
            "         if (msg == null) {\n",
            "             msg = \"[no message for \"+e.getClass().getName()+\"]\";\n",
            "         }\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/ser/PropertyBuilder.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.ser;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.util.*;\n\n\npublic class PropertyBuilder { private final static Object NO_DEFAULT_MARKER = Boolean.FALSE; final protected SerializationConfig _config; final protected BeanDescription _beanDesc; final protected AnnotationIntrospector _annotationIntrospector; protected Object _defaultBean; final protected JsonInclude.Value _defaultInclusion; final protected boolean _useRealPropertyDefaults; public PropertyBuilder(SerializationConfig config, BeanDescription beanDesc) {\n        _config = config;\n        _beanDesc = beanDesc;\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        JsonInclude.Value inclPerType = JsonInclude.Value.merge(\n                beanDesc.findPropertyInclusion(JsonInclude.Value.empty()),\n                config.getDefaultPropertyInclusion(beanDesc.getBeanClass(),\n                        JsonInclude.Value.empty()));\n        _defaultInclusion = JsonInclude.Value.merge(config.getDefaultPropertyInclusion(),\n                inclPerType);\n        _useRealPropertyDefaults = inclPerType.getValueInclusion() == JsonInclude.Include.NON_DEFAULT;\n        _annotationIntrospector = _config.getAnnotationIntrospector();\n    }\n\n    \n\n    public Annotations getClassAnnotations() {\n        return _beanDesc.getClassAnnotations();\n    }\n\n    \n    protected BeanPropertyWriter buildWriter(SerializerProvider prov, BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) throws JsonMappingException {\n        \n        JavaType serializationType;\n        try {\n            serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n        } catch (JsonMappingException e) {\n            if (propDef == null) {\n                return prov.reportBadDefinition(declaredType, e.getMessage());\n            }\n            return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());\n        }\n\n        \n        if (contentTypeSer != null) {\n            \n            \n            \n            if (serializationType == null) {\n\n                serializationType = declaredType;\n            }\n            JavaType ct = serializationType.getContentType();\n            \n            if (ct == null) {\n                prov.reportBadPropertyDefinition(_beanDesc, propDef,\n                        \"serialization type \"+serializationType+\" has no content\");\n            }\n            serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n            ct = serializationType.getContentType();\n        }\n\n        Object valueToSuppress = null;\n        boolean suppressNulls = false;\n\n        \n        JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n        \n        \n        AnnotatedMember accessor = propDef.getAccessor();\n        if (accessor == null) {\n            \n            return prov.reportBadPropertyDefinition(_beanDesc, propDef,\n                    \"could not determine property type\");\n        }\n        Class<?> rawPropertyType = accessor.getRawType();\n\n        \n        \n        \n        JsonInclude.Value inclV = _config.getDefaultInclusion(actualType.getRawClass(),\n                rawPropertyType, _defaultInclusion);\n\n        \n        \n        inclV = inclV.withOverrides(propDef.findInclusion());\n\n        JsonInclude.Include inclusion = inclV.getValueInclusion();\n        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { \n            inclusion = JsonInclude.Include.ALWAYS;\n        }\n        switch (inclusion) {\n        case NON_DEFAULT:\n            \n            \n            \n            \n            \n            Object defaultBean;\n\n            \n            \n            \n            \n            if (_useRealPropertyDefaults && (defaultBean = getDefaultBean()) != null) {\n                \n                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                }\n                try {\n                    valueToSuppress = am.getValue(defaultBean);\n                } catch (Exception e) {\n                    _throwWrapped(e, propDef.getName(), defaultBean);\n                }\n            } else {\n                valueToSuppress = BeanUtil.getDefaultValue(actualType);\n                suppressNulls = true;\n            }\n            if (valueToSuppress == null) {\n                suppressNulls = true;\n            } else {\n                if (valueToSuppress.getClass().isArray()) {\n                    valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n                }\n            }\n            break;\n        case NON_ABSENT: \n            \n            suppressNulls = true;\n            \n            if (actualType.isReferenceType()) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        case NON_EMPTY:\n            \n            suppressNulls = true;\n            \n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            break;\n        case CUSTOM: \n            valueToSuppress = prov.includeFilterInstance(propDef, inclV.getValueFilter());\n            if (valueToSuppress == null) { \n                suppressNulls = true;\n            } else {\n                suppressNulls = prov.includeFilterSuppressNulls(valueToSuppress);\n            }\n            break;\n        case NON_NULL:\n            suppressNulls = true;\n            \n        case ALWAYS: \n        default:\n            \n            if (actualType.isContainerType()\n                    && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        }\n        Class<?>[] views = propDef.findViews();\n        if (views == null) {\n            views = _beanDesc.findDefaultViews();\n        }\n        BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n                am, _beanDesc.getClassAnnotations(), declaredType,\n                ser, typeSer, serializationType, suppressNulls, valueToSuppress, views);\n\n        \n        Object serDef = _annotationIntrospector.findNullSerializer(am);\n        if (serDef != null) {\n            bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n        }\n        \n        NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n        if (unwrapper != null) {\n            bpw = bpw.unwrappingWriter(unwrapper);\n        }\n        return bpw;\n    }\n\n    \n\n    \n    protected JavaType findSerializationType(Annotated a, boolean useStaticTyping, JavaType declaredType) throws JsonMappingException {\n        JavaType secondary = _annotationIntrospector.refineSerializationType(_config, a, declaredType);\n\n        \n        \n        if (secondary != declaredType) {\n            Class<?> serClass = secondary.getRawClass();\n            \n            Class<?> rawDeclared = declaredType.getRawClass();\n            if (serClass.isAssignableFrom(rawDeclared)) {\n                ; \n            } else {\n                \n                if (!rawDeclared.isAssignableFrom(serClass)) {\n                    throw new IllegalArgumentException(\"Illegal concrete-type annotation for method '\"+a.getName()+\"': class \"+serClass.getName()+\" not a super-type of (declared) class \"+rawDeclared.getName());\n                }\n                \n            }\n            useStaticTyping = true;\n            declaredType = secondary;\n        }\n        \n        JsonSerialize.Typing typing = _annotationIntrospector.findSerializationTyping(a);\n        if ((typing != null) && (typing != JsonSerialize.Typing.DEFAULT_TYPING)) {\n            useStaticTyping = (typing == JsonSerialize.Typing.STATIC);\n        }\n        if (useStaticTyping) {\n            \n            return declaredType.withStaticTyping();\n            \n        }\n        return null;\n    }\n\n    \n\n    protected Object getDefaultBean() {\n        Object def = _defaultBean;\n        if (def == null) {\n            \n            def = _beanDesc.instantiateBean(_config.canOverrideAccessModifiers());\n            if (def == null) {\n                \n                \n\n                \n                def = NO_DEFAULT_MARKER;\n            }\n            _defaultBean = def;\n        }\n        return (def == NO_DEFAULT_MARKER) ? null : _defaultBean;\n    }\n\n    \n    @Deprecated \n    protected Object getPropertyDefaultValue(String name, AnnotatedMember member, JavaType type) {\n        Object defaultBean = getDefaultBean();\n        if (defaultBean == null) {\n            return getDefaultValue(type);\n        }\n        try {\n            return member.getValue(defaultBean);\n        } catch (Exception e) {\n            return _throwWrapped(e, name, defaultBean);\n        }\n    }\n\n    \n    @Deprecated \n    protected Object getDefaultValue(JavaType type) {\n        return BeanUtil.getDefaultValue(type);\n    }\n\n    \n    \n    protected Object _throwWrapped(Exception e, String propName, Object defaultBean) {\n        Throwable t = e;\n        while (t.getCause() != null) {\n            t = t.getCause();\n        }\n        ClassUtil.throwIfError(t);\n        ClassUtil.throwIfRTE(t);\n        throw new IllegalArgumentException(\"Failed to get property '\"+propName+\"' of default \"+defaultBean.getClass().getName()+\" instance\");\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.ser;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.util.*;\n\n\npublic class PropertyBuilder { private final static Object NO_DEFAULT_MARKER = Boolean.FALSE; final protected SerializationConfig _config; final protected BeanDescription _beanDesc; final protected AnnotationIntrospector _annotationIntrospector; protected Object _defaultBean; final protected JsonInclude.Value _defaultInclusion; final protected boolean _useRealPropertyDefaults; public PropertyBuilder(SerializationConfig config, BeanDescription beanDesc) {\n        _config = config;\n        _beanDesc = beanDesc;\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        JsonInclude.Value inclPerType = JsonInclude.Value.merge(\n                beanDesc.findPropertyInclusion(JsonInclude.Value.empty()),\n                config.getDefaultPropertyInclusion(beanDesc.getBeanClass(),\n                        JsonInclude.Value.empty()));\n        _defaultInclusion = JsonInclude.Value.merge(config.getDefaultPropertyInclusion(),\n                inclPerType);\n        _useRealPropertyDefaults = inclPerType.getValueInclusion() == JsonInclude.Include.NON_DEFAULT;\n        _annotationIntrospector = _config.getAnnotationIntrospector();\n    }\n\n    \n\n    public Annotations getClassAnnotations() {\n        return _beanDesc.getClassAnnotations();\n    }\n\n    \n    protected BeanPropertyWriter buildWriter(SerializerProvider prov, BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) throws JsonMappingException {\n        \n        JavaType serializationType;\n        try {\n            serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n        } catch (JsonMappingException e) {\n            if (propDef == null) {\n                return prov.reportBadDefinition(declaredType, ClassUtil.exceptionMessage(e));\n            }\n            return prov.reportBadPropertyDefinition(_beanDesc, propDef, ClassUtil.exceptionMessage(e));\n        }\n\n        \n        if (contentTypeSer != null) {\n            \n            \n            \n            if (serializationType == null) {\n\n                serializationType = declaredType;\n            }\n            JavaType ct = serializationType.getContentType();\n            \n            if (ct == null) {\n                prov.reportBadPropertyDefinition(_beanDesc, propDef,\n                        \"serialization type \"+serializationType+\" has no content\");\n            }\n            serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n            ct = serializationType.getContentType();\n        }\n\n        Object valueToSuppress = null;\n        boolean suppressNulls = false;\n\n        \n        JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n        \n        \n        AnnotatedMember accessor = propDef.getAccessor();\n        if (accessor == null) {\n            \n            return prov.reportBadPropertyDefinition(_beanDesc, propDef,\n                    \"could not determine property type\");\n        }\n        Class<?> rawPropertyType = accessor.getRawType();\n\n        \n        \n        \n        JsonInclude.Value inclV = _config.getDefaultInclusion(actualType.getRawClass(),\n                rawPropertyType, _defaultInclusion);\n\n        \n        \n        inclV = inclV.withOverrides(propDef.findInclusion());\n\n        JsonInclude.Include inclusion = inclV.getValueInclusion();\n        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { \n            inclusion = JsonInclude.Include.ALWAYS;\n        }\n        switch (inclusion) {\n        case NON_DEFAULT:\n            \n            \n            \n            \n            \n            Object defaultBean;\n\n            \n            \n            \n            \n            if (_useRealPropertyDefaults && (defaultBean = getDefaultBean()) != null) {\n                \n                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                }\n                try {\n                    valueToSuppress = am.getValue(defaultBean);\n                } catch (Exception e) {\n                    _throwWrapped(e, propDef.getName(), defaultBean);\n                }\n            } else {\n                valueToSuppress = BeanUtil.getDefaultValue(actualType);\n                suppressNulls = true;\n            }\n            if (valueToSuppress == null) {\n                suppressNulls = true;\n            } else {\n                if (valueToSuppress.getClass().isArray()) {\n                    valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n                }\n            }\n            break;\n        case NON_ABSENT: \n            \n            suppressNulls = true;\n            \n            if (actualType.isReferenceType()) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        case NON_EMPTY:\n            \n            suppressNulls = true;\n            \n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            break;\n        case CUSTOM: \n            valueToSuppress = prov.includeFilterInstance(propDef, inclV.getValueFilter());\n            if (valueToSuppress == null) { \n                suppressNulls = true;\n            } else {\n                suppressNulls = prov.includeFilterSuppressNulls(valueToSuppress);\n            }\n            break;\n        case NON_NULL:\n            suppressNulls = true;\n            \n        case ALWAYS: \n        default:\n            \n            if (actualType.isContainerType()\n                    && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        }\n        Class<?>[] views = propDef.findViews();\n        if (views == null) {\n            views = _beanDesc.findDefaultViews();\n        }\n        BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n                am, _beanDesc.getClassAnnotations(), declaredType,\n                ser, typeSer, serializationType, suppressNulls, valueToSuppress, views);\n\n        \n        Object serDef = _annotationIntrospector.findNullSerializer(am);\n        if (serDef != null) {\n            bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n        }\n        \n        NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n        if (unwrapper != null) {\n            bpw = bpw.unwrappingWriter(unwrapper);\n        }\n        return bpw;\n    }\n\n    \n\n    \n    protected JavaType findSerializationType(Annotated a, boolean useStaticTyping, JavaType declaredType) throws JsonMappingException {\n        JavaType secondary = _annotationIntrospector.refineSerializationType(_config, a, declaredType);\n\n        \n        \n        if (secondary != declaredType) {\n            Class<?> serClass = secondary.getRawClass();\n            \n            Class<?> rawDeclared = declaredType.getRawClass();\n            if (serClass.isAssignableFrom(rawDeclared)) {\n                ; \n            } else {\n                \n                if (!rawDeclared.isAssignableFrom(serClass)) {\n                    throw new IllegalArgumentException(\"Illegal concrete-type annotation for method '\"+a.getName()+\"': class \"+serClass.getName()+\" not a super-type of (declared) class \"+rawDeclared.getName());\n                }\n                \n            }\n            useStaticTyping = true;\n            declaredType = secondary;\n        }\n        \n        JsonSerialize.Typing typing = _annotationIntrospector.findSerializationTyping(a);\n        if ((typing != null) && (typing != JsonSerialize.Typing.DEFAULT_TYPING)) {\n            useStaticTyping = (typing == JsonSerialize.Typing.STATIC);\n        }\n        if (useStaticTyping) {\n            \n            return declaredType.withStaticTyping();\n            \n        }\n        return null;\n    }\n\n    \n\n    protected Object getDefaultBean() {\n        Object def = _defaultBean;\n        if (def == null) {\n            \n            def = _beanDesc.instantiateBean(_config.canOverrideAccessModifiers());\n            if (def == null) {\n                \n                \n\n                \n                def = NO_DEFAULT_MARKER;\n            }\n            _defaultBean = def;\n        }\n        return (def == NO_DEFAULT_MARKER) ? null : _defaultBean;\n    }\n\n    \n    @Deprecated \n    protected Object getPropertyDefaultValue(String name, AnnotatedMember member, JavaType type) {\n        Object defaultBean = getDefaultBean();\n        if (defaultBean == null) {\n            return getDefaultValue(type);\n        }\n        try {\n            return member.getValue(defaultBean);\n        } catch (Exception e) {\n            return _throwWrapped(e, name, defaultBean);\n        }\n    }\n\n    \n    @Deprecated \n    protected Object getDefaultValue(JavaType type) {\n        return BeanUtil.getDefaultValue(type);\n    }\n\n    \n    \n    protected Object _throwWrapped(Exception e, String propName, Object defaultBean) {\n        Throwable t = e;\n        while (t.getCause() != null) {\n            t = t.getCause();\n        }\n        ClassUtil.throwIfError(t);\n        ClassUtil.throwIfRTE(t);\n        throw new IllegalArgumentException(\"Failed to get property '\"+propName+\"' of default \"+defaultBean.getClass().getName()+\" instance\");\n    }\n}\n",
      "buggy_signatures": [
        "public Annotations getClassAnnotations()",
        "protected BeanPropertyWriter buildWriter(SerializerProvider prov, BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) throws JsonMappingException",
        "protected JavaType findSerializationType(Annotated a, boolean useStaticTyping, JavaType declaredType) throws JsonMappingException",
        "protected Object getDefaultBean()",
        "protected Object getPropertyDefaultValue(String name, AnnotatedMember member, JavaType type)",
        "protected Object getDefaultValue(JavaType type)",
        "protected Object _throwWrapped(Exception e, String propName, Object defaultBean)"
      ],
      "fixed_signatures": [
        "public Annotations getClassAnnotations()",
        "protected BeanPropertyWriter buildWriter(SerializerProvider prov, BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) throws JsonMappingException",
        "protected JavaType findSerializationType(Annotated a, boolean useStaticTyping, JavaType declaredType) throws JsonMappingException",
        "protected Object getDefaultBean()",
        "protected Object getPropertyDefaultValue(String name, AnnotatedMember member, JavaType type)",
        "protected Object getDefaultValue(JavaType type)",
        "protected Object _throwWrapped(Exception e, String propName, Object defaultBean)"
      ],
      "methods": [
        {
          "buggy_method": "  protected BeanPropertyWriter buildWriter(SerializerProvider prov, BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) throws JsonMappingException {\n  \n  JavaType serializationType;\n  try {\n  serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n  } catch (JsonMappingException e) {\n  if (propDef == null) {\n  return prov.reportBadDefinition(declaredType, e.getMessage());\n  }\n  return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());\n  }\n\n  \n  if (contentTypeSer != null) {\n  \n  \n  \n  if (serializationType == null) {\n\n  serializationType = declaredType;\n  }\n  JavaType ct = serializationType.getContentType();\n  \n  if (ct == null) {\n  prov.reportBadPropertyDefinition(_beanDesc, propDef,\n  \"serialization type \"+serializationType+\" has no content\");\n  }\n  serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n  ct = serializationType.getContentType();\n  }\n\n  Object valueToSuppress = null;\n  boolean suppressNulls = false;\n\n  \n  JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n  \n  \n  AnnotatedMember accessor = propDef.getAccessor();\n  if (accessor == null) {\n  \n  return prov.reportBadPropertyDefinition(_beanDesc, propDef,\n  \"could not determine property type\");\n  }\n  Class<?> rawPropertyType = accessor.getRawType();\n\n  \n  \n  \n  JsonInclude.Value inclV = _config.getDefaultInclusion(actualType.getRawClass(),\n  rawPropertyType, _defaultInclusion);\n\n  \n  \n  inclV = inclV.withOverrides(propDef.findInclusion());\n\n  JsonInclude.Include inclusion = inclV.getValueInclusion();\n  if (inclusion == JsonInclude.Include.USE_DEFAULTS) { \n  inclusion = JsonInclude.Include.ALWAYS;\n  }\n  switch (inclusion) {\n  case NON_DEFAULT:\n  \n  \n  \n  \n  \n  Object defaultBean;\n\n  \n  \n  \n  \n  if (_useRealPropertyDefaults && (defaultBean = getDefaultBean()) != null) {\n  \n  if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n  am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n  }\n  try {\n  valueToSuppress = am.getValue(defaultBean);\n  } catch (Exception e) {\n  _throwWrapped(e, propDef.getName(), defaultBean);\n  }\n  } else {\n  valueToSuppress = BeanUtil.getDefaultValue(actualType);\n  suppressNulls = true;\n  }\n  if (valueToSuppress == null) {\n  suppressNulls = true;\n  } else {\n  if (valueToSuppress.getClass().isArray()) {\n  valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n  }\n  }\n  break;\n  case NON_ABSENT: \n  \n  suppressNulls = true;\n  \n  if (actualType.isReferenceType()) {\n  valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n  }\n  break;\n  case NON_EMPTY:\n  \n  suppressNulls = true;\n  \n  valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n  break;\n  case CUSTOM: \n  valueToSuppress = prov.includeFilterInstance(propDef, inclV.getValueFilter());\n  if (valueToSuppress == null) { \n  suppressNulls = true;\n  } else {\n  suppressNulls = prov.includeFilterSuppressNulls(valueToSuppress);\n  }\n  break;\n  case NON_NULL:\n  suppressNulls = true;\n  \n  case ALWAYS: \n  default:\n  \n  if (actualType.isContainerType()\n  && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n  valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n  }\n  break;\n  }\n  Class<?>[] views = propDef.findViews();\n  if (views == null) {\n  views = _beanDesc.findDefaultViews();\n  }\n  BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n  am, _beanDesc.getClassAnnotations(), declaredType,\n  ser, typeSer, serializationType, suppressNulls, valueToSuppress, views);\n\n  \n  Object serDef = _annotationIntrospector.findNullSerializer(am);\n  if (serDef != null) {\n  bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n  }\n  \n  NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n  if (unwrapper != null) {\n  bpw = bpw.unwrappingWriter(unwrapper);\n  }\n  return bpw;\n  }",
          "fixed_method": "  protected BeanPropertyWriter buildWriter(SerializerProvider prov, BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) throws JsonMappingException {\n  \n  JavaType serializationType;\n  try {\n  serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n  } catch (JsonMappingException e) {\n  if (propDef == null) {\n  return prov.reportBadDefinition(declaredType, ClassUtil.exceptionMessage(e));\n  }\n  return prov.reportBadPropertyDefinition(_beanDesc, propDef, ClassUtil.exceptionMessage(e));\n  }\n\n  \n  if (contentTypeSer != null) {\n  \n  \n  \n  if (serializationType == null) {\n\n  serializationType = declaredType;\n  }\n  JavaType ct = serializationType.getContentType();\n  \n  if (ct == null) {\n  prov.reportBadPropertyDefinition(_beanDesc, propDef,\n  \"serialization type \"+serializationType+\" has no content\");\n  }\n  serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n  ct = serializationType.getContentType();\n  }\n\n  Object valueToSuppress = null;\n  boolean suppressNulls = false;\n\n  \n  JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n  \n  \n  AnnotatedMember accessor = propDef.getAccessor();\n  if (accessor == null) {\n  \n  return prov.reportBadPropertyDefinition(_beanDesc, propDef,\n  \"could not determine property type\");\n  }\n  Class<?> rawPropertyType = accessor.getRawType();\n\n  \n  \n  \n  JsonInclude.Value inclV = _config.getDefaultInclusion(actualType.getRawClass(),\n  rawPropertyType, _defaultInclusion);\n\n  \n  \n  inclV = inclV.withOverrides(propDef.findInclusion());\n\n  JsonInclude.Include inclusion = inclV.getValueInclusion();\n  if (inclusion == JsonInclude.Include.USE_DEFAULTS) { \n  inclusion = JsonInclude.Include.ALWAYS;\n  }\n  switch (inclusion) {\n  case NON_DEFAULT:\n  \n  \n  \n  \n  \n  Object defaultBean;\n\n  \n  \n  \n  \n  if (_useRealPropertyDefaults && (defaultBean = getDefaultBean()) != null) {\n  \n  if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n  am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n  }\n  try {\n  valueToSuppress = am.getValue(defaultBean);\n  } catch (Exception e) {\n  _throwWrapped(e, propDef.getName(), defaultBean);\n  }\n  } else {\n  valueToSuppress = BeanUtil.getDefaultValue(actualType);\n  suppressNulls = true;\n  }\n  if (valueToSuppress == null) {\n  suppressNulls = true;\n  } else {\n  if (valueToSuppress.getClass().isArray()) {\n  valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n  }\n  }\n  break;\n  case NON_ABSENT: \n  \n  suppressNulls = true;\n  \n  if (actualType.isReferenceType()) {\n  valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n  }\n  break;\n  case NON_EMPTY:\n  \n  suppressNulls = true;\n  \n  valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n  break;\n  case CUSTOM: \n  valueToSuppress = prov.includeFilterInstance(propDef, inclV.getValueFilter());\n  if (valueToSuppress == null) { \n  suppressNulls = true;\n  } else {\n  suppressNulls = prov.includeFilterSuppressNulls(valueToSuppress);\n  }\n  break;\n  case NON_NULL:\n  suppressNulls = true;\n  \n  case ALWAYS: \n  default:\n  \n  if (actualType.isContainerType()\n  && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n  valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n  }\n  break;\n  }\n  Class<?>[] views = propDef.findViews();\n  if (views == null) {\n  views = _beanDesc.findDefaultViews();\n  }\n  BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n  am, _beanDesc.getClassAnnotations(), declaredType,\n  ser, typeSer, serializationType, suppressNulls, valueToSuppress, views);\n\n  \n  Object serDef = _annotationIntrospector.findNullSerializer(am);\n  if (serDef != null) {\n  bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n  }\n  \n  NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n  if (unwrapper != null) {\n  bpw = bpw.unwrappingWriter(unwrapper);\n  }\n  return bpw;\n  }",
          "diff": [
            "@@ -100,9 +100,9 @@",
            "             serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n",
            "         } catch (JsonMappingException e) {\n",
            "             if (propDef == null) {\n",
            "-                return prov.reportBadDefinition(declaredType, e.getMessage());\n",
            "-            }\n",
            "-            return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());\n",
            "+                return prov.reportBadDefinition(declaredType, ClassUtil.exceptionMessage(e));\n",
            "+            }\n",
            "+            return prov.reportBadPropertyDefinition(_beanDesc, propDef, ClassUtil.exceptionMessage(e));\n",
            "         }\n",
            " \n",
            "         // Container types can have separate type serializers for content (value / element) type\n"
          ],
          "changed_lines": 6
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/util/ClassUtil.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.util;\n\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.*;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n\npublic final class ClassUtil { private final static Class<?> CLS_OBJECT = Object.class; private final static Annotation[] NO_ANNOTATIONS = new Annotation[0]; private final static Ctor[] NO_CTORS = new Ctor[0]; private final static Iterator<?> EMPTY_ITERATOR = Collections.emptyIterator(); @SuppressWarnings(\"unchecked\") public static <T> Iterator<T> emptyIterator() {\n        return (Iterator<T>) EMPTY_ITERATOR;\n    }\n\n    \n\n    \n    public static List<JavaType> findSuperTypes(JavaType type, Class<?> endBefore, boolean addClassItself) {\n        if ((type == null) || type.hasRawClass(endBefore) || type.hasRawClass(Object.class)) {\n            return Collections.emptyList();\n        }\n        List<JavaType> result = new ArrayList<JavaType>(8);\n        _addSuperTypes(type, endBefore, result, addClassItself);\n        return result;\n    }\n\n    \n    public static List<Class<?>> findRawSuperTypes(Class<?> cls, Class<?> endBefore, boolean addClassItself) {\n        if ((cls == null) || (cls == endBefore) || (cls == Object.class)) {\n            return Collections.emptyList();\n        }\n        List<Class<?>> result = new ArrayList<Class<?>>(8);\n        _addRawSuperTypes(cls, endBefore, result, addClassItself);\n        return result;\n    }\n\n    \n    public static List<Class<?>> findSuperClasses(Class<?> cls, Class<?> endBefore, boolean addClassItself) {\n        List<Class<?>> result = new LinkedList<Class<?>>();\n        if ((cls != null) && (cls != endBefore))  {\n            if (addClassItself) {\n                result.add(cls);\n            }\n            while ((cls = cls.getSuperclass()) != null) {\n                if (cls == endBefore) {\n                    break;\n                }\n                result.add(cls);\n            }\n        }\n        return result;\n    }\n\n    @Deprecated \n    public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore) {\n        return findSuperTypes(cls, endBefore, new ArrayList<Class<?>>(8));\n    }\n\n    @Deprecated \n    public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore, List<Class<?>> result) {\n        _addRawSuperTypes(cls, endBefore, result, false);\n        return result;\n    }\n\n    private static void _addSuperTypes(JavaType type, Class<?> endBefore, Collection<JavaType> result, boolean addClassItself) {\n        if (type == null) {\n            return;\n        }\n        final Class<?> cls = type.getRawClass();\n        if (cls == endBefore || cls == Object.class) { return; }\n        if (addClassItself) {\n            if (result.contains(type)) { \n                return;\n            }\n            result.add(type);\n        }\n        for (JavaType intCls : type.getInterfaces()) {\n            _addSuperTypes(intCls, endBefore, result, true);\n        }\n        _addSuperTypes(type.getSuperClass(), endBefore, result, true);\n    }\n\n    private static void _addRawSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself) {\n        if (cls == endBefore || cls == null || cls == Object.class) { return; }\n        if (addClassItself) {\n            if (result.contains(cls)) { \n                return;\n            }\n            result.add(cls);\n        }\n        for (Class<?> intCls : _interfaces(cls)) {\n            _addRawSuperTypes(intCls, endBefore, result, true);\n        }\n        _addRawSuperTypes(cls.getSuperclass(), endBefore, result, true);\n    }\n\n    \n\n    \n    public static String canBeABeanType(Class<?> type) {\n        \n        if (type.isAnnotation()) {\n            return \"annotation\";\n        }\n        if (type.isArray()) {\n            return \"array\";\n        }\n        if (type.isEnum()) {\n            return \"enum\";\n        }\n        if (type.isPrimitive()) {\n            return \"primitive\";\n        }\n\n        \n        return null;\n    }\n    \n    public static String isLocalType(Class<?> type, boolean allowNonStatic) {\n        \n        try {\n            \n            if (hasEnclosingMethod(type)) {\n                return \"local/anonymous\";\n            }\n            \n            \n            if (!allowNonStatic) {\n                if (!Modifier.isStatic(type.getModifiers())) {\n                    if (getEnclosingClass(type) != null) {\n                        return \"non-static member class\"; } } } } catch (SecurityException e) { }\n        catch (NullPointerException e) { }\n        return null;\n    }\n\n    \n    public static Class<?> getOuterClass(Class<?> type) {\n        \n        try {\n            \n            if (hasEnclosingMethod(type)) {\n                return null;\n            }\n            if (!Modifier.isStatic(type.getModifiers())) {\n                return getEnclosingClass(type);\n            }\n        } catch (SecurityException e) { }\n        return null;\n    }\n    \n    \n    \n    public static boolean isProxyType(Class<?> type) {\n        \n        \n        String name = type.getName();\n        \n        if (name.startsWith(\"net.sf.cglib.proxy.\")\n            || name.startsWith(\"org.hibernate.proxy.\")) {\n            return true;\n        }\n        \n        return false;\n    }\n\n    \n    public static boolean isConcrete(Class<?> type) {\n        int mod = type.getModifiers();\n        return (mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0;\n    }\n\n    public static boolean isConcrete(Member member) {\n        int mod = member.getModifiers();\n        return (mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0;\n    }\n    \n    public static boolean isCollectionMapOrArray(Class<?> type) {\n        if (type.isArray()) return true;\n        if (Collection.class.isAssignableFrom(type)) return true;\n        if (Map.class.isAssignableFrom(type)) return true;\n        return false;\n    }\n\n    public static boolean isBogusClass(Class<?> cls) {\n        return (cls == Void.class || cls == Void.TYPE\n                || cls == com.fasterxml.jackson.databind.annotation.NoClass.class);\n    }\n\n    public static boolean isNonStaticInnerClass(Class<?> cls) {\n        return !Modifier.isStatic(cls.getModifiers())\n                && (getEnclosingClass(cls) != null);\n    }\n\n    \n    public static boolean isObjectOrPrimitive(Class<?> cls) {\n        return (cls == CLS_OBJECT) || cls.isPrimitive();\n    }\n\n    \n    public static boolean hasClass(Object inst, Class<?> raw) {\n        \n        \n        return (inst != null) && (inst.getClass() == raw);\n    }\n\n    \n    public static void verifyMustOverride(Class<?> expType, Object instance, String method) {\n        if (instance.getClass() != expType) {\n            throw new IllegalStateException(String.format(\n                    \"Sub-class %s (of class %s) must override method '%s'\",\n                instance.getClass().getName(), expType.getName(), method));\n        }\n    }\n\n    \n\n    \n    @Deprecated \n    public static boolean hasGetterSignature(Method m) {\n        \n        if (Modifier.isStatic(m.getModifiers())) {\n            return false;\n        }\n        \n        Class<?>[] pts = m.getParameterTypes();\n        if (pts != null && pts.length != 0) {\n            return false;\n        }\n        \n        if (Void.TYPE == m.getReturnType()) {\n            return false;\n        }\n        \n        return true;\n    }\n\n    \n\n    \n    public static Throwable throwIfError(Throwable t) {\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        return t;\n    }\n\n    \n    public static Throwable throwIfRTE(Throwable t) {\n        if (t instanceof RuntimeException) {\n            throw (RuntimeException) t;\n        }\n        return t;\n    }\n\n    \n    public static Throwable throwIfIOE(Throwable t) throws IOException {\n        if (t instanceof IOException) {\n            throw (IOException) t;\n        }\n        return t;\n    }\n\n    \n    \n    \n    public static Throwable getRootCause(Throwable t) {\n        while (t.getCause() != null) {\n            t = t.getCause();\n        }\n        return t;\n    }\n\n    \n    public static Throwable throwRootCauseIfIOE(Throwable t) throws IOException {\n        return throwIfIOE(getRootCause(t));\n    }\n\n    \n    public static void throwAsIAE(Throwable t) {\n        throwAsIAE(t, t.getMessage());\n    }\n\n    \n    public static void throwAsIAE(Throwable t, String msg) {\n        throwIfRTE(t);\n        throwIfError(t);\n        throw new IllegalArgumentException(msg, t);\n    }\n\n    \n    public static <T> T throwAsMappingException(DeserializationContext ctxt, IOException e0) throws JsonMappingException {\n        if (e0 instanceof JsonMappingException) {\n            throw (JsonMappingException) e0;\n        }\n        JsonMappingException e = JsonMappingException.from(ctxt, e0.getMessage());\n        e.initCause(e0);\n        throw e;\n    }\n\n    \n    public static void unwrapAndThrowAsIAE(Throwable t) {\n        throwAsIAE(getRootCause(t));\n    }\n\n    \n    public static void unwrapAndThrowAsIAE(Throwable t, String msg) {\n        throwAsIAE(getRootCause(t), msg);\n    }\n\n    \n    public static void closeOnFailAndThrowAsIOE(JsonGenerator g, Exception fail) throws IOException {\n        \n        g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n        try {\n            g.close();\n        } catch (Exception e) {\n            fail.addSuppressed(e);\n        }\n        throwIfIOE(fail);\n        throwIfRTE(fail);\n        throw new RuntimeException(fail);\n    }\n\n    \n    public static void closeOnFailAndThrowAsIOE(JsonGenerator g, Closeable toClose, Exception fail) throws IOException {\n        if (g != null) {\n            g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n            try {\n                g.close();\n            } catch (Exception e) {\n                fail.addSuppressed(e);\n            }\n        }\n        if (toClose != null) {\n            try {\n                toClose.close();\n            } catch (Exception e) {\n                fail.addSuppressed(e);\n            }\n        }\n        throwIfIOE(fail);\n        throwIfRTE(fail);\n        throw new RuntimeException(fail);\n    }\n\n    \n\n    \n    public static <T> T createInstance(Class<T> cls, boolean canFixAccess) throws IllegalArgumentException {\n        Constructor<T> ctor = findConstructor(cls, canFixAccess);\n        if (ctor == null) {\n            throw new IllegalArgumentException(\"Class \"+cls.getName()+\" has no default (no arg) constructor\");\n        }\n        try {\n            return ctor.newInstance();\n        } catch (Exception e) {\n            ClassUtil.unwrapAndThrowAsIAE(e, \"Failed to instantiate class \"+cls.getName()+\", problem: \"+e.getMessage());\n            return null;\n        }\n    }\n\n    public static <T> Constructor<T> findConstructor(Class<T> cls, boolean forceAccess) throws IllegalArgumentException {\n        try {\n            Constructor<T> ctor = cls.getDeclaredConstructor();\n            if (forceAccess) {\n                checkAndFixAccess(ctor, forceAccess);\n            } else {\n                \n                if (!Modifier.isPublic(ctor.getModifiers())) {\n                    throw new IllegalArgumentException(\"Default constructor for \"+cls.getName()+\" is not accessible (non-public?): not allowed to try modify access via Reflection: cannot instantiate type\"); } } return ctor; } catch (NoSuchMethodException e) { ; } catch (Exception e) { ClassUtil.unwrapAndThrowAsIAE(e, \"Failed to find default constructor of class \"+cls.getName()+\", problem: \"+e.getMessage()); } return null; } public static Class<?> classOf(Object inst) {\n        if (inst == null) {\n            return null;\n        }\n        return inst.getClass();\n    }\n    \n    \n    public static Class<?> rawClass(JavaType t) {\n        if (t == null) {\n            return null;\n        }\n        return t.getRawClass();\n    }\n\n    \n    public static <T> T nonNull(T valueOrNull, T defaultValue) {\n        return (valueOrNull == null) ? defaultValue : valueOrNull;\n    }\n\n    \n    public static String nullOrToString(Object value) {\n        if (value == null) {\n            return null;\n        }\n        return value.toString();\n    }\n\n    \n    public static String nonNullString(String str) {\n        if (str == null) {\n            return \"\";\n        }\n        return str;\n    }\n\n    \n    public static String quotedOr(Object str, String forNull) {\n        if (str == null) {\n            return forNull;\n        }\n        return String.format(\"\\\"%s\\\"\", str);\n    }\n\n    \n    \n    \n    public static String getClassDescription(Object classOrInstance) {\n        if (classOrInstance == null) {\n            return \"unknown\";\n        }\n        Class<?> cls = (classOrInstance instanceof Class<?>) ?\n            (Class<?>) classOrInstance : classOrInstance.getClass();\n        return nameOf(cls);\n    }\n\n    \n    public static String classNameOf(Object inst) {\n        if (inst == null) {\n            return \"[null]\";\n        }\n        return nameOf(inst.getClass());\n    }\n\n    \n    public static String nameOf(Class<?> cls) {\n        if (cls == null) {\n            return \"[null]\";\n        }\n        int index = 0;\n        while (cls.isArray()) {\n            ++index;\n            cls = cls.getComponentType();\n        }\n        String base = cls.isPrimitive() ? cls.getSimpleName() : cls.getName();\n        if (index > 0) {\n            StringBuilder sb = new StringBuilder(base);\n            do {\n                sb.append(\"[]\");\n            } while (--index > 0);\n            base = sb.toString();\n        }\n        return backticked(base);\n    }\n\n    \n    public static String nameOf(Named named) {\n        if (named == null) {\n            return \"[null]\";\n        }\n        return backticked(named.getName());\n    }\n\n    \n    \n    \n    public static String backticked(String text) {\n        if (text == null) {\n            return \"[null]\";\n        }\n        return new StringBuilder(text.length()+2).append('`').append(text).append('`').toString();\n    }\n\n    \n    \n    \n    \n    \n    public static Object defaultValue(Class<?> cls) {\n        if (cls == Integer.TYPE) {\n            return Integer.valueOf(0);\n        }\n        if (cls == Long.TYPE) {\n            return Long.valueOf(0L);\n        }\n        if (cls == Boolean.TYPE) {\n            return Boolean.FALSE;\n        }\n        if (cls == Double.TYPE) {\n            return Double.valueOf(0.0);\n        }\n        if (cls == Float.TYPE) {\n            return Float.valueOf(0.0f);\n        }\n        if (cls == Byte.TYPE) {\n            return Byte.valueOf((byte) 0);\n        }\n        if (cls == Short.TYPE) {\n            return Short.valueOf((short) 0);\n        }\n        if (cls == Character.TYPE) {\n            return '\\0';\n        }\n        throw new IllegalArgumentException(\"Class \"+cls.getName()+\" is not a primitive type\");\n    }\n\n    \n    public static Class<?> wrapperType(Class<?> primitiveType) {\n        if (primitiveType == Integer.TYPE) {\n            return Integer.class;\n        }\n        if (primitiveType == Long.TYPE) {\n            return Long.class;\n        }\n        if (primitiveType == Boolean.TYPE) {\n            return Boolean.class;\n        }\n        if (primitiveType == Double.TYPE) {\n            return Double.class;\n        }\n        if (primitiveType == Float.TYPE) {\n            return Float.class;\n        }\n        if (primitiveType == Byte.TYPE) {\n            return Byte.class;\n        }\n        if (primitiveType == Short.TYPE) {\n            return Short.class;\n        }\n        if (primitiveType == Character.TYPE) {\n            return Character.class;\n        }\n        throw new IllegalArgumentException(\"Class \"+primitiveType.getName()+\" is not a primitive type\");\n    }\n\n    \n    public static Class<?> primitiveType(Class<?> type) {\n        if (type.isPrimitive()) {\n            return type;\n        }\n        \n        if (type == Integer.class) {\n            return Integer.TYPE;\n        }\n        if (type == Long.class) {\n            return Long.TYPE;\n        }\n        if (type == Boolean.class) {\n            return Boolean.TYPE;\n        }\n        if (type == Double.class) {\n            return Double.TYPE;\n        }\n        if (type == Float.class) {\n            return Float.TYPE;\n        }\n        if (type == Byte.class) {\n            return Byte.TYPE;\n        }\n        if (type == Short.class) {\n            return Short.TYPE;\n        }\n        if (type == Character.class) {\n            return Character.TYPE;\n        }\n        return null;\n    }\n\n    \n\n    \n    @Deprecated\n    public static void checkAndFixAccess(Member member) {\n        checkAndFixAccess(member, false);\n    }\n\n    \n    public static void checkAndFixAccess(Member member, boolean force) {\n        \n        AccessibleObject ao = (AccessibleObject) member;\n\n        \n        try {\n            if (force || \n                    (!Modifier.isPublic(member.getModifiers())\n                            || !Modifier.isPublic(member.getDeclaringClass().getModifiers()))) {\n                ao.setAccessible(true);\n            }\n        } catch (SecurityException se) {\n            \n            \n            if (!ao.isAccessible()) {\n                Class<?> declClass = member.getDeclaringClass();\n                throw new IllegalArgumentException(\"Cannot access \"+member+\" (from class \"+declClass.getName()+\"; failed to set access: \"+se.getMessage());\n            }\n        }\n    }\n\n    \n\n    \n    public static Class<? extends Enum<?>> findEnumType(EnumSet<?> s) {\n        \n        if (!s.isEmpty()) {\n            return findEnumType(s.iterator().next());\n        }\n        \n        return EnumTypeLocator.instance.enumTypeFor(s);\n    }\n\n    \n    public static Class<? extends Enum<?>> findEnumType(EnumMap<?,?> m) {\n        if (!m.isEmpty()) {\n            return findEnumType(m.keySet().iterator().next());\n        }\n        \n        return EnumTypeLocator.instance.enumTypeFor(m);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public static Class<? extends Enum<?>> findEnumType(Enum<?> en) {\n        \n    \tClass<?> ec = en.getClass();\n    \tif (ec.getSuperclass() != Enum.class) {\n    \t    ec = ec.getSuperclass();\n    \t}\n    \treturn (Class<? extends Enum<?>>) ec;\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public static Class<? extends Enum<?>> findEnumType(Class<?> cls) {\n        \n        if (cls.getSuperclass() != Enum.class) {\n            cls = cls.getSuperclass();\n        }\n        return (Class<? extends Enum<?>>) cls;\n    }\n\n    \n    public static <T extends Annotation> Enum<?> findFirstAnnotatedEnumValue(Class<Enum<?>> enumClass, Class<T> annotationClass) {\n        Field[] fields = getDeclaredFields(enumClass);\n        for (Field field : fields) {\n            if (field.isEnumConstant()) {\n                Annotation defaultValueAnnotation = field.getAnnotation(annotationClass);\n                if (defaultValueAnnotation != null) {\n                    final String name = field.getName();\n                    for (Enum<?> enumValue : enumClass.getEnumConstants()) {\n                        if (name.equals(enumValue.name())) {\n                            return enumValue;\n                        }\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    \n\n    \n    public static boolean isJacksonStdImpl(Object impl) {\n        return (impl == null) || isJacksonStdImpl(impl.getClass());\n    }\n\n    public static boolean isJacksonStdImpl(Class<?> implClass) {\n        return (implClass.getAnnotation(JacksonStdImpl.class) != null);\n    }\n\n    \n\n    \n    public static String getPackageName(Class<?> cls) {\n        Package pkg = cls.getPackage();\n        return (pkg == null) ? null : pkg.getName();\n    }\n\n    \n    public static boolean hasEnclosingMethod(Class<?> cls) {\n        return !isObjectOrPrimitive(cls) && (cls.getEnclosingMethod() != null);\n    }\n\n    \n    public static Field[] getDeclaredFields(Class<?> cls) {\n        return cls.getDeclaredFields();\n    }\n\n    \n    public static Method[] getDeclaredMethods(Class<?> cls) {\n        return cls.getDeclaredMethods();\n    }\n\n    \n    public static Annotation[] findClassAnnotations(Class<?> cls) {\n        if (isObjectOrPrimitive(cls)) {\n            return NO_ANNOTATIONS;\n        }\n        return cls.getDeclaredAnnotations();\n    }\n\n    \n    public static Method[] getClassMethods(Class<?> cls) {\n        try {\n            return ClassUtil.getDeclaredMethods(cls);\n        } catch (final NoClassDefFoundError ex) {\n            \n            \n            final ClassLoader loader = Thread.currentThread().getContextClassLoader();\n            if (loader == null){\n                \n                throw ex;\n            }\n            final Class<?> contextClass;\n            try {\n                contextClass = loader.loadClass(cls.getName());\n            } catch (ClassNotFoundException e) {\n                ex.addSuppressed(e);\n                throw ex;\n            }\n            return contextClass.getDeclaredMethods(); \n        }\n    }\n    \n    \n    public static Ctor[] getConstructors(Class<?> cls) {\n        \n        \n        if (cls.isInterface() || isObjectOrPrimitive(cls)) {\n            return NO_CTORS;\n        }\n        Constructor<?>[] rawCtors = cls.getDeclaredConstructors();\n        final int len = rawCtors.length;\n        Ctor[] result = new Ctor[len];\n        for (int i = 0; i < len; ++i) {\n            result[i] = new Ctor(rawCtors[i]);\n        }\n        return result;\n    }\n\n    \n    \n\n    \n    public static Class<?> getDeclaringClass(Class<?> cls) {\n        return isObjectOrPrimitive(cls) ? null : cls.getDeclaringClass();\n    }\n\n    \n    public static Type getGenericSuperclass(Class<?> cls) {\n        return cls.getGenericSuperclass();\n    }\n\n    \n    public static Type[] getGenericInterfaces(Class<?> cls) {\n        return cls.getGenericInterfaces();\n    }\n\n    \n    public static Class<?> getEnclosingClass(Class<?> cls) {\n        \n        return isObjectOrPrimitive(cls) ? null : cls.getEnclosingClass();\n    }\n\n    private static Class<?>[] _interfaces(Class<?> cls) {\n        return cls.getInterfaces();\n    }\n\n    \n\n    \n    private static class EnumTypeLocator { final static EnumTypeLocator instance = new EnumTypeLocator(); private final Field enumSetTypeField; private final Field enumMapTypeField; private EnumTypeLocator() {\n            \n            \n    \t        enumSetTypeField = locateField(EnumSet.class, \"elementType\", Class.class);\n    \t        enumMapTypeField = locateField(EnumMap.class, \"elementType\", Class.class);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public Class<? extends Enum<?>> enumTypeFor(EnumSet<?> set) {\n            if (enumSetTypeField != null) {\n                return (Class<? extends Enum<?>>) get(set, enumSetTypeField);\n            }\n            throw new IllegalStateException(\"Cannot figure out type for EnumSet (odd JDK platform?)\");\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public Class<? extends Enum<?>> enumTypeFor(EnumMap<?,?> set) {\n            if (enumMapTypeField != null) {\n                return (Class<? extends Enum<?>>) get(set, enumMapTypeField);\n            }\n            throw new IllegalStateException(\"Cannot figure out type for EnumMap (odd JDK platform?)\");\n        }\n    \t\n        private Object get(Object bean, Field field) {\n            try {\n                return field.get(bean);\n            } catch (Exception e) {\n                throw new IllegalArgumentException(e);\n            }\n        }\n    \t\n        private static Field locateField(Class<?> fromClass, String expectedName, Class<?> type) {\n            Field found = null;\n    \t        \n            Field[] fields = getDeclaredFields(fromClass);\n    \t        for (Field f : fields) {\n    \t            if (expectedName.equals(f.getName()) && f.getType() == type) {\n    \t                found = f;\n    \t                break;\n    \t            }\n    \t        }\n    \t        \n    \t        if (found == null) {\n    \t            for (Field f : fields) {\n    \t                if (f.getType() == type) {\n    \t                    \n    \t                    if (found != null) return null;\n    \t                    found = f;\n    \t                }\n    \t            }\n    \t        }\n    \t        if (found != null) { \n    \t            try {\n    \t                found.setAccessible(true);\n    \t            } catch (Throwable t) { }\n    \t        }\n    \t        return found;\n        }\n    }\n\n    \n\n    \n    public final static class Ctor { public final Constructor<?> _ctor; private Annotation[] _annotations; private Annotation[][] _paramAnnotations; private int _paramCount = -1; public Ctor(Constructor<?> ctor) {\n            _ctor = ctor;\n        }\n\n        public Constructor<?> getConstructor() {\n            return _ctor;\n        }\n\n        public int getParamCount() {\n            int c = _paramCount;\n            if (c < 0) {\n                c = _ctor.getParameterTypes().length;\n                _paramCount = c;\n            }\n            return c;\n        }\n\n        public Class<?> getDeclaringClass() {\n            return _ctor.getDeclaringClass();\n        }\n\n        public Annotation[] getDeclaredAnnotations() {\n            Annotation[] result = _annotations;\n            if (result == null) {\n                result = _ctor.getDeclaredAnnotations();\n                _annotations = result;\n            }\n            return result;\n        }\n\n        public Annotation[][] getParameterAnnotations() {\n            Annotation[][] result = _paramAnnotations;\n            if (result == null) {\n                result = _ctor.getParameterAnnotations();\n                _paramAnnotations = result;\n            }\n            return result;\n        }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.util;\n\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.*;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n\npublic final class ClassUtil { private final static Class<?> CLS_OBJECT = Object.class; private final static Annotation[] NO_ANNOTATIONS = new Annotation[0]; private final static Ctor[] NO_CTORS = new Ctor[0]; private final static Iterator<?> EMPTY_ITERATOR = Collections.emptyIterator(); @SuppressWarnings(\"unchecked\") public static <T> Iterator<T> emptyIterator() {\n        return (Iterator<T>) EMPTY_ITERATOR;\n    }\n\n    \n\n    \n    public static List<JavaType> findSuperTypes(JavaType type, Class<?> endBefore, boolean addClassItself) {\n        if ((type == null) || type.hasRawClass(endBefore) || type.hasRawClass(Object.class)) {\n            return Collections.emptyList();\n        }\n        List<JavaType> result = new ArrayList<JavaType>(8);\n        _addSuperTypes(type, endBefore, result, addClassItself);\n        return result;\n    }\n\n    \n    public static List<Class<?>> findRawSuperTypes(Class<?> cls, Class<?> endBefore, boolean addClassItself) {\n        if ((cls == null) || (cls == endBefore) || (cls == Object.class)) {\n            return Collections.emptyList();\n        }\n        List<Class<?>> result = new ArrayList<Class<?>>(8);\n        _addRawSuperTypes(cls, endBefore, result, addClassItself);\n        return result;\n    }\n\n    \n    public static List<Class<?>> findSuperClasses(Class<?> cls, Class<?> endBefore, boolean addClassItself) {\n        List<Class<?>> result = new LinkedList<Class<?>>();\n        if ((cls != null) && (cls != endBefore))  {\n            if (addClassItself) {\n                result.add(cls);\n            }\n            while ((cls = cls.getSuperclass()) != null) {\n                if (cls == endBefore) {\n                    break;\n                }\n                result.add(cls);\n            }\n        }\n        return result;\n    }\n\n    @Deprecated \n    public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore) {\n        return findSuperTypes(cls, endBefore, new ArrayList<Class<?>>(8));\n    }\n\n    @Deprecated \n    public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore, List<Class<?>> result) {\n        _addRawSuperTypes(cls, endBefore, result, false);\n        return result;\n    }\n\n    private static void _addSuperTypes(JavaType type, Class<?> endBefore, Collection<JavaType> result, boolean addClassItself) {\n        if (type == null) {\n            return;\n        }\n        final Class<?> cls = type.getRawClass();\n        if (cls == endBefore || cls == Object.class) { return; }\n        if (addClassItself) {\n            if (result.contains(type)) { \n                return;\n            }\n            result.add(type);\n        }\n        for (JavaType intCls : type.getInterfaces()) {\n            _addSuperTypes(intCls, endBefore, result, true);\n        }\n        _addSuperTypes(type.getSuperClass(), endBefore, result, true);\n    }\n\n    private static void _addRawSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself) {\n        if (cls == endBefore || cls == null || cls == Object.class) { return; }\n        if (addClassItself) {\n            if (result.contains(cls)) { \n                return;\n            }\n            result.add(cls);\n        }\n        for (Class<?> intCls : _interfaces(cls)) {\n            _addRawSuperTypes(intCls, endBefore, result, true);\n        }\n        _addRawSuperTypes(cls.getSuperclass(), endBefore, result, true);\n    }\n\n    \n\n    \n    public static String canBeABeanType(Class<?> type) {\n        \n        if (type.isAnnotation()) {\n            return \"annotation\";\n        }\n        if (type.isArray()) {\n            return \"array\";\n        }\n        if (type.isEnum()) {\n            return \"enum\";\n        }\n        if (type.isPrimitive()) {\n            return \"primitive\";\n        }\n\n        \n        return null;\n    }\n    \n    public static String isLocalType(Class<?> type, boolean allowNonStatic) {\n        \n        try {\n            \n            if (hasEnclosingMethod(type)) {\n                return \"local/anonymous\";\n            }\n            \n            \n            if (!allowNonStatic) {\n                if (!Modifier.isStatic(type.getModifiers())) {\n                    if (getEnclosingClass(type) != null) {\n                        return \"non-static member class\"; } } } } catch (SecurityException e) { }\n        catch (NullPointerException e) { }\n        return null;\n    }\n\n    \n    public static Class<?> getOuterClass(Class<?> type) {\n        \n        try {\n            \n            if (hasEnclosingMethod(type)) {\n                return null;\n            }\n            if (!Modifier.isStatic(type.getModifiers())) {\n                return getEnclosingClass(type);\n            }\n        } catch (SecurityException e) { }\n        return null;\n    }\n    \n    \n    \n    public static boolean isProxyType(Class<?> type) {\n        \n        \n        String name = type.getName();\n        \n        if (name.startsWith(\"net.sf.cglib.proxy.\")\n            || name.startsWith(\"org.hibernate.proxy.\")) {\n            return true;\n        }\n        \n        return false;\n    }\n\n    \n    public static boolean isConcrete(Class<?> type) {\n        int mod = type.getModifiers();\n        return (mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0;\n    }\n\n    public static boolean isConcrete(Member member) {\n        int mod = member.getModifiers();\n        return (mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0;\n    }\n    \n    public static boolean isCollectionMapOrArray(Class<?> type) {\n        if (type.isArray()) return true;\n        if (Collection.class.isAssignableFrom(type)) return true;\n        if (Map.class.isAssignableFrom(type)) return true;\n        return false;\n    }\n\n    public static boolean isBogusClass(Class<?> cls) {\n        return (cls == Void.class || cls == Void.TYPE\n                || cls == com.fasterxml.jackson.databind.annotation.NoClass.class);\n    }\n\n    public static boolean isNonStaticInnerClass(Class<?> cls) {\n        return !Modifier.isStatic(cls.getModifiers())\n                && (getEnclosingClass(cls) != null);\n    }\n\n    \n    public static boolean isObjectOrPrimitive(Class<?> cls) {\n        return (cls == CLS_OBJECT) || cls.isPrimitive();\n    }\n\n    \n    public static boolean hasClass(Object inst, Class<?> raw) {\n        \n        \n        return (inst != null) && (inst.getClass() == raw);\n    }\n\n    \n    public static void verifyMustOverride(Class<?> expType, Object instance, String method) {\n        if (instance.getClass() != expType) {\n            throw new IllegalStateException(String.format(\n                    \"Sub-class %s (of class %s) must override method '%s'\",\n                instance.getClass().getName(), expType.getName(), method));\n        }\n    }\n\n    \n\n    \n    @Deprecated \n    public static boolean hasGetterSignature(Method m) {\n        \n        if (Modifier.isStatic(m.getModifiers())) {\n            return false;\n        }\n        \n        Class<?>[] pts = m.getParameterTypes();\n        if (pts != null && pts.length != 0) {\n            return false;\n        }\n        \n        if (Void.TYPE == m.getReturnType()) {\n            return false;\n        }\n        \n        return true;\n    }\n\n    \n\n    \n    public static Throwable throwIfError(Throwable t) {\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        return t;\n    }\n\n    \n    public static Throwable throwIfRTE(Throwable t) {\n        if (t instanceof RuntimeException) {\n            throw (RuntimeException) t;\n        }\n        return t;\n    }\n\n    \n    public static Throwable throwIfIOE(Throwable t) throws IOException {\n        if (t instanceof IOException) {\n            throw (IOException) t;\n        }\n        return t;\n    }\n\n    \n    \n    \n    public static Throwable getRootCause(Throwable t) {\n        while (t.getCause() != null) {\n            t = t.getCause();\n        }\n        return t;\n    }\n\n    \n    public static Throwable throwRootCauseIfIOE(Throwable t) throws IOException {\n        return throwIfIOE(getRootCause(t));\n    }\n\n    \n    public static void throwAsIAE(Throwable t) {\n        throwAsIAE(t, t.getMessage());\n    }\n\n    \n    public static void throwAsIAE(Throwable t, String msg) {\n        throwIfRTE(t);\n        throwIfError(t);\n        throw new IllegalArgumentException(msg, t);\n    }\n\n    \n    public static <T> T throwAsMappingException(DeserializationContext ctxt, IOException e0) throws JsonMappingException {\n        if (e0 instanceof JsonMappingException) {\n            throw (JsonMappingException) e0;\n        }\n        JsonMappingException e = JsonMappingException.from(ctxt, e0.getMessage());\n        e.initCause(e0);\n        throw e;\n    }\n\n    \n    public static void unwrapAndThrowAsIAE(Throwable t) {\n        throwAsIAE(getRootCause(t));\n    }\n\n    \n    public static void unwrapAndThrowAsIAE(Throwable t, String msg) {\n        throwAsIAE(getRootCause(t), msg);\n    }\n\n    \n    public static void closeOnFailAndThrowAsIOE(JsonGenerator g, Exception fail) throws IOException {\n        \n        g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n        try {\n            g.close();\n        } catch (Exception e) {\n            fail.addSuppressed(e);\n        }\n        throwIfIOE(fail);\n        throwIfRTE(fail);\n        throw new RuntimeException(fail);\n    }\n\n    \n    public static void closeOnFailAndThrowAsIOE(JsonGenerator g, Closeable toClose, Exception fail) throws IOException {\n        if (g != null) {\n            g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n            try {\n                g.close();\n            } catch (Exception e) {\n                fail.addSuppressed(e);\n            }\n        }\n        if (toClose != null) {\n            try {\n                toClose.close();\n            } catch (Exception e) {\n                fail.addSuppressed(e);\n            }\n        }\n        throwIfIOE(fail);\n        throwIfRTE(fail);\n        throw new RuntimeException(fail);\n    }\n\n    \n\n    \n    public static <T> T createInstance(Class<T> cls, boolean canFixAccess) throws IllegalArgumentException {\n        Constructor<T> ctor = findConstructor(cls, canFixAccess);\n        if (ctor == null) {\n            throw new IllegalArgumentException(\"Class \"+cls.getName()+\" has no default (no arg) constructor\");\n        }\n        try {\n            return ctor.newInstance();\n        } catch (Exception e) {\n            ClassUtil.unwrapAndThrowAsIAE(e, \"Failed to instantiate class \"+cls.getName()+\", problem: \"+e.getMessage());\n            return null;\n        }\n    }\n\n    public static <T> Constructor<T> findConstructor(Class<T> cls, boolean forceAccess) throws IllegalArgumentException {\n        try {\n            Constructor<T> ctor = cls.getDeclaredConstructor();\n            if (forceAccess) {\n                checkAndFixAccess(ctor, forceAccess);\n            } else {\n                \n                if (!Modifier.isPublic(ctor.getModifiers())) {\n                    throw new IllegalArgumentException(\"Default constructor for \"+cls.getName()+\" is not accessible (non-public?): not allowed to try modify access via Reflection: cannot instantiate type\"); } } return ctor; } catch (NoSuchMethodException e) { ; } catch (Exception e) { ClassUtil.unwrapAndThrowAsIAE(e, \"Failed to find default constructor of class \"+cls.getName()+\", problem: \"+e.getMessage()); } return null; } public static Class<?> classOf(Object inst) {\n        if (inst == null) {\n            return null;\n        }\n        return inst.getClass();\n    }\n    \n    \n    public static Class<?> rawClass(JavaType t) {\n        if (t == null) {\n            return null;\n        }\n        return t.getRawClass();\n    }\n\n    \n    public static <T> T nonNull(T valueOrNull, T defaultValue) {\n        return (valueOrNull == null) ? defaultValue : valueOrNull;\n    }\n\n    \n    public static String nullOrToString(Object value) {\n        if (value == null) {\n            return null;\n        }\n        return value.toString();\n    }\n\n    \n    public static String nonNullString(String str) {\n        if (str == null) {\n            return \"\";\n        }\n        return str;\n    }\n\n    \n    public static String quotedOr(Object str, String forNull) {\n        if (str == null) {\n            return forNull;\n        }\n        return String.format(\"\\\"%s\\\"\", str);\n    }\n\n    \n    \n    \n    public static String getClassDescription(Object classOrInstance) {\n        if (classOrInstance == null) {\n            return \"unknown\";\n        }\n        Class<?> cls = (classOrInstance instanceof Class<?>) ?\n            (Class<?>) classOrInstance : classOrInstance.getClass();\n        return nameOf(cls);\n    }\n\n    \n    public static String classNameOf(Object inst) {\n        if (inst == null) {\n            return \"[null]\";\n        }\n        return nameOf(inst.getClass());\n    }\n\n    \n    public static String nameOf(Class<?> cls) {\n        if (cls == null) {\n            return \"[null]\";\n        }\n        int index = 0;\n        while (cls.isArray()) {\n            ++index;\n            cls = cls.getComponentType();\n        }\n        String base = cls.isPrimitive() ? cls.getSimpleName() : cls.getName();\n        if (index > 0) {\n            StringBuilder sb = new StringBuilder(base);\n            do {\n                sb.append(\"[]\");\n            } while (--index > 0);\n            base = sb.toString();\n        }\n        return backticked(base);\n    }\n\n    \n    public static String nameOf(Named named) {\n        if (named == null) {\n            return \"[null]\";\n        }\n        return backticked(named.getName());\n    }\n\n    \n    \n    \n    public static String backticked(String text) {\n        if (text == null) {\n            return \"[null]\";\n        }\n        return new StringBuilder(text.length()+2).append('`').append(text).append('`').toString();\n    }\n\n    \n    public static String exceptionMessage(Throwable t) {\n        if (t instanceof JsonProcessingException) {\n            return ((JsonProcessingException) t).getOriginalMessage();\n        }\n        return t.getMessage();\n    }\n    \n    \n    \n    \n    public static Object defaultValue(Class<?> cls) {\n        if (cls == Integer.TYPE) {\n            return Integer.valueOf(0);\n        }\n        if (cls == Long.TYPE) {\n            return Long.valueOf(0L);\n        }\n        if (cls == Boolean.TYPE) {\n            return Boolean.FALSE;\n        }\n        if (cls == Double.TYPE) {\n            return Double.valueOf(0.0);\n        }\n        if (cls == Float.TYPE) {\n            return Float.valueOf(0.0f);\n        }\n        if (cls == Byte.TYPE) {\n            return Byte.valueOf((byte) 0);\n        }\n        if (cls == Short.TYPE) {\n            return Short.valueOf((short) 0);\n        }\n        if (cls == Character.TYPE) {\n            return '\\0';\n        }\n        throw new IllegalArgumentException(\"Class \"+cls.getName()+\" is not a primitive type\");\n    }\n\n    \n    public static Class<?> wrapperType(Class<?> primitiveType) {\n        if (primitiveType == Integer.TYPE) {\n            return Integer.class;\n        }\n        if (primitiveType == Long.TYPE) {\n            return Long.class;\n        }\n        if (primitiveType == Boolean.TYPE) {\n            return Boolean.class;\n        }\n        if (primitiveType == Double.TYPE) {\n            return Double.class;\n        }\n        if (primitiveType == Float.TYPE) {\n            return Float.class;\n        }\n        if (primitiveType == Byte.TYPE) {\n            return Byte.class;\n        }\n        if (primitiveType == Short.TYPE) {\n            return Short.class;\n        }\n        if (primitiveType == Character.TYPE) {\n            return Character.class;\n        }\n        throw new IllegalArgumentException(\"Class \"+primitiveType.getName()+\" is not a primitive type\");\n    }\n\n    \n    public static Class<?> primitiveType(Class<?> type) {\n        if (type.isPrimitive()) {\n            return type;\n        }\n        \n        if (type == Integer.class) {\n            return Integer.TYPE;\n        }\n        if (type == Long.class) {\n            return Long.TYPE;\n        }\n        if (type == Boolean.class) {\n            return Boolean.TYPE;\n        }\n        if (type == Double.class) {\n            return Double.TYPE;\n        }\n        if (type == Float.class) {\n            return Float.TYPE;\n        }\n        if (type == Byte.class) {\n            return Byte.TYPE;\n        }\n        if (type == Short.class) {\n            return Short.TYPE;\n        }\n        if (type == Character.class) {\n            return Character.TYPE;\n        }\n        return null;\n    }\n\n    \n\n    \n    @Deprecated\n    public static void checkAndFixAccess(Member member) {\n        checkAndFixAccess(member, false);\n    }\n\n    \n    public static void checkAndFixAccess(Member member, boolean force) {\n        \n        AccessibleObject ao = (AccessibleObject) member;\n\n        \n        try {\n            if (force || \n                    (!Modifier.isPublic(member.getModifiers())\n                            || !Modifier.isPublic(member.getDeclaringClass().getModifiers()))) {\n                ao.setAccessible(true);\n            }\n        } catch (SecurityException se) {\n            \n            \n            if (!ao.isAccessible()) {\n                Class<?> declClass = member.getDeclaringClass();\n                throw new IllegalArgumentException(\"Cannot access \"+member+\" (from class \"+declClass.getName()+\"; failed to set access: \"+se.getMessage());\n            }\n        }\n    }\n\n    \n\n    \n    public static Class<? extends Enum<?>> findEnumType(EnumSet<?> s) {\n        \n        if (!s.isEmpty()) {\n            return findEnumType(s.iterator().next());\n        }\n        \n        return EnumTypeLocator.instance.enumTypeFor(s);\n    }\n\n    \n    public static Class<? extends Enum<?>> findEnumType(EnumMap<?,?> m) {\n        if (!m.isEmpty()) {\n            return findEnumType(m.keySet().iterator().next());\n        }\n        \n        return EnumTypeLocator.instance.enumTypeFor(m);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public static Class<? extends Enum<?>> findEnumType(Enum<?> en) {\n        \n    \tClass<?> ec = en.getClass();\n    \tif (ec.getSuperclass() != Enum.class) {\n    \t    ec = ec.getSuperclass();\n    \t}\n    \treturn (Class<? extends Enum<?>>) ec;\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public static Class<? extends Enum<?>> findEnumType(Class<?> cls) {\n        \n        if (cls.getSuperclass() != Enum.class) {\n            cls = cls.getSuperclass();\n        }\n        return (Class<? extends Enum<?>>) cls;\n    }\n\n    \n    public static <T extends Annotation> Enum<?> findFirstAnnotatedEnumValue(Class<Enum<?>> enumClass, Class<T> annotationClass) {\n        Field[] fields = getDeclaredFields(enumClass);\n        for (Field field : fields) {\n            if (field.isEnumConstant()) {\n                Annotation defaultValueAnnotation = field.getAnnotation(annotationClass);\n                if (defaultValueAnnotation != null) {\n                    final String name = field.getName();\n                    for (Enum<?> enumValue : enumClass.getEnumConstants()) {\n                        if (name.equals(enumValue.name())) {\n                            return enumValue;\n                        }\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    \n\n    \n    public static boolean isJacksonStdImpl(Object impl) {\n        return (impl == null) || isJacksonStdImpl(impl.getClass());\n    }\n\n    public static boolean isJacksonStdImpl(Class<?> implClass) {\n        return (implClass.getAnnotation(JacksonStdImpl.class) != null);\n    }\n\n    \n\n    \n    public static String getPackageName(Class<?> cls) {\n        Package pkg = cls.getPackage();\n        return (pkg == null) ? null : pkg.getName();\n    }\n\n    \n    public static boolean hasEnclosingMethod(Class<?> cls) {\n        return !isObjectOrPrimitive(cls) && (cls.getEnclosingMethod() != null);\n    }\n\n    \n    public static Field[] getDeclaredFields(Class<?> cls) {\n        return cls.getDeclaredFields();\n    }\n\n    \n    public static Method[] getDeclaredMethods(Class<?> cls) {\n        return cls.getDeclaredMethods();\n    }\n\n    \n    public static Annotation[] findClassAnnotations(Class<?> cls) {\n        if (isObjectOrPrimitive(cls)) {\n            return NO_ANNOTATIONS;\n        }\n        return cls.getDeclaredAnnotations();\n    }\n\n    \n    public static Method[] getClassMethods(Class<?> cls) {\n        try {\n            return ClassUtil.getDeclaredMethods(cls);\n        } catch (final NoClassDefFoundError ex) {\n            \n            \n            final ClassLoader loader = Thread.currentThread().getContextClassLoader();\n            if (loader == null){\n                \n                throw ex;\n            }\n            final Class<?> contextClass;\n            try {\n                contextClass = loader.loadClass(cls.getName());\n            } catch (ClassNotFoundException e) {\n                ex.addSuppressed(e);\n                throw ex;\n            }\n            return contextClass.getDeclaredMethods(); \n        }\n    }\n    \n    \n    public static Ctor[] getConstructors(Class<?> cls) {\n        \n        \n        if (cls.isInterface() || isObjectOrPrimitive(cls)) {\n            return NO_CTORS;\n        }\n        Constructor<?>[] rawCtors = cls.getDeclaredConstructors();\n        final int len = rawCtors.length;\n        Ctor[] result = new Ctor[len];\n        for (int i = 0; i < len; ++i) {\n            result[i] = new Ctor(rawCtors[i]);\n        }\n        return result;\n    }\n\n    \n    \n\n    \n    public static Class<?> getDeclaringClass(Class<?> cls) {\n        return isObjectOrPrimitive(cls) ? null : cls.getDeclaringClass();\n    }\n\n    \n    public static Type getGenericSuperclass(Class<?> cls) {\n        return cls.getGenericSuperclass();\n    }\n\n    \n    public static Type[] getGenericInterfaces(Class<?> cls) {\n        return cls.getGenericInterfaces();\n    }\n\n    \n    public static Class<?> getEnclosingClass(Class<?> cls) {\n        \n        return isObjectOrPrimitive(cls) ? null : cls.getEnclosingClass();\n    }\n\n    private static Class<?>[] _interfaces(Class<?> cls) {\n        return cls.getInterfaces();\n    }\n\n    \n\n    \n    private static class EnumTypeLocator { final static EnumTypeLocator instance = new EnumTypeLocator(); private final Field enumSetTypeField; private final Field enumMapTypeField; private EnumTypeLocator() {\n            \n            \n    \t        enumSetTypeField = locateField(EnumSet.class, \"elementType\", Class.class);\n    \t        enumMapTypeField = locateField(EnumMap.class, \"elementType\", Class.class);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public Class<? extends Enum<?>> enumTypeFor(EnumSet<?> set) {\n            if (enumSetTypeField != null) {\n                return (Class<? extends Enum<?>>) get(set, enumSetTypeField);\n            }\n            throw new IllegalStateException(\"Cannot figure out type for EnumSet (odd JDK platform?)\");\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public Class<? extends Enum<?>> enumTypeFor(EnumMap<?,?> set) {\n            if (enumMapTypeField != null) {\n                return (Class<? extends Enum<?>>) get(set, enumMapTypeField);\n            }\n            throw new IllegalStateException(\"Cannot figure out type for EnumMap (odd JDK platform?)\");\n        }\n    \t\n        private Object get(Object bean, Field field) {\n            try {\n                return field.get(bean);\n            } catch (Exception e) {\n                throw new IllegalArgumentException(e);\n            }\n        }\n    \t\n        private static Field locateField(Class<?> fromClass, String expectedName, Class<?> type) {\n            Field found = null;\n    \t        \n            Field[] fields = getDeclaredFields(fromClass);\n    \t        for (Field f : fields) {\n    \t            if (expectedName.equals(f.getName()) && f.getType() == type) {\n    \t                found = f;\n    \t                break;\n    \t            }\n    \t        }\n    \t        \n    \t        if (found == null) {\n    \t            for (Field f : fields) {\n    \t                if (f.getType() == type) {\n    \t                    \n    \t                    if (found != null) return null;\n    \t                    found = f;\n    \t                }\n    \t            }\n    \t        }\n    \t        if (found != null) { \n    \t            try {\n    \t                found.setAccessible(true);\n    \t            } catch (Throwable t) { }\n    \t        }\n    \t        return found;\n        }\n    }\n\n    \n\n    \n    public final static class Ctor { public final Constructor<?> _ctor; private Annotation[] _annotations; private Annotation[][] _paramAnnotations; private int _paramCount = -1; public Ctor(Constructor<?> ctor) {\n            _ctor = ctor;\n        }\n\n        public Constructor<?> getConstructor() {\n            return _ctor;\n        }\n\n        public int getParamCount() {\n            int c = _paramCount;\n            if (c < 0) {\n                c = _ctor.getParameterTypes().length;\n                _paramCount = c;\n            }\n            return c;\n        }\n\n        public Class<?> getDeclaringClass() {\n            return _ctor.getDeclaringClass();\n        }\n\n        public Annotation[] getDeclaredAnnotations() {\n            Annotation[] result = _annotations;\n            if (result == null) {\n                result = _ctor.getDeclaredAnnotations();\n                _annotations = result;\n            }\n            return result;\n        }\n\n        public Annotation[][] getParameterAnnotations() {\n            Annotation[][] result = _paramAnnotations;\n            if (result == null) {\n                result = _ctor.getParameterAnnotations();\n                _paramAnnotations = result;\n            }\n            return result;\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public static List<JavaType> findSuperTypes(JavaType type, Class<?> endBefore, boolean addClassItself)",
        "public static List<Class<?>> findRawSuperTypes(Class<?> cls, Class<?> endBefore, boolean addClassItself)",
        "public static List<Class<?>> findSuperClasses(Class<?> cls, Class<?> endBefore, boolean addClassItself)",
        "public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore)",
        "public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore, List<Class<?>> result)",
        "private static void _addSuperTypes(JavaType type, Class<?> endBefore, Collection<JavaType> result, boolean addClassItself)",
        "private static void _addRawSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself)",
        "public static String canBeABeanType(Class<?> type)",
        "public static String isLocalType(Class<?> type, boolean allowNonStatic)",
        "static member class\"; } } } } catch (SecurityException e)",
        "public static Class<?> getOuterClass(Class<?> type)",
        "public static boolean isProxyType(Class<?> type)",
        "public static boolean isConcrete(Class<?> type)",
        "public static boolean isConcrete(Member member)",
        "public static boolean isCollectionMapOrArray(Class<?> type)",
        "public static boolean isBogusClass(Class<?> cls)",
        "public static boolean isNonStaticInnerClass(Class<?> cls)",
        "public static boolean isObjectOrPrimitive(Class<?> cls)",
        "public static boolean hasClass(Object inst, Class<?> raw)",
        "public static void verifyMustOverride(Class<?> expType, Object instance, String method)",
        "public static boolean hasGetterSignature(Method m)",
        "public static Throwable throwIfError(Throwable t)",
        "public static Throwable throwIfRTE(Throwable t)",
        "public static Throwable throwIfIOE(Throwable t) throws IOException",
        "public static Throwable getRootCause(Throwable t)",
        "public static Throwable throwRootCauseIfIOE(Throwable t) throws IOException",
        "public static void throwAsIAE(Throwable t)",
        "public static void throwAsIAE(Throwable t, String msg)",
        "public static <T> T throwAsMappingException(DeserializationContext ctxt, IOException e0) throws JsonMappingException",
        "public static void unwrapAndThrowAsIAE(Throwable t)",
        "public static void unwrapAndThrowAsIAE(Throwable t, String msg)",
        "public static void closeOnFailAndThrowAsIOE(JsonGenerator g, Exception fail) throws IOException",
        "public static void closeOnFailAndThrowAsIOE(JsonGenerator g, Closeable toClose, Exception fail) throws IOException",
        "public static <T> T createInstance(Class<T> cls, boolean canFixAccess) throws IllegalArgumentException",
        "public static <T> Constructor<T> findConstructor(Class<T> cls, boolean forceAccess) throws IllegalArgumentException",
        "public?): not allowed to try modify access via Reflection: cannot instantiate type\"); } } return ctor; } catch (NoSuchMethodException e) { ; } catch (Exception e) { ClassUtil.unwrapAndThrowAsIAE(e, \"Failed to find default constructor of class \"+cls.getName()+\", problem: \"+e.getMessage()); } return null; } public static Class<?> classOf(Object inst)",
        "public static Class<?> rawClass(JavaType t)",
        "public static <T> T nonNull(T valueOrNull, T defaultValue)",
        "public static String nullOrToString(Object value)",
        "public static String nonNullString(String str)",
        "public static String quotedOr(Object str, String forNull)",
        "public static String getClassDescription(Object classOrInstance)",
        "public static String classNameOf(Object inst)",
        "public static String nameOf(Class<?> cls)",
        "public static String nameOf(Named named)",
        "public static String backticked(String text)",
        "public static Object defaultValue(Class<?> cls)",
        "public static Class<?> wrapperType(Class<?> primitiveType)",
        "public static Class<?> primitiveType(Class<?> type)",
        "public static void checkAndFixAccess(Member member)",
        "public static void checkAndFixAccess(Member member, boolean force)",
        "public static Class<? extends Enum<?>> findEnumType(EnumSet<?> s)",
        "public static Class<? extends Enum<?>> findEnumType(EnumMap<?,?> m)",
        "public static Class<? extends Enum<?>> findEnumType(Enum<?> en)",
        "public static Class<? extends Enum<?>> findEnumType(Class<?> cls)",
        "public static <T extends Annotation> Enum<?> findFirstAnnotatedEnumValue(Class<Enum<?>> enumClass, Class<T> annotationClass)",
        "public static boolean isJacksonStdImpl(Object impl)",
        "public static boolean isJacksonStdImpl(Class<?> implClass)",
        "public static String getPackageName(Class<?> cls)",
        "public static boolean hasEnclosingMethod(Class<?> cls)",
        "public static Field[] getDeclaredFields(Class<?> cls)",
        "public static Method[] getDeclaredMethods(Class<?> cls)",
        "public static Annotation[] findClassAnnotations(Class<?> cls)",
        "public static Method[] getClassMethods(Class<?> cls)",
        "public static Ctor[] getConstructors(Class<?> cls)",
        "public static Class<?> getDeclaringClass(Class<?> cls)",
        "public static Type getGenericSuperclass(Class<?> cls)",
        "public static Type[] getGenericInterfaces(Class<?> cls)",
        "public static Class<?> getEnclosingClass(Class<?> cls)",
        "private static Class<?>[] _interfaces(Class<?> cls)",
        "public Class<? extends Enum<?>> enumTypeFor(EnumSet<?> set)",
        "public Class<? extends Enum<?>> enumTypeFor(EnumMap<?,?> set)",
        "private Object get(Object bean, Field field)",
        "private static Field locateField(Class<?> fromClass, String expectedName, Class<?> type)",
        "public Constructor<?> getConstructor()",
        "public int getParamCount()",
        "public Class<?> getDeclaringClass()",
        "public Annotation[] getDeclaredAnnotations()",
        "public Annotation[][] getParameterAnnotations()"
      ],
      "fixed_signatures": [
        "public static List<JavaType> findSuperTypes(JavaType type, Class<?> endBefore, boolean addClassItself)",
        "public static List<Class<?>> findRawSuperTypes(Class<?> cls, Class<?> endBefore, boolean addClassItself)",
        "public static List<Class<?>> findSuperClasses(Class<?> cls, Class<?> endBefore, boolean addClassItself)",
        "public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore)",
        "public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore, List<Class<?>> result)",
        "private static void _addSuperTypes(JavaType type, Class<?> endBefore, Collection<JavaType> result, boolean addClassItself)",
        "private static void _addRawSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself)",
        "public static String canBeABeanType(Class<?> type)",
        "public static String isLocalType(Class<?> type, boolean allowNonStatic)",
        "static member class\"; } } } } catch (SecurityException e)",
        "public static Class<?> getOuterClass(Class<?> type)",
        "public static boolean isProxyType(Class<?> type)",
        "public static boolean isConcrete(Class<?> type)",
        "public static boolean isConcrete(Member member)",
        "public static boolean isCollectionMapOrArray(Class<?> type)",
        "public static boolean isBogusClass(Class<?> cls)",
        "public static boolean isNonStaticInnerClass(Class<?> cls)",
        "public static boolean isObjectOrPrimitive(Class<?> cls)",
        "public static boolean hasClass(Object inst, Class<?> raw)",
        "public static void verifyMustOverride(Class<?> expType, Object instance, String method)",
        "public static boolean hasGetterSignature(Method m)",
        "public static Throwable throwIfError(Throwable t)",
        "public static Throwable throwIfRTE(Throwable t)",
        "public static Throwable throwIfIOE(Throwable t) throws IOException",
        "public static Throwable getRootCause(Throwable t)",
        "public static Throwable throwRootCauseIfIOE(Throwable t) throws IOException",
        "public static void throwAsIAE(Throwable t)",
        "public static void throwAsIAE(Throwable t, String msg)",
        "public static <T> T throwAsMappingException(DeserializationContext ctxt, IOException e0) throws JsonMappingException",
        "public static void unwrapAndThrowAsIAE(Throwable t)",
        "public static void unwrapAndThrowAsIAE(Throwable t, String msg)",
        "public static void closeOnFailAndThrowAsIOE(JsonGenerator g, Exception fail) throws IOException",
        "public static void closeOnFailAndThrowAsIOE(JsonGenerator g, Closeable toClose, Exception fail) throws IOException",
        "public static <T> T createInstance(Class<T> cls, boolean canFixAccess) throws IllegalArgumentException",
        "public static <T> Constructor<T> findConstructor(Class<T> cls, boolean forceAccess) throws IllegalArgumentException",
        "public?): not allowed to try modify access via Reflection: cannot instantiate type\"); } } return ctor; } catch (NoSuchMethodException e) { ; } catch (Exception e) { ClassUtil.unwrapAndThrowAsIAE(e, \"Failed to find default constructor of class \"+cls.getName()+\", problem: \"+e.getMessage()); } return null; } public static Class<?> classOf(Object inst)",
        "public static Class<?> rawClass(JavaType t)",
        "public static <T> T nonNull(T valueOrNull, T defaultValue)",
        "public static String nullOrToString(Object value)",
        "public static String nonNullString(String str)",
        "public static String quotedOr(Object str, String forNull)",
        "public static String getClassDescription(Object classOrInstance)",
        "public static String classNameOf(Object inst)",
        "public static String nameOf(Class<?> cls)",
        "public static String nameOf(Named named)",
        "public static String backticked(String text)",
        "public static String exceptionMessage(Throwable t)",
        "public static Object defaultValue(Class<?> cls)",
        "public static Class<?> wrapperType(Class<?> primitiveType)",
        "public static Class<?> primitiveType(Class<?> type)",
        "public static void checkAndFixAccess(Member member)",
        "public static void checkAndFixAccess(Member member, boolean force)",
        "public static Class<? extends Enum<?>> findEnumType(EnumSet<?> s)",
        "public static Class<? extends Enum<?>> findEnumType(EnumMap<?,?> m)",
        "public static Class<? extends Enum<?>> findEnumType(Enum<?> en)",
        "public static Class<? extends Enum<?>> findEnumType(Class<?> cls)",
        "public static <T extends Annotation> Enum<?> findFirstAnnotatedEnumValue(Class<Enum<?>> enumClass, Class<T> annotationClass)",
        "public static boolean isJacksonStdImpl(Object impl)",
        "public static boolean isJacksonStdImpl(Class<?> implClass)",
        "public static String getPackageName(Class<?> cls)",
        "public static boolean hasEnclosingMethod(Class<?> cls)",
        "public static Field[] getDeclaredFields(Class<?> cls)",
        "public static Method[] getDeclaredMethods(Class<?> cls)",
        "public static Annotation[] findClassAnnotations(Class<?> cls)",
        "public static Method[] getClassMethods(Class<?> cls)",
        "public static Ctor[] getConstructors(Class<?> cls)",
        "public static Class<?> getDeclaringClass(Class<?> cls)",
        "public static Type getGenericSuperclass(Class<?> cls)",
        "public static Type[] getGenericInterfaces(Class<?> cls)",
        "public static Class<?> getEnclosingClass(Class<?> cls)",
        "private static Class<?>[] _interfaces(Class<?> cls)",
        "public Class<? extends Enum<?>> enumTypeFor(EnumSet<?> set)",
        "public Class<? extends Enum<?>> enumTypeFor(EnumMap<?,?> set)",
        "private Object get(Object bean, Field field)",
        "private static Field locateField(Class<?> fromClass, String expectedName, Class<?> type)",
        "public Constructor<?> getConstructor()",
        "public int getParamCount()",
        "public Class<?> getDeclaringClass()",
        "public Annotation[] getDeclaredAnnotations()",
        "public Annotation[][] getParameterAnnotations()"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -7,6 +7,7 @@",
            " import java.util.*;\n",
            " \n",
            " import com.fasterxml.jackson.core.JsonGenerator;\n",
            "+import com.fasterxml.jackson.core.JsonProcessingException;\n",
            " import com.fasterxml.jackson.databind.DeserializationContext;\n",
            " import com.fasterxml.jackson.databind.JavaType;\n",
            " import com.fasterxml.jackson.databind.JsonMappingException;\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  public static String backticked(String text) {\n  if (text == null) {\n  return \"[null]\";\n  }\n  return new StringBuilder(text.length()+2).append('`').append(text).append('`').toString();\n  }",
          "fixed_method": "  public static String exceptionMessage(Throwable t) {\n  if (t instanceof JsonProcessingException) {\n  return ((JsonProcessingException) t).getOriginalMessage();\n  }\n  return t.getMessage();\n  }",
          "diff": [
            "@@ -749,6 +750,12 @@",
            "      *\n",
            "      * @since 2.9.7\n",
            "      */\n",
            "+    public static String exceptionMessage(Throwable t) {\n",
            "+        if (t instanceof JsonProcessingException) {\n",
            "+            return ((JsonProcessingException) t).getOriginalMessage();\n",
            "+        }\n",
            "+        return t.getMessage();\n",
            "+    }\n",
            "     \n",
            "     /*\n",
            "     /**********************************************************\n"
          ],
          "changed_lines": 6
        }
      ]
    }
  ]
}
