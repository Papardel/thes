{
  "bug_id": "87",
  "failed_tests": {
    "org.jsoup.parser.HtmlParserTest": [
      {
        "methodName": "preservedCaseLinksCantNest",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<<A> ONE <[/A> <A> Two] </A>> but was:<<A> ONE <[A> Two </A>] </A>>",
        "fail_line": "        assertEquals(\"<A> ONE </A> <A> Two </A>\", StringUtil.normaliseWhitespace(doc.body().html()));",
        "test_source": "",
        "stack": [
          "HtmlParserTest.preservedCaseLinksCantNest line 1133"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/nodes/Element.java",
      "buggy_full_code": "package org.jsoup.nodes;\n\nimport org.jsoup.helper.ChangeNotifyingArrayList;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.internal.StringUtil;\nimport org.jsoup.parser.ParseSettings;\nimport org.jsoup.parser.Tag;\nimport org.jsoup.select.Collector;\nimport org.jsoup.select.Elements;\nimport org.jsoup.select.Evaluator;\nimport org.jsoup.select.NodeTraversor;\nimport org.jsoup.select.NodeVisitor;\nimport org.jsoup.select.QueryParser;\nimport org.jsoup.select.Selector;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\n\nimport static org.jsoup.internal.Normalizer.normalize; public class Element extends Node { private static final List<Node> EMPTY_NODES = Collections.emptyList(); private static final Pattern classSplit = Pattern.compile(\"\\\\s+\"); private Tag tag; private WeakReference<List<Element>> shadowChildrenRef; List<Node> childNodes; private Attributes attributes; private String baseUri; public Element(String tag) {\n        this(Tag.valueOf(tag), \"\", new Attributes());\n    }\n\n    \n    public Element(Tag tag, String baseUri, Attributes attributes) {\n        Validate.notNull(tag);\n        Validate.notNull(baseUri);\n        childNodes = EMPTY_NODES;\n        this.baseUri = baseUri;\n        this.attributes = attributes;\n        this.tag = tag;\n    }\n    \n    \n    public Element(Tag tag, String baseUri) {\n        this(tag, baseUri, null);\n    }\n\n    protected List<Node> ensureChildNodes() {\n        if (childNodes == EMPTY_NODES) {\n            childNodes = new NodeList(this, 4);\n        }\n        return childNodes;\n    }\n\n    @Override\n    protected boolean hasAttributes() {\n        return attributes != null;\n    }\n\n    @Override\n    public Attributes attributes() {\n        if (!hasAttributes())\n            attributes = new Attributes();\n        return attributes;\n    }\n\n    @Override\n    public String baseUri() {\n        return baseUri;\n    }\n\n    @Override\n    protected void doSetBaseUri(String baseUri) {\n        this.baseUri = baseUri;\n    }\n\n    @Override\n    public int childNodeSize() {\n        return childNodes.size();\n    }\n\n    @Override\n    public String nodeName() {\n        return tag.getName();\n    }\n\n    \n    public String tagName() {\n        return tag.getName();\n    }\n\n    \n\n    \n    public Element tagName(String tagName) {\n        Validate.notEmpty(tagName, \"Tag name must not be empty.\");\n        tag = Tag.valueOf(tagName, NodeUtils.parser(this).settings()); \n        return this;\n    }\n\n    \n    public Tag tag() {\n        return tag;\n    }\n    \n    \n    public boolean isBlock() {\n        return tag.isBlock();\n    }\n\n    \n    public String id() {\n        return attributes().getIgnoreCase(\"id\");\n    }\n\n    \n    public Element attr(String attributeKey, String attributeValue) {\n        super.attr(attributeKey, attributeValue);\n        return this;\n    }\n    \n    \n    public Element attr(String attributeKey, boolean attributeValue) {\n        attributes().put(attributeKey, attributeValue);\n        return this;\n    }\n\n    \n    public Map<String, String> dataset() {\n        return attributes().dataset();\n    }\n\n    @Override\n    public final Element parent() {\n        return (Element) parentNode;\n    }\n\n    \n    public Elements parents() {\n        Elements parents = new Elements();\n        accumulateParents(this, parents);\n        return parents;\n    }\n\n    private static void accumulateParents(Element el, Elements parents) {\n        Element parent = el.parent();\n        if (parent != null && !parent.tagName().equals(\"#root\")) {\n            parents.add(parent);\n            accumulateParents(parent, parents);\n        }\n    }\n\n    \n    public Element child(int index) {\n        return childElementsList().get(index);\n    }\n\n    \n    public Elements children() {\n        return new Elements(childElementsList());\n    }\n\n    \n    private List<Element> childElementsList() {\n        List<Element> children;\n        if (shadowChildrenRef == null || (children = shadowChildrenRef.get()) == null) {\n            final int size = childNodes.size();\n            children = new ArrayList<>(size);\n            \n            for (int i = 0; i < size; i++) {\n                final Node node = childNodes.get(i);\n                if (node instanceof Element)\n                    children.add((Element) node);\n            }\n            shadowChildrenRef = new WeakReference<>(children);\n        }\n        return children;\n    }\n\n    \n    @Override\n    void nodelistChanged() {\n        super.nodelistChanged();\n        shadowChildrenRef = null;\n    }\n\n    \n    public List<TextNode> textNodes() {\n        List<TextNode> textNodes = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof TextNode)\n                textNodes.add((TextNode) node);\n        }\n        return Collections.unmodifiableList(textNodes);\n    }\n\n    \n    public List<DataNode> dataNodes() {\n        List<DataNode> dataNodes = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof DataNode)\n                dataNodes.add((DataNode) node);\n        }\n        return Collections.unmodifiableList(dataNodes);\n    }\n\n    \n    public Elements select(String cssQuery) {\n        return Selector.select(cssQuery, this);\n    }\n\n    \n    public Element selectFirst(String cssQuery) {\n        return Selector.selectFirst(cssQuery, this);\n    }\n\n    \n    public boolean is(String cssQuery) {\n        return is(QueryParser.parse(cssQuery));\n    }\n\n    \n    public boolean is(Evaluator evaluator) {\n        return evaluator.matches((Element)this.root(), this);\n    }\n    \n    \n    public Element appendChild(Node child) {\n        Validate.notNull(child);\n\n        \n        reparentChild(child);\n        ensureChildNodes();\n        childNodes.add(child);\n        child.setSiblingIndex(childNodes.size() - 1);\n        return this;\n    }\n\n    \n    public Element appendTo(Element parent) {\n        Validate.notNull(parent);\n        parent.appendChild(this);\n        return this;\n    }\n\n    \n    public Element prependChild(Node child) {\n        Validate.notNull(child);\n        \n        addChildren(0, child);\n        return this;\n    }\n\n\n    \n    public Element insertChildren(int index, Collection<? extends Node> children) {\n        Validate.notNull(children, \"Children collection to be inserted must not be null.\");\n        int currentSize = childNodeSize();\n        if (index < 0) index += currentSize +1; \n        Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n\n        ArrayList<Node> nodes = new ArrayList<>(children);\n        Node[] nodeArray = nodes.toArray(new Node[nodes.size()]);\n        addChildren(index, nodeArray);\n        return this;\n    }\n\n    \n    public Element insertChildren(int index, Node... children) {\n        Validate.notNull(children, \"Children collection to be inserted must not be null.\");\n        int currentSize = childNodeSize();\n        if (index < 0) index += currentSize +1; \n        Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n\n        addChildren(index, children);\n        return this;\n    }\n    \n    \n    public Element appendElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName, NodeUtils.parser(this).settings()), baseUri());\n        appendChild(child);\n        return child;\n    }\n    \n    \n    public Element prependElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName, NodeUtils.parser(this).settings()), baseUri());\n        prependChild(child);\n        return child;\n    }\n    \n    \n    public Element appendText(String text) {\n        Validate.notNull(text);\n        TextNode node = new TextNode(text);\n        appendChild(node);\n        return this;\n    }\n    \n    \n    public Element prependText(String text) {\n        Validate.notNull(text);\n        TextNode node = new TextNode(text);\n        prependChild(node);\n        return this;\n    }\n    \n    \n    public Element append(String html) {\n        Validate.notNull(html);\n        List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, this, baseUri());\n        addChildren(nodes.toArray(new Node[nodes.size()]));\n        return this;\n    }\n    \n    \n    public Element prepend(String html) {\n        Validate.notNull(html);\n        List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, this, baseUri());\n        addChildren(0, nodes.toArray(new Node[nodes.size()]));\n        return this;\n    }\n\n    \n    @Override\n    public Element before(String html) {\n        return (Element) super.before(html);\n    }\n\n    \n    @Override\n    public Element before(Node node) {\n        return (Element) super.before(node);\n    }\n\n    \n    @Override\n    public Element after(String html) {\n        return (Element) super.after(html);\n    }\n\n    \n    @Override\n    public Element after(Node node) {\n        return (Element) super.after(node);\n    }\n\n    \n    public Element empty() {\n        childNodes.clear();\n        return this;\n    }\n\n    \n    @Override\n    public Element wrap(String html) {\n        return (Element) super.wrap(html);\n    }\n\n    \n    public String cssSelector() {\n        if (id().length() > 0)\n            return \"#\" + id();\n\n        \n        String tagName = tagName().replace(':', '|');\n        StringBuilder selector = new StringBuilder(tagName);\n        String classes = StringUtil.join(classNames(), \".\");\n        if (classes.length() > 0)\n            selector.append('.').append(classes);\n\n        if (parent() == null || parent() instanceof Document) \n            return selector.toString();\n\n        selector.insert(0, \" > \");\n        if (parent().select(selector.toString()).size() > 1)\n            selector.append(String.format(\n                \":nth-child(%d)\", elementSiblingIndex() + 1));\n\n        return parent().cssSelector() + selector.toString();\n    }\n\n    \n    public Elements siblingElements() {\n        if (parentNode == null)\n            return new Elements(0);\n\n        List<Element> elements = parent().childElementsList();\n        Elements siblings = new Elements(elements.size() - 1);\n        for (Element el: elements)\n            if (el != this)\n                siblings.add(el);\n        return siblings;\n    }\n\n    \n    public Element nextElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().childElementsList();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }\n\n    \n    public Elements nextElementSiblings() {\n        return nextElementSiblings(true);\n    }\n\n    \n    public Element previousElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().childElementsList();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }\n\n    \n    public Elements previousElementSiblings() {\n        return nextElementSiblings(false);\n    }\n\n    private Elements nextElementSiblings(boolean next) {\n        Elements els = new Elements();\n        if (parentNode == null)\n            return  els;\n        els.add(this);\n        return next ?  els.nextAll() : els.prevAll();\n    }\n\n    \n    public Element firstElementSibling() {\n        \n        List<Element> siblings = parent().childElementsList();\n        return siblings.size() > 1 ? siblings.get(0) : null;\n    }\n    \n    \n    public int elementSiblingIndex() {\n       if (parent() == null) return 0;\n       return indexInList(this, parent().childElementsList());\n    }\n\n    \n    public Element lastElementSibling() {\n        List<Element> siblings = parent().childElementsList();\n        return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;\n    }\n\n    private static <E extends Element> int indexInList(Element search, List<E> elements) {\n        final int size = elements.size();\n        for (int i = 0; i < size; i++) {\n            if (elements.get(i) == search)\n                return i;\n        }\n        return 0;\n    }\n\n    \n\n    \n    public Elements getElementsByTag(String tagName) {\n        Validate.notEmpty(tagName);\n        tagName = normalize(tagName);\n\n        return Collector.collect(new Evaluator.Tag(tagName), this);\n    }\n\n    \n    public Element getElementById(String id) {\n        Validate.notEmpty(id);\n        \n        Elements elements = Collector.collect(new Evaluator.Id(id), this);\n        if (elements.size() > 0)\n            return elements.get(0);\n        else\n            return null;\n    }\n\n    \n    public Elements getElementsByClass(String className) {\n        Validate.notEmpty(className);\n\n        return Collector.collect(new Evaluator.Class(className), this);\n    }\n\n    \n    public Elements getElementsByAttribute(String key) {\n        Validate.notEmpty(key);\n        key = key.trim();\n\n        return Collector.collect(new Evaluator.Attribute(key), this);\n    }\n\n    \n    public Elements getElementsByAttributeStarting(String keyPrefix) {\n        Validate.notEmpty(keyPrefix);\n        keyPrefix = keyPrefix.trim();\n\n        return Collector.collect(new Evaluator.AttributeStarting(keyPrefix), this);\n    }\n\n    \n    public Elements getElementsByAttributeValue(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValue(key, value), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueNot(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) {\n        return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) {\n        return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueContaining(String key, String match) {\n        return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this);\n    }\n    \n    \n    public Elements getElementsByAttributeValueMatching(String key, Pattern pattern) {\n        return Collector.collect(new Evaluator.AttributeWithValueMatching(key, pattern), this);\n        \n    }\n    \n    \n    public Elements getElementsByAttributeValueMatching(String key, String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsByAttributeValueMatching(key, pattern);\n    }\n    \n    \n    public Elements getElementsByIndexLessThan(int index) {\n        return Collector.collect(new Evaluator.IndexLessThan(index), this);\n    }\n    \n    \n    public Elements getElementsByIndexGreaterThan(int index) {\n        return Collector.collect(new Evaluator.IndexGreaterThan(index), this);\n    }\n    \n    \n    public Elements getElementsByIndexEquals(int index) {\n        return Collector.collect(new Evaluator.IndexEquals(index), this);\n    }\n    \n    \n    public Elements getElementsContainingText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsText(searchText), this);\n    }\n    \n    \n    public Elements getElementsContainingOwnText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsOwnText(searchText), this);\n    }\n    \n    \n    public Elements getElementsMatchingText(Pattern pattern) {\n        return Collector.collect(new Evaluator.Matches(pattern), this);\n    }\n    \n    \n    public Elements getElementsMatchingText(String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsMatchingText(pattern);\n    }\n    \n    \n    public Elements getElementsMatchingOwnText(Pattern pattern) {\n        return Collector.collect(new Evaluator.MatchesOwn(pattern), this);\n    }\n    \n    \n    public Elements getElementsMatchingOwnText(String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsMatchingOwnText(pattern);\n    }\n    \n    \n    public Elements getAllElements() {\n        return Collector.collect(new Evaluator.AllElements(), this);\n    }\n\n    \n    public String text() {\n        final StringBuilder accum = StringUtil.borrowBuilder();\n        NodeTraversor.traverse(new NodeVisitor() {\n            public void head(Node node, int depth) {\n                if (node instanceof TextNode) {\n                    TextNode textNode = (TextNode) node;\n                    appendNormalisedText(accum, textNode);\n                } else if (node instanceof Element) {\n                    Element element = (Element) node;\n                    if (accum.length() > 0 &&\n                        (element.isBlock() || element.tag.getName().equals(\"br\")) &&\n                        !TextNode.lastCharIsWhitespace(accum))\n                        accum.append(' ');\n                }\n            }\n\n            public void tail(Node node, int depth) {\n                \n                if (node instanceof Element) {\n                    Element element = (Element) node;\n                    if (element.isBlock() && (node.nextSibling() instanceof TextNode) && !TextNode.lastCharIsWhitespace(accum))\n                        accum.append(' ');\n                }\n\n            }\n        }, this);\n\n        return StringUtil.releaseBuilder(accum).trim();\n    }\n\n    \n    public String wholeText() {\n        final StringBuilder accum = StringUtil.borrowBuilder();\n        NodeTraversor.traverse(new NodeVisitor() {\n            public void head(Node node, int depth) {\n                if (node instanceof TextNode) {\n                    TextNode textNode = (TextNode) node;\n                    accum.append(textNode.getWholeText());\n                }\n            }\n\n            public void tail(Node node, int depth) {\n            }\n        }, this);\n\n        return StringUtil.releaseBuilder(accum);\n    }\n\n    \n    public String ownText() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        ownText(sb);\n        return StringUtil.releaseBuilder(sb).trim();\n    }\n\n    private void ownText(StringBuilder accum) {\n        for (Node child : childNodes) {\n            if (child instanceof TextNode) {\n                TextNode textNode = (TextNode) child;\n                appendNormalisedText(accum, textNode);\n            } else if (child instanceof Element) {\n                appendWhitespaceIfBr((Element) child, accum);\n            }\n        }\n    }\n\n    private static void appendNormalisedText(StringBuilder accum, TextNode textNode) {\n        String text = textNode.getWholeText();\n\n        if (preserveWhitespace(textNode.parentNode) || textNode instanceof CDataNode)\n            accum.append(text);\n        else\n            StringUtil.appendNormalisedWhitespace(accum, text, TextNode.lastCharIsWhitespace(accum));\n    }\n\n    private static void appendWhitespaceIfBr(Element element, StringBuilder accum) {\n        if (element.tag.getName().equals(\"br\") && !TextNode.lastCharIsWhitespace(accum))\n            accum.append(\" \");\n    }\n\n    static boolean preserveWhitespace(Node node) {\n        \n        if (node instanceof Element) {\n            Element el = (Element) node;\n            int i = 0;\n            do {\n                if (el.tag.preserveWhitespace())\n                    return true;\n                el = el.parent();\n                i++;\n            } while (i < 6 && el != null);\n        }\n        return false;\n    }\n\n    \n    public Element text(String text) {\n        Validate.notNull(text);\n\n        empty();\n        TextNode textNode = new TextNode(text);\n        appendChild(textNode);\n\n        return this;\n    }\n\n    \n    public boolean hasText() {\n        for (Node child: childNodes) {\n            if (child instanceof TextNode) {\n                TextNode textNode = (TextNode) child;\n                if (!textNode.isBlank())\n                    return true;\n            } else if (child instanceof Element) {\n                Element el = (Element) child;\n                if (el.hasText())\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    \n    public String data() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n\n        for (Node childNode : childNodes) {\n            if (childNode instanceof DataNode) {\n                DataNode data = (DataNode) childNode;\n                sb.append(data.getWholeData());\n            } else if (childNode instanceof Comment) {\n                Comment comment = (Comment) childNode;\n                sb.append(comment.getData());\n            } else if (childNode instanceof Element) {\n                Element element = (Element) childNode;\n                String elementData = element.data();\n                sb.append(elementData);\n            } else if (childNode instanceof CDataNode) {\n                \n                \n                CDataNode cDataNode = (CDataNode) childNode;\n                sb.append(cDataNode.getWholeText());\n            }\n        }\n        return StringUtil.releaseBuilder(sb);\n    }   \n\n    \n    public String className() {\n        return attr(\"class\").trim();\n    }\n\n    \n    public Set<String> classNames() {\n    \tString[] names = classSplit.split(className());\n    \tSet<String> classNames = new LinkedHashSet<>(Arrays.asList(names));\n    \tclassNames.remove(\"\"); \n\n        return classNames;\n    }\n\n    \n    public Element classNames(Set<String> classNames) {\n        Validate.notNull(classNames);\n        if (classNames.isEmpty()) {\n            attributes().remove(\"class\");\n        } else {\n            attributes().put(\"class\", StringUtil.join(classNames, \" \"));\n        }\n        return this;\n    }\n\n    \n    \n    public boolean hasClass(String className) {\n        final String classAttr = attributes().getIgnoreCase(\"class\");\n        final int len = classAttr.length();\n        final int wantLen = className.length();\n\n        if (len == 0 || len < wantLen) {\n            return false;\n        }\n\n        \n        if (len == wantLen) {\n            return className.equalsIgnoreCase(classAttr);\n        }\n\n        \n        boolean inClass = false;\n        int start = 0;\n        for (int i = 0; i < len; i++) {\n            if (Character.isWhitespace(classAttr.charAt(i))) {\n                if (inClass) {\n                    \n                    if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                        return true;\n                    }\n                    inClass = false;\n                }\n            } else {\n                if (!inClass) {\n                    \n                    inClass = true;\n                    start = i;\n                }\n            }\n        }\n\n        \n        if (inClass && len - start == wantLen) {\n            return classAttr.regionMatches(true, start, className, 0, wantLen);\n        }\n\n        return false;\n    }\n\n    \n    public Element addClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        classes.add(className);\n        classNames(classes);\n\n        return this;\n    }\n\n    \n    public Element removeClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        classes.remove(className);\n        classNames(classes);\n\n        return this;\n    }\n\n    \n    public Element toggleClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        if (classes.contains(className))\n            classes.remove(className);\n        else\n            classes.add(className);\n        classNames(classes);\n\n        return this;\n    }\n    \n    \n    public String val() {\n        if (tagName().equals(\"textarea\"))\n            return text();\n        else\n            return attr(\"value\");\n    }\n    \n    \n    public Element val(String value) {\n        if (tagName().equals(\"textarea\"))\n            text(value);\n        else\n            attr(\"value\", value);\n        return this;\n    }\n\n    void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException {\n        if (out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline())) {\n            if (accum instanceof StringBuilder) {\n                if (((StringBuilder) accum).length() > 0)\n                    indent(accum, depth, out);\n            } else {\n                indent(accum, depth, out);\n            }\n        }\n        accum.append('<').append(tagName());\n        if (attributes != null) attributes.html(accum, out);\n\n        \n        if (childNodes.isEmpty() && tag.isSelfClosing()) {\n            if (out.syntax() == Document.OutputSettings.Syntax.html && tag.isEmpty())\n                accum.append('>');\n            else\n                accum.append(\" />\"); \n        }\n        else\n            accum.append('>');\n    }\n\n\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        if (!(childNodes.isEmpty() && tag.isSelfClosing())) {\n            if (out.prettyPrint() && (!childNodes.isEmpty() && (\n                    tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode))))\n            )))\n                indent(accum, depth, out);\n            accum.append(\"</\").append(tagName()).append('>');\n        }\n    }\n\n    \n    public String html() {\n        StringBuilder accum = StringUtil.borrowBuilder();\n        html(accum);\n        String html = StringUtil.releaseBuilder(accum);\n        return NodeUtils.outputSettings(this).prettyPrint() ? html.trim() : html;\n    }\n\n    @Override\n    public <T extends Appendable> T html(T appendable) {\n        final int size = childNodes.size();\n        for (int i = 0; i < size; i++)\n            childNodes.get(i).outerHtml(appendable);\n\n        return appendable;\n    }\n    \n    \n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n    @Override\n    public Element clone() {\n        return (Element) super.clone();\n    }\n\n    @Override\n    public Element shallowClone() {\n        \n        return new Element(tag, baseUri, attributes);\n    }\n\n    @Override\n    protected Element doClone(Node parent) {\n        Element clone = (Element) super.doClone(parent);\n        clone.attributes = attributes != null ? attributes.clone() : null;\n        clone.baseUri = baseUri;\n        clone.childNodes = new NodeList(clone, childNodes.size());\n        clone.childNodes.addAll(childNodes); \n\n        return clone;\n    }\n\n    private static final class NodeList extends ChangeNotifyingArrayList<Node> { private final Element owner; NodeList(Element owner, int initialCapacity) {\n            super(initialCapacity);\n            this.owner = owner;\n        }\n\n        public void onContentsChanged() {\n            owner.nodelistChanged();\n        }\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.nodes;\n\nimport org.jsoup.helper.ChangeNotifyingArrayList;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.internal.StringUtil;\nimport org.jsoup.parser.ParseSettings;\nimport org.jsoup.parser.Tag;\nimport org.jsoup.select.Collector;\nimport org.jsoup.select.Elements;\nimport org.jsoup.select.Evaluator;\nimport org.jsoup.select.NodeTraversor;\nimport org.jsoup.select.NodeVisitor;\nimport org.jsoup.select.QueryParser;\nimport org.jsoup.select.Selector;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\n\nimport static org.jsoup.internal.Normalizer.normalize; public class Element extends Node { private static final List<Node> EMPTY_NODES = Collections.emptyList(); private static final Pattern classSplit = Pattern.compile(\"\\\\s+\"); private Tag tag; private WeakReference<List<Element>> shadowChildrenRef; List<Node> childNodes; private Attributes attributes; private String baseUri; public Element(String tag) {\n        this(Tag.valueOf(tag), \"\", new Attributes());\n    }\n\n    \n    public Element(Tag tag, String baseUri, Attributes attributes) {\n        Validate.notNull(tag);\n        Validate.notNull(baseUri);\n        childNodes = EMPTY_NODES;\n        this.baseUri = baseUri;\n        this.attributes = attributes;\n        this.tag = tag;\n    }\n    \n    \n    public Element(Tag tag, String baseUri) {\n        this(tag, baseUri, null);\n    }\n\n    protected List<Node> ensureChildNodes() {\n        if (childNodes == EMPTY_NODES) {\n            childNodes = new NodeList(this, 4);\n        }\n        return childNodes;\n    }\n\n    @Override\n    protected boolean hasAttributes() {\n        return attributes != null;\n    }\n\n    @Override\n    public Attributes attributes() {\n        if (!hasAttributes())\n            attributes = new Attributes();\n        return attributes;\n    }\n\n    @Override\n    public String baseUri() {\n        return baseUri;\n    }\n\n    @Override\n    protected void doSetBaseUri(String baseUri) {\n        this.baseUri = baseUri;\n    }\n\n    @Override\n    public int childNodeSize() {\n        return childNodes.size();\n    }\n\n    @Override\n    public String nodeName() {\n        return tag.getName();\n    }\n\n    \n    public String tagName() {\n        return tag.getName();\n    }\n\n    \n    public String normalName() {\n        return tag.normalName();\n    }\n\n    \n    public Element tagName(String tagName) {\n        Validate.notEmpty(tagName, \"Tag name must not be empty.\");\n        tag = Tag.valueOf(tagName, NodeUtils.parser(this).settings()); \n        return this;\n    }\n\n    \n    public Tag tag() {\n        return tag;\n    }\n    \n    \n    public boolean isBlock() {\n        return tag.isBlock();\n    }\n\n    \n    public String id() {\n        return attributes().getIgnoreCase(\"id\");\n    }\n\n    \n    public Element attr(String attributeKey, String attributeValue) {\n        super.attr(attributeKey, attributeValue);\n        return this;\n    }\n    \n    \n    public Element attr(String attributeKey, boolean attributeValue) {\n        attributes().put(attributeKey, attributeValue);\n        return this;\n    }\n\n    \n    public Map<String, String> dataset() {\n        return attributes().dataset();\n    }\n\n    @Override\n    public final Element parent() {\n        return (Element) parentNode;\n    }\n\n    \n    public Elements parents() {\n        Elements parents = new Elements();\n        accumulateParents(this, parents);\n        return parents;\n    }\n\n    private static void accumulateParents(Element el, Elements parents) {\n        Element parent = el.parent();\n        if (parent != null && !parent.tagName().equals(\"#root\")) {\n            parents.add(parent);\n            accumulateParents(parent, parents);\n        }\n    }\n\n    \n    public Element child(int index) {\n        return childElementsList().get(index);\n    }\n\n    \n    public Elements children() {\n        return new Elements(childElementsList());\n    }\n\n    \n    private List<Element> childElementsList() {\n        List<Element> children;\n        if (shadowChildrenRef == null || (children = shadowChildrenRef.get()) == null) {\n            final int size = childNodes.size();\n            children = new ArrayList<>(size);\n            \n            for (int i = 0; i < size; i++) {\n                final Node node = childNodes.get(i);\n                if (node instanceof Element)\n                    children.add((Element) node);\n            }\n            shadowChildrenRef = new WeakReference<>(children);\n        }\n        return children;\n    }\n\n    \n    @Override\n    void nodelistChanged() {\n        super.nodelistChanged();\n        shadowChildrenRef = null;\n    }\n\n    \n    public List<TextNode> textNodes() {\n        List<TextNode> textNodes = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof TextNode)\n                textNodes.add((TextNode) node);\n        }\n        return Collections.unmodifiableList(textNodes);\n    }\n\n    \n    public List<DataNode> dataNodes() {\n        List<DataNode> dataNodes = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof DataNode)\n                dataNodes.add((DataNode) node);\n        }\n        return Collections.unmodifiableList(dataNodes);\n    }\n\n    \n    public Elements select(String cssQuery) {\n        return Selector.select(cssQuery, this);\n    }\n\n    \n    public Element selectFirst(String cssQuery) {\n        return Selector.selectFirst(cssQuery, this);\n    }\n\n    \n    public boolean is(String cssQuery) {\n        return is(QueryParser.parse(cssQuery));\n    }\n\n    \n    public boolean is(Evaluator evaluator) {\n        return evaluator.matches((Element)this.root(), this);\n    }\n    \n    \n    public Element appendChild(Node child) {\n        Validate.notNull(child);\n\n        \n        reparentChild(child);\n        ensureChildNodes();\n        childNodes.add(child);\n        child.setSiblingIndex(childNodes.size() - 1);\n        return this;\n    }\n\n    \n    public Element appendTo(Element parent) {\n        Validate.notNull(parent);\n        parent.appendChild(this);\n        return this;\n    }\n\n    \n    public Element prependChild(Node child) {\n        Validate.notNull(child);\n        \n        addChildren(0, child);\n        return this;\n    }\n\n\n    \n    public Element insertChildren(int index, Collection<? extends Node> children) {\n        Validate.notNull(children, \"Children collection to be inserted must not be null.\");\n        int currentSize = childNodeSize();\n        if (index < 0) index += currentSize +1; \n        Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n\n        ArrayList<Node> nodes = new ArrayList<>(children);\n        Node[] nodeArray = nodes.toArray(new Node[nodes.size()]);\n        addChildren(index, nodeArray);\n        return this;\n    }\n\n    \n    public Element insertChildren(int index, Node... children) {\n        Validate.notNull(children, \"Children collection to be inserted must not be null.\");\n        int currentSize = childNodeSize();\n        if (index < 0) index += currentSize +1; \n        Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n\n        addChildren(index, children);\n        return this;\n    }\n    \n    \n    public Element appendElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName, NodeUtils.parser(this).settings()), baseUri());\n        appendChild(child);\n        return child;\n    }\n    \n    \n    public Element prependElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName, NodeUtils.parser(this).settings()), baseUri());\n        prependChild(child);\n        return child;\n    }\n    \n    \n    public Element appendText(String text) {\n        Validate.notNull(text);\n        TextNode node = new TextNode(text);\n        appendChild(node);\n        return this;\n    }\n    \n    \n    public Element prependText(String text) {\n        Validate.notNull(text);\n        TextNode node = new TextNode(text);\n        prependChild(node);\n        return this;\n    }\n    \n    \n    public Element append(String html) {\n        Validate.notNull(html);\n        List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, this, baseUri());\n        addChildren(nodes.toArray(new Node[nodes.size()]));\n        return this;\n    }\n    \n    \n    public Element prepend(String html) {\n        Validate.notNull(html);\n        List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, this, baseUri());\n        addChildren(0, nodes.toArray(new Node[nodes.size()]));\n        return this;\n    }\n\n    \n    @Override\n    public Element before(String html) {\n        return (Element) super.before(html);\n    }\n\n    \n    @Override\n    public Element before(Node node) {\n        return (Element) super.before(node);\n    }\n\n    \n    @Override\n    public Element after(String html) {\n        return (Element) super.after(html);\n    }\n\n    \n    @Override\n    public Element after(Node node) {\n        return (Element) super.after(node);\n    }\n\n    \n    public Element empty() {\n        childNodes.clear();\n        return this;\n    }\n\n    \n    @Override\n    public Element wrap(String html) {\n        return (Element) super.wrap(html);\n    }\n\n    \n    public String cssSelector() {\n        if (id().length() > 0)\n            return \"#\" + id();\n\n        \n        String tagName = tagName().replace(':', '|');\n        StringBuilder selector = new StringBuilder(tagName);\n        String classes = StringUtil.join(classNames(), \".\");\n        if (classes.length() > 0)\n            selector.append('.').append(classes);\n\n        if (parent() == null || parent() instanceof Document) \n            return selector.toString();\n\n        selector.insert(0, \" > \");\n        if (parent().select(selector.toString()).size() > 1)\n            selector.append(String.format(\n                \":nth-child(%d)\", elementSiblingIndex() + 1));\n\n        return parent().cssSelector() + selector.toString();\n    }\n\n    \n    public Elements siblingElements() {\n        if (parentNode == null)\n            return new Elements(0);\n\n        List<Element> elements = parent().childElementsList();\n        Elements siblings = new Elements(elements.size() - 1);\n        for (Element el: elements)\n            if (el != this)\n                siblings.add(el);\n        return siblings;\n    }\n\n    \n    public Element nextElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().childElementsList();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }\n\n    \n    public Elements nextElementSiblings() {\n        return nextElementSiblings(true);\n    }\n\n    \n    public Element previousElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().childElementsList();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }\n\n    \n    public Elements previousElementSiblings() {\n        return nextElementSiblings(false);\n    }\n\n    private Elements nextElementSiblings(boolean next) {\n        Elements els = new Elements();\n        if (parentNode == null)\n            return  els;\n        els.add(this);\n        return next ?  els.nextAll() : els.prevAll();\n    }\n\n    \n    public Element firstElementSibling() {\n        \n        List<Element> siblings = parent().childElementsList();\n        return siblings.size() > 1 ? siblings.get(0) : null;\n    }\n    \n    \n    public int elementSiblingIndex() {\n       if (parent() == null) return 0;\n       return indexInList(this, parent().childElementsList());\n    }\n\n    \n    public Element lastElementSibling() {\n        List<Element> siblings = parent().childElementsList();\n        return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;\n    }\n\n    private static <E extends Element> int indexInList(Element search, List<E> elements) {\n        final int size = elements.size();\n        for (int i = 0; i < size; i++) {\n            if (elements.get(i) == search)\n                return i;\n        }\n        return 0;\n    }\n\n    \n\n    \n    public Elements getElementsByTag(String tagName) {\n        Validate.notEmpty(tagName);\n        tagName = normalize(tagName);\n\n        return Collector.collect(new Evaluator.Tag(tagName), this);\n    }\n\n    \n    public Element getElementById(String id) {\n        Validate.notEmpty(id);\n        \n        Elements elements = Collector.collect(new Evaluator.Id(id), this);\n        if (elements.size() > 0)\n            return elements.get(0);\n        else\n            return null;\n    }\n\n    \n    public Elements getElementsByClass(String className) {\n        Validate.notEmpty(className);\n\n        return Collector.collect(new Evaluator.Class(className), this);\n    }\n\n    \n    public Elements getElementsByAttribute(String key) {\n        Validate.notEmpty(key);\n        key = key.trim();\n\n        return Collector.collect(new Evaluator.Attribute(key), this);\n    }\n\n    \n    public Elements getElementsByAttributeStarting(String keyPrefix) {\n        Validate.notEmpty(keyPrefix);\n        keyPrefix = keyPrefix.trim();\n\n        return Collector.collect(new Evaluator.AttributeStarting(keyPrefix), this);\n    }\n\n    \n    public Elements getElementsByAttributeValue(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValue(key, value), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueNot(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) {\n        return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) {\n        return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueContaining(String key, String match) {\n        return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this);\n    }\n    \n    \n    public Elements getElementsByAttributeValueMatching(String key, Pattern pattern) {\n        return Collector.collect(new Evaluator.AttributeWithValueMatching(key, pattern), this);\n        \n    }\n    \n    \n    public Elements getElementsByAttributeValueMatching(String key, String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsByAttributeValueMatching(key, pattern);\n    }\n    \n    \n    public Elements getElementsByIndexLessThan(int index) {\n        return Collector.collect(new Evaluator.IndexLessThan(index), this);\n    }\n    \n    \n    public Elements getElementsByIndexGreaterThan(int index) {\n        return Collector.collect(new Evaluator.IndexGreaterThan(index), this);\n    }\n    \n    \n    public Elements getElementsByIndexEquals(int index) {\n        return Collector.collect(new Evaluator.IndexEquals(index), this);\n    }\n    \n    \n    public Elements getElementsContainingText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsText(searchText), this);\n    }\n    \n    \n    public Elements getElementsContainingOwnText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsOwnText(searchText), this);\n    }\n    \n    \n    public Elements getElementsMatchingText(Pattern pattern) {\n        return Collector.collect(new Evaluator.Matches(pattern), this);\n    }\n    \n    \n    public Elements getElementsMatchingText(String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsMatchingText(pattern);\n    }\n    \n    \n    public Elements getElementsMatchingOwnText(Pattern pattern) {\n        return Collector.collect(new Evaluator.MatchesOwn(pattern), this);\n    }\n    \n    \n    public Elements getElementsMatchingOwnText(String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsMatchingOwnText(pattern);\n    }\n    \n    \n    public Elements getAllElements() {\n        return Collector.collect(new Evaluator.AllElements(), this);\n    }\n\n    \n    public String text() {\n        final StringBuilder accum = StringUtil.borrowBuilder();\n        NodeTraversor.traverse(new NodeVisitor() {\n            public void head(Node node, int depth) {\n                if (node instanceof TextNode) {\n                    TextNode textNode = (TextNode) node;\n                    appendNormalisedText(accum, textNode);\n                } else if (node instanceof Element) {\n                    Element element = (Element) node;\n                    if (accum.length() > 0 &&\n                        (element.isBlock() || element.tag.getName().equals(\"br\")) &&\n                        !TextNode.lastCharIsWhitespace(accum))\n                        accum.append(' ');\n                }\n            }\n\n            public void tail(Node node, int depth) {\n                \n                if (node instanceof Element) {\n                    Element element = (Element) node;\n                    if (element.isBlock() && (node.nextSibling() instanceof TextNode) && !TextNode.lastCharIsWhitespace(accum))\n                        accum.append(' ');\n                }\n\n            }\n        }, this);\n\n        return StringUtil.releaseBuilder(accum).trim();\n    }\n\n    \n    public String wholeText() {\n        final StringBuilder accum = StringUtil.borrowBuilder();\n        NodeTraversor.traverse(new NodeVisitor() {\n            public void head(Node node, int depth) {\n                if (node instanceof TextNode) {\n                    TextNode textNode = (TextNode) node;\n                    accum.append(textNode.getWholeText());\n                }\n            }\n\n            public void tail(Node node, int depth) {\n            }\n        }, this);\n\n        return StringUtil.releaseBuilder(accum);\n    }\n\n    \n    public String ownText() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        ownText(sb);\n        return StringUtil.releaseBuilder(sb).trim();\n    }\n\n    private void ownText(StringBuilder accum) {\n        for (Node child : childNodes) {\n            if (child instanceof TextNode) {\n                TextNode textNode = (TextNode) child;\n                appendNormalisedText(accum, textNode);\n            } else if (child instanceof Element) {\n                appendWhitespaceIfBr((Element) child, accum);\n            }\n        }\n    }\n\n    private static void appendNormalisedText(StringBuilder accum, TextNode textNode) {\n        String text = textNode.getWholeText();\n\n        if (preserveWhitespace(textNode.parentNode) || textNode instanceof CDataNode)\n            accum.append(text);\n        else\n            StringUtil.appendNormalisedWhitespace(accum, text, TextNode.lastCharIsWhitespace(accum));\n    }\n\n    private static void appendWhitespaceIfBr(Element element, StringBuilder accum) {\n        if (element.tag.getName().equals(\"br\") && !TextNode.lastCharIsWhitespace(accum))\n            accum.append(\" \");\n    }\n\n    static boolean preserveWhitespace(Node node) {\n        \n        if (node instanceof Element) {\n            Element el = (Element) node;\n            int i = 0;\n            do {\n                if (el.tag.preserveWhitespace())\n                    return true;\n                el = el.parent();\n                i++;\n            } while (i < 6 && el != null);\n        }\n        return false;\n    }\n\n    \n    public Element text(String text) {\n        Validate.notNull(text);\n\n        empty();\n        TextNode textNode = new TextNode(text);\n        appendChild(textNode);\n\n        return this;\n    }\n\n    \n    public boolean hasText() {\n        for (Node child: childNodes) {\n            if (child instanceof TextNode) {\n                TextNode textNode = (TextNode) child;\n                if (!textNode.isBlank())\n                    return true;\n            } else if (child instanceof Element) {\n                Element el = (Element) child;\n                if (el.hasText())\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    \n    public String data() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n\n        for (Node childNode : childNodes) {\n            if (childNode instanceof DataNode) {\n                DataNode data = (DataNode) childNode;\n                sb.append(data.getWholeData());\n            } else if (childNode instanceof Comment) {\n                Comment comment = (Comment) childNode;\n                sb.append(comment.getData());\n            } else if (childNode instanceof Element) {\n                Element element = (Element) childNode;\n                String elementData = element.data();\n                sb.append(elementData);\n            } else if (childNode instanceof CDataNode) {\n                \n                \n                CDataNode cDataNode = (CDataNode) childNode;\n                sb.append(cDataNode.getWholeText());\n            }\n        }\n        return StringUtil.releaseBuilder(sb);\n    }   \n\n    \n    public String className() {\n        return attr(\"class\").trim();\n    }\n\n    \n    public Set<String> classNames() {\n    \tString[] names = classSplit.split(className());\n    \tSet<String> classNames = new LinkedHashSet<>(Arrays.asList(names));\n    \tclassNames.remove(\"\"); \n\n        return classNames;\n    }\n\n    \n    public Element classNames(Set<String> classNames) {\n        Validate.notNull(classNames);\n        if (classNames.isEmpty()) {\n            attributes().remove(\"class\");\n        } else {\n            attributes().put(\"class\", StringUtil.join(classNames, \" \"));\n        }\n        return this;\n    }\n\n    \n    \n    public boolean hasClass(String className) {\n        final String classAttr = attributes().getIgnoreCase(\"class\");\n        final int len = classAttr.length();\n        final int wantLen = className.length();\n\n        if (len == 0 || len < wantLen) {\n            return false;\n        }\n\n        \n        if (len == wantLen) {\n            return className.equalsIgnoreCase(classAttr);\n        }\n\n        \n        boolean inClass = false;\n        int start = 0;\n        for (int i = 0; i < len; i++) {\n            if (Character.isWhitespace(classAttr.charAt(i))) {\n                if (inClass) {\n                    \n                    if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                        return true;\n                    }\n                    inClass = false;\n                }\n            } else {\n                if (!inClass) {\n                    \n                    inClass = true;\n                    start = i;\n                }\n            }\n        }\n\n        \n        if (inClass && len - start == wantLen) {\n            return classAttr.regionMatches(true, start, className, 0, wantLen);\n        }\n\n        return false;\n    }\n\n    \n    public Element addClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        classes.add(className);\n        classNames(classes);\n\n        return this;\n    }\n\n    \n    public Element removeClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        classes.remove(className);\n        classNames(classes);\n\n        return this;\n    }\n\n    \n    public Element toggleClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        if (classes.contains(className))\n            classes.remove(className);\n        else\n            classes.add(className);\n        classNames(classes);\n\n        return this;\n    }\n    \n    \n    public String val() {\n        if (tagName().equals(\"textarea\"))\n            return text();\n        else\n            return attr(\"value\");\n    }\n    \n    \n    public Element val(String value) {\n        if (tagName().equals(\"textarea\"))\n            text(value);\n        else\n            attr(\"value\", value);\n        return this;\n    }\n\n    void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException {\n        if (out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline())) {\n            if (accum instanceof StringBuilder) {\n                if (((StringBuilder) accum).length() > 0)\n                    indent(accum, depth, out);\n            } else {\n                indent(accum, depth, out);\n            }\n        }\n        accum.append('<').append(tagName());\n        if (attributes != null) attributes.html(accum, out);\n\n        \n        if (childNodes.isEmpty() && tag.isSelfClosing()) {\n            if (out.syntax() == Document.OutputSettings.Syntax.html && tag.isEmpty())\n                accum.append('>');\n            else\n                accum.append(\" />\"); \n        }\n        else\n            accum.append('>');\n    }\n\n\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        if (!(childNodes.isEmpty() && tag.isSelfClosing())) {\n            if (out.prettyPrint() && (!childNodes.isEmpty() && (\n                    tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode))))\n            )))\n                indent(accum, depth, out);\n            accum.append(\"</\").append(tagName()).append('>');\n        }\n    }\n\n    \n    public String html() {\n        StringBuilder accum = StringUtil.borrowBuilder();\n        html(accum);\n        String html = StringUtil.releaseBuilder(accum);\n        return NodeUtils.outputSettings(this).prettyPrint() ? html.trim() : html;\n    }\n\n    @Override\n    public <T extends Appendable> T html(T appendable) {\n        final int size = childNodes.size();\n        for (int i = 0; i < size; i++)\n            childNodes.get(i).outerHtml(appendable);\n\n        return appendable;\n    }\n    \n    \n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n    @Override\n    public Element clone() {\n        return (Element) super.clone();\n    }\n\n    @Override\n    public Element shallowClone() {\n        \n        return new Element(tag, baseUri, attributes);\n    }\n\n    @Override\n    protected Element doClone(Node parent) {\n        Element clone = (Element) super.doClone(parent);\n        clone.attributes = attributes != null ? attributes.clone() : null;\n        clone.baseUri = baseUri;\n        clone.childNodes = new NodeList(clone, childNodes.size());\n        clone.childNodes.addAll(childNodes); \n\n        return clone;\n    }\n\n    private static final class NodeList extends ChangeNotifyingArrayList<Node> { private final Element owner; NodeList(Element owner, int initialCapacity) {\n            super(initialCapacity);\n            this.owner = owner;\n        }\n\n        public void onContentsChanged() {\n            owner.nodelistChanged();\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public Element(Tag tag, String baseUri, Attributes attributes)",
        "public Element(Tag tag, String baseUri)",
        "protected List<Node> ensureChildNodes()",
        "protected boolean hasAttributes()",
        "public Attributes attributes()",
        "public String baseUri()",
        "protected void doSetBaseUri(String baseUri)",
        "public int childNodeSize()",
        "public String nodeName()",
        "public String tagName()",
        "public Element tagName(String tagName)",
        "public Tag tag()",
        "public boolean isBlock()",
        "public String id()",
        "public Element attr(String attributeKey, String attributeValue)",
        "public Element attr(String attributeKey, boolean attributeValue)",
        "public Map<String, String> dataset()",
        "public final Element parent()",
        "public Elements parents()",
        "private static void accumulateParents(Element el, Elements parents)",
        "public Element child(int index)",
        "public Elements children()",
        "private List<Element> childElementsList()",
        "public List<TextNode> textNodes()",
        "public List<DataNode> dataNodes()",
        "public Elements select(String cssQuery)",
        "public Element selectFirst(String cssQuery)",
        "public boolean is(String cssQuery)",
        "public boolean is(Evaluator evaluator)",
        "public Element appendChild(Node child)",
        "public Element appendTo(Element parent)",
        "public Element prependChild(Node child)",
        "public Element insertChildren(int index, Collection<? extends Node> children)",
        "public Element insertChildren(int index, Node... children)",
        "public Element appendElement(String tagName)",
        "public Element prependElement(String tagName)",
        "public Element appendText(String text)",
        "public Element prependText(String text)",
        "public Element append(String html)",
        "public Element prepend(String html)",
        "public Element before(String html)",
        "public Element before(Node node)",
        "public Element after(String html)",
        "public Element after(Node node)",
        "public Element empty()",
        "public Element wrap(String html)",
        "public String cssSelector()",
        "public Elements siblingElements()",
        "public Element nextElementSibling()",
        "public Elements nextElementSiblings()",
        "public Element previousElementSibling()",
        "public Elements previousElementSiblings()",
        "private Elements nextElementSiblings(boolean next)",
        "public Element firstElementSibling()",
        "public int elementSiblingIndex()",
        "public Element lastElementSibling()",
        "private static <E extends Element> int indexInList(Element search, List<E> elements)",
        "public Elements getElementsByTag(String tagName)",
        "public Element getElementById(String id)",
        "public Elements getElementsByClass(String className)",
        "public Elements getElementsByAttribute(String key)",
        "public Elements getElementsByAttributeStarting(String keyPrefix)",
        "public Elements getElementsByAttributeValue(String key, String value)",
        "public Elements getElementsByAttributeValueNot(String key, String value)",
        "public Elements getElementsByAttributeValueStarting(String key, String valuePrefix)",
        "public Elements getElementsByAttributeValueEnding(String key, String valueSuffix)",
        "public Elements getElementsByAttributeValueContaining(String key, String match)",
        "public Elements getElementsByAttributeValueMatching(String key, Pattern pattern)",
        "public Elements getElementsByAttributeValueMatching(String key, String regex)",
        "public Elements getElementsByIndexLessThan(int index)",
        "public Elements getElementsByIndexGreaterThan(int index)",
        "public Elements getElementsByIndexEquals(int index)",
        "public Elements getElementsContainingText(String searchText)",
        "public Elements getElementsContainingOwnText(String searchText)",
        "public Elements getElementsMatchingText(Pattern pattern)",
        "public Elements getElementsMatchingText(String regex)",
        "public Elements getElementsMatchingOwnText(Pattern pattern)",
        "public Elements getElementsMatchingOwnText(String regex)",
        "public Elements getAllElements()",
        "public String text()",
        "public void head(Node node, int depth)",
        "public void tail(Node node, int depth)",
        "public String wholeText()",
        "public void head(Node node, int depth)",
        "public void tail(Node node, int depth)",
        "public String ownText()",
        "private void ownText(StringBuilder accum)",
        "private static void appendNormalisedText(StringBuilder accum, TextNode textNode)",
        "private static void appendWhitespaceIfBr(Element element, StringBuilder accum)",
        "static boolean preserveWhitespace(Node node)",
        "public Element text(String text)",
        "public boolean hasText()",
        "public String data()",
        "public String className()",
        "public Set<String> classNames()",
        "public Element classNames(Set<String> classNames)",
        "public boolean hasClass(String className)",
        "public Element addClass(String className)",
        "public Element removeClass(String className)",
        "public Element toggleClass(String className)",
        "public String val()",
        "public Element val(String value)",
        "public String html()",
        "public <T extends Appendable> T html(T appendable)",
        "public Element html(String html)",
        "public Element clone()",
        "public Element shallowClone()",
        "protected Element doClone(Node parent)",
        "private static final class NodeList extends ChangeNotifyingArrayList<Node> { private final Element owner; NodeList(Element owner, int initialCapacity)",
        "public void onContentsChanged()"
      ],
      "fixed_signatures": [
        "public Element(Tag tag, String baseUri, Attributes attributes)",
        "public Element(Tag tag, String baseUri)",
        "protected List<Node> ensureChildNodes()",
        "protected boolean hasAttributes()",
        "public Attributes attributes()",
        "public String baseUri()",
        "protected void doSetBaseUri(String baseUri)",
        "public int childNodeSize()",
        "public String nodeName()",
        "public String tagName()",
        "public String normalName()",
        "public Element tagName(String tagName)",
        "public Tag tag()",
        "public boolean isBlock()",
        "public String id()",
        "public Element attr(String attributeKey, String attributeValue)",
        "public Element attr(String attributeKey, boolean attributeValue)",
        "public Map<String, String> dataset()",
        "public final Element parent()",
        "public Elements parents()",
        "private static void accumulateParents(Element el, Elements parents)",
        "public Element child(int index)",
        "public Elements children()",
        "private List<Element> childElementsList()",
        "public List<TextNode> textNodes()",
        "public List<DataNode> dataNodes()",
        "public Elements select(String cssQuery)",
        "public Element selectFirst(String cssQuery)",
        "public boolean is(String cssQuery)",
        "public boolean is(Evaluator evaluator)",
        "public Element appendChild(Node child)",
        "public Element appendTo(Element parent)",
        "public Element prependChild(Node child)",
        "public Element insertChildren(int index, Collection<? extends Node> children)",
        "public Element insertChildren(int index, Node... children)",
        "public Element appendElement(String tagName)",
        "public Element prependElement(String tagName)",
        "public Element appendText(String text)",
        "public Element prependText(String text)",
        "public Element append(String html)",
        "public Element prepend(String html)",
        "public Element before(String html)",
        "public Element before(Node node)",
        "public Element after(String html)",
        "public Element after(Node node)",
        "public Element empty()",
        "public Element wrap(String html)",
        "public String cssSelector()",
        "public Elements siblingElements()",
        "public Element nextElementSibling()",
        "public Elements nextElementSiblings()",
        "public Element previousElementSibling()",
        "public Elements previousElementSiblings()",
        "private Elements nextElementSiblings(boolean next)",
        "public Element firstElementSibling()",
        "public int elementSiblingIndex()",
        "public Element lastElementSibling()",
        "private static <E extends Element> int indexInList(Element search, List<E> elements)",
        "public Elements getElementsByTag(String tagName)",
        "public Element getElementById(String id)",
        "public Elements getElementsByClass(String className)",
        "public Elements getElementsByAttribute(String key)",
        "public Elements getElementsByAttributeStarting(String keyPrefix)",
        "public Elements getElementsByAttributeValue(String key, String value)",
        "public Elements getElementsByAttributeValueNot(String key, String value)",
        "public Elements getElementsByAttributeValueStarting(String key, String valuePrefix)",
        "public Elements getElementsByAttributeValueEnding(String key, String valueSuffix)",
        "public Elements getElementsByAttributeValueContaining(String key, String match)",
        "public Elements getElementsByAttributeValueMatching(String key, Pattern pattern)",
        "public Elements getElementsByAttributeValueMatching(String key, String regex)",
        "public Elements getElementsByIndexLessThan(int index)",
        "public Elements getElementsByIndexGreaterThan(int index)",
        "public Elements getElementsByIndexEquals(int index)",
        "public Elements getElementsContainingText(String searchText)",
        "public Elements getElementsContainingOwnText(String searchText)",
        "public Elements getElementsMatchingText(Pattern pattern)",
        "public Elements getElementsMatchingText(String regex)",
        "public Elements getElementsMatchingOwnText(Pattern pattern)",
        "public Elements getElementsMatchingOwnText(String regex)",
        "public Elements getAllElements()",
        "public String text()",
        "public void head(Node node, int depth)",
        "public void tail(Node node, int depth)",
        "public String wholeText()",
        "public void head(Node node, int depth)",
        "public void tail(Node node, int depth)",
        "public String ownText()",
        "private void ownText(StringBuilder accum)",
        "private static void appendNormalisedText(StringBuilder accum, TextNode textNode)",
        "private static void appendWhitespaceIfBr(Element element, StringBuilder accum)",
        "static boolean preserveWhitespace(Node node)",
        "public Element text(String text)",
        "public boolean hasText()",
        "public String data()",
        "public String className()",
        "public Set<String> classNames()",
        "public Element classNames(Set<String> classNames)",
        "public boolean hasClass(String className)",
        "public Element addClass(String className)",
        "public Element removeClass(String className)",
        "public Element toggleClass(String className)",
        "public String val()",
        "public Element val(String value)",
        "public String html()",
        "public <T extends Appendable> T html(T appendable)",
        "public Element html(String html)",
        "public Element clone()",
        "public Element shallowClone()",
        "protected Element doClone(Node parent)",
        "private static final class NodeList extends ChangeNotifyingArrayList<Node> { private final Element owner; NodeList(Element owner, int initialCapacity)",
        "public void onContentsChanged()"
      ],
      "methods": [
        {
          "buggy_method": "  public String tagName() {\n  return tag.getName();\n  }",
          "fixed_method": "  public String normalName() {\n  return tag.normalName();\n  }",
          "diff": [
            "@@ -137,6 +137,9 @@",
            "      * of the tag case preserving setting of the parser.\n",
            "      * @return\n",
            "      */\n",
            "+    public String normalName() {\n",
            "+        return tag.normalName();\n",
            "+    }\n",
            " \n",
            "     /**\n",
            "      * Change the tag of this element. For example, convert a {@code <span>} to a {@code <div>} with\n"
          ],
          "changed_lines": 3
        }
      ]
    },
    {
      "name": "org/jsoup/parser/HtmlTreeBuilder.java",
      "buggy_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.internal.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.CDataNode;\nimport org.jsoup.nodes.Comment;\nimport org.jsoup.nodes.DataNode;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.FormElement;\nimport org.jsoup.nodes.Node;\nimport org.jsoup.nodes.TextNode;\nimport org.jsoup.select.Elements;\n\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.jsoup.internal.StringUtil.inSorted; public class HtmlTreeBuilder extends TreeBuilder { static final String[] TagsSearchInScope = new String[]{\"applet\", \"caption\", \"html\", \"marquee\", \"object\", \"table\", \"td\", \"th\"}; static final String[] TagSearchList = new String[]{\"ol\", \"ul\"}; static final String[] TagSearchButton = new String[]{\"button\"}; static final String[] TagSearchTableScope = new String[]{\"html\", \"table\"}; static final String[] TagSearchSelectScope = new String[]{\"optgroup\", \"option\"}; static final String[] TagSearchEndTags = new String[]{\"dd\", \"dt\", \"li\", \"optgroup\", \"option\", \"p\", \"rp\", \"rt\"}; static final String[] TagSearchSpecial = new String[]{\"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\", \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"command\", \"dd\", \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\", \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"marquee\", \"menu\", \"meta\", \"nav\", \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\", \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\"}; public static final int MaxScopeSearchDepth = 100; private HtmlTreeBuilderState state; private HtmlTreeBuilderState originalState; private boolean baseUriSetFromDoc; private Element headElement; private FormElement formElement; private Element contextElement; private ArrayList<Element> formattingElements; private List<String> pendingTableCharacters; private Token.EndTag emptyEnd; private boolean framesetOk; private boolean fosterInserts; private boolean fragmentParsing; ParseSettings defaultSettings() {\n        return ParseSettings.htmlDefault;\n    }\n\n    @Override\n    protected void initialiseParse(Reader input, String baseUri, Parser parser) {\n        super.initialiseParse(input, baseUri, parser);\n\n        \n        state = HtmlTreeBuilderState.Initial;\n        originalState = null;\n        baseUriSetFromDoc = false;\n        headElement = null;\n        formElement = null;\n        contextElement = null;\n        formattingElements = new ArrayList<>();\n        pendingTableCharacters = new ArrayList<>();\n        emptyEnd = new Token.EndTag();\n        framesetOk = true;\n        fosterInserts = false;\n        fragmentParsing = false;\n    }\n\n    List<Node> parseFragment(String inputFragment, Element context, String baseUri, Parser parser) {\n        \n        state = HtmlTreeBuilderState.Initial;\n        initialiseParse(new StringReader(inputFragment), baseUri, parser);\n        contextElement = context;\n        fragmentParsing = true;\n        Element root = null;\n\n        if (context != null) {\n            if (context.ownerDocument() != null) \n                doc.quirksMode(context.ownerDocument().quirksMode());\n\n            \n            String contextTag = context.tagName();\n            if (StringUtil.in(contextTag, \"title\", \"textarea\"))\n                tokeniser.transition(TokeniserState.Rcdata);\n            else if (StringUtil.in(contextTag, \"iframe\", \"noembed\", \"noframes\", \"style\", \"xmp\"))\n                tokeniser.transition(TokeniserState.Rawtext);\n            else if (contextTag.equals(\"script\"))\n                tokeniser.transition(TokeniserState.ScriptData);\n            else if (contextTag.equals((\"noscript\")))\n                tokeniser.transition(TokeniserState.Data); \n            else if (contextTag.equals(\"plaintext\"))\n                tokeniser.transition(TokeniserState.Data);\n            else\n                tokeniser.transition(TokeniserState.Data); \n\n            root = new Element(Tag.valueOf(\"html\", settings), baseUri);\n            doc.appendChild(root);\n            stack.add(root);\n            resetInsertionMode();\n\n            \n            \n            Elements contextChain = context.parents();\n            contextChain.add(0, context);\n            for (Element parent: contextChain) {\n                if (parent instanceof FormElement) {\n                    formElement = (FormElement) parent;\n                    break;\n                }\n            }\n        }\n\n        runParser();\n        if (context != null)\n            return root.childNodes();\n        else\n            return doc.childNodes();\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        currentToken = token;\n        return this.state.process(token, this);\n    }\n\n    boolean process(Token token, HtmlTreeBuilderState state) {\n        currentToken = token;\n        return state.process(token, this);\n    }\n\n    void transition(HtmlTreeBuilderState state) {\n        this.state = state;\n    }\n\n    HtmlTreeBuilderState state() {\n        return state;\n    }\n\n    void markInsertionMode() {\n        originalState = state;\n    }\n\n    HtmlTreeBuilderState originalState() {\n        return originalState;\n    }\n\n    void framesetOk(boolean framesetOk) {\n        this.framesetOk = framesetOk;\n    }\n\n    boolean framesetOk() {\n        return framesetOk;\n    }\n\n    Document getDocument() {\n        return doc;\n    }\n\n    String getBaseUri() {\n        return baseUri;\n    }\n\n    void maybeSetBaseUri(Element base) {\n        if (baseUriSetFromDoc) \n            return;\n\n        String href = base.absUrl(\"href\");\n        if (href.length() != 0) { \n            baseUri = href;\n            baseUriSetFromDoc = true;\n            doc.setBaseUri(href); \n        }\n    }\n\n    boolean isFragmentParsing() {\n        return fragmentParsing;\n    }\n\n    void error(HtmlTreeBuilderState state) {\n        if (parser.getErrors().canAddError())\n            parser.getErrors().add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }\n\n    Element insert(Token.StartTag startTag) {\n        \n        \n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.transition(TokeniserState.Data); \n            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  \n            return el;\n        }\n        \n        Element el = new Element(Tag.valueOf(startTag.name(), settings), baseUri, settings.normalizeAttributes(startTag.attributes));\n        insert(el);\n        return el;\n    }\n\n    Element insertStartTag(String startTagName) {\n        Element el = new Element(Tag.valueOf(startTagName, settings), baseUri);\n        insert(el);\n        return el;\n    }\n\n    void insert(Element el) {\n        insertNode(el);\n        stack.add(el);\n    }\n\n    Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (tag.isKnownTag()) {\n                if (!tag.isEmpty())\n                    tokeniser.error(\"Tag cannot be self closing; not a void tag\");\n            }\n            else \n                tag.setSelfClosing();\n        }\n        return el;\n    }\n\n    FormElement insertForm(Token.StartTag startTag, boolean onStack) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        FormElement el = new FormElement(tag, baseUri, startTag.attributes);\n        setFormElement(el);\n        insertNode(el);\n        if (onStack)\n            stack.add(el);\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData());\n        insertNode(comment);\n    }\n\n    void insert(Token.Character characterToken) {\n        final Node node;\n        final Element el = currentElement();\n        final String tagName = el.tagName();\n        final String data = characterToken.getData();\n\n        if (characterToken.isCData())\n            node = new CDataNode(data);\n        else if (tagName.equals(\"script\") || tagName.equals(\"style\"))\n            node = new DataNode(data);\n        else\n            node = new TextNode(data);\n        el.appendChild(node); \n    }\n\n    private void insertNode(Node node) {\n        \n        if (stack.size() == 0)\n            doc.appendChild(node);\n        else if (isFosterInserts())\n            insertInFosterParent(node);\n        else\n            currentElement().appendChild(node);\n\n        \n        if (node instanceof Element && ((Element) node).tag().isFormListed()) {\n            if (formElement != null)\n                formElement.addElement((Element) node);\n        }\n    }\n\n    Element pop() {\n        int size = stack.size();\n        return stack.remove(size-1);\n    }\n\n    void push(Element element) {\n        stack.add(element);\n    }\n\n    ArrayList<Element> getStack() {\n        return stack;\n    }\n\n    boolean onStack(Element el) {\n        return isElementInQueue(stack, el);\n    }\n\n    private boolean isElementInQueue(ArrayList<Element> queue, Element element) {\n        for (int pos = queue.size() -1; pos >= 0; pos--) {\n            Element next = queue.get(pos);\n            if (next == element) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    Element getFromStack(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                return next;\n            }\n        }\n        return null;\n    }\n\n    boolean removeFromStack(Element el) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                stack.remove(pos);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    void popStackToClose(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next.nodeName().equals(elName))\n                break;\n        }\n    }\n\n    \n    void popStackToClose(String... elNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (inSorted(next.nodeName(), elNames))\n                break;\n        }\n    }\n\n    void popStackToBefore(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                break;\n            } else {\n                stack.remove(pos);\n            }\n        }\n    }\n\n    void clearStackToTableContext() {\n        clearStackToContext(\"table\");\n    }\n\n    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\", \"template\");\n    }\n\n    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\", \"template\");\n    }\n\n    private void clearStackToContext(String... nodeNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n                break;\n            else\n                stack.remove(pos);\n        }\n    }\n\n    Element aboveOnStack(Element el) {\n        assert onStack(el);\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                return stack.get(pos-1);\n            }\n        }\n        return null;\n    }\n\n    void insertOnStackAfter(Element after, Element in) {\n        int i = stack.lastIndexOf(after);\n        Validate.isTrue(i != -1);\n        stack.add(i+1, in);\n    }\n\n    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }\n\n    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.set(i, in);\n    }\n\n    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; \n            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; \n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; \n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; \n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; \n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; \n            }\n        }\n    }\n\n    \n    private String[] specificScopeTarget = {null}; private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        specificScopeTarget[0] = targetName;\n        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        \n        final int bottom = stack.size() -1;\n        final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n        \n\n        for (int pos = bottom; pos >= top; pos--) {\n            final String elName = stack.get(pos).nodeName();\n            if (inSorted(elName, targetNames))\n                return true;\n            if (inSorted(elName, baseTypes))\n                return false;\n            if (extraTypes != null && inSorted(elName, extraTypes))\n                return false;\n        }\n        \n        return false;\n    }\n\n    boolean inScope(String[] targetNames) {\n        return inSpecificScope(targetNames, TagsSearchInScope, null);\n    }\n\n    boolean inScope(String targetName) {\n        return inScope(targetName, null);\n    }\n\n    boolean inScope(String targetName, String[] extras) {\n        return inSpecificScope(targetName, TagsSearchInScope, extras);\n        \n        \n    }\n\n    boolean inListItemScope(String targetName) {\n        return inScope(targetName, TagSearchList);\n    }\n\n    boolean inButtonScope(String targetName) {\n        return inScope(targetName, TagSearchButton);\n    }\n\n    boolean inTableScope(String targetName) {\n        return inSpecificScope(targetName, TagSearchTableScope, null);\n    }\n\n    boolean inSelectScope(String targetName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.nodeName();\n            if (elName.equals(targetName))\n                return true;\n            if (!inSorted(elName, TagSearchSelectScope)) \n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }\n\n    void setHeadElement(Element headElement) {\n        this.headElement = headElement;\n    }\n\n    Element getHeadElement() {\n        return headElement;\n    }\n\n    boolean isFosterInserts() {\n        return fosterInserts;\n    }\n\n    void setFosterInserts(boolean fosterInserts) {\n        this.fosterInserts = fosterInserts;\n    }\n\n    FormElement getFormElement() {\n        return formElement;\n    }\n\n    void setFormElement(FormElement formElement) {\n        this.formElement = formElement;\n    }\n\n    void newPendingTableCharacters() {\n        pendingTableCharacters = new ArrayList<>();\n    }\n\n    List<String> getPendingTableCharacters() {\n        return pendingTableCharacters;\n    }\n\n    \n    void generateImpliedEndTags(String excludeTag) {\n        while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\n                inSorted(currentElement().nodeName(), TagSearchEndTags))\n            pop();\n    }\n\n    void generateImpliedEndTags() {\n        generateImpliedEndTags(null);\n    }\n\n    boolean isSpecial(Element el) {\n        \n        \n        String name = el.nodeName();\n        return inSorted(name, TagSearchSpecial);\n    }\n\n    Element lastFormattingElement() {\n        return formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;\n    }\n\n    Element removeLastFormattingElement() {\n        int size = formattingElements.size();\n        if (size > 0)\n            return formattingElements.remove(size-1);\n        else\n            return null;\n    }\n\n    \n    void pushActiveFormattingElements(Element in) {\n        int numSeen = 0;\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element el = formattingElements.get(pos);\n            if (el == null) \n                break;\n\n            if (isSameFormattingElement(in, el))\n                numSeen++;\n\n            if (numSeen == 3) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n        formattingElements.add(in);\n    }\n\n    private boolean isSameFormattingElement(Element a, Element b) {\n        \n        return a.nodeName().equals(b.nodeName()) &&\n                \n                a.attributes().equals(b.attributes());\n        \n    }\n\n    void reconstructFormattingElements() {\n        Element last = lastFormattingElement();\n        if (last == null || onStack(last))\n            return;\n\n        Element entry = last;\n        int size = formattingElements.size();\n        int pos = size - 1;\n        boolean skip = false;\n        while (true) {\n            if (pos == 0) { \n                skip = true;\n                break;\n            }\n            entry = formattingElements.get(--pos); \n            if (entry == null || onStack(entry)) \n                break; \n        }\n        while(true) {\n            if (!skip) \n                entry = formattingElements.get(++pos);\n            Validate.notNull(entry); \n\n            \n            skip = false; \n            Element newEl = insertStartTag(entry.nodeName());\n            \n            newEl.attributes().addAll(entry.attributes());\n\n            \n            formattingElements.set(pos, newEl);\n\n            \n            if (pos == size-1) \n                break;\n        }\n    }\n\n    void clearFormattingElementsToLastMarker() {\n        while (!formattingElements.isEmpty()) {\n            Element el = removeLastFormattingElement();\n            if (el == null)\n                break;\n        }\n    }\n\n    void removeFromActiveFormattingElements(Element el) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == el) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n    }\n\n    boolean isInActiveFormattingElements(Element el) {\n        return isElementInQueue(formattingElements, el);\n    }\n\n    Element getActiveFormattingElement(String nodeName) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == null) \n                break;\n            else if (next.nodeName().equals(nodeName))\n                return next;\n        }\n        return null;\n    }\n\n    void replaceActiveFormattingElement(Element out, Element in) {\n        replaceInQueue(formattingElements, out, in);\n    }\n\n    void insertMarkerToFormattingElements() {\n        formattingElements.add(null);\n    }\n\n    void insertInFosterParent(Node in) {\n        Element fosterParent;\n        Element lastTable = getFromStack(\"table\");\n        boolean isLastTableParent = false;\n        if (lastTable != null) {\n            if (lastTable.parent() != null) {\n                fosterParent = lastTable.parent();\n                isLastTableParent = true;\n            } else\n                fosterParent = aboveOnStack(lastTable);\n        } else { \n            fosterParent = stack.get(0);\n        }\n\n        if (isLastTableParent) {\n            Validate.notNull(lastTable); \n            lastTable.before(in);\n        }\n        else\n            fosterParent.appendChild(in);\n    }\n\n    @Override\n    public String toString() {\n        return \"TreeBuilder{\" +\n                \"currentToken=\" + currentToken +\n                \", state=\" + state +\n                \", currentElement=\" + currentElement() +\n                '}';\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.internal.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.CDataNode;\nimport org.jsoup.nodes.Comment;\nimport org.jsoup.nodes.DataNode;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.FormElement;\nimport org.jsoup.nodes.Node;\nimport org.jsoup.nodes.TextNode;\nimport org.jsoup.select.Elements;\n\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.jsoup.internal.StringUtil.inSorted; public class HtmlTreeBuilder extends TreeBuilder { static final String[] TagsSearchInScope = new String[]{\"applet\", \"caption\", \"html\", \"marquee\", \"object\", \"table\", \"td\", \"th\"}; static final String[] TagSearchList = new String[]{\"ol\", \"ul\"}; static final String[] TagSearchButton = new String[]{\"button\"}; static final String[] TagSearchTableScope = new String[]{\"html\", \"table\"}; static final String[] TagSearchSelectScope = new String[]{\"optgroup\", \"option\"}; static final String[] TagSearchEndTags = new String[]{\"dd\", \"dt\", \"li\", \"optgroup\", \"option\", \"p\", \"rp\", \"rt\"}; static final String[] TagSearchSpecial = new String[]{\"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\", \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"command\", \"dd\", \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\", \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"marquee\", \"menu\", \"meta\", \"nav\", \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\", \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\"}; public static final int MaxScopeSearchDepth = 100; private HtmlTreeBuilderState state; private HtmlTreeBuilderState originalState; private boolean baseUriSetFromDoc; private Element headElement; private FormElement formElement; private Element contextElement; private ArrayList<Element> formattingElements; private List<String> pendingTableCharacters; private Token.EndTag emptyEnd; private boolean framesetOk; private boolean fosterInserts; private boolean fragmentParsing; ParseSettings defaultSettings() {\n        return ParseSettings.htmlDefault;\n    }\n\n    @Override\n    protected void initialiseParse(Reader input, String baseUri, Parser parser) {\n        super.initialiseParse(input, baseUri, parser);\n\n        \n        state = HtmlTreeBuilderState.Initial;\n        originalState = null;\n        baseUriSetFromDoc = false;\n        headElement = null;\n        formElement = null;\n        contextElement = null;\n        formattingElements = new ArrayList<>();\n        pendingTableCharacters = new ArrayList<>();\n        emptyEnd = new Token.EndTag();\n        framesetOk = true;\n        fosterInserts = false;\n        fragmentParsing = false;\n    }\n\n    List<Node> parseFragment(String inputFragment, Element context, String baseUri, Parser parser) {\n        \n        state = HtmlTreeBuilderState.Initial;\n        initialiseParse(new StringReader(inputFragment), baseUri, parser);\n        contextElement = context;\n        fragmentParsing = true;\n        Element root = null;\n\n        if (context != null) {\n            if (context.ownerDocument() != null) \n                doc.quirksMode(context.ownerDocument().quirksMode());\n\n            \n            String contextTag = context.tagName();\n            if (StringUtil.in(contextTag, \"title\", \"textarea\"))\n                tokeniser.transition(TokeniserState.Rcdata);\n            else if (StringUtil.in(contextTag, \"iframe\", \"noembed\", \"noframes\", \"style\", \"xmp\"))\n                tokeniser.transition(TokeniserState.Rawtext);\n            else if (contextTag.equals(\"script\"))\n                tokeniser.transition(TokeniserState.ScriptData);\n            else if (contextTag.equals((\"noscript\")))\n                tokeniser.transition(TokeniserState.Data); \n            else if (contextTag.equals(\"plaintext\"))\n                tokeniser.transition(TokeniserState.Data);\n            else\n                tokeniser.transition(TokeniserState.Data); \n\n            root = new Element(Tag.valueOf(\"html\", settings), baseUri);\n            doc.appendChild(root);\n            stack.add(root);\n            resetInsertionMode();\n\n            \n            \n            Elements contextChain = context.parents();\n            contextChain.add(0, context);\n            for (Element parent: contextChain) {\n                if (parent instanceof FormElement) {\n                    formElement = (FormElement) parent;\n                    break;\n                }\n            }\n        }\n\n        runParser();\n        if (context != null)\n            return root.childNodes();\n        else\n            return doc.childNodes();\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        currentToken = token;\n        return this.state.process(token, this);\n    }\n\n    boolean process(Token token, HtmlTreeBuilderState state) {\n        currentToken = token;\n        return state.process(token, this);\n    }\n\n    void transition(HtmlTreeBuilderState state) {\n        this.state = state;\n    }\n\n    HtmlTreeBuilderState state() {\n        return state;\n    }\n\n    void markInsertionMode() {\n        originalState = state;\n    }\n\n    HtmlTreeBuilderState originalState() {\n        return originalState;\n    }\n\n    void framesetOk(boolean framesetOk) {\n        this.framesetOk = framesetOk;\n    }\n\n    boolean framesetOk() {\n        return framesetOk;\n    }\n\n    Document getDocument() {\n        return doc;\n    }\n\n    String getBaseUri() {\n        return baseUri;\n    }\n\n    void maybeSetBaseUri(Element base) {\n        if (baseUriSetFromDoc) \n            return;\n\n        String href = base.absUrl(\"href\");\n        if (href.length() != 0) { \n            baseUri = href;\n            baseUriSetFromDoc = true;\n            doc.setBaseUri(href); \n        }\n    }\n\n    boolean isFragmentParsing() {\n        return fragmentParsing;\n    }\n\n    void error(HtmlTreeBuilderState state) {\n        if (parser.getErrors().canAddError())\n            parser.getErrors().add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }\n\n    Element insert(Token.StartTag startTag) {\n        \n        \n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.transition(TokeniserState.Data); \n            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  \n            return el;\n        }\n        \n        Element el = new Element(Tag.valueOf(startTag.name(), settings), baseUri, settings.normalizeAttributes(startTag.attributes));\n        insert(el);\n        return el;\n    }\n\n    Element insertStartTag(String startTagName) {\n        Element el = new Element(Tag.valueOf(startTagName, settings), baseUri);\n        insert(el);\n        return el;\n    }\n\n    void insert(Element el) {\n        insertNode(el);\n        stack.add(el);\n    }\n\n    Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (tag.isKnownTag()) {\n                if (!tag.isEmpty())\n                    tokeniser.error(\"Tag cannot be self closing; not a void tag\");\n            }\n            else \n                tag.setSelfClosing();\n        }\n        return el;\n    }\n\n    FormElement insertForm(Token.StartTag startTag, boolean onStack) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        FormElement el = new FormElement(tag, baseUri, startTag.attributes);\n        setFormElement(el);\n        insertNode(el);\n        if (onStack)\n            stack.add(el);\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData());\n        insertNode(comment);\n    }\n\n    void insert(Token.Character characterToken) {\n        final Node node;\n        final Element el = currentElement();\n        final String tagName = el.tagName();\n        final String data = characterToken.getData();\n\n        if (characterToken.isCData())\n            node = new CDataNode(data);\n        else if (tagName.equals(\"script\") || tagName.equals(\"style\"))\n            node = new DataNode(data);\n        else\n            node = new TextNode(data);\n        el.appendChild(node); \n    }\n\n    private void insertNode(Node node) {\n        \n        if (stack.size() == 0)\n            doc.appendChild(node);\n        else if (isFosterInserts())\n            insertInFosterParent(node);\n        else\n            currentElement().appendChild(node);\n\n        \n        if (node instanceof Element && ((Element) node).tag().isFormListed()) {\n            if (formElement != null)\n                formElement.addElement((Element) node);\n        }\n    }\n\n    Element pop() {\n        int size = stack.size();\n        return stack.remove(size-1);\n    }\n\n    void push(Element element) {\n        stack.add(element);\n    }\n\n    ArrayList<Element> getStack() {\n        return stack;\n    }\n\n    boolean onStack(Element el) {\n        return isElementInQueue(stack, el);\n    }\n\n    private boolean isElementInQueue(ArrayList<Element> queue, Element element) {\n        for (int pos = queue.size() -1; pos >= 0; pos--) {\n            Element next = queue.get(pos);\n            if (next == element) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    Element getFromStack(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.normalName().equals(elName)) {\n                return next;\n            }\n        }\n        return null;\n    }\n\n    boolean removeFromStack(Element el) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                stack.remove(pos);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    void popStackToClose(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next.normalName().equals(elName))\n                break;\n        }\n    }\n\n    \n    void popStackToClose(String... elNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (inSorted(next.normalName(), elNames))\n                break;\n        }\n    }\n\n    void popStackToBefore(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.normalName().equals(elName)) {\n                break;\n            } else {\n                stack.remove(pos);\n            }\n        }\n    }\n\n    void clearStackToTableContext() {\n        clearStackToContext(\"table\");\n    }\n\n    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\", \"template\");\n    }\n\n    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\", \"template\");\n    }\n\n    private void clearStackToContext(String... nodeNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (StringUtil.in(next.normalName(), nodeNames) || next.normalName().equals(\"html\"))\n                break;\n            else\n                stack.remove(pos);\n        }\n    }\n\n    Element aboveOnStack(Element el) {\n        assert onStack(el);\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                return stack.get(pos-1);\n            }\n        }\n        return null;\n    }\n\n    void insertOnStackAfter(Element after, Element in) {\n        int i = stack.lastIndexOf(after);\n        Validate.isTrue(i != -1);\n        stack.add(i+1, in);\n    }\n\n    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }\n\n    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.set(i, in);\n    }\n\n    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.normalName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; \n            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; \n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; \n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; \n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; \n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; \n            }\n        }\n    }\n\n    \n    private String[] specificScopeTarget = {null}; private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        specificScopeTarget[0] = targetName;\n        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        \n        final int bottom = stack.size() -1;\n        final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n        \n\n        for (int pos = bottom; pos >= top; pos--) {\n            final String elName = stack.get(pos).normalName();\n            if (inSorted(elName, targetNames))\n                return true;\n            if (inSorted(elName, baseTypes))\n                return false;\n            if (extraTypes != null && inSorted(elName, extraTypes))\n                return false;\n        }\n        \n        return false;\n    }\n\n    boolean inScope(String[] targetNames) {\n        return inSpecificScope(targetNames, TagsSearchInScope, null);\n    }\n\n    boolean inScope(String targetName) {\n        return inScope(targetName, null);\n    }\n\n    boolean inScope(String targetName, String[] extras) {\n        return inSpecificScope(targetName, TagsSearchInScope, extras);\n        \n        \n    }\n\n    boolean inListItemScope(String targetName) {\n        return inScope(targetName, TagSearchList);\n    }\n\n    boolean inButtonScope(String targetName) {\n        return inScope(targetName, TagSearchButton);\n    }\n\n    boolean inTableScope(String targetName) {\n        return inSpecificScope(targetName, TagSearchTableScope, null);\n    }\n\n    boolean inSelectScope(String targetName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.normalName();\n            if (elName.equals(targetName))\n                return true;\n            if (!inSorted(elName, TagSearchSelectScope)) \n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }\n\n    void setHeadElement(Element headElement) {\n        this.headElement = headElement;\n    }\n\n    Element getHeadElement() {\n        return headElement;\n    }\n\n    boolean isFosterInserts() {\n        return fosterInserts;\n    }\n\n    void setFosterInserts(boolean fosterInserts) {\n        this.fosterInserts = fosterInserts;\n    }\n\n    FormElement getFormElement() {\n        return formElement;\n    }\n\n    void setFormElement(FormElement formElement) {\n        this.formElement = formElement;\n    }\n\n    void newPendingTableCharacters() {\n        pendingTableCharacters = new ArrayList<>();\n    }\n\n    List<String> getPendingTableCharacters() {\n        return pendingTableCharacters;\n    }\n\n    \n    void generateImpliedEndTags(String excludeTag) {\n        while ((excludeTag != null && !currentElement().normalName().equals(excludeTag)) &&\n                inSorted(currentElement().normalName(), TagSearchEndTags))\n            pop();\n    }\n\n    void generateImpliedEndTags() {\n        generateImpliedEndTags(null);\n    }\n\n    boolean isSpecial(Element el) {\n        \n        \n        String name = el.normalName();\n        return inSorted(name, TagSearchSpecial);\n    }\n\n    Element lastFormattingElement() {\n        return formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;\n    }\n\n    Element removeLastFormattingElement() {\n        int size = formattingElements.size();\n        if (size > 0)\n            return formattingElements.remove(size-1);\n        else\n            return null;\n    }\n\n    \n    void pushActiveFormattingElements(Element in) {\n        int numSeen = 0;\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element el = formattingElements.get(pos);\n            if (el == null) \n                break;\n\n            if (isSameFormattingElement(in, el))\n                numSeen++;\n\n            if (numSeen == 3) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n        formattingElements.add(in);\n    }\n\n    private boolean isSameFormattingElement(Element a, Element b) {\n        \n        return a.normalName().equals(b.normalName()) &&\n                \n                a.attributes().equals(b.attributes());\n        \n    }\n\n    void reconstructFormattingElements() {\n        Element last = lastFormattingElement();\n        if (last == null || onStack(last))\n            return;\n\n        Element entry = last;\n        int size = formattingElements.size();\n        int pos = size - 1;\n        boolean skip = false;\n        while (true) {\n            if (pos == 0) { \n                skip = true;\n                break;\n            }\n            entry = formattingElements.get(--pos); \n            if (entry == null || onStack(entry)) \n                break; \n        }\n        while(true) {\n            if (!skip) \n                entry = formattingElements.get(++pos);\n            Validate.notNull(entry); \n\n            \n            skip = false; \n            Element newEl = insertStartTag(entry.normalName()); \n            \n            newEl.attributes().addAll(entry.attributes());\n\n            \n            formattingElements.set(pos, newEl);\n\n            \n            if (pos == size-1) \n                break;\n        }\n    }\n\n    void clearFormattingElementsToLastMarker() {\n        while (!formattingElements.isEmpty()) {\n            Element el = removeLastFormattingElement();\n            if (el == null)\n                break;\n        }\n    }\n\n    void removeFromActiveFormattingElements(Element el) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == el) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n    }\n\n    boolean isInActiveFormattingElements(Element el) {\n        return isElementInQueue(formattingElements, el);\n    }\n\n    Element getActiveFormattingElement(String nodeName) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == null) \n                break;\n            else if (next.normalName().equals(nodeName))\n                return next;\n        }\n        return null;\n    }\n\n    void replaceActiveFormattingElement(Element out, Element in) {\n        replaceInQueue(formattingElements, out, in);\n    }\n\n    void insertMarkerToFormattingElements() {\n        formattingElements.add(null);\n    }\n\n    void insertInFosterParent(Node in) {\n        Element fosterParent;\n        Element lastTable = getFromStack(\"table\");\n        boolean isLastTableParent = false;\n        if (lastTable != null) {\n            if (lastTable.parent() != null) {\n                fosterParent = lastTable.parent();\n                isLastTableParent = true;\n            } else\n                fosterParent = aboveOnStack(lastTable);\n        } else { \n            fosterParent = stack.get(0);\n        }\n\n        if (isLastTableParent) {\n            Validate.notNull(lastTable); \n            lastTable.before(in);\n        }\n        else\n            fosterParent.appendChild(in);\n    }\n\n    @Override\n    public String toString() {\n        return \"TreeBuilder{\" +\n                \"currentToken=\" + currentToken +\n                \", state=\" + state +\n                \", currentElement=\" + currentElement() +\n                '}';\n    }\n}\n",
      "buggy_signatures": [
        "protected void initialiseParse(Reader input, String baseUri, Parser parser)",
        "protected boolean process(Token token)",
        "private void insertNode(Node node)",
        "private boolean isElementInQueue(ArrayList<Element> queue, Element element)",
        "private void clearStackToContext(String... nodeNames)",
        "private void replaceInQueue(ArrayList<Element> queue, Element out, Element in)",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes)",
        "private boolean isSameFormattingElement(Element a, Element b)",
        "public String toString()"
      ],
      "fixed_signatures": [
        "protected void initialiseParse(Reader input, String baseUri, Parser parser)",
        "protected boolean process(Token token)",
        "private void insertNode(Node node)",
        "private boolean isElementInQueue(ArrayList<Element> queue, Element element)",
        "private void clearStackToContext(String... nodeNames)",
        "private void replaceInQueue(ArrayList<Element> queue, Element out, Element in)",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes)",
        "private boolean isSameFormattingElement(Element a, Element b)",
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "  private boolean isElementInQueue(ArrayList<Element> queue, Element element) {\n  for (int pos = queue.size() -1; pos >= 0; pos--) {\n  Element next = queue.get(pos);\n  if (next == element) {\n  return true;\n  }\n  }\n  return false;\n  }",
          "fixed_method": "  private boolean isElementInQueue(ArrayList<Element> queue, Element element) {\n  for (int pos = queue.size() -1; pos >= 0; pos--) {\n  Element next = queue.get(pos);\n  if (next == element) {\n  return true;\n  }\n  }\n  return false;\n  }",
          "diff": [
            "@@ -312,7 +312,7 @@",
            "     Element getFromStack(String elName) {\n",
            "         for (int pos = stack.size() -1; pos >= 0; pos--) {\n",
            "             Element next = stack.get(pos);\n",
            "-            if (next.nodeName().equals(elName)) {\n",
            "+            if (next.normalName().equals(elName)) {\n",
            "                 return next;\n",
            "             }\n",
            "         }\n",
            "@@ -334,7 +334,7 @@",
            "         for (int pos = stack.size() -1; pos >= 0; pos--) {\n",
            "             Element next = stack.get(pos);\n",
            "             stack.remove(pos);\n",
            "-            if (next.nodeName().equals(elName))\n",
            "+            if (next.normalName().equals(elName))\n",
            "                 break;\n",
            "         }\n",
            "     }\n",
            "@@ -344,7 +344,7 @@",
            "         for (int pos = stack.size() -1; pos >= 0; pos--) {\n",
            "             Element next = stack.get(pos);\n",
            "             stack.remove(pos);\n",
            "-            if (inSorted(next.nodeName(), elNames))\n",
            "+            if (inSorted(next.normalName(), elNames))\n",
            "                 break;\n",
            "         }\n",
            "     }\n",
            "@@ -352,7 +352,7 @@",
            "     void popStackToBefore(String elName) {\n",
            "         for (int pos = stack.size() -1; pos >= 0; pos--) {\n",
            "             Element next = stack.get(pos);\n",
            "-            if (next.nodeName().equals(elName)) {\n",
            "+            if (next.normalName().equals(elName)) {\n",
            "                 break;\n",
            "             } else {\n",
            "                 stack.remove(pos);\n"
          ],
          "changed_lines": 8
        },
        {
          "buggy_method": "  private void clearStackToContext(String... nodeNames) {\n  for (int pos = stack.size() -1; pos >= 0; pos--) {\n  Element next = stack.get(pos);\n  if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n  break;\n  else\n  stack.remove(pos);\n  }\n  }",
          "fixed_method": "  private void clearStackToContext(String... nodeNames) {\n  for (int pos = stack.size() -1; pos >= 0; pos--) {\n  Element next = stack.get(pos);\n  if (StringUtil.in(next.normalName(), nodeNames) || next.normalName().equals(\"html\"))\n  break;\n  else\n  stack.remove(pos);\n  }\n  }",
          "diff": [
            "@@ -375,7 +375,7 @@",
            "     private void clearStackToContext(String... nodeNames) {\n",
            "         for (int pos = stack.size() -1; pos >= 0; pos--) {\n",
            "             Element next = stack.get(pos);\n",
            "-            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n",
            "+            if (StringUtil.in(next.normalName(), nodeNames) || next.normalName().equals(\"html\"))\n",
            "                 break;\n",
            "             else\n",
            "                 stack.remove(pos);\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n  int i = queue.lastIndexOf(out);\n  Validate.isTrue(i != -1);\n  queue.set(i, in);\n  }",
          "fixed_method": "  private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n  int i = queue.lastIndexOf(out);\n  Validate.isTrue(i != -1);\n  queue.set(i, in);\n  }",
          "diff": [
            "@@ -417,7 +417,7 @@",
            "                 last = true;\n",
            "                 node = contextElement;\n",
            "             }\n",
            "-            String name = node.nodeName();\n",
            "+            String name = node.normalName();\n",
            "             if (\"select\".equals(name)) {\n",
            "                 transition(HtmlTreeBuilderState.InSelect);\n",
            "                 break; // frag\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n  \n  final int bottom = stack.size() -1;\n  final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n  \n\n  for (int pos = bottom; pos >= top; pos--) {\n  final String elName = stack.get(pos).nodeName();\n  if (inSorted(elName, targetNames))\n  return true;\n  if (inSorted(elName, baseTypes))\n  return false;\n  if (extraTypes != null && inSorted(elName, extraTypes))\n  return false;\n  }\n  \n  return false;\n  }",
          "fixed_method": "  private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n  \n  final int bottom = stack.size() -1;\n  final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n  \n\n  for (int pos = bottom; pos >= top; pos--) {\n  final String elName = stack.get(pos).normalName();\n  if (inSorted(elName, targetNames))\n  return true;\n  if (inSorted(elName, baseTypes))\n  return false;\n  if (extraTypes != null && inSorted(elName, extraTypes))\n  return false;\n  }\n  \n  return false;\n  }",
          "diff": [
            "@@ -473,7 +473,7 @@",
            "         // don't walk too far up the tree\n",
            " \n",
            "         for (int pos = bottom; pos >= top; pos--) {\n",
            "-            final String elName = stack.get(pos).nodeName();\n",
            "+            final String elName = stack.get(pos).normalName();\n",
            "             if (inSorted(elName, targetNames))\n",
            "                 return true;\n",
            "             if (inSorted(elName, baseTypes))\n",
            "@@ -514,7 +514,7 @@",
            "     boolean inSelectScope(String targetName) {\n",
            "         for (int pos = stack.size() -1; pos >= 0; pos--) {\n",
            "             Element el = stack.get(pos);\n",
            "-            String elName = el.nodeName();\n",
            "+            String elName = el.normalName();\n",
            "             if (elName.equals(targetName))\n",
            "                 return true;\n",
            "             if (!inSorted(elName, TagSearchSelectScope)) // all elements except\n",
            "@@ -566,8 +566,8 @@",
            "      process, then the UA must perform the above steps as if that element was not in the above list.\n",
            "      */\n",
            "     void generateImpliedEndTags(String excludeTag) {\n",
            "-        while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\n",
            "-                inSorted(currentElement().nodeName(), TagSearchEndTags))\n",
            "+        while ((excludeTag != null && !currentElement().normalName().equals(excludeTag)) &&\n",
            "+                inSorted(currentElement().normalName(), TagSearchEndTags))\n",
            "             pop();\n",
            "     }\n",
            " \n",
            "@@ -578,7 +578,7 @@",
            "     boolean isSpecial(Element el) {\n",
            "         // todo: mathml's mi, mo, mn\n",
            "         // todo: svg's foreigObject, desc, title\n",
            "-        String name = el.nodeName();\n",
            "+        String name = el.normalName();\n",
            "         return inSorted(name, TagSearchSpecial);\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 10
        },
        {
          "buggy_method": "  private boolean isSameFormattingElement(Element a, Element b) {\n  \n  return a.nodeName().equals(b.nodeName()) &&\n  \n  a.attributes().equals(b.attributes());\n  \n  }",
          "fixed_method": "  private boolean isSameFormattingElement(Element a, Element b) {\n  \n  return a.normalName().equals(b.normalName()) &&\n  \n  a.attributes().equals(b.attributes());\n  \n  }",
          "diff": [
            "@@ -615,7 +615,7 @@",
            " \n",
            "     private boolean isSameFormattingElement(Element a, Element b) {\n",
            "         // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children\n",
            "-        return a.nodeName().equals(b.nodeName()) &&\n",
            "+        return a.normalName().equals(b.normalName()) &&\n",
            "                 // a.namespace().equals(b.namespace()) &&\n",
            "                 a.attributes().equals(b.attributes());\n",
            "         // todo: namespaces\n",
            "@@ -646,7 +646,7 @@",
            " \n",
            "             // 8. create new element from element, 9 insert into current node, onto stack\n",
            "             skip = false; // can only skip increment from 4.\n",
            "-            Element newEl = insertStartTag(entry.nodeName());\n",
            "+            Element newEl = insertStartTag(entry.normalName()); // todo: avoid fostering here?\n",
            "             // newEl.namespace(entry.namespace()); // todo: namespaces\n",
            "             newEl.attributes().addAll(entry.attributes());\n",
            " \n",
            "@@ -686,7 +686,7 @@",
            "             Element next = formattingElements.get(pos);\n",
            "             if (next == null) // scope marker\n",
            "                 break;\n",
            "-            else if (next.nodeName().equals(nodeName))\n",
            "+            else if (next.normalName().equals(nodeName))\n",
            "                 return next;\n",
            "         }\n",
            "         return null;\n"
          ],
          "changed_lines": 6
        }
      ]
    },
    {
      "name": "org/jsoup/parser/HtmlTreeBuilderState.java",
      "buggy_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.internal.StringUtil;\nimport org.jsoup.nodes.Attribute;\nimport org.jsoup.nodes.Attributes;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.DocumentType;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.Node;\n\nimport java.util.ArrayList;\n\n\nenum HtmlTreeBuilderState {\n    Initial {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                return true; \n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                \n                \n                Token.Doctype d = t.asDoctype();\n                DocumentType doctype = new DocumentType(\n                    tb.settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier());\n                doctype.setPubSysKey(d.getPubSysKey());\n                tb.getDocument().appendChild(doctype);\n                if (d.isForceQuirks())\n                    tb.getDocument().quirksMode(Document.QuirksMode.quirks);\n                tb.transition(BeforeHtml);\n            } else {\n                \n                tb.transition(BeforeHtml);\n                return tb.process(t); \n            }\n            return true;\n        }\n    },\n    BeforeHtml {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (isWhitespace(t)) {\n                return true; \n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                tb.insert(t.asStartTag());\n                tb.transition(BeforeHead);\n            } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().normalName(), \"head\", \"body\", \"html\", \"br\"))) {\n                return anythingElse(t, tb);\n            } else if (t.isEndTag()) {\n                tb.error(this);\n                return false;\n            } else {\n                return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.insertStartTag(\"html\");\n            tb.transition(BeforeHead);\n            return tb.process(t);\n        }\n    },\n    BeforeHead {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                return true;\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                return InBody.process(t, tb); \n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"head\")) {\n                Element head = tb.insert(t.asStartTag());\n                tb.setHeadElement(head);\n                tb.transition(InHead);\n            } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().normalName(), \"head\", \"body\", \"html\", \"br\"))) {\n                tb.processStartTag(\"head\");\n                return tb.process(t);\n            } else if (t.isEndTag()) {\n                tb.error(this);\n                return false;\n            } else {\n                tb.processStartTag(\"head\");\n                return tb.process(t);\n            }\n            return true;\n        }\n    },\n    InHead {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n                return true;\n            }\n            switch (t.type) {\n                case Comment:\n                    tb.insert(t.asComment());\n                    break;\n                case Doctype:\n                    tb.error(this);\n                    return false;\n                case StartTag:\n                    Token.StartTag start = t.asStartTag();\n                    String name = start.normalName();\n                    if (name.equals(\"html\")) {\n                        return InBody.process(t, tb);\n                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\")) {\n                        Element el = tb.insertEmpty(start);\n                        \n                        if (name.equals(\"base\") && el.hasAttr(\"href\"))\n                            tb.maybeSetBaseUri(el);\n                    } else if (name.equals(\"meta\")) {\n                        Element meta = tb.insertEmpty(start);\n                        \n                    } else if (name.equals(\"title\")) {\n                        handleRcData(start, tb);\n                    } else if (StringUtil.in(name, \"noframes\", \"style\")) {\n                        handleRawtext(start, tb);\n                    } else if (name.equals(\"noscript\")) {\n                        \n                        tb.insert(start);\n                        tb.transition(InHeadNoscript);\n                    } else if (name.equals(\"script\")) {\n                        \n\n                        tb.tokeniser.transition(TokeniserState.ScriptData);\n                        tb.markInsertionMode();\n                        tb.transition(Text);\n                        tb.insert(start);\n                    } else if (name.equals(\"head\")) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        return anythingElse(t, tb);\n                    }\n                    break;\n                case EndTag:\n                    Token.EndTag end = t.asEndTag();\n                    name = end.normalName();\n                    if (name.equals(\"head\")) {\n                        tb.pop();\n                        tb.transition(AfterHead);\n                    } else if (StringUtil.in(name, \"body\", \"html\", \"br\")) {\n                        return anythingElse(t, tb);\n                    } else {\n                        tb.error(this);\n                        return false;\n                    }\n                    break;\n                default:\n                    return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, TreeBuilder tb) {\n            tb.processEndTag(\"head\");\n            return tb.process(t);\n        }\n    },\n    InHeadNoscript {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isDoctype()) {\n                tb.error(this);\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                return tb.process(t, InBody);\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"noscript\")) {\n                tb.pop();\n                tb.transition(InHead);\n            } else if (isWhitespace(t) || t.isComment() || (t.isStartTag() && StringUtil.in(t.asStartTag().normalName(),\n                    \"basefont\", \"bgsound\", \"link\", \"meta\", \"noframes\", \"style\"))) {\n                return tb.process(t, InHead);\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"br\")) {\n                return anythingElse(t, tb);\n            } else if ((t.isStartTag() && StringUtil.in(t.asStartTag().normalName(), \"head\", \"noscript\")) || t.isEndTag()) {\n                tb.error(this);\n                return false;\n            } else {\n                return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.error(this);\n            tb.insert(new Token.Character().data(t.toString()));\n            return true;\n        }\n    },\n    AfterHead {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                tb.error(this);\n            } else if (t.isStartTag()) {\n                Token.StartTag startTag = t.asStartTag();\n                String name = startTag.normalName();\n                if (name.equals(\"html\")) {\n                    return tb.process(t, InBody);\n                } else if (name.equals(\"body\")) {\n                    tb.insert(startTag);\n                    tb.framesetOk(false);\n                    tb.transition(InBody);\n                } else if (name.equals(\"frameset\")) {\n                    tb.insert(startTag);\n                    tb.transition(InFrameset);\n                } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                    tb.error(this);\n                    Element head = tb.getHeadElement();\n                    tb.push(head);\n                    tb.process(t, InHead);\n                    tb.removeFromStack(head);\n                } else if (name.equals(\"head\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    anythingElse(t, tb);\n                }\n            } else if (t.isEndTag()) {\n                if (StringUtil.in(t.asEndTag().normalName(), \"body\", \"html\")) {\n                    anythingElse(t, tb);\n                } else {\n                    tb.error(this);\n                    return false;\n                }\n            } else {\n                anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.processStartTag(\"body\");\n            tb.framesetOk(true);\n            return tb.process(t);\n        }\n    },\n    InBody {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character: {\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        \n                        tb.error(this);\n                        return false;\n                    } else if (tb.framesetOk() && isWhitespace(c)) { \n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    \n                    String name = startTag.normalName();\n                    if (name.equals(\"a\")) {\n                        if (tb.getActiveFormattingElement(\"a\") != null) {\n                            tb.error(this);\n                            tb.processEndTag(\"a\");\n\n                            \n                            Element remainingA = tb.getFromStack(\"a\");\n                            if (remainingA != null) {\n                                tb.removeFromActiveFormattingElements(remainingA);\n                                tb.removeFromStack(remainingA);\n                            }\n                        }\n                        tb.reconstructFormattingElements();\n                        Element a = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(a);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n                        tb.reconstructFormattingElements();\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"span\")) {\n                        \n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (name.equals(\"li\")) {\n                        tb.framesetOk(false);\n                        ArrayList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (el.nodeName().equals(\"li\")) {\n                                tb.processEndTag(\"li\");\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"html\")) {\n                        tb.error(this);\n                        \n                        Element html = tb.getStack().get(0);\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        ArrayList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            \n                            return false; \n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        ArrayList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            \n                            return false; \n                        } else if (!tb.framesetOk()) {\n                            return false; \n                        } else {\n                            Element second = stack.get(1);\n                            if (second.parent() != null)\n                                second.remove();\n                            \n                            while (stack.size() > 1)\n                                stack.remove(stack.size()-1);\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n                            tb.error(this);\n                            tb.pop();\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.reader.matchConsume(\"\\n\"); \n                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null) {\n                            tb.error(this);\n                            return false;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insertForm(startTag, true);\n                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                        tb.framesetOk(false);\n                        ArrayList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n                                tb.processEndTag(el.nodeName());\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"plaintext\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); \n                    } else if (name.equals(\"button\")) {\n                        if (tb.inButtonScope(\"button\")) {\n                            \n                            tb.error(this);\n                            tb.processEndTag(\"button\");\n                            tb.process(startTag);\n                        } else {\n                            tb.reconstructFormattingElements();\n                            tb.insert(startTag);\n                            tb.framesetOk(false);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Formatters)) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (name.equals(\"nobr\")) {\n                        tb.reconstructFormattingElements();\n                        if (tb.inScope(\"nobr\")) {\n                            tb.error(this);\n                            tb.processEndTag(\"nobr\");\n                            tb.reconstructFormattingElements();\n                        }\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.insertMarkerToFormattingElements();\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"table\")) {\n                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        tb.transition(InTable);\n                    } else if (name.equals(\"input\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insertEmpty(startTag);\n                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                            tb.framesetOk(false);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n                        tb.insertEmpty(startTag);\n                    } else if (name.equals(\"hr\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"image\")) {\n                        if (tb.getFromStack(\"svg\") == null)\n                            return tb.process(startTag.name(\"img\")); \n                        else\n                            tb.insert(startTag);\n                    } else if (name.equals(\"isindex\")) {\n                        \n                        tb.error(this);\n                        if (tb.getFormElement() != null)\n                            return false;\n\n                        tb.processStartTag(\"form\");\n                        if (startTag.attributes.hasKey(\"action\")) {\n                            Element form = tb.getFormElement();\n                            form.attr(\"action\", startTag.attributes.get(\"action\"));\n                        }\n                        tb.processStartTag(\"hr\");\n                        tb.processStartTag(\"label\");\n                        \n                        String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                                startTag.attributes.get(\"prompt\") :\n                                \"This is a searchable index. Enter search keywords: \";\n\n                        tb.process(new Token.Character().data(prompt));\n\n                        \n                        Attributes inputAttribs = new Attributes();\n                        for (Attribute attr : startTag.attributes) {\n                            if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n                                inputAttribs.put(attr);\n                        }\n                        inputAttribs.put(\"name\", \"isindex\");\n                        tb.processStartTag(\"input\", inputAttribs);\n                        tb.processEndTag(\"label\");\n                        tb.processStartTag(\"hr\");\n                        tb.processEndTag(\"form\");\n                    } else if (name.equals(\"textarea\")) {\n                        tb.insert(startTag);\n                        \n                        tb.tokeniser.transition(TokeniserState.Rcdata);\n                        tb.markInsertionMode();\n                        tb.framesetOk(false);\n                        tb.transition(Text);\n                    } else if (name.equals(\"xmp\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.reconstructFormattingElements();\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"iframe\")) {\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"noembed\")) {\n                        \n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"select\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n\n                        HtmlTreeBuilderState state = tb.state();\n                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                            tb.transition(InSelectInTable);\n                        else\n                            tb.transition(InSelect);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.processEndTag(\"option\");\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n                        if (tb.inScope(\"ruby\")) {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                                tb.error(this);\n                                tb.popStackToBefore(\"ruby\"); \n                            }\n                            tb.insert(startTag);\n                        }\n                    } else if (name.equals(\"math\")) {\n                        tb.reconstructFormattingElements();\n                        \n                        tb.insert(startTag);\n                    } else if (name.equals(\"svg\")) {\n                        tb.reconstructFormattingElements();\n                        \n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    }\n                    break;\n\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.normalName();\n                    if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n                        \n                        for (int i = 0; i < 8; i++) {\n                            Element formatEl = tb.getActiveFormattingElement(name);\n                            if (formatEl == null)\n                                return anyOtherEndTag(t, tb);\n                            else if (!tb.onStack(formatEl)) {\n                                tb.error(this);\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            } else if (!tb.inScope(formatEl.nodeName())) {\n                                tb.error(this);\n                                return false;\n                            } else if (tb.currentElement() != formatEl)\n                                tb.error(this);\n\n                            Element furthestBlock = null;\n                            Element commonAncestor = null;\n                            boolean seenFormattingElement = false;\n                            ArrayList<Element> stack = tb.getStack();\n                            \n                            \n                            final int stackSize = stack.size();\n                            for (int si = 0; si < stackSize && si < 64; si++) {\n                                Element el = stack.get(si);\n                                if (el == formatEl) {\n                                    commonAncestor = stack.get(si - 1);\n                                    seenFormattingElement = true;\n                                } else if (seenFormattingElement && tb.isSpecial(el)) {\n                                    furthestBlock = el;\n                                    break;\n                                }\n                            }\n                            if (furthestBlock == null) {\n                                tb.popStackToClose(formatEl.nodeName());\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            }\n\n                            \n                            \n                            Element node = furthestBlock;\n                            Element lastNode = furthestBlock;\n                            for (int j = 0; j < 3; j++) {\n                                if (tb.onStack(node))\n                                    node = tb.aboveOnStack(node);\n                                if (!tb.isInActiveFormattingElements(node)) { \n                                    tb.removeFromStack(node);\n                                    continue;\n                                } else if (node == formatEl)\n                                    break;\n\n                                Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n                                \n                                tb.replaceActiveFormattingElement(node, replacement);\n                                tb.replaceOnStack(node, replacement);\n                                node = replacement;\n\n                                if (lastNode == furthestBlock) {\n                                    \n                                    \n                                }\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                node.appendChild(lastNode);\n\n                                lastNode = node;\n                            }\n\n                            if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                tb.insertInFosterParent(lastNode);\n                            } else {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                commonAncestor.appendChild(lastNode);\n                            }\n\n                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                            adopter.attributes().addAll(formatEl.attributes());\n                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                            for (Node childNode : childNodes) {\n                                adopter.appendChild(childNode); \n                            }\n                            furthestBlock.appendChild(adopter);\n                            tb.removeFromActiveFormattingElements(formatEl);\n                            \n                            tb.removeFromStack(formatEl);\n                            tb.insertOnStackAfter(furthestBlock, adopter);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n                        if (!tb.inScope(name)) {\n                            \n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"span\")) {\n                        \n                        return anyOtherEndTag(t, tb);\n                    } else if (name.equals(\"li\")) {\n                        if (!tb.inListItemScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"body\")) {\n                        if (!tb.inScope(\"body\")) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            \n                            tb.transition(AfterBody);\n                        }\n                    } else if (name.equals(\"html\")) {\n                        boolean notIgnored = tb.processEndTag(\"body\");\n                        if (notIgnored)\n                            return tb.process(endTag);\n                    } else if (name.equals(\"form\")) {\n                        Element currentForm = tb.getFormElement();\n                        tb.setFormElement(null);\n                        if (currentForm == null || !tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            \n                            tb.removeFromStack(currentForm);\n                        }\n                    } else if (name.equals(\"p\")) {\n                        if (!tb.inButtonScope(name)) {\n                            tb.error(this);\n                            tb.processStartTag(name); \n                            return tb.process(endTag);\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                        if (!tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                        if (!tb.inScope(Constants.Headings)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(Constants.Headings);\n                        }\n                    } else if (name.equals(\"sarcasm\")) {\n                        \n                        return anyOtherEndTag(t, tb);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                        if (!tb.inScope(\"name\")) {\n                            if (!tb.inScope(name)) {\n                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker();\n                        }\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.processStartTag(\"br\");\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n\n                    break;\n                case EOF:\n                    \n                    \n                    break;\n            }\n            return true;\n        }\n\n        boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n            String name = tb.settings.normalizeTag(t.asEndTag().name());\n            ArrayList<Element> stack = tb.getStack();\n            for (int pos = stack.size() -1; pos >= 0; pos--) {\n                Element node = stack.get(pos);\n                if (node.nodeName().equals(name)) {\n                    tb.generateImpliedEndTags(name);\n                    if (!name.equals(tb.currentElement().nodeName()))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    break;\n                } else {\n                    if (tb.isSpecial(node)) {\n                        tb.error(this);\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    Text {\n        \n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isCharacter()) {\n                tb.insert(t.asCharacter());\n            } else if (t.isEOF()) {\n                tb.error(this);\n                \n                tb.pop();\n                tb.transition(tb.originalState());\n                return tb.process(t);\n            } else if (t.isEndTag()) {\n                \n                tb.pop();\n                tb.transition(tb.originalState());\n            }\n            return true;\n        }\n    },\n    InTable {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isCharacter()) {\n                tb.newPendingTableCharacters();\n                tb.markInsertionMode();\n                tb.transition(InTableText);\n                return tb.process(t);\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n                return true;\n            } else if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isStartTag()) {\n                Token.StartTag startTag = t.asStartTag();\n                String name = startTag.normalName();\n                if (name.equals(\"caption\")) {\n                    tb.clearStackToTableContext();\n                    tb.insertMarkerToFormattingElements();\n                    tb.insert(startTag);\n                    tb.transition(InCaption);\n                } else if (name.equals(\"colgroup\")) {\n                    tb.clearStackToTableContext();\n                    tb.insert(startTag);\n                    tb.transition(InColumnGroup);\n                } else if (name.equals(\"col\")) {\n                    tb.processStartTag(\"colgroup\");\n                    return tb.process(t);\n                } else if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n                    tb.clearStackToTableContext();\n                    tb.insert(startTag);\n                    tb.transition(InTableBody);\n                } else if (StringUtil.in(name, \"td\", \"th\", \"tr\")) {\n                    tb.processStartTag(\"tbody\");\n                    return tb.process(t);\n                } else if (name.equals(\"table\")) {\n                    tb.error(this);\n                    boolean processed = tb.processEndTag(\"table\");\n                    if (processed) \n                        return tb.process(t);\n                } else if (StringUtil.in(name, \"style\", \"script\")) {\n                    return tb.process(t, InHead);\n                } else if (name.equals(\"input\")) {\n                    if (!startTag.attributes.get(\"type\").equalsIgnoreCase(\"hidden\")) {\n                        return anythingElse(t, tb);\n                    } else {\n                        tb.insertEmpty(startTag);\n                    }\n                } else if (name.equals(\"form\")) {\n                    tb.error(this);\n                    if (tb.getFormElement() != null)\n                        return false;\n                    else {\n                        tb.insertForm(startTag, false);\n                    }\n                } else {\n                    return anythingElse(t, tb);\n                }\n                return true; \n            } else if (t.isEndTag()) {\n                Token.EndTag endTag = t.asEndTag();\n                String name = endTag.normalName();\n\n                if (name.equals(\"table\")) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.popStackToClose(\"table\");\n                    }\n                    tb.resetInsertionMode();\n                } else if (StringUtil.in(name,\n                        \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    return anythingElse(t, tb);\n                }\n                return true; \n            } else if (t.isEOF()) {\n                if (tb.currentElement().nodeName().equals(\"html\"))\n                    tb.error(this);\n                return true; \n            }\n            return anythingElse(t, tb);\n        }\n\n        boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.error(this);\n            boolean processed;\n            if (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                tb.setFosterInserts(true);\n                processed = tb.process(t, InBody);\n                tb.setFosterInserts(false);\n            } else {\n                processed = tb.process(t, InBody);\n            }\n            return processed;\n        }\n    },\n    InTableText {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character:\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.getPendingTableCharacters().add(c.getData());\n                    }\n                    break;\n                default:\n                    \n                    if (tb.getPendingTableCharacters().size() > 0) {\n                        for (String character : tb.getPendingTableCharacters()) {\n                            if (!isWhitespace(character)) {\n                                \n                                tb.error(this);\n                                if (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                                    tb.setFosterInserts(true);\n                                    tb.process(new Token.Character().data(character), InBody);\n                                    tb.setFosterInserts(false);\n                                } else {\n                                    tb.process(new Token.Character().data(character), InBody);\n                                }\n                            } else\n                                tb.insert(new Token.Character().data(character));\n                        }\n                        tb.newPendingTableCharacters();\n                    }\n                    tb.transition(tb.originalState());\n                    return tb.process(t);\n            }\n            return true;\n        }\n    },\n    InCaption {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isEndTag() && t.asEndTag().normalName().equals(\"caption\")) {\n                Token.EndTag endTag = t.asEndTag();\n                String name = endTag.normalName();\n                if (!tb.inTableScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(\"caption\"))\n                        tb.error(this);\n                    tb.popStackToClose(\"caption\");\n                    tb.clearFormattingElementsToLastMarker();\n                    tb.transition(InTable);\n                }\n            } else if ((\n                    t.isStartTag() && StringUtil.in(t.asStartTag().normalName(),\n                            \"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\") ||\n                            t.isEndTag() && t.asEndTag().normalName().equals(\"table\"))\n                    ) {\n                tb.error(this);\n                boolean processed = tb.processEndTag(\"caption\");\n                if (processed)\n                    return tb.process(t);\n            } else if (t.isEndTag() && StringUtil.in(t.asEndTag().normalName(),\n                    \"body\", \"col\", \"colgroup\", \"html\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                tb.error(this);\n                return false;\n            } else {\n                return tb.process(t, InBody);\n            }\n            return true;\n        }\n    },\n    InColumnGroup {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n                return true;\n            }\n            switch (t.type) {\n                case Comment:\n                    tb.insert(t.asComment());\n                    break;\n                case Doctype:\n                    tb.error(this);\n                    break;\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    switch (startTag.normalName()) {\n                        case \"html\":\n                            return tb.process(t, InBody);\n                        case \"col\":\n                            tb.insertEmpty(startTag);\n                            break;\n                        default:\n                            return anythingElse(t, tb);\n                    }\n                    break;\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    if (endTag.normalName.equals(\"colgroup\")) {\n                        if (tb.currentElement().nodeName().equals(\"html\")) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.pop();\n                            tb.transition(InTable);\n                        }\n                    } else\n                        return anythingElse(t, tb);\n                    break;\n                case EOF:\n                    if (tb.currentElement().nodeName().equals(\"html\"))\n                        return true; \n                    else\n                        return anythingElse(t, tb);\n                default:\n                    return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, TreeBuilder tb) {\n            boolean processed = tb.processEndTag(\"colgroup\");\n            if (processed) \n                return tb.process(t);\n            return true;\n        }\n    },\n    InTableBody {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.normalName();\n                    if (name.equals(\"template\")) {\n                        tb.insert(startTag);\n                    } else if (name.equals(\"tr\")) {\n                        tb.clearStackToTableBodyContext();\n                        tb.insert(startTag);\n                        tb.transition(InRow);\n                    } else if (StringUtil.in(name, \"th\", \"td\")) {\n                        tb.error(this);\n                        tb.processStartTag(\"tr\");\n                        return tb.process(startTag);\n                    } else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\")) {\n                        return exitTableBody(t, tb);\n                    } else\n                        return anythingElse(t, tb);\n                    break;\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.normalName();\n                    if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n                        if (!tb.inTableScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.clearStackToTableBodyContext();\n                            tb.pop();\n                            tb.transition(InTable);\n                        }\n                    } else if (name.equals(\"table\")) {\n                        return exitTableBody(t, tb);\n                    } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\", \"tr\")) {\n                        tb.error(this);\n                        return false;\n                    } else\n                        return anythingElse(t, tb);\n                    break;\n                default:\n                    return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean exitTableBody(Token t, HtmlTreeBuilder tb) {\n            if (!(tb.inTableScope(\"tbody\") || tb.inTableScope(\"thead\") || tb.inScope(\"tfoot\"))) {\n                \n                tb.error(this);\n                return false;\n            }\n            tb.clearStackToTableBodyContext();\n            tb.processEndTag(tb.currentElement().nodeName());\n            return tb.process(t);\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            return tb.process(t, InTable);\n        }\n    },\n    InRow {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isStartTag()) {\n                Token.StartTag startTag = t.asStartTag();\n                String name = startTag.normalName();\n\n                if (name.equals(\"template\")) {\n                    tb.insert(startTag);\n                } else if (StringUtil.in(name, \"th\", \"td\")) {\n                    tb.clearStackToTableRowContext();\n                    tb.insert(startTag);\n                    tb.transition(InCell);\n                    tb.insertMarkerToFormattingElements();\n                } else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                    return handleMissingTr(t, tb);\n                } else {\n                    return anythingElse(t, tb);\n                }\n            } else if (t.isEndTag()) {\n                Token.EndTag endTag = t.asEndTag();\n                String name = endTag.normalName();\n\n                if (name.equals(\"tr\")) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this); \n                        return false;\n                    }\n                    tb.clearStackToTableRowContext();\n                    tb.pop(); \n                    tb.transition(InTableBody);\n                } else if (name.equals(\"table\")) {\n                    return handleMissingTr(t, tb);\n                } else if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this);\n                        return false;\n                    }\n                    tb.processEndTag(\"tr\");\n                    return tb.process(t);\n                } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    return anythingElse(t, tb);\n                }\n            } else {\n                return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            return tb.process(t, InTable);\n        }\n\n        private boolean handleMissingTr(Token t, TreeBuilder tb) {\n            boolean processed = tb.processEndTag(\"tr\");\n            if (processed)\n                return tb.process(t);\n            else\n                return false;\n        }\n    },\n    InCell {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isEndTag()) {\n                Token.EndTag endTag = t.asEndTag();\n                String name = endTag.normalName();\n\n                if (StringUtil.inSorted(name, Constants.InCellNames)) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this);\n                        tb.transition(InRow); \n                        return false;\n                    }\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    tb.clearFormattingElementsToLastMarker();\n                    tb.transition(InRow);\n                } else if (StringUtil.inSorted(name, Constants.InCellBody)) {\n                    tb.error(this);\n                    return false;\n                } else if (StringUtil.inSorted(name, Constants.InCellTable)) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this);\n                        return false;\n                    }\n                    closeCell(tb);\n                    return tb.process(t);\n                } else {\n                    return anythingElse(t, tb);\n                }\n            } else if (t.isStartTag() &&\n                    StringUtil.inSorted(t.asStartTag().normalName(), Constants.InCellCol)) {\n                if (!(tb.inTableScope(\"td\") || tb.inTableScope(\"th\"))) {\n                    tb.error(this);\n                    return false;\n                }\n                closeCell(tb);\n                return tb.process(t);\n            } else {\n                return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            return tb.process(t, InBody);\n        }\n\n        private void closeCell(HtmlTreeBuilder tb) {\n            if (tb.inTableScope(\"td\"))\n                tb.processEndTag(\"td\");\n            else\n                tb.processEndTag(\"th\"); \n        }\n    },\n    InSelect {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character:\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.insert(c);\n                    }\n                    break;\n                case Comment:\n                    tb.insert(t.asComment());\n                    break;\n                case Doctype:\n                    tb.error(this);\n                    return false;\n                case StartTag:\n                    Token.StartTag start = t.asStartTag();\n                    String name = start.normalName();\n                    if (name.equals(\"html\"))\n                        return tb.process(start, InBody);\n                    else if (name.equals(\"option\")) {\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.processEndTag(\"option\");\n                        tb.insert(start);\n                    } else if (name.equals(\"optgroup\")) {\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.processEndTag(\"option\");\n                        else if (tb.currentElement().nodeName().equals(\"optgroup\"))\n                            tb.processEndTag(\"optgroup\");\n                        tb.insert(start);\n                    } else if (name.equals(\"select\")) {\n                        tb.error(this);\n                        return tb.processEndTag(\"select\");\n                    } else if (StringUtil.in(name, \"input\", \"keygen\", \"textarea\")) {\n                        tb.error(this);\n                        if (!tb.inSelectScope(\"select\"))\n                            return false; \n                        tb.processEndTag(\"select\");\n                        return tb.process(start);\n                    } else if (name.equals(\"script\")) {\n                        return tb.process(t, InHead);\n                    } else {\n                        return anythingElse(t, tb);\n                    }\n                    break;\n                case EndTag:\n                    Token.EndTag end = t.asEndTag();\n                    name = end.normalName();\n                    switch (name) {\n                        case \"optgroup\":\n                            if (tb.currentElement().nodeName().equals(\"option\") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).nodeName().equals(\"optgroup\"))\n                                tb.processEndTag(\"option\");\n                            if (tb.currentElement().nodeName().equals(\"optgroup\"))\n                                tb.pop();\n                            else\n                                tb.error(this);\n                            break;\n                        case \"option\":\n                            if (tb.currentElement().nodeName().equals(\"option\"))\n                                tb.pop();\n                            else\n                                tb.error(this);\n                            break;\n                        case \"select\":\n                            if (!tb.inSelectScope(name)) {\n                                tb.error(this);\n                                return false;\n                            } else {\n                                tb.popStackToClose(name);\n                                tb.resetInsertionMode();\n                            }\n                            break;\n                        default:\n                            return anythingElse(t, tb);\n                    }\n                    break;\n                case EOF:\n                    if (!tb.currentElement().nodeName().equals(\"html\"))\n                        tb.error(this);\n                    break;\n                default:\n                    return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.error(this);\n            return false;\n        }\n    },\n    InSelectInTable {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isStartTag() && StringUtil.in(t.asStartTag().normalName(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n                tb.error(this);\n                tb.processEndTag(\"select\");\n                return tb.process(t);\n            } else if (t.isEndTag() && StringUtil.in(t.asEndTag().normalName(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n                tb.error(this);\n                if (tb.inTableScope(t.asEndTag().normalName())) {\n                    tb.processEndTag(\"select\");\n                    return (tb.process(t));\n                } else\n                    return false;\n            } else {\n                return tb.process(t, InSelect);\n            }\n        }\n    },\n    AfterBody {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                return tb.process(t, InBody);\n            } else if (t.isComment()) {\n                tb.insert(t.asComment()); \n            } else if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                return tb.process(t, InBody);\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"html\")) {\n                if (tb.isFragmentParsing()) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.transition(AfterAfterBody);\n                }\n            } else if (t.isEOF()) {\n                \n            } else {\n                tb.error(this);\n                tb.transition(InBody);\n                return tb.process(t);\n            }\n            return true;\n        }\n    },\n    InFrameset {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isStartTag()) {\n                Token.StartTag start = t.asStartTag();\n                switch (start.normalName()) {\n                    case \"html\":\n                        return tb.process(start, InBody);\n                    case \"frameset\":\n                        tb.insert(start);\n                        break;\n                    case \"frame\":\n                        tb.insertEmpty(start);\n                        break;\n                    case \"noframes\":\n                        return tb.process(start, InHead);\n                    default:\n                        tb.error(this);\n                        return false;\n                }\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"frameset\")) {\n                if (tb.currentElement().nodeName().equals(\"html\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.pop();\n                    if (!tb.isFragmentParsing() && !tb.currentElement().nodeName().equals(\"frameset\")) {\n                        tb.transition(AfterFrameset);\n                    }\n                }\n            } else if (t.isEOF()) {\n                if (!tb.currentElement().nodeName().equals(\"html\")) {\n                    tb.error(this);\n                    return true;\n                }\n            } else {\n                tb.error(this);\n                return false;\n            }\n            return true;\n        }\n    },\n    AfterFrameset {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                return tb.process(t, InBody);\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"html\")) {\n                tb.transition(AfterAfterFrameset);\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"noframes\")) {\n                return tb.process(t, InHead);\n            } else if (t.isEOF()) {\n                \n            } else {\n                tb.error(this);\n                return false;\n            }\n            return true;\n        }\n    },\n    AfterAfterBody {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().normalName().equals(\"html\"))) {\n                return tb.process(t, InBody);\n            } else if (t.isEOF()) {\n                \n            } else {\n                tb.error(this);\n                tb.transition(InBody);\n                return tb.process(t);\n            }\n            return true;\n        }\n    },\n    AfterAfterFrameset {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().normalName().equals(\"html\"))) {\n                return tb.process(t, InBody);\n            } else if (t.isEOF()) {\n                \n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"noframes\")) {\n                return tb.process(t, InHead);\n            } else {\n                tb.error(this);\n                return false;\n            }\n            return true;\n        }\n    },\n    ForeignContent {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            return true;\n            \n        }\n    };\n\n    private static String nullString = String.valueOf('\\u0000'); abstract boolean process(Token t, HtmlTreeBuilder tb); private static boolean isWhitespace(Token t) {\n        if (t.isCharacter()) {\n            String data = t.asCharacter().getData();\n            return isWhitespace(data);\n        }\n        return false;\n    }\n\n    private static boolean isWhitespace(String data) {\n        return StringUtil.isBlank(data);\n    }\n\n    private static void handleRcData(Token.StartTag startTag, HtmlTreeBuilder tb) {\n        tb.tokeniser.transition(TokeniserState.Rcdata);\n        tb.markInsertionMode();\n        tb.transition(Text);\n        tb.insert(startTag);\n    }\n\n    private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb) {\n        tb.tokeniser.transition(TokeniserState.Rawtext);\n        tb.markInsertionMode();\n        tb.transition(Text);\n        tb.insert(startTag);\n    }\n\n    \n    \n    \n    static final class Constants {\n        static final String[] InBodyStartToHead = new String[]{\"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\"};\n        static final String[] InBodyStartPClosers = new String[]{\"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\",\n            \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n            \"p\", \"section\", \"summary\", \"ul\"};\n        static final String[] Headings = new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"};\n        static final String[] InBodyStartPreListing = new String[]{\"listing\", \"pre\"};\n        static final String[] InBodyStartLiBreakers = new String[]{\"address\", \"div\", \"p\"};\n        static final String[] DdDt = new String[]{\"dd\", \"dt\"};\n        static final String[] Formatters = new String[]{\"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\"};\n        static final String[] InBodyStartApplets = new String[]{\"applet\", \"marquee\", \"object\"};\n        static final String[] InBodyStartEmptyFormatters = new String[]{\"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\"};\n        static final String[] InBodyStartMedia = new String[]{\"param\", \"source\", \"track\"};\n        static final String[] InBodyStartInputAttribs = new String[]{\"action\", \"name\", \"prompt\"};\n        static final String[] InBodyStartOptions = new String[]{\"optgroup\", \"option\"};\n        static final String[] InBodyStartRuby = new String[]{\"rp\", \"rt\"};\n        static final String[] InBodyStartDrop = new String[]{\"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\"};\n        static final String[] InBodyEndClosers = new String[]{\"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\",\n            \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\",\n            \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\"};\n        static final String[] InBodyEndAdoptionFormatters = new String[]{\"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\"};\n        static final String[] InBodyEndTableFosters = new String[]{\"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\"};\n        static final String[] InCellNames = new String[]{\"td\", \"th\"};\n        static final String[] InCellBody = new String[]{\"body\", \"caption\", \"col\", \"colgroup\", \"html\"};\n        static final String[] InCellTable = new String[]{ \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\"};\n        static final String[] InCellCol = new String[]{\"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\"};\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.internal.StringUtil;\nimport org.jsoup.nodes.Attribute;\nimport org.jsoup.nodes.Attributes;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.DocumentType;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.Node;\n\nimport java.util.ArrayList;\n\n\nenum HtmlTreeBuilderState {\n    Initial {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                return true; \n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                \n                \n                Token.Doctype d = t.asDoctype();\n                DocumentType doctype = new DocumentType(\n                    tb.settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier());\n                doctype.setPubSysKey(d.getPubSysKey());\n                tb.getDocument().appendChild(doctype);\n                if (d.isForceQuirks())\n                    tb.getDocument().quirksMode(Document.QuirksMode.quirks);\n                tb.transition(BeforeHtml);\n            } else {\n                \n                tb.transition(BeforeHtml);\n                return tb.process(t); \n            }\n            return true;\n        }\n    },\n    BeforeHtml {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (isWhitespace(t)) {\n                return true; \n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                tb.insert(t.asStartTag());\n                tb.transition(BeforeHead);\n            } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().normalName(), \"head\", \"body\", \"html\", \"br\"))) {\n                return anythingElse(t, tb);\n            } else if (t.isEndTag()) {\n                tb.error(this);\n                return false;\n            } else {\n                return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.insertStartTag(\"html\");\n            tb.transition(BeforeHead);\n            return tb.process(t);\n        }\n    },\n    BeforeHead {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                return true;\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                return InBody.process(t, tb); \n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"head\")) {\n                Element head = tb.insert(t.asStartTag());\n                tb.setHeadElement(head);\n                tb.transition(InHead);\n            } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().normalName(), \"head\", \"body\", \"html\", \"br\"))) {\n                tb.processStartTag(\"head\");\n                return tb.process(t);\n            } else if (t.isEndTag()) {\n                tb.error(this);\n                return false;\n            } else {\n                tb.processStartTag(\"head\");\n                return tb.process(t);\n            }\n            return true;\n        }\n    },\n    InHead {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n                return true;\n            }\n            switch (t.type) {\n                case Comment:\n                    tb.insert(t.asComment());\n                    break;\n                case Doctype:\n                    tb.error(this);\n                    return false;\n                case StartTag:\n                    Token.StartTag start = t.asStartTag();\n                    String name = start.normalName();\n                    if (name.equals(\"html\")) {\n                        return InBody.process(t, tb);\n                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\")) {\n                        Element el = tb.insertEmpty(start);\n                        \n                        if (name.equals(\"base\") && el.hasAttr(\"href\"))\n                            tb.maybeSetBaseUri(el);\n                    } else if (name.equals(\"meta\")) {\n                        Element meta = tb.insertEmpty(start);\n                        \n                    } else if (name.equals(\"title\")) {\n                        handleRcData(start, tb);\n                    } else if (StringUtil.in(name, \"noframes\", \"style\")) {\n                        handleRawtext(start, tb);\n                    } else if (name.equals(\"noscript\")) {\n                        \n                        tb.insert(start);\n                        tb.transition(InHeadNoscript);\n                    } else if (name.equals(\"script\")) {\n                        \n\n                        tb.tokeniser.transition(TokeniserState.ScriptData);\n                        tb.markInsertionMode();\n                        tb.transition(Text);\n                        tb.insert(start);\n                    } else if (name.equals(\"head\")) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        return anythingElse(t, tb);\n                    }\n                    break;\n                case EndTag:\n                    Token.EndTag end = t.asEndTag();\n                    name = end.normalName();\n                    if (name.equals(\"head\")) {\n                        tb.pop();\n                        tb.transition(AfterHead);\n                    } else if (StringUtil.in(name, \"body\", \"html\", \"br\")) {\n                        return anythingElse(t, tb);\n                    } else {\n                        tb.error(this);\n                        return false;\n                    }\n                    break;\n                default:\n                    return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, TreeBuilder tb) {\n            tb.processEndTag(\"head\");\n            return tb.process(t);\n        }\n    },\n    InHeadNoscript {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isDoctype()) {\n                tb.error(this);\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                return tb.process(t, InBody);\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"noscript\")) {\n                tb.pop();\n                tb.transition(InHead);\n            } else if (isWhitespace(t) || t.isComment() || (t.isStartTag() && StringUtil.in(t.asStartTag().normalName(),\n                    \"basefont\", \"bgsound\", \"link\", \"meta\", \"noframes\", \"style\"))) {\n                return tb.process(t, InHead);\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"br\")) {\n                return anythingElse(t, tb);\n            } else if ((t.isStartTag() && StringUtil.in(t.asStartTag().normalName(), \"head\", \"noscript\")) || t.isEndTag()) {\n                tb.error(this);\n                return false;\n            } else {\n                return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.error(this);\n            tb.insert(new Token.Character().data(t.toString()));\n            return true;\n        }\n    },\n    AfterHead {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                tb.error(this);\n            } else if (t.isStartTag()) {\n                Token.StartTag startTag = t.asStartTag();\n                String name = startTag.normalName();\n                if (name.equals(\"html\")) {\n                    return tb.process(t, InBody);\n                } else if (name.equals(\"body\")) {\n                    tb.insert(startTag);\n                    tb.framesetOk(false);\n                    tb.transition(InBody);\n                } else if (name.equals(\"frameset\")) {\n                    tb.insert(startTag);\n                    tb.transition(InFrameset);\n                } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                    tb.error(this);\n                    Element head = tb.getHeadElement();\n                    tb.push(head);\n                    tb.process(t, InHead);\n                    tb.removeFromStack(head);\n                } else if (name.equals(\"head\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    anythingElse(t, tb);\n                }\n            } else if (t.isEndTag()) {\n                if (StringUtil.in(t.asEndTag().normalName(), \"body\", \"html\")) {\n                    anythingElse(t, tb);\n                } else {\n                    tb.error(this);\n                    return false;\n                }\n            } else {\n                anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.processStartTag(\"body\");\n            tb.framesetOk(true);\n            return tb.process(t);\n        }\n    },\n    InBody {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character: {\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        \n                        tb.error(this);\n                        return false;\n                    } else if (tb.framesetOk() && isWhitespace(c)) { \n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    \n                    String name = startTag.normalName();\n                    if (name.equals(\"a\")) {\n                        if (tb.getActiveFormattingElement(\"a\") != null) {\n                            tb.error(this);\n                            tb.processEndTag(\"a\");\n\n                            \n                            Element remainingA = tb.getFromStack(\"a\");\n                            if (remainingA != null) {\n                                tb.removeFromActiveFormattingElements(remainingA);\n                                tb.removeFromStack(remainingA);\n                            }\n                        }\n                        tb.reconstructFormattingElements();\n                        Element a = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(a);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n                        tb.reconstructFormattingElements();\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"span\")) {\n                        \n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (name.equals(\"li\")) {\n                        tb.framesetOk(false);\n                        ArrayList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (el.normalName().equals(\"li\")) {\n                                tb.processEndTag(\"li\");\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.normalName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"html\")) {\n                        tb.error(this);\n                        \n                        Element html = tb.getStack().get(0);\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        ArrayList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).normalName().equals(\"body\"))) {\n                            \n                            return false; \n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        ArrayList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).normalName().equals(\"body\"))) {\n                            \n                            return false; \n                        } else if (!tb.framesetOk()) {\n                            return false; \n                        } else {\n                            Element second = stack.get(1);\n                            if (second.parent() != null)\n                                second.remove();\n                            \n                            while (stack.size() > 1)\n                                stack.remove(stack.size()-1);\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        if (StringUtil.inSorted(tb.currentElement().normalName(), Constants.Headings)) {\n                            tb.error(this);\n                            tb.pop();\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.reader.matchConsume(\"\\n\"); \n                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null) {\n                            tb.error(this);\n                            return false;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insertForm(startTag, true);\n                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                        tb.framesetOk(false);\n                        ArrayList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (StringUtil.inSorted(el.normalName(), Constants.DdDt)) {\n                                tb.processEndTag(el.normalName());\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.normalName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"plaintext\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); \n                    } else if (name.equals(\"button\")) {\n                        if (tb.inButtonScope(\"button\")) {\n                            \n                            tb.error(this);\n                            tb.processEndTag(\"button\");\n                            tb.process(startTag);\n                        } else {\n                            tb.reconstructFormattingElements();\n                            tb.insert(startTag);\n                            tb.framesetOk(false);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Formatters)) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (name.equals(\"nobr\")) {\n                        tb.reconstructFormattingElements();\n                        if (tb.inScope(\"nobr\")) {\n                            tb.error(this);\n                            tb.processEndTag(\"nobr\");\n                            tb.reconstructFormattingElements();\n                        }\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.insertMarkerToFormattingElements();\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"table\")) {\n                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        tb.transition(InTable);\n                    } else if (name.equals(\"input\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insertEmpty(startTag);\n                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                            tb.framesetOk(false);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n                        tb.insertEmpty(startTag);\n                    } else if (name.equals(\"hr\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"image\")) {\n                        if (tb.getFromStack(\"svg\") == null)\n                            return tb.process(startTag.name(\"img\")); \n                        else\n                            tb.insert(startTag);\n                    } else if (name.equals(\"isindex\")) {\n                        \n                        tb.error(this);\n                        if (tb.getFormElement() != null)\n                            return false;\n\n                        tb.processStartTag(\"form\");\n                        if (startTag.attributes.hasKey(\"action\")) {\n                            Element form = tb.getFormElement();\n                            form.attr(\"action\", startTag.attributes.get(\"action\"));\n                        }\n                        tb.processStartTag(\"hr\");\n                        tb.processStartTag(\"label\");\n                        \n                        String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                                startTag.attributes.get(\"prompt\") :\n                                \"This is a searchable index. Enter search keywords: \";\n\n                        tb.process(new Token.Character().data(prompt));\n\n                        \n                        Attributes inputAttribs = new Attributes();\n                        for (Attribute attr : startTag.attributes) {\n                            if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n                                inputAttribs.put(attr);\n                        }\n                        inputAttribs.put(\"name\", \"isindex\");\n                        tb.processStartTag(\"input\", inputAttribs);\n                        tb.processEndTag(\"label\");\n                        tb.processStartTag(\"hr\");\n                        tb.processEndTag(\"form\");\n                    } else if (name.equals(\"textarea\")) {\n                        tb.insert(startTag);\n                        \n                        tb.tokeniser.transition(TokeniserState.Rcdata);\n                        tb.markInsertionMode();\n                        tb.framesetOk(false);\n                        tb.transition(Text);\n                    } else if (name.equals(\"xmp\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.reconstructFormattingElements();\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"iframe\")) {\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"noembed\")) {\n                        \n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"select\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n\n                        HtmlTreeBuilderState state = tb.state();\n                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                            tb.transition(InSelectInTable);\n                        else\n                            tb.transition(InSelect);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n                        if (tb.currentElement().normalName().equals(\"option\"))\n                            tb.processEndTag(\"option\");\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n                        if (tb.inScope(\"ruby\")) {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().normalName().equals(\"ruby\")) {\n                                tb.error(this);\n                                tb.popStackToBefore(\"ruby\"); \n                            }\n                            tb.insert(startTag);\n                        }\n                    } else if (name.equals(\"math\")) {\n                        tb.reconstructFormattingElements();\n                        \n                        tb.insert(startTag);\n                    } else if (name.equals(\"svg\")) {\n                        tb.reconstructFormattingElements();\n                        \n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    }\n                    break;\n\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.normalName();\n                    if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n                        \n                        for (int i = 0; i < 8; i++) {\n                            Element formatEl = tb.getActiveFormattingElement(name);\n                            if (formatEl == null)\n                                return anyOtherEndTag(t, tb);\n                            else if (!tb.onStack(formatEl)) {\n                                tb.error(this);\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            } else if (!tb.inScope(formatEl.normalName())) {\n                                tb.error(this);\n                                return false;\n                            } else if (tb.currentElement() != formatEl)\n                                tb.error(this);\n\n                            Element furthestBlock = null;\n                            Element commonAncestor = null;\n                            boolean seenFormattingElement = false;\n                            ArrayList<Element> stack = tb.getStack();\n                            \n                            \n                            final int stackSize = stack.size();\n                            for (int si = 0; si < stackSize && si < 64; si++) {\n                                Element el = stack.get(si);\n                                if (el == formatEl) {\n                                    commonAncestor = stack.get(si - 1);\n                                    seenFormattingElement = true;\n                                } else if (seenFormattingElement && tb.isSpecial(el)) {\n                                    furthestBlock = el;\n                                    break;\n                                }\n                            }\n                            if (furthestBlock == null) {\n                                tb.popStackToClose(formatEl.normalName());\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            }\n\n                            \n                            \n                            Element node = furthestBlock;\n                            Element lastNode = furthestBlock;\n                            for (int j = 0; j < 3; j++) {\n                                if (tb.onStack(node))\n                                    node = tb.aboveOnStack(node);\n                                if (!tb.isInActiveFormattingElements(node)) { \n                                    tb.removeFromStack(node);\n                                    continue;\n                                } else if (node == formatEl)\n                                    break;\n\n                                Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n                                \n                                tb.replaceActiveFormattingElement(node, replacement);\n                                tb.replaceOnStack(node, replacement);\n                                node = replacement;\n\n                                if (lastNode == furthestBlock) {\n                                    \n                                    \n                                }\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                node.appendChild(lastNode);\n\n                                lastNode = node;\n                            }\n\n                            if (StringUtil.inSorted(commonAncestor.normalName(), Constants.InBodyEndTableFosters)) {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                tb.insertInFosterParent(lastNode);\n                            } else {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                commonAncestor.appendChild(lastNode);\n                            }\n\n                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                            adopter.attributes().addAll(formatEl.attributes());\n                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                            for (Node childNode : childNodes) {\n                                adopter.appendChild(childNode); \n                            }\n                            furthestBlock.appendChild(adopter);\n                            tb.removeFromActiveFormattingElements(formatEl);\n                            \n                            tb.removeFromStack(formatEl);\n                            tb.insertOnStackAfter(furthestBlock, adopter);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n                        if (!tb.inScope(name)) {\n                            \n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().normalName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"span\")) {\n                        \n                        return anyOtherEndTag(t, tb);\n                    } else if (name.equals(\"li\")) {\n                        if (!tb.inListItemScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().normalName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"body\")) {\n                        if (!tb.inScope(\"body\")) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            \n                            tb.transition(AfterBody);\n                        }\n                    } else if (name.equals(\"html\")) {\n                        boolean notIgnored = tb.processEndTag(\"body\");\n                        if (notIgnored)\n                            return tb.process(endTag);\n                    } else if (name.equals(\"form\")) {\n                        Element currentForm = tb.getFormElement();\n                        tb.setFormElement(null);\n                        if (currentForm == null || !tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().normalName().equals(name))\n                                tb.error(this);\n                            \n                            tb.removeFromStack(currentForm);\n                        }\n                    } else if (name.equals(\"p\")) {\n                        if (!tb.inButtonScope(name)) {\n                            tb.error(this);\n                            tb.processStartTag(name); \n                            return tb.process(endTag);\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().normalName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                        if (!tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().normalName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                        if (!tb.inScope(Constants.Headings)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().normalName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(Constants.Headings);\n                        }\n                    } else if (name.equals(\"sarcasm\")) {\n                        \n                        return anyOtherEndTag(t, tb);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                        if (!tb.inScope(\"name\")) {\n                            if (!tb.inScope(name)) {\n                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().normalName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker();\n                        }\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.processStartTag(\"br\");\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n\n                    break;\n                case EOF:\n                    \n                    \n                    break;\n            }\n            return true;\n        }\n\n        boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n            String name = t.asEndTag().normalName; \n            ArrayList<Element> stack = tb.getStack();\n            for (int pos = stack.size() -1; pos >= 0; pos--) {\n                Element node = stack.get(pos);\n                if (node.normalName().equals(name)) {\n                    tb.generateImpliedEndTags(name);\n                    if (!name.equals(tb.currentElement().normalName()))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    break;\n                } else {\n                    if (tb.isSpecial(node)) {\n                        tb.error(this);\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    Text {\n        \n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isCharacter()) {\n                tb.insert(t.asCharacter());\n            } else if (t.isEOF()) {\n                tb.error(this);\n                \n                tb.pop();\n                tb.transition(tb.originalState());\n                return tb.process(t);\n            } else if (t.isEndTag()) {\n                \n                tb.pop();\n                tb.transition(tb.originalState());\n            }\n            return true;\n        }\n    },\n    InTable {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isCharacter()) {\n                tb.newPendingTableCharacters();\n                tb.markInsertionMode();\n                tb.transition(InTableText);\n                return tb.process(t);\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n                return true;\n            } else if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isStartTag()) {\n                Token.StartTag startTag = t.asStartTag();\n                String name = startTag.normalName();\n                if (name.equals(\"caption\")) {\n                    tb.clearStackToTableContext();\n                    tb.insertMarkerToFormattingElements();\n                    tb.insert(startTag);\n                    tb.transition(InCaption);\n                } else if (name.equals(\"colgroup\")) {\n                    tb.clearStackToTableContext();\n                    tb.insert(startTag);\n                    tb.transition(InColumnGroup);\n                } else if (name.equals(\"col\")) {\n                    tb.processStartTag(\"colgroup\");\n                    return tb.process(t);\n                } else if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n                    tb.clearStackToTableContext();\n                    tb.insert(startTag);\n                    tb.transition(InTableBody);\n                } else if (StringUtil.in(name, \"td\", \"th\", \"tr\")) {\n                    tb.processStartTag(\"tbody\");\n                    return tb.process(t);\n                } else if (name.equals(\"table\")) {\n                    tb.error(this);\n                    boolean processed = tb.processEndTag(\"table\");\n                    if (processed) \n                        return tb.process(t);\n                } else if (StringUtil.in(name, \"style\", \"script\")) {\n                    return tb.process(t, InHead);\n                } else if (name.equals(\"input\")) {\n                    if (!startTag.attributes.get(\"type\").equalsIgnoreCase(\"hidden\")) {\n                        return anythingElse(t, tb);\n                    } else {\n                        tb.insertEmpty(startTag);\n                    }\n                } else if (name.equals(\"form\")) {\n                    tb.error(this);\n                    if (tb.getFormElement() != null)\n                        return false;\n                    else {\n                        tb.insertForm(startTag, false);\n                    }\n                } else {\n                    return anythingElse(t, tb);\n                }\n                return true; \n            } else if (t.isEndTag()) {\n                Token.EndTag endTag = t.asEndTag();\n                String name = endTag.normalName();\n\n                if (name.equals(\"table\")) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.popStackToClose(\"table\");\n                    }\n                    tb.resetInsertionMode();\n                } else if (StringUtil.in(name,\n                        \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    return anythingElse(t, tb);\n                }\n                return true; \n            } else if (t.isEOF()) {\n                if (tb.currentElement().normalName().equals(\"html\"))\n                    tb.error(this);\n                return true; \n            }\n            return anythingElse(t, tb);\n        }\n\n        boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.error(this);\n            boolean processed;\n            if (StringUtil.in(tb.currentElement().normalName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                tb.setFosterInserts(true);\n                processed = tb.process(t, InBody);\n                tb.setFosterInserts(false);\n            } else {\n                processed = tb.process(t, InBody);\n            }\n            return processed;\n        }\n    },\n    InTableText {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character:\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.getPendingTableCharacters().add(c.getData());\n                    }\n                    break;\n                default:\n                    \n                    if (tb.getPendingTableCharacters().size() > 0) {\n                        for (String character : tb.getPendingTableCharacters()) {\n                            if (!isWhitespace(character)) {\n                                \n                                tb.error(this);\n                                if (StringUtil.in(tb.currentElement().normalName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                                    tb.setFosterInserts(true);\n                                    tb.process(new Token.Character().data(character), InBody);\n                                    tb.setFosterInserts(false);\n                                } else {\n                                    tb.process(new Token.Character().data(character), InBody);\n                                }\n                            } else\n                                tb.insert(new Token.Character().data(character));\n                        }\n                        tb.newPendingTableCharacters();\n                    }\n                    tb.transition(tb.originalState());\n                    return tb.process(t);\n            }\n            return true;\n        }\n    },\n    InCaption {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isEndTag() && t.asEndTag().normalName().equals(\"caption\")) {\n                Token.EndTag endTag = t.asEndTag();\n                String name = endTag.normalName();\n                if (!tb.inTableScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().normalName().equals(\"caption\"))\n                        tb.error(this);\n                    tb.popStackToClose(\"caption\");\n                    tb.clearFormattingElementsToLastMarker();\n                    tb.transition(InTable);\n                }\n            } else if ((\n                    t.isStartTag() && StringUtil.in(t.asStartTag().normalName(),\n                            \"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\") ||\n                            t.isEndTag() && t.asEndTag().normalName().equals(\"table\"))\n                    ) {\n                tb.error(this);\n                boolean processed = tb.processEndTag(\"caption\");\n                if (processed)\n                    return tb.process(t);\n            } else if (t.isEndTag() && StringUtil.in(t.asEndTag().normalName(),\n                    \"body\", \"col\", \"colgroup\", \"html\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                tb.error(this);\n                return false;\n            } else {\n                return tb.process(t, InBody);\n            }\n            return true;\n        }\n    },\n    InColumnGroup {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n                return true;\n            }\n            switch (t.type) {\n                case Comment:\n                    tb.insert(t.asComment());\n                    break;\n                case Doctype:\n                    tb.error(this);\n                    break;\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    switch (startTag.normalName()) {\n                        case \"html\":\n                            return tb.process(t, InBody);\n                        case \"col\":\n                            tb.insertEmpty(startTag);\n                            break;\n                        default:\n                            return anythingElse(t, tb);\n                    }\n                    break;\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    if (endTag.normalName.equals(\"colgroup\")) {\n                        if (tb.currentElement().normalName().equals(\"html\")) { \n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.pop();\n                            tb.transition(InTable);\n                        }\n                    } else\n                        return anythingElse(t, tb);\n                    break;\n                case EOF:\n                    if (tb.currentElement().normalName().equals(\"html\"))\n                        return true; \n                    else\n                        return anythingElse(t, tb);\n                default:\n                    return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, TreeBuilder tb) {\n            boolean processed = tb.processEndTag(\"colgroup\");\n            if (processed) \n                return tb.process(t);\n            return true;\n        }\n    },\n    InTableBody {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.normalName();\n                    if (name.equals(\"template\")) {\n                        tb.insert(startTag);\n                    } else if (name.equals(\"tr\")) {\n                        tb.clearStackToTableBodyContext();\n                        tb.insert(startTag);\n                        tb.transition(InRow);\n                    } else if (StringUtil.in(name, \"th\", \"td\")) {\n                        tb.error(this);\n                        tb.processStartTag(\"tr\");\n                        return tb.process(startTag);\n                    } else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\")) {\n                        return exitTableBody(t, tb);\n                    } else\n                        return anythingElse(t, tb);\n                    break;\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.normalName();\n                    if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n                        if (!tb.inTableScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.clearStackToTableBodyContext();\n                            tb.pop();\n                            tb.transition(InTable);\n                        }\n                    } else if (name.equals(\"table\")) {\n                        return exitTableBody(t, tb);\n                    } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\", \"tr\")) {\n                        tb.error(this);\n                        return false;\n                    } else\n                        return anythingElse(t, tb);\n                    break;\n                default:\n                    return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean exitTableBody(Token t, HtmlTreeBuilder tb) {\n            if (!(tb.inTableScope(\"tbody\") || tb.inTableScope(\"thead\") || tb.inScope(\"tfoot\"))) {\n                \n                tb.error(this);\n                return false;\n            }\n            tb.clearStackToTableBodyContext();\n            tb.processEndTag(tb.currentElement().normalName()); \n            return tb.process(t);\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            return tb.process(t, InTable);\n        }\n    },\n    InRow {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isStartTag()) {\n                Token.StartTag startTag = t.asStartTag();\n                String name = startTag.normalName();\n\n                if (name.equals(\"template\")) {\n                    tb.insert(startTag);\n                } else if (StringUtil.in(name, \"th\", \"td\")) {\n                    tb.clearStackToTableRowContext();\n                    tb.insert(startTag);\n                    tb.transition(InCell);\n                    tb.insertMarkerToFormattingElements();\n                } else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                    return handleMissingTr(t, tb);\n                } else {\n                    return anythingElse(t, tb);\n                }\n            } else if (t.isEndTag()) {\n                Token.EndTag endTag = t.asEndTag();\n                String name = endTag.normalName();\n\n                if (name.equals(\"tr\")) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this); \n                        return false;\n                    }\n                    tb.clearStackToTableRowContext();\n                    tb.pop(); \n                    tb.transition(InTableBody);\n                } else if (name.equals(\"table\")) {\n                    return handleMissingTr(t, tb);\n                } else if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this);\n                        return false;\n                    }\n                    tb.processEndTag(\"tr\");\n                    return tb.process(t);\n                } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    return anythingElse(t, tb);\n                }\n            } else {\n                return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            return tb.process(t, InTable);\n        }\n\n        private boolean handleMissingTr(Token t, TreeBuilder tb) {\n            boolean processed = tb.processEndTag(\"tr\");\n            if (processed)\n                return tb.process(t);\n            else\n                return false;\n        }\n    },\n    InCell {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isEndTag()) {\n                Token.EndTag endTag = t.asEndTag();\n                String name = endTag.normalName();\n\n                if (StringUtil.inSorted(name, Constants.InCellNames)) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this);\n                        tb.transition(InRow); \n                        return false;\n                    }\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().normalName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    tb.clearFormattingElementsToLastMarker();\n                    tb.transition(InRow);\n                } else if (StringUtil.inSorted(name, Constants.InCellBody)) {\n                    tb.error(this);\n                    return false;\n                } else if (StringUtil.inSorted(name, Constants.InCellTable)) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this);\n                        return false;\n                    }\n                    closeCell(tb);\n                    return tb.process(t);\n                } else {\n                    return anythingElse(t, tb);\n                }\n            } else if (t.isStartTag() &&\n                    StringUtil.inSorted(t.asStartTag().normalName(), Constants.InCellCol)) {\n                if (!(tb.inTableScope(\"td\") || tb.inTableScope(\"th\"))) {\n                    tb.error(this);\n                    return false;\n                }\n                closeCell(tb);\n                return tb.process(t);\n            } else {\n                return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            return tb.process(t, InBody);\n        }\n\n        private void closeCell(HtmlTreeBuilder tb) {\n            if (tb.inTableScope(\"td\"))\n                tb.processEndTag(\"td\");\n            else\n                tb.processEndTag(\"th\"); \n        }\n    },\n    InSelect {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character:\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.insert(c);\n                    }\n                    break;\n                case Comment:\n                    tb.insert(t.asComment());\n                    break;\n                case Doctype:\n                    tb.error(this);\n                    return false;\n                case StartTag:\n                    Token.StartTag start = t.asStartTag();\n                    String name = start.normalName();\n                    if (name.equals(\"html\"))\n                        return tb.process(start, InBody);\n                    else if (name.equals(\"option\")) {\n                        if (tb.currentElement().normalName().equals(\"option\"))\n                            tb.processEndTag(\"option\");\n                        tb.insert(start);\n                    } else if (name.equals(\"optgroup\")) {\n                        if (tb.currentElement().normalName().equals(\"option\"))\n                            tb.processEndTag(\"option\");\n                        else if (tb.currentElement().normalName().equals(\"optgroup\"))\n                            tb.processEndTag(\"optgroup\");\n                        tb.insert(start);\n                    } else if (name.equals(\"select\")) {\n                        tb.error(this);\n                        return tb.processEndTag(\"select\");\n                    } else if (StringUtil.in(name, \"input\", \"keygen\", \"textarea\")) {\n                        tb.error(this);\n                        if (!tb.inSelectScope(\"select\"))\n                            return false; \n                        tb.processEndTag(\"select\");\n                        return tb.process(start);\n                    } else if (name.equals(\"script\")) {\n                        return tb.process(t, InHead);\n                    } else {\n                        return anythingElse(t, tb);\n                    }\n                    break;\n                case EndTag:\n                    Token.EndTag end = t.asEndTag();\n                    name = end.normalName();\n                    switch (name) {\n                        case \"optgroup\":\n                            if (tb.currentElement().normalName().equals(\"option\") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).normalName().equals(\"optgroup\"))\n                                tb.processEndTag(\"option\");\n                            if (tb.currentElement().normalName().equals(\"optgroup\"))\n                                tb.pop();\n                            else\n                                tb.error(this);\n                            break;\n                        case \"option\":\n                            if (tb.currentElement().normalName().equals(\"option\"))\n                                tb.pop();\n                            else\n                                tb.error(this);\n                            break;\n                        case \"select\":\n                            if (!tb.inSelectScope(name)) {\n                                tb.error(this);\n                                return false;\n                            } else {\n                                tb.popStackToClose(name);\n                                tb.resetInsertionMode();\n                            }\n                            break;\n                        default:\n                            return anythingElse(t, tb);\n                    }\n                    break;\n                case EOF:\n                    if (!tb.currentElement().normalName().equals(\"html\"))\n                        tb.error(this);\n                    break;\n                default:\n                    return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.error(this);\n            return false;\n        }\n    },\n    InSelectInTable {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isStartTag() && StringUtil.in(t.asStartTag().normalName(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n                tb.error(this);\n                tb.processEndTag(\"select\");\n                return tb.process(t);\n            } else if (t.isEndTag() && StringUtil.in(t.asEndTag().normalName(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n                tb.error(this);\n                if (tb.inTableScope(t.asEndTag().normalName())) {\n                    tb.processEndTag(\"select\");\n                    return (tb.process(t));\n                } else\n                    return false;\n            } else {\n                return tb.process(t, InSelect);\n            }\n        }\n    },\n    AfterBody {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                return tb.process(t, InBody);\n            } else if (t.isComment()) {\n                tb.insert(t.asComment()); \n            } else if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                return tb.process(t, InBody);\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"html\")) {\n                if (tb.isFragmentParsing()) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.transition(AfterAfterBody);\n                }\n            } else if (t.isEOF()) {\n                \n            } else {\n                tb.error(this);\n                tb.transition(InBody);\n                return tb.process(t);\n            }\n            return true;\n        }\n    },\n    InFrameset {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isStartTag()) {\n                Token.StartTag start = t.asStartTag();\n                switch (start.normalName()) {\n                    case \"html\":\n                        return tb.process(start, InBody);\n                    case \"frameset\":\n                        tb.insert(start);\n                        break;\n                    case \"frame\":\n                        tb.insertEmpty(start);\n                        break;\n                    case \"noframes\":\n                        return tb.process(start, InHead);\n                    default:\n                        tb.error(this);\n                        return false;\n                }\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"frameset\")) {\n                if (tb.currentElement().normalName().equals(\"html\")) { \n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.pop();\n                    if (!tb.isFragmentParsing() && !tb.currentElement().normalName().equals(\"frameset\")) {\n                        tb.transition(AfterFrameset);\n                    }\n                }\n            } else if (t.isEOF()) {\n                if (!tb.currentElement().normalName().equals(\"html\")) {\n                    tb.error(this);\n                    return true;\n                }\n            } else {\n                tb.error(this);\n                return false;\n            }\n            return true;\n        }\n    },\n    AfterFrameset {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                return tb.process(t, InBody);\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"html\")) {\n                tb.transition(AfterAfterFrameset);\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"noframes\")) {\n                return tb.process(t, InHead);\n            } else if (t.isEOF()) {\n                \n            } else {\n                tb.error(this);\n                return false;\n            }\n            return true;\n        }\n    },\n    AfterAfterBody {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().normalName().equals(\"html\"))) {\n                return tb.process(t, InBody);\n            } else if (t.isEOF()) {\n                \n            } else {\n                tb.error(this);\n                tb.transition(InBody);\n                return tb.process(t);\n            }\n            return true;\n        }\n    },\n    AfterAfterFrameset {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().normalName().equals(\"html\"))) {\n                return tb.process(t, InBody);\n            } else if (t.isEOF()) {\n                \n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"noframes\")) {\n                return tb.process(t, InHead);\n            } else {\n                tb.error(this);\n                return false;\n            }\n            return true;\n        }\n    },\n    ForeignContent {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            return true;\n            \n        }\n    };\n\n    private static String nullString = String.valueOf('\\u0000'); abstract boolean process(Token t, HtmlTreeBuilder tb); private static boolean isWhitespace(Token t) {\n        if (t.isCharacter()) {\n            String data = t.asCharacter().getData();\n            return isWhitespace(data);\n        }\n        return false;\n    }\n\n    private static boolean isWhitespace(String data) {\n        return StringUtil.isBlank(data);\n    }\n\n    private static void handleRcData(Token.StartTag startTag, HtmlTreeBuilder tb) {\n        tb.tokeniser.transition(TokeniserState.Rcdata);\n        tb.markInsertionMode();\n        tb.transition(Text);\n        tb.insert(startTag);\n    }\n\n    private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb) {\n        tb.tokeniser.transition(TokeniserState.Rawtext);\n        tb.markInsertionMode();\n        tb.transition(Text);\n        tb.insert(startTag);\n    }\n\n    \n    \n    \n    static final class Constants {\n        static final String[] InBodyStartToHead = new String[]{\"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\"};\n        static final String[] InBodyStartPClosers = new String[]{\"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\",\n            \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n            \"p\", \"section\", \"summary\", \"ul\"};\n        static final String[] Headings = new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"};\n        static final String[] InBodyStartPreListing = new String[]{\"listing\", \"pre\"};\n        static final String[] InBodyStartLiBreakers = new String[]{\"address\", \"div\", \"p\"};\n        static final String[] DdDt = new String[]{\"dd\", \"dt\"};\n        static final String[] Formatters = new String[]{\"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\"};\n        static final String[] InBodyStartApplets = new String[]{\"applet\", \"marquee\", \"object\"};\n        static final String[] InBodyStartEmptyFormatters = new String[]{\"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\"};\n        static final String[] InBodyStartMedia = new String[]{\"param\", \"source\", \"track\"};\n        static final String[] InBodyStartInputAttribs = new String[]{\"action\", \"name\", \"prompt\"};\n        static final String[] InBodyStartOptions = new String[]{\"optgroup\", \"option\"};\n        static final String[] InBodyStartRuby = new String[]{\"rp\", \"rt\"};\n        static final String[] InBodyStartDrop = new String[]{\"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\"};\n        static final String[] InBodyEndClosers = new String[]{\"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\",\n            \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\",\n            \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\"};\n        static final String[] InBodyEndAdoptionFormatters = new String[]{\"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\"};\n        static final String[] InBodyEndTableFosters = new String[]{\"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\"};\n        static final String[] InCellNames = new String[]{\"td\", \"th\"};\n        static final String[] InCellBody = new String[]{\"body\", \"caption\", \"col\", \"colgroup\", \"html\"};\n        static final String[] InCellTable = new String[]{ \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\"};\n        static final String[] InCellCol = new String[]{\"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\"};\n    }\n}\n",
      "buggy_signatures": [
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private boolean anythingElse(Token t, TreeBuilder tb)",
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private boolean anythingElse(Token t, TreeBuilder tb)",
        "private boolean exitTableBody(Token t, HtmlTreeBuilder tb)",
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private boolean handleMissingTr(Token t, TreeBuilder tb)",
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private void closeCell(HtmlTreeBuilder tb)",
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private static boolean isWhitespace(String data)",
        "private static void handleRcData(Token.StartTag startTag, HtmlTreeBuilder tb)",
        "private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb)"
      ],
      "fixed_signatures": [
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private boolean anythingElse(Token t, TreeBuilder tb)",
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private boolean anythingElse(Token t, TreeBuilder tb)",
        "private boolean exitTableBody(Token t, HtmlTreeBuilder tb)",
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private boolean handleMissingTr(Token t, TreeBuilder tb)",
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private void closeCell(HtmlTreeBuilder tb)",
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private static boolean isWhitespace(String data)",
        "private static void handleRcData(Token.StartTag startTag, HtmlTreeBuilder tb)",
        "private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb)"
      ],
      "methods": [
        {
          "buggy_method": "  private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n  tb.processStartTag(\"body\");\n  tb.framesetOk(true);\n  return tb.process(t);\n  }",
          "fixed_method": "  private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n  tb.processStartTag(\"body\");\n  tb.framesetOk(true);\n  return tb.process(t);\n  }",
          "diff": [
            "@@ -312,11 +312,11 @@",
            "                         ArrayList<Element> stack = tb.getStack();\n",
            "                         for (int i = stack.size() - 1; i > 0; i--) {\n",
            "                             Element el = stack.get(i);\n",
            "-                            if (el.nodeName().equals(\"li\")) {\n",
            "+                            if (el.normalName().equals(\"li\")) {\n",
            "                                 tb.processEndTag(\"li\");\n",
            "                                 break;\n",
            "                             }\n",
            "-                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n",
            "+                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.normalName(), Constants.InBodyStartLiBreakers))\n",
            "                                 break;\n",
            "                         }\n",
            "                         if (tb.inButtonScope(\"p\")) {\n",
            "@@ -336,7 +336,7 @@",
            "                     } else if (name.equals(\"body\")) {\n",
            "                         tb.error(this);\n",
            "                         ArrayList<Element> stack = tb.getStack();\n",
            "-                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
            "+                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).normalName().equals(\"body\"))) {\n",
            "                             // only in fragment case\n",
            "                             return false; // ignore\n",
            "                         } else {\n",
            "@@ -350,7 +350,7 @@",
            "                     } else if (name.equals(\"frameset\")) {\n",
            "                         tb.error(this);\n",
            "                         ArrayList<Element> stack = tb.getStack();\n",
            "-                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
            "+                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).normalName().equals(\"body\"))) {\n",
            "                             // only in fragment case\n",
            "                             return false; // ignore\n",
            "                         } else if (!tb.framesetOk()) {\n",
            "@@ -369,7 +369,7 @@",
            "                         if (tb.inButtonScope(\"p\")) {\n",
            "                             tb.processEndTag(\"p\");\n",
            "                         }\n",
            "-                        if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n",
            "+                        if (StringUtil.inSorted(tb.currentElement().normalName(), Constants.Headings)) {\n",
            "                             tb.error(this);\n",
            "                             tb.pop();\n",
            "                         }\n",
            "@@ -395,11 +395,11 @@",
            "                         ArrayList<Element> stack = tb.getStack();\n",
            "                         for (int i = stack.size() - 1; i > 0; i--) {\n",
            "                             Element el = stack.get(i);\n",
            "-                            if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n",
            "-                                tb.processEndTag(el.nodeName());\n",
            "+                            if (StringUtil.inSorted(el.normalName(), Constants.DdDt)) {\n",
            "+                                tb.processEndTag(el.normalName());\n",
            "                                 break;\n",
            "                             }\n",
            "-                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n",
            "+                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.normalName(), Constants.InBodyStartLiBreakers))\n",
            "                                 break;\n",
            "                         }\n",
            "                         if (tb.inButtonScope(\"p\")) {\n",
            "@@ -528,14 +528,14 @@",
            "                         else\n",
            "                             tb.transition(InSelect);\n",
            "                     } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n",
            "-                        if (tb.currentElement().nodeName().equals(\"option\"))\n",
            "+                        if (tb.currentElement().normalName().equals(\"option\"))\n",
            "                             tb.processEndTag(\"option\");\n",
            "                         tb.reconstructFormattingElements();\n",
            "                         tb.insert(startTag);\n",
            "                     } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n",
            "                         if (tb.inScope(\"ruby\")) {\n",
            "                             tb.generateImpliedEndTags();\n",
            "-                            if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n",
            "+                            if (!tb.currentElement().normalName().equals(\"ruby\")) {\n",
            "                                 tb.error(this);\n",
            "                                 tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n",
            "                             }\n",
            "@@ -571,7 +571,7 @@",
            "                                 tb.error(this);\n",
            "                                 tb.removeFromActiveFormattingElements(formatEl);\n",
            "                                 return true;\n",
            "-                            } else if (!tb.inScope(formatEl.nodeName())) {\n",
            "+                            } else if (!tb.inScope(formatEl.normalName())) {\n",
            "                                 tb.error(this);\n",
            "                                 return false;\n",
            "                             } else if (tb.currentElement() != formatEl)\n",
            "@@ -595,7 +595,7 @@",
            "                                 }\n",
            "                             }\n",
            "                             if (furthestBlock == null) {\n",
            "-                                tb.popStackToClose(formatEl.nodeName());\n",
            "+                                tb.popStackToClose(formatEl.normalName());\n",
            "                                 tb.removeFromActiveFormattingElements(formatEl);\n",
            "                                 return true;\n",
            "                             }\n",
            "@@ -630,7 +630,7 @@",
            "                                 lastNode = node;\n",
            "                             }\n",
            " \n",
            "-                            if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n",
            "+                            if (StringUtil.inSorted(commonAncestor.normalName(), Constants.InBodyEndTableFosters)) {\n",
            "                                 if (lastNode.parent() != null)\n",
            "                                     lastNode.remove();\n",
            "                                 tb.insertInFosterParent(lastNode);\n",
            "@@ -659,7 +659,7 @@",
            "                             return false;\n",
            "                         } else {\n",
            "                             tb.generateImpliedEndTags();\n",
            "-                            if (!tb.currentElement().nodeName().equals(name))\n",
            "+                            if (!tb.currentElement().normalName().equals(name))\n",
            "                                 tb.error(this);\n",
            "                             tb.popStackToClose(name);\n",
            "                         }\n",
            "@@ -672,7 +672,7 @@",
            "                             return false;\n",
            "                         } else {\n",
            "                             tb.generateImpliedEndTags(name);\n",
            "-                            if (!tb.currentElement().nodeName().equals(name))\n",
            "+                            if (!tb.currentElement().normalName().equals(name))\n",
            "                                 tb.error(this);\n",
            "                             tb.popStackToClose(name);\n",
            "                         }\n",
            "@@ -696,7 +696,7 @@",
            "                             return false;\n",
            "                         } else {\n",
            "                             tb.generateImpliedEndTags();\n",
            "-                            if (!tb.currentElement().nodeName().equals(name))\n",
            "+                            if (!tb.currentElement().normalName().equals(name))\n",
            "                                 tb.error(this);\n",
            "                             // remove currentForm from stack. will shift anything under up.\n",
            "                             tb.removeFromStack(currentForm);\n",
            "@@ -708,7 +708,7 @@",
            "                             return tb.process(endTag);\n",
            "                         } else {\n",
            "                             tb.generateImpliedEndTags(name);\n",
            "-                            if (!tb.currentElement().nodeName().equals(name))\n",
            "+                            if (!tb.currentElement().normalName().equals(name))\n",
            "                                 tb.error(this);\n",
            "                             tb.popStackToClose(name);\n",
            "                         }\n",
            "@@ -718,7 +718,7 @@",
            "                             return false;\n",
            "                         } else {\n",
            "                             tb.generateImpliedEndTags(name);\n",
            "-                            if (!tb.currentElement().nodeName().equals(name))\n",
            "+                            if (!tb.currentElement().normalName().equals(name))\n",
            "                                 tb.error(this);\n",
            "                             tb.popStackToClose(name);\n",
            "                         }\n",
            "@@ -728,7 +728,7 @@",
            "                             return false;\n",
            "                         } else {\n",
            "                             tb.generateImpliedEndTags(name);\n",
            "-                            if (!tb.currentElement().nodeName().equals(name))\n",
            "+                            if (!tb.currentElement().normalName().equals(name))\n",
            "                                 tb.error(this);\n",
            "                             tb.popStackToClose(Constants.Headings);\n",
            "                         }\n",
            "@@ -742,7 +742,7 @@",
            "                                 return false;\n",
            "                             }\n",
            "                             tb.generateImpliedEndTags();\n",
            "-                            if (!tb.currentElement().nodeName().equals(name))\n",
            "+                            if (!tb.currentElement().normalName().equals(name))\n",
            "                                 tb.error(this);\n",
            "                             tb.popStackToClose(name);\n",
            "                             tb.clearFormattingElementsToLastMarker();\n",
            "@@ -765,13 +765,13 @@",
            "         }\n",
            " \n",
            "         boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n",
            "-            String name = tb.settings.normalizeTag(t.asEndTag().name());\n",
            "+            String name = t.asEndTag().normalName; // case insensitive search - goal is to preserve output case, not for the parse to be case sensitive\n",
            "             ArrayList<Element> stack = tb.getStack();\n",
            "             for (int pos = stack.size() -1; pos >= 0; pos--) {\n",
            "                 Element node = stack.get(pos);\n",
            "-                if (node.nodeName().equals(name)) {\n",
            "+                if (node.normalName().equals(name)) {\n",
            "                     tb.generateImpliedEndTags(name);\n",
            "-                    if (!name.equals(tb.currentElement().nodeName()))\n",
            "+                    if (!name.equals(tb.currentElement().normalName()))\n",
            "                         tb.error(this);\n",
            "                     tb.popStackToClose(name);\n",
            "                     break;\n",
            "@@ -884,7 +884,7 @@",
            "                 }\n",
            "                 return true; // todo: as above todo\n",
            "             } else if (t.isEOF()) {\n",
            "-                if (tb.currentElement().nodeName().equals(\"html\"))\n",
            "+                if (tb.currentElement().normalName().equals(\"html\"))\n",
            "                     tb.error(this);\n",
            "                 return true; // stops parsing\n",
            "             }\n",
            "@@ -894,7 +894,7 @@",
            "         boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n",
            "             tb.error(this);\n",
            "             boolean processed;\n",
            "-            if (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n",
            "+            if (StringUtil.in(tb.currentElement().normalName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n",
            "                 tb.setFosterInserts(true);\n",
            "                 processed = tb.process(t, InBody);\n",
            "                 tb.setFosterInserts(false);\n",
            "@@ -923,7 +923,7 @@",
            "                             if (!isWhitespace(character)) {\n",
            "                                 // InTable anything else section:\n",
            "                                 tb.error(this);\n",
            "-                                if (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n",
            "+                                if (StringUtil.in(tb.currentElement().normalName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n",
            "                                     tb.setFosterInserts(true);\n",
            "                                     tb.process(new Token.Character().data(character), InBody);\n",
            "                                     tb.setFosterInserts(false);\n",
            "@@ -951,7 +951,7 @@",
            "                     return false;\n",
            "                 } else {\n",
            "                     tb.generateImpliedEndTags();\n",
            "-                    if (!tb.currentElement().nodeName().equals(\"caption\"))\n",
            "+                    if (!tb.currentElement().normalName().equals(\"caption\"))\n",
            "                         tb.error(this);\n",
            "                     tb.popStackToClose(\"caption\");\n",
            "                     tb.clearFormattingElementsToLastMarker();\n",
            "@@ -1004,7 +1004,7 @@",
            "                 case EndTag:\n",
            "                     Token.EndTag endTag = t.asEndTag();\n",
            "                     if (endTag.normalName.equals(\"colgroup\")) {\n",
            "-                        if (tb.currentElement().nodeName().equals(\"html\")) {\n",
            "+                        if (tb.currentElement().normalName().equals(\"html\")) { // frag case\n",
            "                             tb.error(this);\n",
            "                             return false;\n",
            "                         } else {\n",
            "@@ -1015,7 +1015,7 @@",
            "                         return anythingElse(t, tb);\n",
            "                     break;\n",
            "                 case EOF:\n",
            "-                    if (tb.currentElement().nodeName().equals(\"html\"))\n",
            "+                    if (tb.currentElement().normalName().equals(\"html\"))\n",
            "                         return true; // stop parsing; frag case\n",
            "                     else\n",
            "                         return anythingElse(t, tb);\n",
            "@@ -1380,17 +1380,17 @@",
            "                         return false;\n",
            "                 }\n",
            "             } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"frameset\")) {\n",
            "-                if (tb.currentElement().nodeName().equals(\"html\")) {\n",
            "+                if (tb.currentElement().normalName().equals(\"html\")) { // frag\n",
            "                     tb.error(this);\n",
            "                     return false;\n",
            "                 } else {\n",
            "                     tb.pop();\n",
            "-                    if (!tb.isFragmentParsing() && !tb.currentElement().nodeName().equals(\"frameset\")) {\n",
            "+                    if (!tb.isFragmentParsing() && !tb.currentElement().normalName().equals(\"frameset\")) {\n",
            "                         tb.transition(AfterFrameset);\n",
            "                     }\n",
            "                 }\n",
            "             } else if (t.isEOF()) {\n",
            "-                if (!tb.currentElement().nodeName().equals(\"html\")) {\n",
            "+                if (!tb.currentElement().normalName().equals(\"html\")) {\n",
            "                     tb.error(this);\n",
            "                     return true;\n",
            "                 }\n"
          ],
          "changed_lines": 64
        },
        {
          "buggy_method": "  private boolean exitTableBody(Token t, HtmlTreeBuilder tb) {\n  if (!(tb.inTableScope(\"tbody\") || tb.inTableScope(\"thead\") || tb.inScope(\"tfoot\"))) {\n  \n  tb.error(this);\n  return false;\n  }\n  tb.clearStackToTableBodyContext();\n  tb.processEndTag(tb.currentElement().nodeName());\n  return tb.process(t);\n  }",
          "fixed_method": "  private boolean exitTableBody(Token t, HtmlTreeBuilder tb) {\n  if (!(tb.inTableScope(\"tbody\") || tb.inTableScope(\"thead\") || tb.inScope(\"tfoot\"))) {\n  \n  tb.error(this);\n  return false;\n  }\n  tb.clearStackToTableBodyContext();\n  tb.processEndTag(tb.currentElement().normalName()); \n  return tb.process(t);\n  }",
          "diff": [
            "@@ -1086,7 +1086,7 @@",
            "                 return false;\n",
            "             }\n",
            "             tb.clearStackToTableBodyContext();\n",
            "-            tb.processEndTag(tb.currentElement().nodeName());\n",
            "+            tb.processEndTag(tb.currentElement().normalName()); // tbody, tfoot, thead\n",
            "             return tb.process(t);\n",
            "         }\n",
            " \n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  private boolean handleMissingTr(Token t, TreeBuilder tb) {\n  boolean processed = tb.processEndTag(\"tr\");\n  if (processed)\n  return tb.process(t);\n  else\n  return false;\n  }",
          "fixed_method": "  private boolean handleMissingTr(Token t, TreeBuilder tb) {\n  boolean processed = tb.processEndTag(\"tr\");\n  if (processed)\n  return tb.process(t);\n  else\n  return false;\n  }",
          "diff": [
            "@@ -1170,7 +1170,7 @@",
            "                         return false;\n",
            "                     }\n",
            "                     tb.generateImpliedEndTags();\n",
            "-                    if (!tb.currentElement().nodeName().equals(name))\n",
            "+                    if (!tb.currentElement().normalName().equals(name))\n",
            "                         tb.error(this);\n",
            "                     tb.popStackToClose(name);\n",
            "                     tb.clearFormattingElementsToLastMarker();\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  private void closeCell(HtmlTreeBuilder tb) {\n  if (tb.inTableScope(\"td\"))\n  tb.processEndTag(\"td\");\n  else\n  tb.processEndTag(\"th\"); \n  }",
          "fixed_method": "  private void closeCell(HtmlTreeBuilder tb) {\n  if (tb.inTableScope(\"td\"))\n  tb.processEndTag(\"td\");\n  else\n  tb.processEndTag(\"th\"); \n  }",
          "diff": [
            "@@ -1237,13 +1237,13 @@",
            "                     if (name.equals(\"html\"))\n",
            "                         return tb.process(start, InBody);\n",
            "                     else if (name.equals(\"option\")) {\n",
            "-                        if (tb.currentElement().nodeName().equals(\"option\"))\n",
            "+                        if (tb.currentElement().normalName().equals(\"option\"))\n",
            "                             tb.processEndTag(\"option\");\n",
            "                         tb.insert(start);\n",
            "                     } else if (name.equals(\"optgroup\")) {\n",
            "-                        if (tb.currentElement().nodeName().equals(\"option\"))\n",
            "+                        if (tb.currentElement().normalName().equals(\"option\"))\n",
            "                             tb.processEndTag(\"option\");\n",
            "-                        else if (tb.currentElement().nodeName().equals(\"optgroup\"))\n",
            "+                        else if (tb.currentElement().normalName().equals(\"optgroup\"))\n",
            "                             tb.processEndTag(\"optgroup\");\n",
            "                         tb.insert(start);\n",
            "                     } else if (name.equals(\"select\")) {\n",
            "@@ -1266,15 +1266,15 @@",
            "                     name = end.normalName();\n",
            "                     switch (name) {\n",
            "                         case \"optgroup\":\n",
            "-                            if (tb.currentElement().nodeName().equals(\"option\") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).nodeName().equals(\"optgroup\"))\n",
            "+                            if (tb.currentElement().normalName().equals(\"option\") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).normalName().equals(\"optgroup\"))\n",
            "                                 tb.processEndTag(\"option\");\n",
            "-                            if (tb.currentElement().nodeName().equals(\"optgroup\"))\n",
            "+                            if (tb.currentElement().normalName().equals(\"optgroup\"))\n",
            "                                 tb.pop();\n",
            "                             else\n",
            "                                 tb.error(this);\n",
            "                             break;\n",
            "                         case \"option\":\n",
            "-                            if (tb.currentElement().nodeName().equals(\"option\"))\n",
            "+                            if (tb.currentElement().normalName().equals(\"option\"))\n",
            "                                 tb.pop();\n",
            "                             else\n",
            "                                 tb.error(this);\n",
            "@@ -1293,7 +1293,7 @@",
            "                     }\n",
            "                     break;\n",
            "                 case EOF:\n",
            "-                    if (!tb.currentElement().nodeName().equals(\"html\"))\n",
            "+                    if (!tb.currentElement().normalName().equals(\"html\"))\n",
            "                         tb.error(this);\n",
            "                     break;\n",
            "                 default:\n"
          ],
          "changed_lines": 14
        }
      ]
    },
    {
      "name": "org/jsoup/parser/Tag.java",
      "buggy_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n\npublic class Tag { private static final Map<String, Tag> tags = new HashMap<>(); private String tagName; private boolean isBlock = true; private boolean formatAsBlock = true; private boolean canContainInline = true; private boolean empty = false; private boolean selfClosing = false; private boolean preserveWhitespace = false; private boolean formList = false; private boolean formSubmit = false; private Tag(String tagName) {\n        this.tagName = tagName;\n    }\n\n    \n    public String getName() {\n        return tagName;\n    }\n\n    \n\n    \n    public static Tag valueOf(String tagName, ParseSettings settings) {\n        Validate.notNull(tagName);\n        Tag tag = tags.get(tagName);\n\n        if (tag == null) {\n            tagName = settings.normalizeTag(tagName);\n            Validate.notEmpty(tagName);\n            tag = tags.get(tagName);\n\n            if (tag == null) {\n                \n                tag = new Tag(tagName);\n                tag.isBlock = false;\n            }\n        }\n        return tag;\n    }\n\n    \n    public static Tag valueOf(String tagName) {\n        return valueOf(tagName, ParseSettings.preserveCase);\n    }\n\n    \n    public boolean isBlock() {\n        return isBlock;\n    }\n\n    \n    public boolean formatAsBlock() {\n        return formatAsBlock;\n    }\n\n    \n    public boolean canContainBlock() {\n        return isBlock;\n    }\n\n    \n    public boolean isInline() {\n        return !isBlock;\n    }\n\n    \n    public boolean isData() {\n        return !canContainInline && !isEmpty();\n    }\n\n    \n    public boolean isEmpty() {\n        return empty;\n    }\n\n    \n    public boolean isSelfClosing() {\n        return empty || selfClosing;\n    }\n\n    \n    public boolean isKnownTag() {\n        return tags.containsKey(tagName);\n    }\n\n    \n    public static boolean isKnownTag(String tagName) {\n        return tags.containsKey(tagName);\n    }\n\n    \n    public boolean preserveWhitespace() {\n        return preserveWhitespace;\n    }\n\n    \n    public boolean isFormListed() {\n        return formList;\n    }\n\n    \n    public boolean isFormSubmittable() {\n        return formSubmit;\n    }\n\n    Tag setSelfClosing() {\n        selfClosing = true;\n        return this;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Tag)) return false;\n\n        Tag tag = (Tag) o;\n\n        if (!tagName.equals(tag.tagName)) return false;\n        if (canContainInline != tag.canContainInline) return false;\n        if (empty != tag.empty) return false;\n        if (formatAsBlock != tag.formatAsBlock) return false;\n        if (isBlock != tag.isBlock) return false;\n        if (preserveWhitespace != tag.preserveWhitespace) return false;\n        if (selfClosing != tag.selfClosing) return false;\n        if (formList != tag.formList) return false;\n        return formSubmit == tag.formSubmit;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = tagName.hashCode();\n        result = 31 * result + (isBlock ? 1 : 0);\n        result = 31 * result + (formatAsBlock ? 1 : 0);\n        result = 31 * result + (canContainInline ? 1 : 0);\n        result = 31 * result + (empty ? 1 : 0);\n        result = 31 * result + (selfClosing ? 1 : 0);\n        result = 31 * result + (preserveWhitespace ? 1 : 0);\n        result = 31 * result + (formList ? 1 : 0);\n        result = 31 * result + (formSubmit ? 1 : 0);\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return tagName;\n    }\n\n    \n    \n    private static final String[] blockTags = { \"html\", \"head\", \"body\", \"frameset\", \"script\", \"noscript\", \"style\", \"meta\", \"link\", \"title\", \"frame\", \"noframes\", \"section\", \"nav\", \"aside\", \"hgroup\", \"header\", \"footer\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"ul\", \"ol\", \"pre\", \"div\", \"blockquote\", \"hr\", \"address\", \"figure\", \"figcaption\", \"form\", \"fieldset\", \"ins\", \"del\", \"dl\", \"dt\", \"dd\", \"li\", \"table\", \"caption\", \"thead\", \"tfoot\", \"tbody\", \"colgroup\", \"col\", \"tr\", \"th\", \"td\", \"video\", \"audio\", \"canvas\", \"details\", \"menu\", \"plaintext\", \"template\", \"article\", \"main\", \"svg\", \"math\" }; private static final String[] inlineTags = { \"object\", \"base\", \"font\", \"tt\", \"i\", \"b\", \"u\", \"big\", \"small\", \"em\", \"strong\", \"dfn\", \"code\", \"samp\", \"kbd\", \"var\", \"cite\", \"abbr\", \"time\", \"acronym\", \"mark\", \"ruby\", \"rt\", \"rp\", \"a\", \"img\", \"br\", \"wbr\", \"map\", \"q\", \"sub\", \"sup\", \"bdo\", \"iframe\", \"embed\", \"span\", \"input\", \"select\", \"textarea\", \"label\", \"button\", \"optgroup\", \"option\", \"legend\", \"datalist\", \"keygen\", \"output\", \"progress\", \"meter\", \"area\", \"param\", \"source\", \"track\", \"summary\", \"command\", \"device\", \"area\", \"basefont\", \"bgsound\", \"menuitem\", \"param\", \"source\", \"track\", \"data\", \"bdi\", \"s\" }; private static final String[] emptyTags = { \"meta\", \"link\", \"base\", \"frame\", \"img\", \"br\", \"wbr\", \"embed\", \"hr\", \"input\", \"keygen\", \"col\", \"command\", \"device\", \"area\", \"basefont\", \"bgsound\", \"menuitem\", \"param\", \"source\", \"track\" }; private static final String[] formatAsInlineTags = { \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\", \"ins\", \"del\", \"s\" }; private static final String[] preserveWhitespaceTags = { \"pre\", \"plaintext\", \"title\", \"textarea\" }; private static final String[] formListedTags = { \"button\", \"fieldset\", \"input\", \"keygen\", \"object\", \"output\", \"select\", \"textarea\" }; private static final String[] formSubmitTags = { \"input\", \"keygen\", \"object\", \"select\", \"textarea\" }; static { for (String tagName : blockTags) {\n            Tag tag = new Tag(tagName);\n            register(tag);\n        }\n        for (String tagName : inlineTags) {\n            Tag tag = new Tag(tagName);\n            tag.isBlock = false;\n            tag.formatAsBlock = false;\n            register(tag);\n        }\n\n        \n        for (String tagName : emptyTags) {\n            Tag tag = tags.get(tagName);\n            Validate.notNull(tag);\n            tag.canContainInline = false;\n            tag.empty = true;\n        }\n\n        for (String tagName : formatAsInlineTags) {\n            Tag tag = tags.get(tagName);\n            Validate.notNull(tag);\n            tag.formatAsBlock = false;\n        }\n\n        for (String tagName : preserveWhitespaceTags) {\n            Tag tag = tags.get(tagName);\n            Validate.notNull(tag);\n            tag.preserveWhitespace = true;\n        }\n\n        for (String tagName : formListedTags) {\n            Tag tag = tags.get(tagName);\n            Validate.notNull(tag);\n            tag.formList = true;\n        }\n\n        for (String tagName : formSubmitTags) {\n            Tag tag = tags.get(tagName);\n            Validate.notNull(tag);\n            tag.formSubmit = true;\n        }\n    }\n\n    private static void register(Tag tag) {\n        tags.put(tag.tagName, tag);\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.internal.Normalizer;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n\npublic class Tag { private static final Map<String, Tag> tags = new HashMap<>(); private String tagName; private String normalName; private boolean isBlock = true; private boolean formatAsBlock = true; private boolean canContainInline = true; private boolean empty = false; private boolean selfClosing = false; private boolean preserveWhitespace = false; private boolean formList = false; private boolean formSubmit = false; private Tag(String tagName) {\n        this.tagName = tagName;\n        normalName = Normalizer.lowerCase(tagName);\n    }\n\n    \n    public String getName() {\n        return tagName;\n    }\n\n    \n    public String normalName() {\n        return normalName;\n    }\n\n    \n    public static Tag valueOf(String tagName, ParseSettings settings) {\n        Validate.notNull(tagName);\n        Tag tag = tags.get(tagName);\n\n        if (tag == null) {\n            tagName = settings.normalizeTag(tagName);\n            Validate.notEmpty(tagName);\n            tag = tags.get(tagName);\n\n            if (tag == null) {\n                \n                tag = new Tag(tagName);\n                tag.isBlock = false;\n            }\n        }\n        return tag;\n    }\n\n    \n    public static Tag valueOf(String tagName) {\n        return valueOf(tagName, ParseSettings.preserveCase);\n    }\n\n    \n    public boolean isBlock() {\n        return isBlock;\n    }\n\n    \n    public boolean formatAsBlock() {\n        return formatAsBlock;\n    }\n\n    \n    public boolean canContainBlock() {\n        return isBlock;\n    }\n\n    \n    public boolean isInline() {\n        return !isBlock;\n    }\n\n    \n    public boolean isData() {\n        return !canContainInline && !isEmpty();\n    }\n\n    \n    public boolean isEmpty() {\n        return empty;\n    }\n\n    \n    public boolean isSelfClosing() {\n        return empty || selfClosing;\n    }\n\n    \n    public boolean isKnownTag() {\n        return tags.containsKey(tagName);\n    }\n\n    \n    public static boolean isKnownTag(String tagName) {\n        return tags.containsKey(tagName);\n    }\n\n    \n    public boolean preserveWhitespace() {\n        return preserveWhitespace;\n    }\n\n    \n    public boolean isFormListed() {\n        return formList;\n    }\n\n    \n    public boolean isFormSubmittable() {\n        return formSubmit;\n    }\n\n    Tag setSelfClosing() {\n        selfClosing = true;\n        return this;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Tag)) return false;\n\n        Tag tag = (Tag) o;\n\n        if (!tagName.equals(tag.tagName)) return false;\n        if (canContainInline != tag.canContainInline) return false;\n        if (empty != tag.empty) return false;\n        if (formatAsBlock != tag.formatAsBlock) return false;\n        if (isBlock != tag.isBlock) return false;\n        if (preserveWhitespace != tag.preserveWhitespace) return false;\n        if (selfClosing != tag.selfClosing) return false;\n        if (formList != tag.formList) return false;\n        return formSubmit == tag.formSubmit;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = tagName.hashCode();\n        result = 31 * result + (isBlock ? 1 : 0);\n        result = 31 * result + (formatAsBlock ? 1 : 0);\n        result = 31 * result + (canContainInline ? 1 : 0);\n        result = 31 * result + (empty ? 1 : 0);\n        result = 31 * result + (selfClosing ? 1 : 0);\n        result = 31 * result + (preserveWhitespace ? 1 : 0);\n        result = 31 * result + (formList ? 1 : 0);\n        result = 31 * result + (formSubmit ? 1 : 0);\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return tagName;\n    }\n\n    \n    \n    private static final String[] blockTags = { \"html\", \"head\", \"body\", \"frameset\", \"script\", \"noscript\", \"style\", \"meta\", \"link\", \"title\", \"frame\", \"noframes\", \"section\", \"nav\", \"aside\", \"hgroup\", \"header\", \"footer\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"ul\", \"ol\", \"pre\", \"div\", \"blockquote\", \"hr\", \"address\", \"figure\", \"figcaption\", \"form\", \"fieldset\", \"ins\", \"del\", \"dl\", \"dt\", \"dd\", \"li\", \"table\", \"caption\", \"thead\", \"tfoot\", \"tbody\", \"colgroup\", \"col\", \"tr\", \"th\", \"td\", \"video\", \"audio\", \"canvas\", \"details\", \"menu\", \"plaintext\", \"template\", \"article\", \"main\", \"svg\", \"math\" }; private static final String[] inlineTags = { \"object\", \"base\", \"font\", \"tt\", \"i\", \"b\", \"u\", \"big\", \"small\", \"em\", \"strong\", \"dfn\", \"code\", \"samp\", \"kbd\", \"var\", \"cite\", \"abbr\", \"time\", \"acronym\", \"mark\", \"ruby\", \"rt\", \"rp\", \"a\", \"img\", \"br\", \"wbr\", \"map\", \"q\", \"sub\", \"sup\", \"bdo\", \"iframe\", \"embed\", \"span\", \"input\", \"select\", \"textarea\", \"label\", \"button\", \"optgroup\", \"option\", \"legend\", \"datalist\", \"keygen\", \"output\", \"progress\", \"meter\", \"area\", \"param\", \"source\", \"track\", \"summary\", \"command\", \"device\", \"area\", \"basefont\", \"bgsound\", \"menuitem\", \"param\", \"source\", \"track\", \"data\", \"bdi\", \"s\" }; private static final String[] emptyTags = { \"meta\", \"link\", \"base\", \"frame\", \"img\", \"br\", \"wbr\", \"embed\", \"hr\", \"input\", \"keygen\", \"col\", \"command\", \"device\", \"area\", \"basefont\", \"bgsound\", \"menuitem\", \"param\", \"source\", \"track\" }; private static final String[] formatAsInlineTags = { \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\", \"ins\", \"del\", \"s\" }; private static final String[] preserveWhitespaceTags = { \"pre\", \"plaintext\", \"title\", \"textarea\" }; private static final String[] formListedTags = { \"button\", \"fieldset\", \"input\", \"keygen\", \"object\", \"output\", \"select\", \"textarea\" }; private static final String[] formSubmitTags = { \"input\", \"keygen\", \"object\", \"select\", \"textarea\" }; static { for (String tagName : blockTags) {\n            Tag tag = new Tag(tagName);\n            register(tag);\n        }\n        for (String tagName : inlineTags) {\n            Tag tag = new Tag(tagName);\n            tag.isBlock = false;\n            tag.formatAsBlock = false;\n            register(tag);\n        }\n\n        \n        for (String tagName : emptyTags) {\n            Tag tag = tags.get(tagName);\n            Validate.notNull(tag);\n            tag.canContainInline = false;\n            tag.empty = true;\n        }\n\n        for (String tagName : formatAsInlineTags) {\n            Tag tag = tags.get(tagName);\n            Validate.notNull(tag);\n            tag.formatAsBlock = false;\n        }\n\n        for (String tagName : preserveWhitespaceTags) {\n            Tag tag = tags.get(tagName);\n            Validate.notNull(tag);\n            tag.preserveWhitespace = true;\n        }\n\n        for (String tagName : formListedTags) {\n            Tag tag = tags.get(tagName);\n            Validate.notNull(tag);\n            tag.formList = true;\n        }\n\n        for (String tagName : formSubmitTags) {\n            Tag tag = tags.get(tagName);\n            Validate.notNull(tag);\n            tag.formSubmit = true;\n        }\n    }\n\n    private static void register(Tag tag) {\n        tags.put(tag.tagName, tag);\n    }\n}\n",
      "buggy_signatures": [
        "public String getName()",
        "public static Tag valueOf(String tagName, ParseSettings settings)",
        "public static Tag valueOf(String tagName)",
        "public boolean isBlock()",
        "public boolean formatAsBlock()",
        "public boolean canContainBlock()",
        "public boolean isInline()",
        "public boolean isData()",
        "public boolean isEmpty()",
        "public boolean isSelfClosing()",
        "public boolean isKnownTag()",
        "public static boolean isKnownTag(String tagName)",
        "public boolean preserveWhitespace()",
        "public boolean isFormListed()",
        "public boolean isFormSubmittable()",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "public String toString()",
        "private static void register(Tag tag)"
      ],
      "fixed_signatures": [
        "public String getName()",
        "public String normalName()",
        "public static Tag valueOf(String tagName, ParseSettings settings)",
        "public static Tag valueOf(String tagName)",
        "public boolean isBlock()",
        "public boolean formatAsBlock()",
        "public boolean canContainBlock()",
        "public boolean isInline()",
        "public boolean isData()",
        "public boolean isEmpty()",
        "public boolean isSelfClosing()",
        "public boolean isKnownTag()",
        "public static boolean isKnownTag(String tagName)",
        "public boolean preserveWhitespace()",
        "public boolean isFormListed()",
        "public boolean isFormSubmittable()",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "public String toString()",
        "private static void register(Tag tag)"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -1,6 +1,7 @@",
            " package org.jsoup.parser;\n",
            " \n",
            " import org.jsoup.helper.Validate;\n",
            "+import org.jsoup.internal.Normalizer;\n",
            " \n",
            " import java.util.HashMap;\n",
            " import java.util.Map;\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  private static final Map<String, Tag> tags = new HashMap<>(); private String tagName; private boolean isBlock = true; private boolean formatAsBlock = true; private boolean canContainInline = true; private boolean empty = false; private boolean selfClosing = false; private boolean preserveWhitespace = false; private boolean formList = false; private boolean formSubmit = false; private Tag(String tagName) {\n  this.tagName = tagName;\n  }",
          "fixed_method": "  private static final Map<String, Tag> tags = new HashMap<>(); private String tagName; private String normalName; private boolean isBlock = true; private boolean formatAsBlock = true; private boolean canContainInline = true; private boolean empty = false; private boolean selfClosing = false; private boolean preserveWhitespace = false; private boolean formList = false; private boolean formSubmit = false; private Tag(String tagName) {\n  this.tagName = tagName;\n  normalName = Normalizer.lowerCase(tagName);\n  }",
          "diff": [
            "@@ -14,6 +15,7 @@",
            "     private static final Map<String, Tag> tags = new HashMap<>(); // map of known tags\n",
            " \n",
            "     private String tagName;\n",
            "+    private String normalName; // always the lower case version of this tag, regardless of case preservation mode\n",
            "     private boolean isBlock = true; // block or inline\n",
            "     private boolean formatAsBlock = true; // should be formatted as a block\n",
            "     private boolean canContainInline = true; // only pcdata if not\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  private Tag(String tagName) {\n  this.tagName = tagName;\n  }",
          "fixed_method": "  private Tag(String tagName) {\n  this.tagName = tagName;\n  normalName = Normalizer.lowerCase(tagName);\n  }",
          "diff": [
            "@@ -25,6 +27,7 @@",
            " \n",
            "     private Tag(String tagName) {\n",
            "         this.tagName = tagName;\n",
            "+        normalName = Normalizer.lowerCase(tagName);\n",
            "     }\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  public String getName() {\n  return tagName;\n  }",
          "fixed_method": "  public String normalName() {\n  return normalName;\n  }",
          "diff": [
            "@@ -40,6 +43,9 @@",
            "      * Get this tag's normalized (lowercased) name.\n",
            "      * @return the tag's normal name.\n",
            "      */\n",
            "+    public String normalName() {\n",
            "+        return normalName;\n",
            "+    }\n",
            " \n",
            "     /**\n",
            "      * Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything.\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
