{
  "bug_id": "1",
  "failed_tests": {
    "org.joda.time.TestPartial_Constructors": [
      {
        "methodName": "testConstructorEx7_TypeArray_intArray",
        "error": "junit.framework.AssertionFailedError",
        "message": "",
        "fail_line": "            fail();",
        "test_source": "  public void testConstructorEx7_TypeArray_intArray() throws Throwable {\n  int[] values = new int[] {1, 1, 1};\n  DateTimeFieldType[] types = new DateTimeFieldType[] {\n  DateTimeFieldType.dayOfMonth(), DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };\n  try {\n  new Partial(types, values);\n  fail();\n  } catch (IllegalArgumentException ex) {\n  assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n  }\n  \n  types = new DateTimeFieldType[] {\n  DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear() };\n  try {\n  new Partial(types, values);\n  fail();\n  } catch (IllegalArgumentException ex) {\n  assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n  }\n  \n  types = new DateTimeFieldType[] {\n  DateTimeFieldType.year(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() };\n  try {\n  new Partial(types, values);\n  fail();\n  } catch (IllegalArgumentException ex) {\n  assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n  }\n  \n  types = new DateTimeFieldType[] {\n  DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.era() };\n  try {\n  new Partial(types, values);\n  fail();\n  } catch (IllegalArgumentException ex) {\n  assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n  }\n  \n  types = new DateTimeFieldType[] {\n  DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfYear() };\n  try {\n  new Partial(types, values);\n  fail();\n  } catch (IllegalArgumentException ex) {\n  assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n  }\n  \n  types = new DateTimeFieldType[] {\n  DateTimeFieldType.yearOfEra(), DateTimeFieldType.year(), DateTimeFieldType.dayOfYear() };\n  try {\n  new Partial(types, values);\n  fail();\n  } catch (IllegalArgumentException ex) {\n  assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n  }\n  }",
        "stack": [
          "TestPartial_Constructors.testConstructorEx7_TypeArray_intArray line 284"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/joda/time/field/UnsupportedDurationField.java",
      "buggy_full_code": "\npackage org.joda.time.field;\n\nimport java.io.Serializable;\nimport java.util.HashMap;\n\nimport org.joda.time.DurationField;\nimport org.joda.time.DurationFieldType;\n\n\npublic final class UnsupportedDurationField extends DurationField implements Serializable { private static final long serialVersionUID = -6390301302770925357L; private static HashMap<DurationFieldType, UnsupportedDurationField> cCache; public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) {\n        UnsupportedDurationField field;\n        if (cCache == null) {\n            cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7);\n            field = null;\n        } else {\n            field = cCache.get(type);\n        }\n        if (field == null) {\n            field = new UnsupportedDurationField(type);\n            cCache.put(type, field);\n        }\n        return field;\n    }\n\n    \n    private final DurationFieldType iType; private UnsupportedDurationField(DurationFieldType type) {\n        iType = type;\n    }\n\n    \n    \n    \n\n    public final DurationFieldType getType() {\n        return iType;\n    }\n\n    public String getName() {\n        return iType.getName();\n    }\n\n    \n    public boolean isSupported() {\n        return false;\n    }\n\n    \n    public boolean isPrecise() {\n        return true;\n    }\n\n    \n    public int getValue(long duration) {\n        throw unsupported();\n    }\n\n    \n    public long getValueAsLong(long duration) {\n        throw unsupported();\n    }\n\n    \n    public int getValue(long duration, long instant) {\n        throw unsupported();\n    }\n\n    \n    public long getValueAsLong(long duration, long instant) {\n        throw unsupported();\n    }\n\n    \n    public long getMillis(int value) {\n        throw unsupported();\n    }\n\n    \n    public long getMillis(long value) {\n        throw unsupported();\n    }\n\n    \n    public long getMillis(int value, long instant) {\n        throw unsupported();\n    }\n\n    \n    public long getMillis(long value, long instant) {\n        throw unsupported();\n    }\n\n    \n    public long add(long instant, int value) {\n        throw unsupported();\n    }\n\n    \n    public long add(long instant, long value) {\n        throw unsupported();\n    }\n\n    \n    public int getDifference(long minuendInstant, long subtrahendInstant) {\n        throw unsupported();\n    }\n\n    \n    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n        throw unsupported();\n    }\n\n    \n    public long getUnitMillis() {\n        return 0;\n    }\n\n    \n    public int compareTo(DurationField durationField) {\n        if (durationField.isSupported()) {\n            return 1;\n        }\n        return 0;\n    }\n\n    \n    \n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        } else if (obj instanceof UnsupportedDurationField) {\n            UnsupportedDurationField other = (UnsupportedDurationField) obj;\n            if (other.getName() == null) {\n                return (getName() == null);\n            }\n            return (other.getName().equals(getName()));\n        }\n        return false;\n    }\n\n    \n    public int hashCode() {\n        return getName().hashCode();\n    }\n\n    \n    public String toString() {\n        return \"UnsupportedDurationField[\" + getName() + ']';\n    }\n\n    \n    private Object readResolve() {\n        return getInstance(iType);\n    }\n\n    private UnsupportedOperationException unsupported() {\n        return new UnsupportedOperationException(iType + \" field is unsupported\");\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.joda.time.field;\n\nimport java.io.Serializable;\nimport java.util.HashMap;\n\nimport org.joda.time.DurationField;\nimport org.joda.time.DurationFieldType;\n\n\npublic final class UnsupportedDurationField extends DurationField implements Serializable { private static final long serialVersionUID = -6390301302770925357L; private static HashMap<DurationFieldType, UnsupportedDurationField> cCache; public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) {\n        UnsupportedDurationField field;\n        if (cCache == null) {\n            cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7);\n            field = null;\n        } else {\n            field = cCache.get(type);\n        }\n        if (field == null) {\n            field = new UnsupportedDurationField(type);\n            cCache.put(type, field);\n        }\n        return field;\n    }\n\n    \n    private final DurationFieldType iType; private UnsupportedDurationField(DurationFieldType type) {\n        iType = type;\n    }\n\n    \n    \n    \n\n    public final DurationFieldType getType() {\n        return iType;\n    }\n\n    public String getName() {\n        return iType.getName();\n    }\n\n    \n    public boolean isSupported() {\n        return false;\n    }\n\n    \n    public boolean isPrecise() {\n        return true;\n    }\n\n    \n    public int getValue(long duration) {\n        throw unsupported();\n    }\n\n    \n    public long getValueAsLong(long duration) {\n        throw unsupported();\n    }\n\n    \n    public int getValue(long duration, long instant) {\n        throw unsupported();\n    }\n\n    \n    public long getValueAsLong(long duration, long instant) {\n        throw unsupported();\n    }\n\n    \n    public long getMillis(int value) {\n        throw unsupported();\n    }\n\n    \n    public long getMillis(long value) {\n        throw unsupported();\n    }\n\n    \n    public long getMillis(int value, long instant) {\n        throw unsupported();\n    }\n\n    \n    public long getMillis(long value, long instant) {\n        throw unsupported();\n    }\n\n    \n    public long add(long instant, int value) {\n        throw unsupported();\n    }\n\n    \n    public long add(long instant, long value) {\n        throw unsupported();\n    }\n\n    \n    public int getDifference(long minuendInstant, long subtrahendInstant) {\n        throw unsupported();\n    }\n\n    \n    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n        throw unsupported();\n    }\n\n    \n    public long getUnitMillis() {\n        return 0;\n    }\n\n    \n    public int compareTo(DurationField durationField) {\n        return 0;\n    }\n\n    \n    \n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        } else if (obj instanceof UnsupportedDurationField) {\n            UnsupportedDurationField other = (UnsupportedDurationField) obj;\n            if (other.getName() == null) {\n                return (getName() == null);\n            }\n            return (other.getName().equals(getName()));\n        }\n        return false;\n    }\n\n    \n    public int hashCode() {\n        return getName().hashCode();\n    }\n\n    \n    public String toString() {\n        return \"UnsupportedDurationField[\" + getName() + ']';\n    }\n\n    \n    private Object readResolve() {\n        return getInstance(iType);\n    }\n\n    private UnsupportedOperationException unsupported() {\n        return new UnsupportedOperationException(iType + \" field is unsupported\");\n    }\n\n}\n",
      "buggy_signatures": [
        "private final DurationFieldType iType; private UnsupportedDurationField(DurationFieldType type)",
        "public final DurationFieldType getType()",
        "public String getName()",
        "public boolean isSupported()",
        "public boolean isPrecise()",
        "public int getValue(long duration)",
        "public long getValueAsLong(long duration)",
        "public int getValue(long duration, long instant)",
        "public long getValueAsLong(long duration, long instant)",
        "public long getMillis(int value)",
        "public long getMillis(long value)",
        "public long getMillis(int value, long instant)",
        "public long getMillis(long value, long instant)",
        "public long add(long instant, int value)",
        "public long add(long instant, long value)",
        "public int getDifference(long minuendInstant, long subtrahendInstant)",
        "public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant)",
        "public long getUnitMillis()",
        "public int compareTo(DurationField durationField)",
        "public boolean equals(Object obj)",
        "public int hashCode()",
        "public String toString()",
        "private Object readResolve()",
        "private UnsupportedOperationException unsupported()"
      ],
      "fixed_signatures": [
        "private final DurationFieldType iType; private UnsupportedDurationField(DurationFieldType type)",
        "public final DurationFieldType getType()",
        "public String getName()",
        "public boolean isSupported()",
        "public boolean isPrecise()",
        "public int getValue(long duration)",
        "public long getValueAsLong(long duration)",
        "public int getValue(long duration, long instant)",
        "public long getValueAsLong(long duration, long instant)",
        "public long getMillis(int value)",
        "public long getMillis(long value)",
        "public long getMillis(int value, long instant)",
        "public long getMillis(long value, long instant)",
        "public long add(long instant, int value)",
        "public long add(long instant, long value)",
        "public int getDifference(long minuendInstant, long subtrahendInstant)",
        "public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant)",
        "public long getUnitMillis()",
        "public int compareTo(DurationField durationField)",
        "public boolean equals(Object obj)",
        "public int hashCode()",
        "public String toString()",
        "private Object readResolve()",
        "private UnsupportedOperationException unsupported()"
      ],
      "methods": [
        {
          "buggy_method": "  public int compareTo(DurationField durationField) {\n  if (durationField.isSupported()) {\n  return 1;\n  }\n  return 0;\n  }",
          "fixed_method": "  public int compareTo(DurationField durationField) {\n  return 0;\n  }",
          "diff": [
            "@@ -224,9 +224,6 @@",
            "      * @return zero always\n",
            "      */\n",
            "     public int compareTo(DurationField durationField) {\n",
            "-        if (durationField.isSupported()) {\n",
            "-            return 1;\n",
            "-        }\n",
            "         return 0;\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 3
        }
      ]
    },
    {
      "name": "org/joda/time/Partial.java",
      "buggy_full_code": "\npackage org.joda.time;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.joda.time.base.AbstractPartial;\nimport org.joda.time.field.AbstractPartialFieldProperty;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n\npublic final class Partial extends AbstractPartial implements ReadablePartial, Serializable { private static final long serialVersionUID = 12324121189002L; private final Chronology iChronology; private final DateTimeFieldType[] iTypes; private final int[] iValues; private transient DateTimeFormatter[] iFormatter; public Partial() {\n        this((Chronology) null);\n    }\n\n    \n    public Partial(Chronology chrono) {\n        super();\n        iChronology = DateTimeUtils.getChronology(chrono).withUTC();\n        iTypes = new DateTimeFieldType[0];\n        iValues = new int[0];\n    }\n\n    \n    public Partial(DateTimeFieldType type, int value) {\n        this(type, value, null);\n    }\n\n    \n    public Partial(DateTimeFieldType type, int value, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (type == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        iTypes = new DateTimeFieldType[] {type};\n        iValues = new int[] {value};\n        chronology.validate(this, iValues);\n    }\n\n    \n    public Partial(DateTimeFieldType[] types, int[] values) {\n        this(types, values, null);\n    }\n\n    \n    public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (types == null) {\n            throw new IllegalArgumentException(\"Types array must not be null\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Values array must not be null\");\n        }\n        if (values.length != types.length) {\n            throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n        }\n        if (types.length == 0) {\n            iTypes = types;\n            iValues = values;\n            return;\n        }\n        for (int i = 0; i < types.length; i++) {\n            if (types[i] == null) {\n                throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n            }\n        }\n        DurationField lastUnitField = null;\n        for (int i = 0; i < types.length; i++) {\n            DateTimeFieldType loopType = types[i];\n            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n            if (i > 0) {\n                int compare = lastUnitField.compareTo(loopUnitField);\n                if (compare < 0) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }\n            }\n            lastUnitField = loopUnitField;\n        }\n        \n        iTypes = (DateTimeFieldType[]) types.clone();\n        chronology.validate(this, values);\n        iValues = (int[]) values.clone();\n    }\n\n    \n    public Partial(ReadablePartial partial) {\n        super();\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        iChronology = DateTimeUtils.getChronology(partial.getChronology()).withUTC();\n        iTypes = new DateTimeFieldType[partial.size()];\n        iValues = new int[partial.size()];\n        for (int i = 0; i < partial.size(); i++) {\n            iTypes[i] = partial.getFieldType(i);\n            iValues[i] = partial.getValue(i);\n        }\n    }\n\n    \n    Partial(Partial partial, int[] values) {\n        super();\n        iChronology = partial.iChronology;\n        iTypes = partial.iTypes;\n        iValues = values;\n    }\n\n    \n    Partial(Chronology chronology, DateTimeFieldType[] types, int[] values) {\n        super();\n        iChronology = chronology;\n        iTypes = types;\n        iValues = values;\n    }\n\n    \n    \n    public int size() {\n        return iTypes.length;\n    }\n\n    \n    public Chronology getChronology() {\n        return iChronology;\n    }\n\n    \n    protected DateTimeField getField(int index, Chronology chrono) {\n        return iTypes[index].getField(chrono);\n    }\n\n    \n    public DateTimeFieldType getFieldType(int index) {\n        return iTypes[index];\n    }\n\n    \n    public DateTimeFieldType[] getFieldTypes() {\n        return (DateTimeFieldType[]) iTypes.clone();\n    }\n\n    \n    \n    public int getValue(int index) {\n        return iValues[index];\n    }\n\n    \n    public int[] getValues() {\n        return (int[]) iValues.clone();\n    }\n\n    \n    \n    public Partial withChronologyRetainFields(Chronology newChronology) {\n        newChronology = DateTimeUtils.getChronology(newChronology);\n        newChronology = newChronology.withUTC();\n        if (newChronology == getChronology()) {\n            return this;\n        } else {\n            Partial newPartial = new Partial(newChronology, iTypes, iValues);\n            newChronology.validate(newPartial, iValues);\n            return newPartial;\n        }\n    }\n\n    \n    \n    public Partial with(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        int index = indexOf(fieldType);\n        if (index == -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n            int[] newValues = new int[newTypes.length];\n            \n            \n            int i = 0;\n            DurationField unitField = fieldType.getDurationType().getField(iChronology);\n            if (unitField.isSupported()) {\n                for (; i < iTypes.length; i++) {\n                    DateTimeFieldType loopType = iTypes[i];\n                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                    if (loopUnitField.isSupported()) {\n                        int compare = unitField.compareTo(loopUnitField);\n                        if (compare > 0) {\n                            break;\n                        } else if (compare == 0) {\n                            if (fieldType.getRangeDurationType() == null) {\n                                break;\n                            }\n                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                            if (rangeField.compareTo(loopRangeField) > 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            System.arraycopy(iTypes, 0, newTypes, 0, i);\n            System.arraycopy(iValues, 0, newValues, 0, i);\n            newTypes[i] = fieldType;\n            newValues[i] = value;\n            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n            \n            \n            Partial newPartial = new Partial(newTypes, newValues, iChronology);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }\n\n    \n    public Partial without(DateTimeFieldType fieldType) {\n        int index = indexOf(fieldType);\n        if (index != -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1];\n            int[] newValues = new int[size() - 1];\n            System.arraycopy(iTypes, 0, newTypes, 0, index);\n            System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index);\n            System.arraycopy(iValues, 0, newValues, 0, index);\n            System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index);\n            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        return this;\n    }\n\n    \n    \n    public Partial withField(DateTimeFieldType fieldType, int value) {\n        int index = indexOfSupported(fieldType);\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }\n\n    \n    public Partial withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).add(this, index, newValues, amount);\n        return new Partial(this, newValues);\n    }\n\n    \n    public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).addWrapPartial(this, index, newValues, amount);\n        return new Partial(this, newValues);\n    }\n\n    \n    public Partial withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        for (int i = 0; i < period.size(); i++) {\n            DurationFieldType fieldType = period.getFieldType(i);\n            int index = indexOf(fieldType);\n            if (index >= 0) {\n                newValues = getField(index).add(this, index, newValues,\n                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n            }\n        }\n        return new Partial(this, newValues);\n    }\n\n    \n    public Partial plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }\n\n    \n    public Partial minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }\n\n    \n    \n    public Property property(DateTimeFieldType type) {\n        return new Property(this, indexOfSupported(type));\n    }\n\n    \n    \n    public boolean isMatch(ReadableInstant instant) {\n        long millis = DateTimeUtils.getInstantMillis(instant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n        for (int i = 0; i < iTypes.length; i++) {\n            int value = iTypes[i].getField(chrono).get(millis);\n            if (value != iValues[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public boolean isMatch(ReadablePartial partial) {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        for (int i = 0; i < iTypes.length; i++) {\n            int value = partial.get(iTypes[i]);\n            if (value != iValues[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    \n    public DateTimeFormatter getFormatter() {\n        DateTimeFormatter[] f = iFormatter;\n        if (f == null) {\n            if (size() == 0) {\n                return null;\n            }\n            f = new DateTimeFormatter[2];\n            try {\n                List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes));\n                f[0] = ISODateTimeFormat.forFields(list, true, false);\n                if (list.size() == 0) {\n                    f[1] = f[0];\n                }\n            } catch (IllegalArgumentException ex) {\n                \n            }\n            iFormatter = f;\n        }\n        return f[0];\n    }\n\n    \n    \n    public String toString() {\n        DateTimeFormatter[] f = iFormatter;\n        if (f == null) {\n            getFormatter();\n            f = iFormatter;\n            if (f == null) {\n                return toStringList();\n            }\n        }\n        DateTimeFormatter f1 = f[1];\n        if (f1 == null) {\n            return toStringList();\n        }\n        return f1.print(this);\n    }\n\n    \n    public String toStringList() {\n        int size = size();\n        StringBuilder buf = new StringBuilder(20 * size);\n        buf.append('[');\n        for (int i = 0; i < size; i++) {\n            if (i > 0) {\n                buf.append(',').append(' ');\n            }\n            buf.append(iTypes[i].getName());\n            buf.append('=');\n            buf.append(iValues[i]);\n        }\n        buf.append(']');\n        return buf.toString();\n    }\n\n    \n    public String toString(String pattern) {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).print(this);\n    }\n\n    \n    public String toString(String pattern, Locale locale) {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n    }\n\n    \n    \n    public static class Property extends AbstractPartialFieldProperty implements Serializable { private static final long serialVersionUID = 53278362873888L; private final Partial iPartial; private final int iFieldIndex; Property(Partial partial, int fieldIndex) {\n            super();\n            iPartial = partial;\n            iFieldIndex = fieldIndex;\n        }\n\n        \n        public DateTimeField getField() {\n            return iPartial.getField(iFieldIndex);\n        }\n\n        \n        protected ReadablePartial getReadablePartial() {\n            return iPartial;\n        }\n\n        \n        public Partial getPartial() {\n            return iPartial;\n        }\n\n        \n        public int get() {\n            return iPartial.getValue(iFieldIndex);\n        }\n\n        \n        \n        public Partial addToCopy(int valueToAdd) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().add(iPartial, iFieldIndex, newValues, valueToAdd);\n            return new Partial(iPartial, newValues);\n        }\n\n        \n        public Partial addWrapFieldToCopy(int valueToAdd) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().addWrapField(iPartial, iFieldIndex, newValues, valueToAdd);\n            return new Partial(iPartial, newValues);\n        }\n\n        \n        \n        public Partial setCopy(int value) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().set(iPartial, iFieldIndex, newValues, value);\n            return new Partial(iPartial, newValues);\n        }\n\n        \n        public Partial setCopy(String text, Locale locale) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().set(iPartial, iFieldIndex, newValues, text, locale);\n            return new Partial(iPartial, newValues);\n        }\n\n        \n        public Partial setCopy(String text) {\n            return setCopy(text, null);\n        }\n\n        \n        \n        public Partial withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }\n\n        \n        public Partial withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.joda.time;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.joda.time.base.AbstractPartial;\nimport org.joda.time.field.AbstractPartialFieldProperty;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n\npublic final class Partial extends AbstractPartial implements ReadablePartial, Serializable { private static final long serialVersionUID = 12324121189002L; private final Chronology iChronology; private final DateTimeFieldType[] iTypes; private final int[] iValues; private transient DateTimeFormatter[] iFormatter; public Partial() {\n        this((Chronology) null);\n    }\n\n    \n    public Partial(Chronology chrono) {\n        super();\n        iChronology = DateTimeUtils.getChronology(chrono).withUTC();\n        iTypes = new DateTimeFieldType[0];\n        iValues = new int[0];\n    }\n\n    \n    public Partial(DateTimeFieldType type, int value) {\n        this(type, value, null);\n    }\n\n    \n    public Partial(DateTimeFieldType type, int value, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (type == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        iTypes = new DateTimeFieldType[] {type};\n        iValues = new int[] {value};\n        chronology.validate(this, iValues);\n    }\n\n    \n    public Partial(DateTimeFieldType[] types, int[] values) {\n        this(types, values, null);\n    }\n\n    \n    public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (types == null) {\n            throw new IllegalArgumentException(\"Types array must not be null\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Values array must not be null\");\n        }\n        if (values.length != types.length) {\n            throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n        }\n        if (types.length == 0) {\n            iTypes = types;\n            iValues = values;\n            return;\n        }\n        for (int i = 0; i < types.length; i++) {\n            if (types[i] == null) {\n                throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n            }\n        }\n        DurationField lastUnitField = null;\n        for (int i = 0; i < types.length; i++) {\n            DateTimeFieldType loopType = types[i];\n            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n            if (i > 0) {\n                if (loopUnitField.isSupported() == false) {\n                    if (lastUnitField.isSupported()) {\n                        throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                        types[i - 1].getName() + \" < \" + loopType.getName());\n                    } else {\n                        throw new IllegalArgumentException(\"Types array must not contain duplicate unsupported: \" +\n                                        types[i - 1].getName() + \" and \" + loopType.getName());\n                    }\n                }\n                int compare = lastUnitField.compareTo(loopUnitField);\n                if (compare < 0) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }\n            }\n            lastUnitField = loopUnitField;\n        }\n        \n        iTypes = (DateTimeFieldType[]) types.clone();\n        chronology.validate(this, values);\n        iValues = (int[]) values.clone();\n    }\n\n    \n    public Partial(ReadablePartial partial) {\n        super();\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        iChronology = DateTimeUtils.getChronology(partial.getChronology()).withUTC();\n        iTypes = new DateTimeFieldType[partial.size()];\n        iValues = new int[partial.size()];\n        for (int i = 0; i < partial.size(); i++) {\n            iTypes[i] = partial.getFieldType(i);\n            iValues[i] = partial.getValue(i);\n        }\n    }\n\n    \n    Partial(Partial partial, int[] values) {\n        super();\n        iChronology = partial.iChronology;\n        iTypes = partial.iTypes;\n        iValues = values;\n    }\n\n    \n    Partial(Chronology chronology, DateTimeFieldType[] types, int[] values) {\n        super();\n        iChronology = chronology;\n        iTypes = types;\n        iValues = values;\n    }\n\n    \n    \n    public int size() {\n        return iTypes.length;\n    }\n\n    \n    public Chronology getChronology() {\n        return iChronology;\n    }\n\n    \n    protected DateTimeField getField(int index, Chronology chrono) {\n        return iTypes[index].getField(chrono);\n    }\n\n    \n    public DateTimeFieldType getFieldType(int index) {\n        return iTypes[index];\n    }\n\n    \n    public DateTimeFieldType[] getFieldTypes() {\n        return (DateTimeFieldType[]) iTypes.clone();\n    }\n\n    \n    \n    public int getValue(int index) {\n        return iValues[index];\n    }\n\n    \n    public int[] getValues() {\n        return (int[]) iValues.clone();\n    }\n\n    \n    \n    public Partial withChronologyRetainFields(Chronology newChronology) {\n        newChronology = DateTimeUtils.getChronology(newChronology);\n        newChronology = newChronology.withUTC();\n        if (newChronology == getChronology()) {\n            return this;\n        } else {\n            Partial newPartial = new Partial(newChronology, iTypes, iValues);\n            newChronology.validate(newPartial, iValues);\n            return newPartial;\n        }\n    }\n\n    \n    \n    public Partial with(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        int index = indexOf(fieldType);\n        if (index == -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n            int[] newValues = new int[newTypes.length];\n            \n            \n            int i = 0;\n            DurationField unitField = fieldType.getDurationType().getField(iChronology);\n            if (unitField.isSupported()) {\n                for (; i < iTypes.length; i++) {\n                    DateTimeFieldType loopType = iTypes[i];\n                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                    if (loopUnitField.isSupported()) {\n                        int compare = unitField.compareTo(loopUnitField);\n                        if (compare > 0) {\n                            break;\n                        } else if (compare == 0) {\n                            if (fieldType.getRangeDurationType() == null) {\n                                break;\n                            }\n                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                            if (rangeField.compareTo(loopRangeField) > 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            System.arraycopy(iTypes, 0, newTypes, 0, i);\n            System.arraycopy(iValues, 0, newValues, 0, i);\n            newTypes[i] = fieldType;\n            newValues[i] = value;\n            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n            \n            \n            Partial newPartial = new Partial(newTypes, newValues, iChronology);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }\n\n    \n    public Partial without(DateTimeFieldType fieldType) {\n        int index = indexOf(fieldType);\n        if (index != -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1];\n            int[] newValues = new int[size() - 1];\n            System.arraycopy(iTypes, 0, newTypes, 0, index);\n            System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index);\n            System.arraycopy(iValues, 0, newValues, 0, index);\n            System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index);\n            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        return this;\n    }\n\n    \n    \n    public Partial withField(DateTimeFieldType fieldType, int value) {\n        int index = indexOfSupported(fieldType);\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }\n\n    \n    public Partial withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).add(this, index, newValues, amount);\n        return new Partial(this, newValues);\n    }\n\n    \n    public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).addWrapPartial(this, index, newValues, amount);\n        return new Partial(this, newValues);\n    }\n\n    \n    public Partial withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        for (int i = 0; i < period.size(); i++) {\n            DurationFieldType fieldType = period.getFieldType(i);\n            int index = indexOf(fieldType);\n            if (index >= 0) {\n                newValues = getField(index).add(this, index, newValues,\n                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n            }\n        }\n        return new Partial(this, newValues);\n    }\n\n    \n    public Partial plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }\n\n    \n    public Partial minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }\n\n    \n    \n    public Property property(DateTimeFieldType type) {\n        return new Property(this, indexOfSupported(type));\n    }\n\n    \n    \n    public boolean isMatch(ReadableInstant instant) {\n        long millis = DateTimeUtils.getInstantMillis(instant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n        for (int i = 0; i < iTypes.length; i++) {\n            int value = iTypes[i].getField(chrono).get(millis);\n            if (value != iValues[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public boolean isMatch(ReadablePartial partial) {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        for (int i = 0; i < iTypes.length; i++) {\n            int value = partial.get(iTypes[i]);\n            if (value != iValues[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    \n    public DateTimeFormatter getFormatter() {\n        DateTimeFormatter[] f = iFormatter;\n        if (f == null) {\n            if (size() == 0) {\n                return null;\n            }\n            f = new DateTimeFormatter[2];\n            try {\n                List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes));\n                f[0] = ISODateTimeFormat.forFields(list, true, false);\n                if (list.size() == 0) {\n                    f[1] = f[0];\n                }\n            } catch (IllegalArgumentException ex) {\n                \n            }\n            iFormatter = f;\n        }\n        return f[0];\n    }\n\n    \n    \n    public String toString() {\n        DateTimeFormatter[] f = iFormatter;\n        if (f == null) {\n            getFormatter();\n            f = iFormatter;\n            if (f == null) {\n                return toStringList();\n            }\n        }\n        DateTimeFormatter f1 = f[1];\n        if (f1 == null) {\n            return toStringList();\n        }\n        return f1.print(this);\n    }\n\n    \n    public String toStringList() {\n        int size = size();\n        StringBuilder buf = new StringBuilder(20 * size);\n        buf.append('[');\n        for (int i = 0; i < size; i++) {\n            if (i > 0) {\n                buf.append(',').append(' ');\n            }\n            buf.append(iTypes[i].getName());\n            buf.append('=');\n            buf.append(iValues[i]);\n        }\n        buf.append(']');\n        return buf.toString();\n    }\n\n    \n    public String toString(String pattern) {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).print(this);\n    }\n\n    \n    public String toString(String pattern, Locale locale) {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n    }\n\n    \n    \n    public static class Property extends AbstractPartialFieldProperty implements Serializable { private static final long serialVersionUID = 53278362873888L; private final Partial iPartial; private final int iFieldIndex; Property(Partial partial, int fieldIndex) {\n            super();\n            iPartial = partial;\n            iFieldIndex = fieldIndex;\n        }\n\n        \n        public DateTimeField getField() {\n            return iPartial.getField(iFieldIndex);\n        }\n\n        \n        protected ReadablePartial getReadablePartial() {\n            return iPartial;\n        }\n\n        \n        public Partial getPartial() {\n            return iPartial;\n        }\n\n        \n        public int get() {\n            return iPartial.getValue(iFieldIndex);\n        }\n\n        \n        \n        public Partial addToCopy(int valueToAdd) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().add(iPartial, iFieldIndex, newValues, valueToAdd);\n            return new Partial(iPartial, newValues);\n        }\n\n        \n        public Partial addWrapFieldToCopy(int valueToAdd) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().addWrapField(iPartial, iFieldIndex, newValues, valueToAdd);\n            return new Partial(iPartial, newValues);\n        }\n\n        \n        \n        public Partial setCopy(int value) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().set(iPartial, iFieldIndex, newValues, value);\n            return new Partial(iPartial, newValues);\n        }\n\n        \n        public Partial setCopy(String text, Locale locale) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().set(iPartial, iFieldIndex, newValues, text, locale);\n            return new Partial(iPartial, newValues);\n        }\n\n        \n        public Partial setCopy(String text) {\n            return setCopy(text, null);\n        }\n\n        \n        \n        public Partial withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }\n\n        \n        public Partial withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }\n    }\n\n}\n",
      "buggy_signatures": [
        "public Partial(Chronology chrono)",
        "public Partial(DateTimeFieldType type, int value)",
        "public Partial(DateTimeFieldType type, int value, Chronology chronology)",
        "public Partial(DateTimeFieldType[] types, int[] values)",
        "public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology)",
        "public Partial(ReadablePartial partial)",
        "public int size()",
        "public Chronology getChronology()",
        "protected DateTimeField getField(int index, Chronology chrono)",
        "public DateTimeFieldType getFieldType(int index)",
        "public DateTimeFieldType[] getFieldTypes()",
        "public int getValue(int index)",
        "public int[] getValues()",
        "public Partial withChronologyRetainFields(Chronology newChronology)",
        "public Partial with(DateTimeFieldType fieldType, int value)",
        "public Partial without(DateTimeFieldType fieldType)",
        "public Partial withField(DateTimeFieldType fieldType, int value)",
        "public Partial withFieldAdded(DurationFieldType fieldType, int amount)",
        "public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount)",
        "public Partial withPeriodAdded(ReadablePeriod period, int scalar)",
        "public Partial plus(ReadablePeriod period)",
        "public Partial minus(ReadablePeriod period)",
        "public Property property(DateTimeFieldType type)",
        "public boolean isMatch(ReadableInstant instant)",
        "public boolean isMatch(ReadablePartial partial)",
        "public DateTimeFormatter getFormatter()",
        "public String toString()",
        "public String toStringList()",
        "public String toString(String pattern)",
        "public String toString(String pattern, Locale locale)",
        "public DateTimeField getField()",
        "protected ReadablePartial getReadablePartial()",
        "public Partial getPartial()",
        "public int get()",
        "public Partial addToCopy(int valueToAdd)",
        "public Partial addWrapFieldToCopy(int valueToAdd)",
        "public Partial setCopy(int value)",
        "public Partial setCopy(String text, Locale locale)",
        "public Partial setCopy(String text)",
        "public Partial withMaximumValue()",
        "public Partial withMinimumValue()"
      ],
      "fixed_signatures": [
        "public Partial(Chronology chrono)",
        "public Partial(DateTimeFieldType type, int value)",
        "public Partial(DateTimeFieldType type, int value, Chronology chronology)",
        "public Partial(DateTimeFieldType[] types, int[] values)",
        "public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology)",
        "public Partial(ReadablePartial partial)",
        "public int size()",
        "public Chronology getChronology()",
        "protected DateTimeField getField(int index, Chronology chrono)",
        "public DateTimeFieldType getFieldType(int index)",
        "public DateTimeFieldType[] getFieldTypes()",
        "public int getValue(int index)",
        "public int[] getValues()",
        "public Partial withChronologyRetainFields(Chronology newChronology)",
        "public Partial with(DateTimeFieldType fieldType, int value)",
        "public Partial without(DateTimeFieldType fieldType)",
        "public Partial withField(DateTimeFieldType fieldType, int value)",
        "public Partial withFieldAdded(DurationFieldType fieldType, int amount)",
        "public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount)",
        "public Partial withPeriodAdded(ReadablePeriod period, int scalar)",
        "public Partial plus(ReadablePeriod period)",
        "public Partial minus(ReadablePeriod period)",
        "public Property property(DateTimeFieldType type)",
        "public boolean isMatch(ReadableInstant instant)",
        "public boolean isMatch(ReadablePartial partial)",
        "public DateTimeFormatter getFormatter()",
        "public String toString()",
        "public String toStringList()",
        "public String toString(String pattern)",
        "public String toString(String pattern, Locale locale)",
        "public DateTimeField getField()",
        "protected ReadablePartial getReadablePartial()",
        "public Partial getPartial()",
        "public int get()",
        "public Partial addToCopy(int valueToAdd)",
        "public Partial addWrapFieldToCopy(int valueToAdd)",
        "public Partial setCopy(int value)",
        "public Partial setCopy(String text, Locale locale)",
        "public Partial setCopy(String text)",
        "public Partial withMaximumValue()",
        "public Partial withMinimumValue()"
      ],
      "methods": [
        {
          "buggy_method": "  public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n  super();\n  chronology = DateTimeUtils.getChronology(chronology).withUTC();\n  iChronology = chronology;\n  if (types == null) {\n  throw new IllegalArgumentException(\"Types array must not be null\");\n  }\n  if (values == null) {\n  throw new IllegalArgumentException(\"Values array must not be null\");\n  }\n  if (values.length != types.length) {\n  throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n  }\n  if (types.length == 0) {\n  iTypes = types;\n  iValues = values;\n  return;\n  }\n  for (int i = 0; i < types.length; i++) {\n  if (types[i] == null) {\n  throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n  }\n  }\n  DurationField lastUnitField = null;\n  for (int i = 0; i < types.length; i++) {\n  DateTimeFieldType loopType = types[i];\n  DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n  if (i > 0) {\n  int compare = lastUnitField.compareTo(loopUnitField);\n  if (compare < 0) {\n  throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n  types[i - 1].getName() + \" < \" + loopType.getName());\n  } else if (compare == 0) {\n  if (types[i - 1].getRangeDurationType() == null) {\n  if (loopType.getRangeDurationType() == null) {\n  throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n  types[i - 1].getName() + \" and \" + loopType.getName());\n  }\n  } else {\n  if (loopType.getRangeDurationType() == null) {\n  throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n  types[i - 1].getName() + \" < \" + loopType.getName());\n  }\n  DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n  DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n  if (lastRangeField.compareTo(loopRangeField) < 0) {\n  throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n  types[i - 1].getName() + \" < \" + loopType.getName());\n  }\n  if (lastRangeField.compareTo(loopRangeField) == 0) {\n  throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n  types[i - 1].getName() + \" and \" + loopType.getName());\n  }\n  }\n  }\n  }\n  lastUnitField = loopUnitField;\n  }\n  \n  iTypes = (DateTimeFieldType[]) types.clone();\n  chronology.validate(this, values);\n  iValues = (int[]) values.clone();\n  }",
          "fixed_method": "  public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n  super();\n  chronology = DateTimeUtils.getChronology(chronology).withUTC();\n  iChronology = chronology;\n  if (types == null) {\n  throw new IllegalArgumentException(\"Types array must not be null\");\n  }\n  if (values == null) {\n  throw new IllegalArgumentException(\"Values array must not be null\");\n  }\n  if (values.length != types.length) {\n  throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n  }\n  if (types.length == 0) {\n  iTypes = types;\n  iValues = values;\n  return;\n  }\n  for (int i = 0; i < types.length; i++) {\n  if (types[i] == null) {\n  throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n  }\n  }\n  DurationField lastUnitField = null;\n  for (int i = 0; i < types.length; i++) {\n  DateTimeFieldType loopType = types[i];\n  DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n  if (i > 0) {\n  if (loopUnitField.isSupported() == false) {\n  if (lastUnitField.isSupported()) {\n  throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n  types[i - 1].getName() + \" < \" + loopType.getName());\n  } else {\n  throw new IllegalArgumentException(\"Types array must not contain duplicate unsupported: \" +\n  types[i - 1].getName() + \" and \" + loopType.getName());\n  }\n  }\n  int compare = lastUnitField.compareTo(loopUnitField);\n  if (compare < 0) {\n  throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n  types[i - 1].getName() + \" < \" + loopType.getName());\n  } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {\n  if (types[i - 1].getRangeDurationType() == null) {\n  if (loopType.getRangeDurationType() == null) {\n  throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n  types[i - 1].getName() + \" and \" + loopType.getName());\n  }\n  } else {\n  if (loopType.getRangeDurationType() == null) {\n  throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n  types[i - 1].getName() + \" < \" + loopType.getName());\n  }\n  DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n  DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n  if (lastRangeField.compareTo(loopRangeField) < 0) {\n  throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n  types[i - 1].getName() + \" < \" + loopType.getName());\n  }\n  if (lastRangeField.compareTo(loopRangeField) == 0) {\n  throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n  types[i - 1].getName() + \" and \" + loopType.getName());\n  }\n  }\n  }\n  }\n  lastUnitField = loopUnitField;\n  }\n  \n  iTypes = (DateTimeFieldType[]) types.clone();\n  chronology.validate(this, values);\n  iValues = (int[]) values.clone();\n  }",
          "diff": [
            "@@ -214,11 +214,20 @@",
            "             DateTimeFieldType loopType = types[i];\n",
            "             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n",
            "             if (i > 0) {\n",
            "+                if (loopUnitField.isSupported() == false) {\n",
            "+                    if (lastUnitField.isSupported()) {\n",
            "+                        throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n",
            "+                                        types[i - 1].getName() + \" < \" + loopType.getName());\n",
            "+                    } else {\n",
            "+                        throw new IllegalArgumentException(\"Types array must not contain duplicate unsupported: \" +\n",
            "+                                        types[i - 1].getName() + \" and \" + loopType.getName());\n",
            "+                    }\n",
            "+                }\n",
            "                 int compare = lastUnitField.compareTo(loopUnitField);\n",
            "                 if (compare < 0) {\n",
            "                     throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n",
            "                             types[i - 1].getName() + \" < \" + loopType.getName());\n",
            "-                } else if (compare == 0) {\n",
            "+                } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {\n",
            "                     if (types[i - 1].getRangeDurationType() == null) {\n",
            "                         if (loopType.getRangeDurationType() == null) {\n",
            "                             throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n"
          ],
          "changed_lines": 11
        }
      ]
    }
  ]
}
