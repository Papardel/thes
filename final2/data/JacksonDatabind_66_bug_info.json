{
  "bug_id": "66",
  "failed_tests": {
    "com.fasterxml.jackson.databind.module.TestCustomEnumKeyDeserializer": [
      {
        "methodName": "testCustomEnumKeySerializerWithPolymorphic",
        "error": "com.fasterxml.jackson.databind.exc.InvalidFormatException",
        "message": "Can not deserialize Map key of type com.fasterxml.jackson.databind.module.TestCustomEnumKeyDeserializer$SuperTypeEnum from String \"FOO\": not a valid representation: No enum constant com.fasterxml.jackson.databind.module.TestCustomEnumKeyDeserializer.SuperTypeEnum.}",
        "fail_line": "        SuperType superType = mapper.readValue(\"{\\\"someMap\\\": {\\\"FOO\\\": \\\"bar\\\"}}\",",
        "test_source": "  public void testCustomEnumKeySerializerWithPolymorphic() throws IOException {\n  SimpleModule simpleModule = new SimpleModule();\n  simpleModule.addDeserializer(SuperTypeEnum.class, new JsonDeserializer<SuperTypeEnum>() {\n  @Override\n  public SuperTypeEnum deserialize(JsonParser p, DeserializationContext deserializationContext) throws IOException {\n  return SuperTypeEnum.valueOf(p.getText());\n  }\n  });\n  ObjectMapper mapper = new ObjectMapper()\n  .registerModule(simpleModule);\n\n  SuperType superType = mapper.readValue(\"{\\\"someMap\\\": {\\\"FOO\\\": \\\"bar\\\"}}\",\n  SuperType.class);\n  assertEquals(\"Deserialized someMap.FOO should equal bar\", \"bar\",\n  superType.someMap.get(SuperTypeEnum.FOO));\n  }",
        "stack": [
          "InvalidFormatException.from line 74, DeserializationContext.weirdKeyException line 1389, DeserializationContext.handleWeirdKey line 880, StdKeyDeserializer$DelegatingKD.deserializeKey line 322, MapDeserializer._readAndBind line 445, MapDeserializer.deserialize line 365, MapDeserializer.deserialize line 27, SettableBeanProperty.deserialize line 499, FieldProperty.deserializeAndSet line 108, BeanDeserializer.vanillaDeserialize line 276, BeanDeserializer._deserializeOther line 178, BeanDeserializer.deserialize line 150, AsPropertyTypeDeserializer._deserializeTypedUsingDefaultImpl line 146, AsPropertyTypeDeserializer.deserializeTypedFromObject line 105, BeanDeserializerBase.deserializeWithType line 1089, TypeWrappedDeserializer.deserialize line 63, ObjectMapper._readMapAndClose line 3798, ObjectMapper.readValue line 2842, TestCustomEnumKeyDeserializer.testCustomEnumKeySerializerWithPolymorphic line 221"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.core.io.NumberInput;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.EnumResolver;\n\n\n@JacksonStdImpl\npublic class StdKeyDeserializer extends KeyDeserializer implements java.io.Serializable { private static final long serialVersionUID = 1L; public final static int TYPE_BOOLEAN = 1; public final static int TYPE_BYTE = 2; public final static int TYPE_SHORT = 3; public final static int TYPE_CHAR = 4; public final static int TYPE_INT = 5; public final static int TYPE_LONG = 6; public final static int TYPE_FLOAT = 7; public final static int TYPE_DOUBLE = 8; public final static int TYPE_LOCALE = 9; public final static int TYPE_DATE = 10; public final static int TYPE_CALENDAR = 11; public final static int TYPE_UUID = 12; public final static int TYPE_URI = 13; public final static int TYPE_URL = 14; public final static int TYPE_CLASS = 15; public final static int TYPE_CURRENCY = 16; final protected int _kind; final protected Class<?> _keyClass; protected final FromStringDeserializer<?> _deser; protected StdKeyDeserializer(int kind, Class<?> cls) {\n        this(kind, cls, null);\n    }\n\n    protected StdKeyDeserializer(int kind, Class<?> cls, FromStringDeserializer<?> deser) {\n        _kind = kind;\n        _keyClass = cls;\n        _deser = deser;\n    }\n\n    public static StdKeyDeserializer forType(Class<?> raw) {\n        int kind;\n\n        \n        if (raw == String.class || raw == Object.class) {\n            return StringKD.forType(raw);\n        } else if (raw == UUID.class) {\n            kind = TYPE_UUID;\n        } else if (raw == Integer.class) {\n            kind = TYPE_INT;\n        } else if (raw == Long.class) {\n            kind = TYPE_LONG;\n        } else if (raw == Date.class) {\n            kind = TYPE_DATE;\n        } else if (raw == Calendar.class) {\n            kind = TYPE_CALENDAR;\n        \n        } else if (raw == Boolean.class) {\n            kind = TYPE_BOOLEAN;\n        } else if (raw == Byte.class) {\n            kind = TYPE_BYTE;\n        } else if (raw == Character.class) {\n            kind = TYPE_CHAR;\n        } else if (raw == Short.class) {\n            kind = TYPE_SHORT;\n        } else if (raw == Float.class) {\n            kind = TYPE_FLOAT;\n        } else if (raw == Double.class) {\n            kind = TYPE_DOUBLE;\n        } else if (raw == URI.class) {\n            kind = TYPE_URI;\n        } else if (raw == URL.class) {\n            kind = TYPE_URL;\n        } else if (raw == Class.class) {\n            kind = TYPE_CLASS;\n        } else if (raw == Locale.class) {\n            FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class);\n            return new StdKeyDeserializer(TYPE_LOCALE, raw, deser);\n        } else if (raw == Currency.class) {\n            FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class);\n            return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser);\n        } else {\n            return null;\n        }\n        return new StdKeyDeserializer(kind, raw);\n    }\n\n    @Override\n    public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n        if (key == null) { \n            return null;\n        }\n        try {\n            Object result = _parse(key, ctxt);\n            if (result != null) {\n                return result;\n            }\n        } catch (Exception re) {\n            return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\",\n                    re.getClass().getName(), re.getMessage());\n        }\n        if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            return null;\n        }\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n    }\n\n    public Class<?> getKeyClass() { return _keyClass; }\n\n    protected Object _parse(String key, DeserializationContext ctxt) throws Exception {\n        switch (_kind) {\n        case TYPE_BOOLEAN:\n            if (\"true\".equals(key)) {\n                return Boolean.TRUE;\n            }\n            if (\"false\".equals(key)) {\n                return Boolean.FALSE;\n            }\n            return ctxt.handleWeirdKey(_keyClass, key, \"value not 'true' or 'false'\");\n        case TYPE_BYTE:\n            {\n                int value = _parseInt(key);\n                \n                if (value < Byte.MIN_VALUE || value > 255) {\n                    return ctxt.handleWeirdKey(_keyClass, key, \"overflow, value can not be represented as 8-bit value\");\n                }\n                return Byte.valueOf((byte) value);\n            }\n        case TYPE_SHORT:\n            {\n                int value = _parseInt(key);\n                if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {\n                    return ctxt.handleWeirdKey(_keyClass, key, \"overflow, value can not be represented as 16-bit value\");\n                    \n                }\n                return Short.valueOf((short) value);\n            }\n        case TYPE_CHAR:\n            if (key.length() == 1) {\n                return Character.valueOf(key.charAt(0));\n            }\n            return ctxt.handleWeirdKey(_keyClass, key, \"can only convert 1-character Strings\");\n        case TYPE_INT:\n            return _parseInt(key);\n\n        case TYPE_LONG:\n            return _parseLong(key);\n\n        case TYPE_FLOAT:\n            \n            return Float.valueOf((float) _parseDouble(key));\n        case TYPE_DOUBLE:\n            return _parseDouble(key);\n        case TYPE_LOCALE:\n            try {\n                return _deser._deserialize(key, ctxt);\n            } catch (IOException e) {\n                return ctxt.handleWeirdKey(_keyClass, key, \"unable to parse key as locale\");\n            }\n        case TYPE_CURRENCY:\n            try {\n                return _deser._deserialize(key, ctxt);\n            } catch (IOException e) {\n                return ctxt.handleWeirdKey(_keyClass, key, \"unable to parse key as currency\");\n            }\n        case TYPE_DATE:\n            return ctxt.parseDate(key);\n        case TYPE_CALENDAR:\n            java.util.Date date = ctxt.parseDate(key);\n            return (date == null)  ? null : ctxt.constructCalendar(date);\n        case TYPE_UUID:\n            try {\n                return UUID.fromString(key);\n            } catch (Exception e) {\n                return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\", e.getMessage());\n            }\n        case TYPE_URI:\n            try {\n                return URI.create(key);\n            } catch (Exception e) {\n                return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\", e.getMessage());\n            }\n        case TYPE_URL:\n            try {\n                return new URL(key);\n            } catch (MalformedURLException e) {\n                return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\", e.getMessage());\n            }\n        case TYPE_CLASS:\n            try {\n                return ctxt.findClass(key);\n            } catch (Exception e) {\n                return ctxt.handleWeirdKey(_keyClass, key, \"unable to parse key as Class\");\n            }\n        default:\n            throw new IllegalStateException(\"Internal error: unknown key type \"+_keyClass);\n        }\n    }\n\n    \n\n    protected int _parseInt(String key) throws IllegalArgumentException {\n        return Integer.parseInt(key);\n    }\n\n    protected long _parseLong(String key) throws IllegalArgumentException {\n        return Long.parseLong(key);\n    }\n\n    protected double _parseDouble(String key) throws IllegalArgumentException {\n        return NumberInput.parseDouble(key);\n    }\n\n    \n\n    @JacksonStdImpl\n    final static class StringKD extends StdKeyDeserializer { private static final long serialVersionUID = 1L; private final static StringKD sString = new StringKD(String.class); private final static StringKD sObject = new StringKD(Object.class); private StringKD(Class<?> nominalType) { super(-1, nominalType); }\n\n        public static StringKD forType(Class<?> nominalType) {\n            if (nominalType == String.class) {\n                return sString;\n            }\n            if (nominalType == Object.class) {\n                return sObject;\n            }\n            return new StringKD(nominalType);\n        }\n\n        @Override\n        public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n            return key;\n        }\n    }    \n\n    \n\n    \n    final static class DelegatingKD extends KeyDeserializer implements java.io.Serializable { private static final long serialVersionUID = 1L; final protected Class<?> _keyClass; protected final JsonDeserializer<?> _delegate; protected DelegatingKD(Class<?> cls, JsonDeserializer<?> deser) {\n            _keyClass = cls;\n            _delegate = deser;\n        }\n\n        @SuppressWarnings(\"resource\")\n        @Override\n        public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n            if (key == null) { \n                return null;\n            }\n            try {\n                \n                Object result = _delegate.deserialize(ctxt.getParser(), ctxt);\n                if (result != null) {\n                    return result;\n                }\n                return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n            } catch (Exception re) {\n                return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation: %s\", re.getMessage());\n            }\n        }\n\n        public Class<?> getKeyClass() { return _keyClass; }\n    }\n     \n    @JacksonStdImpl\n    final static class EnumKD extends StdKeyDeserializer { private static final long serialVersionUID = 1L; protected final EnumResolver _byNameResolver; protected final AnnotatedMethod _factory; protected EnumResolver _byToStringResolver; protected EnumKD(EnumResolver er, AnnotatedMethod factory) {\n            super(-1, er.getEnumClass());\n            _byNameResolver = er;\n            _factory = factory;\n        }\n\n        @Override\n        public Object _parse(String key, DeserializationContext ctxt) throws IOException {\n            if (_factory != null) {\n                try {\n                    return _factory.call1(key);\n                } catch (Exception e) {\n                    ClassUtil.unwrapAndThrowAsIAE(e);\n                }\n            }\n            EnumResolver res = ctxt.isEnabled(DeserializationFeature.READ_ENUMS_USING_TO_STRING)\n                    ? _getToStringResolver(ctxt) : _byNameResolver;\n            Enum<?> e = res.findEnum(key);\n            if ((e == null) && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n                return ctxt.handleWeirdKey(_keyClass, key, \"not one of values excepted for Enum class: %s\",\n                        res.getEnumIds());\n                \n            }\n            return e;\n        }\n\n        private EnumResolver _getToStringResolver(DeserializationContext ctxt) {\n            EnumResolver res = _byToStringResolver;\n            if (res == null) {\n                synchronized (this) {\n                    res = EnumResolver.constructUnsafeUsingToString(_byNameResolver.getEnumClass(),\n                            ctxt.getAnnotationIntrospector());\n                }\n            }\n            return res;\n        }\n    }\n    \n    \n    final static class StringCtorKeyDeserializer extends StdKeyDeserializer { private static final long serialVersionUID = 1L; protected final Constructor<?> _ctor; public StringCtorKeyDeserializer(Constructor<?> ctor) {\n            super(-1, ctor.getDeclaringClass());\n            _ctor = ctor;\n        }\n\n        @Override\n        public Object _parse(String key, DeserializationContext ctxt) throws Exception {\n            return _ctor.newInstance(key);\n        }\n    }\n\n    \n    final static class StringFactoryKeyDeserializer extends StdKeyDeserializer { private static final long serialVersionUID = 1L; final Method _factoryMethod; public StringFactoryKeyDeserializer(Method fm) {\n            super(-1, fm.getDeclaringClass());\n            _factoryMethod = fm;\n        }\n\n        @Override\n        public Object _parse(String key, DeserializationContext ctxt) throws Exception {\n            return _factoryMethod.invoke(null, key);\n        }\n    }\n}\n\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.core.io.NumberInput;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.EnumResolver;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n\n@JacksonStdImpl\npublic class StdKeyDeserializer extends KeyDeserializer implements java.io.Serializable { private static final long serialVersionUID = 1L; public final static int TYPE_BOOLEAN = 1; public final static int TYPE_BYTE = 2; public final static int TYPE_SHORT = 3; public final static int TYPE_CHAR = 4; public final static int TYPE_INT = 5; public final static int TYPE_LONG = 6; public final static int TYPE_FLOAT = 7; public final static int TYPE_DOUBLE = 8; public final static int TYPE_LOCALE = 9; public final static int TYPE_DATE = 10; public final static int TYPE_CALENDAR = 11; public final static int TYPE_UUID = 12; public final static int TYPE_URI = 13; public final static int TYPE_URL = 14; public final static int TYPE_CLASS = 15; public final static int TYPE_CURRENCY = 16; final protected int _kind; final protected Class<?> _keyClass; protected final FromStringDeserializer<?> _deser; protected StdKeyDeserializer(int kind, Class<?> cls) {\n        this(kind, cls, null);\n    }\n\n    protected StdKeyDeserializer(int kind, Class<?> cls, FromStringDeserializer<?> deser) {\n        _kind = kind;\n        _keyClass = cls;\n        _deser = deser;\n    }\n\n    public static StdKeyDeserializer forType(Class<?> raw) {\n        int kind;\n\n        \n        if (raw == String.class || raw == Object.class) {\n            return StringKD.forType(raw);\n        } else if (raw == UUID.class) {\n            kind = TYPE_UUID;\n        } else if (raw == Integer.class) {\n            kind = TYPE_INT;\n        } else if (raw == Long.class) {\n            kind = TYPE_LONG;\n        } else if (raw == Date.class) {\n            kind = TYPE_DATE;\n        } else if (raw == Calendar.class) {\n            kind = TYPE_CALENDAR;\n        \n        } else if (raw == Boolean.class) {\n            kind = TYPE_BOOLEAN;\n        } else if (raw == Byte.class) {\n            kind = TYPE_BYTE;\n        } else if (raw == Character.class) {\n            kind = TYPE_CHAR;\n        } else if (raw == Short.class) {\n            kind = TYPE_SHORT;\n        } else if (raw == Float.class) {\n            kind = TYPE_FLOAT;\n        } else if (raw == Double.class) {\n            kind = TYPE_DOUBLE;\n        } else if (raw == URI.class) {\n            kind = TYPE_URI;\n        } else if (raw == URL.class) {\n            kind = TYPE_URL;\n        } else if (raw == Class.class) {\n            kind = TYPE_CLASS;\n        } else if (raw == Locale.class) {\n            FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class);\n            return new StdKeyDeserializer(TYPE_LOCALE, raw, deser);\n        } else if (raw == Currency.class) {\n            FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class);\n            return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser);\n        } else {\n            return null;\n        }\n        return new StdKeyDeserializer(kind, raw);\n    }\n\n    @Override\n    public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n        if (key == null) { \n            return null;\n        }\n        try {\n            Object result = _parse(key, ctxt);\n            if (result != null) {\n                return result;\n            }\n        } catch (Exception re) {\n            return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\",\n                    re.getClass().getName(), re.getMessage());\n        }\n        if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            return null;\n        }\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n    }\n\n    public Class<?> getKeyClass() { return _keyClass; }\n\n    protected Object _parse(String key, DeserializationContext ctxt) throws Exception {\n        switch (_kind) {\n        case TYPE_BOOLEAN:\n            if (\"true\".equals(key)) {\n                return Boolean.TRUE;\n            }\n            if (\"false\".equals(key)) {\n                return Boolean.FALSE;\n            }\n            return ctxt.handleWeirdKey(_keyClass, key, \"value not 'true' or 'false'\");\n        case TYPE_BYTE:\n            {\n                int value = _parseInt(key);\n                \n                if (value < Byte.MIN_VALUE || value > 255) {\n                    return ctxt.handleWeirdKey(_keyClass, key, \"overflow, value can not be represented as 8-bit value\");\n                }\n                return Byte.valueOf((byte) value);\n            }\n        case TYPE_SHORT:\n            {\n                int value = _parseInt(key);\n                if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {\n                    return ctxt.handleWeirdKey(_keyClass, key, \"overflow, value can not be represented as 16-bit value\");\n                    \n                }\n                return Short.valueOf((short) value);\n            }\n        case TYPE_CHAR:\n            if (key.length() == 1) {\n                return Character.valueOf(key.charAt(0));\n            }\n            return ctxt.handleWeirdKey(_keyClass, key, \"can only convert 1-character Strings\");\n        case TYPE_INT:\n            return _parseInt(key);\n\n        case TYPE_LONG:\n            return _parseLong(key);\n\n        case TYPE_FLOAT:\n            \n            return Float.valueOf((float) _parseDouble(key));\n        case TYPE_DOUBLE:\n            return _parseDouble(key);\n        case TYPE_LOCALE:\n            try {\n                return _deser._deserialize(key, ctxt);\n            } catch (IOException e) {\n                return ctxt.handleWeirdKey(_keyClass, key, \"unable to parse key as locale\");\n            }\n        case TYPE_CURRENCY:\n            try {\n                return _deser._deserialize(key, ctxt);\n            } catch (IOException e) {\n                return ctxt.handleWeirdKey(_keyClass, key, \"unable to parse key as currency\");\n            }\n        case TYPE_DATE:\n            return ctxt.parseDate(key);\n        case TYPE_CALENDAR:\n            java.util.Date date = ctxt.parseDate(key);\n            return (date == null)  ? null : ctxt.constructCalendar(date);\n        case TYPE_UUID:\n            try {\n                return UUID.fromString(key);\n            } catch (Exception e) {\n                return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\", e.getMessage());\n            }\n        case TYPE_URI:\n            try {\n                return URI.create(key);\n            } catch (Exception e) {\n                return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\", e.getMessage());\n            }\n        case TYPE_URL:\n            try {\n                return new URL(key);\n            } catch (MalformedURLException e) {\n                return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\", e.getMessage());\n            }\n        case TYPE_CLASS:\n            try {\n                return ctxt.findClass(key);\n            } catch (Exception e) {\n                return ctxt.handleWeirdKey(_keyClass, key, \"unable to parse key as Class\");\n            }\n        default:\n            throw new IllegalStateException(\"Internal error: unknown key type \"+_keyClass);\n        }\n    }\n\n    \n\n    protected int _parseInt(String key) throws IllegalArgumentException {\n        return Integer.parseInt(key);\n    }\n\n    protected long _parseLong(String key) throws IllegalArgumentException {\n        return Long.parseLong(key);\n    }\n\n    protected double _parseDouble(String key) throws IllegalArgumentException {\n        return NumberInput.parseDouble(key);\n    }\n\n    \n\n    @JacksonStdImpl\n    final static class StringKD extends StdKeyDeserializer { private static final long serialVersionUID = 1L; private final static StringKD sString = new StringKD(String.class); private final static StringKD sObject = new StringKD(Object.class); private StringKD(Class<?> nominalType) { super(-1, nominalType); }\n\n        public static StringKD forType(Class<?> nominalType) {\n            if (nominalType == String.class) {\n                return sString;\n            }\n            if (nominalType == Object.class) {\n                return sObject;\n            }\n            return new StringKD(nominalType);\n        }\n\n        @Override\n        public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n            return key;\n        }\n    }    \n\n    \n\n    \n    final static class DelegatingKD extends KeyDeserializer implements java.io.Serializable { private static final long serialVersionUID = 1L; final protected Class<?> _keyClass; protected final JsonDeserializer<?> _delegate; protected DelegatingKD(Class<?> cls, JsonDeserializer<?> deser) {\n            _keyClass = cls;\n            _delegate = deser;\n        }\n\n        @SuppressWarnings(\"resource\")\n        @Override\n        public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n            if (key == null) { \n                return null;\n            }\n            TokenBuffer tb = new TokenBuffer(ctxt.getParser(), ctxt);\n            tb.writeString(key);\n            try {\n                \n                JsonParser p = tb.asParser();\n                p.nextToken();\n                Object result = _delegate.deserialize(p, ctxt);\n                if (result != null) {\n                    return result;\n                }\n                return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n            } catch (Exception re) {\n                return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation: %s\", re.getMessage());\n            }\n        }\n\n        public Class<?> getKeyClass() { return _keyClass; }\n    }\n     \n    @JacksonStdImpl\n    final static class EnumKD extends StdKeyDeserializer { private static final long serialVersionUID = 1L; protected final EnumResolver _byNameResolver; protected final AnnotatedMethod _factory; protected EnumResolver _byToStringResolver; protected EnumKD(EnumResolver er, AnnotatedMethod factory) {\n            super(-1, er.getEnumClass());\n            _byNameResolver = er;\n            _factory = factory;\n        }\n\n        @Override\n        public Object _parse(String key, DeserializationContext ctxt) throws IOException {\n            if (_factory != null) {\n                try {\n                    return _factory.call1(key);\n                } catch (Exception e) {\n                    ClassUtil.unwrapAndThrowAsIAE(e);\n                }\n            }\n            EnumResolver res = ctxt.isEnabled(DeserializationFeature.READ_ENUMS_USING_TO_STRING)\n                    ? _getToStringResolver(ctxt) : _byNameResolver;\n            Enum<?> e = res.findEnum(key);\n            if ((e == null) && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n                return ctxt.handleWeirdKey(_keyClass, key, \"not one of values excepted for Enum class: %s\",\n                        res.getEnumIds());\n                \n            }\n            return e;\n        }\n\n        private EnumResolver _getToStringResolver(DeserializationContext ctxt) {\n            EnumResolver res = _byToStringResolver;\n            if (res == null) {\n                synchronized (this) {\n                    res = EnumResolver.constructUnsafeUsingToString(_byNameResolver.getEnumClass(),\n                            ctxt.getAnnotationIntrospector());\n                }\n            }\n            return res;\n        }\n    }\n    \n    \n    final static class StringCtorKeyDeserializer extends StdKeyDeserializer { private static final long serialVersionUID = 1L; protected final Constructor<?> _ctor; public StringCtorKeyDeserializer(Constructor<?> ctor) {\n            super(-1, ctor.getDeclaringClass());\n            _ctor = ctor;\n        }\n\n        @Override\n        public Object _parse(String key, DeserializationContext ctxt) throws Exception {\n            return _ctor.newInstance(key);\n        }\n    }\n\n    \n    final static class StringFactoryKeyDeserializer extends StdKeyDeserializer { private static final long serialVersionUID = 1L; final Method _factoryMethod; public StringFactoryKeyDeserializer(Method fm) {\n            super(-1, fm.getDeclaringClass());\n            _factoryMethod = fm;\n        }\n\n        @Override\n        public Object _parse(String key, DeserializationContext ctxt) throws Exception {\n            return _factoryMethod.invoke(null, key);\n        }\n    }\n}\n\n",
      "buggy_signatures": [
        "protected StdKeyDeserializer(int kind, Class<?> cls, FromStringDeserializer<?> deser)",
        "public static StdKeyDeserializer forType(Class<?> raw)",
        "public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException",
        "public Class<?> getKeyClass()",
        "protected Object _parse(String key, DeserializationContext ctxt) throws Exception",
        "protected int _parseInt(String key) throws IllegalArgumentException",
        "protected long _parseLong(String key) throws IllegalArgumentException",
        "protected double _parseDouble(String key) throws IllegalArgumentException",
        "public static StringKD forType(Class<?> nominalType)",
        "public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException",
        "public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException",
        "public Class<?> getKeyClass()",
        "public Object _parse(String key, DeserializationContext ctxt) throws IOException",
        "private EnumResolver _getToStringResolver(DeserializationContext ctxt)",
        "synchronized (this)",
        "public Object _parse(String key, DeserializationContext ctxt) throws Exception",
        "public Object _parse(String key, DeserializationContext ctxt) throws Exception"
      ],
      "fixed_signatures": [
        "protected StdKeyDeserializer(int kind, Class<?> cls, FromStringDeserializer<?> deser)",
        "public static StdKeyDeserializer forType(Class<?> raw)",
        "public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException",
        "public Class<?> getKeyClass()",
        "protected Object _parse(String key, DeserializationContext ctxt) throws Exception",
        "protected int _parseInt(String key) throws IllegalArgumentException",
        "protected long _parseLong(String key) throws IllegalArgumentException",
        "protected double _parseDouble(String key) throws IllegalArgumentException",
        "public static StringKD forType(Class<?> nominalType)",
        "public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException",
        "public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException",
        "public Class<?> getKeyClass()",
        "public Object _parse(String key, DeserializationContext ctxt) throws IOException",
        "private EnumResolver _getToStringResolver(DeserializationContext ctxt)",
        "synchronized (this)",
        "public Object _parse(String key, DeserializationContext ctxt) throws Exception",
        "public Object _parse(String key, DeserializationContext ctxt) throws Exception"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -8,6 +8,7 @@",
            " import java.net.URL;\n",
            " import java.util.*;\n",
            " \n",
            "+import com.fasterxml.jackson.core.JsonParser;\n",
            " import com.fasterxml.jackson.core.JsonProcessingException;\n",
            " import com.fasterxml.jackson.core.io.NumberInput;\n",
            " import com.fasterxml.jackson.databind.*;\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -15,6 +16,7 @@",
            " import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n",
            " import com.fasterxml.jackson.databind.util.ClassUtil;\n",
            " import com.fasterxml.jackson.databind.util.EnumResolver;\n",
            "+import com.fasterxml.jackson.databind.util.TokenBuffer;\n",
            " \n",
            " /**\n",
            "  * Default {@link KeyDeserializer} implementation used for most {@link java.util.Map}\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n  if (key == null) { \n  return null;\n  }\n  try {\n  \n  Object result = _delegate.deserialize(ctxt.getParser(), ctxt);\n  if (result != null) {\n  return result;\n  }\n  return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n  } catch (Exception re) {\n  return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation: %s\", re.getMessage());\n  }\n  }",
          "fixed_method": "  public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n  if (key == null) { \n  return null;\n  }\n  TokenBuffer tb = new TokenBuffer(ctxt.getParser(), ctxt);\n  tb.writeString(key);\n  try {\n  \n  JsonParser p = tb.asParser();\n  p.nextToken();\n  Object result = _delegate.deserialize(p, ctxt);\n  if (result != null) {\n  return result;\n  }\n  return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n  } catch (Exception re) {\n  return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation: %s\", re.getMessage());\n  }\n  }",
          "diff": [
            "@@ -311,9 +313,13 @@",
            "             if (key == null) { // is this even legal call?\n",
            "                 return null;\n",
            "             }\n",
            "+            TokenBuffer tb = new TokenBuffer(ctxt.getParser(), ctxt);\n",
            "+            tb.writeString(key);\n",
            "             try {\n",
            "                 // Ugh... should not have to give parser which may or may not be correct one...\n",
            "-                Object result = _delegate.deserialize(ctxt.getParser(), ctxt);\n",
            "+                JsonParser p = tb.asParser();\n",
            "+                p.nextToken();\n",
            "+                Object result = _delegate.deserialize(p, ctxt);\n",
            "                 if (result != null) {\n",
            "                     return result;\n",
            "                 }\n"
          ],
          "changed_lines": 6
        }
      ]
    }
  ]
}
