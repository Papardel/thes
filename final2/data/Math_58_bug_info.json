{
  "bug_id": "58",
  "failed_tests": {
    "org.apache.commons.math.optimization.fitting.GaussianFitterTest": [
      {
        "methodName": "testMath519",
        "error": "org.apache.commons.math.exception.NotStrictlyPositiveException",
        "message": "-1.277 is smaller than, or equal to, the minimum (0)",
        "fail_line": "        final double[] p = fitter.fit();",
        "test_source": "  public void testMath519() {\n  // The optimizer will try negative sigma values but \"GaussianFitter\"\n  // will catch the raised exceptions and return NaN values instead.\n\n  final double[] data = { \n  1.1143831578403364E-29,\n  4.95281403484594E-28,\n  1.1171347211930288E-26,\n  1.7044813962636277E-25,\n  1.9784716574832164E-24,\n  1.8630236407866774E-23,\n  1.4820532905097742E-22,\n  1.0241963854632831E-21,\n  6.275077366673128E-21,\n  3.461808994532493E-20,\n  1.7407124684715706E-19,\n  8.056687953553974E-19,\n  3.460193945992071E-18,\n  1.3883326374011525E-17,\n  5.233894983671116E-17,\n  1.8630791465263745E-16,\n  6.288759227922111E-16,\n  2.0204433920597856E-15,\n  6.198768938576155E-15,\n  1.821419346860626E-14,\n  5.139176445538471E-14,\n  1.3956427429045787E-13,\n  3.655705706448139E-13,\n  9.253753324779779E-13,\n  2.267636001476696E-12,\n  5.3880460095836855E-12,\n  1.2431632654852931E-11\n  };\n\n  GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n  for (int i = 0; i < data.length; i++) {\n  fitter.addObservedPoint(i, data[i]);\n  }\n  final double[] p = fitter.fit();\n\n  Assert.assertEquals(53.1572792, p[1], 1e-7);\n  Assert.assertEquals(5.75214622, p[2], 1e-8);\n  }",
        "stack": [
          "Gaussian$Parametric.validateParameters line 183, Gaussian$Parametric.value line 128, CurveFitter$TheoreticalValuesFunction.value line 203, BaseAbstractVectorialOptimizer.computeObjectiveValue line 107, AbstractLeastSquaresOptimizer.updateResidualsAndCost line 128, LevenbergMarquardtOptimizer.doOptimize line 350, BaseAbstractVectorialOptimizer.optimize line 141, AbstractLeastSquaresOptimizer.optimize line 253, AbstractLeastSquaresOptimizer.optimize line 43, CurveFitter.fit line 161, CurveFitter.fit line 126, GaussianFitter.fit line 121, GaussianFitterTest.testMath519 line 336"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/optimization/fitting/GaussianFitter.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.optimization.fitting;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\n\nimport org.apache.commons.math.analysis.function.Gaussian;\nimport org.apache.commons.math.analysis.ParametricUnivariateRealFunction;\nimport org.apache.commons.math.exception.NullArgumentException;\nimport org.apache.commons.math.exception.NumberIsTooSmallException;\nimport org.apache.commons.math.exception.OutOfRangeException;\nimport org.apache.commons.math.exception.ZeroException;\nimport org.apache.commons.math.exception.NotStrictlyPositiveException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\nimport org.apache.commons.math.optimization.fitting.CurveFitter;\nimport org.apache.commons.math.optimization.fitting.WeightedObservedPoint;\n\n\npublic class GaussianFitter extends CurveFitter { public GaussianFitter(DifferentiableMultivariateVectorialOptimizer optimizer) {\n        super(optimizer);\n    }\n\n    \n    public double[] fit(double[] initialGuess) {\n        final ParametricUnivariateRealFunction f = new ParametricUnivariateRealFunction() {\n                private final ParametricUnivariateRealFunction g = new Gaussian.Parametric(); public double value(double x, double[] p) {\n                    double v = Double.POSITIVE_INFINITY;\n                    try {\n                        v = g.value(x, p);\n                    } catch (NotStrictlyPositiveException e) {\n                        \n                    }\n                    return v;\n                }\n\n                public double[] gradient(double x, double[] p) {\n                    double[] v = { Double.POSITIVE_INFINITY,\n                                   Double.POSITIVE_INFINITY,\n                                   Double.POSITIVE_INFINITY };\n                    try {\n                        v = g.gradient(x, p);\n                    } catch (NotStrictlyPositiveException e) {\n                        \n                    }\n                    return v;\n                }\n            };\n\n        return fit(f, initialGuess);\n    }\n\n    \n    public double[] fit() {\n        final double[] guess = (new ParameterGuesser(getObservations())).guess();\n        return fit(new Gaussian.Parametric(), guess);\n    }\n\n    \n    public static class ParameterGuesser { private final WeightedObservedPoint[] observations; private double[] parameters; public ParameterGuesser(WeightedObservedPoint[] observations) {\n            if (observations == null) {\n                throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n            }\n            if (observations.length < 3) {\n                throw new NumberIsTooSmallException(observations.length, 3, true);\n            }\n            this.observations = observations.clone();\n        }\n\n        \n        public double[] guess() {\n            if (parameters == null) {\n                parameters = basicGuess(observations);\n            }\n            return parameters.clone();\n        }\n\n        \n        private double[] basicGuess(WeightedObservedPoint[] points) {\n            Arrays.sort(points, createWeightedObservedPointComparator());\n            double[] params = new double[3];\n\n            int maxYIdx = findMaxY(points);\n            params[0] = points[maxYIdx].getY();\n            params[1] = points[maxYIdx].getX();\n\n            double fwhmApprox;\n            try {\n                double halfY = params[0] + ((params[1] - params[0]) / 2.0);\n                double fwhmX1 = interpolateXAtY(points, maxYIdx, -1, halfY);\n                double fwhmX2 = interpolateXAtY(points, maxYIdx, +1, halfY);\n                fwhmApprox = fwhmX2 - fwhmX1;\n            } catch (OutOfRangeException e) {\n                fwhmApprox = points[points.length - 1].getX() - points[0].getX();\n            }\n            params[2] = fwhmApprox / (2.0 * Math.sqrt(2.0 * Math.log(2.0)));\n\n            return params;\n        }\n\n        \n        private int findMaxY(WeightedObservedPoint[] points) {\n            int maxYIdx = 0;\n            for (int i = 1; i < points.length; i++) {\n                if (points[i].getY() > points[maxYIdx].getY()) {\n                    maxYIdx = i;\n                }\n            }\n            return maxYIdx;\n        }\n\n        \n        private double interpolateXAtY(WeightedObservedPoint[] points, int startIdx, int idxStep, double y) throws OutOfRangeException {\n            if (idxStep == 0) {\n                throw new ZeroException();\n            }\n            WeightedObservedPoint[] twoPoints = getInterpolationPointsForY(points, startIdx, idxStep, y);\n            WeightedObservedPoint pointA = twoPoints[0];\n            WeightedObservedPoint pointB = twoPoints[1];\n            if (pointA.getY() == y) {\n                return pointA.getX();\n            }\n            if (pointB.getY() == y) {\n                return pointB.getX();\n            }\n            return pointA.getX() +\n                   (((y - pointA.getY()) * (pointB.getX() - pointA.getX())) /\n                    (pointB.getY() - pointA.getY()));\n        }\n\n        \n        private WeightedObservedPoint[] getInterpolationPointsForY(WeightedObservedPoint[] points, int startIdx, int idxStep, double y) throws OutOfRangeException {\n            if (idxStep == 0) {\n                throw new ZeroException();\n            }\n            for (int i = startIdx;\n                 (idxStep < 0) ? (i + idxStep >= 0) : (i + idxStep < points.length);\n                 i += idxStep) {\n                if (isBetween(y, points[i].getY(), points[i + idxStep].getY())) {\n                    return (idxStep < 0) ?\n                           new WeightedObservedPoint[] { points[i + idxStep], points[i] } :\n                           new WeightedObservedPoint[] { points[i], points[i + idxStep] };\n                }\n            }\n\n            double minY = Double.POSITIVE_INFINITY;\n            double maxY = Double.NEGATIVE_INFINITY;\n            for (final WeightedObservedPoint point : points) {\n                minY = Math.min(minY, point.getY());\n                maxY = Math.max(maxY, point.getY());\n            }\n            throw new OutOfRangeException(y, minY, maxY);\n        }\n\n        \n        private boolean isBetween(double value, double boundary1, double boundary2) {\n            return (value >= boundary1 && value <= boundary2) ||\n                   (value >= boundary2 && value <= boundary1);\n        }\n\n        \n        private Comparator<WeightedObservedPoint> createWeightedObservedPointComparator() {\n            return new Comparator<WeightedObservedPoint>() {\n                public int compare(WeightedObservedPoint p1, WeightedObservedPoint p2) {\n                    if (p1 == null && p2 == null) {\n                        return 0;\n                    }\n                    if (p1 == null) {\n                        return -1;\n                    }\n                    if (p2 == null) {\n                        return 1;\n                    }\n                    if (p1.getX() < p2.getX()) {\n                        return -1;\n                    }\n                    if (p1.getX() > p2.getX()) {\n                        return 1;\n                    }\n                    if (p1.getY() < p2.getY()) {\n                        return -1;\n                    }\n                    if (p1.getY() > p2.getY()) {\n                        return 1;\n                    }\n                    if (p1.getWeight() < p2.getWeight()) {\n                        return -1;\n                    }\n                    if (p1.getWeight() > p2.getWeight()) {\n                        return 1;\n                    }\n                    return 0;\n                }\n            };\n        }\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.optimization.fitting;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\n\nimport org.apache.commons.math.analysis.function.Gaussian;\nimport org.apache.commons.math.analysis.ParametricUnivariateRealFunction;\nimport org.apache.commons.math.exception.NullArgumentException;\nimport org.apache.commons.math.exception.NumberIsTooSmallException;\nimport org.apache.commons.math.exception.OutOfRangeException;\nimport org.apache.commons.math.exception.ZeroException;\nimport org.apache.commons.math.exception.NotStrictlyPositiveException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\nimport org.apache.commons.math.optimization.fitting.CurveFitter;\nimport org.apache.commons.math.optimization.fitting.WeightedObservedPoint;\n\n\npublic class GaussianFitter extends CurveFitter { public GaussianFitter(DifferentiableMultivariateVectorialOptimizer optimizer) {\n        super(optimizer);\n    }\n\n    \n    public double[] fit(double[] initialGuess) {\n        final ParametricUnivariateRealFunction f = new ParametricUnivariateRealFunction() {\n                private final ParametricUnivariateRealFunction g = new Gaussian.Parametric(); public double value(double x, double[] p) {\n                    double v = Double.POSITIVE_INFINITY;\n                    try {\n                        v = g.value(x, p);\n                    } catch (NotStrictlyPositiveException e) {\n                        \n                    }\n                    return v;\n                }\n\n                public double[] gradient(double x, double[] p) {\n                    double[] v = { Double.POSITIVE_INFINITY,\n                                   Double.POSITIVE_INFINITY,\n                                   Double.POSITIVE_INFINITY };\n                    try {\n                        v = g.gradient(x, p);\n                    } catch (NotStrictlyPositiveException e) {\n                        \n                    }\n                    return v;\n                }\n            };\n\n        return fit(f, initialGuess);\n    }\n\n    \n    public double[] fit() {\n        final double[] guess = (new ParameterGuesser(getObservations())).guess();\n        return fit(guess);\n    }\n\n    \n    public static class ParameterGuesser { private final WeightedObservedPoint[] observations; private double[] parameters; public ParameterGuesser(WeightedObservedPoint[] observations) {\n            if (observations == null) {\n                throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n            }\n            if (observations.length < 3) {\n                throw new NumberIsTooSmallException(observations.length, 3, true);\n            }\n            this.observations = observations.clone();\n        }\n\n        \n        public double[] guess() {\n            if (parameters == null) {\n                parameters = basicGuess(observations);\n            }\n            return parameters.clone();\n        }\n\n        \n        private double[] basicGuess(WeightedObservedPoint[] points) {\n            Arrays.sort(points, createWeightedObservedPointComparator());\n            double[] params = new double[3];\n\n            int maxYIdx = findMaxY(points);\n            params[0] = points[maxYIdx].getY();\n            params[1] = points[maxYIdx].getX();\n\n            double fwhmApprox;\n            try {\n                double halfY = params[0] + ((params[1] - params[0]) / 2.0);\n                double fwhmX1 = interpolateXAtY(points, maxYIdx, -1, halfY);\n                double fwhmX2 = interpolateXAtY(points, maxYIdx, +1, halfY);\n                fwhmApprox = fwhmX2 - fwhmX1;\n            } catch (OutOfRangeException e) {\n                fwhmApprox = points[points.length - 1].getX() - points[0].getX();\n            }\n            params[2] = fwhmApprox / (2.0 * Math.sqrt(2.0 * Math.log(2.0)));\n\n            return params;\n        }\n\n        \n        private int findMaxY(WeightedObservedPoint[] points) {\n            int maxYIdx = 0;\n            for (int i = 1; i < points.length; i++) {\n                if (points[i].getY() > points[maxYIdx].getY()) {\n                    maxYIdx = i;\n                }\n            }\n            return maxYIdx;\n        }\n\n        \n        private double interpolateXAtY(WeightedObservedPoint[] points, int startIdx, int idxStep, double y) throws OutOfRangeException {\n            if (idxStep == 0) {\n                throw new ZeroException();\n            }\n            WeightedObservedPoint[] twoPoints = getInterpolationPointsForY(points, startIdx, idxStep, y);\n            WeightedObservedPoint pointA = twoPoints[0];\n            WeightedObservedPoint pointB = twoPoints[1];\n            if (pointA.getY() == y) {\n                return pointA.getX();\n            }\n            if (pointB.getY() == y) {\n                return pointB.getX();\n            }\n            return pointA.getX() +\n                   (((y - pointA.getY()) * (pointB.getX() - pointA.getX())) /\n                    (pointB.getY() - pointA.getY()));\n        }\n\n        \n        private WeightedObservedPoint[] getInterpolationPointsForY(WeightedObservedPoint[] points, int startIdx, int idxStep, double y) throws OutOfRangeException {\n            if (idxStep == 0) {\n                throw new ZeroException();\n            }\n            for (int i = startIdx;\n                 (idxStep < 0) ? (i + idxStep >= 0) : (i + idxStep < points.length);\n                 i += idxStep) {\n                if (isBetween(y, points[i].getY(), points[i + idxStep].getY())) {\n                    return (idxStep < 0) ?\n                           new WeightedObservedPoint[] { points[i + idxStep], points[i] } :\n                           new WeightedObservedPoint[] { points[i], points[i + idxStep] };\n                }\n            }\n\n            double minY = Double.POSITIVE_INFINITY;\n            double maxY = Double.NEGATIVE_INFINITY;\n            for (final WeightedObservedPoint point : points) {\n                minY = Math.min(minY, point.getY());\n                maxY = Math.max(maxY, point.getY());\n            }\n            throw new OutOfRangeException(y, minY, maxY);\n        }\n\n        \n        private boolean isBetween(double value, double boundary1, double boundary2) {\n            return (value >= boundary1 && value <= boundary2) ||\n                   (value >= boundary2 && value <= boundary1);\n        }\n\n        \n        private Comparator<WeightedObservedPoint> createWeightedObservedPointComparator() {\n            return new Comparator<WeightedObservedPoint>() {\n                public int compare(WeightedObservedPoint p1, WeightedObservedPoint p2) {\n                    if (p1 == null && p2 == null) {\n                        return 0;\n                    }\n                    if (p1 == null) {\n                        return -1;\n                    }\n                    if (p2 == null) {\n                        return 1;\n                    }\n                    if (p1.getX() < p2.getX()) {\n                        return -1;\n                    }\n                    if (p1.getX() > p2.getX()) {\n                        return 1;\n                    }\n                    if (p1.getY() < p2.getY()) {\n                        return -1;\n                    }\n                    if (p1.getY() > p2.getY()) {\n                        return 1;\n                    }\n                    if (p1.getWeight() < p2.getWeight()) {\n                        return -1;\n                    }\n                    if (p1.getWeight() > p2.getWeight()) {\n                        return 1;\n                    }\n                    return 0;\n                }\n            };\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public class GaussianFitter extends CurveFitter { public GaussianFitter(DifferentiableMultivariateVectorialOptimizer optimizer)",
        "public double[] fit(double[] initialGuess)",
        "public double[] gradient(double x, double[] p)",
        "public double[] fit()",
        "public static class ParameterGuesser { private final WeightedObservedPoint[] observations; private double[] parameters; public ParameterGuesser(WeightedObservedPoint[] observations)",
        "public double[] guess()",
        "private double[] basicGuess(WeightedObservedPoint[] points)",
        "private int findMaxY(WeightedObservedPoint[] points)",
        "private double interpolateXAtY(WeightedObservedPoint[] points, int startIdx, int idxStep, double y) throws OutOfRangeException",
        "private WeightedObservedPoint[] getInterpolationPointsForY(WeightedObservedPoint[] points, int startIdx, int idxStep, double y) throws OutOfRangeException",
        "private boolean isBetween(double value, double boundary1, double boundary2)",
        "private Comparator<WeightedObservedPoint> createWeightedObservedPointComparator()",
        "public int compare(WeightedObservedPoint p1, WeightedObservedPoint p2)"
      ],
      "fixed_signatures": [
        "public class GaussianFitter extends CurveFitter { public GaussianFitter(DifferentiableMultivariateVectorialOptimizer optimizer)",
        "public double[] fit(double[] initialGuess)",
        "public double[] gradient(double x, double[] p)",
        "public double[] fit()",
        "public static class ParameterGuesser { private final WeightedObservedPoint[] observations; private double[] parameters; public ParameterGuesser(WeightedObservedPoint[] observations)",
        "public double[] guess()",
        "private double[] basicGuess(WeightedObservedPoint[] points)",
        "private int findMaxY(WeightedObservedPoint[] points)",
        "private double interpolateXAtY(WeightedObservedPoint[] points, int startIdx, int idxStep, double y) throws OutOfRangeException",
        "private WeightedObservedPoint[] getInterpolationPointsForY(WeightedObservedPoint[] points, int startIdx, int idxStep, double y) throws OutOfRangeException",
        "private boolean isBetween(double value, double boundary1, double boundary2)",
        "private Comparator<WeightedObservedPoint> createWeightedObservedPointComparator()",
        "public int compare(WeightedObservedPoint p1, WeightedObservedPoint p2)"
      ],
      "methods": [
        {
          "buggy_method": "  public double[] fit() {\n  final double[] guess = (new ParameterGuesser(getObservations())).guess();\n  return fit(new Gaussian.Parametric(), guess);\n  }",
          "fixed_method": "  public double[] fit() {\n  final double[] guess = (new ParameterGuesser(getObservations())).guess();\n  return fit(guess);\n  }",
          "diff": [
            "@@ -118,7 +118,7 @@",
            "      */\n",
            "     public double[] fit() {\n",
            "         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n",
            "-        return fit(new Gaussian.Parametric(), guess);\n",
            "+        return fit(guess);\n",
            "     }\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
