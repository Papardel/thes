{
  "bug_id": "17",
  "failed_tests": {
    "org.apache.commons.math3.dfp.DfpTest": [
      {
        "methodName": "testMultiply",
        "error": "junit.framework.AssertionFailedError",
        "message": "assersion failed Multiply #37 x = NaN flags = 1",
        "fail_line": "        test(field.newDfp(\"1\").multiply(10000),",
        "test_source": "  public void testMultiply() {\n  test(field.newDfp(\"1\").multiply(field.newDfp(\"1\")),  // Basic tests  1*1 = 1\n  field.newDfp(\"1\"),\n  0, \"Multiply #1\");\n\n  test(field.newDfp(\"1\").multiply(1),  // Basic tests  1*1 = 1\n  field.newDfp(\"1\"),\n  0, \"Multiply #2\");\n\n  test(field.newDfp(\"-1\").multiply(field.newDfp(\"1\")),  // Basic tests  -1*1 = -1\n  field.newDfp(\"-1\"),\n  0, \"Multiply #3\");\n\n  test(field.newDfp(\"-1\").multiply(1),  // Basic tests  -1*1 = -1\n  field.newDfp(\"-1\"),\n  0, \"Multiply #4\");\n\n  // basic tests with integers\n  test(field.newDfp(\"2\").multiply(field.newDfp(\"3\")),\n  field.newDfp(\"6\"),\n  0, \"Multiply #5\");\n\n  test(field.newDfp(\"2\").multiply(3),\n  field.newDfp(\"6\"),\n  0, \"Multiply #6\");\n\n  test(field.newDfp(\"-2\").multiply(field.newDfp(\"3\")),\n  field.newDfp(\"-6\"),\n  0, \"Multiply #7\");\n\n  test(field.newDfp(\"-2\").multiply(3),\n  field.newDfp(\"-6\"),\n  0, \"Multiply #8\");\n\n  test(field.newDfp(\"2\").multiply(field.newDfp(\"-3\")),\n  field.newDfp(\"-6\"),\n  0, \"Multiply #9\");\n\n  test(field.newDfp(\"-2\").multiply(field.newDfp(\"-3\")),\n  field.newDfp(\"6\"),\n  0, \"Multiply #10\");\n\n  //multiply by zero\n\n  test(field.newDfp(\"-2\").multiply(field.newDfp(\"0\")),\n  field.newDfp(\"-0\"),\n  0, \"Multiply #11\");\n\n  test(field.newDfp(\"-2\").multiply(0),\n  field.newDfp(\"-0\"),\n  0, \"Multiply #12\");\n\n  test(field.newDfp(\"2\").multiply(field.newDfp(\"0\")),\n  field.newDfp(\"0\"),\n  0, \"Multiply #13\");\n\n  test(field.newDfp(\"2\").multiply(0),\n  field.newDfp(\"0\"),\n  0, \"Multiply #14\");\n\n  test(field.newDfp(\"2\").multiply(pinf),\n  pinf,\n  0, \"Multiply #15\");\n\n  test(field.newDfp(\"2\").multiply(ninf),\n  ninf,\n  0, \"Multiply #16\");\n\n  test(field.newDfp(\"-2\").multiply(pinf),\n  ninf,\n  0, \"Multiply #17\");\n\n  test(field.newDfp(\"-2\").multiply(ninf),\n  pinf,\n  0, \"Multiply #18\");\n\n  test(ninf.multiply(field.newDfp(\"-2\")),\n  pinf,\n  0, \"Multiply #18.1\");\n\n  test(field.newDfp(\"5e131071\").multiply(2),\n  pinf,\n  DfpField.FLAG_OVERFLOW, \"Multiply #19\");\n\n  test(field.newDfp(\"5e131071\").multiply(field.newDfp(\"1.999999999999999\")),\n  field.newDfp(\"9.9999999999999950000e131071\"),\n  0, \"Multiply #20\");\n\n  test(field.newDfp(\"-5e131071\").multiply(2),\n  ninf,\n  DfpField.FLAG_OVERFLOW, \"Multiply #22\");\n\n  test(field.newDfp(\"-5e131071\").multiply(field.newDfp(\"1.999999999999999\")),\n  field.newDfp(\"-9.9999999999999950000e131071\"),\n  0, \"Multiply #23\");\n\n  test(field.newDfp(\"1e-65539\").multiply(field.newDfp(\"1e-65539\")),\n  field.newDfp(\"1e-131078\"),\n  DfpField.FLAG_UNDERFLOW, \"Multiply #24\");\n\n  test(field.newDfp(\"1\").multiply(nan),\n  nan,\n  0, \"Multiply #25\");\n\n  test(nan.multiply(field.newDfp(\"1\")),\n  nan,\n  0, \"Multiply #26\");\n\n  test(nan.multiply(pinf),\n  nan,\n  0, \"Multiply #27\");\n\n  test(pinf.multiply(nan),\n  nan,\n  0, \"Multiply #27\");\n\n  test(pinf.multiply(field.newDfp(\"0\")),\n  nan,\n  DfpField.FLAG_INVALID, \"Multiply #28\");\n\n  test(field.newDfp(\"0\").multiply(pinf),\n  nan,\n  DfpField.FLAG_INVALID, \"Multiply #29\");\n\n  test(pinf.multiply(pinf),\n  pinf,\n  0, \"Multiply #30\");\n\n  test(ninf.multiply(pinf),\n  ninf,\n  0, \"Multiply #31\");\n\n  test(pinf.multiply(ninf),\n  ninf,\n  0, \"Multiply #32\");\n\n  test(ninf.multiply(ninf),\n  pinf,\n  0, \"Multiply #33\");\n\n  test(pinf.multiply(1),\n  pinf,\n  0, \"Multiply #34\");\n\n  test(pinf.multiply(0),\n  nan,\n  DfpField.FLAG_INVALID, \"Multiply #35\");\n\n  test(nan.multiply(1),\n  nan,\n  0, \"Multiply #36\");\n\n  test(field.newDfp(\"1\").multiply(10000),\n  field.newDfp(\"10000\"),\n  0, \"Multiply #37\");\n\n  test(field.newDfp(\"2\").multiply(1000000),\n  field.newDfp(\"2000000\"),\n  0, \"Multiply #38\");\n\n  test(field.newDfp(\"1\").multiply(-1),\n  field.newDfp(\"-1\"),\n  0, \"Multiply #39\");\n  }",
        "stack": [
          "DfpTest.test line 74, DfpTest.testMultiply line 909"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math3/dfp/Dfp.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math3.dfp;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.math3.FieldElement;\n\n\npublic class Dfp implements FieldElement<Dfp> { public static final int RADIX = 10000; public static final int MIN_EXP = -32767; public static final int MAX_EXP = 32768; public static final int ERR_SCALE = 32760; public static final byte FINITE = 0; public static final byte INFINITE = 1; public static final byte SNAN = 2; public static final byte QNAN = 3; private static final String NAN_STRING = \"NaN\"; private static final String POS_INFINITY_STRING = \"Infinity\"; private static final String NEG_INFINITY_STRING = \"-Infinity\"; private static final String ADD_TRAP = \"add\"; private static final String MULTIPLY_TRAP = \"multiply\"; private static final String DIVIDE_TRAP = \"divide\"; private static final String SQRT_TRAP = \"sqrt\"; private static final String ALIGN_TRAP = \"align\"; private static final String TRUNC_TRAP = \"trunc\"; private static final String NEXT_AFTER_TRAP = \"nextAfter\"; private static final String LESS_THAN_TRAP = \"lessThan\"; private static final String GREATER_THAN_TRAP = \"greaterThan\"; private static final String NEW_INSTANCE_TRAP = \"newInstance\"; protected int[] mant; protected byte sign; protected int exp; protected byte nans; private final DfpField field; protected Dfp(final DfpField field) {\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n    }\n\n    \n    protected Dfp(final DfpField field, byte x) {\n        this(field, (long) x);\n    }\n\n    \n    protected Dfp(final DfpField field, int x) {\n        this(field, (long) x);\n    }\n\n    \n    protected Dfp(final DfpField field, long x) {\n\n        \n        mant = new int[field.getRadixDigits()];\n        nans = FINITE;\n        this.field = field;\n\n        boolean isLongMin = false;\n        if (x == Long.MIN_VALUE) {\n            \n            \n            isLongMin = true;\n            ++x;\n        }\n\n        \n        if (x < 0) {\n            sign = -1;\n            x = -x;\n        } else {\n            sign = 1;\n        }\n\n        exp = 0;\n        while (x != 0) {\n            System.arraycopy(mant, mant.length - exp, mant, mant.length - 1 - exp, exp);\n            mant[mant.length - 1] = (int) (x % RADIX);\n            x /= RADIX;\n            exp++;\n        }\n\n        if (isLongMin) {\n            \n            \n            for (int i = 0; i < mant.length - 1; i++) {\n                if (mant[i] != 0) {\n                    mant[i]++;\n                    break;\n                }\n            }\n        }\n    }\n\n    \n    protected Dfp(final DfpField field, double x) {\n\n        \n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            \n            if (x == 0) {\n                \n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            \n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            \n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  \n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n\n    \n    public Dfp(final Dfp d) {\n        mant  = d.mant.clone();\n        sign  = d.sign;\n        exp   = d.exp;\n        nans  = d.nans;\n        field = d.field;\n    }\n\n    \n    protected Dfp(final DfpField field, final String s) {\n\n        \n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        boolean decimalFound = false;\n        final int rsize = 4;   \n        final int offset = 4;  \n        final char[] striped = new char[getRadixDigits() * rsize + offset * 2];\n\n        \n        if (s.equals(POS_INFINITY_STRING)) {\n            sign = (byte) 1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NEG_INFINITY_STRING)) {\n            sign = (byte) -1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NAN_STRING)) {\n            sign = (byte) 1;\n            nans = QNAN;\n            return;\n        }\n\n        \n        int p = s.indexOf(\"e\");\n        if (p == -1) { \n            p = s.indexOf(\"E\");\n        }\n\n        final String fpdecimal;\n        int sciexp = 0;\n        if (p != -1) {\n            \n            fpdecimal = s.substring(0, p);\n            String fpexp = s.substring(p+1);\n            boolean negative = false;\n\n            for (int i=0; i<fpexp.length(); i++)\n            {\n                if (fpexp.charAt(i) == '-')\n                {\n                    negative = true;\n                    continue;\n                }\n                if (fpexp.charAt(i) >= '0' && fpexp.charAt(i) <= '9') {\n                    sciexp = sciexp * 10 + fpexp.charAt(i) - '0';\n                }\n            }\n\n            if (negative) {\n                sciexp = -sciexp;\n            }\n        } else {\n            \n            fpdecimal = s;\n        }\n\n        \n        if (fpdecimal.indexOf(\"-\") !=  -1) {\n            sign = -1;\n        }\n\n        \n        p = 0;\n\n        \n        int decimalPos = 0;\n        for (;;) {\n            if (fpdecimal.charAt(p) >= '1' && fpdecimal.charAt(p) <= '9') {\n                break;\n            }\n\n            if (decimalFound && fpdecimal.charAt(p) == '0') {\n                decimalPos--;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n            }\n\n            p++;\n\n            if (p == fpdecimal.length()) {\n                break;\n            }\n        }\n\n        \n        int q = offset;\n        striped[0] = '0';\n        striped[1] = '0';\n        striped[2] = '0';\n        striped[3] = '0';\n        int significantDigits=0;\n        for(;;) {\n            if (p == (fpdecimal.length())) {\n                break;\n            }\n\n            \n            if (q == mant.length*rsize+offset+1) {\n                break;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n                decimalPos = significantDigits;\n                p++;\n                continue;\n            }\n\n            if (fpdecimal.charAt(p) < '0' || fpdecimal.charAt(p) > '9') {\n                p++;\n                continue;\n            }\n\n            striped[q] = fpdecimal.charAt(p);\n            q++;\n            p++;\n            significantDigits++;\n        }\n\n\n        \n        if (decimalFound && q != offset) {\n            for (;;) {\n                q--;\n                if (q == offset) {\n                    break;\n                }\n                if (striped[q] == '0') {\n                    significantDigits--;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        \n        if (decimalFound && significantDigits == 0) {\n            decimalPos = 0;\n        }\n\n        \n        if (!decimalFound) {\n            decimalPos = q-offset;\n        }\n\n        \n        q = offset;  \n        p = significantDigits-1+offset;\n\n        while (p > q) {\n            if (striped[p] != '0') {\n                break;\n            }\n            p--;\n        }\n\n        \n        int i = ((rsize * 100) - decimalPos - sciexp % rsize) % rsize;\n        q -= i;\n        decimalPos += i;\n\n        \n        while ((p - q) < (mant.length * rsize)) {\n            for (i = 0; i < rsize; i++) {\n                striped[++p] = '0';\n            }\n        }\n\n        \n        \n        for (i = mant.length - 1; i >= 0; i--) {\n            mant[i] = (striped[q]   - '0') * 1000 +\n                      (striped[q+1] - '0') * 100  +\n                      (striped[q+2] - '0') * 10   +\n                      (striped[q+3] - '0');\n            q += 4;\n        }\n\n\n        exp = (decimalPos+sciexp) / rsize;\n\n        if (q < striped.length) {\n            \n            round((striped[q] - '0')*1000);\n        }\n\n    }\n\n    \n    protected Dfp(final DfpField field, final byte sign, final byte nans) {\n        this.field = field;\n        this.mant    = new int[field.getRadixDigits()];\n        this.sign    = sign;\n        this.exp     = 0;\n        this.nans    = nans;\n    }\n\n    \n    public Dfp newInstance() {\n        return new Dfp(getField());\n    }\n\n    \n    public Dfp newInstance(final byte x) {\n        return new Dfp(getField(), x);\n    }\n\n    \n    public Dfp newInstance(final int x) {\n        return new Dfp(getField(), x);\n    }\n\n    \n    public Dfp newInstance(final long x) {\n        return new Dfp(getField(), x);\n    }\n\n    \n    public Dfp newInstance(final double x) {\n        return new Dfp(getField(), x);\n    }\n\n    \n    public Dfp newInstance(final Dfp d) {\n\n        \n        if (field.getRadixDigits() != d.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEW_INSTANCE_TRAP, d, result);\n        }\n\n        return new Dfp(d);\n\n    }\n\n    \n    public Dfp newInstance(final String s) {\n        return new Dfp(field, s);\n    }\n\n    \n    public Dfp newInstance(final byte sig, final byte code) {\n        return field.newDfp(sig, code);\n    }\n\n    \n    public DfpField getField() {\n        return field;\n    }\n\n    \n    public int getRadixDigits() {\n        return field.getRadixDigits();\n    }\n\n    \n    public Dfp getZero() {\n        return field.getZero();\n    }\n\n    \n    public Dfp getOne() {\n        return field.getOne();\n    }\n\n    \n    public Dfp getTwo() {\n        return field.getTwo();\n    }\n\n    \n    protected void shiftLeft() {\n        for (int i = mant.length - 1; i > 0; i--) {\n            mant[i] = mant[i-1];\n        }\n        mant[0] = 0;\n        exp--;\n    }\n\n    \n    \n    protected void shiftRight() {\n        for (int i = 0; i < mant.length - 1; i++) {\n            mant[i] = mant[i+1];\n        }\n        mant[mant.length - 1] = 0;\n        exp++;\n    }\n\n    \n    protected int align(int e) {\n        int lostdigit = 0;\n        boolean inexact = false;\n\n        int diff = exp - e;\n\n        int adiff = diff;\n        if (adiff < 0) {\n            adiff = -adiff;\n        }\n\n        if (diff == 0) {\n            return 0;\n        }\n\n        if (adiff > (mant.length + 1)) {\n            \n            Arrays.fill(mant, 0);\n            exp = e;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n\n            return 0;\n        }\n\n        for (int i = 0; i < adiff; i++) {\n            if (diff < 0) {\n                \n                if (lostdigit != 0) {\n                    inexact = true;\n                }\n\n                lostdigit = mant[0];\n\n                shiftRight();\n            } else {\n                shiftLeft();\n            }\n        }\n\n        if (inexact) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n        }\n\n        return lostdigit;\n\n    }\n\n    \n    public boolean lessThan(final Dfp x) {\n\n        \n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, result);\n            return false;\n        }\n\n        \n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) < 0;\n    }\n\n    \n    public boolean greaterThan(final Dfp x) {\n\n        \n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, result);\n            return false;\n        }\n\n        \n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) > 0;\n    }\n\n    \n    public boolean negativeOrNull() {\n\n        if (isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, this, newInstance(getZero()));\n            return false;\n        }\n\n        return (sign < 0) || ((mant[mant.length - 1] == 0) && !isInfinite());\n\n    }\n\n    \n    public boolean strictlyNegative() {\n\n        if (isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, this, newInstance(getZero()));\n            return false;\n        }\n\n        return (sign < 0) && ((mant[mant.length - 1] != 0) || isInfinite());\n\n    }\n\n    \n    public boolean positiveOrNull() {\n\n        if (isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, this, newInstance(getZero()));\n            return false;\n        }\n\n        return (sign > 0) || ((mant[mant.length - 1] == 0) && !isInfinite());\n\n    }\n\n    \n    public boolean strictlyPositive() {\n\n        if (isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, this, newInstance(getZero()));\n            return false;\n        }\n\n        return (sign > 0) && ((mant[mant.length - 1] != 0) || isInfinite());\n\n    }\n\n    \n    public Dfp abs() {\n        Dfp result = newInstance(this);\n        result.sign = 1;\n        return result;\n    }\n\n    \n    public boolean isInfinite() {\n        return nans == INFINITE;\n    }\n\n    \n    public boolean isNaN() {\n        return (nans == QNAN) || (nans == SNAN);\n    }\n\n    \n    public boolean isZero() {\n\n        if (isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, this, newInstance(getZero()));\n            return false;\n        }\n\n        return (mant[mant.length - 1] == 0) && !isInfinite();\n\n    }\n\n    \n    @Override\n    public boolean equals(final Object other) {\n\n        if (other instanceof Dfp) {\n            final Dfp x = (Dfp) other;\n            if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n                return false;\n            }\n\n            return compare(this, x) == 0;\n        }\n\n        return false;\n\n    }\n\n    \n    @Override\n    public int hashCode() {\n        return 17 + (sign << 8) + (nans << 16) + exp + Arrays.hashCode(mant);\n    }\n\n    \n    public boolean unequal(final Dfp x) {\n        if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n            return false;\n        }\n\n        return greaterThan(x) || lessThan(x);\n    }\n\n    \n    private static int compare(final Dfp a, final Dfp b) {\n        \n        if (a.mant[a.mant.length - 1] == 0 && b.mant[b.mant.length - 1] == 0 &&\n            a.nans == FINITE && b.nans == FINITE) {\n            return 0;\n        }\n\n        if (a.sign != b.sign) {\n            if (a.sign == -1) {\n                return -1;\n            } else {\n                return 1;\n            }\n        }\n\n        \n        if (a.nans == INFINITE && b.nans == FINITE) {\n            return a.sign;\n        }\n\n        if (a.nans == FINITE && b.nans == INFINITE) {\n            return -b.sign;\n        }\n\n        if (a.nans == INFINITE && b.nans == INFINITE) {\n            return 0;\n        }\n\n        \n        if (b.mant[b.mant.length-1] != 0 && a.mant[b.mant.length-1] != 0) {\n            if (a.exp < b.exp) {\n                return -a.sign;\n            }\n\n            if (a.exp > b.exp) {\n                return a.sign;\n            }\n        }\n\n        \n        for (int i = a.mant.length - 1; i >= 0; i--) {\n            if (a.mant[i] > b.mant[i]) {\n                return a.sign;\n            }\n\n            if (a.mant[i] < b.mant[i]) {\n                return -a.sign;\n            }\n        }\n\n        return 0;\n\n    }\n\n    \n    public Dfp rint() {\n        return trunc(DfpField.RoundingMode.ROUND_HALF_EVEN);\n    }\n\n    \n    public Dfp floor() {\n        return trunc(DfpField.RoundingMode.ROUND_FLOOR);\n    }\n\n    \n    public Dfp ceil() {\n        return trunc(DfpField.RoundingMode.ROUND_CEIL);\n    }\n\n    \n    public Dfp remainder(final Dfp d) {\n\n        final Dfp result = this.subtract(this.divide(d).rint().multiply(d));\n\n        \n        if (result.mant[mant.length-1] == 0) {\n            result.sign = sign;\n        }\n\n        return result;\n\n    }\n\n    \n    protected Dfp trunc(final DfpField.RoundingMode rmode) {\n        boolean changed = false;\n\n        if (isNaN()) {\n            return newInstance(this);\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n\n        if (mant[mant.length-1] == 0) {\n            \n            return newInstance(this);\n        }\n\n        \n        if (exp < 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            Dfp result = newInstance(getZero());\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        \n\n        if (exp >= mant.length) {\n            return newInstance(this);\n        }\n\n        \n\n        Dfp result = newInstance(this);\n        for (int i = 0; i < mant.length-result.exp; i++) {\n            changed |= result.mant[i] != 0;\n            result.mant[i] = 0;\n        }\n\n        if (changed) {\n            switch (rmode) {\n                case ROUND_FLOOR:\n                    if (result.sign == -1) {\n                        \n                        result = result.add(newInstance(-1));\n                    }\n                    break;\n\n                case ROUND_CEIL:\n                    if (result.sign == 1) {\n                        \n                        result = result.add(getOne());\n                    }\n                    break;\n\n                case ROUND_HALF_EVEN:\n                default:\n                    final Dfp half = newInstance(\"0.5\");\n                    Dfp a = subtract(result);  \n                    a.sign = 1;            \n                    if (a.greaterThan(half)) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n\n                    \n                    if (a.equals(half) && result.exp > 0 && (result.mant[mant.length-result.exp]&1) != 0) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n                    break;\n            }\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);  \n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        return result;\n    }\n\n    \n    public int intValue() {\n        Dfp rounded;\n        int result = 0;\n\n        rounded = rint();\n\n        if (rounded.greaterThan(newInstance(2147483647))) {\n            return 2147483647;\n        }\n\n        if (rounded.lessThan(newInstance(-2147483648))) {\n            return -2147483648;\n        }\n\n        for (int i = mant.length - 1; i >= mant.length - rounded.exp; i--) {\n            result = result * RADIX + rounded.mant[i];\n        }\n\n        if (rounded.sign == -1) {\n            result = -result;\n        }\n\n        return result;\n    }\n\n    \n    public int log10K() {\n        return exp - 1;\n    }\n\n    \n    public Dfp power10K(final int e) {\n        Dfp d = newInstance(getOne());\n        d.exp = e + 1;\n        return d;\n    }\n\n    \n    public int log10() {\n        if (mant[mant.length-1] > 1000) {\n            return exp * 4 - 1;\n        }\n        if (mant[mant.length-1] > 100) {\n            return exp * 4 - 2;\n        }\n        if (mant[mant.length-1] > 10) {\n            return exp * 4 - 3;\n        }\n        return exp * 4 - 4;\n    }\n\n    \n    public Dfp power10(final int e) {\n        Dfp d = newInstance(getOne());\n\n        if (e >= 0) {\n            d.exp = e / 4 + 1;\n        } else {\n            d.exp = (e + 1) / 4;\n        }\n\n        switch ((e % 4 + 4) % 4) {\n            case 0:\n                break;\n            case 1:\n                d = d.multiply(10);\n                break;\n            case 2:\n                d = d.multiply(100);\n                break;\n            default:\n                d = d.multiply(1000);\n        }\n\n        return d;\n    }\n\n    \n    protected int complement(int extra) {\n\n        extra = RADIX-extra;\n        for (int i = 0; i < mant.length; i++) {\n            mant[i] = RADIX-mant[i]-1;\n        }\n\n        int rh = extra / RADIX;\n        extra = extra - rh * RADIX;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] + rh;\n            rh = r / RADIX;\n            mant[i] = r - rh * RADIX;\n        }\n\n        return extra;\n    }\n\n    \n    public Dfp add(final Dfp x) {\n\n        \n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        \n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE) {\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        \n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        \n        Dfp result = newInstance(getZero());\n\n        \n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        \n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        \n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        \n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        \n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        \n        int rh = 0; \n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        \n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        \n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        \n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                \n                result.sign = 1;  \n            }\n        }\n\n        \n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }\n\n    \n    public Dfp negate() {\n        Dfp result = newInstance(this);\n        result.sign = (byte) - result.sign;\n        return result;\n    }\n\n    \n    public Dfp subtract(final Dfp x) {\n        return add(x.negate());\n    }\n\n    \n    protected int round(int n) {\n        boolean inc = false;\n        switch (field.getRoundingMode()) {\n            case ROUND_DOWN:\n                inc = false;\n                break;\n\n            case ROUND_UP:\n                inc = n != 0;       \n                break;\n\n            case ROUND_HALF_UP:\n                inc = n >= 5000;  \n                break;\n\n            case ROUND_HALF_DOWN:\n                inc = n > 5000;  \n                break;\n\n            case ROUND_HALF_EVEN:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 1);  \n                break;\n\n            case ROUND_HALF_ODD:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 0);  \n                break;\n\n            case ROUND_CEIL:\n                inc = sign == 1 && n != 0;  \n                break;\n\n            case ROUND_FLOOR:\n            default:\n                inc = sign == -1 && n != 0;  \n                break;\n        }\n\n        if (inc) {\n            \n            int rh = 1;\n            for (int i = 0; i < mant.length; i++) {\n                final int r = mant[i] + rh;\n                rh = r / RADIX;\n                mant[i] = r - rh * RADIX;\n            }\n\n            if (rh != 0) {\n                shiftRight();\n                mant[mant.length-1] = rh;\n            }\n        }\n\n        \n        if (exp < MIN_EXP) {\n            \n            field.setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW);\n            return DfpField.FLAG_UNDERFLOW;\n        }\n\n        if (exp > MAX_EXP) {\n            \n            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n            return DfpField.FLAG_OVERFLOW;\n        }\n\n        if (n != 0) {\n            \n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            return DfpField.FLAG_INEXACT;\n        }\n\n        return 0;\n\n    }\n\n    \n    public Dfp multiply(final Dfp x) {\n\n        \n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        \n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {\n                result = newInstance(x);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) ||\n                    (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n                return result;\n            }\n        }\n\n        int[] product = new int[mant.length*2];  \n\n        for (int i = 0; i < mant.length; i++) {\n            int rh = 0;  \n            for (int j=0; j<mant.length; j++) {\n                int r = mant[i] * x.mant[j];    \n                r = r + product[i+j] + rh;  \n\n                rh = r / RADIX;\n                product[i+j] = r - rh * RADIX;\n            }\n            product[i+mant.length] = rh;\n        }\n\n        \n        int md = mant.length * 2 - 1;  \n        for (int i = mant.length * 2 - 1; i >= 0; i--) {\n            if (product[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        \n        for (int i = 0; i < mant.length; i++) {\n            result.mant[mant.length - i - 1] = product[md - i];\n        }\n\n        \n        result.exp = exp + x.exp + md - 2 * mant.length + 1;\n        result.sign = (byte)((sign == x.sign)?1:-1);\n\n        if (result.mant[mant.length-1] == 0) {\n            \n            result.exp = 0;\n        }\n\n        final int excp;\n        if (md > (mant.length-1)) {\n            excp = result.round(product[md-mant.length]);\n        } else {\n            excp = result.round(0); \n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    \n    public Dfp multiply(final int x) {\n            return multiplyFast(x);\n    }\n\n    \n    private Dfp multiplyFast(final int x) {\n        Dfp result = newInstance(this);\n\n        \n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE && x != 0) {\n                result = newInstance(this);\n                return result;\n            }\n\n            if (nans == INFINITE && x == 0) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result);\n                return result;\n            }\n        }\n\n        \n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        int rh = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] * x + rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n\n        int lostdigit = 0;\n        if (rh != 0) {\n            lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) { \n            result.exp = 0;\n        }\n\n        final int excp = result.round(lostdigit);\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, result, result);\n        }\n\n        return result;\n    }\n\n    \n    public Dfp divide(Dfp divisor) {\n        int dividend[]; \n        int quotient[]; \n        int remainder[];\n        int qd;         \n        int nsqd;       \n        int trial=0;    \n        int minadj;     \n        boolean trialgood; \n        int md=0;       \n        int excp;       \n\n        \n        if (field.getRadixDigits() != divisor.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        \n        if (nans != FINITE || divisor.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (divisor.isNaN()) {\n                return divisor;\n            }\n\n            if (nans == INFINITE && divisor.nans == FINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == FINITE) {\n                result = newInstance(getZero());\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == INFINITE) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n                return result;\n            }\n        }\n\n        \n        if (divisor.mant[mant.length-1] == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            result = newInstance(getZero());\n            result.sign = (byte) (sign * divisor.sign);\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, divisor, result);\n            return result;\n        }\n\n        dividend = new int[mant.length+1];  \n        quotient = new int[mant.length+2];  \n        remainder = new int[mant.length+1]; \n\n        \n\n        dividend[mant.length] = 0;\n        quotient[mant.length] = 0;\n        quotient[mant.length+1] = 0;\n        remainder[mant.length] = 0;\n\n        \n\n        for (int i = 0; i < mant.length; i++) {\n            dividend[i] = mant[i];\n            quotient[i] = 0;\n            remainder[i] = 0;\n        }\n\n        \n        nsqd = 0;\n        for (qd = mant.length+1; qd >= 0; qd--) {\n            \n\n            \n            final int divMsb = dividend[mant.length]*RADIX+dividend[mant.length-1];\n            int min = divMsb       / (divisor.mant[mant.length-1]+1);\n            int max = (divMsb + 1) / divisor.mant[mant.length-1];\n\n            trialgood = false;\n            while (!trialgood) {\n                \n                trial = (min+max)/2;\n\n                \n                int rh = 0;\n                for (int i = 0; i < mant.length + 1; i++) {\n                    int dm = (i<mant.length)?divisor.mant[i]:0;\n                    final int r = (dm * trial) + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                \n                rh = 1;  \n                for (int i = 0; i < mant.length + 1; i++) {\n                    final int r = ((RADIX-1) - remainder[i]) + dividend[i] + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                \n                if (rh == 0) {\n                    \n                    max = trial-1;\n                    continue;\n                }\n\n                \n                minadj = (remainder[mant.length] * RADIX)+remainder[mant.length-1];\n                minadj = minadj / (divisor.mant[mant.length-1]+1);\n\n                if (minadj >= 2) {\n                    min = trial+minadj;  \n                    continue;\n                }\n\n                \n                trialgood = false;  \n                for (int i = mant.length - 1; i >= 0; i--) {\n                    if (divisor.mant[i] > remainder[i]) {\n                        trialgood = true;\n                    }\n                    if (divisor.mant[i] < remainder[i]) {\n                        break;\n                    }\n                }\n\n                if (remainder[mant.length] != 0) {\n                    trialgood = false;\n                }\n\n                if (trialgood == false) {\n                    min = trial+1;\n                }\n            }\n\n            \n            quotient[qd] = trial;\n            if (trial != 0 || nsqd != 0) {\n                nsqd++;\n            }\n\n            if (field.getRoundingMode() == DfpField.RoundingMode.ROUND_DOWN && nsqd == mant.length) {\n                \n                break;\n            }\n\n            if (nsqd > mant.length) {\n                \n                break;\n            }\n\n            \n            dividend[0] = 0;\n            for (int i = 0; i < mant.length; i++) {\n                dividend[i + 1] = remainder[i];\n            }\n        }\n\n        \n        md = mant.length;  \n        for (int i = mant.length + 1; i >= 0; i--) {\n            if (quotient[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        \n        for (int i=0; i<mant.length; i++) {\n            result.mant[mant.length-i-1] = quotient[md-i];\n        }\n\n        \n        result.exp = exp - divisor.exp + md - mant.length;\n        result.sign = (byte) ((sign == divisor.sign) ? 1 : -1);\n\n        if (result.mant[mant.length-1] == 0) { \n            result.exp = 0;\n        }\n\n        if (md > (mant.length-1)) {\n            excp = result.round(quotient[md-mant.length]);\n        } else {\n            excp = result.round(0);\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, divisor, result);\n        }\n\n        return result;\n    }\n\n    \n    public Dfp divide(int divisor) {\n\n        \n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        \n        if (divisor == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, getZero(), result);\n            return result;\n        }\n\n        \n        if (divisor < 0 || divisor >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[i] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) {\n            \n            result.shiftLeft();\n            final int r = rl * RADIX;        \n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[0] = rh;\n        }\n\n        final int excp = result.round(rl * RADIX / divisor);  \n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, result, result);\n        }\n\n        return result;\n\n    }\n\n    \n    public Dfp reciprocal() {\n        return field.getOne().divide(this);\n    }\n\n    \n    public Dfp sqrt() {\n\n        \n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            \n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                \n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            \n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        \n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        \n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        \n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                \n                break;\n            }\n\n            \n            \n            if (dx.mant[mant.length-1] == 0) {\n                break;\n            }\n        }\n\n        return x;\n\n    }\n\n    \n    @Override\n    public String toString() {\n        if (nans != FINITE) {\n            \n            if (nans == INFINITE) {\n                return (sign < 0) ? NEG_INFINITY_STRING : POS_INFINITY_STRING;\n            } else {\n                return NAN_STRING;\n            }\n        }\n\n        if (exp > mant.length || exp < -1) {\n            return dfp2sci();\n        }\n\n        return dfp2string();\n\n    }\n\n    \n    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        \n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            rawdigits[p++] = (char) (((mant[i]) % 10) + '0');\n        }\n\n        \n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        \n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            \n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        \n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        \n        for (p = 1000000000; p > ae; p /= 10) {\n            \n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }\n\n    \n    protected String dfp2string() {\n        char buffer[] = new char[mant.length*4 + 20];\n        int p = 1;\n        int q;\n        int e = exp;\n        boolean pointInserted = false;\n\n        buffer[0] = ' ';\n\n        if (e <= 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '.';\n            pointInserted = true;\n        }\n\n        while (e < 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e++;\n        }\n\n        for (int i = mant.length - 1; i >= 0; i--) {\n            buffer[p++] = (char) ((mant[i] / 1000) + '0');\n            buffer[p++] = (char) (((mant[i] / 100) % 10) + '0');\n            buffer[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            buffer[p++] = (char) (((mant[i]) % 10) + '0');\n            if (--e == 0) {\n                buffer[p++] = '.';\n                pointInserted = true;\n            }\n        }\n\n        while (e > 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e--;\n        }\n\n        if (!pointInserted) {\n            \n            buffer[p++] = '.';\n        }\n\n        \n        q = 1;\n        while (buffer[q] == '0') {\n            q++;\n        }\n        if (buffer[q] == '.') {\n            q--;\n        }\n\n        \n        while (buffer[p-1] == '0') {\n            p--;\n        }\n\n        \n        if (sign < 0) {\n            buffer[--q] = '-';\n        }\n\n        return new String(buffer, q, p - q);\n\n    }\n\n    \n    public Dfp dotrap(int type, String what, Dfp oper, Dfp result) {\n        Dfp def = result;\n\n        switch (type) {\n            case DfpField.FLAG_INVALID:\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = QNAN;\n                break;\n\n            case DfpField.FLAG_DIV_ZERO:\n                if (nans == FINITE && mant[mant.length-1] != 0) {\n                    \n                    def = newInstance(getZero());\n                    def.sign = (byte)(sign*oper.sign);\n                    def.nans = INFINITE;\n                }\n\n                if (nans == FINITE && mant[mant.length-1] == 0) {\n                    \n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == QNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == SNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n                break;\n\n            case DfpField.FLAG_UNDERFLOW:\n                if ( (result.exp+mant.length) < MIN_EXP) {\n                    def = newInstance(getZero());\n                    def.sign = result.sign;\n                } else {\n                    def = newInstance(result);  \n                }\n                result.exp = result.exp + ERR_SCALE;\n                break;\n\n            case DfpField.FLAG_OVERFLOW:\n                result.exp = result.exp - ERR_SCALE;\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = INFINITE;\n                break;\n\n            default: def = result; break;\n        }\n\n        return trap(type, what, oper, def, result);\n\n    }\n\n    \n    protected Dfp trap(int type, String what, Dfp oper, Dfp def, Dfp result) {\n        return def;\n    }\n\n    \n    public int classify() {\n        return nans;\n    }\n\n    \n    public static Dfp copysign(final Dfp x, final Dfp y) {\n        Dfp result = x.newInstance(x);\n        result.sign = y.sign;\n        return result;\n    }\n\n    \n    public Dfp nextAfter(final Dfp x) {\n\n        \n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEXT_AFTER_TRAP, x, result);\n        }\n\n        \n        boolean up = false;\n        if (this.lessThan(x)) {\n            up = true;\n        }\n\n        if (compare(this, x) == 0) {\n            return newInstance(x);\n        }\n\n        if (lessThan(getZero())) {\n            up = !up;\n        }\n\n        final Dfp inc;\n        Dfp result;\n        if (up) {\n            inc = newInstance(getOne());\n            inc.exp = this.exp-mant.length+1;\n            inc.sign = this.sign;\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = add(inc);\n        } else {\n            inc = newInstance(getOne());\n            inc.exp = this.exp;\n            inc.sign = this.sign;\n\n            if (this.equals(inc)) {\n                inc.exp = this.exp-mant.length;\n            } else {\n                inc.exp = this.exp-mant.length+1;\n            }\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = this.subtract(inc);\n        }\n\n        if (result.classify() == INFINITE && this.classify() != INFINITE) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        if (result.equals(getZero()) && this.equals(getZero()) == false) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    \n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        int cmp0 = compare(this, getZero());\n        if (cmp0 == 0) {\n            return sign < 0 ? -0.0 : +0.0;\n        } else if (cmp0 < 0) {\n            y = negate();\n            negate = true;\n        }\n\n        \n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        \n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            \n            mantissa = 0;\n            exponent++;\n        }\n\n        \n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n\n    \n    public double[] toSplitDouble() {\n        double split[] = new double[2];\n        long mask = 0xffffffffc0000000L;\n\n        split[0] = Double.longBitsToDouble(Double.doubleToLongBits(toDouble()) & mask);\n        split[1] = subtract(newInstance(split[0])).toDouble();\n\n        return split;\n    }\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math3.dfp;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.math3.FieldElement;\n\n\npublic class Dfp implements FieldElement<Dfp> { public static final int RADIX = 10000; public static final int MIN_EXP = -32767; public static final int MAX_EXP = 32768; public static final int ERR_SCALE = 32760; public static final byte FINITE = 0; public static final byte INFINITE = 1; public static final byte SNAN = 2; public static final byte QNAN = 3; private static final String NAN_STRING = \"NaN\"; private static final String POS_INFINITY_STRING = \"Infinity\"; private static final String NEG_INFINITY_STRING = \"-Infinity\"; private static final String ADD_TRAP = \"add\"; private static final String MULTIPLY_TRAP = \"multiply\"; private static final String DIVIDE_TRAP = \"divide\"; private static final String SQRT_TRAP = \"sqrt\"; private static final String ALIGN_TRAP = \"align\"; private static final String TRUNC_TRAP = \"trunc\"; private static final String NEXT_AFTER_TRAP = \"nextAfter\"; private static final String LESS_THAN_TRAP = \"lessThan\"; private static final String GREATER_THAN_TRAP = \"greaterThan\"; private static final String NEW_INSTANCE_TRAP = \"newInstance\"; protected int[] mant; protected byte sign; protected int exp; protected byte nans; private final DfpField field; protected Dfp(final DfpField field) {\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n    }\n\n    \n    protected Dfp(final DfpField field, byte x) {\n        this(field, (long) x);\n    }\n\n    \n    protected Dfp(final DfpField field, int x) {\n        this(field, (long) x);\n    }\n\n    \n    protected Dfp(final DfpField field, long x) {\n\n        \n        mant = new int[field.getRadixDigits()];\n        nans = FINITE;\n        this.field = field;\n\n        boolean isLongMin = false;\n        if (x == Long.MIN_VALUE) {\n            \n            \n            isLongMin = true;\n            ++x;\n        }\n\n        \n        if (x < 0) {\n            sign = -1;\n            x = -x;\n        } else {\n            sign = 1;\n        }\n\n        exp = 0;\n        while (x != 0) {\n            System.arraycopy(mant, mant.length - exp, mant, mant.length - 1 - exp, exp);\n            mant[mant.length - 1] = (int) (x % RADIX);\n            x /= RADIX;\n            exp++;\n        }\n\n        if (isLongMin) {\n            \n            \n            for (int i = 0; i < mant.length - 1; i++) {\n                if (mant[i] != 0) {\n                    mant[i]++;\n                    break;\n                }\n            }\n        }\n    }\n\n    \n    protected Dfp(final DfpField field, double x) {\n\n        \n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            \n            if (x == 0) {\n                \n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            \n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            \n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  \n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n\n    \n    public Dfp(final Dfp d) {\n        mant  = d.mant.clone();\n        sign  = d.sign;\n        exp   = d.exp;\n        nans  = d.nans;\n        field = d.field;\n    }\n\n    \n    protected Dfp(final DfpField field, final String s) {\n\n        \n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        boolean decimalFound = false;\n        final int rsize = 4;   \n        final int offset = 4;  \n        final char[] striped = new char[getRadixDigits() * rsize + offset * 2];\n\n        \n        if (s.equals(POS_INFINITY_STRING)) {\n            sign = (byte) 1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NEG_INFINITY_STRING)) {\n            sign = (byte) -1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NAN_STRING)) {\n            sign = (byte) 1;\n            nans = QNAN;\n            return;\n        }\n\n        \n        int p = s.indexOf(\"e\");\n        if (p == -1) { \n            p = s.indexOf(\"E\");\n        }\n\n        final String fpdecimal;\n        int sciexp = 0;\n        if (p != -1) {\n            \n            fpdecimal = s.substring(0, p);\n            String fpexp = s.substring(p+1);\n            boolean negative = false;\n\n            for (int i=0; i<fpexp.length(); i++)\n            {\n                if (fpexp.charAt(i) == '-')\n                {\n                    negative = true;\n                    continue;\n                }\n                if (fpexp.charAt(i) >= '0' && fpexp.charAt(i) <= '9') {\n                    sciexp = sciexp * 10 + fpexp.charAt(i) - '0';\n                }\n            }\n\n            if (negative) {\n                sciexp = -sciexp;\n            }\n        } else {\n            \n            fpdecimal = s;\n        }\n\n        \n        if (fpdecimal.indexOf(\"-\") !=  -1) {\n            sign = -1;\n        }\n\n        \n        p = 0;\n\n        \n        int decimalPos = 0;\n        for (;;) {\n            if (fpdecimal.charAt(p) >= '1' && fpdecimal.charAt(p) <= '9') {\n                break;\n            }\n\n            if (decimalFound && fpdecimal.charAt(p) == '0') {\n                decimalPos--;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n            }\n\n            p++;\n\n            if (p == fpdecimal.length()) {\n                break;\n            }\n        }\n\n        \n        int q = offset;\n        striped[0] = '0';\n        striped[1] = '0';\n        striped[2] = '0';\n        striped[3] = '0';\n        int significantDigits=0;\n        for(;;) {\n            if (p == (fpdecimal.length())) {\n                break;\n            }\n\n            \n            if (q == mant.length*rsize+offset+1) {\n                break;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n                decimalPos = significantDigits;\n                p++;\n                continue;\n            }\n\n            if (fpdecimal.charAt(p) < '0' || fpdecimal.charAt(p) > '9') {\n                p++;\n                continue;\n            }\n\n            striped[q] = fpdecimal.charAt(p);\n            q++;\n            p++;\n            significantDigits++;\n        }\n\n\n        \n        if (decimalFound && q != offset) {\n            for (;;) {\n                q--;\n                if (q == offset) {\n                    break;\n                }\n                if (striped[q] == '0') {\n                    significantDigits--;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        \n        if (decimalFound && significantDigits == 0) {\n            decimalPos = 0;\n        }\n\n        \n        if (!decimalFound) {\n            decimalPos = q-offset;\n        }\n\n        \n        q = offset;  \n        p = significantDigits-1+offset;\n\n        while (p > q) {\n            if (striped[p] != '0') {\n                break;\n            }\n            p--;\n        }\n\n        \n        int i = ((rsize * 100) - decimalPos - sciexp % rsize) % rsize;\n        q -= i;\n        decimalPos += i;\n\n        \n        while ((p - q) < (mant.length * rsize)) {\n            for (i = 0; i < rsize; i++) {\n                striped[++p] = '0';\n            }\n        }\n\n        \n        \n        for (i = mant.length - 1; i >= 0; i--) {\n            mant[i] = (striped[q]   - '0') * 1000 +\n                      (striped[q+1] - '0') * 100  +\n                      (striped[q+2] - '0') * 10   +\n                      (striped[q+3] - '0');\n            q += 4;\n        }\n\n\n        exp = (decimalPos+sciexp) / rsize;\n\n        if (q < striped.length) {\n            \n            round((striped[q] - '0')*1000);\n        }\n\n    }\n\n    \n    protected Dfp(final DfpField field, final byte sign, final byte nans) {\n        this.field = field;\n        this.mant    = new int[field.getRadixDigits()];\n        this.sign    = sign;\n        this.exp     = 0;\n        this.nans    = nans;\n    }\n\n    \n    public Dfp newInstance() {\n        return new Dfp(getField());\n    }\n\n    \n    public Dfp newInstance(final byte x) {\n        return new Dfp(getField(), x);\n    }\n\n    \n    public Dfp newInstance(final int x) {\n        return new Dfp(getField(), x);\n    }\n\n    \n    public Dfp newInstance(final long x) {\n        return new Dfp(getField(), x);\n    }\n\n    \n    public Dfp newInstance(final double x) {\n        return new Dfp(getField(), x);\n    }\n\n    \n    public Dfp newInstance(final Dfp d) {\n\n        \n        if (field.getRadixDigits() != d.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEW_INSTANCE_TRAP, d, result);\n        }\n\n        return new Dfp(d);\n\n    }\n\n    \n    public Dfp newInstance(final String s) {\n        return new Dfp(field, s);\n    }\n\n    \n    public Dfp newInstance(final byte sig, final byte code) {\n        return field.newDfp(sig, code);\n    }\n\n    \n    public DfpField getField() {\n        return field;\n    }\n\n    \n    public int getRadixDigits() {\n        return field.getRadixDigits();\n    }\n\n    \n    public Dfp getZero() {\n        return field.getZero();\n    }\n\n    \n    public Dfp getOne() {\n        return field.getOne();\n    }\n\n    \n    public Dfp getTwo() {\n        return field.getTwo();\n    }\n\n    \n    protected void shiftLeft() {\n        for (int i = mant.length - 1; i > 0; i--) {\n            mant[i] = mant[i-1];\n        }\n        mant[0] = 0;\n        exp--;\n    }\n\n    \n    \n    protected void shiftRight() {\n        for (int i = 0; i < mant.length - 1; i++) {\n            mant[i] = mant[i+1];\n        }\n        mant[mant.length - 1] = 0;\n        exp++;\n    }\n\n    \n    protected int align(int e) {\n        int lostdigit = 0;\n        boolean inexact = false;\n\n        int diff = exp - e;\n\n        int adiff = diff;\n        if (adiff < 0) {\n            adiff = -adiff;\n        }\n\n        if (diff == 0) {\n            return 0;\n        }\n\n        if (adiff > (mant.length + 1)) {\n            \n            Arrays.fill(mant, 0);\n            exp = e;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n\n            return 0;\n        }\n\n        for (int i = 0; i < adiff; i++) {\n            if (diff < 0) {\n                \n                if (lostdigit != 0) {\n                    inexact = true;\n                }\n\n                lostdigit = mant[0];\n\n                shiftRight();\n            } else {\n                shiftLeft();\n            }\n        }\n\n        if (inexact) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n        }\n\n        return lostdigit;\n\n    }\n\n    \n    public boolean lessThan(final Dfp x) {\n\n        \n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, result);\n            return false;\n        }\n\n        \n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) < 0;\n    }\n\n    \n    public boolean greaterThan(final Dfp x) {\n\n        \n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, result);\n            return false;\n        }\n\n        \n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) > 0;\n    }\n\n    \n    public boolean negativeOrNull() {\n\n        if (isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, this, newInstance(getZero()));\n            return false;\n        }\n\n        return (sign < 0) || ((mant[mant.length - 1] == 0) && !isInfinite());\n\n    }\n\n    \n    public boolean strictlyNegative() {\n\n        if (isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, this, newInstance(getZero()));\n            return false;\n        }\n\n        return (sign < 0) && ((mant[mant.length - 1] != 0) || isInfinite());\n\n    }\n\n    \n    public boolean positiveOrNull() {\n\n        if (isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, this, newInstance(getZero()));\n            return false;\n        }\n\n        return (sign > 0) || ((mant[mant.length - 1] == 0) && !isInfinite());\n\n    }\n\n    \n    public boolean strictlyPositive() {\n\n        if (isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, this, newInstance(getZero()));\n            return false;\n        }\n\n        return (sign > 0) && ((mant[mant.length - 1] != 0) || isInfinite());\n\n    }\n\n    \n    public Dfp abs() {\n        Dfp result = newInstance(this);\n        result.sign = 1;\n        return result;\n    }\n\n    \n    public boolean isInfinite() {\n        return nans == INFINITE;\n    }\n\n    \n    public boolean isNaN() {\n        return (nans == QNAN) || (nans == SNAN);\n    }\n\n    \n    public boolean isZero() {\n\n        if (isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, this, newInstance(getZero()));\n            return false;\n        }\n\n        return (mant[mant.length - 1] == 0) && !isInfinite();\n\n    }\n\n    \n    @Override\n    public boolean equals(final Object other) {\n\n        if (other instanceof Dfp) {\n            final Dfp x = (Dfp) other;\n            if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n                return false;\n            }\n\n            return compare(this, x) == 0;\n        }\n\n        return false;\n\n    }\n\n    \n    @Override\n    public int hashCode() {\n        return 17 + (sign << 8) + (nans << 16) + exp + Arrays.hashCode(mant);\n    }\n\n    \n    public boolean unequal(final Dfp x) {\n        if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n            return false;\n        }\n\n        return greaterThan(x) || lessThan(x);\n    }\n\n    \n    private static int compare(final Dfp a, final Dfp b) {\n        \n        if (a.mant[a.mant.length - 1] == 0 && b.mant[b.mant.length - 1] == 0 &&\n            a.nans == FINITE && b.nans == FINITE) {\n            return 0;\n        }\n\n        if (a.sign != b.sign) {\n            if (a.sign == -1) {\n                return -1;\n            } else {\n                return 1;\n            }\n        }\n\n        \n        if (a.nans == INFINITE && b.nans == FINITE) {\n            return a.sign;\n        }\n\n        if (a.nans == FINITE && b.nans == INFINITE) {\n            return -b.sign;\n        }\n\n        if (a.nans == INFINITE && b.nans == INFINITE) {\n            return 0;\n        }\n\n        \n        if (b.mant[b.mant.length-1] != 0 && a.mant[b.mant.length-1] != 0) {\n            if (a.exp < b.exp) {\n                return -a.sign;\n            }\n\n            if (a.exp > b.exp) {\n                return a.sign;\n            }\n        }\n\n        \n        for (int i = a.mant.length - 1; i >= 0; i--) {\n            if (a.mant[i] > b.mant[i]) {\n                return a.sign;\n            }\n\n            if (a.mant[i] < b.mant[i]) {\n                return -a.sign;\n            }\n        }\n\n        return 0;\n\n    }\n\n    \n    public Dfp rint() {\n        return trunc(DfpField.RoundingMode.ROUND_HALF_EVEN);\n    }\n\n    \n    public Dfp floor() {\n        return trunc(DfpField.RoundingMode.ROUND_FLOOR);\n    }\n\n    \n    public Dfp ceil() {\n        return trunc(DfpField.RoundingMode.ROUND_CEIL);\n    }\n\n    \n    public Dfp remainder(final Dfp d) {\n\n        final Dfp result = this.subtract(this.divide(d).rint().multiply(d));\n\n        \n        if (result.mant[mant.length-1] == 0) {\n            result.sign = sign;\n        }\n\n        return result;\n\n    }\n\n    \n    protected Dfp trunc(final DfpField.RoundingMode rmode) {\n        boolean changed = false;\n\n        if (isNaN()) {\n            return newInstance(this);\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n\n        if (mant[mant.length-1] == 0) {\n            \n            return newInstance(this);\n        }\n\n        \n        if (exp < 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            Dfp result = newInstance(getZero());\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        \n\n        if (exp >= mant.length) {\n            return newInstance(this);\n        }\n\n        \n\n        Dfp result = newInstance(this);\n        for (int i = 0; i < mant.length-result.exp; i++) {\n            changed |= result.mant[i] != 0;\n            result.mant[i] = 0;\n        }\n\n        if (changed) {\n            switch (rmode) {\n                case ROUND_FLOOR:\n                    if (result.sign == -1) {\n                        \n                        result = result.add(newInstance(-1));\n                    }\n                    break;\n\n                case ROUND_CEIL:\n                    if (result.sign == 1) {\n                        \n                        result = result.add(getOne());\n                    }\n                    break;\n\n                case ROUND_HALF_EVEN:\n                default:\n                    final Dfp half = newInstance(\"0.5\");\n                    Dfp a = subtract(result);  \n                    a.sign = 1;            \n                    if (a.greaterThan(half)) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n\n                    \n                    if (a.equals(half) && result.exp > 0 && (result.mant[mant.length-result.exp]&1) != 0) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n                    break;\n            }\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);  \n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        return result;\n    }\n\n    \n    public int intValue() {\n        Dfp rounded;\n        int result = 0;\n\n        rounded = rint();\n\n        if (rounded.greaterThan(newInstance(2147483647))) {\n            return 2147483647;\n        }\n\n        if (rounded.lessThan(newInstance(-2147483648))) {\n            return -2147483648;\n        }\n\n        for (int i = mant.length - 1; i >= mant.length - rounded.exp; i--) {\n            result = result * RADIX + rounded.mant[i];\n        }\n\n        if (rounded.sign == -1) {\n            result = -result;\n        }\n\n        return result;\n    }\n\n    \n    public int log10K() {\n        return exp - 1;\n    }\n\n    \n    public Dfp power10K(final int e) {\n        Dfp d = newInstance(getOne());\n        d.exp = e + 1;\n        return d;\n    }\n\n    \n    public int log10() {\n        if (mant[mant.length-1] > 1000) {\n            return exp * 4 - 1;\n        }\n        if (mant[mant.length-1] > 100) {\n            return exp * 4 - 2;\n        }\n        if (mant[mant.length-1] > 10) {\n            return exp * 4 - 3;\n        }\n        return exp * 4 - 4;\n    }\n\n    \n    public Dfp power10(final int e) {\n        Dfp d = newInstance(getOne());\n\n        if (e >= 0) {\n            d.exp = e / 4 + 1;\n        } else {\n            d.exp = (e + 1) / 4;\n        }\n\n        switch ((e % 4 + 4) % 4) {\n            case 0:\n                break;\n            case 1:\n                d = d.multiply(10);\n                break;\n            case 2:\n                d = d.multiply(100);\n                break;\n            default:\n                d = d.multiply(1000);\n        }\n\n        return d;\n    }\n\n    \n    protected int complement(int extra) {\n\n        extra = RADIX-extra;\n        for (int i = 0; i < mant.length; i++) {\n            mant[i] = RADIX-mant[i]-1;\n        }\n\n        int rh = extra / RADIX;\n        extra = extra - rh * RADIX;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] + rh;\n            rh = r / RADIX;\n            mant[i] = r - rh * RADIX;\n        }\n\n        return extra;\n    }\n\n    \n    public Dfp add(final Dfp x) {\n\n        \n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        \n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE) {\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        \n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        \n        Dfp result = newInstance(getZero());\n\n        \n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        \n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        \n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        \n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        \n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        \n        int rh = 0; \n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        \n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        \n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        \n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                \n                result.sign = 1;  \n            }\n        }\n\n        \n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }\n\n    \n    public Dfp negate() {\n        Dfp result = newInstance(this);\n        result.sign = (byte) - result.sign;\n        return result;\n    }\n\n    \n    public Dfp subtract(final Dfp x) {\n        return add(x.negate());\n    }\n\n    \n    protected int round(int n) {\n        boolean inc = false;\n        switch (field.getRoundingMode()) {\n            case ROUND_DOWN:\n                inc = false;\n                break;\n\n            case ROUND_UP:\n                inc = n != 0;       \n                break;\n\n            case ROUND_HALF_UP:\n                inc = n >= 5000;  \n                break;\n\n            case ROUND_HALF_DOWN:\n                inc = n > 5000;  \n                break;\n\n            case ROUND_HALF_EVEN:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 1);  \n                break;\n\n            case ROUND_HALF_ODD:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 0);  \n                break;\n\n            case ROUND_CEIL:\n                inc = sign == 1 && n != 0;  \n                break;\n\n            case ROUND_FLOOR:\n            default:\n                inc = sign == -1 && n != 0;  \n                break;\n        }\n\n        if (inc) {\n            \n            int rh = 1;\n            for (int i = 0; i < mant.length; i++) {\n                final int r = mant[i] + rh;\n                rh = r / RADIX;\n                mant[i] = r - rh * RADIX;\n            }\n\n            if (rh != 0) {\n                shiftRight();\n                mant[mant.length-1] = rh;\n            }\n        }\n\n        \n        if (exp < MIN_EXP) {\n            \n            field.setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW);\n            return DfpField.FLAG_UNDERFLOW;\n        }\n\n        if (exp > MAX_EXP) {\n            \n            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n            return DfpField.FLAG_OVERFLOW;\n        }\n\n        if (n != 0) {\n            \n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            return DfpField.FLAG_INEXACT;\n        }\n\n        return 0;\n\n    }\n\n    \n    public Dfp multiply(final Dfp x) {\n\n        \n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        \n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {\n                result = newInstance(x);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) ||\n                    (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n                return result;\n            }\n        }\n\n        int[] product = new int[mant.length*2];  \n\n        for (int i = 0; i < mant.length; i++) {\n            int rh = 0;  \n            for (int j=0; j<mant.length; j++) {\n                int r = mant[i] * x.mant[j];    \n                r = r + product[i+j] + rh;  \n\n                rh = r / RADIX;\n                product[i+j] = r - rh * RADIX;\n            }\n            product[i+mant.length] = rh;\n        }\n\n        \n        int md = mant.length * 2 - 1;  \n        for (int i = mant.length * 2 - 1; i >= 0; i--) {\n            if (product[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        \n        for (int i = 0; i < mant.length; i++) {\n            result.mant[mant.length - i - 1] = product[md - i];\n        }\n\n        \n        result.exp = exp + x.exp + md - 2 * mant.length + 1;\n        result.sign = (byte)((sign == x.sign)?1:-1);\n\n        if (result.mant[mant.length-1] == 0) {\n            \n            result.exp = 0;\n        }\n\n        final int excp;\n        if (md > (mant.length-1)) {\n            excp = result.round(product[md-mant.length]);\n        } else {\n            excp = result.round(0); \n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    \n    public Dfp multiply(final int x) {\n        if (x >= 0 && x < RADIX) {\n            return multiplyFast(x);\n        } else {\n            return multiply(newInstance(x));\n        }\n    }\n\n    \n    private Dfp multiplyFast(final int x) {\n        Dfp result = newInstance(this);\n\n        \n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE && x != 0) {\n                result = newInstance(this);\n                return result;\n            }\n\n            if (nans == INFINITE && x == 0) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result);\n                return result;\n            }\n        }\n\n        \n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        int rh = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] * x + rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n\n        int lostdigit = 0;\n        if (rh != 0) {\n            lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) { \n            result.exp = 0;\n        }\n\n        final int excp = result.round(lostdigit);\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, result, result);\n        }\n\n        return result;\n    }\n\n    \n    public Dfp divide(Dfp divisor) {\n        int dividend[]; \n        int quotient[]; \n        int remainder[];\n        int qd;         \n        int nsqd;       \n        int trial=0;    \n        int minadj;     \n        boolean trialgood; \n        int md=0;       \n        int excp;       \n\n        \n        if (field.getRadixDigits() != divisor.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        \n        if (nans != FINITE || divisor.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (divisor.isNaN()) {\n                return divisor;\n            }\n\n            if (nans == INFINITE && divisor.nans == FINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == FINITE) {\n                result = newInstance(getZero());\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == INFINITE) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n                return result;\n            }\n        }\n\n        \n        if (divisor.mant[mant.length-1] == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            result = newInstance(getZero());\n            result.sign = (byte) (sign * divisor.sign);\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, divisor, result);\n            return result;\n        }\n\n        dividend = new int[mant.length+1];  \n        quotient = new int[mant.length+2];  \n        remainder = new int[mant.length+1]; \n\n        \n\n        dividend[mant.length] = 0;\n        quotient[mant.length] = 0;\n        quotient[mant.length+1] = 0;\n        remainder[mant.length] = 0;\n\n        \n\n        for (int i = 0; i < mant.length; i++) {\n            dividend[i] = mant[i];\n            quotient[i] = 0;\n            remainder[i] = 0;\n        }\n\n        \n        nsqd = 0;\n        for (qd = mant.length+1; qd >= 0; qd--) {\n            \n\n            \n            final int divMsb = dividend[mant.length]*RADIX+dividend[mant.length-1];\n            int min = divMsb       / (divisor.mant[mant.length-1]+1);\n            int max = (divMsb + 1) / divisor.mant[mant.length-1];\n\n            trialgood = false;\n            while (!trialgood) {\n                \n                trial = (min+max)/2;\n\n                \n                int rh = 0;\n                for (int i = 0; i < mant.length + 1; i++) {\n                    int dm = (i<mant.length)?divisor.mant[i]:0;\n                    final int r = (dm * trial) + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                \n                rh = 1;  \n                for (int i = 0; i < mant.length + 1; i++) {\n                    final int r = ((RADIX-1) - remainder[i]) + dividend[i] + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                \n                if (rh == 0) {\n                    \n                    max = trial-1;\n                    continue;\n                }\n\n                \n                minadj = (remainder[mant.length] * RADIX)+remainder[mant.length-1];\n                minadj = minadj / (divisor.mant[mant.length-1]+1);\n\n                if (minadj >= 2) {\n                    min = trial+minadj;  \n                    continue;\n                }\n\n                \n                trialgood = false;  \n                for (int i = mant.length - 1; i >= 0; i--) {\n                    if (divisor.mant[i] > remainder[i]) {\n                        trialgood = true;\n                    }\n                    if (divisor.mant[i] < remainder[i]) {\n                        break;\n                    }\n                }\n\n                if (remainder[mant.length] != 0) {\n                    trialgood = false;\n                }\n\n                if (trialgood == false) {\n                    min = trial+1;\n                }\n            }\n\n            \n            quotient[qd] = trial;\n            if (trial != 0 || nsqd != 0) {\n                nsqd++;\n            }\n\n            if (field.getRoundingMode() == DfpField.RoundingMode.ROUND_DOWN && nsqd == mant.length) {\n                \n                break;\n            }\n\n            if (nsqd > mant.length) {\n                \n                break;\n            }\n\n            \n            dividend[0] = 0;\n            for (int i = 0; i < mant.length; i++) {\n                dividend[i + 1] = remainder[i];\n            }\n        }\n\n        \n        md = mant.length;  \n        for (int i = mant.length + 1; i >= 0; i--) {\n            if (quotient[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        \n        for (int i=0; i<mant.length; i++) {\n            result.mant[mant.length-i-1] = quotient[md-i];\n        }\n\n        \n        result.exp = exp - divisor.exp + md - mant.length;\n        result.sign = (byte) ((sign == divisor.sign) ? 1 : -1);\n\n        if (result.mant[mant.length-1] == 0) { \n            result.exp = 0;\n        }\n\n        if (md > (mant.length-1)) {\n            excp = result.round(quotient[md-mant.length]);\n        } else {\n            excp = result.round(0);\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, divisor, result);\n        }\n\n        return result;\n    }\n\n    \n    public Dfp divide(int divisor) {\n\n        \n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        \n        if (divisor == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, getZero(), result);\n            return result;\n        }\n\n        \n        if (divisor < 0 || divisor >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[i] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) {\n            \n            result.shiftLeft();\n            final int r = rl * RADIX;        \n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[0] = rh;\n        }\n\n        final int excp = result.round(rl * RADIX / divisor);  \n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, result, result);\n        }\n\n        return result;\n\n    }\n\n    \n    public Dfp reciprocal() {\n        return field.getOne().divide(this);\n    }\n\n    \n    public Dfp sqrt() {\n\n        \n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            \n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                \n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            \n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        \n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        \n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        \n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                \n                break;\n            }\n\n            \n            \n            if (dx.mant[mant.length-1] == 0) {\n                break;\n            }\n        }\n\n        return x;\n\n    }\n\n    \n    @Override\n    public String toString() {\n        if (nans != FINITE) {\n            \n            if (nans == INFINITE) {\n                return (sign < 0) ? NEG_INFINITY_STRING : POS_INFINITY_STRING;\n            } else {\n                return NAN_STRING;\n            }\n        }\n\n        if (exp > mant.length || exp < -1) {\n            return dfp2sci();\n        }\n\n        return dfp2string();\n\n    }\n\n    \n    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        \n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            rawdigits[p++] = (char) (((mant[i]) % 10) + '0');\n        }\n\n        \n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        \n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            \n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        \n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        \n        for (p = 1000000000; p > ae; p /= 10) {\n            \n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }\n\n    \n    protected String dfp2string() {\n        char buffer[] = new char[mant.length*4 + 20];\n        int p = 1;\n        int q;\n        int e = exp;\n        boolean pointInserted = false;\n\n        buffer[0] = ' ';\n\n        if (e <= 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '.';\n            pointInserted = true;\n        }\n\n        while (e < 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e++;\n        }\n\n        for (int i = mant.length - 1; i >= 0; i--) {\n            buffer[p++] = (char) ((mant[i] / 1000) + '0');\n            buffer[p++] = (char) (((mant[i] / 100) % 10) + '0');\n            buffer[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            buffer[p++] = (char) (((mant[i]) % 10) + '0');\n            if (--e == 0) {\n                buffer[p++] = '.';\n                pointInserted = true;\n            }\n        }\n\n        while (e > 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e--;\n        }\n\n        if (!pointInserted) {\n            \n            buffer[p++] = '.';\n        }\n\n        \n        q = 1;\n        while (buffer[q] == '0') {\n            q++;\n        }\n        if (buffer[q] == '.') {\n            q--;\n        }\n\n        \n        while (buffer[p-1] == '0') {\n            p--;\n        }\n\n        \n        if (sign < 0) {\n            buffer[--q] = '-';\n        }\n\n        return new String(buffer, q, p - q);\n\n    }\n\n    \n    public Dfp dotrap(int type, String what, Dfp oper, Dfp result) {\n        Dfp def = result;\n\n        switch (type) {\n            case DfpField.FLAG_INVALID:\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = QNAN;\n                break;\n\n            case DfpField.FLAG_DIV_ZERO:\n                if (nans == FINITE && mant[mant.length-1] != 0) {\n                    \n                    def = newInstance(getZero());\n                    def.sign = (byte)(sign*oper.sign);\n                    def.nans = INFINITE;\n                }\n\n                if (nans == FINITE && mant[mant.length-1] == 0) {\n                    \n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == QNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == SNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n                break;\n\n            case DfpField.FLAG_UNDERFLOW:\n                if ( (result.exp+mant.length) < MIN_EXP) {\n                    def = newInstance(getZero());\n                    def.sign = result.sign;\n                } else {\n                    def = newInstance(result);  \n                }\n                result.exp = result.exp + ERR_SCALE;\n                break;\n\n            case DfpField.FLAG_OVERFLOW:\n                result.exp = result.exp - ERR_SCALE;\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = INFINITE;\n                break;\n\n            default: def = result; break;\n        }\n\n        return trap(type, what, oper, def, result);\n\n    }\n\n    \n    protected Dfp trap(int type, String what, Dfp oper, Dfp def, Dfp result) {\n        return def;\n    }\n\n    \n    public int classify() {\n        return nans;\n    }\n\n    \n    public static Dfp copysign(final Dfp x, final Dfp y) {\n        Dfp result = x.newInstance(x);\n        result.sign = y.sign;\n        return result;\n    }\n\n    \n    public Dfp nextAfter(final Dfp x) {\n\n        \n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEXT_AFTER_TRAP, x, result);\n        }\n\n        \n        boolean up = false;\n        if (this.lessThan(x)) {\n            up = true;\n        }\n\n        if (compare(this, x) == 0) {\n            return newInstance(x);\n        }\n\n        if (lessThan(getZero())) {\n            up = !up;\n        }\n\n        final Dfp inc;\n        Dfp result;\n        if (up) {\n            inc = newInstance(getOne());\n            inc.exp = this.exp-mant.length+1;\n            inc.sign = this.sign;\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = add(inc);\n        } else {\n            inc = newInstance(getOne());\n            inc.exp = this.exp;\n            inc.sign = this.sign;\n\n            if (this.equals(inc)) {\n                inc.exp = this.exp-mant.length;\n            } else {\n                inc.exp = this.exp-mant.length+1;\n            }\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = this.subtract(inc);\n        }\n\n        if (result.classify() == INFINITE && this.classify() != INFINITE) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        if (result.equals(getZero()) && this.equals(getZero()) == false) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    \n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        int cmp0 = compare(this, getZero());\n        if (cmp0 == 0) {\n            return sign < 0 ? -0.0 : +0.0;\n        } else if (cmp0 < 0) {\n            y = negate();\n            negate = true;\n        }\n\n        \n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        \n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            \n            mantissa = 0;\n            exponent++;\n        }\n\n        \n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n\n    \n    public double[] toSplitDouble() {\n        double split[] = new double[2];\n        long mask = 0xffffffffc0000000L;\n\n        split[0] = Double.longBitsToDouble(Double.doubleToLongBits(toDouble()) & mask);\n        split[1] = subtract(newInstance(split[0])).toDouble();\n\n        return split;\n    }\n\n}\n",
      "buggy_signatures": [
        "protected Dfp(final DfpField field, byte x)",
        "protected Dfp(final DfpField field, int x)",
        "protected Dfp(final DfpField field, long x)",
        "protected Dfp(final DfpField field, double x)",
        "public Dfp(final Dfp d)",
        "protected Dfp(final DfpField field, final String s)",
        "protected Dfp(final DfpField field, final byte sign, final byte nans)",
        "public Dfp newInstance()",
        "public Dfp newInstance(final byte x)",
        "public Dfp newInstance(final int x)",
        "public Dfp newInstance(final long x)",
        "public Dfp newInstance(final double x)",
        "public Dfp newInstance(final Dfp d)",
        "public Dfp newInstance(final String s)",
        "public Dfp newInstance(final byte sig, final byte code)",
        "public DfpField getField()",
        "public int getRadixDigits()",
        "public Dfp getZero()",
        "public Dfp getOne()",
        "public Dfp getTwo()",
        "protected void shiftLeft()",
        "protected void shiftRight()",
        "protected int align(int e)",
        "public boolean lessThan(final Dfp x)",
        "public boolean greaterThan(final Dfp x)",
        "public boolean negativeOrNull()",
        "public boolean strictlyNegative()",
        "public boolean positiveOrNull()",
        "public boolean strictlyPositive()",
        "public Dfp abs()",
        "public boolean isInfinite()",
        "public boolean isNaN()",
        "public boolean isZero()",
        "public boolean equals(final Object other)",
        "public int hashCode()",
        "public boolean unequal(final Dfp x)",
        "private static int compare(final Dfp a, final Dfp b)",
        "public Dfp rint()",
        "public Dfp floor()",
        "public Dfp ceil()",
        "public Dfp remainder(final Dfp d)",
        "protected Dfp trunc(final DfpField.RoundingMode rmode)",
        "public int intValue()",
        "public int log10K()",
        "public Dfp power10K(final int e)",
        "public int log10()",
        "public Dfp power10(final int e)",
        "protected int complement(int extra)",
        "public Dfp add(final Dfp x)",
        "public Dfp negate()",
        "public Dfp subtract(final Dfp x)",
        "protected int round(int n)",
        "public Dfp multiply(final Dfp x)",
        "public Dfp multiply(final int x)",
        "private Dfp multiplyFast(final int x)",
        "public Dfp divide(Dfp divisor)",
        "public Dfp divide(int divisor)",
        "public Dfp reciprocal()",
        "public Dfp sqrt()",
        "public String toString()",
        "protected String dfp2sci()",
        "protected String dfp2string()",
        "public Dfp dotrap(int type, String what, Dfp oper, Dfp result)",
        "protected Dfp trap(int type, String what, Dfp oper, Dfp def, Dfp result)",
        "public int classify()",
        "public static Dfp copysign(final Dfp x, final Dfp y)",
        "public Dfp nextAfter(final Dfp x)",
        "public double toDouble()",
        "public double[] toSplitDouble()"
      ],
      "fixed_signatures": [
        "protected Dfp(final DfpField field, byte x)",
        "protected Dfp(final DfpField field, int x)",
        "protected Dfp(final DfpField field, long x)",
        "protected Dfp(final DfpField field, double x)",
        "public Dfp(final Dfp d)",
        "protected Dfp(final DfpField field, final String s)",
        "protected Dfp(final DfpField field, final byte sign, final byte nans)",
        "public Dfp newInstance()",
        "public Dfp newInstance(final byte x)",
        "public Dfp newInstance(final int x)",
        "public Dfp newInstance(final long x)",
        "public Dfp newInstance(final double x)",
        "public Dfp newInstance(final Dfp d)",
        "public Dfp newInstance(final String s)",
        "public Dfp newInstance(final byte sig, final byte code)",
        "public DfpField getField()",
        "public int getRadixDigits()",
        "public Dfp getZero()",
        "public Dfp getOne()",
        "public Dfp getTwo()",
        "protected void shiftLeft()",
        "protected void shiftRight()",
        "protected int align(int e)",
        "public boolean lessThan(final Dfp x)",
        "public boolean greaterThan(final Dfp x)",
        "public boolean negativeOrNull()",
        "public boolean strictlyNegative()",
        "public boolean positiveOrNull()",
        "public boolean strictlyPositive()",
        "public Dfp abs()",
        "public boolean isInfinite()",
        "public boolean isNaN()",
        "public boolean isZero()",
        "public boolean equals(final Object other)",
        "public int hashCode()",
        "public boolean unequal(final Dfp x)",
        "private static int compare(final Dfp a, final Dfp b)",
        "public Dfp rint()",
        "public Dfp floor()",
        "public Dfp ceil()",
        "public Dfp remainder(final Dfp d)",
        "protected Dfp trunc(final DfpField.RoundingMode rmode)",
        "public int intValue()",
        "public int log10K()",
        "public Dfp power10K(final int e)",
        "public int log10()",
        "public Dfp power10(final int e)",
        "protected int complement(int extra)",
        "public Dfp add(final Dfp x)",
        "public Dfp negate()",
        "public Dfp subtract(final Dfp x)",
        "protected int round(int n)",
        "public Dfp multiply(final Dfp x)",
        "public Dfp multiply(final int x)",
        "private Dfp multiplyFast(final int x)",
        "public Dfp divide(Dfp divisor)",
        "public Dfp divide(int divisor)",
        "public Dfp reciprocal()",
        "public Dfp sqrt()",
        "public String toString()",
        "protected String dfp2sci()",
        "protected String dfp2string()",
        "public Dfp dotrap(int type, String what, Dfp oper, Dfp result)",
        "protected Dfp trap(int type, String what, Dfp oper, Dfp def, Dfp result)",
        "public int classify()",
        "public static Dfp copysign(final Dfp x, final Dfp y)",
        "public Dfp nextAfter(final Dfp x)",
        "public double toDouble()",
        "public double[] toSplitDouble()"
      ],
      "methods": [
        {
          "buggy_method": "  public Dfp multiply(final int x) {\n  return multiplyFast(x);\n  }",
          "fixed_method": "  public Dfp multiply(final int x) {\n  if (x >= 0 && x < RADIX) {\n  return multiplyFast(x);\n  } else {\n  return multiply(newInstance(x));\n  }\n  }",
          "diff": [
            "@@ -1600,7 +1600,11 @@",
            "      * @return product of this and x\n",
            "      */\n",
            "     public Dfp multiply(final int x) {\n",
            "+        if (x >= 0 && x < RADIX) {\n",
            "             return multiplyFast(x);\n",
            "+        } else {\n",
            "+            return multiply(newInstance(x));\n",
            "+        }\n",
            "     }\n",
            " \n",
            "     /** Multiply this by a single digit 0&lt;=x&lt;radix.\n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
