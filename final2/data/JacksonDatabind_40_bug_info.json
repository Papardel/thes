{
  "bug_id": "40",
  "failed_tests": {
    "com.fasterxml.jackson.databind.deser.TestSimpleTypes": [
      {
        "methodName": "testEmptyToNullCoercionForPrimitives",
        "error": "junit.framework.AssertionFailedError",
        "message": "Should not have passed",
        "fail_line": "        _testEmptyToNullCoercion(int.class, Integer.valueOf(0));",
        "test_source": "  public void testEmptyToNullCoercionForPrimitives() throws Exception {\n  _testEmptyToNullCoercion(int.class, Integer.valueOf(0));\n  _testEmptyToNullCoercion(long.class, Long.valueOf(0));\n  _testEmptyToNullCoercion(double.class, Double.valueOf(0.0));\n  _testEmptyToNullCoercion(float.class, Float.valueOf(0.0f));\n  }",
        "stack": [
          "TestSimpleTypes._testEmptyToNullCoercion line 280, TestSimpleTypes.testEmptyToNullCoercionForPrimitives line 263"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.HashSet;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n\n\npublic class NumberDeserializers { private final static HashSet<String> _classNames = new HashSet<String>(); static {\n        \n        Class<?>[] numberTypes = new Class<?>[] {\n            Boolean.class,\n            Byte.class,\n            Short.class,\n            Character.class,\n            Integer.class,\n            Long.class,\n            Float.class,\n            Double.class,\n            \n            Number.class, BigDecimal.class, BigInteger.class\n        };\n        for (Class<?> cls : numberTypes) {\n            _classNames.add(cls.getName());\n        }\n    }\n\n    public static JsonDeserializer<?> find(Class<?> rawType, String clsName) {\n        if (rawType.isPrimitive()) {\n            if (rawType == Integer.TYPE) {\n                return IntegerDeserializer.primitiveInstance;\n            }\n            if (rawType == Boolean.TYPE) {\n                return BooleanDeserializer.primitiveInstance;\n            }\n            if (rawType == Long.TYPE) {\n                return LongDeserializer.primitiveInstance;\n            }\n            if (rawType == Double.TYPE) {\n                return DoubleDeserializer.primitiveInstance;\n            }\n            if (rawType == Character.TYPE) {\n                return CharacterDeserializer.primitiveInstance;\n            }\n            if (rawType == Byte.TYPE) {\n                return ByteDeserializer.primitiveInstance;\n            }\n            if (rawType == Short.TYPE) {\n                return ShortDeserializer.primitiveInstance;\n            }\n            if (rawType == Float.TYPE) {\n                return FloatDeserializer.primitiveInstance;\n            }\n        } else if (_classNames.contains(clsName)) {\n            \n            if (rawType == Integer.class) {\n                return IntegerDeserializer.wrapperInstance;\n            }\n            if (rawType == Boolean.class) {\n                return BooleanDeserializer.wrapperInstance;\n            }\n            if (rawType == Long.class) {\n                return LongDeserializer.wrapperInstance;\n            }\n            if (rawType == Double.class) {\n                return DoubleDeserializer.wrapperInstance;\n            }\n            if (rawType == Character.class) {\n                return CharacterDeserializer.wrapperInstance;\n            }\n            if (rawType == Byte.class) {\n                return ByteDeserializer.wrapperInstance;\n            }\n            if (rawType == Short.class) {\n                return ShortDeserializer.wrapperInstance;\n            }\n            if (rawType == Float.class) {\n                return FloatDeserializer.wrapperInstance;\n            }\n            if (rawType == Number.class) {\n                return NumberDeserializer.instance;\n            }\n            if (rawType == BigDecimal.class) {\n                return BigDecimalDeserializer.instance;\n            }\n            if (rawType == BigInteger.class) {\n                return BigIntegerDeserializer.instance;\n            }\n        } else {\n            return null;\n        }\n        \n        throw new IllegalArgumentException(\"Internal error: can't find deserializer for \"+rawType.getName());\n    }\n    \n    \n\n    protected abstract static class PrimitiveOrWrapperDeserializer<T> extends StdScalarDeserializer<T> { private static final long serialVersionUID = 1L; protected final T _nullValue; protected final boolean _primitive; protected PrimitiveOrWrapperDeserializer(Class<T> vc, T nvl) {\n            super(vc);\n            _nullValue = nvl;\n            _primitive = vc.isPrimitive();\n        }\n\n        @Override\n        public final T getNullValue(DeserializationContext ctxt) throws JsonMappingException {\n            if (_primitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n                throw ctxt.mappingException(\n                        \"Can not map JSON null into type %s (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)\",\n                        handledType().toString());\n            }\n            return _nullValue;\n        }\n\n        @Override\n        @Deprecated \n        public final T getNullValue() {\n            return _nullValue;\n        }\n\n            \n            \n    }\n\n    \n\n    @JacksonStdImpl\n    public final static class BooleanDeserializer extends PrimitiveOrWrapperDeserializer<Boolean> { private static final long serialVersionUID = 1L; final static BooleanDeserializer primitiveInstance = new BooleanDeserializer(Boolean.TYPE, Boolean.FALSE); final static BooleanDeserializer wrapperInstance = new BooleanDeserializer(Boolean.class, null); public BooleanDeserializer(Class<Boolean> cls, Boolean nvl) {\n            super(cls, nvl);\n        }\n        \n        @Override\n        public Boolean deserialize(JsonParser j, DeserializationContext ctxt) throws IOException {\n            return _parseBoolean(j, ctxt);\n        }\n\n        \n        \n        @Override\n        public Boolean deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n            return _parseBoolean(p, ctxt);\n        }\n    }\n\n    @JacksonStdImpl\n    public static class ByteDeserializer extends PrimitiveOrWrapperDeserializer<Byte> { private static final long serialVersionUID = 1L; final static ByteDeserializer primitiveInstance = new ByteDeserializer(Byte.TYPE, (byte) 0); final static ByteDeserializer wrapperInstance = new ByteDeserializer(Byte.class, null); public ByteDeserializer(Class<Byte> cls, Byte nvl) {\n            super(cls, nvl);\n        }\n\n        @Override\n        public Byte deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n            return _parseByte(p, ctxt);\n        }\n    }\n\n    @JacksonStdImpl\n    public static class ShortDeserializer extends PrimitiveOrWrapperDeserializer<Short> { private static final long serialVersionUID = 1L; final static ShortDeserializer primitiveInstance = new ShortDeserializer(Short.TYPE, Short.valueOf((short)0)); final static ShortDeserializer wrapperInstance = new ShortDeserializer(Short.class, null); public ShortDeserializer(Class<Short> cls, Short nvl) {\n            super(cls, nvl);\n        }\n\n        @Override\n        public Short deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n            return _parseShort(jp, ctxt);\n        }\n    }\n\n    @JacksonStdImpl\n    public static class CharacterDeserializer extends PrimitiveOrWrapperDeserializer<Character> { private static final long serialVersionUID = 1L; final static CharacterDeserializer primitiveInstance = new CharacterDeserializer(Character.TYPE, '\\0'); final static CharacterDeserializer wrapperInstance = new CharacterDeserializer(Character.class, null); public CharacterDeserializer(Class<Character> cls, Character nvl) {\n            super(cls, nvl);\n        }\n\n        @Override\n        public Character deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n            switch (p.getCurrentTokenId()) {\n            case JsonTokenId.ID_NUMBER_INT: \n                int value = p.getIntValue();\n                if (value >= 0 && value <= 0xFFFF) {\n                    return Character.valueOf((char) value);\n                }\n                break;\n            case JsonTokenId.ID_STRING: \n                \n                String text = p.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                \n                if (text.length() == 0) {\n                    return (Character) getEmptyValue(ctxt);\n                }               \n                break;\n            case JsonTokenId.ID_START_ARRAY:\n                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                    p.nextToken();\n                    final Character C = deserialize(p, ctxt);\n                    if (p.nextToken() != JsonToken.END_ARRAY) {\n                        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \n                                \"Attempted to unwrap single value array for single '\" + _valueClass.getName() + \"' value but there was more than a single value in the array\"\n                                );\n                    }\n                    return C;\n                }\n            }\n            throw ctxt.mappingException(_valueClass, p.getCurrentToken());\n        }\n    }\n\n    @JacksonStdImpl\n    public final static class IntegerDeserializer extends PrimitiveOrWrapperDeserializer<Integer> { private static final long serialVersionUID = 1L; final static IntegerDeserializer primitiveInstance = new IntegerDeserializer(Integer.TYPE, Integer.valueOf(0)); final static IntegerDeserializer wrapperInstance = new IntegerDeserializer(Integer.class, null); public IntegerDeserializer(Class<Integer> cls, Integer nvl) {\n            super(cls, nvl);\n        }\n\n        \n        @Override\n        public boolean isCachable() { return true; }\n\n        @Override\n        public Integer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n            if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {\n                return p.getIntValue();\n            }\n            return _parseInteger(p, ctxt);\n        }\n\n        \n        \n        @Override\n        public Integer deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n            if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {\n                return p.getIntValue();\n            }\n            return _parseInteger(p, ctxt);\n        }\n    }\n\n    @JacksonStdImpl\n    public final static class LongDeserializer extends PrimitiveOrWrapperDeserializer<Long> { private static final long serialVersionUID = 1L; final static LongDeserializer primitiveInstance = new LongDeserializer(Long.TYPE, Long.valueOf(0L)); final static LongDeserializer wrapperInstance = new LongDeserializer(Long.class, null); public LongDeserializer(Class<Long> cls, Long nvl) {\n            super(cls, nvl);\n        }\n\n        \n        @Override\n        public boolean isCachable() { return true; }\n        \n        @Override\n        public Long deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n            if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {\n                return p.getLongValue();\n            }\n            return _parseLong(p, ctxt);\n        }\n    }\n\n    @JacksonStdImpl\n    public static class FloatDeserializer extends PrimitiveOrWrapperDeserializer<Float> { private static final long serialVersionUID = 1L; final static FloatDeserializer primitiveInstance = new FloatDeserializer(Float.TYPE, 0.f); final static FloatDeserializer wrapperInstance = new FloatDeserializer(Float.class, null); public FloatDeserializer(Class<Float> cls, Float nvl) {\n            super(cls, nvl);\n        }\n\n        @Override\n        public Float deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n            return _parseFloat(p, ctxt);\n        }\n    }\n\n    @JacksonStdImpl\n    public static class DoubleDeserializer extends PrimitiveOrWrapperDeserializer<Double> { private static final long serialVersionUID = 1L; final static DoubleDeserializer primitiveInstance = new DoubleDeserializer(Double.TYPE, 0.d); final static DoubleDeserializer wrapperInstance = new DoubleDeserializer(Double.class, null); public DoubleDeserializer(Class<Double> cls, Double nvl) {\n            super(cls, nvl);\n        }\n\n        @Override\n        public Double deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n            return _parseDouble(jp, ctxt);\n        }\n\n        \n        \n        @Override\n        public Double deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n            return _parseDouble(jp, ctxt);\n        }\n    }\n\n    \n    @SuppressWarnings(\"serial\")\n    @JacksonStdImpl\n    public static class NumberDeserializer extends StdScalarDeserializer<Object> { public final static NumberDeserializer instance = new NumberDeserializer(); public NumberDeserializer() {\n            super(Number.class);\n        }\n\n        @Override\n        public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n            switch (p.getCurrentTokenId()) {\n            case JsonTokenId.ID_NUMBER_INT:\n                if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                    return _coerceIntegral(p, ctxt);\n                }\n                return p.getNumberValue();\n\n            case JsonTokenId.ID_NUMBER_FLOAT:\n                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                    return p.getDecimalValue();\n                }\n                return Double.valueOf(p.getDoubleValue());\n\n            case JsonTokenId.ID_STRING:\n                \n                String text = p.getText().trim();\n                if (text.length() == 0) {\n                    return getEmptyValue(ctxt);\n                }\n                if (_hasTextualNull(text)) {\n                    return getNullValue(ctxt);\n                }\n                if (_isPosInf(text)) {\n                    return Double.POSITIVE_INFINITY;\n                }\n                if (_isNegInf(text)) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n                if (_isNaN(text)) {\n                    return Double.NaN;\n                }\n                try {\n                    if (!_isIntNumber(text)) {\n                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                            return new BigDecimal(text);\n                        }\n                        return new Double(text);\n                    }\n                    if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n                        return new BigInteger(text);\n                    }\n                    long value = Long.parseLong(text);\n                    if (!ctxt.isEnabled(DeserializationFeature.USE_LONG_FOR_INTS)) {\n                        if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) {\n                            return Integer.valueOf((int) value);\n                        }\n                    }\n                    return Long.valueOf(value);\n                } catch (IllegalArgumentException iae) {\n                    throw ctxt.weirdStringException(text, _valueClass, \"not a valid number\");\n                }\n            case JsonTokenId.ID_START_ARRAY:\n                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                    p.nextToken();\n                    final Object value = deserialize(p, ctxt);\n                    if (p.nextToken() != JsonToken.END_ARRAY) {\n                        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \n                                \"Attempted to unwrap single value array for single '\" + _valueClass.getName() + \"' value but there was more than a single value in the array\"\n                                );\n                    }\n                    return value;\n                }\n                break;\n            }\n            \n            throw ctxt.mappingException(_valueClass, p.getCurrentToken());\n        }\n\n        \n        @Override\n        public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n            switch (jp.getCurrentTokenId()) {\n            case JsonTokenId.ID_NUMBER_INT:\n            case JsonTokenId.ID_NUMBER_FLOAT:\n            case JsonTokenId.ID_STRING:\n                \n                return deserialize(jp, ctxt);\n            }\n            return typeDeserializer.deserializeTypedFromScalar(jp, ctxt);\n        }\n    }\n\n    \n\n    \n    @SuppressWarnings(\"serial\")\n    @JacksonStdImpl\n    public static class BigIntegerDeserializer extends StdScalarDeserializer<BigInteger> { public final static BigIntegerDeserializer instance = new BigIntegerDeserializer(); public BigIntegerDeserializer() { super(BigInteger.class); }\n\n        @SuppressWarnings(\"incomplete-switch\")\n        @Override\n        public BigInteger deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n            switch (p.getCurrentTokenId()) {\n            case JsonTokenId.ID_NUMBER_INT:\n                switch (p.getNumberType()) {\n                case INT:\n                case LONG:\n                case BIG_INTEGER:\n                    return p.getBigIntegerValue();\n                }\n                break;\n            case JsonTokenId.ID_NUMBER_FLOAT:\n                if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {\n                    _failDoubleToIntCoercion(p, ctxt, \"java.math.BigInteger\");\n                }\n                return p.getDecimalValue().toBigInteger();\n            case JsonTokenId.ID_START_ARRAY:\n                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                    p.nextToken();\n                    final BigInteger value = deserialize(p, ctxt);\n                    if (p.nextToken() != JsonToken.END_ARRAY) {\n                        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY,\n                            \"Attempted to unwrap single value array for single 'BigInteger' value but there was more than a single value in the array\"\n                        );\n                    }\n                    return value;\n                }\n                break;\n            case JsonTokenId.ID_STRING: \n                String text = p.getText().trim();\n                if (text.length() == 0) {\n                    return null;\n                }\n                try {\n                    return new BigInteger(text);\n                } catch (IllegalArgumentException iae) {\n                    throw ctxt.weirdStringException(text, _valueClass, \"not a valid representation\");\n                }\n            }\n            \n            throw ctxt.mappingException(_valueClass, p.getCurrentToken());\n        }\n    }\n    \n    @SuppressWarnings(\"serial\")\n    @JacksonStdImpl\n    public static class BigDecimalDeserializer extends StdScalarDeserializer<BigDecimal> { public final static BigDecimalDeserializer instance = new BigDecimalDeserializer(); public BigDecimalDeserializer() { super(BigDecimal.class); }\n\n        @Override\n        public BigDecimal deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n            switch (p.getCurrentTokenId()) {\n            case JsonTokenId.ID_NUMBER_INT:\n            case JsonTokenId.ID_NUMBER_FLOAT:\n                return p.getDecimalValue();\n            case JsonTokenId.ID_STRING:\n                String text = p.getText().trim();\n                if (text.length() == 0) {\n                    return null;\n                }\n                try {\n                    return new BigDecimal(text);\n                } catch (IllegalArgumentException iae) {\n                    throw ctxt.weirdStringException(text, _valueClass, \"not a valid representation\");\n                }\n            case JsonTokenId.ID_START_ARRAY:\n                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                    p.nextToken();\n                    final BigDecimal value = deserialize(p, ctxt);\n                    if (p.nextToken() != JsonToken.END_ARRAY) {\n                        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY,\n                            \"Attempted to unwrap single value array for single 'BigDecimal' value but there was more than a single value in the array\"\n                        );\n                    }\n                    return value;\n                }\n                break;\n            }\n            \n            throw ctxt.mappingException(_valueClass, p.getCurrentToken());\n        }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.HashSet;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n\n\npublic class NumberDeserializers { private final static HashSet<String> _classNames = new HashSet<String>(); static {\n        \n        Class<?>[] numberTypes = new Class<?>[] {\n            Boolean.class,\n            Byte.class,\n            Short.class,\n            Character.class,\n            Integer.class,\n            Long.class,\n            Float.class,\n            Double.class,\n            \n            Number.class, BigDecimal.class, BigInteger.class\n        };\n        for (Class<?> cls : numberTypes) {\n            _classNames.add(cls.getName());\n        }\n    }\n\n    public static JsonDeserializer<?> find(Class<?> rawType, String clsName) {\n        if (rawType.isPrimitive()) {\n            if (rawType == Integer.TYPE) {\n                return IntegerDeserializer.primitiveInstance;\n            }\n            if (rawType == Boolean.TYPE) {\n                return BooleanDeserializer.primitiveInstance;\n            }\n            if (rawType == Long.TYPE) {\n                return LongDeserializer.primitiveInstance;\n            }\n            if (rawType == Double.TYPE) {\n                return DoubleDeserializer.primitiveInstance;\n            }\n            if (rawType == Character.TYPE) {\n                return CharacterDeserializer.primitiveInstance;\n            }\n            if (rawType == Byte.TYPE) {\n                return ByteDeserializer.primitiveInstance;\n            }\n            if (rawType == Short.TYPE) {\n                return ShortDeserializer.primitiveInstance;\n            }\n            if (rawType == Float.TYPE) {\n                return FloatDeserializer.primitiveInstance;\n            }\n        } else if (_classNames.contains(clsName)) {\n            \n            if (rawType == Integer.class) {\n                return IntegerDeserializer.wrapperInstance;\n            }\n            if (rawType == Boolean.class) {\n                return BooleanDeserializer.wrapperInstance;\n            }\n            if (rawType == Long.class) {\n                return LongDeserializer.wrapperInstance;\n            }\n            if (rawType == Double.class) {\n                return DoubleDeserializer.wrapperInstance;\n            }\n            if (rawType == Character.class) {\n                return CharacterDeserializer.wrapperInstance;\n            }\n            if (rawType == Byte.class) {\n                return ByteDeserializer.wrapperInstance;\n            }\n            if (rawType == Short.class) {\n                return ShortDeserializer.wrapperInstance;\n            }\n            if (rawType == Float.class) {\n                return FloatDeserializer.wrapperInstance;\n            }\n            if (rawType == Number.class) {\n                return NumberDeserializer.instance;\n            }\n            if (rawType == BigDecimal.class) {\n                return BigDecimalDeserializer.instance;\n            }\n            if (rawType == BigInteger.class) {\n                return BigIntegerDeserializer.instance;\n            }\n        } else {\n            return null;\n        }\n        \n        throw new IllegalArgumentException(\"Internal error: can't find deserializer for \"+rawType.getName());\n    }\n    \n    \n\n    protected abstract static class PrimitiveOrWrapperDeserializer<T> extends StdScalarDeserializer<T> { private static final long serialVersionUID = 1L; protected final T _nullValue; protected final boolean _primitive; protected PrimitiveOrWrapperDeserializer(Class<T> vc, T nvl) {\n            super(vc);\n            _nullValue = nvl;\n            _primitive = vc.isPrimitive();\n        }\n\n        @Override\n        public final T getNullValue(DeserializationContext ctxt) throws JsonMappingException {\n            if (_primitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n                throw ctxt.mappingException(\n                        \"Can not map JSON null into type %s (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)\",\n                        handledType().toString());\n            }\n            return _nullValue;\n        }\n\n        @Override\n        @Deprecated \n        public final T getNullValue() {\n            return _nullValue;\n        }\n\n        @Override\n        public T getEmptyValue(DeserializationContext ctxt) throws JsonMappingException {\n            \n            \n            if (_primitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n                throw ctxt.mappingException(\n                        \"Can not map Empty String as null into type %s (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)\",\n                        handledType().toString());\n            }\n            return _nullValue;\n        }\n    }\n\n    \n\n    @JacksonStdImpl\n    public final static class BooleanDeserializer extends PrimitiveOrWrapperDeserializer<Boolean> { private static final long serialVersionUID = 1L; final static BooleanDeserializer primitiveInstance = new BooleanDeserializer(Boolean.TYPE, Boolean.FALSE); final static BooleanDeserializer wrapperInstance = new BooleanDeserializer(Boolean.class, null); public BooleanDeserializer(Class<Boolean> cls, Boolean nvl) {\n            super(cls, nvl);\n        }\n        \n        @Override\n        public Boolean deserialize(JsonParser j, DeserializationContext ctxt) throws IOException {\n            return _parseBoolean(j, ctxt);\n        }\n\n        \n        \n        @Override\n        public Boolean deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n            return _parseBoolean(p, ctxt);\n        }\n    }\n\n    @JacksonStdImpl\n    public static class ByteDeserializer extends PrimitiveOrWrapperDeserializer<Byte> { private static final long serialVersionUID = 1L; final static ByteDeserializer primitiveInstance = new ByteDeserializer(Byte.TYPE, (byte) 0); final static ByteDeserializer wrapperInstance = new ByteDeserializer(Byte.class, null); public ByteDeserializer(Class<Byte> cls, Byte nvl) {\n            super(cls, nvl);\n        }\n\n        @Override\n        public Byte deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n            return _parseByte(p, ctxt);\n        }\n    }\n\n    @JacksonStdImpl\n    public static class ShortDeserializer extends PrimitiveOrWrapperDeserializer<Short> { private static final long serialVersionUID = 1L; final static ShortDeserializer primitiveInstance = new ShortDeserializer(Short.TYPE, Short.valueOf((short)0)); final static ShortDeserializer wrapperInstance = new ShortDeserializer(Short.class, null); public ShortDeserializer(Class<Short> cls, Short nvl) {\n            super(cls, nvl);\n        }\n\n        @Override\n        public Short deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n            return _parseShort(jp, ctxt);\n        }\n    }\n\n    @JacksonStdImpl\n    public static class CharacterDeserializer extends PrimitiveOrWrapperDeserializer<Character> { private static final long serialVersionUID = 1L; final static CharacterDeserializer primitiveInstance = new CharacterDeserializer(Character.TYPE, '\\0'); final static CharacterDeserializer wrapperInstance = new CharacterDeserializer(Character.class, null); public CharacterDeserializer(Class<Character> cls, Character nvl) {\n            super(cls, nvl);\n        }\n\n        @Override\n        public Character deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n            switch (p.getCurrentTokenId()) {\n            case JsonTokenId.ID_NUMBER_INT: \n                int value = p.getIntValue();\n                if (value >= 0 && value <= 0xFFFF) {\n                    return Character.valueOf((char) value);\n                }\n                break;\n            case JsonTokenId.ID_STRING: \n                \n                String text = p.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                \n                if (text.length() == 0) {\n                    return (Character) getEmptyValue(ctxt);\n                }               \n                break;\n            case JsonTokenId.ID_START_ARRAY:\n                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                    p.nextToken();\n                    final Character C = deserialize(p, ctxt);\n                    if (p.nextToken() != JsonToken.END_ARRAY) {\n                        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \n                                \"Attempted to unwrap single value array for single '\" + _valueClass.getName() + \"' value but there was more than a single value in the array\"\n                                );\n                    }\n                    return C;\n                }\n            }\n            throw ctxt.mappingException(_valueClass, p.getCurrentToken());\n        }\n    }\n\n    @JacksonStdImpl\n    public final static class IntegerDeserializer extends PrimitiveOrWrapperDeserializer<Integer> { private static final long serialVersionUID = 1L; final static IntegerDeserializer primitiveInstance = new IntegerDeserializer(Integer.TYPE, Integer.valueOf(0)); final static IntegerDeserializer wrapperInstance = new IntegerDeserializer(Integer.class, null); public IntegerDeserializer(Class<Integer> cls, Integer nvl) {\n            super(cls, nvl);\n        }\n\n        \n        @Override\n        public boolean isCachable() { return true; }\n\n        @Override\n        public Integer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n            if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {\n                return p.getIntValue();\n            }\n            return _parseInteger(p, ctxt);\n        }\n\n        \n        \n        @Override\n        public Integer deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n            if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {\n                return p.getIntValue();\n            }\n            return _parseInteger(p, ctxt);\n        }\n    }\n\n    @JacksonStdImpl\n    public final static class LongDeserializer extends PrimitiveOrWrapperDeserializer<Long> { private static final long serialVersionUID = 1L; final static LongDeserializer primitiveInstance = new LongDeserializer(Long.TYPE, Long.valueOf(0L)); final static LongDeserializer wrapperInstance = new LongDeserializer(Long.class, null); public LongDeserializer(Class<Long> cls, Long nvl) {\n            super(cls, nvl);\n        }\n\n        \n        @Override\n        public boolean isCachable() { return true; }\n        \n        @Override\n        public Long deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n            if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {\n                return p.getLongValue();\n            }\n            return _parseLong(p, ctxt);\n        }\n    }\n\n    @JacksonStdImpl\n    public static class FloatDeserializer extends PrimitiveOrWrapperDeserializer<Float> { private static final long serialVersionUID = 1L; final static FloatDeserializer primitiveInstance = new FloatDeserializer(Float.TYPE, 0.f); final static FloatDeserializer wrapperInstance = new FloatDeserializer(Float.class, null); public FloatDeserializer(Class<Float> cls, Float nvl) {\n            super(cls, nvl);\n        }\n\n        @Override\n        public Float deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n            return _parseFloat(p, ctxt);\n        }\n    }\n\n    @JacksonStdImpl\n    public static class DoubleDeserializer extends PrimitiveOrWrapperDeserializer<Double> { private static final long serialVersionUID = 1L; final static DoubleDeserializer primitiveInstance = new DoubleDeserializer(Double.TYPE, 0.d); final static DoubleDeserializer wrapperInstance = new DoubleDeserializer(Double.class, null); public DoubleDeserializer(Class<Double> cls, Double nvl) {\n            super(cls, nvl);\n        }\n\n        @Override\n        public Double deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n            return _parseDouble(jp, ctxt);\n        }\n\n        \n        \n        @Override\n        public Double deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n            return _parseDouble(jp, ctxt);\n        }\n    }\n\n    \n    @SuppressWarnings(\"serial\")\n    @JacksonStdImpl\n    public static class NumberDeserializer extends StdScalarDeserializer<Object> { public final static NumberDeserializer instance = new NumberDeserializer(); public NumberDeserializer() {\n            super(Number.class);\n        }\n\n        @Override\n        public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n            switch (p.getCurrentTokenId()) {\n            case JsonTokenId.ID_NUMBER_INT:\n                if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                    return _coerceIntegral(p, ctxt);\n                }\n                return p.getNumberValue();\n\n            case JsonTokenId.ID_NUMBER_FLOAT:\n                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                    return p.getDecimalValue();\n                }\n                return Double.valueOf(p.getDoubleValue());\n\n            case JsonTokenId.ID_STRING:\n                \n                String text = p.getText().trim();\n                if (text.length() == 0) {\n                    return getEmptyValue(ctxt);\n                }\n                if (_hasTextualNull(text)) {\n                    return getNullValue(ctxt);\n                }\n                if (_isPosInf(text)) {\n                    return Double.POSITIVE_INFINITY;\n                }\n                if (_isNegInf(text)) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n                if (_isNaN(text)) {\n                    return Double.NaN;\n                }\n                try {\n                    if (!_isIntNumber(text)) {\n                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                            return new BigDecimal(text);\n                        }\n                        return new Double(text);\n                    }\n                    if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n                        return new BigInteger(text);\n                    }\n                    long value = Long.parseLong(text);\n                    if (!ctxt.isEnabled(DeserializationFeature.USE_LONG_FOR_INTS)) {\n                        if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) {\n                            return Integer.valueOf((int) value);\n                        }\n                    }\n                    return Long.valueOf(value);\n                } catch (IllegalArgumentException iae) {\n                    throw ctxt.weirdStringException(text, _valueClass, \"not a valid number\");\n                }\n            case JsonTokenId.ID_START_ARRAY:\n                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                    p.nextToken();\n                    final Object value = deserialize(p, ctxt);\n                    if (p.nextToken() != JsonToken.END_ARRAY) {\n                        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \n                                \"Attempted to unwrap single value array for single '\" + _valueClass.getName() + \"' value but there was more than a single value in the array\"\n                                );\n                    }\n                    return value;\n                }\n                break;\n            }\n            \n            throw ctxt.mappingException(_valueClass, p.getCurrentToken());\n        }\n\n        \n        @Override\n        public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n            switch (jp.getCurrentTokenId()) {\n            case JsonTokenId.ID_NUMBER_INT:\n            case JsonTokenId.ID_NUMBER_FLOAT:\n            case JsonTokenId.ID_STRING:\n                \n                return deserialize(jp, ctxt);\n            }\n            return typeDeserializer.deserializeTypedFromScalar(jp, ctxt);\n        }\n    }\n\n    \n\n    \n    @SuppressWarnings(\"serial\")\n    @JacksonStdImpl\n    public static class BigIntegerDeserializer extends StdScalarDeserializer<BigInteger> { public final static BigIntegerDeserializer instance = new BigIntegerDeserializer(); public BigIntegerDeserializer() { super(BigInteger.class); }\n\n        @SuppressWarnings(\"incomplete-switch\")\n        @Override\n        public BigInteger deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n            switch (p.getCurrentTokenId()) {\n            case JsonTokenId.ID_NUMBER_INT:\n                switch (p.getNumberType()) {\n                case INT:\n                case LONG:\n                case BIG_INTEGER:\n                    return p.getBigIntegerValue();\n                }\n                break;\n            case JsonTokenId.ID_NUMBER_FLOAT:\n                if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {\n                    _failDoubleToIntCoercion(p, ctxt, \"java.math.BigInteger\");\n                }\n                return p.getDecimalValue().toBigInteger();\n            case JsonTokenId.ID_START_ARRAY:\n                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                    p.nextToken();\n                    final BigInteger value = deserialize(p, ctxt);\n                    if (p.nextToken() != JsonToken.END_ARRAY) {\n                        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY,\n                            \"Attempted to unwrap single value array for single 'BigInteger' value but there was more than a single value in the array\"\n                        );\n                    }\n                    return value;\n                }\n                break;\n            case JsonTokenId.ID_STRING: \n                String text = p.getText().trim();\n                if (text.length() == 0) {\n                    return null;\n                }\n                try {\n                    return new BigInteger(text);\n                } catch (IllegalArgumentException iae) {\n                    throw ctxt.weirdStringException(text, _valueClass, \"not a valid representation\");\n                }\n            }\n            \n            throw ctxt.mappingException(_valueClass, p.getCurrentToken());\n        }\n    }\n    \n    @SuppressWarnings(\"serial\")\n    @JacksonStdImpl\n    public static class BigDecimalDeserializer extends StdScalarDeserializer<BigDecimal> { public final static BigDecimalDeserializer instance = new BigDecimalDeserializer(); public BigDecimalDeserializer() { super(BigDecimal.class); }\n\n        @Override\n        public BigDecimal deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n            switch (p.getCurrentTokenId()) {\n            case JsonTokenId.ID_NUMBER_INT:\n            case JsonTokenId.ID_NUMBER_FLOAT:\n                return p.getDecimalValue();\n            case JsonTokenId.ID_STRING:\n                String text = p.getText().trim();\n                if (text.length() == 0) {\n                    return null;\n                }\n                try {\n                    return new BigDecimal(text);\n                } catch (IllegalArgumentException iae) {\n                    throw ctxt.weirdStringException(text, _valueClass, \"not a valid representation\");\n                }\n            case JsonTokenId.ID_START_ARRAY:\n                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                    p.nextToken();\n                    final BigDecimal value = deserialize(p, ctxt);\n                    if (p.nextToken() != JsonToken.END_ARRAY) {\n                        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY,\n                            \"Attempted to unwrap single value array for single 'BigDecimal' value but there was more than a single value in the array\"\n                        );\n                    }\n                    return value;\n                }\n                break;\n            }\n            \n            throw ctxt.mappingException(_valueClass, p.getCurrentToken());\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public static JsonDeserializer<?> find(Class<?> rawType, String clsName)",
        "public final T getNullValue(DeserializationContext ctxt) throws JsonMappingException",
        "public final T getNullValue()",
        "public Boolean deserialize(JsonParser j, DeserializationContext ctxt) throws IOException",
        "public Boolean deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException",
        "public Byte deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public Short deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "public Character deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public boolean isCachable()",
        "public Integer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public Integer deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException",
        "public boolean isCachable()",
        "public Long deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public Float deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public Double deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "public Double deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException",
        "public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException",
        "public BigInteger deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public BigDecimal deserialize(JsonParser p, DeserializationContext ctxt) throws IOException"
      ],
      "fixed_signatures": [
        "public static JsonDeserializer<?> find(Class<?> rawType, String clsName)",
        "public final T getNullValue(DeserializationContext ctxt) throws JsonMappingException",
        "public final T getNullValue()",
        "public T getEmptyValue(DeserializationContext ctxt) throws JsonMappingException",
        "public Boolean deserialize(JsonParser j, DeserializationContext ctxt) throws IOException",
        "public Boolean deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException",
        "public Byte deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public Short deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "public Character deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public boolean isCachable()",
        "public Integer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public Integer deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException",
        "public boolean isCachable()",
        "public Long deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public Float deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public Double deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "public Double deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException",
        "public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException",
        "public BigInteger deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public BigDecimal deserialize(JsonParser p, DeserializationContext ctxt) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  public final T getNullValue() {\n  return _nullValue;\n  }",
          "fixed_method": "  public T getEmptyValue(DeserializationContext ctxt) throws JsonMappingException {\n  \n  \n  if (_primitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n  throw ctxt.mappingException(\n  \"Can not map Empty String as null into type %s (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)\",\n  handledType().toString());\n  }\n  return _nullValue;\n  }",
          "diff": [
            "@@ -145,8 +145,17 @@",
            "             return _nullValue;\n",
            "         }\n",
            " \n",
            "+        @Override\n",
            "+        public T getEmptyValue(DeserializationContext ctxt) throws JsonMappingException {\n",
            "             // [databind#1095]: Should not allow coercion from into null from Empty String\n",
            "             // either, if `null` not allowed\n",
            "+            if (_primitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n",
            "+                throw ctxt.mappingException(\n",
            "+                        \"Can not map Empty String as null into type %s (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)\",\n",
            "+                        handledType().toString());\n",
            "+            }\n",
            "+            return _nullValue;\n",
            "+        }\n",
            "     }\n",
            " \n",
            "     /*\n"
          ],
          "changed_lines": 9
        }
      ]
    }
  ]
}
