{
  "bug_id": "29",
  "failed_tests": {
    "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest": [
      {
        "methodName": "testEncodingInputStream",
        "error": "junit.framework.AssertionFailedError",
        "message": "Tests failed: 20",
        "fail_line": "            fail(\"Tests failed: \" + failed);",
        "test_source": "  public void testEncodingInputStream() throws Exception {\n  int failed = 0;\n  for(int i = 1; i <= TESTS.length; i++) {\n  TestData test = TESTS[i-1];\n  ArchiveInputStream ais = getInputStreamFor(test.type, test.testFile, test.fac);\n  final String field = getField(ais,test.fieldName);\n  if (!eq(test.expectedEncoding,field)) {\n  System.out.println(\"Failed test \" + i + \". expected: \" + test.expectedEncoding + \" actual: \" + field + \" type: \" + test.type);\n  failed++;\n  }\n  }\n  if (failed > 0) {\n  fail(\"Tests failed: \" + failed);\n  }\n  }",
        "stack": [
          "ArchiveStreamFactoryTest.testEncodingInputStream line 319"
        ]
      },
      {
        "methodName": "testEncodingInputStreamAutodetect",
        "error": "junit.framework.AssertionFailedError",
        "message": "Tests failed: 24",
        "fail_line": "            fail(\"Tests failed: \" + failed);",
        "test_source": "  public void testEncodingInputStreamAutodetect() throws Exception {\n  int failed = 0;\n  for(int i = 1; i <= TESTS.length; i++) {\n  TestData test = TESTS[i-1];\n  ArchiveInputStream ais = getInputStreamFor(test.testFile, test.fac);\n  final String field = getField(ais,test.fieldName);\n  if (!eq(test.expectedEncoding,field)) {\n  System.out.println(\"Failed test \" + i + \". expected: \" + test.expectedEncoding + \" actual: \" + field + \" type: \" + test.type);\n  failed++;\n  }\n  }\n  if (failed > 0) {\n  fail(\"Tests failed: \" + failed);\n  }\n  }",
        "stack": [
          "ArchiveStreamFactoryTest.testEncodingInputStreamAutodetect line 302"
        ]
      },
      {
        "methodName": "testEncodingOutputStream",
        "error": "junit.framework.AssertionFailedError",
        "message": "Tests failed: 14",
        "fail_line": "            fail(\"Tests failed: \" + failed);",
        "test_source": "  public void testEncodingOutputStream() throws Exception {\n  int failed = 0;\n  for(int i = 1; i <= TESTS.length; i++) {\n  TestData test = TESTS[i-1];\n  if (test.hasOutputStream) {\n  ArchiveOutputStream ais = getOutputStreamFor(test.type, test.fac);\n  final String field = getField(ais, test.fieldName);\n  if (!eq(test.expectedEncoding, field)) {\n  System.out.println(\"Failed test \" + i + \". expected: \" + test.expectedEncoding + \" actual: \" + field + \" type: \" + test.type);\n  failed++;\n  }\n  }\n  }\n  if (failed > 0) {\n  fail(\"Tests failed: \" + failed);\n  }\n  }",
        "stack": [
          "ArchiveStreamFactoryTest.testEncodingOutputStream line 338"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/compress/archivers/ArchiveStreamFactory.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\nimport org.apache.commons.compress.archivers.ar.ArArchiveInputStream;\nimport org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;\nimport org.apache.commons.compress.archivers.arj.ArjArchiveInputStream;\nimport org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream;\nimport org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream;\nimport org.apache.commons.compress.archivers.dump.DumpArchiveInputStream;\nimport org.apache.commons.compress.archivers.jar.JarArchiveInputStream;\nimport org.apache.commons.compress.archivers.jar.JarArchiveOutputStream;\nimport org.apache.commons.compress.archivers.sevenz.SevenZFile;\nimport org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\nimport org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;\nimport org.apache.commons.compress.utils.IOUtils;\n\n\npublic class ArchiveStreamFactory { public static final String AR = \"ar\"; public static final String ARJ = \"arj\"; public static final String CPIO = \"cpio\"; public static final String DUMP = \"dump\"; public static final String JAR = \"jar\"; public static final String TAR = \"tar\"; public static final String ZIP = \"zip\"; public static final String SEVEN_Z = \"7z\"; private final String encoding; private volatile String entryEncoding = null; public ArchiveStreamFactory() {\n        this(null);\n    }\n\n    \n    public ArchiveStreamFactory(String encoding) {\n        super();\n        this.encoding = encoding;\n        \n        this.entryEncoding = encoding;\n    }\n\n    \n    public String getEntryEncoding() {\n        return entryEncoding;\n    }\n\n    \n    @Deprecated\n    public void setEntryEncoding(String entryEncoding) {\n        \n        if (encoding != null) {\n            throw new IllegalStateException(\"Cannot overide encoding set by the constructor\");\n        }\n        this.entryEncoding = entryEncoding;\n    }\n\n    \n    public ArchiveInputStream createArchiveInputStream( final String archiverName, final InputStream in) throws ArchiveException {\n\n        if (archiverName == null) {\n            throw new IllegalArgumentException(\"Archivername must not be null.\");\n        }\n\n        if (in == null) {\n            throw new IllegalArgumentException(\"InputStream must not be null.\");\n        }\n\n        if (AR.equalsIgnoreCase(archiverName)) {\n            return new ArArchiveInputStream(in);\n        }\n        if (ARJ.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new ArjArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ArjArchiveInputStream(in);\n            }\n        }\n        if (ZIP.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        }\n        if (TAR.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new TarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new TarArchiveInputStream(in);\n            }\n        }\n        if (JAR.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        }\n        if (CPIO.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        }\n        if (DUMP.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new DumpArchiveInputStream(in, entryEncoding);\n            } else {\n                return new DumpArchiveInputStream(in);\n            }\n        }\n        if (SEVEN_Z.equalsIgnoreCase(archiverName)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n\n        throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n    }\n\n    \n    public ArchiveOutputStream createArchiveOutputStream( final String archiverName, final OutputStream out) throws ArchiveException {\n        if (archiverName == null) {\n            throw new IllegalArgumentException(\"Archivername must not be null.\");\n        }\n        if (out == null) {\n            throw new IllegalArgumentException(\"OutputStream must not be null.\");\n        }\n\n        if (AR.equalsIgnoreCase(archiverName)) {\n            return new ArArchiveOutputStream(out);\n        }\n        if (ZIP.equalsIgnoreCase(archiverName)) {\n            ZipArchiveOutputStream zip = new ZipArchiveOutputStream(out);\n            if (entryEncoding != null) {\n                zip.setEncoding(entryEncoding);\n            }\n            return zip;\n        }\n        if (TAR.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new TarArchiveOutputStream(out, entryEncoding);\n            } else {\n                return new TarArchiveOutputStream(out);\n            }\n        }\n        if (JAR.equalsIgnoreCase(archiverName)) {\n                return new JarArchiveOutputStream(out);\n        }\n        if (CPIO.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveOutputStream(out, entryEncoding);\n            } else {\n                return new CpioArchiveOutputStream(out);\n            }\n        }\n        if (SEVEN_Z.equalsIgnoreCase(archiverName)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n    }\n\n    \n    public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n        if (in == null) {\n            throw new IllegalArgumentException(\"Stream must not be null.\");\n        }\n\n        if (!in.markSupported()) {\n            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n\n        final byte[] signature = new byte[12];\n        in.mark(signature.length);\n        try {\n            int signatureLength = IOUtils.readFully(in, signature);\n            in.reset();\n            if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n                if (entryEncoding != null) {\n                    return new ZipArchiveInputStream(in, entryEncoding);\n                } else {\n                    return new ZipArchiveInputStream(in);\n                }\n            } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n                if (entryEncoding != null) {\n                    return new JarArchiveInputStream(in, entryEncoding);\n                } else {\n                    return new JarArchiveInputStream(in);\n                }\n            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n                return new ArArchiveInputStream(in);\n            } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n                if (entryEncoding != null) {\n                    return new CpioArchiveInputStream(in, entryEncoding);\n                } else {\n                    return new CpioArchiveInputStream(in);\n                }\n            } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n                    return new ArjArchiveInputStream(in);\n            } else if (SevenZFile.matches(signature, signatureLength)) {\n                throw new StreamingNotSupportedException(SEVEN_Z);\n            }\n\n            \n            final byte[] dumpsig = new byte[32];\n            in.mark(dumpsig.length);\n            signatureLength = IOUtils.readFully(in, dumpsig);\n            in.reset();\n            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n                return new DumpArchiveInputStream(in, entryEncoding);\n            }\n\n            \n            final byte[] tarheader = new byte[512];\n            in.mark(tarheader.length);\n            signatureLength = IOUtils.readFully(in, tarheader);\n            in.reset();\n            if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n                return new TarArchiveInputStream(in, entryEncoding);\n            }\n            \n            if (signatureLength >= 512) {\n                TarArchiveInputStream tais = null;\n                try {\n                    tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                    \n                    if (tais.getNextTarEntry().isCheckSumOK()) {\n                        return new TarArchiveInputStream(in, encoding);\n                    }\n                } catch (Exception e) { \n                    \n                    \n                    \n                    \n                } finally {\n                    IOUtils.closeQuietly(tais);\n                }\n            }\n        } catch (IOException e) {\n            throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n        }\n\n        throw new ArchiveException(\"No Archiver found for the stream signature\");\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\nimport org.apache.commons.compress.archivers.ar.ArArchiveInputStream;\nimport org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;\nimport org.apache.commons.compress.archivers.arj.ArjArchiveInputStream;\nimport org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream;\nimport org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream;\nimport org.apache.commons.compress.archivers.dump.DumpArchiveInputStream;\nimport org.apache.commons.compress.archivers.jar.JarArchiveInputStream;\nimport org.apache.commons.compress.archivers.jar.JarArchiveOutputStream;\nimport org.apache.commons.compress.archivers.sevenz.SevenZFile;\nimport org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\nimport org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;\nimport org.apache.commons.compress.utils.IOUtils;\n\n\npublic class ArchiveStreamFactory { public static final String AR = \"ar\"; public static final String ARJ = \"arj\"; public static final String CPIO = \"cpio\"; public static final String DUMP = \"dump\"; public static final String JAR = \"jar\"; public static final String TAR = \"tar\"; public static final String ZIP = \"zip\"; public static final String SEVEN_Z = \"7z\"; private final String encoding; private volatile String entryEncoding = null; public ArchiveStreamFactory() {\n        this(null);\n    }\n\n    \n    public ArchiveStreamFactory(String encoding) {\n        super();\n        this.encoding = encoding;\n        \n        this.entryEncoding = encoding;\n    }\n\n    \n    public String getEntryEncoding() {\n        return entryEncoding;\n    }\n\n    \n    @Deprecated\n    public void setEntryEncoding(String entryEncoding) {\n        \n        if (encoding != null) {\n            throw new IllegalStateException(\"Cannot overide encoding set by the constructor\");\n        }\n        this.entryEncoding = entryEncoding;\n    }\n\n    \n    public ArchiveInputStream createArchiveInputStream( final String archiverName, final InputStream in) throws ArchiveException {\n\n        if (archiverName == null) {\n            throw new IllegalArgumentException(\"Archivername must not be null.\");\n        }\n\n        if (in == null) {\n            throw new IllegalArgumentException(\"InputStream must not be null.\");\n        }\n\n        if (AR.equalsIgnoreCase(archiverName)) {\n            return new ArArchiveInputStream(in);\n        }\n        if (ARJ.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new ArjArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ArjArchiveInputStream(in);\n            }\n        }\n        if (ZIP.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        }\n        if (TAR.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new TarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new TarArchiveInputStream(in);\n            }\n        }\n        if (JAR.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        }\n        if (CPIO.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        }\n        if (DUMP.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new DumpArchiveInputStream(in, entryEncoding);\n            } else {\n                return new DumpArchiveInputStream(in);\n            }\n        }\n        if (SEVEN_Z.equalsIgnoreCase(archiverName)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n\n        throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n    }\n\n    \n    public ArchiveOutputStream createArchiveOutputStream( final String archiverName, final OutputStream out) throws ArchiveException {\n        if (archiverName == null) {\n            throw new IllegalArgumentException(\"Archivername must not be null.\");\n        }\n        if (out == null) {\n            throw new IllegalArgumentException(\"OutputStream must not be null.\");\n        }\n\n        if (AR.equalsIgnoreCase(archiverName)) {\n            return new ArArchiveOutputStream(out);\n        }\n        if (ZIP.equalsIgnoreCase(archiverName)) {\n            ZipArchiveOutputStream zip = new ZipArchiveOutputStream(out);\n            if (entryEncoding != null) {\n                zip.setEncoding(entryEncoding);\n            }\n            return zip;\n        }\n        if (TAR.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new TarArchiveOutputStream(out, entryEncoding);\n            } else {\n                return new TarArchiveOutputStream(out);\n            }\n        }\n        if (JAR.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new JarArchiveOutputStream(out, entryEncoding);\n            } else {\n                return new JarArchiveOutputStream(out);\n            }\n        }\n        if (CPIO.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveOutputStream(out, entryEncoding);\n            } else {\n                return new CpioArchiveOutputStream(out);\n            }\n        }\n        if (SEVEN_Z.equalsIgnoreCase(archiverName)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n    }\n\n    \n    public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n        if (in == null) {\n            throw new IllegalArgumentException(\"Stream must not be null.\");\n        }\n\n        if (!in.markSupported()) {\n            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n\n        final byte[] signature = new byte[12];\n        in.mark(signature.length);\n        try {\n            int signatureLength = IOUtils.readFully(in, signature);\n            in.reset();\n            if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n                if (entryEncoding != null) {\n                    return new ZipArchiveInputStream(in, entryEncoding);\n                } else {\n                    return new ZipArchiveInputStream(in);\n                }\n            } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n                if (entryEncoding != null) {\n                    return new JarArchiveInputStream(in, entryEncoding);\n                } else {\n                    return new JarArchiveInputStream(in);\n                }\n            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n                return new ArArchiveInputStream(in);\n            } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n                if (entryEncoding != null) {\n                    return new CpioArchiveInputStream(in, entryEncoding);\n                } else {\n                    return new CpioArchiveInputStream(in);\n                }\n            } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n                if (entryEncoding != null) {\n                    return new ArjArchiveInputStream(in, entryEncoding);\n                } else {\n                    return new ArjArchiveInputStream(in);\n                }\n            } else if (SevenZFile.matches(signature, signatureLength)) {\n                throw new StreamingNotSupportedException(SEVEN_Z);\n            }\n\n            \n            final byte[] dumpsig = new byte[32];\n            in.mark(dumpsig.length);\n            signatureLength = IOUtils.readFully(in, dumpsig);\n            in.reset();\n            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n                return new DumpArchiveInputStream(in, entryEncoding);\n            }\n\n            \n            final byte[] tarheader = new byte[512];\n            in.mark(tarheader.length);\n            signatureLength = IOUtils.readFully(in, tarheader);\n            in.reset();\n            if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n                return new TarArchiveInputStream(in, entryEncoding);\n            }\n            \n            if (signatureLength >= 512) {\n                TarArchiveInputStream tais = null;\n                try {\n                    tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                    \n                    if (tais.getNextTarEntry().isCheckSumOK()) {\n                        return new TarArchiveInputStream(in, encoding);\n                    }\n                } catch (Exception e) { \n                    \n                    \n                    \n                    \n                } finally {\n                    IOUtils.closeQuietly(tais);\n                }\n            }\n        } catch (IOException e) {\n            throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n        }\n\n        throw new ArchiveException(\"No Archiver found for the stream signature\");\n    }\n\n}\n",
      "buggy_signatures": [
        "public ArchiveStreamFactory(String encoding)",
        "public String getEntryEncoding()",
        "public void setEntryEncoding(String entryEncoding)",
        "public ArchiveInputStream createArchiveInputStream( final String archiverName, final InputStream in) throws ArchiveException",
        "public ArchiveOutputStream createArchiveOutputStream( final String archiverName, final OutputStream out) throws ArchiveException",
        "public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException"
      ],
      "fixed_signatures": [
        "public ArchiveStreamFactory(String encoding)",
        "public String getEntryEncoding()",
        "public void setEntryEncoding(String entryEncoding)",
        "public ArchiveInputStream createArchiveInputStream( final String archiverName, final InputStream in) throws ArchiveException",
        "public ArchiveOutputStream createArchiveOutputStream( final String archiverName, final OutputStream out) throws ArchiveException",
        "public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException"
      ],
      "methods": [
        {
          "buggy_method": "  public ArchiveOutputStream createArchiveOutputStream( final String archiverName, final OutputStream out) throws ArchiveException {\n  if (archiverName == null) {\n  throw new IllegalArgumentException(\"Archivername must not be null.\");\n  }\n  if (out == null) {\n  throw new IllegalArgumentException(\"OutputStream must not be null.\");\n  }\n\n  if (AR.equalsIgnoreCase(archiverName)) {\n  return new ArArchiveOutputStream(out);\n  }\n  if (ZIP.equalsIgnoreCase(archiverName)) {\n  ZipArchiveOutputStream zip = new ZipArchiveOutputStream(out);\n  if (entryEncoding != null) {\n  zip.setEncoding(entryEncoding);\n  }\n  return zip;\n  }\n  if (TAR.equalsIgnoreCase(archiverName)) {\n  if (entryEncoding != null) {\n  return new TarArchiveOutputStream(out, entryEncoding);\n  } else {\n  return new TarArchiveOutputStream(out);\n  }\n  }\n  if (JAR.equalsIgnoreCase(archiverName)) {\n  return new JarArchiveOutputStream(out);\n  }\n  if (CPIO.equalsIgnoreCase(archiverName)) {\n  if (entryEncoding != null) {\n  return new CpioArchiveOutputStream(out, entryEncoding);\n  } else {\n  return new CpioArchiveOutputStream(out);\n  }\n  }\n  if (SEVEN_Z.equalsIgnoreCase(archiverName)) {\n  throw new StreamingNotSupportedException(SEVEN_Z);\n  }\n  throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n  }",
          "fixed_method": "  public ArchiveOutputStream createArchiveOutputStream( final String archiverName, final OutputStream out) throws ArchiveException {\n  if (archiverName == null) {\n  throw new IllegalArgumentException(\"Archivername must not be null.\");\n  }\n  if (out == null) {\n  throw new IllegalArgumentException(\"OutputStream must not be null.\");\n  }\n\n  if (AR.equalsIgnoreCase(archiverName)) {\n  return new ArArchiveOutputStream(out);\n  }\n  if (ZIP.equalsIgnoreCase(archiverName)) {\n  ZipArchiveOutputStream zip = new ZipArchiveOutputStream(out);\n  if (entryEncoding != null) {\n  zip.setEncoding(entryEncoding);\n  }\n  return zip;\n  }\n  if (TAR.equalsIgnoreCase(archiverName)) {\n  if (entryEncoding != null) {\n  return new TarArchiveOutputStream(out, entryEncoding);\n  } else {\n  return new TarArchiveOutputStream(out);\n  }\n  }\n  if (JAR.equalsIgnoreCase(archiverName)) {\n  if (entryEncoding != null) {\n  return new JarArchiveOutputStream(out, entryEncoding);\n  } else {\n  return new JarArchiveOutputStream(out);\n  }\n  }\n  if (CPIO.equalsIgnoreCase(archiverName)) {\n  if (entryEncoding != null) {\n  return new CpioArchiveOutputStream(out, entryEncoding);\n  } else {\n  return new CpioArchiveOutputStream(out);\n  }\n  }\n  if (SEVEN_Z.equalsIgnoreCase(archiverName)) {\n  throw new StreamingNotSupportedException(SEVEN_Z);\n  }\n  throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n  }",
          "diff": [
            "@@ -294,7 +294,11 @@",
            "             }\n",
            "         }\n",
            "         if (JAR.equalsIgnoreCase(archiverName)) {\n",
            "+            if (entryEncoding != null) {\n",
            "+                return new JarArchiveOutputStream(out, entryEncoding);\n",
            "+            } else {\n",
            "                 return new JarArchiveOutputStream(out);\n",
            "+            }\n",
            "         }\n",
            "         if (CPIO.equalsIgnoreCase(archiverName)) {\n",
            "             if (entryEncoding != null) {\n"
          ],
          "changed_lines": 4
        },
        {
          "buggy_method": "  public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n  if (in == null) {\n  throw new IllegalArgumentException(\"Stream must not be null.\");\n  }\n\n  if (!in.markSupported()) {\n  throw new IllegalArgumentException(\"Mark is not supported.\");\n  }\n\n  final byte[] signature = new byte[12];\n  in.mark(signature.length);\n  try {\n  int signatureLength = IOUtils.readFully(in, signature);\n  in.reset();\n  if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n  if (entryEncoding != null) {\n  return new ZipArchiveInputStream(in, entryEncoding);\n  } else {\n  return new ZipArchiveInputStream(in);\n  }\n  } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n  if (entryEncoding != null) {\n  return new JarArchiveInputStream(in, entryEncoding);\n  } else {\n  return new JarArchiveInputStream(in);\n  }\n  } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n  return new ArArchiveInputStream(in);\n  } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n  if (entryEncoding != null) {\n  return new CpioArchiveInputStream(in, entryEncoding);\n  } else {\n  return new CpioArchiveInputStream(in);\n  }\n  } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n  return new ArjArchiveInputStream(in);\n  } else if (SevenZFile.matches(signature, signatureLength)) {\n  throw new StreamingNotSupportedException(SEVEN_Z);\n  }\n\n  \n  final byte[] dumpsig = new byte[32];\n  in.mark(dumpsig.length);\n  signatureLength = IOUtils.readFully(in, dumpsig);\n  in.reset();\n  if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n  return new DumpArchiveInputStream(in, entryEncoding);\n  }\n\n  \n  final byte[] tarheader = new byte[512];\n  in.mark(tarheader.length);\n  signatureLength = IOUtils.readFully(in, tarheader);\n  in.reset();\n  if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n  return new TarArchiveInputStream(in, entryEncoding);\n  }\n  \n  if (signatureLength >= 512) {\n  TarArchiveInputStream tais = null;\n  try {\n  tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n  \n  if (tais.getNextTarEntry().isCheckSumOK()) {\n  return new TarArchiveInputStream(in, encoding);\n  }\n  } catch (Exception e) { \n  \n  \n  \n  \n  } finally {\n  IOUtils.closeQuietly(tais);\n  }\n  }\n  } catch (IOException e) {\n  throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n  }\n\n  throw new ArchiveException(\"No Archiver found for the stream signature\");\n  }",
          "fixed_method": "  public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n  if (in == null) {\n  throw new IllegalArgumentException(\"Stream must not be null.\");\n  }\n\n  if (!in.markSupported()) {\n  throw new IllegalArgumentException(\"Mark is not supported.\");\n  }\n\n  final byte[] signature = new byte[12];\n  in.mark(signature.length);\n  try {\n  int signatureLength = IOUtils.readFully(in, signature);\n  in.reset();\n  if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n  if (entryEncoding != null) {\n  return new ZipArchiveInputStream(in, entryEncoding);\n  } else {\n  return new ZipArchiveInputStream(in);\n  }\n  } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n  if (entryEncoding != null) {\n  return new JarArchiveInputStream(in, entryEncoding);\n  } else {\n  return new JarArchiveInputStream(in);\n  }\n  } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n  return new ArArchiveInputStream(in);\n  } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n  if (entryEncoding != null) {\n  return new CpioArchiveInputStream(in, entryEncoding);\n  } else {\n  return new CpioArchiveInputStream(in);\n  }\n  } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n  if (entryEncoding != null) {\n  return new ArjArchiveInputStream(in, entryEncoding);\n  } else {\n  return new ArjArchiveInputStream(in);\n  }\n  } else if (SevenZFile.matches(signature, signatureLength)) {\n  throw new StreamingNotSupportedException(SEVEN_Z);\n  }\n\n  \n  final byte[] dumpsig = new byte[32];\n  in.mark(dumpsig.length);\n  signatureLength = IOUtils.readFully(in, dumpsig);\n  in.reset();\n  if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n  return new DumpArchiveInputStream(in, entryEncoding);\n  }\n\n  \n  final byte[] tarheader = new byte[512];\n  in.mark(tarheader.length);\n  signatureLength = IOUtils.readFully(in, tarheader);\n  in.reset();\n  if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n  return new TarArchiveInputStream(in, entryEncoding);\n  }\n  \n  if (signatureLength >= 512) {\n  TarArchiveInputStream tais = null;\n  try {\n  tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n  \n  if (tais.getNextTarEntry().isCheckSumOK()) {\n  return new TarArchiveInputStream(in, encoding);\n  }\n  } catch (Exception e) { \n  \n  \n  \n  \n  } finally {\n  IOUtils.closeQuietly(tais);\n  }\n  }\n  } catch (IOException e) {\n  throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n  }\n\n  throw new ArchiveException(\"No Archiver found for the stream signature\");\n  }",
          "diff": [
            "@@ -357,7 +361,11 @@",
            "                     return new CpioArchiveInputStream(in);\n",
            "                 }\n",
            "             } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n",
            "+                if (entryEncoding != null) {\n",
            "+                    return new ArjArchiveInputStream(in, entryEncoding);\n",
            "+                } else {\n",
            "                     return new ArjArchiveInputStream(in);\n",
            "+                }\n",
            "             } else if (SevenZFile.matches(signature, signatureLength)) {\n",
            "                 throw new StreamingNotSupportedException(SEVEN_Z);\n",
            "             }\n"
          ],
          "changed_lines": 4
        }
      ]
    },
    {
      "name": "org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.cpio;\n\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.archivers.zip.ZipEncoding;\nimport org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\nimport org.apache.commons.compress.utils.ArchiveUtils;\nimport org.apache.commons.compress.utils.CharsetNames;\nimport org.apache.commons.compress.utils.IOUtils;\n\n\n\npublic class CpioArchiveInputStream extends ArchiveInputStream implements CpioConstants { private boolean closed = false; private CpioArchiveEntry entry; private long entryBytesRead = 0; private boolean entryEOF = false; private final byte tmpbuf[] = new byte[4096]; private long crc = 0; private final InputStream in; private final byte[] TWO_BYTES_BUF = new byte[2]; private final byte[] FOUR_BYTES_BUF = new byte[4]; private final byte[] SIX_BYTES_BUF = new byte[6]; private final int blockSize; private final ZipEncoding zipEncoding; public CpioArchiveInputStream(final InputStream in) {\n        this(in, BLOCK_SIZE, CharsetNames.US_ASCII);\n    }\n\n    \n    public CpioArchiveInputStream(final InputStream in, String encoding) {\n        this(in, BLOCK_SIZE, encoding);\n    }\n\n    \n    public CpioArchiveInputStream(final InputStream in, int blockSize) {\n        this(in, blockSize, CharsetNames.US_ASCII);\n    }\n\n    \n    public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n        this.in = in;\n        this.blockSize = blockSize;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    }\n\n    \n    @Override\n    public int available() throws IOException {\n        ensureOpen();\n        if (this.entryEOF) {\n            return 0;\n        }\n        return 1;\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        if (!this.closed) {\n            in.close();\n            this.closed = true;\n        }\n    }\n\n    \n    private void closeEntry() throws IOException {\n        \n        \n        while (skip((long) Integer.MAX_VALUE) == Integer.MAX_VALUE) { \n            \n        }\n    }\n\n    \n    private void ensureOpen() throws IOException {\n        if (this.closed) {\n            throw new IOException(\"Stream closed\");\n        }\n    }\n\n    \n    public CpioArchiveEntry getNextCPIOEntry() throws IOException {\n        ensureOpen();\n        if (this.entry != null) {\n            closeEntry();\n        }\n        readFully(TWO_BYTES_BUF, 0, TWO_BYTES_BUF.length);\n        if (CpioUtil.byteArray2long(TWO_BYTES_BUF, false) == MAGIC_OLD_BINARY) {\n            this.entry = readOldBinaryEntry(false);\n        } else if (CpioUtil.byteArray2long(TWO_BYTES_BUF, true)\n                   == MAGIC_OLD_BINARY) {\n            this.entry = readOldBinaryEntry(true);\n        } else {\n            System.arraycopy(TWO_BYTES_BUF, 0, SIX_BYTES_BUF, 0,\n                             TWO_BYTES_BUF.length);\n            readFully(SIX_BYTES_BUF, TWO_BYTES_BUF.length,\n                      FOUR_BYTES_BUF.length);\n            String magicString = ArchiveUtils.toAsciiString(SIX_BYTES_BUF);\n            if (magicString.equals(MAGIC_NEW)) {\n                this.entry = readNewEntry(false);\n            } else if (magicString.equals(MAGIC_NEW_CRC)) {\n                this.entry = readNewEntry(true);\n            } else if (magicString.equals(MAGIC_OLD_ASCII)) {\n                this.entry = readOldAsciiEntry();\n            } else {\n                throw new IOException(\"Unknown magic [\" + magicString + \"]. Occured at byte: \" + getBytesRead());\n            }\n        }\n\n        this.entryBytesRead = 0;\n        this.entryEOF = false;\n        this.crc = 0;\n\n        if (this.entry.getName().equals(CPIO_TRAILER)) {\n            this.entryEOF = true;\n            skipRemainderOfLastBlock();\n            return null;\n        }\n        return this.entry;\n    }\n\n    private void skip(int bytes) throws IOException {\n        \n        if (bytes > 0) {\n            readFully(FOUR_BYTES_BUF, 0, bytes);\n        }\n    }\n\n    \n    @Override\n    public int read(final byte[] b, final int off, final int len) throws IOException {\n        ensureOpen();\n        if (off < 0 || len < 0 || off > b.length - len) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        }\n\n        if (this.entry == null || this.entryEOF) {\n            return -1;\n        }\n        if (this.entryBytesRead == this.entry.getSize()) {\n            skip(entry.getDataPadCount());\n            this.entryEOF = true;\n            if (this.entry.getFormat() == FORMAT_NEW_CRC\n                && this.crc != this.entry.getChksum()) {\n                throw new IOException(\"CRC Error. Occured at byte: \"\n                                      + getBytesRead());\n            }\n            return -1; \n        }\n        int tmplength = (int) Math.min(len, this.entry.getSize()\n                - this.entryBytesRead);\n        if (tmplength < 0) {\n            return -1;\n        }\n\n        int tmpread = readFully(b, off, tmplength);\n        if (this.entry.getFormat() == FORMAT_NEW_CRC) {\n            for (int pos = 0; pos < tmpread; pos++) {\n                this.crc += b[pos] & 0xFF;\n            }\n        }\n        this.entryBytesRead += tmpread;\n\n        return tmpread;\n    }\n\n    private final int readFully(final byte[] b, final int off, final int len) throws IOException {\n        int count = IOUtils.readFully(in, b, off, len);\n        count(count);\n        if (count < len) {\n            throw new EOFException();\n        }\n        return count;\n    }\n\n    private long readBinaryLong(final int length, final boolean swapHalfWord) throws IOException {\n        byte tmp[] = new byte[length];\n        readFully(tmp, 0, tmp.length);\n        return CpioUtil.byteArray2long(tmp, swapHalfWord);\n    }\n\n    private long readAsciiLong(final int length, final int radix) throws IOException {\n        byte tmpBuffer[] = new byte[length];\n        readFully(tmpBuffer, 0, tmpBuffer.length);\n        return Long.parseLong(ArchiveUtils.toAsciiString(tmpBuffer), radix);\n    }\n\n    private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException {\n        CpioArchiveEntry ret;\n        if (hasCrc) {\n            ret = new CpioArchiveEntry(FORMAT_NEW_CRC);\n        } else {\n            ret = new CpioArchiveEntry(FORMAT_NEW);\n        }\n\n        ret.setInode(readAsciiLong(8, 16));\n        long mode = readAsciiLong(8, 16);\n        if (CpioUtil.fileType(mode) != 0){ \n            ret.setMode(mode);\n        }\n        ret.setUID(readAsciiLong(8, 16));\n        ret.setGID(readAsciiLong(8, 16));\n        ret.setNumberOfLinks(readAsciiLong(8, 16));\n        ret.setTime(readAsciiLong(8, 16));\n        ret.setSize(readAsciiLong(8, 16));\n        ret.setDeviceMaj(readAsciiLong(8, 16));\n        ret.setDeviceMin(readAsciiLong(8, 16));\n        ret.setRemoteDeviceMaj(readAsciiLong(8, 16));\n        ret.setRemoteDeviceMin(readAsciiLong(8, 16));\n        long namesize = readAsciiLong(8, 16);\n        ret.setChksum(readAsciiLong(8, 16));\n        String name = readCString((int) namesize);\n        ret.setName(name);\n        if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){\n            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \"+name + \" Occured at byte: \" + getBytesRead());\n        }\n        skip(ret.getHeaderPadCount());\n\n        return ret;\n    }\n\n    private CpioArchiveEntry readOldAsciiEntry() throws IOException {\n        CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_ASCII);\n\n        ret.setDevice(readAsciiLong(6, 8));\n        ret.setInode(readAsciiLong(6, 8));\n        final long mode = readAsciiLong(6, 8);\n        if (CpioUtil.fileType(mode) != 0) {\n            ret.setMode(mode);\n        }\n        ret.setUID(readAsciiLong(6, 8));\n        ret.setGID(readAsciiLong(6, 8));\n        ret.setNumberOfLinks(readAsciiLong(6, 8));\n        ret.setRemoteDevice(readAsciiLong(6, 8));\n        ret.setTime(readAsciiLong(11, 8));\n        long namesize = readAsciiLong(6, 8);\n        ret.setSize(readAsciiLong(11, 8));\n        final String name = readCString((int) namesize);\n        ret.setName(name);\n        if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){\n            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+ name + \" Occured at byte: \" + getBytesRead());\n        }\n\n        return ret;\n    }\n\n    private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord) throws IOException {\n        CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY);\n\n        ret.setDevice(readBinaryLong(2, swapHalfWord));\n        ret.setInode(readBinaryLong(2, swapHalfWord));\n        final long mode = readBinaryLong(2, swapHalfWord);\n        if (CpioUtil.fileType(mode) != 0){\n            ret.setMode(mode);\n        }\n        ret.setUID(readBinaryLong(2, swapHalfWord));\n        ret.setGID(readBinaryLong(2, swapHalfWord));\n        ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord));\n        ret.setRemoteDevice(readBinaryLong(2, swapHalfWord));\n        ret.setTime(readBinaryLong(4, swapHalfWord));\n        long namesize = readBinaryLong(2, swapHalfWord);\n        ret.setSize(readBinaryLong(4, swapHalfWord));\n        final String name = readCString((int) namesize);\n        ret.setName(name);\n        if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){\n            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+name + \"Occured at byte: \" + getBytesRead());\n        }\n        skip(ret.getHeaderPadCount());\n\n        return ret;\n    }\n\n    private String readCString(final int length) throws IOException {\n        \n        byte tmpBuffer[] = new byte[length - 1];\n        readFully(tmpBuffer, 0, tmpBuffer.length);\n        this.in.read();\n        return zipEncoding.decode(tmpBuffer);\n    }\n\n    \n    @Override\n    public long skip(final long n) throws IOException {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"negative skip length\");\n        }\n        ensureOpen();\n        int max = (int) Math.min(n, Integer.MAX_VALUE);\n        int total = 0;\n\n        while (total < max) {\n            int len = max - total;\n            if (len > this.tmpbuf.length) {\n                len = this.tmpbuf.length;\n            }\n            len = read(this.tmpbuf, 0, len);\n            if (len == -1) {\n                this.entryEOF = true;\n                break;\n            }\n            total += len;\n        }\n        return total;\n    }\n\n    @Override\n    public ArchiveEntry getNextEntry() throws IOException {\n        return getNextCPIOEntry();\n    }\n\n    \n    private void skipRemainderOfLastBlock() throws IOException {\n        long readFromLastBlock = getBytesRead() % blockSize;\n        long remainingBytes = readFromLastBlock == 0 ? 0\n            : blockSize - readFromLastBlock;\n        while (remainingBytes > 0) {\n            long skipped = skip(blockSize - readFromLastBlock);\n            if (skipped <= 0) {\n                break;\n            }\n            remainingBytes -= skipped;\n        }\n    }\n\n    \n    public static boolean matches(byte[] signature, int length) {\n        if (length < 6) {\n            return false;\n        }\n\n        \n        if (signature[0] == 0x71 && (signature[1] & 0xFF) == 0xc7) {\n            return true;\n        }\n        if (signature[1] == 0x71 && (signature[0] & 0xFF) == 0xc7) {\n            return true;\n        }\n\n        \n        \n        if (signature[0] != 0x30) {\n            return false;\n        }\n        if (signature[1] != 0x37) {\n            return false;\n        }\n        if (signature[2] != 0x30) {\n            return false;\n        }\n        if (signature[3] != 0x37) {\n            return false;\n        }\n        if (signature[4] != 0x30) {\n            return false;\n        }\n        \n        if (signature[5] == 0x31) {\n            return true;\n        }\n        if (signature[5] == 0x32) {\n            return true;\n        }\n        if (signature[5] == 0x37) {\n            return true;\n        }\n\n        return false;\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.cpio;\n\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.archivers.zip.ZipEncoding;\nimport org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\nimport org.apache.commons.compress.utils.ArchiveUtils;\nimport org.apache.commons.compress.utils.CharsetNames;\nimport org.apache.commons.compress.utils.IOUtils;\n\n\n\npublic class CpioArchiveInputStream extends ArchiveInputStream implements CpioConstants { private boolean closed = false; private CpioArchiveEntry entry; private long entryBytesRead = 0; private boolean entryEOF = false; private final byte tmpbuf[] = new byte[4096]; private long crc = 0; private final InputStream in; private final byte[] TWO_BYTES_BUF = new byte[2]; private final byte[] FOUR_BYTES_BUF = new byte[4]; private final byte[] SIX_BYTES_BUF = new byte[6]; private final int blockSize; private final ZipEncoding zipEncoding; final String encoding; public CpioArchiveInputStream(final InputStream in) {\n        this(in, BLOCK_SIZE, CharsetNames.US_ASCII);\n    }\n\n    \n    public CpioArchiveInputStream(final InputStream in, String encoding) {\n        this(in, BLOCK_SIZE, encoding);\n    }\n\n    \n    public CpioArchiveInputStream(final InputStream in, int blockSize) {\n        this(in, blockSize, CharsetNames.US_ASCII);\n    }\n\n    \n    public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n        this.in = in;\n        this.blockSize = blockSize;\n        this.encoding = encoding;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    }\n\n    \n    @Override\n    public int available() throws IOException {\n        ensureOpen();\n        if (this.entryEOF) {\n            return 0;\n        }\n        return 1;\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        if (!this.closed) {\n            in.close();\n            this.closed = true;\n        }\n    }\n\n    \n    private void closeEntry() throws IOException {\n        \n        \n        while (skip((long) Integer.MAX_VALUE) == Integer.MAX_VALUE) { \n            \n        }\n    }\n\n    \n    private void ensureOpen() throws IOException {\n        if (this.closed) {\n            throw new IOException(\"Stream closed\");\n        }\n    }\n\n    \n    public CpioArchiveEntry getNextCPIOEntry() throws IOException {\n        ensureOpen();\n        if (this.entry != null) {\n            closeEntry();\n        }\n        readFully(TWO_BYTES_BUF, 0, TWO_BYTES_BUF.length);\n        if (CpioUtil.byteArray2long(TWO_BYTES_BUF, false) == MAGIC_OLD_BINARY) {\n            this.entry = readOldBinaryEntry(false);\n        } else if (CpioUtil.byteArray2long(TWO_BYTES_BUF, true)\n                   == MAGIC_OLD_BINARY) {\n            this.entry = readOldBinaryEntry(true);\n        } else {\n            System.arraycopy(TWO_BYTES_BUF, 0, SIX_BYTES_BUF, 0,\n                             TWO_BYTES_BUF.length);\n            readFully(SIX_BYTES_BUF, TWO_BYTES_BUF.length,\n                      FOUR_BYTES_BUF.length);\n            String magicString = ArchiveUtils.toAsciiString(SIX_BYTES_BUF);\n            if (magicString.equals(MAGIC_NEW)) {\n                this.entry = readNewEntry(false);\n            } else if (magicString.equals(MAGIC_NEW_CRC)) {\n                this.entry = readNewEntry(true);\n            } else if (magicString.equals(MAGIC_OLD_ASCII)) {\n                this.entry = readOldAsciiEntry();\n            } else {\n                throw new IOException(\"Unknown magic [\" + magicString + \"]. Occured at byte: \" + getBytesRead());\n            }\n        }\n\n        this.entryBytesRead = 0;\n        this.entryEOF = false;\n        this.crc = 0;\n\n        if (this.entry.getName().equals(CPIO_TRAILER)) {\n            this.entryEOF = true;\n            skipRemainderOfLastBlock();\n            return null;\n        }\n        return this.entry;\n    }\n\n    private void skip(int bytes) throws IOException {\n        \n        if (bytes > 0) {\n            readFully(FOUR_BYTES_BUF, 0, bytes);\n        }\n    }\n\n    \n    @Override\n    public int read(final byte[] b, final int off, final int len) throws IOException {\n        ensureOpen();\n        if (off < 0 || len < 0 || off > b.length - len) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        }\n\n        if (this.entry == null || this.entryEOF) {\n            return -1;\n        }\n        if (this.entryBytesRead == this.entry.getSize()) {\n            skip(entry.getDataPadCount());\n            this.entryEOF = true;\n            if (this.entry.getFormat() == FORMAT_NEW_CRC\n                && this.crc != this.entry.getChksum()) {\n                throw new IOException(\"CRC Error. Occured at byte: \"\n                                      + getBytesRead());\n            }\n            return -1; \n        }\n        int tmplength = (int) Math.min(len, this.entry.getSize()\n                - this.entryBytesRead);\n        if (tmplength < 0) {\n            return -1;\n        }\n\n        int tmpread = readFully(b, off, tmplength);\n        if (this.entry.getFormat() == FORMAT_NEW_CRC) {\n            for (int pos = 0; pos < tmpread; pos++) {\n                this.crc += b[pos] & 0xFF;\n            }\n        }\n        this.entryBytesRead += tmpread;\n\n        return tmpread;\n    }\n\n    private final int readFully(final byte[] b, final int off, final int len) throws IOException {\n        int count = IOUtils.readFully(in, b, off, len);\n        count(count);\n        if (count < len) {\n            throw new EOFException();\n        }\n        return count;\n    }\n\n    private long readBinaryLong(final int length, final boolean swapHalfWord) throws IOException {\n        byte tmp[] = new byte[length];\n        readFully(tmp, 0, tmp.length);\n        return CpioUtil.byteArray2long(tmp, swapHalfWord);\n    }\n\n    private long readAsciiLong(final int length, final int radix) throws IOException {\n        byte tmpBuffer[] = new byte[length];\n        readFully(tmpBuffer, 0, tmpBuffer.length);\n        return Long.parseLong(ArchiveUtils.toAsciiString(tmpBuffer), radix);\n    }\n\n    private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException {\n        CpioArchiveEntry ret;\n        if (hasCrc) {\n            ret = new CpioArchiveEntry(FORMAT_NEW_CRC);\n        } else {\n            ret = new CpioArchiveEntry(FORMAT_NEW);\n        }\n\n        ret.setInode(readAsciiLong(8, 16));\n        long mode = readAsciiLong(8, 16);\n        if (CpioUtil.fileType(mode) != 0){ \n            ret.setMode(mode);\n        }\n        ret.setUID(readAsciiLong(8, 16));\n        ret.setGID(readAsciiLong(8, 16));\n        ret.setNumberOfLinks(readAsciiLong(8, 16));\n        ret.setTime(readAsciiLong(8, 16));\n        ret.setSize(readAsciiLong(8, 16));\n        ret.setDeviceMaj(readAsciiLong(8, 16));\n        ret.setDeviceMin(readAsciiLong(8, 16));\n        ret.setRemoteDeviceMaj(readAsciiLong(8, 16));\n        ret.setRemoteDeviceMin(readAsciiLong(8, 16));\n        long namesize = readAsciiLong(8, 16);\n        ret.setChksum(readAsciiLong(8, 16));\n        String name = readCString((int) namesize);\n        ret.setName(name);\n        if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){\n            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \"+name + \" Occured at byte: \" + getBytesRead());\n        }\n        skip(ret.getHeaderPadCount());\n\n        return ret;\n    }\n\n    private CpioArchiveEntry readOldAsciiEntry() throws IOException {\n        CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_ASCII);\n\n        ret.setDevice(readAsciiLong(6, 8));\n        ret.setInode(readAsciiLong(6, 8));\n        final long mode = readAsciiLong(6, 8);\n        if (CpioUtil.fileType(mode) != 0) {\n            ret.setMode(mode);\n        }\n        ret.setUID(readAsciiLong(6, 8));\n        ret.setGID(readAsciiLong(6, 8));\n        ret.setNumberOfLinks(readAsciiLong(6, 8));\n        ret.setRemoteDevice(readAsciiLong(6, 8));\n        ret.setTime(readAsciiLong(11, 8));\n        long namesize = readAsciiLong(6, 8);\n        ret.setSize(readAsciiLong(11, 8));\n        final String name = readCString((int) namesize);\n        ret.setName(name);\n        if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){\n            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+ name + \" Occured at byte: \" + getBytesRead());\n        }\n\n        return ret;\n    }\n\n    private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord) throws IOException {\n        CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY);\n\n        ret.setDevice(readBinaryLong(2, swapHalfWord));\n        ret.setInode(readBinaryLong(2, swapHalfWord));\n        final long mode = readBinaryLong(2, swapHalfWord);\n        if (CpioUtil.fileType(mode) != 0){\n            ret.setMode(mode);\n        }\n        ret.setUID(readBinaryLong(2, swapHalfWord));\n        ret.setGID(readBinaryLong(2, swapHalfWord));\n        ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord));\n        ret.setRemoteDevice(readBinaryLong(2, swapHalfWord));\n        ret.setTime(readBinaryLong(4, swapHalfWord));\n        long namesize = readBinaryLong(2, swapHalfWord);\n        ret.setSize(readBinaryLong(4, swapHalfWord));\n        final String name = readCString((int) namesize);\n        ret.setName(name);\n        if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){\n            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+name + \"Occured at byte: \" + getBytesRead());\n        }\n        skip(ret.getHeaderPadCount());\n\n        return ret;\n    }\n\n    private String readCString(final int length) throws IOException {\n        \n        byte tmpBuffer[] = new byte[length - 1];\n        readFully(tmpBuffer, 0, tmpBuffer.length);\n        this.in.read();\n        return zipEncoding.decode(tmpBuffer);\n    }\n\n    \n    @Override\n    public long skip(final long n) throws IOException {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"negative skip length\");\n        }\n        ensureOpen();\n        int max = (int) Math.min(n, Integer.MAX_VALUE);\n        int total = 0;\n\n        while (total < max) {\n            int len = max - total;\n            if (len > this.tmpbuf.length) {\n                len = this.tmpbuf.length;\n            }\n            len = read(this.tmpbuf, 0, len);\n            if (len == -1) {\n                this.entryEOF = true;\n                break;\n            }\n            total += len;\n        }\n        return total;\n    }\n\n    @Override\n    public ArchiveEntry getNextEntry() throws IOException {\n        return getNextCPIOEntry();\n    }\n\n    \n    private void skipRemainderOfLastBlock() throws IOException {\n        long readFromLastBlock = getBytesRead() % blockSize;\n        long remainingBytes = readFromLastBlock == 0 ? 0\n            : blockSize - readFromLastBlock;\n        while (remainingBytes > 0) {\n            long skipped = skip(blockSize - readFromLastBlock);\n            if (skipped <= 0) {\n                break;\n            }\n            remainingBytes -= skipped;\n        }\n    }\n\n    \n    public static boolean matches(byte[] signature, int length) {\n        if (length < 6) {\n            return false;\n        }\n\n        \n        if (signature[0] == 0x71 && (signature[1] & 0xFF) == 0xc7) {\n            return true;\n        }\n        if (signature[1] == 0x71 && (signature[0] & 0xFF) == 0xc7) {\n            return true;\n        }\n\n        \n        \n        if (signature[0] != 0x30) {\n            return false;\n        }\n        if (signature[1] != 0x37) {\n            return false;\n        }\n        if (signature[2] != 0x30) {\n            return false;\n        }\n        if (signature[3] != 0x37) {\n            return false;\n        }\n        if (signature[4] != 0x30) {\n            return false;\n        }\n        \n        if (signature[5] == 0x31) {\n            return true;\n        }\n        if (signature[5] == 0x32) {\n            return true;\n        }\n        if (signature[5] == 0x37) {\n            return true;\n        }\n\n        return false;\n    }\n}\n",
      "buggy_signatures": [
        "public CpioArchiveInputStream(final InputStream in, String encoding)",
        "public CpioArchiveInputStream(final InputStream in, int blockSize)",
        "public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding)",
        "public int available() throws IOException",
        "public void close() throws IOException",
        "private void closeEntry() throws IOException",
        "private void ensureOpen() throws IOException",
        "public CpioArchiveEntry getNextCPIOEntry() throws IOException",
        "private void skip(int bytes) throws IOException",
        "public int read(final byte[] b, final int off, final int len) throws IOException",
        "private final int readFully(final byte[] b, final int off, final int len) throws IOException",
        "private long readBinaryLong(final int length, final boolean swapHalfWord) throws IOException",
        "private long readAsciiLong(final int length, final int radix) throws IOException",
        "private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException",
        "private CpioArchiveEntry readOldAsciiEntry() throws IOException",
        "private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord) throws IOException",
        "private String readCString(final int length) throws IOException",
        "public long skip(final long n) throws IOException",
        "public ArchiveEntry getNextEntry() throws IOException",
        "private void skipRemainderOfLastBlock() throws IOException",
        "public static boolean matches(byte[] signature, int length)"
      ],
      "fixed_signatures": [
        "public CpioArchiveInputStream(final InputStream in, String encoding)",
        "public CpioArchiveInputStream(final InputStream in, int blockSize)",
        "public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding)",
        "public int available() throws IOException",
        "public void close() throws IOException",
        "private void closeEntry() throws IOException",
        "private void ensureOpen() throws IOException",
        "public CpioArchiveEntry getNextCPIOEntry() throws IOException",
        "private void skip(int bytes) throws IOException",
        "public int read(final byte[] b, final int off, final int len) throws IOException",
        "private final int readFully(final byte[] b, final int off, final int len) throws IOException",
        "private long readBinaryLong(final int length, final boolean swapHalfWord) throws IOException",
        "private long readAsciiLong(final int length, final int radix) throws IOException",
        "private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException",
        "private CpioArchiveEntry readOldAsciiEntry() throws IOException",
        "private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord) throws IOException",
        "private String readCString(final int length) throws IOException",
        "public long skip(final long n) throws IOException",
        "public ArchiveEntry getNextEntry() throws IOException",
        "private void skipRemainderOfLastBlock() throws IOException",
        "public static boolean matches(byte[] signature, int length)"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -94,6 +94,7 @@",
            "     private final ZipEncoding zipEncoding;\n",
            " \n",
            "     // the provided encoding (for unit tests)\n",
            "+    final String encoding;\n",
            " \n",
            "     /**\n",
            "      * Construct the cpio input stream with a blocksize of {@link\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n  this.in = in;\n  this.blockSize = blockSize;\n  this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n  }",
          "fixed_method": "  public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n  this.in = in;\n  this.blockSize = blockSize;\n  this.encoding = encoding;\n  this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n  }",
          "diff": [
            "@@ -152,6 +153,7 @@",
            "     public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n",
            "         this.in = in;\n",
            "         this.blockSize = blockSize;\n",
            "+        this.encoding = encoding;\n",
            "         this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 1
        }
      ]
    },
    {
      "name": "org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.cpio;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.ByteBuffer;\nimport java.util.HashMap;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveOutputStream;\nimport org.apache.commons.compress.archivers.zip.ZipEncoding;\nimport org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\nimport org.apache.commons.compress.utils.ArchiveUtils;\nimport org.apache.commons.compress.utils.CharsetNames;\n\n\npublic class CpioArchiveOutputStream extends ArchiveOutputStream implements CpioConstants { private CpioArchiveEntry entry; private boolean closed = false; private boolean finished; private final short entryFormat; private final HashMap<String, CpioArchiveEntry> names = new HashMap<String, CpioArchiveEntry>(); private long crc = 0; private long written; private final OutputStream out; private final int blockSize; private long nextArtificalDeviceAndInode = 1; private final ZipEncoding zipEncoding; public CpioArchiveOutputStream(final OutputStream out, final short format) {\n        this(out, format, BLOCK_SIZE, CharsetNames.US_ASCII);\n    }\n\n    \n    public CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize) {\n        this(out, format, blockSize, CharsetNames.US_ASCII);\n    }        \n\n    \n    public CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding) {\n        this.out = out;\n        switch (format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown format: \"+format);\n\n        }\n        this.entryFormat = format;\n        this.blockSize = blockSize;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    }\n\n    \n    public CpioArchiveOutputStream(final OutputStream out) {\n        this(out, FORMAT_NEW);\n    }\n\n    \n    public CpioArchiveOutputStream(final OutputStream out, String encoding) {\n        this(out, FORMAT_NEW, BLOCK_SIZE, encoding);\n    }\n\n    \n    private void ensureOpen() throws IOException {\n        if (this.closed) {\n            throw new IOException(\"Stream closed\");\n        }\n    }\n\n    \n    @Override\n    public void putArchiveEntry(ArchiveEntry entry) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n\n        CpioArchiveEntry e = (CpioArchiveEntry) entry;\n        ensureOpen();\n        if (this.entry != null) {\n            closeArchiveEntry(); \n        }\n        if (e.getTime() == -1) {\n            e.setTime(System.currentTimeMillis() / 1000);\n        }\n\n        final short format = e.getFormat();\n        if (format != this.entryFormat){\n            throw new IOException(\"Header format: \"+format+\" does not match existing format: \"+this.entryFormat);\n        }\n\n        if (this.names.put(e.getName(), e) != null) {\n            throw new IOException(\"duplicate entry: \" + e.getName());\n        }\n\n        writeHeader(e);\n        this.entry = e;\n        this.written = 0;\n    }\n\n    private void writeHeader(final CpioArchiveEntry e) throws IOException {\n        switch (e.getFormat()) {\n        case FORMAT_NEW:\n            out.write(ArchiveUtils.toAsciiBytes(MAGIC_NEW));\n            count(6);\n            writeNewEntry(e);\n            break;\n        case FORMAT_NEW_CRC:\n            out.write(ArchiveUtils.toAsciiBytes(MAGIC_NEW_CRC));\n            count(6);\n            writeNewEntry(e);\n            break;\n        case FORMAT_OLD_ASCII:\n            out.write(ArchiveUtils.toAsciiBytes(MAGIC_OLD_ASCII));\n            count(6);\n            writeOldAsciiEntry(e);\n            break;\n        case FORMAT_OLD_BINARY:\n            boolean swapHalfWord = true;\n            writeBinaryLong(MAGIC_OLD_BINARY, 2, swapHalfWord);\n            writeOldBinaryEntry(e, swapHalfWord);\n            break;\n        default:\n            throw new IOException(\"unknown format \" + e.getFormat());\n        }\n    }\n\n    private void writeNewEntry(final CpioArchiveEntry entry) throws IOException {\n        long inode = entry.getInode();\n        long devMin = entry.getDeviceMin();\n        if (CPIO_TRAILER.equals(entry.getName())) {\n            inode = devMin = 0;\n        } else {\n            if (inode == 0 && devMin == 0) {\n                inode = nextArtificalDeviceAndInode & 0xFFFFFFFF;\n                devMin = (nextArtificalDeviceAndInode++ >> 32) & 0xFFFFFFFF;\n            } else {\n                nextArtificalDeviceAndInode =\n                    Math.max(nextArtificalDeviceAndInode,\n                             inode + 0x100000000L * devMin) + 1;\n            }\n        }\n\n        writeAsciiLong(inode, 8, 16);\n        writeAsciiLong(entry.getMode(), 8, 16);\n        writeAsciiLong(entry.getUID(), 8, 16);\n        writeAsciiLong(entry.getGID(), 8, 16);\n        writeAsciiLong(entry.getNumberOfLinks(), 8, 16);\n        writeAsciiLong(entry.getTime(), 8, 16);\n        writeAsciiLong(entry.getSize(), 8, 16);\n        writeAsciiLong(entry.getDeviceMaj(), 8, 16);\n        writeAsciiLong(devMin, 8, 16);\n        writeAsciiLong(entry.getRemoteDeviceMaj(), 8, 16);\n        writeAsciiLong(entry.getRemoteDeviceMin(), 8, 16);\n        writeAsciiLong(entry.getName().length() + 1, 8, 16);\n        writeAsciiLong(entry.getChksum(), 8, 16);\n        writeCString(entry.getName());\n        pad(entry.getHeaderPadCount());\n    }\n\n    private void writeOldAsciiEntry(final CpioArchiveEntry entry) throws IOException {\n        long inode = entry.getInode();\n        long device = entry.getDevice();\n        if (CPIO_TRAILER.equals(entry.getName())) {\n            inode = device = 0;\n        } else {\n            if (inode == 0 && device == 0) {\n                inode = nextArtificalDeviceAndInode & 0777777;\n                device = (nextArtificalDeviceAndInode++ >> 18) & 0777777;\n            } else {\n                nextArtificalDeviceAndInode =\n                    Math.max(nextArtificalDeviceAndInode,\n                             inode + 01000000 * device) + 1;\n            }\n        }\n\n        writeAsciiLong(device, 6, 8);\n        writeAsciiLong(inode, 6, 8);\n        writeAsciiLong(entry.getMode(), 6, 8);\n        writeAsciiLong(entry.getUID(), 6, 8);\n        writeAsciiLong(entry.getGID(), 6, 8);\n        writeAsciiLong(entry.getNumberOfLinks(), 6, 8);\n        writeAsciiLong(entry.getRemoteDevice(), 6, 8);\n        writeAsciiLong(entry.getTime(), 11, 8);\n        writeAsciiLong(entry.getName().length() + 1, 6, 8);\n        writeAsciiLong(entry.getSize(), 11, 8);\n        writeCString(entry.getName());\n    }\n\n    private void writeOldBinaryEntry(final CpioArchiveEntry entry, final boolean swapHalfWord) throws IOException {\n        long inode = entry.getInode();\n        long device = entry.getDevice();\n        if (CPIO_TRAILER.equals(entry.getName())) {\n            inode = device = 0;\n        } else {\n            if (inode == 0 && device == 0) {\n                inode = nextArtificalDeviceAndInode & 0xFFFF;\n                device = (nextArtificalDeviceAndInode++ >> 16) & 0xFFFF;\n            } else {\n                nextArtificalDeviceAndInode =\n                    Math.max(nextArtificalDeviceAndInode,\n                             inode + 0x10000 * device) + 1;\n            }\n        }\n\n        writeBinaryLong(device, 2, swapHalfWord);\n        writeBinaryLong(inode, 2, swapHalfWord);\n        writeBinaryLong(entry.getMode(), 2, swapHalfWord);\n        writeBinaryLong(entry.getUID(), 2, swapHalfWord);\n        writeBinaryLong(entry.getGID(), 2, swapHalfWord);\n        writeBinaryLong(entry.getNumberOfLinks(), 2, swapHalfWord);\n        writeBinaryLong(entry.getRemoteDevice(), 2, swapHalfWord);\n        writeBinaryLong(entry.getTime(), 4, swapHalfWord);\n        writeBinaryLong(entry.getName().length() + 1, 2, swapHalfWord);\n        writeBinaryLong(entry.getSize(), 4, swapHalfWord);\n        writeCString(entry.getName());\n        pad(entry.getHeaderPadCount());\n    }\n\n    \n    @Override\n    public void closeArchiveEntry() throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n\n        ensureOpen();\n\n        if (entry == null) {\n            throw new IOException(\"Trying to close non-existent entry\");\n        }\n\n        if (this.entry.getSize() != this.written) {\n            throw new IOException(\"invalid entry size (expected \"\n                    + this.entry.getSize() + \" but got \" + this.written\n                    + \" bytes)\");\n        }\n        pad(this.entry.getDataPadCount());\n        if (this.entry.getFormat() == FORMAT_NEW_CRC\n            && this.crc != this.entry.getChksum()) {\n            throw new IOException(\"CRC Error\");\n        }\n        this.entry = null;\n        this.crc = 0;\n        this.written = 0;\n    }\n\n    \n    @Override\n    public void write(final byte[] b, final int off, final int len) throws IOException {\n        ensureOpen();\n        if (off < 0 || len < 0 || off > b.length - len) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return;\n        }\n\n        if (this.entry == null) {\n            throw new IOException(\"no current CPIO entry\");\n        }\n        if (this.written + len > this.entry.getSize()) {\n            throw new IOException(\"attempt to write past end of STORED entry\");\n        }\n        out.write(b, off, len);\n        this.written += len;\n        if (this.entry.getFormat() == FORMAT_NEW_CRC) {\n            for (int pos = 0; pos < len; pos++) {\n                this.crc += b[pos] & 0xFF;\n            }\n        }\n        count(len);\n    }\n\n    \n    @Override\n    public void finish() throws IOException {\n        ensureOpen();\n        if (finished) {\n            throw new IOException(\"This archive has already been finished\");\n        }\n\n        if (this.entry != null) {\n            throw new IOException(\"This archive contains unclosed entries.\");\n        }\n        this.entry = new CpioArchiveEntry(this.entryFormat);\n        this.entry.setName(CPIO_TRAILER);\n        this.entry.setNumberOfLinks(1);\n        writeHeader(this.entry);\n        closeArchiveEntry();\n\n        int lengthOfLastBlock = (int) (getBytesWritten() % blockSize);\n        if (lengthOfLastBlock != 0) {\n            pad(blockSize - lengthOfLastBlock);\n        }\n\n        finished = true;\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        if(!finished) {\n            finish();\n        }\n\n        if (!this.closed) {\n            out.close();\n            this.closed = true;\n        }\n    }\n\n    private void pad(int count) throws IOException {\n        if (count > 0){\n            byte buff[] = new byte[count];\n            out.write(buff);\n            count(count);\n        }\n    }\n\n    private void writeBinaryLong(final long number, final int length, final boolean swapHalfWord) throws IOException {\n        byte tmp[] = CpioUtil.long2byteArray(number, length, swapHalfWord);\n        out.write(tmp);\n        count(tmp.length);\n    }\n\n    private void writeAsciiLong(final long number, final int length, final int radix) throws IOException {\n        StringBuilder tmp = new StringBuilder();\n        String tmpStr;\n        if (radix == 16) {\n            tmp.append(Long.toHexString(number));\n        } else if (radix == 8) {\n            tmp.append(Long.toOctalString(number));\n        } else {\n            tmp.append(Long.toString(number));\n        }\n\n        if (tmp.length() <= length) {\n            long insertLength = length - tmp.length();\n            for (int pos = 0; pos < insertLength; pos++) {\n                tmp.insert(0, \"0\");\n            }\n            tmpStr = tmp.toString();\n        } else {\n            tmpStr = tmp.substring(tmp.length() - length);\n        }\n        byte[] b = ArchiveUtils.toAsciiBytes(tmpStr);\n        out.write(b);\n        count(b.length);\n    }\n\n    \n    private void writeCString(final String str) throws IOException {\n        ByteBuffer buf = zipEncoding.encode(str);\n        final int len = buf.limit() - buf.position();\n        out.write(buf.array(), buf.arrayOffset(), len);\n        out.write('\\0');\n        count(len + 1);\n    }\n\n    \n    @Override\n    public ArchiveEntry createArchiveEntry(File inputFile, String entryName) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        return new CpioArchiveEntry(inputFile, entryName);\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.cpio;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.ByteBuffer;\nimport java.util.HashMap;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveOutputStream;\nimport org.apache.commons.compress.archivers.zip.ZipEncoding;\nimport org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\nimport org.apache.commons.compress.utils.ArchiveUtils;\nimport org.apache.commons.compress.utils.CharsetNames;\n\n\npublic class CpioArchiveOutputStream extends ArchiveOutputStream implements CpioConstants { private CpioArchiveEntry entry; private boolean closed = false; private boolean finished; private final short entryFormat; private final HashMap<String, CpioArchiveEntry> names = new HashMap<String, CpioArchiveEntry>(); private long crc = 0; private long written; private final OutputStream out; private final int blockSize; private long nextArtificalDeviceAndInode = 1; private final ZipEncoding zipEncoding; final String encoding; public CpioArchiveOutputStream(final OutputStream out, final short format) {\n        this(out, format, BLOCK_SIZE, CharsetNames.US_ASCII);\n    }\n\n    \n    public CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize) {\n        this(out, format, blockSize, CharsetNames.US_ASCII);\n    }        \n\n    \n    public CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding) {\n        this.out = out;\n        switch (format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown format: \"+format);\n\n        }\n        this.entryFormat = format;\n        this.blockSize = blockSize;\n        this.encoding = encoding;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    }\n\n    \n    public CpioArchiveOutputStream(final OutputStream out) {\n        this(out, FORMAT_NEW);\n    }\n\n    \n    public CpioArchiveOutputStream(final OutputStream out, String encoding) {\n        this(out, FORMAT_NEW, BLOCK_SIZE, encoding);\n    }\n\n    \n    private void ensureOpen() throws IOException {\n        if (this.closed) {\n            throw new IOException(\"Stream closed\");\n        }\n    }\n\n    \n    @Override\n    public void putArchiveEntry(ArchiveEntry entry) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n\n        CpioArchiveEntry e = (CpioArchiveEntry) entry;\n        ensureOpen();\n        if (this.entry != null) {\n            closeArchiveEntry(); \n        }\n        if (e.getTime() == -1) {\n            e.setTime(System.currentTimeMillis() / 1000);\n        }\n\n        final short format = e.getFormat();\n        if (format != this.entryFormat){\n            throw new IOException(\"Header format: \"+format+\" does not match existing format: \"+this.entryFormat);\n        }\n\n        if (this.names.put(e.getName(), e) != null) {\n            throw new IOException(\"duplicate entry: \" + e.getName());\n        }\n\n        writeHeader(e);\n        this.entry = e;\n        this.written = 0;\n    }\n\n    private void writeHeader(final CpioArchiveEntry e) throws IOException {\n        switch (e.getFormat()) {\n        case FORMAT_NEW:\n            out.write(ArchiveUtils.toAsciiBytes(MAGIC_NEW));\n            count(6);\n            writeNewEntry(e);\n            break;\n        case FORMAT_NEW_CRC:\n            out.write(ArchiveUtils.toAsciiBytes(MAGIC_NEW_CRC));\n            count(6);\n            writeNewEntry(e);\n            break;\n        case FORMAT_OLD_ASCII:\n            out.write(ArchiveUtils.toAsciiBytes(MAGIC_OLD_ASCII));\n            count(6);\n            writeOldAsciiEntry(e);\n            break;\n        case FORMAT_OLD_BINARY:\n            boolean swapHalfWord = true;\n            writeBinaryLong(MAGIC_OLD_BINARY, 2, swapHalfWord);\n            writeOldBinaryEntry(e, swapHalfWord);\n            break;\n        default:\n            throw new IOException(\"unknown format \" + e.getFormat());\n        }\n    }\n\n    private void writeNewEntry(final CpioArchiveEntry entry) throws IOException {\n        long inode = entry.getInode();\n        long devMin = entry.getDeviceMin();\n        if (CPIO_TRAILER.equals(entry.getName())) {\n            inode = devMin = 0;\n        } else {\n            if (inode == 0 && devMin == 0) {\n                inode = nextArtificalDeviceAndInode & 0xFFFFFFFF;\n                devMin = (nextArtificalDeviceAndInode++ >> 32) & 0xFFFFFFFF;\n            } else {\n                nextArtificalDeviceAndInode =\n                    Math.max(nextArtificalDeviceAndInode,\n                             inode + 0x100000000L * devMin) + 1;\n            }\n        }\n\n        writeAsciiLong(inode, 8, 16);\n        writeAsciiLong(entry.getMode(), 8, 16);\n        writeAsciiLong(entry.getUID(), 8, 16);\n        writeAsciiLong(entry.getGID(), 8, 16);\n        writeAsciiLong(entry.getNumberOfLinks(), 8, 16);\n        writeAsciiLong(entry.getTime(), 8, 16);\n        writeAsciiLong(entry.getSize(), 8, 16);\n        writeAsciiLong(entry.getDeviceMaj(), 8, 16);\n        writeAsciiLong(devMin, 8, 16);\n        writeAsciiLong(entry.getRemoteDeviceMaj(), 8, 16);\n        writeAsciiLong(entry.getRemoteDeviceMin(), 8, 16);\n        writeAsciiLong(entry.getName().length() + 1, 8, 16);\n        writeAsciiLong(entry.getChksum(), 8, 16);\n        writeCString(entry.getName());\n        pad(entry.getHeaderPadCount());\n    }\n\n    private void writeOldAsciiEntry(final CpioArchiveEntry entry) throws IOException {\n        long inode = entry.getInode();\n        long device = entry.getDevice();\n        if (CPIO_TRAILER.equals(entry.getName())) {\n            inode = device = 0;\n        } else {\n            if (inode == 0 && device == 0) {\n                inode = nextArtificalDeviceAndInode & 0777777;\n                device = (nextArtificalDeviceAndInode++ >> 18) & 0777777;\n            } else {\n                nextArtificalDeviceAndInode =\n                    Math.max(nextArtificalDeviceAndInode,\n                             inode + 01000000 * device) + 1;\n            }\n        }\n\n        writeAsciiLong(device, 6, 8);\n        writeAsciiLong(inode, 6, 8);\n        writeAsciiLong(entry.getMode(), 6, 8);\n        writeAsciiLong(entry.getUID(), 6, 8);\n        writeAsciiLong(entry.getGID(), 6, 8);\n        writeAsciiLong(entry.getNumberOfLinks(), 6, 8);\n        writeAsciiLong(entry.getRemoteDevice(), 6, 8);\n        writeAsciiLong(entry.getTime(), 11, 8);\n        writeAsciiLong(entry.getName().length() + 1, 6, 8);\n        writeAsciiLong(entry.getSize(), 11, 8);\n        writeCString(entry.getName());\n    }\n\n    private void writeOldBinaryEntry(final CpioArchiveEntry entry, final boolean swapHalfWord) throws IOException {\n        long inode = entry.getInode();\n        long device = entry.getDevice();\n        if (CPIO_TRAILER.equals(entry.getName())) {\n            inode = device = 0;\n        } else {\n            if (inode == 0 && device == 0) {\n                inode = nextArtificalDeviceAndInode & 0xFFFF;\n                device = (nextArtificalDeviceAndInode++ >> 16) & 0xFFFF;\n            } else {\n                nextArtificalDeviceAndInode =\n                    Math.max(nextArtificalDeviceAndInode,\n                             inode + 0x10000 * device) + 1;\n            }\n        }\n\n        writeBinaryLong(device, 2, swapHalfWord);\n        writeBinaryLong(inode, 2, swapHalfWord);\n        writeBinaryLong(entry.getMode(), 2, swapHalfWord);\n        writeBinaryLong(entry.getUID(), 2, swapHalfWord);\n        writeBinaryLong(entry.getGID(), 2, swapHalfWord);\n        writeBinaryLong(entry.getNumberOfLinks(), 2, swapHalfWord);\n        writeBinaryLong(entry.getRemoteDevice(), 2, swapHalfWord);\n        writeBinaryLong(entry.getTime(), 4, swapHalfWord);\n        writeBinaryLong(entry.getName().length() + 1, 2, swapHalfWord);\n        writeBinaryLong(entry.getSize(), 4, swapHalfWord);\n        writeCString(entry.getName());\n        pad(entry.getHeaderPadCount());\n    }\n\n    \n    @Override\n    public void closeArchiveEntry() throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n\n        ensureOpen();\n\n        if (entry == null) {\n            throw new IOException(\"Trying to close non-existent entry\");\n        }\n\n        if (this.entry.getSize() != this.written) {\n            throw new IOException(\"invalid entry size (expected \"\n                    + this.entry.getSize() + \" but got \" + this.written\n                    + \" bytes)\");\n        }\n        pad(this.entry.getDataPadCount());\n        if (this.entry.getFormat() == FORMAT_NEW_CRC\n            && this.crc != this.entry.getChksum()) {\n            throw new IOException(\"CRC Error\");\n        }\n        this.entry = null;\n        this.crc = 0;\n        this.written = 0;\n    }\n\n    \n    @Override\n    public void write(final byte[] b, final int off, final int len) throws IOException {\n        ensureOpen();\n        if (off < 0 || len < 0 || off > b.length - len) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return;\n        }\n\n        if (this.entry == null) {\n            throw new IOException(\"no current CPIO entry\");\n        }\n        if (this.written + len > this.entry.getSize()) {\n            throw new IOException(\"attempt to write past end of STORED entry\");\n        }\n        out.write(b, off, len);\n        this.written += len;\n        if (this.entry.getFormat() == FORMAT_NEW_CRC) {\n            for (int pos = 0; pos < len; pos++) {\n                this.crc += b[pos] & 0xFF;\n            }\n        }\n        count(len);\n    }\n\n    \n    @Override\n    public void finish() throws IOException {\n        ensureOpen();\n        if (finished) {\n            throw new IOException(\"This archive has already been finished\");\n        }\n\n        if (this.entry != null) {\n            throw new IOException(\"This archive contains unclosed entries.\");\n        }\n        this.entry = new CpioArchiveEntry(this.entryFormat);\n        this.entry.setName(CPIO_TRAILER);\n        this.entry.setNumberOfLinks(1);\n        writeHeader(this.entry);\n        closeArchiveEntry();\n\n        int lengthOfLastBlock = (int) (getBytesWritten() % blockSize);\n        if (lengthOfLastBlock != 0) {\n            pad(blockSize - lengthOfLastBlock);\n        }\n\n        finished = true;\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        if(!finished) {\n            finish();\n        }\n\n        if (!this.closed) {\n            out.close();\n            this.closed = true;\n        }\n    }\n\n    private void pad(int count) throws IOException {\n        if (count > 0){\n            byte buff[] = new byte[count];\n            out.write(buff);\n            count(count);\n        }\n    }\n\n    private void writeBinaryLong(final long number, final int length, final boolean swapHalfWord) throws IOException {\n        byte tmp[] = CpioUtil.long2byteArray(number, length, swapHalfWord);\n        out.write(tmp);\n        count(tmp.length);\n    }\n\n    private void writeAsciiLong(final long number, final int length, final int radix) throws IOException {\n        StringBuilder tmp = new StringBuilder();\n        String tmpStr;\n        if (radix == 16) {\n            tmp.append(Long.toHexString(number));\n        } else if (radix == 8) {\n            tmp.append(Long.toOctalString(number));\n        } else {\n            tmp.append(Long.toString(number));\n        }\n\n        if (tmp.length() <= length) {\n            long insertLength = length - tmp.length();\n            for (int pos = 0; pos < insertLength; pos++) {\n                tmp.insert(0, \"0\");\n            }\n            tmpStr = tmp.toString();\n        } else {\n            tmpStr = tmp.substring(tmp.length() - length);\n        }\n        byte[] b = ArchiveUtils.toAsciiBytes(tmpStr);\n        out.write(b);\n        count(b.length);\n    }\n\n    \n    private void writeCString(final String str) throws IOException {\n        ByteBuffer buf = zipEncoding.encode(str);\n        final int len = buf.limit() - buf.position();\n        out.write(buf.array(), buf.arrayOffset(), len);\n        out.write('\\0');\n        count(len + 1);\n    }\n\n    \n    @Override\n    public ArchiveEntry createArchiveEntry(File inputFile, String entryName) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        return new CpioArchiveEntry(inputFile, entryName);\n    }\n\n}\n",
      "buggy_signatures": [
        "public CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize)",
        "public CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding)",
        "public CpioArchiveOutputStream(final OutputStream out)",
        "public CpioArchiveOutputStream(final OutputStream out, String encoding)",
        "private void ensureOpen() throws IOException",
        "public void putArchiveEntry(ArchiveEntry entry) throws IOException",
        "private void writeHeader(final CpioArchiveEntry e) throws IOException",
        "private void writeNewEntry(final CpioArchiveEntry entry) throws IOException",
        "private void writeOldAsciiEntry(final CpioArchiveEntry entry) throws IOException",
        "private void writeOldBinaryEntry(final CpioArchiveEntry entry, final boolean swapHalfWord) throws IOException",
        "public void closeArchiveEntry() throws IOException",
        "public void write(final byte[] b, final int off, final int len) throws IOException",
        "public void finish() throws IOException",
        "public void close() throws IOException",
        "private void pad(int count) throws IOException",
        "private void writeBinaryLong(final long number, final int length, final boolean swapHalfWord) throws IOException",
        "private void writeAsciiLong(final long number, final int length, final int radix) throws IOException",
        "private void writeCString(final String str) throws IOException",
        "public ArchiveEntry createArchiveEntry(File inputFile, String entryName) throws IOException"
      ],
      "fixed_signatures": [
        "public CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize)",
        "public CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding)",
        "public CpioArchiveOutputStream(final OutputStream out)",
        "public CpioArchiveOutputStream(final OutputStream out, String encoding)",
        "private void ensureOpen() throws IOException",
        "public void putArchiveEntry(ArchiveEntry entry) throws IOException",
        "private void writeHeader(final CpioArchiveEntry e) throws IOException",
        "private void writeNewEntry(final CpioArchiveEntry entry) throws IOException",
        "private void writeOldAsciiEntry(final CpioArchiveEntry entry) throws IOException",
        "private void writeOldBinaryEntry(final CpioArchiveEntry entry, final boolean swapHalfWord) throws IOException",
        "public void closeArchiveEntry() throws IOException",
        "public void write(final byte[] b, final int off, final int len) throws IOException",
        "public void finish() throws IOException",
        "public void close() throws IOException",
        "private void pad(int count) throws IOException",
        "private void writeBinaryLong(final long number, final int length, final boolean swapHalfWord) throws IOException",
        "private void writeAsciiLong(final long number, final int length, final int radix) throws IOException",
        "private void writeCString(final String str) throws IOException",
        "public ArchiveEntry createArchiveEntry(File inputFile, String entryName) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -95,6 +95,7 @@",
            "     private final ZipEncoding zipEncoding;\n",
            " \n",
            "     // the provided encoding (for unit tests)\n",
            "+    final String encoding;\n",
            " \n",
            "     /**\n",
            "      * Construct the cpio output stream with a specified format, a\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  public CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding) {\n  this.out = out;\n  switch (format) {\n  case FORMAT_NEW:\n  case FORMAT_NEW_CRC:\n  case FORMAT_OLD_ASCII:\n  case FORMAT_OLD_BINARY:\n  break;\n  default:\n  throw new IllegalArgumentException(\"Unknown format: \"+format);\n\n  }\n  this.entryFormat = format;\n  this.blockSize = blockSize;\n  this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n  }",
          "fixed_method": "  public CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding) {\n  this.out = out;\n  switch (format) {\n  case FORMAT_NEW:\n  case FORMAT_NEW_CRC:\n  case FORMAT_OLD_ASCII:\n  case FORMAT_OLD_BINARY:\n  break;\n  default:\n  throw new IllegalArgumentException(\"Unknown format: \"+format);\n\n  }\n  this.entryFormat = format;\n  this.blockSize = blockSize;\n  this.encoding = encoding;\n  this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n  }",
          "diff": [
            "@@ -159,6 +160,7 @@",
            "         }\n",
            "         this.entryFormat = format;\n",
            "         this.blockSize = blockSize;\n",
            "+        this.encoding = encoding;\n",
            "         this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 1
        }
      ]
    },
    {
      "name": "org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.dump;\n\nimport org.apache.commons.compress.archivers.ArchiveException;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.archivers.zip.ZipEncoding;\nimport org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\n\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Stack;\n\n\npublic class DumpArchiveInputStream extends ArchiveInputStream { private DumpArchiveSummary summary; private DumpArchiveEntry active; private boolean isClosed; private boolean hasHitEOF; private long entrySize; private long entryOffset; private int readIdx; private final byte[] readBuf = new byte[DumpArchiveConstants.TP_SIZE]; private byte[] blockBuffer; private int recordOffset; private long filepos; protected TapeInputStream raw; private final Map<Integer, Dirent> names = new HashMap<Integer, Dirent>(); private final Map<Integer, DumpArchiveEntry> pending = new HashMap<Integer, DumpArchiveEntry>(); private Queue<DumpArchiveEntry> queue; private final ZipEncoding zipEncoding; public DumpArchiveInputStream(InputStream is) throws ArchiveException {\n        this(is, null);\n    }\n\n    \n    public DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n        this.raw = new TapeInputStream(is);\n        this.hasHitEOF = false;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n\n        try {\n            \n            byte[] headerBytes = raw.readRecord();\n\n            if (!DumpArchiveUtil.verify(headerBytes)) {\n                throw new UnrecognizedFormatException();\n            }\n\n            \n            summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n\n            \n            raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n\n            \n            blockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n\n            \n            readCLRI();\n            readBITS();\n        } catch (IOException ex) {\n            throw new ArchiveException(ex.getMessage(), ex);\n        }\n\n        \n        Dirent root = new Dirent(2, 2, 4, \".\");\n        names.put(2, root);\n\n        \n        \n        queue = new PriorityQueue<DumpArchiveEntry>(10,\n                new Comparator<DumpArchiveEntry>() {\n                    public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n                        if (p.getOriginalName() == null || q.getOriginalName() == null) {\n                            return Integer.MAX_VALUE;\n                        }\n\n                        return p.getOriginalName().compareTo(q.getOriginalName());\n                    }\n                });\n    }\n\n    @Deprecated\n    @Override\n    public int getCount() {\n        return (int) getBytesRead();\n    }\n\n    @Override\n    public long getBytesRead() {\n        return raw.getBytesRead();\n    }\n\n    \n    public DumpArchiveSummary getSummary() {\n        return summary;\n    }\n\n    \n    private void readCLRI() throws IOException {\n        byte[] buffer = raw.readRecord();\n\n        if (!DumpArchiveUtil.verify(buffer)) {\n            throw new InvalidFormatException();\n        }\n\n        active = DumpArchiveEntry.parse(buffer);\n\n        if (DumpArchiveConstants.SEGMENT_TYPE.CLRI != active.getHeaderType()) {\n            throw new InvalidFormatException();\n        }\n\n        \n        if (raw.skip(DumpArchiveConstants.TP_SIZE * active.getHeaderCount())\n            == -1) {\n            throw new EOFException();\n        }\n        readIdx = active.getHeaderCount();\n    }\n\n    \n    private void readBITS() throws IOException {\n        byte[] buffer = raw.readRecord();\n\n        if (!DumpArchiveUtil.verify(buffer)) {\n            throw new InvalidFormatException();\n        }\n\n        active = DumpArchiveEntry.parse(buffer);\n\n        if (DumpArchiveConstants.SEGMENT_TYPE.BITS != active.getHeaderType()) {\n            throw new InvalidFormatException();\n        }\n\n        \n        if (raw.skip(DumpArchiveConstants.TP_SIZE * active.getHeaderCount())\n            == -1) {\n            throw new EOFException();\n        }\n        readIdx = active.getHeaderCount();\n    }\n\n    \n    public DumpArchiveEntry getNextDumpEntry() throws IOException {\n        return getNextEntry();\n    }\n\n    \n    @Override\n    public DumpArchiveEntry getNextEntry() throws IOException {\n        DumpArchiveEntry entry = null;\n        String path = null;\n\n        \n        if (!queue.isEmpty()) {\n            return queue.remove();\n        }\n\n        while (entry == null) {\n            if (hasHitEOF) {\n                return null;\n            }\n\n            \n            \n            \n            \n            while (readIdx < active.getHeaderCount()) {\n                if (!active.isSparseRecord(readIdx++)\n                    && raw.skip(DumpArchiveConstants.TP_SIZE) == -1) {\n                    throw new EOFException();\n                }\n            }\n\n            readIdx = 0;\n            filepos = raw.getBytesRead();\n\n            byte[] headerBytes = raw.readRecord();\n\n            if (!DumpArchiveUtil.verify(headerBytes)) {\n                throw new InvalidFormatException();\n            }\n\n            active = DumpArchiveEntry.parse(headerBytes);\n\n            \n            while (DumpArchiveConstants.SEGMENT_TYPE.ADDR == active.getHeaderType()) {\n                if (raw.skip(DumpArchiveConstants.TP_SIZE\n                             * (active.getHeaderCount()\n                                - active.getHeaderHoles())) == -1) {\n                    throw new EOFException();\n                }\n\n                filepos = raw.getBytesRead();\n                headerBytes = raw.readRecord();\n\n                if (!DumpArchiveUtil.verify(headerBytes)) {\n                    throw new InvalidFormatException();\n                }\n\n                active = DumpArchiveEntry.parse(headerBytes);\n            }\n\n            \n            if (DumpArchiveConstants.SEGMENT_TYPE.END == active.getHeaderType()) {\n                hasHitEOF = true;\n\n                return null;\n            }\n\n            entry = active;\n\n            if (entry.isDirectory()) {\n                readDirectoryEntry(active);\n\n                \n                entryOffset = 0;\n                entrySize = 0;\n                readIdx = active.getHeaderCount();\n            } else {\n                entryOffset = 0;\n                entrySize = active.getEntrySize();\n                readIdx = 0;\n            }\n\n            recordOffset = readBuf.length;\n\n            path = getPath(entry);\n\n            if (path == null) {\n                entry = null;\n            }\n        }\n\n        entry.setName(path);\n        entry.setSimpleName(names.get(entry.getIno()).getName());\n        entry.setOffset(filepos);\n\n        return entry;\n    }\n\n    \n    private void readDirectoryEntry(DumpArchiveEntry entry) throws IOException {\n        long size = entry.getEntrySize();\n        boolean first = true;\n\n        while (first ||\n                DumpArchiveConstants.SEGMENT_TYPE.ADDR == entry.getHeaderType()) {\n            \n            if (!first) {\n                raw.readRecord();\n            }\n\n            if (!names.containsKey(entry.getIno()) &&\n                    DumpArchiveConstants.SEGMENT_TYPE.INODE == entry.getHeaderType()) {\n                pending.put(entry.getIno(), entry);\n            }\n\n            int datalen = DumpArchiveConstants.TP_SIZE * entry.getHeaderCount();\n\n            if (blockBuffer.length < datalen) {\n                blockBuffer = new byte[datalen];\n            }\n\n            if (raw.read(blockBuffer, 0, datalen) != datalen) {\n                throw new EOFException();\n            }\n\n            int reclen = 0;\n\n            for (int i = 0; i < datalen - 8 && i < size - 8;\n                    i += reclen) {\n                int ino = DumpArchiveUtil.convert32(blockBuffer, i);\n                reclen = DumpArchiveUtil.convert16(blockBuffer, i + 4);\n\n                byte type = blockBuffer[i + 6];\n\n                String name = DumpArchiveUtil.decode(zipEncoding, blockBuffer, i + 8, blockBuffer[i + 7]);\n\n                if (\".\".equals(name) || \"..\".equals(name)) {\n                    \n                    continue;\n                }\n\n                Dirent d = new Dirent(ino, entry.getIno(), type, name);\n\n                \n\n                names.put(ino, d);\n\n                \n                for (Map.Entry<Integer, DumpArchiveEntry> e : pending.entrySet()) {\n                    String path = getPath(e.getValue());\n\n                    if (path != null) {\n                        e.getValue().setName(path);\n                        e.getValue()\n                         .setSimpleName(names.get(e.getKey()).getName());\n                        queue.add(e.getValue());\n                    }\n                }\n\n                \n                \n                for (DumpArchiveEntry e : queue) {\n                    pending.remove(e.getIno());\n                }\n            }\n\n            byte[] peekBytes = raw.peek();\n\n            if (!DumpArchiveUtil.verify(peekBytes)) {\n                throw new InvalidFormatException();\n            }\n\n            entry = DumpArchiveEntry.parse(peekBytes);\n            first = false;\n            size -= DumpArchiveConstants.TP_SIZE;\n        }\n    }\n\n    \n    private String getPath(DumpArchiveEntry entry) {\n        \n        \n        Stack<String> elements = new Stack<String>();\n        Dirent dirent = null;\n\n        for (int i = entry.getIno();; i = dirent.getParentIno()) {\n            if (!names.containsKey(i)) {\n                elements.clear();\n                break;\n            }\n\n            dirent = names.get(i);\n            elements.push(dirent.getName());\n\n            if (dirent.getIno() == dirent.getParentIno()) {\n                break;\n            }\n        }\n\n        \n        if (elements.isEmpty()) {\n            pending.put(entry.getIno(), entry);\n\n            return null;\n        }\n\n        \n        StringBuilder sb = new StringBuilder(elements.pop());\n\n        while (!elements.isEmpty()) {\n            sb.append('/');\n            sb.append(elements.pop());\n        }\n\n        return sb.toString();\n    }\n\n    \n    @Override\n    public int read(byte[] buf, int off, int len) throws IOException {\n        int totalRead = 0;\n\n        if (hasHitEOF || isClosed || entryOffset >= entrySize) {\n            return -1;\n        }\n\n        if (active == null) {\n            throw new IllegalStateException(\"No current dump entry\");\n        }\n\n        if (len + entryOffset > entrySize) {\n            len = (int) (entrySize - entryOffset);\n        }\n\n        while (len > 0) {\n            int sz = len > readBuf.length - recordOffset\n                ? readBuf.length - recordOffset : len;\n\n            \n            if (recordOffset + sz <= readBuf.length) {\n                System.arraycopy(readBuf, recordOffset, buf, off, sz);\n                totalRead += sz;\n                recordOffset += sz;\n                len -= sz;\n                off += sz;\n            }\n\n            \n            if (len > 0) {\n                if (readIdx >= 512) {\n                    byte[] headerBytes = raw.readRecord();\n\n                    if (!DumpArchiveUtil.verify(headerBytes)) {\n                        throw new InvalidFormatException();\n                    }\n\n                    active = DumpArchiveEntry.parse(headerBytes);\n                    readIdx = 0;\n                }\n\n                if (!active.isSparseRecord(readIdx++)) {\n                    int r = raw.read(readBuf, 0, readBuf.length);\n                    if (r != readBuf.length) {\n                        throw new EOFException();\n                    }\n                } else {\n                    Arrays.fill(readBuf, (byte) 0);\n                }\n\n                recordOffset = 0;\n            }\n        }\n\n        entryOffset += totalRead;\n\n        return totalRead;\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        if (!isClosed) {\n            isClosed = true;\n            raw.close();\n        }\n    }\n\n    \n    public static boolean matches(byte[] buffer, int length) {\n        \n        if (length < 32) {\n            return false;\n        }\n\n        \n        if (length >= DumpArchiveConstants.TP_SIZE) {\n            return DumpArchiveUtil.verify(buffer);\n        }\n\n        \n        return DumpArchiveConstants.NFS_MAGIC == DumpArchiveUtil.convert32(buffer,\n            24);\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.dump;\n\nimport org.apache.commons.compress.archivers.ArchiveException;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.archivers.zip.ZipEncoding;\nimport org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\n\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Stack;\n\n\npublic class DumpArchiveInputStream extends ArchiveInputStream { private DumpArchiveSummary summary; private DumpArchiveEntry active; private boolean isClosed; private boolean hasHitEOF; private long entrySize; private long entryOffset; private int readIdx; private final byte[] readBuf = new byte[DumpArchiveConstants.TP_SIZE]; private byte[] blockBuffer; private int recordOffset; private long filepos; protected TapeInputStream raw; private final Map<Integer, Dirent> names = new HashMap<Integer, Dirent>(); private final Map<Integer, DumpArchiveEntry> pending = new HashMap<Integer, DumpArchiveEntry>(); private Queue<DumpArchiveEntry> queue; private final ZipEncoding zipEncoding; final String encoding; public DumpArchiveInputStream(InputStream is) throws ArchiveException {\n        this(is, null);\n    }\n\n    \n    public DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n        this.raw = new TapeInputStream(is);\n        this.hasHitEOF = false;\n        this.encoding = encoding;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n\n        try {\n            \n            byte[] headerBytes = raw.readRecord();\n\n            if (!DumpArchiveUtil.verify(headerBytes)) {\n                throw new UnrecognizedFormatException();\n            }\n\n            \n            summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n\n            \n            raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n\n            \n            blockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n\n            \n            readCLRI();\n            readBITS();\n        } catch (IOException ex) {\n            throw new ArchiveException(ex.getMessage(), ex);\n        }\n\n        \n        Dirent root = new Dirent(2, 2, 4, \".\");\n        names.put(2, root);\n\n        \n        \n        queue = new PriorityQueue<DumpArchiveEntry>(10,\n                new Comparator<DumpArchiveEntry>() {\n                    public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n                        if (p.getOriginalName() == null || q.getOriginalName() == null) {\n                            return Integer.MAX_VALUE;\n                        }\n\n                        return p.getOriginalName().compareTo(q.getOriginalName());\n                    }\n                });\n    }\n\n    @Deprecated\n    @Override\n    public int getCount() {\n        return (int) getBytesRead();\n    }\n\n    @Override\n    public long getBytesRead() {\n        return raw.getBytesRead();\n    }\n\n    \n    public DumpArchiveSummary getSummary() {\n        return summary;\n    }\n\n    \n    private void readCLRI() throws IOException {\n        byte[] buffer = raw.readRecord();\n\n        if (!DumpArchiveUtil.verify(buffer)) {\n            throw new InvalidFormatException();\n        }\n\n        active = DumpArchiveEntry.parse(buffer);\n\n        if (DumpArchiveConstants.SEGMENT_TYPE.CLRI != active.getHeaderType()) {\n            throw new InvalidFormatException();\n        }\n\n        \n        if (raw.skip(DumpArchiveConstants.TP_SIZE * active.getHeaderCount())\n            == -1) {\n            throw new EOFException();\n        }\n        readIdx = active.getHeaderCount();\n    }\n\n    \n    private void readBITS() throws IOException {\n        byte[] buffer = raw.readRecord();\n\n        if (!DumpArchiveUtil.verify(buffer)) {\n            throw new InvalidFormatException();\n        }\n\n        active = DumpArchiveEntry.parse(buffer);\n\n        if (DumpArchiveConstants.SEGMENT_TYPE.BITS != active.getHeaderType()) {\n            throw new InvalidFormatException();\n        }\n\n        \n        if (raw.skip(DumpArchiveConstants.TP_SIZE * active.getHeaderCount())\n            == -1) {\n            throw new EOFException();\n        }\n        readIdx = active.getHeaderCount();\n    }\n\n    \n    public DumpArchiveEntry getNextDumpEntry() throws IOException {\n        return getNextEntry();\n    }\n\n    \n    @Override\n    public DumpArchiveEntry getNextEntry() throws IOException {\n        DumpArchiveEntry entry = null;\n        String path = null;\n\n        \n        if (!queue.isEmpty()) {\n            return queue.remove();\n        }\n\n        while (entry == null) {\n            if (hasHitEOF) {\n                return null;\n            }\n\n            \n            \n            \n            \n            while (readIdx < active.getHeaderCount()) {\n                if (!active.isSparseRecord(readIdx++)\n                    && raw.skip(DumpArchiveConstants.TP_SIZE) == -1) {\n                    throw new EOFException();\n                }\n            }\n\n            readIdx = 0;\n            filepos = raw.getBytesRead();\n\n            byte[] headerBytes = raw.readRecord();\n\n            if (!DumpArchiveUtil.verify(headerBytes)) {\n                throw new InvalidFormatException();\n            }\n\n            active = DumpArchiveEntry.parse(headerBytes);\n\n            \n            while (DumpArchiveConstants.SEGMENT_TYPE.ADDR == active.getHeaderType()) {\n                if (raw.skip(DumpArchiveConstants.TP_SIZE\n                             * (active.getHeaderCount()\n                                - active.getHeaderHoles())) == -1) {\n                    throw new EOFException();\n                }\n\n                filepos = raw.getBytesRead();\n                headerBytes = raw.readRecord();\n\n                if (!DumpArchiveUtil.verify(headerBytes)) {\n                    throw new InvalidFormatException();\n                }\n\n                active = DumpArchiveEntry.parse(headerBytes);\n            }\n\n            \n            if (DumpArchiveConstants.SEGMENT_TYPE.END == active.getHeaderType()) {\n                hasHitEOF = true;\n\n                return null;\n            }\n\n            entry = active;\n\n            if (entry.isDirectory()) {\n                readDirectoryEntry(active);\n\n                \n                entryOffset = 0;\n                entrySize = 0;\n                readIdx = active.getHeaderCount();\n            } else {\n                entryOffset = 0;\n                entrySize = active.getEntrySize();\n                readIdx = 0;\n            }\n\n            recordOffset = readBuf.length;\n\n            path = getPath(entry);\n\n            if (path == null) {\n                entry = null;\n            }\n        }\n\n        entry.setName(path);\n        entry.setSimpleName(names.get(entry.getIno()).getName());\n        entry.setOffset(filepos);\n\n        return entry;\n    }\n\n    \n    private void readDirectoryEntry(DumpArchiveEntry entry) throws IOException {\n        long size = entry.getEntrySize();\n        boolean first = true;\n\n        while (first ||\n                DumpArchiveConstants.SEGMENT_TYPE.ADDR == entry.getHeaderType()) {\n            \n            if (!first) {\n                raw.readRecord();\n            }\n\n            if (!names.containsKey(entry.getIno()) &&\n                    DumpArchiveConstants.SEGMENT_TYPE.INODE == entry.getHeaderType()) {\n                pending.put(entry.getIno(), entry);\n            }\n\n            int datalen = DumpArchiveConstants.TP_SIZE * entry.getHeaderCount();\n\n            if (blockBuffer.length < datalen) {\n                blockBuffer = new byte[datalen];\n            }\n\n            if (raw.read(blockBuffer, 0, datalen) != datalen) {\n                throw new EOFException();\n            }\n\n            int reclen = 0;\n\n            for (int i = 0; i < datalen - 8 && i < size - 8;\n                    i += reclen) {\n                int ino = DumpArchiveUtil.convert32(blockBuffer, i);\n                reclen = DumpArchiveUtil.convert16(blockBuffer, i + 4);\n\n                byte type = blockBuffer[i + 6];\n\n                String name = DumpArchiveUtil.decode(zipEncoding, blockBuffer, i + 8, blockBuffer[i + 7]);\n\n                if (\".\".equals(name) || \"..\".equals(name)) {\n                    \n                    continue;\n                }\n\n                Dirent d = new Dirent(ino, entry.getIno(), type, name);\n\n                \n\n                names.put(ino, d);\n\n                \n                for (Map.Entry<Integer, DumpArchiveEntry> e : pending.entrySet()) {\n                    String path = getPath(e.getValue());\n\n                    if (path != null) {\n                        e.getValue().setName(path);\n                        e.getValue()\n                         .setSimpleName(names.get(e.getKey()).getName());\n                        queue.add(e.getValue());\n                    }\n                }\n\n                \n                \n                for (DumpArchiveEntry e : queue) {\n                    pending.remove(e.getIno());\n                }\n            }\n\n            byte[] peekBytes = raw.peek();\n\n            if (!DumpArchiveUtil.verify(peekBytes)) {\n                throw new InvalidFormatException();\n            }\n\n            entry = DumpArchiveEntry.parse(peekBytes);\n            first = false;\n            size -= DumpArchiveConstants.TP_SIZE;\n        }\n    }\n\n    \n    private String getPath(DumpArchiveEntry entry) {\n        \n        \n        Stack<String> elements = new Stack<String>();\n        Dirent dirent = null;\n\n        for (int i = entry.getIno();; i = dirent.getParentIno()) {\n            if (!names.containsKey(i)) {\n                elements.clear();\n                break;\n            }\n\n            dirent = names.get(i);\n            elements.push(dirent.getName());\n\n            if (dirent.getIno() == dirent.getParentIno()) {\n                break;\n            }\n        }\n\n        \n        if (elements.isEmpty()) {\n            pending.put(entry.getIno(), entry);\n\n            return null;\n        }\n\n        \n        StringBuilder sb = new StringBuilder(elements.pop());\n\n        while (!elements.isEmpty()) {\n            sb.append('/');\n            sb.append(elements.pop());\n        }\n\n        return sb.toString();\n    }\n\n    \n    @Override\n    public int read(byte[] buf, int off, int len) throws IOException {\n        int totalRead = 0;\n\n        if (hasHitEOF || isClosed || entryOffset >= entrySize) {\n            return -1;\n        }\n\n        if (active == null) {\n            throw new IllegalStateException(\"No current dump entry\");\n        }\n\n        if (len + entryOffset > entrySize) {\n            len = (int) (entrySize - entryOffset);\n        }\n\n        while (len > 0) {\n            int sz = len > readBuf.length - recordOffset\n                ? readBuf.length - recordOffset : len;\n\n            \n            if (recordOffset + sz <= readBuf.length) {\n                System.arraycopy(readBuf, recordOffset, buf, off, sz);\n                totalRead += sz;\n                recordOffset += sz;\n                len -= sz;\n                off += sz;\n            }\n\n            \n            if (len > 0) {\n                if (readIdx >= 512) {\n                    byte[] headerBytes = raw.readRecord();\n\n                    if (!DumpArchiveUtil.verify(headerBytes)) {\n                        throw new InvalidFormatException();\n                    }\n\n                    active = DumpArchiveEntry.parse(headerBytes);\n                    readIdx = 0;\n                }\n\n                if (!active.isSparseRecord(readIdx++)) {\n                    int r = raw.read(readBuf, 0, readBuf.length);\n                    if (r != readBuf.length) {\n                        throw new EOFException();\n                    }\n                } else {\n                    Arrays.fill(readBuf, (byte) 0);\n                }\n\n                recordOffset = 0;\n            }\n        }\n\n        entryOffset += totalRead;\n\n        return totalRead;\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        if (!isClosed) {\n            isClosed = true;\n            raw.close();\n        }\n    }\n\n    \n    public static boolean matches(byte[] buffer, int length) {\n        \n        if (length < 32) {\n            return false;\n        }\n\n        \n        if (length >= DumpArchiveConstants.TP_SIZE) {\n            return DumpArchiveUtil.verify(buffer);\n        }\n\n        \n        return DumpArchiveConstants.NFS_MAGIC == DumpArchiveUtil.convert32(buffer,\n            24);\n    }\n\n}\n",
      "buggy_signatures": [
        "public DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException",
        "public int compare(DumpArchiveEntry p, DumpArchiveEntry q)",
        "public int getCount()",
        "public long getBytesRead()",
        "public DumpArchiveSummary getSummary()",
        "private void readCLRI() throws IOException",
        "private void readBITS() throws IOException",
        "public DumpArchiveEntry getNextDumpEntry() throws IOException",
        "public DumpArchiveEntry getNextEntry() throws IOException",
        "private void readDirectoryEntry(DumpArchiveEntry entry) throws IOException",
        "private String getPath(DumpArchiveEntry entry)",
        "public int read(byte[] buf, int off, int len) throws IOException",
        "public void close() throws IOException",
        "public static boolean matches(byte[] buffer, int length)"
      ],
      "fixed_signatures": [
        "public DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException",
        "public int compare(DumpArchiveEntry p, DumpArchiveEntry q)",
        "public int getCount()",
        "public long getBytesRead()",
        "public DumpArchiveSummary getSummary()",
        "private void readCLRI() throws IOException",
        "private void readBITS() throws IOException",
        "public DumpArchiveEntry getNextDumpEntry() throws IOException",
        "public DumpArchiveEntry getNextEntry() throws IOException",
        "private void readDirectoryEntry(DumpArchiveEntry entry) throws IOException",
        "private String getPath(DumpArchiveEntry entry)",
        "public int read(byte[] buf, int off, int len) throws IOException",
        "public void close() throws IOException",
        "public static boolean matches(byte[] buffer, int length)"
      ],
      "methods": [
        {
          "buggy_method": "  private final Map<Integer, DumpArchiveEntry> pending = new HashMap<Integer, DumpArchiveEntry>(); private Queue<DumpArchiveEntry> queue; private final ZipEncoding zipEncoding; public DumpArchiveInputStream(InputStream is) throws ArchiveException {\n  this(is, null);\n  }",
          "fixed_method": "  private final Map<Integer, DumpArchiveEntry> pending = new HashMap<Integer, DumpArchiveEntry>(); private Queue<DumpArchiveEntry> queue; private final ZipEncoding zipEncoding; final String encoding; public DumpArchiveInputStream(InputStream is) throws ArchiveException {\n  this(is, null);\n  }",
          "diff": [
            "@@ -77,6 +77,7 @@",
            "     private final ZipEncoding zipEncoding;\n",
            " \n",
            "     // the provided encoding (for unit tests)\n",
            "+    final String encoding;\n",
            " \n",
            "     /**\n",
            "      * Constructor using the platform's default encoding for file\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  public DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n  this.raw = new TapeInputStream(is);\n  this.hasHitEOF = false;\n  this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n\n  try {\n  \n  byte[] headerBytes = raw.readRecord();\n\n  if (!DumpArchiveUtil.verify(headerBytes)) {\n  throw new UnrecognizedFormatException();\n  }\n\n  \n  summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n\n  \n  raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n\n  \n  blockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n\n  \n  readCLRI();\n  readBITS();\n  } catch (IOException ex) {\n  throw new ArchiveException(ex.getMessage(), ex);\n  }\n\n  \n  Dirent root = new Dirent(2, 2, 4, \".\");\n  names.put(2, root);\n\n  \n  \n  queue = new PriorityQueue<DumpArchiveEntry>(10,\n  new Comparator<DumpArchiveEntry>() {\n  public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n  if (p.getOriginalName() == null || q.getOriginalName() == null) {\n  return Integer.MAX_VALUE;\n  }\n\n  return p.getOriginalName().compareTo(q.getOriginalName());\n  }\n  });\n  }",
          "fixed_method": "  public DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n  this.raw = new TapeInputStream(is);\n  this.hasHitEOF = false;\n  this.encoding = encoding;\n  this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n\n  try {\n  \n  byte[] headerBytes = raw.readRecord();\n\n  if (!DumpArchiveUtil.verify(headerBytes)) {\n  throw new UnrecognizedFormatException();\n  }\n\n  \n  summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n\n  \n  raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n\n  \n  blockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n\n  \n  readCLRI();\n  readBITS();\n  } catch (IOException ex) {\n  throw new ArchiveException(ex.getMessage(), ex);\n  }\n\n  \n  Dirent root = new Dirent(2, 2, 4, \".\");\n  names.put(2, root);\n\n  \n  \n  queue = new PriorityQueue<DumpArchiveEntry>(10,\n  new Comparator<DumpArchiveEntry>() {\n  public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n  if (p.getOriginalName() == null || q.getOriginalName() == null) {\n  return Integer.MAX_VALUE;\n  }\n\n  return p.getOriginalName().compareTo(q.getOriginalName());\n  }\n  });\n  }",
          "diff": [
            "@@ -101,6 +102,7 @@",
            "         throws ArchiveException {\n",
            "         this.raw = new TapeInputStream(is);\n",
            "         this.hasHitEOF = false;\n",
            "+        this.encoding = encoding;\n",
            "         this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n",
            " \n",
            "         try {\n"
          ],
          "changed_lines": 1
        }
      ]
    },
    {
      "name": "org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java",
      "buggy_full_code": "\n\n\n\npackage org.apache.commons.compress.archivers.tar;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.archivers.zip.ZipEncoding;\nimport org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\nimport org.apache.commons.compress.utils.ArchiveUtils;\nimport org.apache.commons.compress.utils.CharsetNames;\nimport org.apache.commons.compress.utils.IOUtils;\n\n\npublic class TarArchiveInputStream extends ArchiveInputStream { private static final int SMALL_BUFFER_SIZE = 256; private final byte[] SMALL_BUF = new byte[SMALL_BUFFER_SIZE]; private final int recordSize; private final int blockSize; private boolean hasHitEOF; private long entrySize; private long entryOffset; private final InputStream is; private TarArchiveEntry currEntry; private final ZipEncoding zipEncoding; public TarArchiveInputStream(InputStream is) {\n        this(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveInputStream(InputStream is, String encoding) {\n        this(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE,\n             encoding);\n    }\n\n    \n    public TarArchiveInputStream(InputStream is, int blockSize) {\n        this(is, blockSize, TarConstants.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveInputStream(InputStream is, int blockSize, String encoding) {\n        this(is, blockSize, TarConstants.DEFAULT_RCDSIZE, encoding);\n    }\n\n    \n    public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\n        this(is, blockSize, recordSize, null);      \n    }\n\n    \n    public TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n        this.is = is;\n        this.hasHitEOF = false;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.recordSize = recordSize;\n        this.blockSize = blockSize;\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        is.close();\n    }\n\n    \n    public int getRecordSize() {\n        return recordSize;\n    }\n\n    \n    @Override\n    public int available() throws IOException {\n        if (entrySize - entryOffset > Integer.MAX_VALUE) {\n            return Integer.MAX_VALUE;\n        }\n        return (int) (entrySize - entryOffset);\n    }\n\n    \n    \n    @Override\n    public long skip(final long n) throws IOException {\n        if (n <= 0) {\n            return 0;\n        }\n\n        final long available = entrySize - entryOffset;\n        final long skipped = is.skip(Math.min(n, available)); \n        count(skipped);\n        entryOffset += skipped;\n        return skipped;\n    }\n\n    \n    @Override\n    public boolean markSupported() {\n        return false;\n    }\n\n    \n    @Override\n    public void mark(int markLimit) {\n    }\n\n    \n    @Override\n    public synchronized void reset() {\n    }\n\n    \n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            \n            IOUtils.skip(this, Long.MAX_VALUE);\n\n            \n            skipRecordPadding();\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (headerBuf == null) {\n            \n            currEntry = null;\n            return null;\n        }\n\n        try {\n            currEntry = new TarArchiveEntry(headerBuf, zipEncoding);\n        } catch (IllegalArgumentException e) {\n            IOException ioe = new IOException(\"Error detected parsing the header\");\n            ioe.initCause(e);\n            throw ioe;\n        }\n\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongLinkEntry()) {\n            byte[] longLinkData = getLongNameData();\n            if (longLinkData == null) {\n                \n                \n                \n                return null;\n            }\n            currEntry.setLinkName(zipEncoding.decode(longLinkData));\n        }\n\n        if (currEntry.isGNULongNameEntry()) {\n            byte[] longNameData = getLongNameData();\n            if (longNameData == null) {\n                \n                \n                \n                return null;\n            }\n            currEntry.setName(zipEncoding.decode(longNameData));\n        }\n\n        if (currEntry.isPaxHeader()){ \n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()){ \n            readGNUSparse();\n        }\n\n        \n        \n        \n        \n        entrySize = currEntry.getSize();\n\n        return currEntry;\n    }\n    \n    \n    private void skipRecordPadding() throws IOException {\n        if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) {\n            long numRecords = (this.entrySize / this.recordSize) + 1;\n            long padding = (numRecords * this.recordSize) - this.entrySize;\n            long skipped = IOUtils.skip(is, padding);\n            count(skipped);\n        }\n    }\n\n    \n    protected byte[] getLongNameData() throws IOException {\n        \n        ByteArrayOutputStream longName = new ByteArrayOutputStream();\n        int length = 0;\n        while ((length = read(SMALL_BUF)) >= 0) {\n            longName.write(SMALL_BUF, 0, length);\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            \n            \n            return null;\n        }\n        byte[] longNameData = longName.toByteArray();\n        \n        length = longNameData.length;\n        while (length > 0 && longNameData[length - 1] == 0) {\n            --length;\n        }\n        if (length != longNameData.length) {\n            byte[] l = new byte[length];\n            System.arraycopy(longNameData, 0, l, 0, length);\n            longNameData = l;\n        }\n        return longNameData;\n    }\n\n    \n    private byte[] getRecord() throws IOException {\n        byte[] headerBuf = readRecord();\n        hasHitEOF = isEOFRecord(headerBuf);\n        if (hasHitEOF && headerBuf != null) {\n            tryToConsumeSecondEOFRecord();\n            consumeRemainderOfLastBlock();\n            headerBuf = null;\n        }\n        return headerBuf;\n    }\n\n    \n    protected boolean isEOFRecord(byte[] record) {\n        return record == null || ArchiveUtils.isArrayZero(record, recordSize);\n    }\n    \n    \n    protected byte[] readRecord() throws IOException {\n\n        byte[] record = new byte[recordSize];\n\n        int readNow = IOUtils.readFully(is, record);\n        count(readNow);\n        if (readNow != recordSize) {\n            return null;\n        }\n\n        return record;\n    }\n\n    private void paxHeaders() throws IOException {\n        Map<String, String> headers = parsePaxHeaders(this);\n        getNextEntry(); \n        applyPaxHeadersToCurrentEntry(headers);\n    }\n\n    Map<String, String> parsePaxHeaders(InputStream i) throws IOException {\n        Map<String, String> headers = new HashMap<String, String>();\n        \n        while(true){ \n            int ch;\n            int len = 0;\n            int read = 0;\n            while((ch = i.read()) != -1) {\n                read++;\n                if (ch == ' '){ \n                    \n                    ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                    while((ch = i.read()) != -1) {\n                        read++;\n                        if (ch == '='){ \n                            String keyword = coll.toString(CharsetNames.UTF_8);\n                            \n                            final int restLen = len - read;\n                            byte[] rest = new byte[restLen];\n                            int got = IOUtils.readFully(i, rest);\n                            if (got != restLen) {\n                                throw new IOException(\"Failed to read \"\n                                                      + \"Paxheader. Expected \"\n                                                      + restLen\n                                                      + \" bytes, read \"\n                                                      + got);\n                            }\n                            \n                            String value = new String(rest, 0,\n                                                      restLen - 1, CharsetNames.UTF_8);\n                            headers.put(keyword, value);\n                            break;\n                        }\n                        coll.write((byte) ch);\n                    }\n                    break; \n                }\n                len *= 10;\n                len += ch - '0';\n            }\n            if (ch == -1){ \n                break;\n            }\n        }\n        return headers;\n    }\n\n    private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n        \n        for (Entry<String, String> ent : headers.entrySet()){\n            String key = ent.getKey();\n            String val = ent.getValue();\n            if (\"path\".equals(key)){\n                currEntry.setName(val);\n            } else if (\"linkpath\".equals(key)){\n                currEntry.setLinkName(val);\n            } else if (\"gid\".equals(key)){\n                currEntry.setGroupId(Integer.parseInt(val));\n            } else if (\"gname\".equals(key)){\n                currEntry.setGroupName(val);\n            } else if (\"uid\".equals(key)){\n                currEntry.setUserId(Integer.parseInt(val));\n            } else if (\"uname\".equals(key)){\n                currEntry.setUserName(val);\n            } else if (\"size\".equals(key)){\n                currEntry.setSize(Long.parseLong(val));\n            } else if (\"mtime\".equals(key)){\n                currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n            } else if (\"SCHILY.devminor\".equals(key)){\n                currEntry.setDevMinor(Integer.parseInt(val));\n            } else if (\"SCHILY.devmajor\".equals(key)){\n                currEntry.setDevMajor(Integer.parseInt(val));\n            }\n        }\n    }\n\n    \n    private void readGNUSparse() throws IOException {\n        \n        if (currEntry.isExtended()) {\n            TarArchiveSparseEntry entry;\n            do {\n                byte[] headerBuf = getRecord();\n                if (headerBuf == null) {\n                    currEntry = null;\n                    break;\n                }\n                entry = new TarArchiveSparseEntry(headerBuf);\n                \n            } while (entry.isExtended());\n        }\n    }\n\n    \n    @Override\n    public ArchiveEntry getNextEntry() throws IOException {\n        return getNextTarEntry();\n    }\n    \n    \n    private void tryToConsumeSecondEOFRecord() throws IOException {\n        boolean shouldReset = true;\n        boolean marked = is.markSupported();\n        if (marked) {\n            is.mark(recordSize);\n        }\n        try {\n            shouldReset = !isEOFRecord(readRecord());\n        } finally {\n            if (shouldReset && marked) {\n                pushedBackBytes(recordSize);\n            \tis.reset();\n            }\n        }\n    }\n\n    \n    @Override\n    public int read(byte[] buf, int offset, int numToRead) throws IOException {\n    \tint totalRead = 0;\n\n        if (hasHitEOF || entryOffset >= entrySize) {\n            return -1;\n        }\n\n        if (currEntry == null) {\n            throw new IllegalStateException(\"No current tar entry\");\n        }\n\n        numToRead = Math.min(numToRead, available());\n        \n        totalRead = is.read(buf, offset, numToRead);\n        \n        if (totalRead == -1) {\n            if (numToRead > 0) {\n                throw new IOException(\"Truncated TAR archive\");\n            }\n            hasHitEOF = true;\n        } else {\n            count(totalRead);\n            entryOffset += totalRead;\n        }\n\n        return totalRead;\n    }\n\n    \n    @Override\n    public boolean canReadEntryData(ArchiveEntry ae) {\n        if (ae instanceof TarArchiveEntry) {\n            TarArchiveEntry te = (TarArchiveEntry) ae;\n            return !te.isGNUSparse();\n        }\n        return false;\n    }\n\n    \n    public TarArchiveEntry getCurrentEntry() {\n        return currEntry;\n    }\n\n    protected final void setCurrentEntry(TarArchiveEntry e) {\n        currEntry = e;\n    }\n\n    protected final boolean isAtEOF() {\n        return hasHitEOF;\n    }\n\n    protected final void setAtEOF(boolean b) {\n        hasHitEOF = b;\n    }\n\n    \n    private void consumeRemainderOfLastBlock() throws IOException {\n        long bytesReadOfLastBlock = getBytesRead() % blockSize;\n        if (bytesReadOfLastBlock > 0) {\n            long skipped = IOUtils.skip(is, blockSize - bytesReadOfLastBlock);\n            count(skipped);\n        }\n    }\n\n    \n    public static boolean matches(byte[] signature, int length) {\n        if (length < TarConstants.VERSION_OFFSET+TarConstants.VERSIONLEN) {\n            return false;\n        }\n\n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_POSIX,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_POSIX,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n                ){\n            return true;\n        }\n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_GNU,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            (\n             ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_SPACE,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n            ||\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_ZERO,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n            )\n                ){\n            return true;\n        }\n        \n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_ANT,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_ANT,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n                ){\n            return true;\n        }\n        return false;\n    }\n\n}\n",
      "fixed_full_code": "\n\n\n\npackage org.apache.commons.compress.archivers.tar;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.archivers.zip.ZipEncoding;\nimport org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\nimport org.apache.commons.compress.utils.ArchiveUtils;\nimport org.apache.commons.compress.utils.CharsetNames;\nimport org.apache.commons.compress.utils.IOUtils;\n\n\npublic class TarArchiveInputStream extends ArchiveInputStream { private static final int SMALL_BUFFER_SIZE = 256; private final byte[] SMALL_BUF = new byte[SMALL_BUFFER_SIZE]; private final int recordSize; private final int blockSize; private boolean hasHitEOF; private long entrySize; private long entryOffset; private final InputStream is; private TarArchiveEntry currEntry; private final ZipEncoding zipEncoding; final String encoding; public TarArchiveInputStream(InputStream is) {\n        this(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveInputStream(InputStream is, String encoding) {\n        this(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE,\n             encoding);\n    }\n\n    \n    public TarArchiveInputStream(InputStream is, int blockSize) {\n        this(is, blockSize, TarConstants.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveInputStream(InputStream is, int blockSize, String encoding) {\n        this(is, blockSize, TarConstants.DEFAULT_RCDSIZE, encoding);\n    }\n\n    \n    public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\n        this(is, blockSize, recordSize, null);      \n    }\n\n    \n    public TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n        this.is = is;\n        this.hasHitEOF = false;\n        this.encoding = encoding;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.recordSize = recordSize;\n        this.blockSize = blockSize;\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        is.close();\n    }\n\n    \n    public int getRecordSize() {\n        return recordSize;\n    }\n\n    \n    @Override\n    public int available() throws IOException {\n        if (entrySize - entryOffset > Integer.MAX_VALUE) {\n            return Integer.MAX_VALUE;\n        }\n        return (int) (entrySize - entryOffset);\n    }\n\n    \n    \n    @Override\n    public long skip(final long n) throws IOException {\n        if (n <= 0) {\n            return 0;\n        }\n\n        final long available = entrySize - entryOffset;\n        final long skipped = is.skip(Math.min(n, available)); \n        count(skipped);\n        entryOffset += skipped;\n        return skipped;\n    }\n\n    \n    @Override\n    public boolean markSupported() {\n        return false;\n    }\n\n    \n    @Override\n    public void mark(int markLimit) {\n    }\n\n    \n    @Override\n    public synchronized void reset() {\n    }\n\n    \n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            \n            IOUtils.skip(this, Long.MAX_VALUE);\n\n            \n            skipRecordPadding();\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (headerBuf == null) {\n            \n            currEntry = null;\n            return null;\n        }\n\n        try {\n            currEntry = new TarArchiveEntry(headerBuf, zipEncoding);\n        } catch (IllegalArgumentException e) {\n            IOException ioe = new IOException(\"Error detected parsing the header\");\n            ioe.initCause(e);\n            throw ioe;\n        }\n\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongLinkEntry()) {\n            byte[] longLinkData = getLongNameData();\n            if (longLinkData == null) {\n                \n                \n                \n                return null;\n            }\n            currEntry.setLinkName(zipEncoding.decode(longLinkData));\n        }\n\n        if (currEntry.isGNULongNameEntry()) {\n            byte[] longNameData = getLongNameData();\n            if (longNameData == null) {\n                \n                \n                \n                return null;\n            }\n            currEntry.setName(zipEncoding.decode(longNameData));\n        }\n\n        if (currEntry.isPaxHeader()){ \n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()){ \n            readGNUSparse();\n        }\n\n        \n        \n        \n        \n        entrySize = currEntry.getSize();\n\n        return currEntry;\n    }\n    \n    \n    private void skipRecordPadding() throws IOException {\n        if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) {\n            long numRecords = (this.entrySize / this.recordSize) + 1;\n            long padding = (numRecords * this.recordSize) - this.entrySize;\n            long skipped = IOUtils.skip(is, padding);\n            count(skipped);\n        }\n    }\n\n    \n    protected byte[] getLongNameData() throws IOException {\n        \n        ByteArrayOutputStream longName = new ByteArrayOutputStream();\n        int length = 0;\n        while ((length = read(SMALL_BUF)) >= 0) {\n            longName.write(SMALL_BUF, 0, length);\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            \n            \n            return null;\n        }\n        byte[] longNameData = longName.toByteArray();\n        \n        length = longNameData.length;\n        while (length > 0 && longNameData[length - 1] == 0) {\n            --length;\n        }\n        if (length != longNameData.length) {\n            byte[] l = new byte[length];\n            System.arraycopy(longNameData, 0, l, 0, length);\n            longNameData = l;\n        }\n        return longNameData;\n    }\n\n    \n    private byte[] getRecord() throws IOException {\n        byte[] headerBuf = readRecord();\n        hasHitEOF = isEOFRecord(headerBuf);\n        if (hasHitEOF && headerBuf != null) {\n            tryToConsumeSecondEOFRecord();\n            consumeRemainderOfLastBlock();\n            headerBuf = null;\n        }\n        return headerBuf;\n    }\n\n    \n    protected boolean isEOFRecord(byte[] record) {\n        return record == null || ArchiveUtils.isArrayZero(record, recordSize);\n    }\n    \n    \n    protected byte[] readRecord() throws IOException {\n\n        byte[] record = new byte[recordSize];\n\n        int readNow = IOUtils.readFully(is, record);\n        count(readNow);\n        if (readNow != recordSize) {\n            return null;\n        }\n\n        return record;\n    }\n\n    private void paxHeaders() throws IOException {\n        Map<String, String> headers = parsePaxHeaders(this);\n        getNextEntry(); \n        applyPaxHeadersToCurrentEntry(headers);\n    }\n\n    Map<String, String> parsePaxHeaders(InputStream i) throws IOException {\n        Map<String, String> headers = new HashMap<String, String>();\n        \n        while(true){ \n            int ch;\n            int len = 0;\n            int read = 0;\n            while((ch = i.read()) != -1) {\n                read++;\n                if (ch == ' '){ \n                    \n                    ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                    while((ch = i.read()) != -1) {\n                        read++;\n                        if (ch == '='){ \n                            String keyword = coll.toString(CharsetNames.UTF_8);\n                            \n                            final int restLen = len - read;\n                            byte[] rest = new byte[restLen];\n                            int got = IOUtils.readFully(i, rest);\n                            if (got != restLen) {\n                                throw new IOException(\"Failed to read \"\n                                                      + \"Paxheader. Expected \"\n                                                      + restLen\n                                                      + \" bytes, read \"\n                                                      + got);\n                            }\n                            \n                            String value = new String(rest, 0,\n                                                      restLen - 1, CharsetNames.UTF_8);\n                            headers.put(keyword, value);\n                            break;\n                        }\n                        coll.write((byte) ch);\n                    }\n                    break; \n                }\n                len *= 10;\n                len += ch - '0';\n            }\n            if (ch == -1){ \n                break;\n            }\n        }\n        return headers;\n    }\n\n    private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n        \n        for (Entry<String, String> ent : headers.entrySet()){\n            String key = ent.getKey();\n            String val = ent.getValue();\n            if (\"path\".equals(key)){\n                currEntry.setName(val);\n            } else if (\"linkpath\".equals(key)){\n                currEntry.setLinkName(val);\n            } else if (\"gid\".equals(key)){\n                currEntry.setGroupId(Integer.parseInt(val));\n            } else if (\"gname\".equals(key)){\n                currEntry.setGroupName(val);\n            } else if (\"uid\".equals(key)){\n                currEntry.setUserId(Integer.parseInt(val));\n            } else if (\"uname\".equals(key)){\n                currEntry.setUserName(val);\n            } else if (\"size\".equals(key)){\n                currEntry.setSize(Long.parseLong(val));\n            } else if (\"mtime\".equals(key)){\n                currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n            } else if (\"SCHILY.devminor\".equals(key)){\n                currEntry.setDevMinor(Integer.parseInt(val));\n            } else if (\"SCHILY.devmajor\".equals(key)){\n                currEntry.setDevMajor(Integer.parseInt(val));\n            }\n        }\n    }\n\n    \n    private void readGNUSparse() throws IOException {\n        \n        if (currEntry.isExtended()) {\n            TarArchiveSparseEntry entry;\n            do {\n                byte[] headerBuf = getRecord();\n                if (headerBuf == null) {\n                    currEntry = null;\n                    break;\n                }\n                entry = new TarArchiveSparseEntry(headerBuf);\n                \n            } while (entry.isExtended());\n        }\n    }\n\n    \n    @Override\n    public ArchiveEntry getNextEntry() throws IOException {\n        return getNextTarEntry();\n    }\n    \n    \n    private void tryToConsumeSecondEOFRecord() throws IOException {\n        boolean shouldReset = true;\n        boolean marked = is.markSupported();\n        if (marked) {\n            is.mark(recordSize);\n        }\n        try {\n            shouldReset = !isEOFRecord(readRecord());\n        } finally {\n            if (shouldReset && marked) {\n                pushedBackBytes(recordSize);\n            \tis.reset();\n            }\n        }\n    }\n\n    \n    @Override\n    public int read(byte[] buf, int offset, int numToRead) throws IOException {\n    \tint totalRead = 0;\n\n        if (hasHitEOF || entryOffset >= entrySize) {\n            return -1;\n        }\n\n        if (currEntry == null) {\n            throw new IllegalStateException(\"No current tar entry\");\n        }\n\n        numToRead = Math.min(numToRead, available());\n        \n        totalRead = is.read(buf, offset, numToRead);\n        \n        if (totalRead == -1) {\n            if (numToRead > 0) {\n                throw new IOException(\"Truncated TAR archive\");\n            }\n            hasHitEOF = true;\n        } else {\n            count(totalRead);\n            entryOffset += totalRead;\n        }\n\n        return totalRead;\n    }\n\n    \n    @Override\n    public boolean canReadEntryData(ArchiveEntry ae) {\n        if (ae instanceof TarArchiveEntry) {\n            TarArchiveEntry te = (TarArchiveEntry) ae;\n            return !te.isGNUSparse();\n        }\n        return false;\n    }\n\n    \n    public TarArchiveEntry getCurrentEntry() {\n        return currEntry;\n    }\n\n    protected final void setCurrentEntry(TarArchiveEntry e) {\n        currEntry = e;\n    }\n\n    protected final boolean isAtEOF() {\n        return hasHitEOF;\n    }\n\n    protected final void setAtEOF(boolean b) {\n        hasHitEOF = b;\n    }\n\n    \n    private void consumeRemainderOfLastBlock() throws IOException {\n        long bytesReadOfLastBlock = getBytesRead() % blockSize;\n        if (bytesReadOfLastBlock > 0) {\n            long skipped = IOUtils.skip(is, blockSize - bytesReadOfLastBlock);\n            count(skipped);\n        }\n    }\n\n    \n    public static boolean matches(byte[] signature, int length) {\n        if (length < TarConstants.VERSION_OFFSET+TarConstants.VERSIONLEN) {\n            return false;\n        }\n\n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_POSIX,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_POSIX,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n                ){\n            return true;\n        }\n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_GNU,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            (\n             ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_SPACE,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n            ||\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_ZERO,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n            )\n                ){\n            return true;\n        }\n        \n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_ANT,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_ANT,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n                ){\n            return true;\n        }\n        return false;\n    }\n\n}\n",
      "buggy_signatures": [
        "public TarArchiveInputStream(InputStream is, String encoding)",
        "public TarArchiveInputStream(InputStream is, int blockSize)",
        "public TarArchiveInputStream(InputStream is, int blockSize, String encoding)",
        "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize)",
        "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding)",
        "public void close() throws IOException",
        "public int getRecordSize()",
        "public int available() throws IOException",
        "public long skip(final long n) throws IOException",
        "public boolean markSupported()",
        "public void mark(int markLimit)",
        "public synchronized void reset()",
        "public TarArchiveEntry getNextTarEntry() throws IOException",
        "private void skipRecordPadding() throws IOException",
        "protected byte[] getLongNameData() throws IOException",
        "private byte[] getRecord() throws IOException",
        "protected boolean isEOFRecord(byte[] record)",
        "protected byte[] readRecord() throws IOException",
        "private void paxHeaders() throws IOException",
        "private void applyPaxHeadersToCurrentEntry(Map<String, String> headers)",
        "private void readGNUSparse() throws IOException",
        "public ArchiveEntry getNextEntry() throws IOException",
        "private void tryToConsumeSecondEOFRecord() throws IOException",
        "public int read(byte[] buf, int offset, int numToRead) throws IOException",
        "public boolean canReadEntryData(ArchiveEntry ae)",
        "public TarArchiveEntry getCurrentEntry()",
        "protected final void setCurrentEntry(TarArchiveEntry e)",
        "protected final boolean isAtEOF()",
        "protected final void setAtEOF(boolean b)",
        "private void consumeRemainderOfLastBlock() throws IOException",
        "public static boolean matches(byte[] signature, int length)"
      ],
      "fixed_signatures": [
        "public TarArchiveInputStream(InputStream is, String encoding)",
        "public TarArchiveInputStream(InputStream is, int blockSize)",
        "public TarArchiveInputStream(InputStream is, int blockSize, String encoding)",
        "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize)",
        "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding)",
        "public void close() throws IOException",
        "public int getRecordSize()",
        "public int available() throws IOException",
        "public long skip(final long n) throws IOException",
        "public boolean markSupported()",
        "public void mark(int markLimit)",
        "public synchronized void reset()",
        "public TarArchiveEntry getNextTarEntry() throws IOException",
        "private void skipRecordPadding() throws IOException",
        "protected byte[] getLongNameData() throws IOException",
        "private byte[] getRecord() throws IOException",
        "protected boolean isEOFRecord(byte[] record)",
        "protected byte[] readRecord() throws IOException",
        "private void paxHeaders() throws IOException",
        "private void applyPaxHeadersToCurrentEntry(Map<String, String> headers)",
        "private void readGNUSparse() throws IOException",
        "public ArchiveEntry getNextEntry() throws IOException",
        "private void tryToConsumeSecondEOFRecord() throws IOException",
        "public int read(byte[] buf, int offset, int numToRead) throws IOException",
        "public boolean canReadEntryData(ArchiveEntry ae)",
        "public TarArchiveEntry getCurrentEntry()",
        "protected final void setCurrentEntry(TarArchiveEntry e)",
        "protected final boolean isAtEOF()",
        "protected final void setAtEOF(boolean b)",
        "private void consumeRemainderOfLastBlock() throws IOException",
        "public static boolean matches(byte[] signature, int length)"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -76,6 +76,7 @@",
            "     private final ZipEncoding zipEncoding;\n",
            " \n",
            "     // the provided encoding (for unit tests)\n",
            "+    final String encoding;\n",
            " \n",
            "     /**\n",
            "      * Constructor for TarInputStream.\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  public TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n  this.is = is;\n  this.hasHitEOF = false;\n  this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n  this.recordSize = recordSize;\n  this.blockSize = blockSize;\n  }",
          "fixed_method": "  public TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n  this.is = is;\n  this.hasHitEOF = false;\n  this.encoding = encoding;\n  this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n  this.recordSize = recordSize;\n  this.blockSize = blockSize;\n  }",
          "diff": [
            "@@ -139,6 +140,7 @@",
            "                                  String encoding) {\n",
            "         this.is = is;\n",
            "         this.hasHitEOF = false;\n",
            "+        this.encoding = encoding;\n",
            "         this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n",
            "         this.recordSize = recordSize;\n",
            "         this.blockSize = blockSize;\n"
          ],
          "changed_lines": 1
        }
      ]
    },
    {
      "name": "org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.tar;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveOutputStream;\nimport org.apache.commons.compress.archivers.zip.ZipEncoding;\nimport org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\nimport org.apache.commons.compress.utils.CharsetNames;\nimport org.apache.commons.compress.utils.CountingOutputStream;\n\n\npublic class TarArchiveOutputStream extends ArchiveOutputStream { public static final int LONGFILE_ERROR = 0; public static final int LONGFILE_TRUNCATE = 1; public static final int LONGFILE_GNU = 2; public static final int LONGFILE_POSIX = 3; public static final int BIGNUMBER_ERROR = 0; public static final int BIGNUMBER_STAR = 1; public static final int BIGNUMBER_POSIX = 2; private long currSize; private String currName; private long currBytes; private final byte[] recordBuf; private int assemLen; private final byte[] assemBuf; private int longFileMode = LONGFILE_ERROR; private int bigNumberMode = BIGNUMBER_ERROR; private int recordsWritten; private final int recordsPerBlock; private final int recordSize; private boolean closed = false; private boolean haveUnclosedEntry = false; private boolean finished = false; private final OutputStream out; private final ZipEncoding zipEncoding; private boolean addPaxHeadersForNonAsciiNames = false; private static final ZipEncoding ASCII = ZipEncodingHelper.getZipEncoding(\"ASCII\"); public TarArchiveOutputStream(OutputStream os) {\n        this(os, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, String encoding) {\n        this(os, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE, encoding);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize) {\n        this(os, blockSize, TarConstants.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize, String encoding) {\n        this(os, blockSize, TarConstants.DEFAULT_RCDSIZE, encoding);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) {\n        this(os, blockSize, recordSize, null);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n        out = new CountingOutputStream(os);\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n\n        this.assemLen = 0;\n        this.assemBuf = new byte[recordSize];\n        this.recordBuf = new byte[recordSize];\n        this.recordSize = recordSize;\n        this.recordsPerBlock = blockSize / recordSize;\n    }\n\n    \n    public void setLongFileMode(int longFileMode) {\n        this.longFileMode = longFileMode;\n    }\n\n    \n    public void setBigNumberMode(int bigNumberMode) {\n        this.bigNumberMode = bigNumberMode;\n    }\n\n    \n    public void setAddPaxHeadersForNonAsciiNames(boolean b) {\n        addPaxHeadersForNonAsciiNames = b;\n    }\n\n    @Deprecated\n    @Override\n    public int getCount() {\n        return (int) getBytesWritten();\n    }\n\n    @Override\n    public long getBytesWritten() {\n        return ((CountingOutputStream) out).getBytesWritten();\n    }\n\n    \n    @Override\n    public void finish() throws IOException {\n        if (finished) {\n            throw new IOException(\"This archive has already been finished\");\n        }\n\n        if (haveUnclosedEntry) {\n            throw new IOException(\"This archives contains unclosed entries.\");\n        }\n        writeEOFRecord();\n        writeEOFRecord();\n        padAsNeeded();\n        out.flush();\n        finished = true;\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        if (!finished) {\n            finish();\n        }\n\n        if (!closed) {\n            out.close();\n            closed = true;\n        }\n    }\n\n    \n    public int getRecordSize() {\n        return this.recordSize;\n    }\n\n    \n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if (finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        Map<String, String> paxHeaders = new HashMap<String, String>();\n        final String entryName = entry.getName();\n        boolean paxHeaderContainsPath = handleLongName(entry, entryName, paxHeaders, \"path\",\n                                                       TarConstants.LF_GNUTYPE_LONGNAME, \"file name\");\n\n        final String linkName = entry.getLinkName();\n        boolean paxHeaderContainsLinkPath = linkName != null && linkName.length() > 0\n            && handleLongName(entry, linkName, paxHeaders, \"linkpath\",\n                              TarConstants.LF_GNUTYPE_LONGLINK, \"link name\");\n\n        if (bigNumberMode == BIGNUMBER_POSIX) {\n            addPaxHeadersForBigNumbers(paxHeaders, entry);\n        } else if (bigNumberMode != BIGNUMBER_STAR) {\n            failForBigNumbers(entry);\n        }\n\n        if (addPaxHeadersForNonAsciiNames && !paxHeaderContainsPath\n            && !ASCII.canEncode(entryName)) {\n            paxHeaders.put(\"path\", entryName);\n        }\n\n        if (addPaxHeadersForNonAsciiNames && !paxHeaderContainsLinkPath\n            && (entry.isLink() || entry.isSymbolicLink())\n            && !ASCII.canEncode(linkName)) {\n            paxHeaders.put(\"linkpath\", linkName);\n        }\n\n        if (paxHeaders.size() > 0) {\n            writePaxHeaders(entry, entryName, paxHeaders);\n        }\n\n        entry.writeEntryHeader(recordBuf, zipEncoding,\n                               bigNumberMode == BIGNUMBER_STAR);\n        writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entryName;\n        haveUnclosedEntry = true;\n    }\n\n    \n    @Override\n    public void closeArchiveEntry() throws IOException {\n        if (finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        if (!haveUnclosedEntry){\n            throw new IOException(\"No current entry to close\");\n        }\n        if (assemLen > 0) {\n            for (int i = assemLen; i < assemBuf.length; ++i) {\n                assemBuf[i] = 0;\n            }\n\n            writeRecord(assemBuf);\n\n            currBytes += assemLen;\n            assemLen = 0;\n        }\n\n        if (currBytes < currSize) {\n            throw new IOException(\"entry '\" + currName + \"' closed at '\"\n                                  + currBytes\n                                  + \"' before the '\" + currSize\n                                  + \"' bytes specified in the header were written\");\n        }\n        haveUnclosedEntry = false;\n    }\n\n    \n    @Override\n    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n        if (!haveUnclosedEntry) {\n            throw new IllegalStateException(\"No current tar entry\");\n        }\n        if (currBytes + numToWrite > currSize) {\n            throw new IOException(\"request to write '\" + numToWrite\n                                  + \"' bytes exceeds size in header of '\"\n                                  + currSize + \"' bytes for entry '\"\n                                  + currName + \"'\");\n\n            \n            \n            \n            \n            \n            \n            \n        }\n\n        if (assemLen > 0) {\n            if (assemLen + numToWrite >= recordBuf.length) {\n                int aLen = recordBuf.length - assemLen;\n\n                System.arraycopy(assemBuf, 0, recordBuf, 0,\n                                 assemLen);\n                System.arraycopy(wBuf, wOffset, recordBuf,\n                                 assemLen, aLen);\n                writeRecord(recordBuf);\n\n                currBytes += recordBuf.length;\n                wOffset += aLen;\n                numToWrite -= aLen;\n                assemLen = 0;\n            } else {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                wOffset += numToWrite;\n                assemLen += numToWrite;\n                numToWrite = 0;\n            }\n        }\n\n        \n        \n        \n        \n        \n        while (numToWrite > 0) {\n            if (numToWrite < recordBuf.length) {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                assemLen += numToWrite;\n\n                break;\n            }\n\n            writeRecord(wBuf, wOffset);\n\n            int num = recordBuf.length;\n\n            currBytes += num;\n            numToWrite -= num;\n            wOffset += num;\n        }\n    }\n\n    \n    void writePaxHeaders(TarArchiveEntry entry,\n                         String entryName,\n                         Map<String, String> headers) throws IOException {\n        String name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n        if (name.length() >= TarConstants.NAMELEN) {\n            name = name.substring(0, TarConstants.NAMELEN - 1);\n        }\n        TarArchiveEntry pex = new TarArchiveEntry(name,\n                                                  TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n        transferModTime(entry, pex);\n\n        StringWriter w = new StringWriter();\n        for (Map.Entry<String, String> h : headers.entrySet()) {\n            String key = h.getKey();\n            String value = h.getValue();\n            int len = key.length() + value.length()\n                + 3 \n                + 2 ;\n            String line = len + \" \" + key + \"=\" + value + \"\\n\";\n            int actualLength = line.getBytes(CharsetNames.UTF_8).length;\n            while (len != actualLength) {\n                \n                \n                \n                \n                \n                len = actualLength;\n                line = len + \" \" + key + \"=\" + value + \"\\n\";\n                actualLength = line.getBytes(CharsetNames.UTF_8).length;\n            }\n            w.write(line);\n        }\n        byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n        pex.setSize(data.length);\n        putArchiveEntry(pex);\n        write(data);\n        closeArchiveEntry();\n    }\n\n    private String stripTo7Bits(String name) {\n        final int length = name.length();\n        StringBuilder result = new StringBuilder(length);\n        for (int i = 0; i < length; i++) {\n            char stripped = (char) (name.charAt(i) & 0x7F);\n            if (shouldBeReplaced(stripped)) {\n                result.append(\"_\");\n            } else {\n                result.append(stripped);\n            }\n        }\n        return result.toString();\n    }\n\n    \n    private boolean shouldBeReplaced(char c) {\n        return c == 0 \n            || c == '/' \n            || c == '\\\\'; \n    }\n\n    \n    private void writeEOFRecord() throws IOException {\n        Arrays.fill(recordBuf, (byte) 0);\n        writeRecord(recordBuf);\n    }\n\n    @Override\n    public void flush() throws IOException {\n        out.flush();\n    }\n\n    @Override\n    public ArchiveEntry createArchiveEntry(File inputFile, String entryName) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        return new TarArchiveEntry(inputFile, entryName);\n    }\n    \n    \n    private void writeRecord(byte[] record) throws IOException {\n        if (record.length != recordSize) {\n            throw new IOException(\"record to write has length '\"\n                                  + record.length\n                                  + \"' which is not the record size of '\"\n                                  + recordSize + \"'\");\n        }\n\n        out.write(record);\n        recordsWritten++;\n    }\n    \n    \n    private void writeRecord(byte[] buf, int offset) throws IOException {\n \n        if (offset + recordSize > buf.length) {\n            throw new IOException(\"record has length '\" + buf.length\n                                  + \"' with offset '\" + offset\n                                  + \"' which is less than the record size of '\"\n                                  + recordSize + \"'\");\n        }\n\n        out.write(buf, offset, recordSize);\n        recordsWritten++;\n    }\n\n    private void padAsNeeded() throws IOException {\n        int start = recordsWritten % recordsPerBlock;\n        if (start != 0) {\n            for (int i = start; i < recordsPerBlock; i++) {\n                writeEOFRecord();\n            }\n        }\n    }\n\n    private void addPaxHeadersForBigNumbers(Map<String, String> paxHeaders, TarArchiveEntry entry) {\n        addPaxHeaderForBigNumber(paxHeaders, \"size\", entry.getSize(),\n                                 TarConstants.MAXSIZE);\n        addPaxHeaderForBigNumber(paxHeaders, \"gid\", entry.getGroupId(),\n                                 TarConstants.MAXID);\n        addPaxHeaderForBigNumber(paxHeaders, \"mtime\",\n                                 entry.getModTime().getTime() / 1000,\n                                 TarConstants.MAXSIZE);\n        addPaxHeaderForBigNumber(paxHeaders, \"uid\", entry.getUserId(),\n                                 TarConstants.MAXID);\n        \n        addPaxHeaderForBigNumber(paxHeaders, \"SCHILY.devmajor\",\n                                 entry.getDevMajor(), TarConstants.MAXID);\n        addPaxHeaderForBigNumber(paxHeaders, \"SCHILY.devminor\",\n                                 entry.getDevMinor(), TarConstants.MAXID);\n        \n        failForBigNumber(\"mode\", entry.getMode(), TarConstants.MAXID);\n    }\n\n    private void addPaxHeaderForBigNumber(Map<String, String> paxHeaders, String header, long value, long maxValue) {\n        if (value < 0 || value > maxValue) {\n            paxHeaders.put(header, String.valueOf(value));\n        }\n    }\n\n    private void failForBigNumbers(TarArchiveEntry entry) {\n        failForBigNumber(\"entry size\", entry.getSize(), TarConstants.MAXSIZE);\n        failForBigNumberWithPosixMessage(\"group id\", entry.getGroupId(), TarConstants.MAXID);\n        failForBigNumber(\"last modification time\",\n                         entry.getModTime().getTime() / 1000,\n                         TarConstants.MAXSIZE);\n        failForBigNumber(\"user id\", entry.getUserId(), TarConstants.MAXID);\n        failForBigNumber(\"mode\", entry.getMode(), TarConstants.MAXID);\n        failForBigNumber(\"major device number\", entry.getDevMajor(),\n                         TarConstants.MAXID);\n        failForBigNumber(\"minor device number\", entry.getDevMinor(),\n                         TarConstants.MAXID);\n    }\n\n    private void failForBigNumber(String field, long value, long maxValue) {\n        failForBigNumber(field, value, maxValue, \"\");\n    }\n\n    private void failForBigNumberWithPosixMessage(String field, long value, long maxValue) {\n        failForBigNumber(field, value, maxValue, \" Use STAR or POSIX extensions to overcome this limit\");\n    }\n\n    private void failForBigNumber(String field, long value, long maxValue, String additionalMsg) {\n        if (value < 0 || value > maxValue) {\n            throw new RuntimeException(field + \" '\" + value\n                    + \"' is too big ( > \"\n                    + maxValue + \" ).\" + additionalMsg);\n        }\n    }\n\n    \n    private boolean handleLongName(TarArchiveEntry entry , String name, Map<String, String> paxHeaders, String paxHeaderName, byte linkType, String fieldName) throws IOException {\n        final ByteBuffer encodedName = zipEncoding.encode(name);\n        final int len = encodedName.limit() - encodedName.position();\n        if (len >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_POSIX) {\n                paxHeaders.put(paxHeaderName, name);\n                return true;\n            } else if (longFileMode == LONGFILE_GNU) {\n                \n                \n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK, linkType);\n\n                longLinkEntry.setSize(len + 1); \n                transferModTime(entry, longLinkEntry);\n                putArchiveEntry(longLinkEntry);\n                write(encodedName.array(), encodedName.arrayOffset(), len);\n                write(0); \n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(fieldName + \" '\" + name\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n        return false;\n    }\n\n    private void transferModTime(TarArchiveEntry from, TarArchiveEntry to) {\n        Date fromModTime = from.getModTime();\n        long fromModTimeSeconds = fromModTime.getTime() / 1000;\n        if (fromModTimeSeconds < 0 || fromModTimeSeconds > TarConstants.MAXSIZE) {\n            fromModTime = new Date(0);\n        }\n        to.setModTime(fromModTime);\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.tar;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveOutputStream;\nimport org.apache.commons.compress.archivers.zip.ZipEncoding;\nimport org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\nimport org.apache.commons.compress.utils.CharsetNames;\nimport org.apache.commons.compress.utils.CountingOutputStream;\n\n\npublic class TarArchiveOutputStream extends ArchiveOutputStream { public static final int LONGFILE_ERROR = 0; public static final int LONGFILE_TRUNCATE = 1; public static final int LONGFILE_GNU = 2; public static final int LONGFILE_POSIX = 3; public static final int BIGNUMBER_ERROR = 0; public static final int BIGNUMBER_STAR = 1; public static final int BIGNUMBER_POSIX = 2; private long currSize; private String currName; private long currBytes; private final byte[] recordBuf; private int assemLen; private final byte[] assemBuf; private int longFileMode = LONGFILE_ERROR; private int bigNumberMode = BIGNUMBER_ERROR; private int recordsWritten; private final int recordsPerBlock; private final int recordSize; private boolean closed = false; private boolean haveUnclosedEntry = false; private boolean finished = false; private final OutputStream out; private final ZipEncoding zipEncoding; final String encoding; private boolean addPaxHeadersForNonAsciiNames = false; private static final ZipEncoding ASCII = ZipEncodingHelper.getZipEncoding(\"ASCII\"); public TarArchiveOutputStream(OutputStream os) {\n        this(os, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, String encoding) {\n        this(os, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE, encoding);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize) {\n        this(os, blockSize, TarConstants.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize, String encoding) {\n        this(os, blockSize, TarConstants.DEFAULT_RCDSIZE, encoding);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) {\n        this(os, blockSize, recordSize, null);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n        out = new CountingOutputStream(os);\n        this.encoding = encoding;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n\n        this.assemLen = 0;\n        this.assemBuf = new byte[recordSize];\n        this.recordBuf = new byte[recordSize];\n        this.recordSize = recordSize;\n        this.recordsPerBlock = blockSize / recordSize;\n    }\n\n    \n    public void setLongFileMode(int longFileMode) {\n        this.longFileMode = longFileMode;\n    }\n\n    \n    public void setBigNumberMode(int bigNumberMode) {\n        this.bigNumberMode = bigNumberMode;\n    }\n\n    \n    public void setAddPaxHeadersForNonAsciiNames(boolean b) {\n        addPaxHeadersForNonAsciiNames = b;\n    }\n\n    @Deprecated\n    @Override\n    public int getCount() {\n        return (int) getBytesWritten();\n    }\n\n    @Override\n    public long getBytesWritten() {\n        return ((CountingOutputStream) out).getBytesWritten();\n    }\n\n    \n    @Override\n    public void finish() throws IOException {\n        if (finished) {\n            throw new IOException(\"This archive has already been finished\");\n        }\n\n        if (haveUnclosedEntry) {\n            throw new IOException(\"This archives contains unclosed entries.\");\n        }\n        writeEOFRecord();\n        writeEOFRecord();\n        padAsNeeded();\n        out.flush();\n        finished = true;\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        if (!finished) {\n            finish();\n        }\n\n        if (!closed) {\n            out.close();\n            closed = true;\n        }\n    }\n\n    \n    public int getRecordSize() {\n        return this.recordSize;\n    }\n\n    \n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if (finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        Map<String, String> paxHeaders = new HashMap<String, String>();\n        final String entryName = entry.getName();\n        boolean paxHeaderContainsPath = handleLongName(entry, entryName, paxHeaders, \"path\",\n                                                       TarConstants.LF_GNUTYPE_LONGNAME, \"file name\");\n\n        final String linkName = entry.getLinkName();\n        boolean paxHeaderContainsLinkPath = linkName != null && linkName.length() > 0\n            && handleLongName(entry, linkName, paxHeaders, \"linkpath\",\n                              TarConstants.LF_GNUTYPE_LONGLINK, \"link name\");\n\n        if (bigNumberMode == BIGNUMBER_POSIX) {\n            addPaxHeadersForBigNumbers(paxHeaders, entry);\n        } else if (bigNumberMode != BIGNUMBER_STAR) {\n            failForBigNumbers(entry);\n        }\n\n        if (addPaxHeadersForNonAsciiNames && !paxHeaderContainsPath\n            && !ASCII.canEncode(entryName)) {\n            paxHeaders.put(\"path\", entryName);\n        }\n\n        if (addPaxHeadersForNonAsciiNames && !paxHeaderContainsLinkPath\n            && (entry.isLink() || entry.isSymbolicLink())\n            && !ASCII.canEncode(linkName)) {\n            paxHeaders.put(\"linkpath\", linkName);\n        }\n\n        if (paxHeaders.size() > 0) {\n            writePaxHeaders(entry, entryName, paxHeaders);\n        }\n\n        entry.writeEntryHeader(recordBuf, zipEncoding,\n                               bigNumberMode == BIGNUMBER_STAR);\n        writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entryName;\n        haveUnclosedEntry = true;\n    }\n\n    \n    @Override\n    public void closeArchiveEntry() throws IOException {\n        if (finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        if (!haveUnclosedEntry){\n            throw new IOException(\"No current entry to close\");\n        }\n        if (assemLen > 0) {\n            for (int i = assemLen; i < assemBuf.length; ++i) {\n                assemBuf[i] = 0;\n            }\n\n            writeRecord(assemBuf);\n\n            currBytes += assemLen;\n            assemLen = 0;\n        }\n\n        if (currBytes < currSize) {\n            throw new IOException(\"entry '\" + currName + \"' closed at '\"\n                                  + currBytes\n                                  + \"' before the '\" + currSize\n                                  + \"' bytes specified in the header were written\");\n        }\n        haveUnclosedEntry = false;\n    }\n\n    \n    @Override\n    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n        if (!haveUnclosedEntry) {\n            throw new IllegalStateException(\"No current tar entry\");\n        }\n        if (currBytes + numToWrite > currSize) {\n            throw new IOException(\"request to write '\" + numToWrite\n                                  + \"' bytes exceeds size in header of '\"\n                                  + currSize + \"' bytes for entry '\"\n                                  + currName + \"'\");\n\n            \n            \n            \n            \n            \n            \n            \n        }\n\n        if (assemLen > 0) {\n            if (assemLen + numToWrite >= recordBuf.length) {\n                int aLen = recordBuf.length - assemLen;\n\n                System.arraycopy(assemBuf, 0, recordBuf, 0,\n                                 assemLen);\n                System.arraycopy(wBuf, wOffset, recordBuf,\n                                 assemLen, aLen);\n                writeRecord(recordBuf);\n\n                currBytes += recordBuf.length;\n                wOffset += aLen;\n                numToWrite -= aLen;\n                assemLen = 0;\n            } else {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                wOffset += numToWrite;\n                assemLen += numToWrite;\n                numToWrite = 0;\n            }\n        }\n\n        \n        \n        \n        \n        \n        while (numToWrite > 0) {\n            if (numToWrite < recordBuf.length) {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                assemLen += numToWrite;\n\n                break;\n            }\n\n            writeRecord(wBuf, wOffset);\n\n            int num = recordBuf.length;\n\n            currBytes += num;\n            numToWrite -= num;\n            wOffset += num;\n        }\n    }\n\n    \n    void writePaxHeaders(TarArchiveEntry entry,\n                         String entryName,\n                         Map<String, String> headers) throws IOException {\n        String name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n        if (name.length() >= TarConstants.NAMELEN) {\n            name = name.substring(0, TarConstants.NAMELEN - 1);\n        }\n        TarArchiveEntry pex = new TarArchiveEntry(name,\n                                                  TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n        transferModTime(entry, pex);\n\n        StringWriter w = new StringWriter();\n        for (Map.Entry<String, String> h : headers.entrySet()) {\n            String key = h.getKey();\n            String value = h.getValue();\n            int len = key.length() + value.length()\n                + 3 \n                + 2 ;\n            String line = len + \" \" + key + \"=\" + value + \"\\n\";\n            int actualLength = line.getBytes(CharsetNames.UTF_8).length;\n            while (len != actualLength) {\n                \n                \n                \n                \n                \n                len = actualLength;\n                line = len + \" \" + key + \"=\" + value + \"\\n\";\n                actualLength = line.getBytes(CharsetNames.UTF_8).length;\n            }\n            w.write(line);\n        }\n        byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n        pex.setSize(data.length);\n        putArchiveEntry(pex);\n        write(data);\n        closeArchiveEntry();\n    }\n\n    private String stripTo7Bits(String name) {\n        final int length = name.length();\n        StringBuilder result = new StringBuilder(length);\n        for (int i = 0; i < length; i++) {\n            char stripped = (char) (name.charAt(i) & 0x7F);\n            if (shouldBeReplaced(stripped)) {\n                result.append(\"_\");\n            } else {\n                result.append(stripped);\n            }\n        }\n        return result.toString();\n    }\n\n    \n    private boolean shouldBeReplaced(char c) {\n        return c == 0 \n            || c == '/' \n            || c == '\\\\'; \n    }\n\n    \n    private void writeEOFRecord() throws IOException {\n        Arrays.fill(recordBuf, (byte) 0);\n        writeRecord(recordBuf);\n    }\n\n    @Override\n    public void flush() throws IOException {\n        out.flush();\n    }\n\n    @Override\n    public ArchiveEntry createArchiveEntry(File inputFile, String entryName) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        return new TarArchiveEntry(inputFile, entryName);\n    }\n    \n    \n    private void writeRecord(byte[] record) throws IOException {\n        if (record.length != recordSize) {\n            throw new IOException(\"record to write has length '\"\n                                  + record.length\n                                  + \"' which is not the record size of '\"\n                                  + recordSize + \"'\");\n        }\n\n        out.write(record);\n        recordsWritten++;\n    }\n    \n    \n    private void writeRecord(byte[] buf, int offset) throws IOException {\n \n        if (offset + recordSize > buf.length) {\n            throw new IOException(\"record has length '\" + buf.length\n                                  + \"' with offset '\" + offset\n                                  + \"' which is less than the record size of '\"\n                                  + recordSize + \"'\");\n        }\n\n        out.write(buf, offset, recordSize);\n        recordsWritten++;\n    }\n\n    private void padAsNeeded() throws IOException {\n        int start = recordsWritten % recordsPerBlock;\n        if (start != 0) {\n            for (int i = start; i < recordsPerBlock; i++) {\n                writeEOFRecord();\n            }\n        }\n    }\n\n    private void addPaxHeadersForBigNumbers(Map<String, String> paxHeaders, TarArchiveEntry entry) {\n        addPaxHeaderForBigNumber(paxHeaders, \"size\", entry.getSize(),\n                                 TarConstants.MAXSIZE);\n        addPaxHeaderForBigNumber(paxHeaders, \"gid\", entry.getGroupId(),\n                                 TarConstants.MAXID);\n        addPaxHeaderForBigNumber(paxHeaders, \"mtime\",\n                                 entry.getModTime().getTime() / 1000,\n                                 TarConstants.MAXSIZE);\n        addPaxHeaderForBigNumber(paxHeaders, \"uid\", entry.getUserId(),\n                                 TarConstants.MAXID);\n        \n        addPaxHeaderForBigNumber(paxHeaders, \"SCHILY.devmajor\",\n                                 entry.getDevMajor(), TarConstants.MAXID);\n        addPaxHeaderForBigNumber(paxHeaders, \"SCHILY.devminor\",\n                                 entry.getDevMinor(), TarConstants.MAXID);\n        \n        failForBigNumber(\"mode\", entry.getMode(), TarConstants.MAXID);\n    }\n\n    private void addPaxHeaderForBigNumber(Map<String, String> paxHeaders, String header, long value, long maxValue) {\n        if (value < 0 || value > maxValue) {\n            paxHeaders.put(header, String.valueOf(value));\n        }\n    }\n\n    private void failForBigNumbers(TarArchiveEntry entry) {\n        failForBigNumber(\"entry size\", entry.getSize(), TarConstants.MAXSIZE);\n        failForBigNumberWithPosixMessage(\"group id\", entry.getGroupId(), TarConstants.MAXID);\n        failForBigNumber(\"last modification time\",\n                         entry.getModTime().getTime() / 1000,\n                         TarConstants.MAXSIZE);\n        failForBigNumber(\"user id\", entry.getUserId(), TarConstants.MAXID);\n        failForBigNumber(\"mode\", entry.getMode(), TarConstants.MAXID);\n        failForBigNumber(\"major device number\", entry.getDevMajor(),\n                         TarConstants.MAXID);\n        failForBigNumber(\"minor device number\", entry.getDevMinor(),\n                         TarConstants.MAXID);\n    }\n\n    private void failForBigNumber(String field, long value, long maxValue) {\n        failForBigNumber(field, value, maxValue, \"\");\n    }\n\n    private void failForBigNumberWithPosixMessage(String field, long value, long maxValue) {\n        failForBigNumber(field, value, maxValue, \" Use STAR or POSIX extensions to overcome this limit\");\n    }\n\n    private void failForBigNumber(String field, long value, long maxValue, String additionalMsg) {\n        if (value < 0 || value > maxValue) {\n            throw new RuntimeException(field + \" '\" + value\n                    + \"' is too big ( > \"\n                    + maxValue + \" ).\" + additionalMsg);\n        }\n    }\n\n    \n    private boolean handleLongName(TarArchiveEntry entry , String name, Map<String, String> paxHeaders, String paxHeaderName, byte linkType, String fieldName) throws IOException {\n        final ByteBuffer encodedName = zipEncoding.encode(name);\n        final int len = encodedName.limit() - encodedName.position();\n        if (len >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_POSIX) {\n                paxHeaders.put(paxHeaderName, name);\n                return true;\n            } else if (longFileMode == LONGFILE_GNU) {\n                \n                \n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK, linkType);\n\n                longLinkEntry.setSize(len + 1); \n                transferModTime(entry, longLinkEntry);\n                putArchiveEntry(longLinkEntry);\n                write(encodedName.array(), encodedName.arrayOffset(), len);\n                write(0); \n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(fieldName + \" '\" + name\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n        return false;\n    }\n\n    private void transferModTime(TarArchiveEntry from, TarArchiveEntry to) {\n        Date fromModTime = from.getModTime();\n        long fromModTimeSeconds = fromModTime.getTime() / 1000;\n        if (fromModTimeSeconds < 0 || fromModTimeSeconds > TarConstants.MAXSIZE) {\n            fromModTime = new Date(0);\n        }\n        to.setModTime(fromModTime);\n    }\n}\n",
      "buggy_signatures": [
        "public TarArchiveOutputStream(OutputStream os, String encoding)",
        "public TarArchiveOutputStream(OutputStream os, int blockSize)",
        "public TarArchiveOutputStream(OutputStream os, int blockSize, String encoding)",
        "public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize)",
        "public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding)",
        "public void setLongFileMode(int longFileMode)",
        "public void setBigNumberMode(int bigNumberMode)",
        "public void setAddPaxHeadersForNonAsciiNames(boolean b)",
        "public int getCount()",
        "public long getBytesWritten()",
        "public void finish() throws IOException",
        "public void close() throws IOException",
        "public int getRecordSize()",
        "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException",
        "public void closeArchiveEntry() throws IOException",
        "public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException",
        "private String stripTo7Bits(String name)",
        "private boolean shouldBeReplaced(char c)",
        "private void writeEOFRecord() throws IOException",
        "public void flush() throws IOException",
        "public ArchiveEntry createArchiveEntry(File inputFile, String entryName) throws IOException",
        "private void writeRecord(byte[] record) throws IOException",
        "private void writeRecord(byte[] buf, int offset) throws IOException",
        "private void padAsNeeded() throws IOException",
        "private void addPaxHeadersForBigNumbers(Map<String, String> paxHeaders, TarArchiveEntry entry)",
        "private void addPaxHeaderForBigNumber(Map<String, String> paxHeaders, String header, long value, long maxValue)",
        "private void failForBigNumbers(TarArchiveEntry entry)",
        "private void failForBigNumber(String field, long value, long maxValue)",
        "private void failForBigNumberWithPosixMessage(String field, long value, long maxValue)",
        "private void failForBigNumber(String field, long value, long maxValue, String additionalMsg)",
        "private boolean handleLongName(TarArchiveEntry entry , String name, Map<String, String> paxHeaders, String paxHeaderName, byte linkType, String fieldName) throws IOException",
        "private void transferModTime(TarArchiveEntry from, TarArchiveEntry to)"
      ],
      "fixed_signatures": [
        "public TarArchiveOutputStream(OutputStream os, String encoding)",
        "public TarArchiveOutputStream(OutputStream os, int blockSize)",
        "public TarArchiveOutputStream(OutputStream os, int blockSize, String encoding)",
        "public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize)",
        "public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding)",
        "public void setLongFileMode(int longFileMode)",
        "public void setBigNumberMode(int bigNumberMode)",
        "public void setAddPaxHeadersForNonAsciiNames(boolean b)",
        "public int getCount()",
        "public long getBytesWritten()",
        "public void finish() throws IOException",
        "public void close() throws IOException",
        "public int getRecordSize()",
        "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException",
        "public void closeArchiveEntry() throws IOException",
        "public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException",
        "private String stripTo7Bits(String name)",
        "private boolean shouldBeReplaced(char c)",
        "private void writeEOFRecord() throws IOException",
        "public void flush() throws IOException",
        "public ArchiveEntry createArchiveEntry(File inputFile, String entryName) throws IOException",
        "private void writeRecord(byte[] record) throws IOException",
        "private void writeRecord(byte[] buf, int offset) throws IOException",
        "private void padAsNeeded() throws IOException",
        "private void addPaxHeadersForBigNumbers(Map<String, String> paxHeaders, TarArchiveEntry entry)",
        "private void addPaxHeaderForBigNumber(Map<String, String> paxHeaders, String header, long value, long maxValue)",
        "private void failForBigNumbers(TarArchiveEntry entry)",
        "private void failForBigNumber(String field, long value, long maxValue)",
        "private void failForBigNumberWithPosixMessage(String field, long value, long maxValue)",
        "private void failForBigNumber(String field, long value, long maxValue, String additionalMsg)",
        "private boolean handleLongName(TarArchiveEntry entry , String name, Map<String, String> paxHeaders, String paxHeaderName, byte linkType, String fieldName) throws IOException",
        "private void transferModTime(TarArchiveEntry from, TarArchiveEntry to)"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -87,6 +87,7 @@",
            "     private final ZipEncoding zipEncoding;\n",
            " \n",
            "     // the provided encoding (for unit tests)\n",
            "+    final String encoding;\n",
            " \n",
            "     private boolean addPaxHeadersForNonAsciiNames = false;\n",
            "     private static final ZipEncoding ASCII =\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n  out = new CountingOutputStream(os);\n  this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n\n  this.assemLen = 0;\n  this.assemBuf = new byte[recordSize];\n  this.recordBuf = new byte[recordSize];\n  this.recordSize = recordSize;\n  this.recordsPerBlock = blockSize / recordSize;\n  }",
          "fixed_method": "  public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n  out = new CountingOutputStream(os);\n  this.encoding = encoding;\n  this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n\n  this.assemLen = 0;\n  this.assemBuf = new byte[recordSize];\n  this.recordBuf = new byte[recordSize];\n  this.recordSize = recordSize;\n  this.recordsPerBlock = blockSize / recordSize;\n  }",
          "diff": [
            "@@ -152,6 +153,7 @@",
            "     public TarArchiveOutputStream(OutputStream os, int blockSize,\n",
            "                                   int recordSize, String encoding) {\n",
            "         out = new CountingOutputStream(os);\n",
            "+        this.encoding = encoding;\n",
            "         this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n",
            " \n",
            "         this.assemLen = 0;\n"
          ],
          "changed_lines": 1
        }
      ]
    },
    {
      "name": "org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.zip;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PushbackInputStream;\nimport java.nio.ByteBuffer;\nimport java.util.zip.CRC32;\nimport java.util.zip.DataFormatException;\nimport java.util.zip.Inflater;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipException;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.utils.IOUtils;\n\nimport static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD; import static org.apache.commons.compress.archivers.zip.ZipConstants.SHORT; import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD; import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC; public class ZipArchiveInputStream extends ArchiveInputStream { private final ZipEncoding zipEncoding; private final boolean useUnicodeExtraFields; private final InputStream in; private final Inflater inf = new Inflater(true); private final ByteBuffer buf = ByteBuffer.allocate(ZipArchiveOutputStream.BUFFER_SIZE); private CurrentEntry current = null; private boolean closed = false; private boolean hitCentralDirectory = false; private ByteArrayInputStream lastStoredEntry = null; private boolean allowStoredEntriesWithDataDescriptor = false; private static final int LFH_LEN = 30; private static final int CFH_LEN = 46; private static final long TWO_EXP_32 = ZIP64_MAGIC + 1; private final byte[] LFH_BUF = new byte[LFH_LEN]; private final byte[] SKIP_BUF = new byte[1024]; private final byte[] SHORT_BUF = new byte[SHORT]; private final byte[] WORD_BUF = new byte[WORD]; private final byte[] TWO_DWORD_BUF = new byte[2 * DWORD]; private int entriesRead = 0; public ZipArchiveInputStream(InputStream inputStream) {\n        this(inputStream, ZipEncodingHelper.UTF8);\n    }\n\n    \n    public ZipArchiveInputStream(InputStream inputStream, String encoding) {\n        this(inputStream, encoding, true);\n    }\n\n    \n    public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields) {\n        this(inputStream, encoding, useUnicodeExtraFields, false);\n    }\n\n    \n    public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        in = new PushbackInputStream(inputStream, buf.capacity());\n        this.allowStoredEntriesWithDataDescriptor =\n            allowStoredEntriesWithDataDescriptor;\n        \n        buf.limit(0);\n    }\n\n    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        boolean firstEntry = true;\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n            firstEntry = false;\n        }\n\n        try {\n            if (firstEntry) {\n                \n                \n                \n                \n                readFirstLocalFileHeader(LFH_BUF);\n            } else {\n                readFully(LFH_BUF);\n            }\n        } catch (EOFException e) {\n            return null;\n        }\n\n        ZipLong sig = new ZipLong(LFH_BUF);\n        if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n            hitCentralDirectory = true;\n            skipRemainderOfArchive();\n        }\n        if (!sig.equals(ZipLong.LFH_SIG)) {\n            return null;\n        }\n\n        int off = WORD;\n        current = new CurrentEntry();\n\n        int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n        current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n\n        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n        current.entry.setGeneralPurposeBit(gpFlag);\n\n        off += SHORT;\n\n        current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\n        off += SHORT;\n\n        long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\n        current.entry.setTime(time);\n        off += WORD;\n\n        ZipLong size = null, cSize = null;\n        if (!current.hasDataDescriptor) {\n            current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\n            off += WORD;\n\n            cSize = new ZipLong(LFH_BUF, off);\n            off += WORD;\n\n            size = new ZipLong(LFH_BUF, off);\n            off += WORD;\n        } else {\n            off += 3 * WORD;\n        }\n\n        int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n\n        off += SHORT;\n\n        int extraLen = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n\n        byte[] fileName = new byte[fileNameLen];\n        readFully(fileName);\n        current.entry.setName(entryEncoding.decode(fileName), fileName);\n\n        byte[] extraData = new byte[extraLen];\n        readFully(extraData);\n        current.entry.setExtra(extraData);\n\n        if (!hasUTF8Flag && useUnicodeExtraFields) {\n            ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n        }\n\n        processZip64Extra(size, cSize);\n\n        if (current.entry.getCompressedSize() != ZipArchiveEntry.SIZE_UNKNOWN) {\n            if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n                current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n            } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n                current.in = new ExplodingInputStream(\n                        current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n                        current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n                        new BoundedInputStream(in, current.entry.getCompressedSize()));\n            }\n        }\n        \n        entriesRead++;\n        return current.entry;\n    }\n\n    \n    private void readFirstLocalFileHeader(byte[] lfh) throws IOException {\n        readFully(lfh);\n        ZipLong sig = new ZipLong(lfh);\n        if (sig.equals(ZipLong.DD_SIG)) {\n            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.SPLITTING);\n        }\n\n        if (sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER)) {\n            \n            \n            byte[] missedLfhBytes = new byte[4];\n            readFully(missedLfhBytes);\n            System.arraycopy(lfh, 4, lfh, 0, LFH_LEN - 4);\n            System.arraycopy(missedLfhBytes, 0, lfh, LFH_LEN - 4, 4);\n        }\n    }\n\n    \n    private void processZip64Extra(ZipLong size, ZipLong cSize) {\n        Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField) \n            current.entry.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        current.usesZip64 = z64 != null;\n        if (!current.hasDataDescriptor) {\n            if (z64 != null \n                    && (cSize.equals(ZipLong.ZIP64_MAGIC) || size.equals(ZipLong.ZIP64_MAGIC)) ) {\n                current.entry.setCompressedSize(z64.getCompressedSize().getLongValue());\n                current.entry.setSize(z64.getSize().getLongValue());\n            } else {\n                current.entry.setCompressedSize(cSize.getValue());\n                current.entry.setSize(size.getValue());\n            }\n        }\n    }\n\n    @Override\n    public ArchiveEntry getNextEntry() throws IOException {\n        return getNextZipEntry();\n    }\n\n    \n    @Override\n    public boolean canReadEntryData(ArchiveEntry ae) {\n        if (ae instanceof ZipArchiveEntry) {\n            ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n            return ZipUtil.canHandleEntryData(ze)\n                && supportsDataDescriptorFor(ze);\n\n        }\n        return false;\n    }\n\n    @Override\n    public int read(byte[] buffer, int offset, int length) throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n\n        if (current == null) {\n            return -1;\n        }\n\n        \n        if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n        \n        ZipUtil.checkRequestedFeatures(current.entry);\n        if (!supportsDataDescriptorFor(current.entry)) {\n            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR,\n                    current.entry);\n        }\n\n        int read;\n        if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n            read = readStored(buffer, offset, length);\n        } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n            read = readDeflated(buffer, offset, length);\n        } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()\n                || current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n            read = current.in.read(buffer, offset, length);\n        } else {\n            throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()),\n                    current.entry);\n        }\n        \n        if (read >= 0) {\n            current.crc.update(buffer, offset, read);\n        }\n        \n        return read;\n    }\n\n    \n    private int readStored(byte[] buffer, int offset, int length) throws IOException {\n\n        if (current.hasDataDescriptor) {\n            if (lastStoredEntry == null) {\n                readStoredEntry();\n            }\n            return lastStoredEntry.read(buffer, offset, length);\n        }\n\n        long csize = current.entry.getSize();\n        if (current.bytesRead >= csize) {\n            return -1;\n        }\n\n        if (buf.position() >= buf.limit()) {\n            buf.position(0);\n            int l = in.read(buf.array());\n            if (l == -1) {\n                return -1;\n            }\n            buf.limit(l);\n\n            count(l);\n            current.bytesReadFromStream += l;\n        }\n\n        int toRead = Math.min(buf.remaining(), length);\n        if ((csize - current.bytesRead) < toRead) {\n            \n            toRead = (int) (csize - current.bytesRead);\n        }\n        buf.get(buffer, offset, toRead);\n        current.bytesRead += toRead;\n        return toRead;\n    }\n\n    \n    private int readDeflated(byte[] buffer, int offset, int length) throws IOException {\n        int read = readFromInflater(buffer, offset, length);\n        if (read <= 0) {\n            if (inf.finished()) {\n                return -1;\n            } else if (inf.needsDictionary()) {\n                throw new ZipException(\"This archive needs a preset dictionary\"\n                                       + \" which is not supported by Commons\"\n                                       + \" Compress.\");\n            } else if (read == -1) {\n                throw new IOException(\"Truncated ZIP file\");\n            }\n        }\n        return read;\n    }\n\n    \n    private int readFromInflater(byte[] buffer, int offset, int length) throws IOException {\n        int read = 0;\n        do {\n            if (inf.needsInput()) {\n                int l = fill();\n                if (l > 0) {\n                    current.bytesReadFromStream += buf.limit();\n                } else if (l == -1) {\n                    return -1;\n                } else {\n                    break;\n                }\n            }\n            try {\n                read = inf.inflate(buffer, offset, length);\n            } catch (DataFormatException e) {\n                throw (IOException) new ZipException(e.getMessage()).initCause(e);\n            }\n        } while (read == 0 && inf.needsInput());\n        return read;\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (!closed) {\n            closed = true;\n            in.close();\n            inf.end();\n        }\n    }\n\n    \n    @Override\n    public long skip(long value) throws IOException {\n        if (value >= 0) {\n            long skipped = 0;\n            while (skipped < value) {\n                long rem = value - skipped;\n                int x = read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));\n                if (x == -1) {\n                    return skipped;\n                }\n                skipped += x;\n            }\n            return skipped;\n        }\n        throw new IllegalArgumentException();\n    }\n\n    \n    public static boolean matches(byte[] signature, int length) {\n        if (length < ZipArchiveOutputStream.LFH_SIG.length) {\n            return false;\n        }\n\n        return checksig(signature, ZipArchiveOutputStream.LFH_SIG) \n            || checksig(signature, ZipArchiveOutputStream.EOCD_SIG) \n            || checksig(signature, ZipArchiveOutputStream.DD_SIG) \n            || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());\n    }\n\n    private static boolean checksig(byte[] signature, byte[] expected) {\n        for (int i = 0; i < expected.length; i++) {\n            if (signature[i] != expected[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    private void closeEntry() throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        if (current == null) {\n            return;\n        }\n\n        \n        if (current.bytesReadFromStream <= current.entry.getCompressedSize()\n                && !current.hasDataDescriptor) {\n            drainCurrentEntryData();\n        } else {\n            skip(Long.MAX_VALUE);\n\n            long inB = current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED\n                       ? getBytesInflated() : current.bytesRead;\n\n            \n            \n            int diff = (int) (current.bytesReadFromStream - inB);\n\n            \n            if (diff > 0) {\n                pushback(buf.array(), buf.limit() - diff, diff);\n            }\n        }\n\n        if (lastStoredEntry == null && current.hasDataDescriptor) {\n            readDataDescriptor();\n        }\n\n        inf.reset();\n        buf.clear().flip();\n        current = null;\n        lastStoredEntry = null;\n    }\n\n    \n    private void drainCurrentEntryData() throws IOException {\n        long remaining = current.entry.getCompressedSize() - current.bytesReadFromStream;\n        while (remaining > 0) {\n            long n = in.read(buf.array(), 0, (int) Math.min(buf.capacity(), remaining));\n            if (n < 0) {\n                throw new EOFException(\"Truncated ZIP entry: \" + current.entry.getName());\n            } else {\n                count(n);\n                remaining -= n;\n            }\n        }\n    }\n\n    \n    private long getBytesInflated() {\n        long inB = inf.getBytesRead();\n        if (current.bytesReadFromStream >= TWO_EXP_32) {\n            while (inB + TWO_EXP_32 <= current.bytesReadFromStream) {\n                inB += TWO_EXP_32;\n            }\n        }\n        return inB;\n    }\n\n    private int fill() throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        int length = in.read(buf.array());\n        if (length > 0) {\n            buf.limit(length);\n            count(buf.limit());\n            inf.setInput(buf.array(), 0, buf.limit());\n        }\n        return length;\n    }\n\n    private void readFully(byte[] b) throws IOException {\n        int count = IOUtils.readFully(in, b);\n        count(count);\n        if (count < b.length) {\n            throw new EOFException();\n        }\n    }\n\n    private void readDataDescriptor() throws IOException {\n        readFully(WORD_BUF);\n        ZipLong val = new ZipLong(WORD_BUF);\n        if (ZipLong.DD_SIG.equals(val)) {\n            \n            readFully(WORD_BUF);\n            val = new ZipLong(WORD_BUF);\n        }\n        current.entry.setCrc(val.getValue());\n\n        \n        \n        \n        \n        \n\n        \n        \n        \n        \n        \n        readFully(TWO_DWORD_BUF);\n        ZipLong potentialSig = new ZipLong(TWO_DWORD_BUF, DWORD);\n        if (potentialSig.equals(ZipLong.CFH_SIG) || potentialSig.equals(ZipLong.LFH_SIG)) {\n            pushback(TWO_DWORD_BUF, DWORD, DWORD);\n            current.entry.setCompressedSize(ZipLong.getValue(TWO_DWORD_BUF));\n            current.entry.setSize(ZipLong.getValue(TWO_DWORD_BUF, WORD));\n        } else {\n            current.entry.setCompressedSize(ZipEightByteInteger.getLongValue(TWO_DWORD_BUF));\n            current.entry.setSize(ZipEightByteInteger.getLongValue(TWO_DWORD_BUF, DWORD));\n        }\n    }\n\n    \n    private boolean supportsDataDescriptorFor(ZipArchiveEntry entry) {\n        return !entry.getGeneralPurposeBit().usesDataDescriptor()\n\n                || (allowStoredEntriesWithDataDescriptor && entry.getMethod() == ZipEntry.STORED)\n                || entry.getMethod() == ZipEntry.DEFLATED;\n    }\n\n    \n    private void readStoredEntry() throws IOException {\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        int off = 0;\n        boolean done = false;\n\n        \n        int ddLen = current.usesZip64 ? WORD + 2 * DWORD : 3 * WORD;\n\n        while (!done) {\n            int r = in.read(buf.array(), off, ZipArchiveOutputStream.BUFFER_SIZE - off);\n            if (r <= 0) {\n                \n                \n                throw new IOException(\"Truncated ZIP file\");\n            }\n            if (r + off < 4) {\n                \n                off += r;\n                continue;\n            }\n\n            done = bufferContainsSignature(bos, off, r, ddLen);\n            if (!done) {\n                off = cacheBytesRead(bos, off, r, ddLen);\n            }\n        }\n\n        byte[] b = bos.toByteArray();\n        lastStoredEntry = new ByteArrayInputStream(b);\n    }\n\n    private static final byte[] LFH = ZipLong.LFH_SIG.getBytes(); private static final byte[] CFH = ZipLong.CFH_SIG.getBytes(); private static final byte[] DD = ZipLong.DD_SIG.getBytes(); private boolean bufferContainsSignature(ByteArrayOutputStream bos, int offset, int lastRead, int expectedDDLen) throws IOException {\n\n        boolean done = false;\n        int readTooMuch = 0;\n        for (int i = 0; !done && i < lastRead - 4; i++) {\n            if (buf.array()[i] == LFH[0] && buf.array()[i + 1] == LFH[1]) {\n                if ((buf.array()[i + 2] == LFH[2] && buf.array()[i + 3] == LFH[3])\n                    || (buf.array()[i] == CFH[2] && buf.array()[i + 3] == CFH[3])) {\n                    \n                    readTooMuch = offset + lastRead - i - expectedDDLen;\n                    done = true;\n                }\n                else if (buf.array()[i + 2] == DD[2] && buf.array()[i + 3] == DD[3]) {\n                    \n                    readTooMuch = offset + lastRead - i;\n                    done = true;\n                }\n                if (done) {\n                    \n                    \n                    \n                    \n                    pushback(buf.array(), offset + lastRead - readTooMuch, readTooMuch);\n                    bos.write(buf.array(), 0, i);\n                    readDataDescriptor();\n                }\n            }\n        }\n        return done;\n    }\n\n    \n    private int cacheBytesRead(ByteArrayOutputStream bos, int offset, int lastRead, int expecteDDLen) {\n        final int cacheable = offset + lastRead - expecteDDLen - 3;\n        if (cacheable > 0) {\n            bos.write(buf.array(), 0, cacheable);\n            System.arraycopy(buf.array(), cacheable, buf.array(), 0, expecteDDLen + 3);\n            offset = expecteDDLen + 3;\n        } else {\n            offset += lastRead;\n        }\n        return offset;\n    }\n\n    private void pushback(byte[] buf, int offset, int length) throws IOException {\n        ((PushbackInputStream) in).unread(buf, offset, length);\n        pushedBackBytes(length);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    private void skipRemainderOfArchive() throws IOException {\n        \n        \n        \n        realSkip(entriesRead * CFH_LEN - LFH_LEN);\n        findEocdRecord();\n        realSkip(ZipFile.MIN_EOCD_SIZE - WORD  - SHORT );\n        readFully(SHORT_BUF);\n        \n        realSkip(ZipShort.getValue(SHORT_BUF));\n    }\n\n    \n    private void findEocdRecord() throws IOException {\n        int currentByte = -1;\n        boolean skipReadCall = false;\n        while (skipReadCall || (currentByte = readOneByte()) > -1) {\n            skipReadCall = false;\n            if (!isFirstByteOfEocdSig(currentByte)) {\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[1]) {\n                if (currentByte == -1) {\n                    break;\n                }\n                skipReadCall = isFirstByteOfEocdSig(currentByte);\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[2]) {\n                if (currentByte == -1) {\n                    break;\n                }\n                skipReadCall = isFirstByteOfEocdSig(currentByte);\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte == -1\n                || currentByte == ZipArchiveOutputStream.EOCD_SIG[3]) {\n                break;\n            }\n            skipReadCall = isFirstByteOfEocdSig(currentByte);\n        }\n    }\n\n    \n    private void realSkip(long value) throws IOException {\n        if (value >= 0) {\n            long skipped = 0;\n            while (skipped < value) {\n                long rem = value - skipped;\n                int x = in.read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));\n                if (x == -1) {\n                    return;\n                }\n                count(x);\n                skipped += x;\n            }\n            return;\n        }\n        throw new IllegalArgumentException();\n    }\n\n    \n    private int readOneByte() throws IOException {\n        int b = in.read();\n        if (b != -1) {\n            count(1);\n        }\n        return b;\n    }\n\n    private boolean isFirstByteOfEocdSig(int b) {\n        return b == ZipArchiveOutputStream.EOCD_SIG[0];\n    }\n\n    \n    private static final class CurrentEntry { private final ZipArchiveEntry entry = new ZipArchiveEntry(); private boolean hasDataDescriptor; private boolean usesZip64; private long bytesRead; private long bytesReadFromStream; private final CRC32 crc = new CRC32(); private InputStream in; } private class BoundedInputStream extends InputStream {\n\n        \n        private final InputStream in; private final long max; private long pos = 0; public BoundedInputStream(final InputStream in, final long size) {\n            this.max = size;\n            this.in = in;\n        }\n\n        @Override\n        public int read() throws IOException {\n            if (max >= 0 && pos >= max) {\n                return -1;\n            }\n            final int result = in.read();\n            pos++;\n            count(1);\n            current.bytesReadFromStream++;\n            return result;\n        }\n\n        @Override\n        public int read(final byte[] b) throws IOException {\n            return this.read(b, 0, b.length);\n        }\n\n        @Override\n        public int read(final byte[] b, final int off, final int len) throws IOException {\n            if (max >= 0 && pos >= max) {\n                return -1;\n            }\n            final long maxRead = max >= 0 ? Math.min(len, max - pos) : len;\n            final int bytesRead = in.read(b, off, (int) maxRead);\n\n            if (bytesRead == -1) {\n                return -1;\n            }\n\n            pos += bytesRead;\n            count(bytesRead);\n            current.bytesReadFromStream += bytesRead;\n            return bytesRead;\n        }\n\n        @Override\n        public long skip(final long n) throws IOException {\n            final long toSkip = max >= 0 ? Math.min(n, max - pos) : n;\n            final long skippedBytes = in.skip(toSkip);\n            pos += skippedBytes;\n            return skippedBytes;\n        }\n    \n        @Override\n        public int available() throws IOException {\n            if (max >= 0 && pos >= max) {\n                return 0;\n            }\n            return in.available();\n        }\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.zip;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PushbackInputStream;\nimport java.nio.ByteBuffer;\nimport java.util.zip.CRC32;\nimport java.util.zip.DataFormatException;\nimport java.util.zip.Inflater;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipException;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.utils.IOUtils;\n\nimport static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD; import static org.apache.commons.compress.archivers.zip.ZipConstants.SHORT; import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD; import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC; public class ZipArchiveInputStream extends ArchiveInputStream { private final ZipEncoding zipEncoding; final String encoding; private final boolean useUnicodeExtraFields; private final InputStream in; private final Inflater inf = new Inflater(true); private final ByteBuffer buf = ByteBuffer.allocate(ZipArchiveOutputStream.BUFFER_SIZE); private CurrentEntry current = null; private boolean closed = false; private boolean hitCentralDirectory = false; private ByteArrayInputStream lastStoredEntry = null; private boolean allowStoredEntriesWithDataDescriptor = false; private static final int LFH_LEN = 30; private static final int CFH_LEN = 46; private static final long TWO_EXP_32 = ZIP64_MAGIC + 1; private final byte[] LFH_BUF = new byte[LFH_LEN]; private final byte[] SKIP_BUF = new byte[1024]; private final byte[] SHORT_BUF = new byte[SHORT]; private final byte[] WORD_BUF = new byte[WORD]; private final byte[] TWO_DWORD_BUF = new byte[2 * DWORD]; private int entriesRead = 0; public ZipArchiveInputStream(InputStream inputStream) {\n        this(inputStream, ZipEncodingHelper.UTF8);\n    }\n\n    \n    public ZipArchiveInputStream(InputStream inputStream, String encoding) {\n        this(inputStream, encoding, true);\n    }\n\n    \n    public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields) {\n        this(inputStream, encoding, useUnicodeExtraFields, false);\n    }\n\n    \n    public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n        this.encoding = encoding;\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        in = new PushbackInputStream(inputStream, buf.capacity());\n        this.allowStoredEntriesWithDataDescriptor =\n            allowStoredEntriesWithDataDescriptor;\n        \n        buf.limit(0);\n    }\n\n    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        boolean firstEntry = true;\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n            firstEntry = false;\n        }\n\n        try {\n            if (firstEntry) {\n                \n                \n                \n                \n                readFirstLocalFileHeader(LFH_BUF);\n            } else {\n                readFully(LFH_BUF);\n            }\n        } catch (EOFException e) {\n            return null;\n        }\n\n        ZipLong sig = new ZipLong(LFH_BUF);\n        if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n            hitCentralDirectory = true;\n            skipRemainderOfArchive();\n        }\n        if (!sig.equals(ZipLong.LFH_SIG)) {\n            return null;\n        }\n\n        int off = WORD;\n        current = new CurrentEntry();\n\n        int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n        current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n\n        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n        current.entry.setGeneralPurposeBit(gpFlag);\n\n        off += SHORT;\n\n        current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\n        off += SHORT;\n\n        long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\n        current.entry.setTime(time);\n        off += WORD;\n\n        ZipLong size = null, cSize = null;\n        if (!current.hasDataDescriptor) {\n            current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\n            off += WORD;\n\n            cSize = new ZipLong(LFH_BUF, off);\n            off += WORD;\n\n            size = new ZipLong(LFH_BUF, off);\n            off += WORD;\n        } else {\n            off += 3 * WORD;\n        }\n\n        int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n\n        off += SHORT;\n\n        int extraLen = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n\n        byte[] fileName = new byte[fileNameLen];\n        readFully(fileName);\n        current.entry.setName(entryEncoding.decode(fileName), fileName);\n\n        byte[] extraData = new byte[extraLen];\n        readFully(extraData);\n        current.entry.setExtra(extraData);\n\n        if (!hasUTF8Flag && useUnicodeExtraFields) {\n            ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n        }\n\n        processZip64Extra(size, cSize);\n\n        if (current.entry.getCompressedSize() != ZipArchiveEntry.SIZE_UNKNOWN) {\n            if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n                current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n            } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n                current.in = new ExplodingInputStream(\n                        current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n                        current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n                        new BoundedInputStream(in, current.entry.getCompressedSize()));\n            }\n        }\n        \n        entriesRead++;\n        return current.entry;\n    }\n\n    \n    private void readFirstLocalFileHeader(byte[] lfh) throws IOException {\n        readFully(lfh);\n        ZipLong sig = new ZipLong(lfh);\n        if (sig.equals(ZipLong.DD_SIG)) {\n            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.SPLITTING);\n        }\n\n        if (sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER)) {\n            \n            \n            byte[] missedLfhBytes = new byte[4];\n            readFully(missedLfhBytes);\n            System.arraycopy(lfh, 4, lfh, 0, LFH_LEN - 4);\n            System.arraycopy(missedLfhBytes, 0, lfh, LFH_LEN - 4, 4);\n        }\n    }\n\n    \n    private void processZip64Extra(ZipLong size, ZipLong cSize) {\n        Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField) \n            current.entry.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        current.usesZip64 = z64 != null;\n        if (!current.hasDataDescriptor) {\n            if (z64 != null \n                    && (cSize.equals(ZipLong.ZIP64_MAGIC) || size.equals(ZipLong.ZIP64_MAGIC)) ) {\n                current.entry.setCompressedSize(z64.getCompressedSize().getLongValue());\n                current.entry.setSize(z64.getSize().getLongValue());\n            } else {\n                current.entry.setCompressedSize(cSize.getValue());\n                current.entry.setSize(size.getValue());\n            }\n        }\n    }\n\n    @Override\n    public ArchiveEntry getNextEntry() throws IOException {\n        return getNextZipEntry();\n    }\n\n    \n    @Override\n    public boolean canReadEntryData(ArchiveEntry ae) {\n        if (ae instanceof ZipArchiveEntry) {\n            ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n            return ZipUtil.canHandleEntryData(ze)\n                && supportsDataDescriptorFor(ze);\n\n        }\n        return false;\n    }\n\n    @Override\n    public int read(byte[] buffer, int offset, int length) throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n\n        if (current == null) {\n            return -1;\n        }\n\n        \n        if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n        \n        ZipUtil.checkRequestedFeatures(current.entry);\n        if (!supportsDataDescriptorFor(current.entry)) {\n            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR,\n                    current.entry);\n        }\n\n        int read;\n        if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n            read = readStored(buffer, offset, length);\n        } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n            read = readDeflated(buffer, offset, length);\n        } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()\n                || current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n            read = current.in.read(buffer, offset, length);\n        } else {\n            throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()),\n                    current.entry);\n        }\n        \n        if (read >= 0) {\n            current.crc.update(buffer, offset, read);\n        }\n        \n        return read;\n    }\n\n    \n    private int readStored(byte[] buffer, int offset, int length) throws IOException {\n\n        if (current.hasDataDescriptor) {\n            if (lastStoredEntry == null) {\n                readStoredEntry();\n            }\n            return lastStoredEntry.read(buffer, offset, length);\n        }\n\n        long csize = current.entry.getSize();\n        if (current.bytesRead >= csize) {\n            return -1;\n        }\n\n        if (buf.position() >= buf.limit()) {\n            buf.position(0);\n            int l = in.read(buf.array());\n            if (l == -1) {\n                return -1;\n            }\n            buf.limit(l);\n\n            count(l);\n            current.bytesReadFromStream += l;\n        }\n\n        int toRead = Math.min(buf.remaining(), length);\n        if ((csize - current.bytesRead) < toRead) {\n            \n            toRead = (int) (csize - current.bytesRead);\n        }\n        buf.get(buffer, offset, toRead);\n        current.bytesRead += toRead;\n        return toRead;\n    }\n\n    \n    private int readDeflated(byte[] buffer, int offset, int length) throws IOException {\n        int read = readFromInflater(buffer, offset, length);\n        if (read <= 0) {\n            if (inf.finished()) {\n                return -1;\n            } else if (inf.needsDictionary()) {\n                throw new ZipException(\"This archive needs a preset dictionary\"\n                                       + \" which is not supported by Commons\"\n                                       + \" Compress.\");\n            } else if (read == -1) {\n                throw new IOException(\"Truncated ZIP file\");\n            }\n        }\n        return read;\n    }\n\n    \n    private int readFromInflater(byte[] buffer, int offset, int length) throws IOException {\n        int read = 0;\n        do {\n            if (inf.needsInput()) {\n                int l = fill();\n                if (l > 0) {\n                    current.bytesReadFromStream += buf.limit();\n                } else if (l == -1) {\n                    return -1;\n                } else {\n                    break;\n                }\n            }\n            try {\n                read = inf.inflate(buffer, offset, length);\n            } catch (DataFormatException e) {\n                throw (IOException) new ZipException(e.getMessage()).initCause(e);\n            }\n        } while (read == 0 && inf.needsInput());\n        return read;\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (!closed) {\n            closed = true;\n            in.close();\n            inf.end();\n        }\n    }\n\n    \n    @Override\n    public long skip(long value) throws IOException {\n        if (value >= 0) {\n            long skipped = 0;\n            while (skipped < value) {\n                long rem = value - skipped;\n                int x = read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));\n                if (x == -1) {\n                    return skipped;\n                }\n                skipped += x;\n            }\n            return skipped;\n        }\n        throw new IllegalArgumentException();\n    }\n\n    \n    public static boolean matches(byte[] signature, int length) {\n        if (length < ZipArchiveOutputStream.LFH_SIG.length) {\n            return false;\n        }\n\n        return checksig(signature, ZipArchiveOutputStream.LFH_SIG) \n            || checksig(signature, ZipArchiveOutputStream.EOCD_SIG) \n            || checksig(signature, ZipArchiveOutputStream.DD_SIG) \n            || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());\n    }\n\n    private static boolean checksig(byte[] signature, byte[] expected) {\n        for (int i = 0; i < expected.length; i++) {\n            if (signature[i] != expected[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    private void closeEntry() throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        if (current == null) {\n            return;\n        }\n\n        \n        if (current.bytesReadFromStream <= current.entry.getCompressedSize()\n                && !current.hasDataDescriptor) {\n            drainCurrentEntryData();\n        } else {\n            skip(Long.MAX_VALUE);\n\n            long inB = current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED\n                       ? getBytesInflated() : current.bytesRead;\n\n            \n            \n            int diff = (int) (current.bytesReadFromStream - inB);\n\n            \n            if (diff > 0) {\n                pushback(buf.array(), buf.limit() - diff, diff);\n            }\n        }\n\n        if (lastStoredEntry == null && current.hasDataDescriptor) {\n            readDataDescriptor();\n        }\n\n        inf.reset();\n        buf.clear().flip();\n        current = null;\n        lastStoredEntry = null;\n    }\n\n    \n    private void drainCurrentEntryData() throws IOException {\n        long remaining = current.entry.getCompressedSize() - current.bytesReadFromStream;\n        while (remaining > 0) {\n            long n = in.read(buf.array(), 0, (int) Math.min(buf.capacity(), remaining));\n            if (n < 0) {\n                throw new EOFException(\"Truncated ZIP entry: \" + current.entry.getName());\n            } else {\n                count(n);\n                remaining -= n;\n            }\n        }\n    }\n\n    \n    private long getBytesInflated() {\n        long inB = inf.getBytesRead();\n        if (current.bytesReadFromStream >= TWO_EXP_32) {\n            while (inB + TWO_EXP_32 <= current.bytesReadFromStream) {\n                inB += TWO_EXP_32;\n            }\n        }\n        return inB;\n    }\n\n    private int fill() throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        int length = in.read(buf.array());\n        if (length > 0) {\n            buf.limit(length);\n            count(buf.limit());\n            inf.setInput(buf.array(), 0, buf.limit());\n        }\n        return length;\n    }\n\n    private void readFully(byte[] b) throws IOException {\n        int count = IOUtils.readFully(in, b);\n        count(count);\n        if (count < b.length) {\n            throw new EOFException();\n        }\n    }\n\n    private void readDataDescriptor() throws IOException {\n        readFully(WORD_BUF);\n        ZipLong val = new ZipLong(WORD_BUF);\n        if (ZipLong.DD_SIG.equals(val)) {\n            \n            readFully(WORD_BUF);\n            val = new ZipLong(WORD_BUF);\n        }\n        current.entry.setCrc(val.getValue());\n\n        \n        \n        \n        \n        \n\n        \n        \n        \n        \n        \n        readFully(TWO_DWORD_BUF);\n        ZipLong potentialSig = new ZipLong(TWO_DWORD_BUF, DWORD);\n        if (potentialSig.equals(ZipLong.CFH_SIG) || potentialSig.equals(ZipLong.LFH_SIG)) {\n            pushback(TWO_DWORD_BUF, DWORD, DWORD);\n            current.entry.setCompressedSize(ZipLong.getValue(TWO_DWORD_BUF));\n            current.entry.setSize(ZipLong.getValue(TWO_DWORD_BUF, WORD));\n        } else {\n            current.entry.setCompressedSize(ZipEightByteInteger.getLongValue(TWO_DWORD_BUF));\n            current.entry.setSize(ZipEightByteInteger.getLongValue(TWO_DWORD_BUF, DWORD));\n        }\n    }\n\n    \n    private boolean supportsDataDescriptorFor(ZipArchiveEntry entry) {\n        return !entry.getGeneralPurposeBit().usesDataDescriptor()\n\n                || (allowStoredEntriesWithDataDescriptor && entry.getMethod() == ZipEntry.STORED)\n                || entry.getMethod() == ZipEntry.DEFLATED;\n    }\n\n    \n    private void readStoredEntry() throws IOException {\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        int off = 0;\n        boolean done = false;\n\n        \n        int ddLen = current.usesZip64 ? WORD + 2 * DWORD : 3 * WORD;\n\n        while (!done) {\n            int r = in.read(buf.array(), off, ZipArchiveOutputStream.BUFFER_SIZE - off);\n            if (r <= 0) {\n                \n                \n                throw new IOException(\"Truncated ZIP file\");\n            }\n            if (r + off < 4) {\n                \n                off += r;\n                continue;\n            }\n\n            done = bufferContainsSignature(bos, off, r, ddLen);\n            if (!done) {\n                off = cacheBytesRead(bos, off, r, ddLen);\n            }\n        }\n\n        byte[] b = bos.toByteArray();\n        lastStoredEntry = new ByteArrayInputStream(b);\n    }\n\n    private static final byte[] LFH = ZipLong.LFH_SIG.getBytes(); private static final byte[] CFH = ZipLong.CFH_SIG.getBytes(); private static final byte[] DD = ZipLong.DD_SIG.getBytes(); private boolean bufferContainsSignature(ByteArrayOutputStream bos, int offset, int lastRead, int expectedDDLen) throws IOException {\n\n        boolean done = false;\n        int readTooMuch = 0;\n        for (int i = 0; !done && i < lastRead - 4; i++) {\n            if (buf.array()[i] == LFH[0] && buf.array()[i + 1] == LFH[1]) {\n                if ((buf.array()[i + 2] == LFH[2] && buf.array()[i + 3] == LFH[3])\n                    || (buf.array()[i] == CFH[2] && buf.array()[i + 3] == CFH[3])) {\n                    \n                    readTooMuch = offset + lastRead - i - expectedDDLen;\n                    done = true;\n                }\n                else if (buf.array()[i + 2] == DD[2] && buf.array()[i + 3] == DD[3]) {\n                    \n                    readTooMuch = offset + lastRead - i;\n                    done = true;\n                }\n                if (done) {\n                    \n                    \n                    \n                    \n                    pushback(buf.array(), offset + lastRead - readTooMuch, readTooMuch);\n                    bos.write(buf.array(), 0, i);\n                    readDataDescriptor();\n                }\n            }\n        }\n        return done;\n    }\n\n    \n    private int cacheBytesRead(ByteArrayOutputStream bos, int offset, int lastRead, int expecteDDLen) {\n        final int cacheable = offset + lastRead - expecteDDLen - 3;\n        if (cacheable > 0) {\n            bos.write(buf.array(), 0, cacheable);\n            System.arraycopy(buf.array(), cacheable, buf.array(), 0, expecteDDLen + 3);\n            offset = expecteDDLen + 3;\n        } else {\n            offset += lastRead;\n        }\n        return offset;\n    }\n\n    private void pushback(byte[] buf, int offset, int length) throws IOException {\n        ((PushbackInputStream) in).unread(buf, offset, length);\n        pushedBackBytes(length);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    private void skipRemainderOfArchive() throws IOException {\n        \n        \n        \n        realSkip(entriesRead * CFH_LEN - LFH_LEN);\n        findEocdRecord();\n        realSkip(ZipFile.MIN_EOCD_SIZE - WORD  - SHORT );\n        readFully(SHORT_BUF);\n        \n        realSkip(ZipShort.getValue(SHORT_BUF));\n    }\n\n    \n    private void findEocdRecord() throws IOException {\n        int currentByte = -1;\n        boolean skipReadCall = false;\n        while (skipReadCall || (currentByte = readOneByte()) > -1) {\n            skipReadCall = false;\n            if (!isFirstByteOfEocdSig(currentByte)) {\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[1]) {\n                if (currentByte == -1) {\n                    break;\n                }\n                skipReadCall = isFirstByteOfEocdSig(currentByte);\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[2]) {\n                if (currentByte == -1) {\n                    break;\n                }\n                skipReadCall = isFirstByteOfEocdSig(currentByte);\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte == -1\n                || currentByte == ZipArchiveOutputStream.EOCD_SIG[3]) {\n                break;\n            }\n            skipReadCall = isFirstByteOfEocdSig(currentByte);\n        }\n    }\n\n    \n    private void realSkip(long value) throws IOException {\n        if (value >= 0) {\n            long skipped = 0;\n            while (skipped < value) {\n                long rem = value - skipped;\n                int x = in.read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));\n                if (x == -1) {\n                    return;\n                }\n                count(x);\n                skipped += x;\n            }\n            return;\n        }\n        throw new IllegalArgumentException();\n    }\n\n    \n    private int readOneByte() throws IOException {\n        int b = in.read();\n        if (b != -1) {\n            count(1);\n        }\n        return b;\n    }\n\n    private boolean isFirstByteOfEocdSig(int b) {\n        return b == ZipArchiveOutputStream.EOCD_SIG[0];\n    }\n\n    \n    private static final class CurrentEntry { private final ZipArchiveEntry entry = new ZipArchiveEntry(); private boolean hasDataDescriptor; private boolean usesZip64; private long bytesRead; private long bytesReadFromStream; private final CRC32 crc = new CRC32(); private InputStream in; } private class BoundedInputStream extends InputStream {\n\n        \n        private final InputStream in; private final long max; private long pos = 0; public BoundedInputStream(final InputStream in, final long size) {\n            this.max = size;\n            this.in = in;\n        }\n\n        @Override\n        public int read() throws IOException {\n            if (max >= 0 && pos >= max) {\n                return -1;\n            }\n            final int result = in.read();\n            pos++;\n            count(1);\n            current.bytesReadFromStream++;\n            return result;\n        }\n\n        @Override\n        public int read(final byte[] b) throws IOException {\n            return this.read(b, 0, b.length);\n        }\n\n        @Override\n        public int read(final byte[] b, final int off, final int len) throws IOException {\n            if (max >= 0 && pos >= max) {\n                return -1;\n            }\n            final long maxRead = max >= 0 ? Math.min(len, max - pos) : len;\n            final int bytesRead = in.read(b, off, (int) maxRead);\n\n            if (bytesRead == -1) {\n                return -1;\n            }\n\n            pos += bytesRead;\n            count(bytesRead);\n            current.bytesReadFromStream += bytesRead;\n            return bytesRead;\n        }\n\n        @Override\n        public long skip(final long n) throws IOException {\n            final long toSkip = max >= 0 ? Math.min(n, max - pos) : n;\n            final long skippedBytes = in.skip(toSkip);\n            pos += skippedBytes;\n            return skippedBytes;\n        }\n    \n        @Override\n        public int available() throws IOException {\n            if (max >= 0 && pos >= max) {\n                return 0;\n            }\n            return in.available();\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public ZipArchiveInputStream(InputStream inputStream, String encoding)",
        "public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields)",
        "public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor)",
        "public ZipArchiveEntry getNextZipEntry() throws IOException",
        "private void readFirstLocalFileHeader(byte[] lfh) throws IOException",
        "private void processZip64Extra(ZipLong size, ZipLong cSize)",
        "public ArchiveEntry getNextEntry() throws IOException",
        "public boolean canReadEntryData(ArchiveEntry ae)",
        "public int read(byte[] buffer, int offset, int length) throws IOException",
        "private int readStored(byte[] buffer, int offset, int length) throws IOException",
        "private int readDeflated(byte[] buffer, int offset, int length) throws IOException",
        "private int readFromInflater(byte[] buffer, int offset, int length) throws IOException",
        "public void close() throws IOException",
        "public long skip(long value) throws IOException",
        "public static boolean matches(byte[] signature, int length)",
        "private static boolean checksig(byte[] signature, byte[] expected)",
        "private void closeEntry() throws IOException",
        "private void drainCurrentEntryData() throws IOException",
        "private long getBytesInflated()",
        "private int fill() throws IOException",
        "private void readFully(byte[] b) throws IOException",
        "private void readDataDescriptor() throws IOException",
        "private boolean supportsDataDescriptorFor(ZipArchiveEntry entry)",
        "private void readStoredEntry() throws IOException",
        "private int cacheBytesRead(ByteArrayOutputStream bos, int offset, int lastRead, int expecteDDLen)",
        "private void pushback(byte[] buf, int offset, int length) throws IOException",
        "private void skipRemainderOfArchive() throws IOException",
        "private void findEocdRecord() throws IOException",
        "private void realSkip(long value) throws IOException",
        "private int readOneByte() throws IOException",
        "private boolean isFirstByteOfEocdSig(int b)",
        "public int read() throws IOException",
        "public int read(final byte[] b) throws IOException",
        "public int read(final byte[] b, final int off, final int len) throws IOException",
        "public long skip(final long n) throws IOException",
        "public int available() throws IOException"
      ],
      "fixed_signatures": [
        "public ZipArchiveInputStream(InputStream inputStream, String encoding)",
        "public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields)",
        "public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor)",
        "public ZipArchiveEntry getNextZipEntry() throws IOException",
        "private void readFirstLocalFileHeader(byte[] lfh) throws IOException",
        "private void processZip64Extra(ZipLong size, ZipLong cSize)",
        "public ArchiveEntry getNextEntry() throws IOException",
        "public boolean canReadEntryData(ArchiveEntry ae)",
        "public int read(byte[] buffer, int offset, int length) throws IOException",
        "private int readStored(byte[] buffer, int offset, int length) throws IOException",
        "private int readDeflated(byte[] buffer, int offset, int length) throws IOException",
        "private int readFromInflater(byte[] buffer, int offset, int length) throws IOException",
        "public void close() throws IOException",
        "public long skip(long value) throws IOException",
        "public static boolean matches(byte[] signature, int length)",
        "private static boolean checksig(byte[] signature, byte[] expected)",
        "private void closeEntry() throws IOException",
        "private void drainCurrentEntryData() throws IOException",
        "private long getBytesInflated()",
        "private int fill() throws IOException",
        "private void readFully(byte[] b) throws IOException",
        "private void readDataDescriptor() throws IOException",
        "private boolean supportsDataDescriptorFor(ZipArchiveEntry entry)",
        "private void readStoredEntry() throws IOException",
        "private int cacheBytesRead(ByteArrayOutputStream bos, int offset, int lastRead, int expecteDDLen)",
        "private void pushback(byte[] buf, int offset, int length) throws IOException",
        "private void skipRemainderOfArchive() throws IOException",
        "private void findEocdRecord() throws IOException",
        "private void realSkip(long value) throws IOException",
        "private int readOneByte() throws IOException",
        "private boolean isFirstByteOfEocdSig(int b)",
        "public int read() throws IOException",
        "public int read(final byte[] b) throws IOException",
        "public int read(final byte[] b, final int off, final int len) throws IOException",
        "public long skip(final long n) throws IOException",
        "public int available() throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -62,6 +62,7 @@",
            "     private final ZipEncoding zipEncoding;\n",
            " \n",
            "     // the provided encoding (for unit tests)\n",
            "+    final String encoding;\n",
            " \n",
            "     /** Whether to look for and use Unicode extra fields. */\n",
            "     private final boolean useUnicodeExtraFields;\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n  zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n  this.useUnicodeExtraFields = useUnicodeExtraFields;\n  in = new PushbackInputStream(inputStream, buf.capacity());\n  this.allowStoredEntriesWithDataDescriptor =\n  allowStoredEntriesWithDataDescriptor;\n  \n  buf.limit(0);\n  }",
          "fixed_method": "  public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n  this.encoding = encoding;\n  zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n  this.useUnicodeExtraFields = useUnicodeExtraFields;\n  in = new PushbackInputStream(inputStream, buf.capacity());\n  this.allowStoredEntriesWithDataDescriptor =\n  allowStoredEntriesWithDataDescriptor;\n  \n  buf.limit(0);\n  }",
          "diff": [
            "@@ -181,6 +182,7 @@",
            "                                  String encoding,\n",
            "                                  boolean useUnicodeExtraFields,\n",
            "                                  boolean allowStoredEntriesWithDataDescriptor) {\n",
            "+        this.encoding = encoding;\n",
            "         zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n",
            "         this.useUnicodeExtraFields = useUnicodeExtraFields;\n",
            "         in = new PushbackInputStream(inputStream, buf.capacity());\n"
          ],
          "changed_lines": 1
        }
      ]
    }
  ]
}
