{
  "bug_id": "99",
  "failed_tests": {
    "com.fasterxml.jackson.databind.type.TestTypeFactory": [
      {
        "methodName": "testCanonicalNames",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<...rence<java.lang.Long[>]> but was:<...rence<java.lang.Long[]>",
        "fail_line": "        assertEquals(\"java.util.concurrent.atomic.AtomicReference<java.lang.Long>\",",
        "test_source": "  public void testCanonicalNames() {\n  TypeFactory tf = TypeFactory.defaultInstance();\n  JavaType t = tf.constructType(java.util.Calendar.class);\n  String can = t.toCanonical();\n  assertEquals(\"java.util.Calendar\", can);\n  assertEquals(t, tf.constructFromCanonical(can));\n\n  // Generic maps and collections will default to Object.class if type-erased\n  t = tf.constructType(java.util.ArrayList.class);\n  can = t.toCanonical();\n  assertEquals(\"java.util.ArrayList<java.lang.Object>\", can);\n  assertEquals(t, tf.constructFromCanonical(can));\n\n  t = tf.constructType(java.util.TreeMap.class);\n  can = t.toCanonical();\n  assertEquals(\"java.util.TreeMap<java.lang.Object,java.lang.Object>\", can);\n  assertEquals(t, tf.constructFromCanonical(can));\n\n  // And then EnumMap (actual use case for us)\n  t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);\n  can = t.toCanonical();\n  assertEquals(\"java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>\",\n  can);\n  assertEquals(t, tf.constructFromCanonical(can));\n\n  // [databind#2109]: also ReferenceTypes\n  t = tf.constructType(new TypeReference<AtomicReference<Long>>() { });\n  can = t.toCanonical();\n  assertEquals(\"java.util.concurrent.atomic.AtomicReference<java.lang.Long>\",\n  can);\n  assertEquals(t, tf.constructFromCanonical(can));\n\n  // [databind#1941]: allow \"raw\" types too\n  t = tf.constructFromCanonical(\"java.util.List\");\n  assertEquals(List.class, t.getRawClass());\n  assertEquals(CollectionType.class, t.getClass());\n  // 01-Mar-2018, tatu: not 100% should we expect type parameters here...\n  //  But currently we do NOT get any\n  /*\n  assertEquals(1, t.containedTypeCount());\n  assertEquals(Object.class, t.containedType(0).getRawClass());\n  */\n  assertEquals(Object.class, t.getContentType().getRawClass());\n  can = t.toCanonical();\n  assertEquals(\"java.util.List<java.lang.Object>\", can);\n  assertEquals(t, tf.constructFromCanonical(can));\n  }",
        "stack": [
          "TestTypeFactory.testCanonicalNames line 238"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/type/ReferenceType.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.type;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n\npublic class ReferenceType extends SimpleType { private static final long serialVersionUID = 1L; protected final JavaType _referencedType; protected final JavaType _anchorType; protected ReferenceType(Class<?> cls, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType refType, JavaType anchorType, Object valueHandler, Object typeHandler, boolean asStatic) {\n        super(cls, bindings, superClass, superInts, refType.hashCode(),\n                valueHandler, typeHandler, asStatic);\n        _referencedType = refType;\n        _anchorType = (anchorType == null) ? this : anchorType;\n    }\n\n    \n    protected ReferenceType(TypeBase base, JavaType refType) {\n        super(base);\n        _referencedType = refType;\n        \n        _anchorType = this;\n    }\n\n    \n    public static ReferenceType upgradeFrom(JavaType baseType, JavaType refdType) {\n        if (refdType == null) {\n            throw new IllegalArgumentException(\"Missing referencedType\");\n        }\n        \n        \n        if (baseType instanceof TypeBase) {\n            return new ReferenceType((TypeBase) baseType, refdType);\n        }\n        throw new IllegalArgumentException(\"Can not upgrade from an instance of \"+baseType.getClass());\n    }\n\n    \n    public static ReferenceType construct(Class<?> cls, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType refType) {\n        return new ReferenceType(cls, bindings, superClass, superInts,\n                refType, null, null, null, false);\n    }\n\n    @Deprecated \n    public static ReferenceType construct(Class<?> cls, JavaType refType) {\n        return new ReferenceType(cls, TypeBindings.emptyBindings(),\n                \n                null, null, null, refType, null, null, false);\n    }\n\n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        if (_referencedType == contentType) {\n            return this;\n        }\n        return new ReferenceType(_class, _bindings, _superClass, _superInterfaces,\n                contentType, _anchorType, _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public ReferenceType withTypeHandler(Object h) {\n        if (h == _typeHandler) {\n            return this;\n        }\n        return new ReferenceType(_class, _bindings, _superClass, _superInterfaces,\n                _referencedType, _anchorType, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public ReferenceType withContentTypeHandler(Object h) {\n        if (h == _referencedType.<Object>getTypeHandler()) {\n            return this;\n        }\n        return new ReferenceType(_class, _bindings, _superClass, _superInterfaces,\n                _referencedType.withTypeHandler(h), _anchorType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public ReferenceType withValueHandler(Object h) {\n        if (h == _valueHandler) {\n            return this;\n        }\n        return new ReferenceType(_class, _bindings,\n                _superClass, _superInterfaces, _referencedType, _anchorType,\n                h, _typeHandler,_asStatic);\n    }\n\n    @Override\n    public ReferenceType withContentValueHandler(Object h) {\n        if (h == _referencedType.<Object>getValueHandler()) {\n            return this;\n        }\n        JavaType refdType = _referencedType.withValueHandler(h);\n        return new ReferenceType(_class, _bindings,\n                _superClass, _superInterfaces, refdType, _anchorType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public ReferenceType withStaticTyping() {\n        if (_asStatic) {\n            return this;\n        }\n        return new ReferenceType(_class, _bindings, _superClass, _superInterfaces,\n                _referencedType.withStaticTyping(), _anchorType,\n                 _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        return new ReferenceType(rawType, _bindings,\n                superClass, superInterfaces, _referencedType, _anchorType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    protected String buildCanonicalName() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n        sb.append('<');\n        sb.append(_referencedType.toCanonical());\n        return sb.toString();\n    }\n\n    \n\n    @Override\n    @Deprecated \n    protected JavaType _narrow(Class<?> subclass) {\n        \n        return new ReferenceType(subclass, _bindings,\n                _superClass, _superInterfaces, _referencedType, _anchorType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    \n\n    @Override\n    public JavaType getContentType() {\n        return _referencedType;\n    }\n\n    @Override\n    public JavaType getReferencedType() {\n        return _referencedType;\n    }\n\n    @Override\n    public boolean hasContentType() {\n        return true;\n    }\n\n    @Override\n    public boolean isReferenceType() {\n        return true;\n    }\n\n    @Override\n    public StringBuilder getErasedSignature(StringBuilder sb) {\n        return _classSignature(_class, sb, true);\n    }\n    \n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb) {\n        _classSignature(_class, sb, false);\n        sb.append('<');\n        sb = _referencedType.getGenericSignature(sb);\n        sb.append(\">;\");\n        return sb;\n    }\n\n    \n\n    public JavaType getAnchorType() {\n        return _anchorType;\n    }\n\n    \n    public boolean isAnchorType() {\n        return (_anchorType == this);\n    }\n\n    \n\n    @Override\n    public String toString() {\n        return new StringBuilder(40)\n            .append(\"[reference type, class \")\n            .append(buildCanonicalName())\n            .append('<')\n            .append(_referencedType)\n            .append('>')\n            .append(']')\n            .toString();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        ReferenceType other = (ReferenceType) o;\n\n        if (other._class != _class) return false;\n        \n        \n        return _referencedType.equals(other._referencedType);\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.type;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n\npublic class ReferenceType extends SimpleType { private static final long serialVersionUID = 1L; protected final JavaType _referencedType; protected final JavaType _anchorType; protected ReferenceType(Class<?> cls, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType refType, JavaType anchorType, Object valueHandler, Object typeHandler, boolean asStatic) {\n        super(cls, bindings, superClass, superInts, refType.hashCode(),\n                valueHandler, typeHandler, asStatic);\n        _referencedType = refType;\n        _anchorType = (anchorType == null) ? this : anchorType;\n    }\n\n    \n    protected ReferenceType(TypeBase base, JavaType refType) {\n        super(base);\n        _referencedType = refType;\n        \n        _anchorType = this;\n    }\n\n    \n    public static ReferenceType upgradeFrom(JavaType baseType, JavaType refdType) {\n        if (refdType == null) {\n            throw new IllegalArgumentException(\"Missing referencedType\");\n        }\n        \n        \n        if (baseType instanceof TypeBase) {\n            return new ReferenceType((TypeBase) baseType, refdType);\n        }\n        throw new IllegalArgumentException(\"Can not upgrade from an instance of \"+baseType.getClass());\n    }\n\n    \n    public static ReferenceType construct(Class<?> cls, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType refType) {\n        return new ReferenceType(cls, bindings, superClass, superInts,\n                refType, null, null, null, false);\n    }\n\n    @Deprecated \n    public static ReferenceType construct(Class<?> cls, JavaType refType) {\n        return new ReferenceType(cls, TypeBindings.emptyBindings(),\n                \n                null, null, null, refType, null, null, false);\n    }\n\n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        if (_referencedType == contentType) {\n            return this;\n        }\n        return new ReferenceType(_class, _bindings, _superClass, _superInterfaces,\n                contentType, _anchorType, _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public ReferenceType withTypeHandler(Object h) {\n        if (h == _typeHandler) {\n            return this;\n        }\n        return new ReferenceType(_class, _bindings, _superClass, _superInterfaces,\n                _referencedType, _anchorType, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public ReferenceType withContentTypeHandler(Object h) {\n        if (h == _referencedType.<Object>getTypeHandler()) {\n            return this;\n        }\n        return new ReferenceType(_class, _bindings, _superClass, _superInterfaces,\n                _referencedType.withTypeHandler(h), _anchorType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public ReferenceType withValueHandler(Object h) {\n        if (h == _valueHandler) {\n            return this;\n        }\n        return new ReferenceType(_class, _bindings,\n                _superClass, _superInterfaces, _referencedType, _anchorType,\n                h, _typeHandler,_asStatic);\n    }\n\n    @Override\n    public ReferenceType withContentValueHandler(Object h) {\n        if (h == _referencedType.<Object>getValueHandler()) {\n            return this;\n        }\n        JavaType refdType = _referencedType.withValueHandler(h);\n        return new ReferenceType(_class, _bindings,\n                _superClass, _superInterfaces, refdType, _anchorType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public ReferenceType withStaticTyping() {\n        if (_asStatic) {\n            return this;\n        }\n        return new ReferenceType(_class, _bindings, _superClass, _superInterfaces,\n                _referencedType.withStaticTyping(), _anchorType,\n                 _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        return new ReferenceType(rawType, _bindings,\n                superClass, superInterfaces, _referencedType, _anchorType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    protected String buildCanonicalName() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n        sb.append('<');\n        sb.append(_referencedType.toCanonical());\n        sb.append('>');\n        return sb.toString();\n    }\n\n    \n\n    @Override\n    @Deprecated \n    protected JavaType _narrow(Class<?> subclass) {\n        \n        return new ReferenceType(subclass, _bindings,\n                _superClass, _superInterfaces, _referencedType, _anchorType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    \n\n    @Override\n    public JavaType getContentType() {\n        return _referencedType;\n    }\n\n    @Override\n    public JavaType getReferencedType() {\n        return _referencedType;\n    }\n\n    @Override\n    public boolean hasContentType() {\n        return true;\n    }\n\n    @Override\n    public boolean isReferenceType() {\n        return true;\n    }\n\n    @Override\n    public StringBuilder getErasedSignature(StringBuilder sb) {\n        return _classSignature(_class, sb, true);\n    }\n    \n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb) {\n        _classSignature(_class, sb, false);\n        sb.append('<');\n        sb = _referencedType.getGenericSignature(sb);\n        sb.append(\">;\");\n        return sb;\n    }\n\n    \n\n    public JavaType getAnchorType() {\n        return _anchorType;\n    }\n\n    \n    public boolean isAnchorType() {\n        return (_anchorType == this);\n    }\n\n    \n\n    @Override\n    public String toString() {\n        return new StringBuilder(40)\n            .append(\"[reference type, class \")\n            .append(buildCanonicalName())\n            .append('<')\n            .append(_referencedType)\n            .append('>')\n            .append(']')\n            .toString();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        ReferenceType other = (ReferenceType) o;\n\n        if (other._class != _class) return false;\n        \n        \n        return _referencedType.equals(other._referencedType);\n    }\n}\n",
      "buggy_signatures": [
        "protected ReferenceType(TypeBase base, JavaType refType)",
        "public static ReferenceType upgradeFrom(JavaType baseType, JavaType refdType)",
        "public static ReferenceType construct(Class<?> cls, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType refType)",
        "public static ReferenceType construct(Class<?> cls, JavaType refType)",
        "public JavaType withContentType(JavaType contentType)",
        "public ReferenceType withTypeHandler(Object h)",
        "public ReferenceType withContentTypeHandler(Object h)",
        "public ReferenceType withValueHandler(Object h)",
        "public ReferenceType withContentValueHandler(Object h)",
        "public ReferenceType withStaticTyping()",
        "public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected String buildCanonicalName()",
        "protected JavaType _narrow(Class<?> subclass)",
        "public JavaType getContentType()",
        "public JavaType getReferencedType()",
        "public boolean hasContentType()",
        "public boolean isReferenceType()",
        "public StringBuilder getErasedSignature(StringBuilder sb)",
        "public StringBuilder getGenericSignature(StringBuilder sb)",
        "public JavaType getAnchorType()",
        "public boolean isAnchorType()",
        "public String toString()",
        "public boolean equals(Object o)"
      ],
      "fixed_signatures": [
        "protected ReferenceType(TypeBase base, JavaType refType)",
        "public static ReferenceType upgradeFrom(JavaType baseType, JavaType refdType)",
        "public static ReferenceType construct(Class<?> cls, TypeBindings bindings, JavaType superClass, JavaType[] superInts, JavaType refType)",
        "public static ReferenceType construct(Class<?> cls, JavaType refType)",
        "public JavaType withContentType(JavaType contentType)",
        "public ReferenceType withTypeHandler(Object h)",
        "public ReferenceType withContentTypeHandler(Object h)",
        "public ReferenceType withValueHandler(Object h)",
        "public ReferenceType withContentValueHandler(Object h)",
        "public ReferenceType withStaticTyping()",
        "public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)",
        "protected String buildCanonicalName()",
        "protected JavaType _narrow(Class<?> subclass)",
        "public JavaType getContentType()",
        "public JavaType getReferencedType()",
        "public boolean hasContentType()",
        "public boolean isReferenceType()",
        "public StringBuilder getErasedSignature(StringBuilder sb)",
        "public StringBuilder getGenericSignature(StringBuilder sb)",
        "public JavaType getAnchorType()",
        "public boolean isAnchorType()",
        "public String toString()",
        "public boolean equals(Object o)"
      ],
      "methods": [
        {
          "buggy_method": "  protected String buildCanonicalName() {\n  StringBuilder sb = new StringBuilder();\n  sb.append(_class.getName());\n  sb.append('<');\n  sb.append(_referencedType.toCanonical());\n  return sb.toString();\n  }",
          "fixed_method": "  protected String buildCanonicalName() {\n  StringBuilder sb = new StringBuilder();\n  sb.append(_class.getName());\n  sb.append('<');\n  sb.append(_referencedType.toCanonical());\n  sb.append('>');\n  return sb.toString();\n  }",
          "diff": [
            "@@ -166,6 +166,7 @@",
            "         sb.append(_class.getName());\n",
            "         sb.append('<');\n",
            "         sb.append(_referencedType.toCanonical());\n",
            "+        sb.append('>');\n",
            "         return sb.toString();\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 1
        }
      ]
    }
  ]
}
