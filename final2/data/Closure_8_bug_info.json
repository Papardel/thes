{
  "bug_id": "8",
  "failed_tests": {
    "com.google.javascript.jscomp.CollapseVariableDeclarationsTest": [
      {
        "methodName": "testIssue820",
        "error": "junit.framework.AssertionFailedError:",
        "message": "",
        "fail_line": "    testSame(\"function f(a){ var b=1; a=2; var c; }\");",
        "test_source": "  public void testIssue820() throws Exception {\n  // Don't redeclare function parameters, this is incompatible with\n  // strict mode.\n  testSame(\"function f(a){ var b=1; a=2; var c; }\");\n  }",
        "stack": [
          "CompilerTestCase.test line 892, CompilerTestCase.test line 445, CompilerTestCase.test line 371, CompilerTestCase.test line 340, CompilerTestCase.test line 328, CompilerTestCase.testSame line 560, CollapseVariableDeclarationsTest.testIssue820 line 48"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/google/javascript/jscomp/CollapseVariableDeclarations.java",
      "buggy_full_code": "\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.List;\nimport java.util.Set;\n\n\nclass CollapseVariableDeclarations implements CompilerPass {\n  \n  private final AbstractCompiler compiler; private static class Collapse { final Node startNode; final Node endNode; final Node parent; Collapse(Node startNode, Node endNode, Node parent) {\n      this.startNode = startNode;\n      this.endNode = endNode;\n      this.parent = parent;\n    }\n  }\n\n  \n  private final List<Collapse> collapses = Lists.newArrayList(); private final Set<Node> nodesToCollapse = Sets.newHashSet(); CollapseVariableDeclarations(AbstractCompiler compiler) {\n    Preconditions.checkState(!compiler.getLifeCycleStage().isNormalized());\n    this.compiler = compiler;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    collapses.clear();\n    nodesToCollapse.clear();\n\n    NodeTraversal.traverse(compiler, root, new GatherCollapses());\n\n    if (!collapses.isEmpty()) {\n      applyCollapses();\n      compiler.reportCodeChange();\n    }\n  }\n\n  \n  private class GatherCollapses extends AbstractPostOrderCallback { private final Set<Var> blacklistedVars = Sets.newHashSet(); @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.isVar()) {\n        blacklistStubVars(t, n);\n      }\n\n      \n      if (!n.isVar() && !canBeRedeclared(n, t.getScope())) return;\n\n      \n      if (nodesToCollapse.contains(n)) return;\n\n      \n      \n      if (parent.isIf()) return;\n\n      Node varNode = n;\n\n      boolean hasVar = n.isVar();\n\n      \n      n = n.getNext();\n\n      boolean hasNodesToCollapse = false;\n\n      while (n != null &&\n          (n.isVar() || canBeRedeclared(n, t.getScope()))) {\n\n        if (n.isVar()) {\n          blacklistStubVars(t, n);\n          hasVar = true;\n        }\n\n        nodesToCollapse.add(n);\n        hasNodesToCollapse = true;\n\n        n = n.getNext();\n      }\n\n      if (hasNodesToCollapse && hasVar) {\n        nodesToCollapse.add(varNode);\n        collapses.add(new Collapse(varNode, n, parent));\n      }\n    }\n\n    private void blacklistStubVars(NodeTraversal t, Node varNode) {\n      for (Node child = varNode.getFirstChild();\n           child != null; child = child.getNext()) {\n        if (child.getFirstChild() == null) {\n          blacklistedVars.add(t.getScope().getVar(child.getString()));\n        }\n      }\n    }\n\n    private boolean canBeRedeclared(Node n, Scope s) {\n      if (!NodeUtil.isExprAssign(n)) {\n        return false;\n      }\n      Node assign = n.getFirstChild();\n      Node lhs = assign.getFirstChild();\n\n      if (!lhs.isName()) {\n        return false;\n      }\n\n      Var var = s.getVar(lhs.getString());\n      return var != null\n          && var.getScope() == s\n          && !blacklistedVars.contains(var);\n    }\n  }\n\n\n  private void applyCollapses() {\n    for (Collapse collapse : collapses) {\n\n      Node var = new Node(Token.VAR);\n      var.copyInformationFrom(collapse.startNode);\n      collapse.parent.addChildBefore(var, collapse.startNode);\n\n      boolean redeclaration = false;\n      for (Node n = collapse.startNode; n != collapse.endNode;) {\n        Node next = n.getNext();\n\n        Preconditions.checkState(var.getNext() == n);\n        collapse.parent.removeChildAfter(var);\n\n        if (n.isVar()) {\n          while(n.hasChildren()) {\n            var.addChildToBack(n.removeFirstChild());\n          }\n        } else {\n          Node assign = n.getFirstChild();\n          Node lhs = assign.getFirstChild();\n          Preconditions.checkState(lhs.isName());\n          Node rhs = assign.getLastChild();\n          lhs.addChildToBack(rhs.detachFromParent());\n          var.addChildToBack(lhs.detachFromParent());\n          redeclaration = true;\n        }\n        n = next;\n      }\n\n      if (redeclaration) {\n        JSDocInfo info = new JSDocInfo();\n        info.addSuppression(\"duplicate\");\n        var.setJSDocInfo(info);\n      }\n    }\n  }\n}\n",
      "fixed_full_code": "\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.List;\nimport java.util.Set;\n\n\nclass CollapseVariableDeclarations implements CompilerPass {\n  \n  private final AbstractCompiler compiler; private static class Collapse { final Node startNode; final Node endNode; final Node parent; Collapse(Node startNode, Node endNode, Node parent) {\n      this.startNode = startNode;\n      this.endNode = endNode;\n      this.parent = parent;\n    }\n  }\n\n  \n  private final List<Collapse> collapses = Lists.newArrayList(); private final Set<Node> nodesToCollapse = Sets.newHashSet(); CollapseVariableDeclarations(AbstractCompiler compiler) {\n    Preconditions.checkState(!compiler.getLifeCycleStage().isNormalized());\n    this.compiler = compiler;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    collapses.clear();\n    nodesToCollapse.clear();\n\n    NodeTraversal.traverse(compiler, root, new GatherCollapses());\n\n    if (!collapses.isEmpty()) {\n      applyCollapses();\n      compiler.reportCodeChange();\n    }\n  }\n\n  \n  private class GatherCollapses extends AbstractPostOrderCallback { private final Set<Var> blacklistedVars = Sets.newHashSet(); @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.isVar()) {\n        blacklistStubVars(t, n);\n      }\n\n      \n      if (!n.isVar() && !canBeRedeclared(n, t.getScope())) return;\n\n      \n      if (nodesToCollapse.contains(n)) return;\n\n      \n      \n      if (parent.isIf()) return;\n\n      Node varNode = n;\n\n      boolean hasVar = n.isVar();\n\n      \n      n = n.getNext();\n\n      boolean hasNodesToCollapse = false;\n\n      while (n != null &&\n          (n.isVar() || canBeRedeclared(n, t.getScope()))) {\n\n        if (n.isVar()) {\n          blacklistStubVars(t, n);\n          hasVar = true;\n        }\n\n        nodesToCollapse.add(n);\n        hasNodesToCollapse = true;\n\n        n = n.getNext();\n      }\n\n      if (hasNodesToCollapse && hasVar) {\n        nodesToCollapse.add(varNode);\n        collapses.add(new Collapse(varNode, n, parent));\n      }\n    }\n\n    private void blacklistStubVars(NodeTraversal t, Node varNode) {\n      for (Node child = varNode.getFirstChild();\n           child != null; child = child.getNext()) {\n        if (child.getFirstChild() == null) {\n          blacklistedVars.add(t.getScope().getVar(child.getString()));\n        }\n      }\n    }\n\n    private boolean canBeRedeclared(Node n, Scope s) {\n      if (!NodeUtil.isExprAssign(n)) {\n        return false;\n      }\n      Node assign = n.getFirstChild();\n      Node lhs = assign.getFirstChild();\n\n      if (!lhs.isName()) {\n        return false;\n      }\n\n      Var var = s.getVar(lhs.getString());\n      return var != null\n          && var.getScope() == s\n          && !isNamedParameter(var)\n          && !blacklistedVars.contains(var);\n    }\n  }\n\n  private boolean isNamedParameter(Var v) {\n    return v.getParentNode().isParamList();\n  }\n\n  private void applyCollapses() {\n    for (Collapse collapse : collapses) {\n\n      Node var = new Node(Token.VAR);\n      var.copyInformationFrom(collapse.startNode);\n      collapse.parent.addChildBefore(var, collapse.startNode);\n\n      boolean redeclaration = false;\n      for (Node n = collapse.startNode; n != collapse.endNode;) {\n        Node next = n.getNext();\n\n        Preconditions.checkState(var.getNext() == n);\n        collapse.parent.removeChildAfter(var);\n\n        if (n.isVar()) {\n          while(n.hasChildren()) {\n            var.addChildToBack(n.removeFirstChild());\n          }\n        } else {\n          Node assign = n.getFirstChild();\n          Node lhs = assign.getFirstChild();\n          Preconditions.checkState(lhs.isName());\n          Node rhs = assign.getLastChild();\n          lhs.addChildToBack(rhs.detachFromParent());\n          var.addChildToBack(lhs.detachFromParent());\n          redeclaration = true;\n        }\n        n = next;\n      }\n\n      if (redeclaration) {\n        JSDocInfo info = new JSDocInfo();\n        info.addSuppression(\"duplicate\");\n        var.setJSDocInfo(info);\n      }\n    }\n  }\n}\n",
      "buggy_signatures": [
        "private final AbstractCompiler compiler; private static class Collapse { final Node startNode; final Node endNode; final Node parent; Collapse(Node startNode, Node endNode, Node parent)",
        "public void process(Node externs, Node root)",
        "private void blacklistStubVars(NodeTraversal t, Node varNode)",
        "private boolean canBeRedeclared(Node n, Scope s)",
        "private void applyCollapses()"
      ],
      "fixed_signatures": [
        "private final AbstractCompiler compiler; private static class Collapse { final Node startNode; final Node endNode; final Node parent; Collapse(Node startNode, Node endNode, Node parent)",
        "public void process(Node externs, Node root)",
        "private void blacklistStubVars(NodeTraversal t, Node varNode)",
        "private boolean canBeRedeclared(Node n, Scope s)",
        "private boolean isNamedParameter(Var v)",
        "private void applyCollapses()"
      ],
      "methods": [
        {
          "buggy_method": "  private void applyCollapses() {\n  for (Collapse collapse : collapses) {\n\n  Node var = new Node(Token.VAR);\n  var.copyInformationFrom(collapse.startNode);\n  collapse.parent.addChildBefore(var, collapse.startNode);\n\n  boolean redeclaration = false;\n  for (Node n = collapse.startNode; n != collapse.endNode;) {\n  Node next = n.getNext();\n\n  Preconditions.checkState(var.getNext() == n);\n  collapse.parent.removeChildAfter(var);\n\n  if (n.isVar()) {\n  while(n.hasChildren()) {\n  var.addChildToBack(n.removeFirstChild());\n  }\n  } else {\n  Node assign = n.getFirstChild();\n  Node lhs = assign.getFirstChild();\n  Preconditions.checkState(lhs.isName());\n  Node rhs = assign.getLastChild();\n  lhs.addChildToBack(rhs.detachFromParent());\n  var.addChildToBack(lhs.detachFromParent());\n  redeclaration = true;\n  }\n  n = next;\n  }\n\n  if (redeclaration) {\n  JSDocInfo info = new JSDocInfo();\n  info.addSuppression(\"duplicate\");\n  var.setJSDocInfo(info);\n  }\n  }\n  }",
          "fixed_method": "  private boolean isNamedParameter(Var v) {\n  return v.getParentNode().isParamList();\n  }",
          "diff": [
            "@@ -201,10 +201,14 @@",
            "       Var var = s.getVar(lhs.getString());\n",
            "       return var != null\n",
            "           && var.getScope() == s\n",
            "+          && !isNamedParameter(var)\n",
            "           && !blacklistedVars.contains(var);\n",
            "     }\n",
            "   }\n",
            " \n",
            "+  private boolean isNamedParameter(Var v) {\n",
            "+    return v.getParentNode().isParamList();\n",
            "+  }\n",
            " \n",
            "   private void applyCollapses() {\n",
            "     for (Collapse collapse : collapses) {\n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
