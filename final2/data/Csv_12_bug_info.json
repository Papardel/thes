{
  "bug_id": "12",
  "failed_tests": {
    "org.apache.commons.csv.CSVParserTest": [
      {
        "methodName": "testExcelHeaderCountLessThanData",
        "error": "java.lang.IllegalArgumentException",
        "message": "The header contains a duplicate name: \"\" in [A, B, C, , ]",
        "fail_line": "        final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL.withHeader());",
        "test_source": "  public void testExcelHeaderCountLessThanData() throws Exception {\n  final String code = \"A,B,C,,\\r\\na,b,c,d,e\\r\\n\";\n  final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL.withHeader());\n  try {\n  for (CSVRecord record : parser.getRecords()) {\n  Assert.assertEquals(\"a\", record.get(\"A\"));\n  Assert.assertEquals(\"b\", record.get(\"B\"));\n  Assert.assertEquals(\"c\", record.get(\"C\"));\n  }\n  } finally {\n  parser.close();\n  }\n  }",
        "stack": [
          "CSVParser.initializeHeader line 368, CSVParser.<init> line 248, CSVParser.parse line 178, CSVParserTest.testExcelHeaderCountLessThanData line 380"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/csv/CSVFormat.java",
      "buggy_full_code": "\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH; import static org.apache.commons.csv.Constants.COMMA; import static org.apache.commons.csv.Constants.CR; import static org.apache.commons.csv.Constants.CRLF; import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR; import static org.apache.commons.csv.Constants.LF; import static org.apache.commons.csv.Constants.TAB; import java.io.IOException; import java.io.Reader; import java.io.Serializable; import java.io.StringWriter; import java.util.Arrays; import java.util.HashSet; import java.util.Set; public final class CSVFormat implements Serializable { private static final long serialVersionUID = 1L; private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    \n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    \n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, false, false);\n    }\n\n    \n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        if (header == null) {\n            this.header = null;\n        } else {\n            final Set<String> dupCheck = new HashSet<String>();\n            for (final String hdr : header) {\n                if (!dupCheck.add(hdr)) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate entry: '\" + hdr + \"' in \" +\n                            Arrays.toString(header));\n                }\n            }\n            this.header = header.clone();\n        }\n        this.skipHeaderRecord = skipHeaderRecord;\n        validate();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (quoteMode != other.quoteMode) {\n            return false;\n        }\n        if (quoteCharacter == null) {\n            if (other.quoteCharacter != null) {\n                return false;\n            }\n        } else if (!quoteCharacter.equals(other.quoteCharacter)) {\n            return false;\n        }\n        if (commentMarker == null) {\n            if (other.commentMarker != null) {\n                return false;\n            }\n        } else if (!commentMarker.equals(other.commentMarker)) {\n            return false;\n        }\n        if (escapeCharacter == null) {\n            if (other.escapeCharacter != null) {\n                return false;\n            }\n        } else if (!escapeCharacter.equals(other.escapeCharacter)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        return true;\n    }\n\n    \n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try {\n            new CSVPrinter(out, this).printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            \n            throw new IllegalStateException(e);\n        }\n    }\n\n    \n    public Character getCommentMarker() {\n        return commentMarker;\n    }\n\n    \n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    \n    public Character getEscapeCharacter() {\n        return escapeCharacter;\n    }\n\n    \n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    \n    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }\n\n    \n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    \n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    \n    public String getNullString() {\n        return nullString;\n    }\n\n    \n    public Character getQuoteCharacter() {\n        return quoteCharacter;\n    }\n\n    \n    public QuoteMode getQuoteMode() {\n        return quoteMode;\n    }\n\n    \n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    \n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());\n        result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());\n        result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());\n        result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        return result;\n    }\n\n    \n    public boolean isCommentMarkerSet() {\n        return commentMarker != null;\n    }\n\n    \n    public boolean isEscapeCharacterSet() {\n        return escapeCharacter != null;\n    }\n\n    \n    public boolean isNullStringSet() {\n        return nullString != null;\n    }\n\n    \n    public boolean isQuoteCharacterSet() {\n        return quoteCharacter != null;\n    }\n\n    \n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    \n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if(recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    \n    private void validate() throws IllegalArgumentException {\n        if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n        }\n\n        if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n        }\n\n        if (commentMarker != null && delimiter == commentMarker.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n        }\n    }\n\n    \n    public CSVFormat withCommentMarker(final char commentMarker) {\n        return withCommentMarker(Character.valueOf(commentMarker));\n    }\n\n    \n    public CSVFormat withCommentMarker(final Character commentMarker) {\n        if (isLineBreak(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    \n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    \n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    \n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    \n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    \n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    \n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    \n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    \n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    \n    public CSVFormat withQuote(final char quoteChar) {\n        return withQuote(Character.valueOf(quoteChar));\n    }\n\n    \n    public CSVFormat withQuote(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    \n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    \n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    \n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    \n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH; import static org.apache.commons.csv.Constants.COMMA; import static org.apache.commons.csv.Constants.CR; import static org.apache.commons.csv.Constants.CRLF; import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR; import static org.apache.commons.csv.Constants.LF; import static org.apache.commons.csv.Constants.TAB; import java.io.IOException; import java.io.Reader; import java.io.Serializable; import java.io.StringWriter; import java.util.Arrays; import java.util.HashSet; import java.util.Set; public final class CSVFormat implements Serializable { private static final long serialVersionUID = 1L; private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    \n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    \n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, false, false);\n    }\n\n    \n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        if (header == null) {\n            this.header = null;\n        } else {\n            final Set<String> dupCheck = new HashSet<String>();\n            for (final String hdr : header) {\n                if (!dupCheck.add(hdr)) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate entry: '\" + hdr + \"' in \" +\n                            Arrays.toString(header));\n                }\n            }\n            this.header = header.clone();\n        }\n        this.skipHeaderRecord = skipHeaderRecord;\n        validate();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (quoteMode != other.quoteMode) {\n            return false;\n        }\n        if (quoteCharacter == null) {\n            if (other.quoteCharacter != null) {\n                return false;\n            }\n        } else if (!quoteCharacter.equals(other.quoteCharacter)) {\n            return false;\n        }\n        if (commentMarker == null) {\n            if (other.commentMarker != null) {\n                return false;\n            }\n        } else if (!commentMarker.equals(other.commentMarker)) {\n            return false;\n        }\n        if (escapeCharacter == null) {\n            if (other.escapeCharacter != null) {\n                return false;\n            }\n        } else if (!escapeCharacter.equals(other.escapeCharacter)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        return true;\n    }\n\n    \n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try {\n            new CSVPrinter(out, this).printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            \n            throw new IllegalStateException(e);\n        }\n    }\n\n    \n    public Character getCommentMarker() {\n        return commentMarker;\n    }\n\n    \n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    \n    public Character getEscapeCharacter() {\n        return escapeCharacter;\n    }\n\n    \n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    \n    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }\n\n    \n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    \n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    \n    public String getNullString() {\n        return nullString;\n    }\n\n    \n    public Character getQuoteCharacter() {\n        return quoteCharacter;\n    }\n\n    \n    public QuoteMode getQuoteMode() {\n        return quoteMode;\n    }\n\n    \n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    \n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());\n        result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());\n        result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());\n        result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        return result;\n    }\n\n    \n    public boolean isCommentMarkerSet() {\n        return commentMarker != null;\n    }\n\n    \n    public boolean isEscapeCharacterSet() {\n        return escapeCharacter != null;\n    }\n\n    \n    public boolean isNullStringSet() {\n        return nullString != null;\n    }\n\n    \n    public boolean isQuoteCharacterSet() {\n        return quoteCharacter != null;\n    }\n\n    \n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    \n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if(recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    \n    private void validate() throws IllegalArgumentException {\n        if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n        }\n\n        if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n        }\n\n        if (commentMarker != null && delimiter == commentMarker.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n        }\n    }\n\n    \n    public CSVFormat withCommentMarker(final char commentMarker) {\n        return withCommentMarker(Character.valueOf(commentMarker));\n    }\n\n    \n    public CSVFormat withCommentMarker(final Character commentMarker) {\n        if (isLineBreak(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    \n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    \n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    \n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    \n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    \n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    \n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    \n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    \n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    \n    public CSVFormat withQuote(final char quoteChar) {\n        return withQuote(Character.valueOf(quoteChar));\n    }\n\n    \n    public CSVFormat withQuote(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    \n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    \n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    \n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    \n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n}\n",
      "buggy_signatures": [
        "private static boolean isLineBreak(final Character c)",
        "public static CSVFormat newFormat(final char delimiter)",
        "private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames)",
        "public boolean equals(final Object obj)",
        "public String format(final Object... values)",
        "public Character getCommentMarker()",
        "public char getDelimiter()",
        "public Character getEscapeCharacter()",
        "public String[] getHeader()",
        "public boolean getAllowMissingColumnNames()",
        "public boolean getIgnoreEmptyLines()",
        "public boolean getIgnoreSurroundingSpaces()",
        "public String getNullString()",
        "public Character getQuoteCharacter()",
        "public QuoteMode getQuoteMode()",
        "public String getRecordSeparator()",
        "public boolean getSkipHeaderRecord()",
        "public int hashCode()",
        "public boolean isCommentMarkerSet()",
        "public boolean isEscapeCharacterSet()",
        "public boolean isNullStringSet()",
        "public boolean isQuoteCharacterSet()",
        "public CSVParser parse(final Reader in) throws IOException",
        "public CSVPrinter print(final Appendable out) throws IOException",
        "public String toString()",
        "private void validate() throws IllegalArgumentException",
        "public CSVFormat withCommentMarker(final char commentMarker)",
        "public CSVFormat withCommentMarker(final Character commentMarker)",
        "public CSVFormat withDelimiter(final char delimiter)",
        "public CSVFormat withEscape(final char escape)",
        "public CSVFormat withEscape(final Character escape)",
        "public CSVFormat withHeader(final String... header)",
        "public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames)",
        "public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines)",
        "public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces)",
        "public CSVFormat withNullString(final String nullString)",
        "public CSVFormat withQuote(final char quoteChar)",
        "public CSVFormat withQuote(final Character quoteChar)",
        "public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy)",
        "public CSVFormat withRecordSeparator(final char recordSeparator)",
        "public CSVFormat withRecordSeparator(final String recordSeparator)",
        "public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord)"
      ],
      "fixed_signatures": [
        "private static boolean isLineBreak(final Character c)",
        "public static CSVFormat newFormat(final char delimiter)",
        "private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames)",
        "public boolean equals(final Object obj)",
        "public String format(final Object... values)",
        "public Character getCommentMarker()",
        "public char getDelimiter()",
        "public Character getEscapeCharacter()",
        "public String[] getHeader()",
        "public boolean getAllowMissingColumnNames()",
        "public boolean getIgnoreEmptyLines()",
        "public boolean getIgnoreSurroundingSpaces()",
        "public String getNullString()",
        "public Character getQuoteCharacter()",
        "public QuoteMode getQuoteMode()",
        "public String getRecordSeparator()",
        "public boolean getSkipHeaderRecord()",
        "public int hashCode()",
        "public boolean isCommentMarkerSet()",
        "public boolean isEscapeCharacterSet()",
        "public boolean isNullStringSet()",
        "public boolean isQuoteCharacterSet()",
        "public CSVParser parse(final Reader in) throws IOException",
        "public CSVPrinter print(final Appendable out) throws IOException",
        "public String toString()",
        "private void validate() throws IllegalArgumentException",
        "public CSVFormat withCommentMarker(final char commentMarker)",
        "public CSVFormat withCommentMarker(final Character commentMarker)",
        "public CSVFormat withDelimiter(final char delimiter)",
        "public CSVFormat withEscape(final char escape)",
        "public CSVFormat withEscape(final Character escape)",
        "public CSVFormat withHeader(final String... header)",
        "public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames)",
        "public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines)",
        "public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces)",
        "public CSVFormat withNullString(final String nullString)",
        "public CSVFormat withQuote(final char quoteChar)",
        "public CSVFormat withQuote(final Character quoteChar)",
        "public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy)",
        "public CSVFormat withRecordSeparator(final char recordSeparator)",
        "public CSVFormat withRecordSeparator(final String recordSeparator)",
        "public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord)"
      ],
      "methods": [
        {
          "buggy_method": "  public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); /** * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.",
          "fixed_method": "  public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); /** * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.",
          "diff": [
            "@@ -216,7 +216,7 @@",
            "      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n",
            "      * </p>\n",
            "      */\n",
            "-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n",
            "+    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true);\n",
            " \n",
            "     /**\n",
            "      * Tab-delimited format.\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
