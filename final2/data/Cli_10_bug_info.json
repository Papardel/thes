{
  "bug_id": "10",
  "failed_tests": {
    "org.apache.commons.cli.ParseRequiredTest": [
      {
        "methodName": "testReuseOptionsTwice",
        "error": "junit.framework.AssertionFailedError",
        "message": "MissingOptionException not thrown",
        "fail_line": "            fail(\"MissingOptionException not thrown\");",
        "test_source": "  public void testReuseOptionsTwice() throws Exception {\n  Options opts = new Options();\n\t\topts.addOption(OptionBuilder.isRequired().create('v'));\n\n\t\tGnuParser parser = new GnuParser();\n\n  // first parsing\n  parser.parse(opts, new String[] { \"-v\" });\n\n  try\n  {\n  // second parsing, with the same Options instance and an invalid command line\n  parser.parse(opts, new String[0]);\n  fail(\"MissingOptionException not thrown\");\n  }\n  catch (MissingOptionException e)\n  {\n  // expected\n  }\n  }",
        "stack": [
          "ParseRequiredTest.testReuseOptionsTwice line 157"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/cli/Parser.java",
      "buggy_full_code": "\npackage org.apache.commons.cli;\n\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Properties;\n\n\npublic abstract class Parser implements CommandLineParser { protected CommandLine cmd; private Options options; private List requiredOptions; protected void setOptions(final Options options) {\n        this.options = options;\n        this.requiredOptions = options.getRequiredOptions();\n    }\n\n    protected Options getOptions() {\n        return options;\n    }\n\n    protected List getRequiredOptions() {\n        return requiredOptions;\n    }\n\n\n    \n    protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption); public CommandLine parse(Options options, String[] arguments) throws ParseException {\n        return parse(options, arguments, null, false);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException {\n        return parse(options, arguments, properties, false);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException {\n        \n        for (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\n            Option opt = (Option) it.next();\n            opt.clearValues();\n        }\n\n        \n        setOptions(options);\n\n        cmd = new CommandLine();\n\n        boolean eatTheRest = false;\n\n        if (arguments == null)\n        {\n            arguments = new String[0];\n        }\n\n        List tokenList = Arrays.asList(flatten(getOptions(), \n                                               arguments, \n                                               stopAtNonOption));\n\n        ListIterator iterator = tokenList.listIterator();\n\n        \n        while (iterator.hasNext())\n        {\n            String t = (String) iterator.next();\n\n            \n            if (\"--\".equals(t))\n            {\n                eatTheRest = true;\n            }\n\n            \n            else if (\"-\".equals(t))\n            {\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n                else\n                {\n                    cmd.addArg(t);\n                }\n            }\n\n            \n            else if (t.startsWith(\"-\"))\n            {\n                if (stopAtNonOption && !getOptions().hasOption(t))\n                {\n                    eatTheRest = true;\n                    cmd.addArg(t);\n                }\n                else\n                {\n                    processOption(t, iterator);\n                }\n            }\n\n            \n            else\n            {\n                cmd.addArg(t);\n\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n            }\n\n            \n            if (eatTheRest)\n            {\n                while (iterator.hasNext())\n                {\n                    String str = (String) iterator.next();\n\n                    \n                    if (!\"--\".equals(str))\n                    {\n                        cmd.addArg(str);\n                    }\n                }\n            }\n        }\n\n        processProperties(properties);\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    \n    protected void processProperties(Properties properties) {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            if (!cmd.hasOption(option))\n            {\n                Option opt = getOptions().getOption(option);\n\n                \n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if ((opt.getValues() == null)\n                        || (opt.getValues().length == 0))\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            \n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value) \n                           || \"true\".equalsIgnoreCase(value)\n                           || \"1\".equalsIgnoreCase(value)))\n                {\n                    \n                    \n                    break;\n                }\n\n                cmd.addOption(opt);\n            }\n        }\n    }\n\n    \n    protected void checkRequiredOptions() throws MissingOptionException {\n        \n        \n        if (getRequiredOptions().size() > 0)\n        {\n            Iterator iter = getRequiredOptions().iterator();\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n\n\n            \n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n                buff.append(\", \");\n            }\n\n            throw new MissingOptionException(buff.substring(0, buff.length() - 2));\n        }\n    }\n\n    \n    public void processArgs(Option opt, ListIterator iter) throws ParseException {\n        \n        while (iter.hasNext())\n        {\n            String str = (String) iter.next();\n\n            \n            if (getOptions().hasOption(str) && str.startsWith(\"-\"))\n            {\n                iter.previous();\n                break;\n            }\n\n            \n            try\n            {\n                opt.addValueForProcessing( Util.stripLeadingAndTrailingQuotes(str) );\n            }\n            catch (RuntimeException exp)\n            {\n                iter.previous();\n                break;\n            }\n        }\n\n        if ((opt.getValues() == null) && !opt.hasOptionalArg())\n        {\n            throw new MissingArgumentException(\"Missing argument for option:\"\n                                               + opt.getKey());\n        }\n    }\n\n    \n    protected void processOption(String arg, ListIterator iter) throws ParseException {\n        boolean hasOption = getOptions().hasOption(arg);\n\n        \n        if (!hasOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" \n                                                  + arg);\n        }\n        \n        \n        final Option opt = getOptions().getOption(arg);\n\n        \n        \n        if (opt.isRequired())\n        {\n            getRequiredOptions().remove(opt.getKey());\n        }\n\n        \n        \n        if (getOptions().getOptionGroup(opt) != null)\n        {\n            OptionGroup group = getOptions().getOptionGroup(opt);\n\n            if (group.isRequired())\n            {\n                getRequiredOptions().remove(group);\n            }\n\n            group.setSelected(opt);\n        }\n\n        \n        if (opt.hasArg())\n        {\n            processArgs(opt, iter);\n        }\n\n\n        \n        cmd.addOption(opt);\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Properties;\n\n\npublic abstract class Parser implements CommandLineParser { protected CommandLine cmd; private Options options; private List requiredOptions; protected void setOptions(final Options options) {\n        this.options = options;\n        this.requiredOptions = new ArrayList(options.getRequiredOptions());\n    }\n\n    protected Options getOptions() {\n        return options;\n    }\n\n    protected List getRequiredOptions() {\n        return requiredOptions;\n    }\n\n\n    \n    protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption); public CommandLine parse(Options options, String[] arguments) throws ParseException {\n        return parse(options, arguments, null, false);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException {\n        return parse(options, arguments, properties, false);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    \n    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException {\n        \n        for (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\n            Option opt = (Option) it.next();\n            opt.clearValues();\n        }\n\n        \n        setOptions(options);\n\n        cmd = new CommandLine();\n\n        boolean eatTheRest = false;\n\n        if (arguments == null)\n        {\n            arguments = new String[0];\n        }\n\n        List tokenList = Arrays.asList(flatten(getOptions(), \n                                               arguments, \n                                               stopAtNonOption));\n\n        ListIterator iterator = tokenList.listIterator();\n\n        \n        while (iterator.hasNext())\n        {\n            String t = (String) iterator.next();\n\n            \n            if (\"--\".equals(t))\n            {\n                eatTheRest = true;\n            }\n\n            \n            else if (\"-\".equals(t))\n            {\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n                else\n                {\n                    cmd.addArg(t);\n                }\n            }\n\n            \n            else if (t.startsWith(\"-\"))\n            {\n                if (stopAtNonOption && !getOptions().hasOption(t))\n                {\n                    eatTheRest = true;\n                    cmd.addArg(t);\n                }\n                else\n                {\n                    processOption(t, iterator);\n                }\n            }\n\n            \n            else\n            {\n                cmd.addArg(t);\n\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n            }\n\n            \n            if (eatTheRest)\n            {\n                while (iterator.hasNext())\n                {\n                    String str = (String) iterator.next();\n\n                    \n                    if (!\"--\".equals(str))\n                    {\n                        cmd.addArg(str);\n                    }\n                }\n            }\n        }\n\n        processProperties(properties);\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    \n    protected void processProperties(Properties properties) {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            if (!cmd.hasOption(option))\n            {\n                Option opt = getOptions().getOption(option);\n\n                \n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if ((opt.getValues() == null)\n                        || (opt.getValues().length == 0))\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            \n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value) \n                           || \"true\".equalsIgnoreCase(value)\n                           || \"1\".equalsIgnoreCase(value)))\n                {\n                    \n                    \n                    break;\n                }\n\n                cmd.addOption(opt);\n            }\n        }\n    }\n\n    \n    protected void checkRequiredOptions() throws MissingOptionException {\n        \n        \n        if (getRequiredOptions().size() > 0)\n        {\n            Iterator iter = getRequiredOptions().iterator();\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n\n\n            \n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n                buff.append(\", \");\n            }\n\n            throw new MissingOptionException(buff.substring(0, buff.length() - 2));\n        }\n    }\n\n    \n    public void processArgs(Option opt, ListIterator iter) throws ParseException {\n        \n        while (iter.hasNext())\n        {\n            String str = (String) iter.next();\n\n            \n            if (getOptions().hasOption(str) && str.startsWith(\"-\"))\n            {\n                iter.previous();\n                break;\n            }\n\n            \n            try\n            {\n                opt.addValueForProcessing( Util.stripLeadingAndTrailingQuotes(str) );\n            }\n            catch (RuntimeException exp)\n            {\n                iter.previous();\n                break;\n            }\n        }\n\n        if ((opt.getValues() == null) && !opt.hasOptionalArg())\n        {\n            throw new MissingArgumentException(\"Missing argument for option:\"\n                                               + opt.getKey());\n        }\n    }\n\n    \n    protected void processOption(String arg, ListIterator iter) throws ParseException {\n        boolean hasOption = getOptions().hasOption(arg);\n\n        \n        if (!hasOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" \n                                                  + arg);\n        }\n        \n        \n        final Option opt = getOptions().getOption(arg);\n\n        \n        \n        if (opt.isRequired())\n        {\n            getRequiredOptions().remove(opt.getKey());\n        }\n\n        \n        \n        if (getOptions().getOptionGroup(opt) != null)\n        {\n            OptionGroup group = getOptions().getOptionGroup(opt);\n\n            if (group.isRequired())\n            {\n                getRequiredOptions().remove(group);\n            }\n\n            group.setSelected(opt);\n        }\n\n        \n        if (opt.hasArg())\n        {\n            processArgs(opt, iter);\n        }\n\n\n        \n        cmd.addOption(opt);\n    }\n}\n",
      "buggy_signatures": [
        "public abstract class Parser implements CommandLineParser { protected CommandLine cmd; private Options options; private List requiredOptions; protected void setOptions(final Options options)",
        "protected Options getOptions()",
        "protected List getRequiredOptions()",
        "protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption); public CommandLine parse(Options options, String[] arguments) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException",
        "protected void processProperties(Properties properties)",
        "protected void checkRequiredOptions() throws MissingOptionException",
        "public void processArgs(Option opt, ListIterator iter) throws ParseException",
        "protected void processOption(String arg, ListIterator iter) throws ParseException"
      ],
      "fixed_signatures": [
        "public abstract class Parser implements CommandLineParser { protected CommandLine cmd; private Options options; private List requiredOptions; protected void setOptions(final Options options)",
        "protected Options getOptions()",
        "protected List getRequiredOptions()",
        "protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption); public CommandLine parse(Options options, String[] arguments) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException",
        "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException",
        "protected void processProperties(Properties properties)",
        "protected void checkRequiredOptions() throws MissingOptionException",
        "public void processArgs(Option opt, ListIterator iter) throws ParseException",
        "protected void processOption(String arg, ListIterator iter) throws ParseException"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -16,6 +16,7 @@",
            "  */\n",
            " package org.apache.commons.cli;\n",
            " \n",
            "+import java.util.ArrayList;\n",
            " import java.util.Arrays;\n",
            " import java.util.Enumeration;\n",
            " import java.util.Iterator;\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  protected Options getOptions() {\n  return options;\n  }",
          "fixed_method": "  protected Options getOptions() {\n  return options;\n  }",
          "diff": [
            "@@ -43,7 +44,7 @@",
            " \n",
            "     protected void setOptions(final Options options) {\n",
            "         this.options = options;\n",
            "-        this.requiredOptions = options.getRequiredOptions();\n",
            "+        this.requiredOptions = new ArrayList(options.getRequiredOptions());\n",
            "     }\n",
            " \n",
            "     protected Options getOptions() {\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
