{
  "bug_id": "1",
  "failed_tests": {
    "com.google.javascript.jscomp.CommandLineRunnerTest": [
      {
        "methodName": "testSimpleModeLeavesUnusedParams",
        "error": "junit.framework.AssertionFailedError:",
        "message": "",
        "fail_line": "    testSame(\"window.f = function(a) {};\");",
        "test_source": "  public void testSimpleModeLeavesUnusedParams() {\n  args.add(\"--compilation_level=SIMPLE_OPTIMIZATIONS\");\n  testSame(\"window.f = function(a) {};\");\n  }",
        "stack": [
          "CommandLineRunnerTest.test line 1204, CommandLineRunnerTest.test line 1175, CommandLineRunnerTest.testSame line 1163, CommandLineRunnerTest.testSame line 1159, CommandLineRunnerTest.testSimpleModeLeavesUnusedParams line 156"
        ]
      },
      {
        "methodName": "testForwardDeclareDroppedTypes",
        "error": "junit.framework.AssertionFailedError:",
        "message": "",
        "fail_line": "    test(new String[] {",
        "test_source": "  public void testForwardDeclareDroppedTypes() {\n  args.add(\"--manage_closure_dependencies=true\");\n\n  args.add(\"--warning_level=VERBOSE\");\n  test(new String[] {\n  \"goog.require('beer');\",\n  \"goog.provide('beer'); /** @param {Scotch} x */ function f(x) {}\",\n  \"goog.provide('Scotch'); var x = 3;\"\n  },\n  new String[] {\n  \"var beer = {}; function f(a) {}\",\n  \"\"\n  });\n\n  test(new String[] {\n  \"goog.require('beer');\",\n  \"goog.provide('beer'); /** @param {Scotch} x */ function f(x) {}\"\n  },\n  new String[] {\n  \"var beer = {}; function f(a) {}\",\n  \"\"\n  },\n  RhinoErrorReporter.TYPE_PARSE_ERROR);\n  }",
        "stack": [
          "CommandLineRunnerTest.test line 1204, CommandLineRunnerTest.test line 1175, CommandLineRunnerTest.testForwardDeclareDroppedTypes line 754"
        ]
      },
      {
        "methodName": "testDebugFlag1",
        "error": "junit.framework.AssertionFailedError:",
        "message": "",
        "fail_line": "    test(\"function foo(a) {}\",",
        "test_source": "  public void testDebugFlag1() {\n  args.add(\"--compilation_level=SIMPLE_OPTIMIZATIONS\");\n  args.add(\"--debug=false\");\n  test(\"function foo(a) {}\",\n  \"function foo(a) {}\");\n  }",
        "stack": [
          "CommandLineRunnerTest.test line 1204, CommandLineRunnerTest.test line 1175, CommandLineRunnerTest.test line 1167, CommandLineRunnerTest.testDebugFlag1 line 476"
        ]
      }
    ],
    "com.google.javascript.jscomp.IntegrationTest": [
      {
        "methodName": "testIssue787",
        "error": "junit.framework.AssertionFailedError:",
        "message": "",
        "fail_line": "    test(options, code, result);",
        "test_source": "  public void testIssue787() {\n  CompilerOptions options = createCompilerOptions();\n  CompilationLevel level = CompilationLevel.SIMPLE_OPTIMIZATIONS;\n  level.setOptionsForCompilationLevel(options);\n  WarningLevel warnings = WarningLevel.DEFAULT;\n  warnings.setOptionsForWarningLevel(options);\n\n  String code = \"\" +\n  \"function some_function() {\\n\" +\n  \"  var fn1;\\n\" +\n  \"  var fn2;\\n\" +\n  \"\\n\" +\n  \"  if (any_expression) {\\n\" +\n  \"  fn2 = external_ref;\\n\" +\n  \"  fn1 = function (content) {\\n\" +\n  \"  return fn2();\\n\" +\n  \"  }\\n\" +\n  \"  }\\n\" +\n  \"\\n\" +\n  \"  return {\\n\" +\n  \"  method1: function () {\\n\" +\n  \"  if (fn1) fn1();\\n\" +\n  \"  return true;\\n\" +\n  \"  },\\n\" +\n  \"  method2: function () {\\n\" +\n  \"  return false;\\n\" +\n  \"  }\\n\" +\n  \"  }\\n\" +\n  \"}\";\n\n  String result = \"\" +\n  \"function some_function() {\\n\" +\n  \"  var a, b;\\n\" +\n  \"  any_expression && (b = external_ref, a = function(a) {\\n\" +\n  \"  return b()\\n\" +\n  \"  });\\n\" +\n  \"  return{method1:function() {\\n\" +\n  \"  a && a();\\n\" +\n  \"  return !0\\n\" +\n  \"  }, method2:function() {\\n\" +\n  \"  return !1\\n\" +\n  \"  }}\\n\" +\n  \"}\\n\" +\n  \"\";\n\n  test(options, code, result);\n  }",
        "stack": [
          "IntegrationTestCase.test line 97, IntegrationTestCase.test line 79, IntegrationTest.testIssue787 line 2371"
        ]
      }
    ],
    "com.google.javascript.jscomp.RemoveUnusedVarsTest": [
      {
        "methodName": "testRemoveGlobal1",
        "error": "junit.framework.AssertionFailedError:",
        "message": "",
        "fail_line": "    test(\"var y=function(x){var z;}\", \"var y=function(x){}\");",
        "test_source": "  public void testRemoveGlobal1() {\n  removeGlobal = false;\n  testSame(\"var x=1\");\n  test(\"var y=function(x){var z;}\", \"var y=function(x){}\");\n  }",
        "stack": [
          "CompilerTestCase.test line 905, CompilerTestCase.test line 447, CompilerTestCase.test line 373, CompilerTestCase.test line 342, CompilerTestCase.test line 330, RemoveUnusedVarsTest.testRemoveGlobal1 line 247"
        ]
      },
      {
        "methodName": "testRemoveGlobal2",
        "error": "junit.framework.AssertionFailedError:",
        "message": "",
        "fail_line": "    test(\"function y(x){var z;}\", \"function y(x){}\");",
        "test_source": "  public void testRemoveGlobal2() {\n  removeGlobal = false;\n  testSame(\"var x=1\");\n  test(\"function y(x){var z;}\", \"function y(x){}\");\n  }",
        "stack": [
          "CompilerTestCase.test line 905, CompilerTestCase.test line 447, CompilerTestCase.test line 373, CompilerTestCase.test line 342, CompilerTestCase.test line 330, RemoveUnusedVarsTest.testRemoveGlobal2 line 253"
        ]
      },
      {
        "methodName": "testRemoveGlobal3",
        "error": "junit.framework.AssertionFailedError:",
        "message": "",
        "fail_line": "    test(\"function x(){function y(x){var z;}y()}\",",
        "test_source": "  public void testRemoveGlobal3() {\n  removeGlobal = false;\n  testSame(\"var x=1\");\n  test(\"function x(){function y(x){var z;}y()}\",\n  \"function x(){function y(x){}y()}\");\n  }",
        "stack": [
          "CompilerTestCase.test line 905, CompilerTestCase.test line 447, CompilerTestCase.test line 373, CompilerTestCase.test line 342, CompilerTestCase.test line 330, RemoveUnusedVarsTest.testRemoveGlobal3 line 259"
        ]
      },
      {
        "methodName": "testIssue168b",
        "error": "junit.framework.AssertionFailedError:",
        "message": "",
        "fail_line": "    test(\"function a(){\" +",
        "test_source": "  public void testIssue168b() {\n  removeGlobal = false;\n  test(\"function a(){\" +\n  \"  (function(x){ b(); })(1);\" +\n  \"}\" +\n  \"function b(){\" +\n  \"  a();\" +\n  \"}\",\n  \"function a(){(function(x){b()})(1)}\" +\n  \"function b(){a()}\");\n  }",
        "stack": [
          "CompilerTestCase.test line 905, CompilerTestCase.test line 447, CompilerTestCase.test line 373, CompilerTestCase.test line 342, CompilerTestCase.test line 330, RemoveUnusedVarsTest.testIssue168b line 283"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/google/javascript/jscomp/RemoveUnusedVars.java",
      "buggy_full_code": "\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ArrayListMultimap;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Multimap;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.CodingConvention.SubclassRelationship;\nimport com.google.javascript.jscomp.DefinitionsRemover.Definition;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.*;\n\n\nclass RemoveUnusedVars\n    implements CompilerPass, OptimizeCalls.CallGraphCompilerPass {\n\n  private final AbstractCompiler compiler; private final CodingConvention codingConvention; private final boolean removeGlobals; private boolean preserveFunctionExpressionNames; private final Set<Var> referenced = Sets.newHashSet(); private final List<Var> maybeUnreferenced = Lists.newArrayList(); private final List<Scope> allFunctionScopes = Lists.newArrayList(); private final Multimap<Var, Assign> assignsByVar = ArrayListMultimap.create(); private final Map<Node, Assign> assignsByNode = Maps.newHashMap(); private final Multimap<Var, Node> classDefiningCalls = ArrayListMultimap.create(); private final Multimap<Var, Continuation> continuations = ArrayListMultimap.create(); private boolean modifyCallSites; private CallSiteOptimizer callSiteOptimizer; RemoveUnusedVars( AbstractCompiler compiler, boolean removeGlobals, boolean preserveFunctionExpressionNames, boolean modifyCallSites) {\n    this.compiler = compiler;\n    this.codingConvention = compiler.getCodingConvention();\n    this.removeGlobals = removeGlobals;\n    this.preserveFunctionExpressionNames = preserveFunctionExpressionNames;\n    this.modifyCallSites = modifyCallSites;\n  }\n\n  \n  @Override\n  public void process(Node externs, Node root) {\n    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n    SimpleDefinitionFinder defFinder = null;\n\n    if (modifyCallSites) {\n      \n      defFinder = new SimpleDefinitionFinder(compiler);\n      defFinder.process(externs, root);\n    }\n    process(externs, root, defFinder);\n  }\n\n  @Override\n  public void process( Node externs, Node root, SimpleDefinitionFinder defFinder) {\n    if (modifyCallSites) {\n      Preconditions.checkNotNull(defFinder);\n      callSiteOptimizer = new CallSiteOptimizer(compiler, defFinder);\n    }\n    traverseAndRemoveUnusedReferences(root);\n    if (callSiteOptimizer != null) {\n      callSiteOptimizer.applyChanges();\n    }\n  }\n\n  \n  private void traverseAndRemoveUnusedReferences(Node root) {\n    Scope scope = new SyntacticScopeCreator(compiler).createScope(root, null);\n    traverseNode(root, null, scope);\n\n    if (removeGlobals) {\n      collectMaybeUnreferencedVars(scope);\n    }\n\n    interpretAssigns();\n    removeUnreferencedVars();\n    for (Scope fnScope : allFunctionScopes) {\n      removeUnreferencedFunctionArgs(fnScope);\n    }\n  }\n\n  \n  private void traverseNode(Node n, Node parent, Scope scope) {\n    int type = n.getType();\n    Var var = null;\n    switch (type) {\n      case Token.FUNCTION:\n        \n        \n        if (NodeUtil.isFunctionDeclaration(n)) {\n          var = scope.getVar(n.getFirstChild().getString());\n        }\n\n        if (var != null && isRemovableVar(var)) {\n          continuations.put(var, new Continuation(n, scope));\n        } else {\n          traverseFunction(n, scope);\n        }\n        return;\n\n      case Token.ASSIGN:\n        Assign maybeAssign = Assign.maybeCreateAssign(n);\n        if (maybeAssign != null) {\n          \n          \n          var = scope.getVar(maybeAssign.nameNode.getString());\n          if (var != null) {\n            assignsByVar.put(var, maybeAssign);\n            assignsByNode.put(maybeAssign.nameNode, maybeAssign);\n\n            if (isRemovableVar(var) &&\n                !maybeAssign.mayHaveSecondarySideEffects) {\n              \n              \n              \n              continuations.put(var, new Continuation(n, scope));\n              return;\n            }\n          }\n        }\n        break;\n\n      case Token.CALL:\n        Var modifiedVar = null;\n\n        \n        SubclassRelationship subclassRelationship =\n            codingConvention.getClassesDefinedByCall(n);\n        if (subclassRelationship != null) {\n          modifiedVar = scope.getVar(subclassRelationship.subclassName);\n        } else {\n          \n          String className = codingConvention.getSingletonGetterClassName(n);\n          if (className != null) {\n            modifiedVar = scope.getVar(className);\n          }\n        }\n\n        \n        \n        \n        \n        if (modifiedVar != null && modifiedVar.isGlobal()\n            && !referenced.contains(modifiedVar)) {\n          \n          classDefiningCalls.put(modifiedVar, parent);\n          continuations.put(modifiedVar, new Continuation(n, scope));\n          return;\n        }\n        break;\n\n      case Token.NAME:\n        var = scope.getVar(n.getString());\n        if (parent.isVar()) {\n          Node value = n.getFirstChild();\n          if (value != null && var != null && isRemovableVar(var) &&\n              !NodeUtil.mayHaveSideEffects(value, compiler)) {\n            \n            \n            \n            continuations.put(var, new Continuation(n, scope));\n            return;\n          }\n        } else {\n\n          \n          \n          if (\"arguments\".equals(n.getString()) && scope.isLocal()) {\n            Node lp = scope.getRootNode().getFirstChild().getNext();\n            for (Node a = lp.getFirstChild(); a != null; a = a.getNext()) {\n              markReferencedVar(scope.getVar(a.getString()));\n            }\n          }\n\n          \n          \n          if (var != null) {\n            \n            \n            \n            if (isRemovableVar(var)) {\n              if (!assignsByNode.containsKey(n)) {\n                markReferencedVar(var);\n              }\n            } else {\n              markReferencedVar(var);\n            }\n          }\n        }\n        break;\n    }\n\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      traverseNode(c, n, scope);\n    }\n  }\n\n  private boolean isRemovableVar(Var var) {\n    \n    if (!removeGlobals && var.isGlobal()) {\n      return false;\n    }\n\n    \n    if (referenced.contains(var)) {\n      return false;\n    }\n\n    \n    if (codingConvention.isExported(var.getName())) {\n      return false;\n    }\n\n    return true;\n  }\n\n  \n  private void traverseFunction(Node n, Scope parentScope) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node body = n.getLastChild();\n    Preconditions.checkState(body.getNext() == null &&\n            body.isBlock());\n\n    Scope fnScope =\n        new SyntacticScopeCreator(compiler).createScope(n, parentScope);\n    traverseNode(body, n, fnScope);\n\n    collectMaybeUnreferencedVars(fnScope);\n    allFunctionScopes.add(fnScope);\n  }\n\n  \n  private void collectMaybeUnreferencedVars(Scope scope) {\n    for (Iterator<Var> it = scope.getVars(); it.hasNext(); ) {\n      Var var = it.next();\n      if (isRemovableVar(var)) {\n        maybeUnreferenced.add(var);\n      }\n    }\n  }\n\n  \n  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    Node function = fnScope.getRootNode();\n\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      \n      return;\n    }\n\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites\n        && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n      \n      Node lastArg;\n      while ((lastArg = argList.getLastChild()) != null) {\n        Var var = fnScope.getVar(lastArg.getString());\n        if (!referenced.contains(var)) {\n          argList.removeChild(lastArg);\n          compiler.reportCodeChange();\n        } else {\n          break;\n        }\n      }\n    } else {\n      callSiteOptimizer.optimize(fnScope, referenced);\n    }\n  }\n\n\n  \n  private static Node getFunctionArgList(Node function) {\n    return function.getFirstChild().getNext();\n  }\n\n  private static class CallSiteOptimizer { private final AbstractCompiler compiler; private final SimpleDefinitionFinder defFinder; private final List<Node> toRemove = Lists.newArrayList(); private final List<Node> toReplaceWithZero = Lists.newArrayList(); CallSiteOptimizer( AbstractCompiler compiler, SimpleDefinitionFinder defFinder) {\n      this.compiler = compiler;\n      this.defFinder = defFinder;\n    }\n\n    public void optimize(Scope fnScope, Set<Var> referenced) {\n      Node function = fnScope.getRootNode();\n      Preconditions.checkState(function.isFunction());\n      Node argList = getFunctionArgList(function);\n\n      \n      \n      boolean changeCallSignature = canChangeSignature(function);\n      markUnreferencedFunctionArgs(\n          fnScope, function, referenced,\n          argList.getFirstChild(), 0, changeCallSignature);\n    }\n\n    \n    public void applyChanges() {\n      for (Node n : toRemove) {\n        n.getParent().removeChild(n);\n        compiler.reportCodeChange();\n      }\n      for (Node n : toReplaceWithZero) {\n        n.getParent().replaceChild(n, IR.number(0).srcref(n));\n        compiler.reportCodeChange();\n      }\n    }\n\n    \n    private boolean markUnreferencedFunctionArgs( Scope scope, Node function, Set<Var> referenced, Node param, int paramIndex, boolean canChangeSignature) {\n      if (param != null) {\n        \n        boolean hasFollowing = markUnreferencedFunctionArgs(\n            scope, function, referenced, param.getNext(), paramIndex+1,\n            canChangeSignature);\n\n        Var var = scope.getVar(param.getString());\n        if (!referenced.contains(var)) {\n          Preconditions.checkNotNull(var);\n\n          \n          \n          boolean modifyAllCallSites = canChangeSignature || !hasFollowing;\n          if (modifyAllCallSites) {\n            modifyAllCallSites = canRemoveArgFromCallSites(\n                function, paramIndex);\n          }\n\n          tryRemoveArgFromCallSites(function, paramIndex, modifyAllCallSites);\n\n          \n          \n          if (modifyAllCallSites || !hasFollowing) {\n            toRemove.add(param);\n            return hasFollowing;\n          }\n        }\n        return true;\n      } else {\n        \n        \n        tryRemoveAllFollowingArgs(function, paramIndex-1);\n        return false;\n      }\n    }\n\n    \n    private boolean canRemoveArgFromCallSites(Node function, int argIndex) {\n      Definition definition = getFunctionDefinition(function);\n\n      \n      for (UseSite site : defFinder.getUseSites(definition)) {\n        if (isModifiableCallSite(site)) {\n          Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex);\n          \n          \n          if (arg != null && NodeUtil.mayHaveSideEffects(arg, compiler)) {\n            return false;\n          }\n        } else {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    \n    private void tryRemoveArgFromCallSites( Node function, int argIndex, boolean canModifyAllSites) {\n      Definition definition = getFunctionDefinition(function);\n\n      for (UseSite site : defFinder.getUseSites(definition)) {\n        if (isModifiableCallSite(site)) {\n          Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex);\n          if (arg != null) {\n            Node argParent = arg.getParent();\n            \n            \n            if (canModifyAllSites\n                || (arg.getNext() == null\n                    && !NodeUtil.mayHaveSideEffects(arg, compiler))) {\n              toRemove.add(arg);\n            } else {\n              \n              if (!NodeUtil.mayHaveSideEffects(arg, compiler)\n                  && (!arg.isNumber() || arg.getDouble() != 0)) {\n                toReplaceWithZero.add(arg);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    \n    private void tryRemoveAllFollowingArgs(Node function, final int argIndex) {\n      Definition definition = getFunctionDefinition(function);\n      for (UseSite site : defFinder.getUseSites(definition)) {\n        if (!isModifiableCallSite(site)) {\n          continue;\n        }\n        Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex + 1);\n        while (arg != null) {\n          if (!NodeUtil.mayHaveSideEffects(arg)) {\n            toRemove.add(arg);\n          }\n          arg = arg.getNext();\n        }\n      }\n    }\n\n    \n    private static Node getArgumentForCallOrNewOrDotCall(UseSite site, final int argIndex) {\n      int adjustedArgIndex = argIndex;\n      Node parent = site.node.getParent();\n      if (NodeUtil.isFunctionObjectCall(parent)) {\n        adjustedArgIndex++;\n      }\n      return NodeUtil.getArgumentForCallOrNew(parent, adjustedArgIndex);\n    }\n\n    \n    boolean canModifyCallers(Node function) {\n      if (NodeUtil.isVarArgsFunction(function)) {\n        return false;\n      }\n\n      DefinitionSite defSite = defFinder.getDefinitionForFunction(function);\n      if (defSite == null) {\n        return false;\n      }\n\n      Definition definition = defSite.definition;\n\n      \n      \n      if (!SimpleDefinitionFinder.isSimpleFunctionDeclaration(function)) {\n        return false;\n      }\n\n      return defFinder.canModifyDefinition(definition);\n    }\n\n    \n    private static boolean isModifiableCallSite(UseSite site) {\n      return SimpleDefinitionFinder.isCallOrNewSite(site)\n          && !NodeUtil.isFunctionObjectApply(site.node.getParent());\n    }\n\n    \n    private boolean canChangeSignature(Node function) {\n      Definition definition = getFunctionDefinition(function);\n      CodingConvention convention = compiler.getCodingConvention();\n\n      Preconditions.checkState(!definition.isExtern());\n\n      Collection<UseSite> useSites = defFinder.getUseSites(definition);\n      for (UseSite site : useSites) {\n        Node parent = site.node.getParent();\n\n        \n        \n        \n        \n        if (parent == null) {\n          continue; \n        }\n\n        \n        if (parent.isCall() &&\n            convention.getClassesDefinedByCall(parent) != null) {\n          continue;\n        }\n\n        \n        if (!SimpleDefinitionFinder.isCallOrNewSite(site)) {\n          if (!(parent.isGetProp() &&\n              NodeUtil.isFunctionObjectCall(parent.getParent()))) {\n            return false;\n          }\n        }\n\n        if (NodeUtil.isFunctionObjectApply(parent)) {\n          return false;\n        }\n\n        \n\n        \n        \n        Node nameNode = site.node;\n        Collection<Definition> singleSiteDefinitions =\n            defFinder.getDefinitionsReferencedAt(nameNode);\n        Preconditions.checkState(singleSiteDefinitions.size() == 1);\n        Preconditions.checkState(singleSiteDefinitions.contains(definition));\n      }\n\n      return true;\n    }\n\n    \n    private Definition getFunctionDefinition(Node function) {\n      DefinitionSite definitionSite = defFinder.getDefinitionForFunction(\n          function);\n      Preconditions.checkNotNull(definitionSite);\n      Definition definition = definitionSite.definition;\n      Preconditions.checkState(!definitionSite.inExterns);\n      Preconditions.checkState(definition.getRValue() == function);\n      return definition;\n    }\n  }\n\n\n  \n  private void interpretAssigns() {\n    boolean changes = false;\n    do {\n      changes = false;\n\n      \n      \n      \n      for (int current = 0; current < maybeUnreferenced.size(); current++) {\n        Var var = maybeUnreferenced.get(current);\n        if (referenced.contains(var)) {\n          maybeUnreferenced.remove(current);\n          current--;\n        } else {\n          boolean assignedToUnknownValue = false;\n          boolean hasPropertyAssign = false;\n\n          if (var.getParentNode().isVar() &&\n              !NodeUtil.isForIn(var.getParentNode().getParent())) {\n            Node value = var.getInitialValue();\n            assignedToUnknownValue = value != null &&\n                !NodeUtil.isLiteralValue(value, true);\n          } else {\n            \n            \n            assignedToUnknownValue = true;\n          }\n\n          boolean maybeEscaped = false;\n          for (Assign assign : assignsByVar.get(var)) {\n            if (assign.isPropertyAssign) {\n              hasPropertyAssign = true;\n            } else if (!NodeUtil.isLiteralValue(\n                assign.assignNode.getLastChild(), true)) {\n              assignedToUnknownValue = true;\n            }\n            if (assign.maybeAliased) {\n              maybeEscaped = true;\n            }\n          }\n\n          if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) {\n            changes = markReferencedVar(var) || changes;\n            maybeUnreferenced.remove(current);\n            current--;\n          }\n        }\n      }\n    } while (changes);\n  }\n\n  \n  private void removeAllAssigns(Var var) {\n    for (Assign assign : assignsByVar.get(var)) {\n      assign.remove();\n      compiler.reportCodeChange();\n    }\n  }\n\n  \n  private boolean markReferencedVar(Var var) {\n    if (referenced.add(var)) {\n      for (Continuation c : continuations.get(var)) {\n        c.apply();\n      }\n      return true;\n    }\n    return false;\n  }\n\n  \n  private void removeUnreferencedVars() {\n    CodingConvention convention = codingConvention;\n\n    for (Iterator<Var> it = maybeUnreferenced.iterator(); it.hasNext(); ) {\n      Var var = it.next();\n\n      \n      \n      for (Node exprCallNode : classDefiningCalls.get(var)) {\n        NodeUtil.removeChild(exprCallNode.getParent(), exprCallNode);\n        compiler.reportCodeChange();\n      }\n\n      \n      \n      \n      removeAllAssigns(var);\n\n      compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n      Node nameNode = var.nameNode;\n      Node toRemove = nameNode.getParent();\n      Node parent = toRemove.getParent();\n\n      Preconditions.checkState(\n          toRemove.isVar() ||\n          toRemove.isFunction() ||\n          toRemove.isParamList() &&\n          parent.isFunction(),\n          \"We should only declare vars and functions and function args\");\n\n      if (toRemove.isParamList() &&\n          parent.isFunction()) {\n        \n        \n      } else if (NodeUtil.isFunctionExpression(toRemove)) {\n        if (!preserveFunctionExpressionNames) {\n          toRemove.getFirstChild().setString(\"\");\n          compiler.reportCodeChange();\n        }\n        \n      } else if (parent != null &&\n          parent.isFor() &&\n          parent.getChildCount() < 4) {\n        \n      } else if (toRemove.isVar() &&\n          nameNode.hasChildren() &&\n          NodeUtil.mayHaveSideEffects(nameNode.getFirstChild(), compiler)) {\n        \n        \n        \n        if (toRemove.getChildCount() == 1) {\n          parent.replaceChild(toRemove,\n              IR.exprResult(nameNode.removeFirstChild()));\n          compiler.reportCodeChange();\n        }\n      } else if (toRemove.isVar() &&\n          toRemove.getChildCount() > 1) {\n        \n        \n        toRemove.removeChild(nameNode);\n        compiler.reportCodeChange();\n      } else if (parent != null) {\n        NodeUtil.removeChild(parent, toRemove);\n        compiler.reportCodeChange();\n      }\n    }\n  }\n\n  \n  private class Continuation { private final Node node; private final Scope scope; Continuation(Node node, Scope scope) {\n      this.node = node;\n      this.scope = scope;\n    }\n\n    void apply() {\n      if (NodeUtil.isFunctionDeclaration(node)) {\n        traverseFunction(node, scope);\n      } else {\n        for (Node child = node.getFirstChild();\n             child != null; child = child.getNext()) {\n          traverseNode(child, node, scope);\n        }\n      }\n    }\n  }\n\n  private static class Assign { final Node assignNode; final Node nameNode; final boolean isPropertyAssign; final boolean mayHaveSecondarySideEffects; final boolean maybeAliased; Assign(Node assignNode, Node nameNode, boolean isPropertyAssign) {\n      Preconditions.checkState(NodeUtil.isAssignmentOp(assignNode));\n      this.assignNode = assignNode;\n      this.nameNode = nameNode;\n      this.isPropertyAssign = isPropertyAssign;\n\n      this.maybeAliased = NodeUtil.isExpressionResultUsed(assignNode);\n      this.mayHaveSecondarySideEffects =\n          maybeAliased ||\n          NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||\n          NodeUtil.mayHaveSideEffects(assignNode.getLastChild());\n    }\n\n    \n    static Assign maybeCreateAssign(Node assignNode) {\n      Preconditions.checkState(NodeUtil.isAssignmentOp(assignNode));\n\n      \n      \n      \n      \n      \n      boolean isPropAssign = false;\n      Node current = assignNode.getFirstChild();\n      if (NodeUtil.isGet(current)) {\n        current = current.getFirstChild();\n        isPropAssign = true;\n\n        if (current.isGetProp() &&\n            current.getLastChild().getString().equals(\"prototype\")) {\n          \n          \n          current = current.getFirstChild();\n        }\n      }\n\n      if (current.isName()) {\n        return new Assign(assignNode, current, isPropAssign);\n      }\n      return null;\n    }\n\n    \n    void remove() {\n      Node parent = assignNode.getParent();\n      if (mayHaveSecondarySideEffects) {\n        Node replacement = assignNode.getLastChild().detachFromParent();\n\n        \n        for (Node current = assignNode.getFirstChild();\n             !current.isName();\n             current = current.getFirstChild()) {\n          if (current.isGetElem()) {\n            replacement = IR.comma(\n                current.getLastChild().detachFromParent(), replacement);\n            replacement.copyInformationFrom(current);\n          }\n        }\n\n        parent.replaceChild(assignNode, replacement);\n      } else {\n        Node gramps = parent.getParent();\n        if (parent.isExprResult()) {\n          gramps.removeChild(parent);\n        } else {\n          parent.replaceChild(assignNode,\n              assignNode.getLastChild().detachFromParent());\n        }\n      }\n    }\n  }\n}\n",
      "fixed_full_code": "\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ArrayListMultimap;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Multimap;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.CodingConvention.SubclassRelationship;\nimport com.google.javascript.jscomp.DefinitionsRemover.Definition;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.*;\n\n\nclass RemoveUnusedVars\n    implements CompilerPass, OptimizeCalls.CallGraphCompilerPass {\n\n  private final AbstractCompiler compiler; private final CodingConvention codingConvention; private final boolean removeGlobals; private boolean preserveFunctionExpressionNames; private final Set<Var> referenced = Sets.newHashSet(); private final List<Var> maybeUnreferenced = Lists.newArrayList(); private final List<Scope> allFunctionScopes = Lists.newArrayList(); private final Multimap<Var, Assign> assignsByVar = ArrayListMultimap.create(); private final Map<Node, Assign> assignsByNode = Maps.newHashMap(); private final Multimap<Var, Node> classDefiningCalls = ArrayListMultimap.create(); private final Multimap<Var, Continuation> continuations = ArrayListMultimap.create(); private boolean modifyCallSites; private CallSiteOptimizer callSiteOptimizer; RemoveUnusedVars( AbstractCompiler compiler, boolean removeGlobals, boolean preserveFunctionExpressionNames, boolean modifyCallSites) {\n    this.compiler = compiler;\n    this.codingConvention = compiler.getCodingConvention();\n    this.removeGlobals = removeGlobals;\n    this.preserveFunctionExpressionNames = preserveFunctionExpressionNames;\n    this.modifyCallSites = modifyCallSites;\n  }\n\n  \n  @Override\n  public void process(Node externs, Node root) {\n    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n    SimpleDefinitionFinder defFinder = null;\n\n    if (modifyCallSites) {\n      \n      defFinder = new SimpleDefinitionFinder(compiler);\n      defFinder.process(externs, root);\n    }\n    process(externs, root, defFinder);\n  }\n\n  @Override\n  public void process( Node externs, Node root, SimpleDefinitionFinder defFinder) {\n    if (modifyCallSites) {\n      Preconditions.checkNotNull(defFinder);\n      callSiteOptimizer = new CallSiteOptimizer(compiler, defFinder);\n    }\n    traverseAndRemoveUnusedReferences(root);\n    if (callSiteOptimizer != null) {\n      callSiteOptimizer.applyChanges();\n    }\n  }\n\n  \n  private void traverseAndRemoveUnusedReferences(Node root) {\n    Scope scope = new SyntacticScopeCreator(compiler).createScope(root, null);\n    traverseNode(root, null, scope);\n\n    if (removeGlobals) {\n      collectMaybeUnreferencedVars(scope);\n    }\n\n    interpretAssigns();\n    removeUnreferencedVars();\n    for (Scope fnScope : allFunctionScopes) {\n      removeUnreferencedFunctionArgs(fnScope);\n    }\n  }\n\n  \n  private void traverseNode(Node n, Node parent, Scope scope) {\n    int type = n.getType();\n    Var var = null;\n    switch (type) {\n      case Token.FUNCTION:\n        \n        \n        if (NodeUtil.isFunctionDeclaration(n)) {\n          var = scope.getVar(n.getFirstChild().getString());\n        }\n\n        if (var != null && isRemovableVar(var)) {\n          continuations.put(var, new Continuation(n, scope));\n        } else {\n          traverseFunction(n, scope);\n        }\n        return;\n\n      case Token.ASSIGN:\n        Assign maybeAssign = Assign.maybeCreateAssign(n);\n        if (maybeAssign != null) {\n          \n          \n          var = scope.getVar(maybeAssign.nameNode.getString());\n          if (var != null) {\n            assignsByVar.put(var, maybeAssign);\n            assignsByNode.put(maybeAssign.nameNode, maybeAssign);\n\n            if (isRemovableVar(var) &&\n                !maybeAssign.mayHaveSecondarySideEffects) {\n              \n              \n              \n              continuations.put(var, new Continuation(n, scope));\n              return;\n            }\n          }\n        }\n        break;\n\n      case Token.CALL:\n        Var modifiedVar = null;\n\n        \n        SubclassRelationship subclassRelationship =\n            codingConvention.getClassesDefinedByCall(n);\n        if (subclassRelationship != null) {\n          modifiedVar = scope.getVar(subclassRelationship.subclassName);\n        } else {\n          \n          String className = codingConvention.getSingletonGetterClassName(n);\n          if (className != null) {\n            modifiedVar = scope.getVar(className);\n          }\n        }\n\n        \n        \n        \n        \n        if (modifiedVar != null && modifiedVar.isGlobal()\n            && !referenced.contains(modifiedVar)) {\n          \n          classDefiningCalls.put(modifiedVar, parent);\n          continuations.put(modifiedVar, new Continuation(n, scope));\n          return;\n        }\n        break;\n\n      case Token.NAME:\n        var = scope.getVar(n.getString());\n        if (parent.isVar()) {\n          Node value = n.getFirstChild();\n          if (value != null && var != null && isRemovableVar(var) &&\n              !NodeUtil.mayHaveSideEffects(value, compiler)) {\n            \n            \n            \n            continuations.put(var, new Continuation(n, scope));\n            return;\n          }\n        } else {\n\n          \n          \n          if (\"arguments\".equals(n.getString()) && scope.isLocal()) {\n            Node lp = scope.getRootNode().getFirstChild().getNext();\n            for (Node a = lp.getFirstChild(); a != null; a = a.getNext()) {\n              markReferencedVar(scope.getVar(a.getString()));\n            }\n          }\n\n          \n          \n          if (var != null) {\n            \n            \n            \n            if (isRemovableVar(var)) {\n              if (!assignsByNode.containsKey(n)) {\n                markReferencedVar(var);\n              }\n            } else {\n              markReferencedVar(var);\n            }\n          }\n        }\n        break;\n    }\n\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      traverseNode(c, n, scope);\n    }\n  }\n\n  private boolean isRemovableVar(Var var) {\n    \n    if (!removeGlobals && var.isGlobal()) {\n      return false;\n    }\n\n    \n    if (referenced.contains(var)) {\n      return false;\n    }\n\n    \n    if (codingConvention.isExported(var.getName())) {\n      return false;\n    }\n\n    return true;\n  }\n\n  \n  private void traverseFunction(Node n, Scope parentScope) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node body = n.getLastChild();\n    Preconditions.checkState(body.getNext() == null &&\n            body.isBlock());\n\n    Scope fnScope =\n        new SyntacticScopeCreator(compiler).createScope(n, parentScope);\n    traverseNode(body, n, fnScope);\n\n    collectMaybeUnreferencedVars(fnScope);\n    allFunctionScopes.add(fnScope);\n  }\n\n  \n  private void collectMaybeUnreferencedVars(Scope scope) {\n    for (Iterator<Var> it = scope.getVars(); it.hasNext(); ) {\n      Var var = it.next();\n      if (isRemovableVar(var)) {\n        maybeUnreferenced.add(var);\n      }\n    }\n  }\n\n  \n  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    if (!removeGlobals) {\n      return;\n    }\n\n    Node function = fnScope.getRootNode();\n\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      \n      return;\n    }\n\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites\n        && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n      \n      Node lastArg;\n      while ((lastArg = argList.getLastChild()) != null) {\n        Var var = fnScope.getVar(lastArg.getString());\n        if (!referenced.contains(var)) {\n          argList.removeChild(lastArg);\n          compiler.reportCodeChange();\n        } else {\n          break;\n        }\n      }\n    } else {\n      callSiteOptimizer.optimize(fnScope, referenced);\n    }\n  }\n\n\n  \n  private static Node getFunctionArgList(Node function) {\n    return function.getFirstChild().getNext();\n  }\n\n  private static class CallSiteOptimizer { private final AbstractCompiler compiler; private final SimpleDefinitionFinder defFinder; private final List<Node> toRemove = Lists.newArrayList(); private final List<Node> toReplaceWithZero = Lists.newArrayList(); CallSiteOptimizer( AbstractCompiler compiler, SimpleDefinitionFinder defFinder) {\n      this.compiler = compiler;\n      this.defFinder = defFinder;\n    }\n\n    public void optimize(Scope fnScope, Set<Var> referenced) {\n      Node function = fnScope.getRootNode();\n      Preconditions.checkState(function.isFunction());\n      Node argList = getFunctionArgList(function);\n\n      \n      \n      boolean changeCallSignature = canChangeSignature(function);\n      markUnreferencedFunctionArgs(\n          fnScope, function, referenced,\n          argList.getFirstChild(), 0, changeCallSignature);\n    }\n\n    \n    public void applyChanges() {\n      for (Node n : toRemove) {\n        n.getParent().removeChild(n);\n        compiler.reportCodeChange();\n      }\n      for (Node n : toReplaceWithZero) {\n        n.getParent().replaceChild(n, IR.number(0).srcref(n));\n        compiler.reportCodeChange();\n      }\n    }\n\n    \n    private boolean markUnreferencedFunctionArgs( Scope scope, Node function, Set<Var> referenced, Node param, int paramIndex, boolean canChangeSignature) {\n      if (param != null) {\n        \n        boolean hasFollowing = markUnreferencedFunctionArgs(\n            scope, function, referenced, param.getNext(), paramIndex+1,\n            canChangeSignature);\n\n        Var var = scope.getVar(param.getString());\n        if (!referenced.contains(var)) {\n          Preconditions.checkNotNull(var);\n\n          \n          \n          boolean modifyAllCallSites = canChangeSignature || !hasFollowing;\n          if (modifyAllCallSites) {\n            modifyAllCallSites = canRemoveArgFromCallSites(\n                function, paramIndex);\n          }\n\n          tryRemoveArgFromCallSites(function, paramIndex, modifyAllCallSites);\n\n          \n          \n          if (modifyAllCallSites || !hasFollowing) {\n            toRemove.add(param);\n            return hasFollowing;\n          }\n        }\n        return true;\n      } else {\n        \n        \n        tryRemoveAllFollowingArgs(function, paramIndex-1);\n        return false;\n      }\n    }\n\n    \n    private boolean canRemoveArgFromCallSites(Node function, int argIndex) {\n      Definition definition = getFunctionDefinition(function);\n\n      \n      for (UseSite site : defFinder.getUseSites(definition)) {\n        if (isModifiableCallSite(site)) {\n          Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex);\n          \n          \n          if (arg != null && NodeUtil.mayHaveSideEffects(arg, compiler)) {\n            return false;\n          }\n        } else {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    \n    private void tryRemoveArgFromCallSites( Node function, int argIndex, boolean canModifyAllSites) {\n      Definition definition = getFunctionDefinition(function);\n\n      for (UseSite site : defFinder.getUseSites(definition)) {\n        if (isModifiableCallSite(site)) {\n          Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex);\n          if (arg != null) {\n            Node argParent = arg.getParent();\n            \n            \n            if (canModifyAllSites\n                || (arg.getNext() == null\n                    && !NodeUtil.mayHaveSideEffects(arg, compiler))) {\n              toRemove.add(arg);\n            } else {\n              \n              if (!NodeUtil.mayHaveSideEffects(arg, compiler)\n                  && (!arg.isNumber() || arg.getDouble() != 0)) {\n                toReplaceWithZero.add(arg);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    \n    private void tryRemoveAllFollowingArgs(Node function, final int argIndex) {\n      Definition definition = getFunctionDefinition(function);\n      for (UseSite site : defFinder.getUseSites(definition)) {\n        if (!isModifiableCallSite(site)) {\n          continue;\n        }\n        Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex + 1);\n        while (arg != null) {\n          if (!NodeUtil.mayHaveSideEffects(arg)) {\n            toRemove.add(arg);\n          }\n          arg = arg.getNext();\n        }\n      }\n    }\n\n    \n    private static Node getArgumentForCallOrNewOrDotCall(UseSite site, final int argIndex) {\n      int adjustedArgIndex = argIndex;\n      Node parent = site.node.getParent();\n      if (NodeUtil.isFunctionObjectCall(parent)) {\n        adjustedArgIndex++;\n      }\n      return NodeUtil.getArgumentForCallOrNew(parent, adjustedArgIndex);\n    }\n\n    \n    boolean canModifyCallers(Node function) {\n      if (NodeUtil.isVarArgsFunction(function)) {\n        return false;\n      }\n\n      DefinitionSite defSite = defFinder.getDefinitionForFunction(function);\n      if (defSite == null) {\n        return false;\n      }\n\n      Definition definition = defSite.definition;\n\n      \n      \n      if (!SimpleDefinitionFinder.isSimpleFunctionDeclaration(function)) {\n        return false;\n      }\n\n      return defFinder.canModifyDefinition(definition);\n    }\n\n    \n    private static boolean isModifiableCallSite(UseSite site) {\n      return SimpleDefinitionFinder.isCallOrNewSite(site)\n          && !NodeUtil.isFunctionObjectApply(site.node.getParent());\n    }\n\n    \n    private boolean canChangeSignature(Node function) {\n      Definition definition = getFunctionDefinition(function);\n      CodingConvention convention = compiler.getCodingConvention();\n\n      Preconditions.checkState(!definition.isExtern());\n\n      Collection<UseSite> useSites = defFinder.getUseSites(definition);\n      for (UseSite site : useSites) {\n        Node parent = site.node.getParent();\n\n        \n        \n        \n        \n        if (parent == null) {\n          continue; \n        }\n\n        \n        if (parent.isCall() &&\n            convention.getClassesDefinedByCall(parent) != null) {\n          continue;\n        }\n\n        \n        if (!SimpleDefinitionFinder.isCallOrNewSite(site)) {\n          if (!(parent.isGetProp() &&\n              NodeUtil.isFunctionObjectCall(parent.getParent()))) {\n            return false;\n          }\n        }\n\n        if (NodeUtil.isFunctionObjectApply(parent)) {\n          return false;\n        }\n\n        \n\n        \n        \n        Node nameNode = site.node;\n        Collection<Definition> singleSiteDefinitions =\n            defFinder.getDefinitionsReferencedAt(nameNode);\n        Preconditions.checkState(singleSiteDefinitions.size() == 1);\n        Preconditions.checkState(singleSiteDefinitions.contains(definition));\n      }\n\n      return true;\n    }\n\n    \n    private Definition getFunctionDefinition(Node function) {\n      DefinitionSite definitionSite = defFinder.getDefinitionForFunction(\n          function);\n      Preconditions.checkNotNull(definitionSite);\n      Definition definition = definitionSite.definition;\n      Preconditions.checkState(!definitionSite.inExterns);\n      Preconditions.checkState(definition.getRValue() == function);\n      return definition;\n    }\n  }\n\n\n  \n  private void interpretAssigns() {\n    boolean changes = false;\n    do {\n      changes = false;\n\n      \n      \n      \n      for (int current = 0; current < maybeUnreferenced.size(); current++) {\n        Var var = maybeUnreferenced.get(current);\n        if (referenced.contains(var)) {\n          maybeUnreferenced.remove(current);\n          current--;\n        } else {\n          boolean assignedToUnknownValue = false;\n          boolean hasPropertyAssign = false;\n\n          if (var.getParentNode().isVar() &&\n              !NodeUtil.isForIn(var.getParentNode().getParent())) {\n            Node value = var.getInitialValue();\n            assignedToUnknownValue = value != null &&\n                !NodeUtil.isLiteralValue(value, true);\n          } else {\n            \n            \n            assignedToUnknownValue = true;\n          }\n\n          boolean maybeEscaped = false;\n          for (Assign assign : assignsByVar.get(var)) {\n            if (assign.isPropertyAssign) {\n              hasPropertyAssign = true;\n            } else if (!NodeUtil.isLiteralValue(\n                assign.assignNode.getLastChild(), true)) {\n              assignedToUnknownValue = true;\n            }\n            if (assign.maybeAliased) {\n              maybeEscaped = true;\n            }\n          }\n\n          if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) {\n            changes = markReferencedVar(var) || changes;\n            maybeUnreferenced.remove(current);\n            current--;\n          }\n        }\n      }\n    } while (changes);\n  }\n\n  \n  private void removeAllAssigns(Var var) {\n    for (Assign assign : assignsByVar.get(var)) {\n      assign.remove();\n      compiler.reportCodeChange();\n    }\n  }\n\n  \n  private boolean markReferencedVar(Var var) {\n    if (referenced.add(var)) {\n      for (Continuation c : continuations.get(var)) {\n        c.apply();\n      }\n      return true;\n    }\n    return false;\n  }\n\n  \n  private void removeUnreferencedVars() {\n    CodingConvention convention = codingConvention;\n\n    for (Iterator<Var> it = maybeUnreferenced.iterator(); it.hasNext(); ) {\n      Var var = it.next();\n\n      \n      \n      for (Node exprCallNode : classDefiningCalls.get(var)) {\n        NodeUtil.removeChild(exprCallNode.getParent(), exprCallNode);\n        compiler.reportCodeChange();\n      }\n\n      \n      \n      \n      removeAllAssigns(var);\n\n      compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n      Node nameNode = var.nameNode;\n      Node toRemove = nameNode.getParent();\n      Node parent = toRemove.getParent();\n\n      Preconditions.checkState(\n          toRemove.isVar() ||\n          toRemove.isFunction() ||\n          toRemove.isParamList() &&\n          parent.isFunction(),\n          \"We should only declare vars and functions and function args\");\n\n      if (toRemove.isParamList() &&\n          parent.isFunction()) {\n        \n        \n      } else if (NodeUtil.isFunctionExpression(toRemove)) {\n        if (!preserveFunctionExpressionNames) {\n          toRemove.getFirstChild().setString(\"\");\n          compiler.reportCodeChange();\n        }\n        \n      } else if (parent != null &&\n          parent.isFor() &&\n          parent.getChildCount() < 4) {\n        \n      } else if (toRemove.isVar() &&\n          nameNode.hasChildren() &&\n          NodeUtil.mayHaveSideEffects(nameNode.getFirstChild(), compiler)) {\n        \n        \n        \n        if (toRemove.getChildCount() == 1) {\n          parent.replaceChild(toRemove,\n              IR.exprResult(nameNode.removeFirstChild()));\n          compiler.reportCodeChange();\n        }\n      } else if (toRemove.isVar() &&\n          toRemove.getChildCount() > 1) {\n        \n        \n        toRemove.removeChild(nameNode);\n        compiler.reportCodeChange();\n      } else if (parent != null) {\n        NodeUtil.removeChild(parent, toRemove);\n        compiler.reportCodeChange();\n      }\n    }\n  }\n\n  \n  private class Continuation { private final Node node; private final Scope scope; Continuation(Node node, Scope scope) {\n      this.node = node;\n      this.scope = scope;\n    }\n\n    void apply() {\n      if (NodeUtil.isFunctionDeclaration(node)) {\n        traverseFunction(node, scope);\n      } else {\n        for (Node child = node.getFirstChild();\n             child != null; child = child.getNext()) {\n          traverseNode(child, node, scope);\n        }\n      }\n    }\n  }\n\n  private static class Assign { final Node assignNode; final Node nameNode; final boolean isPropertyAssign; final boolean mayHaveSecondarySideEffects; final boolean maybeAliased; Assign(Node assignNode, Node nameNode, boolean isPropertyAssign) {\n      Preconditions.checkState(NodeUtil.isAssignmentOp(assignNode));\n      this.assignNode = assignNode;\n      this.nameNode = nameNode;\n      this.isPropertyAssign = isPropertyAssign;\n\n      this.maybeAliased = NodeUtil.isExpressionResultUsed(assignNode);\n      this.mayHaveSecondarySideEffects =\n          maybeAliased ||\n          NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||\n          NodeUtil.mayHaveSideEffects(assignNode.getLastChild());\n    }\n\n    \n    static Assign maybeCreateAssign(Node assignNode) {\n      Preconditions.checkState(NodeUtil.isAssignmentOp(assignNode));\n\n      \n      \n      \n      \n      \n      boolean isPropAssign = false;\n      Node current = assignNode.getFirstChild();\n      if (NodeUtil.isGet(current)) {\n        current = current.getFirstChild();\n        isPropAssign = true;\n\n        if (current.isGetProp() &&\n            current.getLastChild().getString().equals(\"prototype\")) {\n          \n          \n          current = current.getFirstChild();\n        }\n      }\n\n      if (current.isName()) {\n        return new Assign(assignNode, current, isPropAssign);\n      }\n      return null;\n    }\n\n    \n    void remove() {\n      Node parent = assignNode.getParent();\n      if (mayHaveSecondarySideEffects) {\n        Node replacement = assignNode.getLastChild().detachFromParent();\n\n        \n        for (Node current = assignNode.getFirstChild();\n             !current.isName();\n             current = current.getFirstChild()) {\n          if (current.isGetElem()) {\n            replacement = IR.comma(\n                current.getLastChild().detachFromParent(), replacement);\n            replacement.copyInformationFrom(current);\n          }\n        }\n\n        parent.replaceChild(assignNode, replacement);\n      } else {\n        Node gramps = parent.getParent();\n        if (parent.isExprResult()) {\n          gramps.removeChild(parent);\n        } else {\n          parent.replaceChild(assignNode,\n              assignNode.getLastChild().detachFromParent());\n        }\n      }\n    }\n  }\n}\n",
      "buggy_signatures": [
        "public void process(Node externs, Node root)",
        "public void process( Node externs, Node root, SimpleDefinitionFinder defFinder)",
        "private void traverseAndRemoveUnusedReferences(Node root)",
        "private void traverseNode(Node n, Node parent, Scope scope)",
        "private boolean isRemovableVar(Var var)",
        "private void traverseFunction(Node n, Scope parentScope)",
        "private void collectMaybeUnreferencedVars(Scope scope)",
        "private void removeUnreferencedFunctionArgs(Scope fnScope)",
        "private static Node getFunctionArgList(Node function)",
        "public void optimize(Scope fnScope, Set<Var> referenced)",
        "public void applyChanges()",
        "private boolean markUnreferencedFunctionArgs( Scope scope, Node function, Set<Var> referenced, Node param, int paramIndex, boolean canChangeSignature)",
        "private boolean canRemoveArgFromCallSites(Node function, int argIndex)",
        "private void tryRemoveArgFromCallSites( Node function, int argIndex, boolean canModifyAllSites)",
        "private void tryRemoveAllFollowingArgs(Node function, final int argIndex)",
        "private static Node getArgumentForCallOrNewOrDotCall(UseSite site, final int argIndex)",
        "private static boolean isModifiableCallSite(UseSite site)",
        "private boolean canChangeSignature(Node function)",
        "private Definition getFunctionDefinition(Node function)",
        "private void interpretAssigns()",
        "private void removeAllAssigns(Var var)",
        "private boolean markReferencedVar(Var var)",
        "private void removeUnreferencedVars()",
        "private class Continuation { private final Node node; private final Scope scope; Continuation(Node node, Scope scope)",
        "private static class Assign { final Node assignNode; final Node nameNode; final boolean isPropertyAssign; final boolean mayHaveSecondarySideEffects; final boolean maybeAliased; Assign(Node assignNode, Node nameNode, boolean isPropertyAssign)",
        "static Assign maybeCreateAssign(Node assignNode)"
      ],
      "fixed_signatures": [
        "public void process(Node externs, Node root)",
        "public void process( Node externs, Node root, SimpleDefinitionFinder defFinder)",
        "private void traverseAndRemoveUnusedReferences(Node root)",
        "private void traverseNode(Node n, Node parent, Scope scope)",
        "private boolean isRemovableVar(Var var)",
        "private void traverseFunction(Node n, Scope parentScope)",
        "private void collectMaybeUnreferencedVars(Scope scope)",
        "private void removeUnreferencedFunctionArgs(Scope fnScope)",
        "private static Node getFunctionArgList(Node function)",
        "public void optimize(Scope fnScope, Set<Var> referenced)",
        "public void applyChanges()",
        "private boolean markUnreferencedFunctionArgs( Scope scope, Node function, Set<Var> referenced, Node param, int paramIndex, boolean canChangeSignature)",
        "private boolean canRemoveArgFromCallSites(Node function, int argIndex)",
        "private void tryRemoveArgFromCallSites( Node function, int argIndex, boolean canModifyAllSites)",
        "private void tryRemoveAllFollowingArgs(Node function, final int argIndex)",
        "private static Node getArgumentForCallOrNewOrDotCall(UseSite site, final int argIndex)",
        "private static boolean isModifiableCallSite(UseSite site)",
        "private boolean canChangeSignature(Node function)",
        "private Definition getFunctionDefinition(Node function)",
        "private void interpretAssigns()",
        "private void removeAllAssigns(Var var)",
        "private boolean markReferencedVar(Var var)",
        "private void removeUnreferencedVars()",
        "private class Continuation { private final Node node; private final Scope scope; Continuation(Node node, Scope scope)",
        "private static class Assign { final Node assignNode; final Node nameNode; final boolean isPropertyAssign; final boolean mayHaveSecondarySideEffects; final boolean maybeAliased; Assign(Node assignNode, Node nameNode, boolean isPropertyAssign)",
        "static Assign maybeCreateAssign(Node assignNode)"
      ],
      "methods": [
        {
          "buggy_method": "  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  Node function = fnScope.getRootNode();\n\n  Preconditions.checkState(function.isFunction());\n  if (NodeUtil.isGetOrSetKey(function.getParent())) {\n  \n  return;\n  }\n\n  Node argList = getFunctionArgList(function);\n  boolean modifyCallers = modifyCallSites\n  && callSiteOptimizer.canModifyCallers(function);\n  if (!modifyCallers) {\n  \n  Node lastArg;\n  while ((lastArg = argList.getLastChild()) != null) {\n  Var var = fnScope.getVar(lastArg.getString());\n  if (!referenced.contains(var)) {\n  argList.removeChild(lastArg);\n  compiler.reportCodeChange();\n  } else {\n  break;\n  }\n  }\n  } else {\n  callSiteOptimizer.optimize(fnScope, referenced);\n  }\n  }",
          "fixed_method": "  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if (!removeGlobals) {\n  return;\n  }\n\n  Node function = fnScope.getRootNode();\n\n  Preconditions.checkState(function.isFunction());\n  if (NodeUtil.isGetOrSetKey(function.getParent())) {\n  \n  return;\n  }\n\n  Node argList = getFunctionArgList(function);\n  boolean modifyCallers = modifyCallSites\n  && callSiteOptimizer.canModifyCallers(function);\n  if (!modifyCallers) {\n  \n  Node lastArg;\n  while ((lastArg = argList.getLastChild()) != null) {\n  Var var = fnScope.getVar(lastArg.getString());\n  if (!referenced.contains(var)) {\n  argList.removeChild(lastArg);\n  compiler.reportCodeChange();\n  } else {\n  break;\n  }\n  }\n  } else {\n  callSiteOptimizer.optimize(fnScope, referenced);\n  }\n  }",
          "diff": [
            "@@ -376,6 +376,9 @@",
            "     // is removing globals, then it's OK to remove unused function args.\n",
            "     //\n",
            "     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n",
            "+    if (!removeGlobals) {\n",
            "+      return;\n",
            "+    }\n",
            " \n",
            "     Node function = fnScope.getRootNode();\n",
            " \n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
