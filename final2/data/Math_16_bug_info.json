{
  "bug_id": "16",
  "failed_tests": {
    "org.apache.commons.math3.util.FastMathTest": [
      {
        "methodName": "testMath905LargePositive",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<0.0> but was:<Infinity>",
        "fail_line": "        Assert.assertEquals(0, maxErr, 3);",
        "test_source": "  public void testMath905LargePositive() {\n  final double start = StrictMath.log(Double.MAX_VALUE);\n  final double endT = StrictMath.sqrt(2) * StrictMath.sqrt(Double.MAX_VALUE);\n  final double end = 2 * StrictMath.log(endT);\n\n  double maxErr = 0;\n  for (double x = start; x < end; x += 1e-3) {\n  final double tst = FastMath.cosh(x);\n  final double ref = Math.cosh(x);\n  maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));  \n  }\n  Assert.assertEquals(0, maxErr, 3);\n\n  for (double x = start; x < end; x += 1e-3) {\n  final double tst = FastMath.sinh(x);\n  final double ref = Math.sinh(x);\n  maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));  \n  }\n  Assert.assertEquals(0, maxErr, 3);\n  }",
        "stack": [
          "FastMathTest.testMath905LargePositive line 172"
        ]
      },
      {
        "methodName": "testMath905LargeNegative",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<0.0> but was:<Infinity>",
        "fail_line": "        Assert.assertEquals(0, maxErr, 3);",
        "test_source": "  public void testMath905LargeNegative() {\n  final double start = -StrictMath.log(Double.MAX_VALUE);\n  final double endT = StrictMath.sqrt(2) * StrictMath.sqrt(Double.MAX_VALUE);\n  final double end = -2 * StrictMath.log(endT);\n\n  double maxErr = 0;\n  for (double x = start; x > end; x -= 1e-3) {\n  final double tst = FastMath.cosh(x);\n  final double ref = Math.cosh(x);\n  maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));  \n  }\n  Assert.assertEquals(0, maxErr, 3);\n\n  for (double x = start; x > end; x -= 1e-3) {\n  final double tst = FastMath.sinh(x);\n  final double ref = Math.sinh(x);\n  maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));  \n  }\n  Assert.assertEquals(0, maxErr, 3);\n  }",
        "stack": [
          "FastMathTest.testMath905LargeNegative line 194"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math3/util/FastMath.java",
      "buggy_full_code": "\npackage org.apache.commons.math3.util;\n\nimport java.io.PrintStream;\n\n\npublic class FastMath { public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9; public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8; static final int EXP_INT_TABLE_MAX_INDEX = 750; static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2; static final int LN_MANT_LEN = 1024; static final int EXP_FRAC_TABLE_LEN = 1025; private static final boolean RECOMPUTE_TABLES_AT_RUNTIME = false; private static final double LN_2_A = 0.693147063255310059; private static final double LN_2_B = 1.17304635250823482e-7; private static final double LN_QUICK_COEF[][] = { {1.0, 5.669184079525E-24}, {-0.25, -0.25}, {0.3333333134651184, 1.986821492305628E-8}, {-0.25, -6.663542893624021E-14}, {0.19999998807907104, 1.1921056801463227E-8}, {-0.1666666567325592, -7.800414592973399E-9}, {0.1428571343421936, 5.650007086920087E-9}, {-0.12502530217170715, -7.44321345601866E-11}, {0.11113807559013367, 9.219544613762692E-9}, }; private static final double LN_HI_PREC_COEF[][] = { {1.0, -6.032174644509064E-23}, {-0.25, -0.25}, {0.3333333134651184, 1.9868161777724352E-8}, {-0.2499999701976776, -2.957007209750105E-8}, {0.19999954104423523, 1.5830993332061267E-10}, {-0.16624879837036133, -2.6033824355191673E-8} }; private static final int SINE_TABLE_LEN = 14; private static final double SINE_TABLE_A[] = { +0.0d, +0.1246747374534607d, +0.24740394949913025d, +0.366272509098053d, +0.4794255495071411d, +0.5850973129272461d, +0.6816387176513672d, +0.7675435543060303d, +0.8414709568023682d, +0.902267575263977d, +0.9489846229553223d, +0.9808930158615112d, +0.9974949359893799d, +0.9985313415527344d, }; private static final double SINE_TABLE_B[] = { +0.0d, -4.068233003401932E-9d, +9.755392680573412E-9d, +1.9987994582857286E-8d, -1.0902938113007961E-8d, -3.9986783938944604E-8d, +4.23719669792332E-8d, -5.207000323380292E-8d, +2.800552834259E-8d, +1.883511811213715E-8d, -3.5997360512765566E-9d, +4.116164446561962E-8d, +5.0614674548127384E-8d, -1.0129027912496858E-9d, }; private static final double COSINE_TABLE_A[] = { +1.0d, +0.9921976327896118d, +0.9689123630523682d, +0.9305076599121094d, +0.8775825500488281d, +0.8109631538391113d, +0.7316888570785522d, +0.6409968137741089d, +0.5403022766113281d, +0.4311765432357788d, +0.3153223395347595d, +0.19454771280288696d, +0.07073719799518585d, -0.05417713522911072d, }; private static final double COSINE_TABLE_B[] = { +0.0d, +3.4439717236742845E-8d, +5.865827662008209E-8d, -3.7999795083850525E-8d, +1.184154459111628E-8d, -3.43338934259355E-8d, +1.1795268640216787E-8d, +4.438921624363781E-8d, +2.925681159240093E-8d, -2.6437112632041807E-8d, +2.2860509143963117E-8d, -4.813899778443457E-9d, +3.6725170580355583E-9d, +2.0217439756338078E-10d, }; private static final double TANGENT_TABLE_A[] = { +0.0d, +0.1256551444530487d, +0.25534194707870483d, +0.3936265707015991d, +0.5463024377822876d, +0.7214844226837158d, +0.9315965175628662d, +1.1974215507507324d, +1.5574076175689697d, +2.092571258544922d, +3.0095696449279785d, +5.041914939880371d, +14.101419448852539d, -18.430862426757812d, }; private static final double TANGENT_TABLE_B[] = { +0.0d, -7.877917738262007E-9d, -2.5857668567479893E-8d, +5.2240336371356666E-9d, +5.206150291559893E-8d, +1.8307188599677033E-8d, -5.7618793749770706E-8d, +7.848361555046424E-8d, +1.0708593250394448E-7d, +1.7827257129423813E-8d, +2.893485277253286E-8d, +3.1660099222737955E-7d, +4.983191803254889E-7d, -3.356118100840571E-7d, }; private static final long RECIP_2PI[] = new long[] { (0x28be60dbL << 32) | 0x9391054aL, (0x7f09d5f4L << 32) | 0x7d4d3770L, (0x36d8a566L << 32) | 0x4f10e410L, (0x7f9458eaL << 32) | 0xf7aef158L, (0x6dc91b8eL << 32) | 0x909374b8L, (0x01924bbaL << 32) | 0x82746487L, (0x3f877ac7L << 32) | 0x2c4a69cfL, (0xba208d7dL << 32) | 0x4baed121L, (0x3a671c09L << 32) | 0xad17df90L, (0x4e64758eL << 32) | 0x60d4ce7dL, (0x272117e2L << 32) | 0xef7e4a0eL, (0xc7fe25ffL << 32) | 0xf7816603L, (0xfbcbc462L << 32) | 0xd6829b47L, (0xdb4d9fb3L << 32) | 0xc9f2c26dL, (0xd3d18fd9L << 32) | 0xa797fa8bL, (0x5d49eeb1L << 32) | 0xfaf97c5eL, (0xcf41ce7dL << 32) | 0xe294a4baL, 0x9afed7ecL << 32 }; private static final long PI_O_4_BITS[] = new long[] {\n        (0xc90fdaa2L << 32) | 0x2168c234L,\n        (0xc4c6628bL << 32) | 0x80dc1cd1L };\n\n    \n    private static final double EIGHTHS[] = {0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625}; private static final double CBRTTWO[] = { 0.6299605249474366, 0.7937005259840998, 1.0, 1.2599210498948732, 1.5874010519681994 }; private static final long HEX_40000000 = 0x40000000L; private static final long MASK_30BITS = -1L - (HEX_40000000 -1); private static final double TWO_POWER_52 = 4503599627370496.0; private static final double F_1_3 = 1d / 3d; private static final double F_1_5 = 1d / 5d; private static final double F_1_7 = 1d / 7d; private static final double F_1_9 = 1d / 9d; private static final double F_1_11 = 1d / 11d; private static final double F_1_13 = 1d / 13d; private static final double F_1_15 = 1d / 15d; private static final double F_1_17 = 1d / 17d; private static final double F_3_4 = 3d / 4d; private static final double F_15_16 = 15d / 16d; private static final double F_13_14 = 13d / 14d; private static final double F_11_12 = 11d / 12d; private static final double F_9_10 = 9d / 10d; private static final double F_7_8 = 7d / 8d; private static final double F_5_6 = 5d / 6d; private static final double F_1_2 = 1d / 2d; private static final double F_1_4 = 1d / 4d; private FastMath() {}\n\n    \n\n    \n    private static double doubleHighPart(double d) {\n        if (d > -Precision.SAFE_MIN && d < Precision.SAFE_MIN){\n            return d; \n        }\n        long xl = Double.doubleToLongBits(d);\n        xl = xl & MASK_30BITS; \n        return Double.longBitsToDouble(xl);\n    }\n\n    \n    public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }\n\n    \n    public static double cosh(double x) {\n      if (x != x) {\n          return x;\n      }\n\n      \n\n      \n      \n\n      if (x > 20) {\n              \n              return 0.5 * exp(x);\n          }\n      if (x < -20) {\n              \n              return 0.5 * exp(-x);\n      }\n\n      final double hiPrec[] = new double[2];\n      if (x < 0.0) {\n          x = -x;\n      }\n      exp(x, 0.0, hiPrec);\n\n      double ya = hiPrec[0] + hiPrec[1];\n      double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n      double temp = ya * HEX_40000000;\n      double yaa = ya + temp - temp;\n      double yab = ya - yaa;\n\n      \n      double recip = 1.0/ya;\n      temp = recip * HEX_40000000;\n      double recipa = recip + temp - temp;\n      double recipb = recip - recipa;\n\n      \n      recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n      \n      recipb += -yb * recip * recip;\n\n      \n      temp = ya + recipa;\n      yb += -(temp - ya - recipa);\n      ya = temp;\n      temp = ya + recipb;\n      yb += -(temp - ya - recipb);\n      ya = temp;\n\n      double result = ya + yb;\n      result *= 0.5;\n      return result;\n    }\n\n    \n    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      \n\n      \n      \n\n      if (x > 20) {\n              \n              return 0.5 * exp(x);\n          }\n      if (x < -20) {\n              \n              return -0.5 * exp(-x);\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          \n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          \n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          \n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          \n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          \n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          \n          rb += yb*denomr;                        \n          rb += -ya * denomb * denomr * denomr;   \n\n          \n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }\n\n    \n    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      \n      \n      \n\n      \n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          \n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          \n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          \n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          \n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          \n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          \n          ratiob += nb / da;\n          \n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          \n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          \n          double na = ya;\n          double nb = yb;\n\n          \n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          \n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          \n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          \n          ratiob += nb / da;\n          \n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }\n\n    \n    public static double acosh(final double a) {\n        return FastMath.log(a + FastMath.sqrt(a * a - 1));\n    }\n\n    \n    public static double asinh(double a) {\n        boolean negative = false;\n        if (a < 0) {\n            negative = true;\n            a = -a;\n        }\n\n        double absAsinh;\n        if (a > 0.167) {\n            absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);\n        } else {\n            final double a2 = a * a;\n            if (a > 0.097) {\n                absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n            } else if (a > 0.036) {\n                absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n            } else if (a > 0.0036) {\n                absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n            } else {\n                absAsinh = a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2);\n            }\n        }\n\n        return negative ? -absAsinh : absAsinh;\n    }\n\n    \n    public static double atanh(double a) {\n        boolean negative = false;\n        if (a < 0) {\n            negative = true;\n            a = -a;\n        }\n\n        double absAtanh;\n        if (a > 0.15) {\n            absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n        } else {\n            final double a2 = a * a;\n            if (a > 0.087) {\n                absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));\n            } else if (a > 0.031) {\n                absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));\n            } else if (a > 0.003) {\n                absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));\n            } else {\n                absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5));\n            }\n        }\n\n        return negative ? -absAtanh : absAtanh;\n    }\n\n    \n    public static double signum(final double a) {\n        return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : a); \n    }\n\n    \n    public static float signum(final float a) {\n        return (a < 0.0f) ? -1.0f : ((a > 0.0f) ? 1.0f : a); \n    }\n\n    \n    public static double nextUp(final double a) {\n        return nextAfter(a, Double.POSITIVE_INFINITY);\n    }\n\n    \n    public static float nextUp(final float a) {\n        return nextAfter(a, Float.POSITIVE_INFINITY);\n    }\n\n    \n    public static double random() {\n        return Math.random();\n    }\n\n    \n    public static double exp(double x) {\n        return exp(x, 0.0, null);\n    }\n\n    \n    private static double exp(double x, double extra, double[] hiPrec) {\n        double intPartA;\n        double intPartB;\n        int intVal;\n\n        \n        if (x < 0.0) {\n            intVal = (int) -x;\n\n            if (intVal > 746) {\n                if (hiPrec != null) {\n                    hiPrec[0] = 0.0;\n                    hiPrec[1] = 0.0;\n                }\n                return 0.0;\n            }\n\n            if (intVal > 709) {\n                \n                final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;\n                if (hiPrec != null) {\n                    hiPrec[0] /= 285040095144011776.0;\n                    hiPrec[1] /= 285040095144011776.0;\n                }\n                return result;\n            }\n\n            if (intVal == 709) {\n                \n                final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;\n                if (hiPrec != null) {\n                    hiPrec[0] /= 4.455505956692756620;\n                    hiPrec[1] /= 4.455505956692756620;\n                }\n                return result;\n            }\n\n            intVal++;\n\n            intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal];\n            intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal];\n\n            intVal = -intVal;\n        } else {\n            intVal = (int) x;\n\n            if (intVal > 709) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.POSITIVE_INFINITY;\n                    hiPrec[1] = 0.0;\n                }\n                return Double.POSITIVE_INFINITY;\n            }\n\n            intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal];\n            intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal];\n        }\n\n        \n        final int intFrac = (int) ((x - intVal) * 1024.0);\n        final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac];\n        final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n\n        \n        final double epsilon = x - (intVal + intFrac / 1024.0);\n\n        \n\n        \n        double z = 0.04168701738764507;\n        z = z * epsilon + 0.1666666505023083;\n        z = z * epsilon + 0.5000000000042687;\n        z = z * epsilon + 1.0;\n        z = z * epsilon + -3.940510424527919E-20;\n\n        \n        double tempA = intPartA * fracPartA;\n        double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\n\n        \n        final double tempC = tempB + tempA;\n        final double result;\n        if (extra != 0.0) {\n            result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;\n        } else {\n            result = tempC*z + tempB + tempA;\n        }\n\n        if (hiPrec != null) {\n            \n            hiPrec[0] = tempA;\n            hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB;\n        }\n\n        return result;\n    }\n\n    \n    public static double expm1(double x) {\n      return expm1(x, null);\n    }\n\n    \n    private static double expm1(double x, double hiPrecOut[]) {\n        if (x != x || x == 0.0) { \n            return x;\n        }\n\n        if (x <= -1.0 || x >= 1.0) {\n            \n            \n            double hiPrec[] = new double[2];\n            exp(x, 0.0, hiPrec);\n            if (x > 0.0) {\n                return -1.0 + hiPrec[0] + hiPrec[1];\n            } else {\n                final double ra = -1.0 + hiPrec[0];\n                double rb = -(ra + 1.0 - hiPrec[0]);\n                rb += hiPrec[1];\n                return ra + rb;\n            }\n        }\n\n        double baseA;\n        double baseB;\n        double epsilon;\n        boolean negative = false;\n\n        if (x < 0.0) {\n            x = -x;\n            negative = true;\n        }\n\n        {\n            int intFrac = (int) (x * 1024.0);\n            double tempA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac] - 1.0;\n            double tempB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n\n            double temp = tempA + tempB;\n            tempB = -(temp - tempA - tempB);\n            tempA = temp;\n\n            temp = tempA * HEX_40000000;\n            baseA = tempA + temp - temp;\n            baseB = tempB + (tempA - baseA);\n\n            epsilon = x - intFrac/1024.0;\n        }\n\n\n        \n        double zb = 0.008336750013465571;\n        zb = zb * epsilon + 0.041666663879186654;\n        zb = zb * epsilon + 0.16666666666745392;\n        zb = zb * epsilon + 0.49999999999999994;\n        zb = zb * epsilon;\n        zb = zb * epsilon;\n\n        double za = epsilon;\n        double temp = za + zb;\n        zb = -(temp - za - zb);\n        za = temp;\n\n        temp = za * HEX_40000000;\n        temp = za + temp - temp;\n        zb += za - temp;\n        za = temp;\n\n        \n        double ya = za * baseA;\n        \n        temp = ya + za * baseB;\n        double yb = -(temp - ya - za * baseB);\n        ya = temp;\n\n        temp = ya + zb * baseA;\n        yb += -(temp - ya - zb * baseA);\n        ya = temp;\n\n        temp = ya + zb * baseB;\n        yb += -(temp - ya - zb*baseB);\n        ya = temp;\n\n        \n        \n        temp = ya + baseA;\n        yb += -(temp - baseA - ya);\n        ya = temp;\n\n        temp = ya + za;\n        \n        yb += -(temp - ya - za);\n        ya = temp;\n\n        temp = ya + baseB;\n        \n        yb += -(temp - ya - baseB);\n        ya = temp;\n\n        temp = ya + zb;\n        \n        yb += -(temp - ya - zb);\n        ya = temp;\n\n        if (negative) {\n            \n            double denom = 1.0 + ya;\n            double denomr = 1.0 / denom;\n            double denomb = -(denom - 1.0 - ya) + yb;\n            double ratio = ya * denomr;\n            temp = ratio * HEX_40000000;\n            final double ra = ratio + temp - temp;\n            double rb = ratio - ra;\n\n            temp = denom * HEX_40000000;\n            za = denom + temp - temp;\n            zb = denom - za;\n\n            rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;\n\n            \n            \n            \n            \n            \n            \n            \n\n            \n            rb += yb * denomr;                      \n            rb += -ya * denomb * denomr * denomr;   \n\n            \n            ya = -ra;\n            yb = -rb;\n        }\n\n        if (hiPrecOut != null) {\n            hiPrecOut[0] = ya;\n            hiPrecOut[1] = yb;\n        }\n\n        return ya + yb;\n    }\n\n    \n    public static double log(final double x) {\n        return log(x, null);\n    }\n\n    \n    private static double log(final double x, final double[] hiPrec) {\n        if (x==0) { \n            return Double.NEGATIVE_INFINITY;\n        }\n        long bits = Double.doubleToLongBits(x);\n\n        \n        if ((bits & 0x8000000000000000L) != 0 || x != x) {\n            if (x != 0.0) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NaN;\n                }\n\n                return Double.NaN;\n            }\n        }\n\n        \n        if (x == Double.POSITIVE_INFINITY) {\n            if (hiPrec != null) {\n                hiPrec[0] = Double.POSITIVE_INFINITY;\n            }\n\n            return Double.POSITIVE_INFINITY;\n        }\n\n        \n        int exp = (int)(bits >> 52)-1023;\n\n        if ((bits & 0x7ff0000000000000L) == 0) {\n            \n            if (x == 0) {\n                \n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.NEGATIVE_INFINITY;\n            }\n\n            \n            bits <<= 1;\n            while ( (bits & 0x0010000000000000L) == 0) {\n                --exp;\n                bits <<= 1;\n            }\n        }\n\n\n        if (exp == -1 || exp == 0) {\n            if (x < 1.01 && x > 0.99 && hiPrec == null) {\n                \n\n               \n                double xa = x - 1.0;\n                double xb = xa - x + 1.0;\n                double tmp = xa * HEX_40000000;\n                double aa = xa + tmp - tmp;\n                double ab = xa - aa;\n                xa = aa;\n                xb = ab;\n\n                final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];\n                double ya = lnCoef_last[0];\n                double yb = lnCoef_last[1];\n\n                for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\n                    \n                    aa = ya * xa;\n                    ab = ya * xb + yb * xa + yb * xb;\n                    \n                    tmp = aa * HEX_40000000;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n\n                    \n                    final double[] lnCoef_i = LN_QUICK_COEF[i];\n                    aa = ya + lnCoef_i[0];\n                    ab = yb + lnCoef_i[1];\n                    \n                    tmp = aa * HEX_40000000;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n                }\n\n                \n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                \n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                return ya + yb;\n            }\n        }\n\n        \n        final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n\n        \n\n        \n        \n        \n        final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\n\n        double lnza = 0.0;\n        double lnzb = 0.0;\n\n        if (hiPrec != null) {\n            \n            double tmp = epsilon * HEX_40000000;\n            double aa = epsilon + tmp - tmp;\n            double ab = epsilon - aa;\n            double xa = aa;\n            double xb = ab;\n\n            \n            final double numer = bits & 0x3ffffffffffL;\n            final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);\n            aa = numer - xa*denom - xb * denom;\n            xb += aa / denom;\n\n            \n            final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1];\n            double ya = lnCoef_last[0];\n            double yb = lnCoef_last[1];\n\n            for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {\n                \n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                \n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                \n                final double[] lnCoef_i = LN_HI_PREC_COEF[i];\n                aa = ya + lnCoef_i[0];\n                ab = yb + lnCoef_i[1];\n                \n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n            }\n\n            \n            aa = ya * xa;\n            ab = ya * xb + yb * xa + yb * xb;\n\n            \n            \n            lnza = aa + ab;\n            lnzb = -(lnza - aa - ab);\n        } else {\n            \n            lnza = -0.16624882440418567;\n            lnza = lnza * epsilon + 0.19999954120254515;\n            lnza = lnza * epsilon + -0.2499999997677497;\n            lnza = lnza * epsilon + 0.3333333333332802;\n            lnza = lnza * epsilon + -0.5;\n            lnza = lnza * epsilon + 1.0;\n            lnza = lnza * epsilon;\n        }\n\n        \n\n        \n\n        \n        double a = LN_2_A*exp;\n        double b = 0.0;\n        double c = a+lnm[0];\n        double d = -(c-a-lnm[0]);\n        a = c;\n        b = b + d;\n\n        c = a + lnza;\n        d = -(c - a - lnza);\n        a = c;\n        b = b + d;\n\n        c = a + LN_2_B*exp;\n        d = -(c - a - LN_2_B*exp);\n        a = c;\n        b = b + d;\n\n        c = a + lnm[1];\n        d = -(c - a - lnm[1]);\n        a = c;\n        b = b + d;\n\n        c = a + lnzb;\n        d = -(c - a - lnzb);\n        a = c;\n        b = b + d;\n\n        if (hiPrec != null) {\n            hiPrec[0] = a;\n            hiPrec[1] = b;\n        }\n\n        return a + b;\n    }\n\n    \n    public static double log1p(final double x) {\n        if (x == -1) {\n            return Double.NEGATIVE_INFINITY;\n        }\n\n        if (x == Double.POSITIVE_INFINITY) {\n            return Double.POSITIVE_INFINITY;\n        }\n\n        if (x > 1e-6 ||\n            x < -1e-6) {\n            final double xpa = 1 + x;\n            final double xpb = -(xpa - 1 - x);\n\n            final double[] hiPrec = new double[2];\n            final double lores = log(xpa, hiPrec);\n            if (Double.isInfinite(lores)) { \n                return lores;\n            }\n\n            \n            \n            final double fx1 = xpb / xpa;\n            final double epsilon = 0.5 * fx1 + 1;\n            return epsilon * fx1 + hiPrec[1] + hiPrec[0];\n        } else {\n            \n            final double y = (x * F_1_3 - F_1_2) * x + 1;\n            return y * x;\n        }\n    }\n\n    \n    public static double log10(final double x) {\n        final double hiPrec[] = new double[2];\n\n        final double lores = log(x, hiPrec);\n        if (Double.isInfinite(lores)){ \n            return lores;\n        }\n\n        final double tmp = hiPrec[0] * HEX_40000000;\n        final double lna = hiPrec[0] + tmp - tmp;\n        final double lnb = hiPrec[0] - lna + hiPrec[1];\n\n        final double rln10a = 0.4342944622039795;\n        final double rln10b = 1.9699272335463627E-8;\n\n        return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna;\n    }\n\n    \n    public static double log(double base, double x) {\n        return log(x) / log(base);\n    }\n\n    \n    public static double pow(double x, double y) {\n        final double lns[] = new double[2];\n\n        if (y == 0.0) {\n            return 1.0;\n        }\n\n        if (x != x) { \n            return x;\n        }\n\n\n        if (x == 0) {\n            long bits = Double.doubleToLongBits(x);\n            if ((bits & 0x8000000000000000L) != 0) {\n                \n                long yi = (long) y;\n\n                if (y < 0 && y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                if (y > 0 && y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n            }\n\n            if (y < 0) {\n                return Double.POSITIVE_INFINITY;\n            }\n            if (y > 0) {\n                return 0.0;\n            }\n\n            return Double.NaN;\n        }\n\n        if (x == Double.POSITIVE_INFINITY) {\n            if (y != y) { \n                return y;\n            }\n            if (y < 0.0) {\n                return 0.0;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.POSITIVE_INFINITY) {\n            if (x * x == 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x > 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        if (x == Double.NEGATIVE_INFINITY) {\n            if (y != y) { \n                return y;\n            }\n\n            if (y < 0) {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n\n                return 0.0;\n            }\n\n            if (y > 0)  {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.NEGATIVE_INFINITY) {\n\n            if (x * x == 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x < 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        \n        if (x < 0) {\n            \n            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n                return pow(-x, y);\n            }\n\n            if (y == (long) y) {\n                \n                return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n            } else {\n                return Double.NaN;\n            }\n        }\n\n        \n        double ya;\n        double yb;\n        if (y < 8e298 && y > -8e298) {\n            double tmp1 = y * HEX_40000000;\n            ya = y + tmp1 - tmp1;\n            yb = y - ya;\n        } else {\n            double tmp1 = y * 9.31322574615478515625E-10;\n            double tmp2 = tmp1 * 9.31322574615478515625E-10;\n            ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\n            yb = y - ya;\n        }\n\n        \n        final double lores = log(x, lns);\n        if (Double.isInfinite(lores)){ \n            return lores;\n        }\n\n        double lna = lns[0];\n        double lnb = lns[1];\n\n        \n        double tmp1 = lna * HEX_40000000;\n        double tmp2 = lna + tmp1 - tmp1;\n        lnb += lna - tmp2;\n        lna = tmp2;\n\n        \n        final double aa = lna * ya;\n        final double ab = lna * yb + lnb * ya + lnb * yb;\n\n        lna = aa+ab;\n        lnb = -(lna - aa - ab);\n\n        double z = 1.0 / 120.0;\n        z = z * lnb + (1.0 / 24.0);\n        z = z * lnb + (1.0 / 6.0);\n        z = z * lnb + 0.5;\n        z = z * lnb + 1.0;\n        z = z * lnb;\n\n        final double result = exp(lna, z, null);\n        \n        return result;\n    }\n\n\n    \n    public static double pow(double d, int e) {\n\n        if (e == 0) {\n            return 1.0;\n        } else if (e < 0) {\n            e = -e;\n            d = 1.0 / d;\n        }\n\n        \n        \n        final int splitFactor = 0x8000001;\n        final double cd       = splitFactor * d;\n        final double d1High   = cd - (cd - d);\n        final double d1Low    = d - d1High;\n\n        \n        double resultHigh = 1;\n        double resultLow  = 0;\n\n        \n        double d2p     = d;\n        double d2pHigh = d1High;\n        double d2pLow  = d1Low;\n\n        while (e != 0) {\n\n            if ((e & 0x1) != 0) {\n                \n                \n                final double tmpHigh = resultHigh * d2p;\n                final double cRH     = splitFactor * resultHigh;\n                final double rHH     = cRH - (cRH - resultHigh);\n                final double rHL     = resultHigh - rHH;\n                final double tmpLow  = rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow);\n                resultHigh = tmpHigh;\n                resultLow  = resultLow * d2p + tmpLow;\n            }\n\n            \n            \n            final double tmpHigh = d2pHigh * d2p;\n            final double cD2pH   = splitFactor * d2pHigh;\n            final double d2pHH   = cD2pH - (cD2pH - d2pHigh);\n            final double d2pHL   = d2pHigh - d2pHH;\n            final double tmpLow  = d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow);\n            final double cTmpH   = splitFactor * tmpHigh;\n            d2pHigh = cTmpH - (cTmpH - tmpHigh);\n            d2pLow  = d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh);\n            d2p     = d2pHigh + d2pLow;\n\n            e = e >> 1;\n\n        }\n\n        return resultHigh + resultLow;\n\n    }\n\n    \n    private static double polySine(final double x) {\n        double x2 = x*x;\n\n        double p = 2.7553817452272217E-6;\n        p = p * x2 + -1.9841269659586505E-4;\n        p = p * x2 + 0.008333333333329196;\n        p = p * x2 + -0.16666666666666666;\n        \n        \n        p = p * x2 * x;\n\n        return p;\n    }\n\n    \n    private static double polyCosine(double x) {\n        double x2 = x*x;\n\n        double p = 2.479773539153719E-5;\n        p = p * x2 + -0.0013888888689039883;\n        p = p * x2 + 0.041666666666621166;\n        p = p * x2 + -0.49999999999999994;\n        p *= x2;\n\n        return p;\n    }\n\n    \n    private static double sinQ(double xa, double xb) {\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; \n\n        \n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        \n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        \n        final double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        \n        double result;\n\n        \n\n        \n        \n\n        \n        \n        double a = 0;\n        double b = 0;\n\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA * sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA * cosEpsB + costA * sinEpsB;\n        \n\n        b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\n        \n\n        if (xb != 0.0) {\n            t = ((costA + costB) * (cosEpsA + cosEpsB) -\n                 (sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  \n            c = a + t;\n            d = -(c - a - t);\n            a = c;\n            b = b + d;\n        }\n\n        result = a + b;\n\n        return result;\n    }\n\n    \n    private static double cosQ(double xa, double xb) {\n        final double pi2a = 1.5707963267948966;\n        final double pi2b = 6.123233995736766E-17;\n\n        final double a = pi2a - xa;\n        double b = -(a - pi2a + xa);\n        b += pi2b - xb;\n\n        return sinQ(a, b);\n    }\n\n    \n    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; \n\n        \n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        \n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        \n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        \n\n        \n\n        \n        \n\n        \n        \n        double a = 0;\n        double b = 0;\n\n        \n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        \n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        \n        \n\n        \n\n        double est = sina/cosa;\n\n        \n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        \n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  \n        err += sinb/cosa;                     \n        err += -sina * cosb / cosa / cosa;    \n\n        if (xb != 0.0) {\n            \n            \n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }\n\n    \n    private static void reducePayneHanek(double x, double result[]) {\n        \n        long inbits = Double.doubleToLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        \n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        \n        exponent++;\n        inbits <<= 11;\n\n        \n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        \n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        \n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        \n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        \n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        \n\n        \n        int intPart = (int)(prodA >>> 62);\n\n        \n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        \n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        \n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        \n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        \n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        \n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        \n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  \n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; \n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        \n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }\n\n    \n    public static double sin(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n        double xa;\n        double xb = 0.0;\n\n        \n        xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        \n        if (xa == 0.0) {\n            long bits = Double.doubleToLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        \n        if (xa > 3294198.0) {\n            \n            \n            \n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa, xb);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (negative) {\n            quadrant ^= 2;  \n        }\n\n        switch (quadrant) {\n            case 0:\n                return sinQ(xa, xb);\n            case 1:\n                return cosQ(xa, xb);\n            case 2:\n                return -sinQ(xa, xb);\n            case 3:\n                return -cosQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }\n\n    \n    public static double cos(double x) {\n        int quadrant = 0;\n\n        \n        double xa = x;\n        if (x < 0) {\n            xa = -xa;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        \n        double xb = 0;\n        if (xa > 3294198.0) {\n            \n            \n            \n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa, xb);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        \n        \n\n        switch (quadrant) {\n            case 0:\n                return cosQ(xa, xb);\n            case 1:\n                return -sinQ(xa, xb);\n            case 2:\n                return -cosQ(xa, xb);\n            case 3:\n                return sinQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }\n\n    \n    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        \n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        \n        if (xa == 0.0) {\n            long bits = Double.doubleToLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        \n        double xb = 0;\n        if (xa > 3294198.0) {\n            \n            \n            \n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa, xb);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            \n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\n            result = -result;\n        }\n\n        return result;\n    }\n\n    \n    public static double atan(double x) {\n        return atan(x, 0.0, false);\n    }\n\n    \n    private static double atan(double xa, double xb, boolean leftPlane) {\n        boolean negate = false;\n        int idx;\n\n        if (xa == 0.0) { \n            return leftPlane ? copySign(Math.PI, xa) : xa;\n        }\n\n        if (xa < 0) {\n            \n            xa = -xa;\n            xb = -xb;\n            negate = true;\n        }\n\n        if (xa > 1.633123935319537E16) { \n            return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2);\n        }\n\n        \n        if (xa < 1) {\n            idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5);\n        } else {\n            final double oneOverXa = 1 / xa;\n            idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07);\n        }\n        double epsA = xa - TANGENT_TABLE_A[idx];\n        double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]);\n        epsB += xb - TANGENT_TABLE_B[idx];\n\n        double temp = epsA + epsB;\n        epsB = -(temp - epsA - epsB);\n        epsA = temp;\n\n        \n        temp = xa * HEX_40000000;\n        double ya = xa + temp - temp;\n        double yb = xb + xa - ya;\n        xa = ya;\n        xb += yb;\n\n        \n        if (idx == 0) {\n            \n            \n            final double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx]));\n            \n            ya = epsA * denom;\n            yb = epsB * denom;\n        } else {\n            double temp2 = xa * TANGENT_TABLE_A[idx];\n            double za = 1d + temp2;\n            double zb = -(za - 1d - temp2);\n            temp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx];\n            temp = za + temp2;\n            zb += -(temp - za - temp2);\n            za = temp;\n\n            zb += xb * TANGENT_TABLE_B[idx];\n            ya = epsA / za;\n\n            temp = ya * HEX_40000000;\n            final double yaa = (ya + temp) - temp;\n            final double yab = ya - yaa;\n\n            temp = za * HEX_40000000;\n            final double zaa = (za + temp) - temp;\n            final double zab = za - zaa;\n\n            \n            yb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za;\n\n            yb += -epsA * zb / za / za;\n            yb += epsB / za;\n        }\n\n\n        epsA = ya;\n        epsB = yb;\n\n        \n        final double epsA2 = epsA * epsA;\n\n        \n\n        yb = 0.07490822288864472;\n        yb = yb * epsA2 + -0.09088450866185192;\n        yb = yb * epsA2 + 0.11111095942313305;\n        yb = yb * epsA2 + -0.1428571423679182;\n        yb = yb * epsA2 + 0.19999999999923582;\n        yb = yb * epsA2 + -0.33333333333333287;\n        yb = yb * epsA2 * epsA;\n\n\n        ya = epsA;\n\n        temp = ya + yb;\n        yb = -(temp - ya - yb);\n        ya = temp;\n\n        \n        yb += epsB / (1d + epsA * epsA);\n\n        \n        double za = EIGHTHS[idx] + ya;\n        double zb = -(za - EIGHTHS[idx] - ya);\n        temp = za + yb;\n        zb += -(temp - za - yb);\n        za = temp;\n\n        double result = za + zb;\n        double resultb = -(result - za - zb);\n\n        if (leftPlane) {\n            \n            final double pia = 1.5707963267948966 * 2;\n            final double pib = 6.123233995736766E-17 * 2;\n\n            za = pia - result;\n            zb = -(za - pia + result);\n            zb += pib - resultb;\n\n            result = za + zb;\n            resultb = -(result - za - zb);\n        }\n\n\n        if (negate ^ leftPlane) {\n            result = -result;\n        }\n\n        return result;\n    }\n\n    \n    public static double atan2(double y, double x) {\n        if (x != x || y != y) {\n            return Double.NaN;\n        }\n\n        if (y == 0) {\n            final double result = x * y;\n            final double invx = 1d / x;\n            final double invy = 1d / y;\n\n            if (invx == 0) { \n                if (x > 0) {\n                    return y; \n                } else {\n                    return copySign(Math.PI, y);\n                }\n            }\n\n            if (x < 0 || invx < 0) {\n                if (y < 0 || invy < 0) {\n                    return -Math.PI;\n                } else {\n                    return Math.PI;\n                }\n            } else {\n                return result;\n            }\n        }\n\n        \n\n        if (y == Double.POSITIVE_INFINITY) {\n            if (x == Double.POSITIVE_INFINITY) {\n                return Math.PI * F_1_4;\n            }\n\n            if (x == Double.NEGATIVE_INFINITY) {\n                return Math.PI * F_3_4;\n            }\n\n            return Math.PI * F_1_2;\n        }\n\n        if (y == Double.NEGATIVE_INFINITY) {\n            if (x == Double.POSITIVE_INFINITY) {\n                return -Math.PI * F_1_4;\n            }\n\n            if (x == Double.NEGATIVE_INFINITY) {\n                return -Math.PI * F_3_4;\n            }\n\n            return -Math.PI * F_1_2;\n        }\n\n        if (x == Double.POSITIVE_INFINITY) {\n            if (y > 0 || 1 / y > 0) {\n                return 0d;\n            }\n\n            if (y < 0 || 1 / y < 0) {\n                return -0d;\n            }\n        }\n\n        if (x == Double.NEGATIVE_INFINITY)\n        {\n            if (y > 0.0 || 1 / y > 0.0) {\n                return Math.PI;\n            }\n\n            if (y < 0 || 1 / y < 0) {\n                return -Math.PI;\n            }\n        }\n\n        \n\n        if (x == 0) {\n            if (y > 0 || 1 / y > 0) {\n                return Math.PI * F_1_2;\n            }\n\n            if (y < 0 || 1 / y < 0) {\n                return -Math.PI * F_1_2;\n            }\n        }\n\n        \n        final double r = y / x;\n        if (Double.isInfinite(r)) { \n            return atan(r, 0, x < 0);\n        }\n\n        double ra = doubleHighPart(r);\n        double rb = r - ra;\n\n        \n        final double xa = doubleHighPart(x);\n        final double xb = x - xa;\n\n        rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n\n        final double temp = ra + rb;\n        rb = -(temp - ra - rb);\n        ra = temp;\n\n        if (ra == 0) { \n            ra = copySign(0d, y);\n        }\n\n        \n        final double result = atan(ra, rb, x < 0);\n\n        return result;\n    }\n\n    \n    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { \n          return x;\n      }\n\n      \n\n      \n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      \n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      \n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      \n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      \n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      \n      double dx = zb / (2.0*y);\n\n      \n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  \n      rb += -x * dx / y / y;  \n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }\n\n    \n    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      \n\n      \n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      \n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      \n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      \n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      \n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      \n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      \n      double r = y/x;\n\n      \n      if (Double.isInfinite(r)) { \n          return Math.PI/2; \n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  \n      rb += yb / x;  \n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }\n\n    \n    public static double cbrt(double x) {\n      \n      long inbits = Double.doubleToLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          \n          subnormal = true;\n          x *= 1.8014398509481984E16;  \n          inbits = Double.doubleToLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          \n          return x;\n      }\n\n      \n      int exp3 = exponent / 3;\n\n      \n      double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) |\n                                          (long)(((exp3 + 1023) & 0x7ff)) << 52);\n\n      \n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      \n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      \n      \n      \n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      \n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      \n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  \n      }\n\n      return est;\n    }\n\n    \n    public static double toRadians(double x) {\n        if (Double.isInfinite(x) || x == 0.0) { \n            return x;\n        }\n\n        \n        final double facta = 0.01745329052209854;\n        final double factb = 1.997844754509471E-9;\n\n        double xa = doubleHighPart(x);\n        double xb = x - xa;\n\n        double result = xb * factb + xb * facta + xa * factb + xa * facta;\n        if (result == 0) {\n            result = result * x; \n        }\n        return result;\n    }\n\n    \n    public static double toDegrees(double x) {\n        if (Double.isInfinite(x) || x == 0.0) { \n            return x;\n        }\n\n        \n        final double facta = 57.2957763671875;\n        final double factb = 3.145894820876798E-6;\n\n        double xa = doubleHighPart(x);\n        double xb = x - xa;\n\n        return xb * factb + xb * facta + xa * factb + xa * facta;\n    }\n\n    \n    public static int abs(final int x) {\n        return (x < 0) ? -x : x;\n    }\n\n    \n    public static long abs(final long x) {\n        return (x < 0l) ? -x : x;\n    }\n\n    \n    public static float abs(final float x) {\n        return (x < 0.0f) ? -x : (x == 0.0f) ? 0.0f : x; \n    }\n\n    \n    public static double abs(double x) {\n        return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; \n    }\n\n    \n    public static double ulp(double x) {\n        if (Double.isInfinite(x)) {\n            return Double.POSITIVE_INFINITY;\n        }\n        return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1));\n    }\n\n    \n    public static float ulp(float x) {\n        if (Float.isInfinite(x)) {\n            return Float.POSITIVE_INFINITY;\n        }\n        return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1));\n    }\n\n    \n    public static double scalb(final double d, final int n) {\n\n        \n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        \n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        \n        final long bits = Double.doubleToLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        \n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            \n            if (scaledExponent > 0) {\n                \n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                \n\n                \n                mantissa = mantissa | (1L << 52);\n\n                \n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    \n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                \n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            \n            if (exponent == 0) {\n\n                \n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }\n\n    \n    public static float scalb(final float f, final int n) {\n\n        \n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        \n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        \n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        \n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            \n            if (scaledExponent > 0) {\n                \n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                \n\n                \n                mantissa = mantissa | (1 << 23);\n\n                \n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    \n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                \n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            \n            if (exponent == 0) {\n\n                \n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }\n\n    \n    public static double nextAfter(double d, double direction) {\n\n        \n        if (Double.isNaN(d) || Double.isNaN(direction)) {\n            return Double.NaN;\n        } else if (d == direction) {\n            return direction;\n        } else if (Double.isInfinite(d)) {\n            return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE;\n        } else if (d == 0) {\n            return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n        }\n        \n        \n\n        final long bits = Double.doubleToLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        if ((direction < d) ^ (sign == 0L)) {\n            return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1));\n        } else {\n            return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1));\n        }\n\n    }\n\n    \n    public static float nextAfter(final float f, final double direction) {\n\n        \n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        \n        \n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) - 1));\n        }\n\n    }\n\n    \n    public static double floor(double x) {\n        long y;\n\n        if (x != x) { \n            return x;\n        }\n\n        if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) {\n            return x;\n        }\n\n        y = (long) x;\n        if (x < 0 && y != x) {\n            y--;\n        }\n\n        if (y == 0) {\n            return x*y;\n        }\n\n        return y;\n    }\n\n    \n    public static double ceil(double x) {\n        double y;\n\n        if (x != x) { \n            return x;\n        }\n\n        y = floor(x);\n        if (y == x) {\n            return y;\n        }\n\n        y += 1.0;\n\n        if (y == 0) {\n            return x*y;\n        }\n\n        return y;\n    }\n\n    \n    public static double rint(double x) {\n        double y = floor(x);\n        double d = x - y;\n\n        if (d > 0.5) {\n            if (y == -1.0) {\n                return -0.0; \n            }\n            return y+1.0;\n        }\n        if (d < 0.5) {\n            return y;\n        }\n\n        \n        long z = (long) y;\n        return (z & 1) == 0 ? y : y + 1.0;\n    }\n\n    \n    public static long round(double x) {\n        return (long) floor(x + 0.5);\n    }\n\n    \n    public static int round(final float x) {\n        return (int) floor(x + 0.5f);\n    }\n\n    \n    public static int min(final int a, final int b) {\n        return (a <= b) ? a : b;\n    }\n\n    \n    public static long min(final long a, final long b) {\n        return (a <= b) ? a : b;\n    }\n\n    \n    public static float min(final float a, final float b) {\n        if (a > b) {\n            return b;\n        }\n        if (a < b) {\n            return a;\n        }\n        \n        if (a != b) {\n            return Float.NaN;\n        }\n        \n        \n        int bits = Float.floatToRawIntBits(a);\n        if (bits == 0x80000000) {\n            return a;\n        }\n        return b;\n    }\n\n    \n    public static double min(final double a, final double b) {\n        if (a > b) {\n            return b;\n        }\n        if (a < b) {\n            return a;\n        }\n        \n        if (a != b) {\n            return Double.NaN;\n        }\n        \n        \n        long bits = Double.doubleToRawLongBits(a);\n        if (bits == 0x8000000000000000L) {\n            return a;\n        }\n        return b;\n    }\n\n    \n    public static int max(final int a, final int b) {\n        return (a <= b) ? b : a;\n    }\n\n    \n    public static long max(final long a, final long b) {\n        return (a <= b) ? b : a;\n    }\n\n    \n    public static float max(final float a, final float b) {\n        if (a > b) {\n            return a;\n        }\n        if (a < b) {\n            return b;\n        }\n        \n        if (a != b) {\n            return Float.NaN;\n        }\n        \n        \n        int bits = Float.floatToRawIntBits(a);\n        if (bits == 0x80000000) {\n            return b;\n        }\n        return a;\n    }\n\n    \n    public static double max(final double a, final double b) {\n        if (a > b) {\n            return a;\n        }\n        if (a < b) {\n            return b;\n        }\n        \n        if (a != b) {\n            return Double.NaN;\n        }\n        \n        \n        long bits = Double.doubleToRawLongBits(a);\n        if (bits == 0x8000000000000000L) {\n            return b;\n        }\n        return a;\n    }\n\n    \n    public static double hypot(final double x, final double y) {\n        if (Double.isInfinite(x) || Double.isInfinite(y)) {\n            return Double.POSITIVE_INFINITY;\n        } else if (Double.isNaN(x) || Double.isNaN(y)) {\n            return Double.NaN;\n        } else {\n\n            final int expX = getExponent(x);\n            final int expY = getExponent(y);\n            if (expX > expY + 27) {\n                \n                return abs(x);\n            } else if (expY > expX + 27) {\n                \n                return abs(y);\n            } else {\n\n                \n                final int middleExp = (expX + expY) / 2;\n\n                \n                final double scaledX = scalb(x, -middleExp);\n                final double scaledY = scalb(y, -middleExp);\n\n                \n                final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY);\n\n                \n                return scalb(scaledH, middleExp);\n\n            }\n\n        }\n    }\n\n    \n    public static double IEEEremainder(double dividend, double divisor) {\n        return StrictMath.IEEEremainder(dividend, divisor); \n    }\n\n    \n    public static double copySign(double magnitude, double sign) {\n        long m = Double.doubleToLongBits(magnitude);\n        long s = Double.doubleToLongBits(sign);\n        if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { \n            return magnitude;\n        }\n        return -magnitude; \n    }\n\n    \n    public static float copySign(float magnitude, float sign) {\n        int m = Float.floatToIntBits(magnitude);\n        int s = Float.floatToIntBits(sign);\n        if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { \n            return magnitude;\n        }\n        return -magnitude; \n    }\n\n    \n    public static int getExponent(final double d) {\n        return (int) ((Double.doubleToLongBits(d) >>> 52) & 0x7ff) - 1023;\n    }\n\n    \n    public static int getExponent(final float f) {\n        return ((Float.floatToIntBits(f) >>> 23) & 0xff) - 127;\n    }\n\n    \n    public static void main(String[] a) {\n        PrintStream out = System.out;\n        FastMathCalc.printarray(out, \"EXP_INT_TABLE_A\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A);\n        FastMathCalc.printarray(out, \"EXP_INT_TABLE_B\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B);\n        FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_A\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A);\n        FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_B\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B);\n        FastMathCalc.printarray(out, \"LN_MANT\",LN_MANT_LEN, lnMant.LN_MANT);\n        FastMathCalc.printarray(out, \"SINE_TABLE_A\", SINE_TABLE_LEN, SINE_TABLE_A);\n        FastMathCalc.printarray(out, \"SINE_TABLE_B\", SINE_TABLE_LEN, SINE_TABLE_B);\n        FastMathCalc.printarray(out, \"COSINE_TABLE_A\", SINE_TABLE_LEN, COSINE_TABLE_A);\n        FastMathCalc.printarray(out, \"COSINE_TABLE_B\", SINE_TABLE_LEN, COSINE_TABLE_B);\n        FastMathCalc.printarray(out, \"TANGENT_TABLE_A\", SINE_TABLE_LEN, TANGENT_TABLE_A);\n        FastMathCalc.printarray(out, \"TANGENT_TABLE_B\", SINE_TABLE_LEN, TANGENT_TABLE_B);\n    }\n\n    \n    private static class ExpIntTable { private static final double[] EXP_INT_TABLE_A; private static final double[] EXP_INT_TABLE_B; static { if (RECOMPUTE_TABLES_AT_RUNTIME) {\n                EXP_INT_TABLE_A = new double[FastMath.EXP_INT_TABLE_LEN];\n                EXP_INT_TABLE_B = new double[FastMath.EXP_INT_TABLE_LEN];\n\n                final double tmp[] = new double[2];\n                final double recip[] = new double[2];\n\n                \n                for (int i = 0; i < FastMath.EXP_INT_TABLE_MAX_INDEX; i++) {\n                    FastMathCalc.expint(i, tmp);\n                    EXP_INT_TABLE_A[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[0];\n                    EXP_INT_TABLE_B[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[1];\n\n                    if (i != 0) {\n                        \n                        FastMathCalc.splitReciprocal(tmp, recip);\n                        EXP_INT_TABLE_A[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[0];\n                        EXP_INT_TABLE_B[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[1];\n                    }\n                }\n            } else {\n                EXP_INT_TABLE_A = FastMathLiteralArrays.loadExpIntA();\n                EXP_INT_TABLE_B = FastMathLiteralArrays.loadExpIntB();\n            }\n        }\n    }\n\n    \n    private static class ExpFracTable { private static final double[] EXP_FRAC_TABLE_A; private static final double[] EXP_FRAC_TABLE_B; static { if (RECOMPUTE_TABLES_AT_RUNTIME) {\n                EXP_FRAC_TABLE_A = new double[FastMath.EXP_FRAC_TABLE_LEN];\n                EXP_FRAC_TABLE_B = new double[FastMath.EXP_FRAC_TABLE_LEN];\n\n                final double tmp[] = new double[2];\n\n                \n                final double factor = 1d / (EXP_FRAC_TABLE_LEN - 1);\n                for (int i = 0; i < EXP_FRAC_TABLE_A.length; i++) {\n                    FastMathCalc.slowexp(i * factor, tmp);\n                    EXP_FRAC_TABLE_A[i] = tmp[0];\n                    EXP_FRAC_TABLE_B[i] = tmp[1];\n                }\n            } else {\n                EXP_FRAC_TABLE_A = FastMathLiteralArrays.loadExpFracA();\n                EXP_FRAC_TABLE_B = FastMathLiteralArrays.loadExpFracB();\n            }\n        }\n    }\n\n    \n    private static class lnMant { private static final double[][] LN_MANT; static { if (RECOMPUTE_TABLES_AT_RUNTIME) {\n                LN_MANT = new double[FastMath.LN_MANT_LEN][];\n\n                \n                for (int i = 0; i < LN_MANT.length; i++) {\n                    final double d = Double.longBitsToDouble( (((long) i) << 42) | 0x3ff0000000000000L );\n                    LN_MANT[i] = FastMathCalc.slowLog(d);\n                }\n            } else {\n                LN_MANT = FastMathLiteralArrays.loadLnMant();\n            }\n        }\n    }\n\n    \n    private static class CodyWaite { private final int finalK; private final double finalRemA; private final double finalRemB; CodyWaite(double xa, double xb) {\n            \n            \n            int k = (int)(xa * 0.6366197723675814);\n\n            \n            double remA;\n            double remB;\n            while (true) {\n                double a = -k * 1.570796251296997;\n                remA = xa + a;\n                remB = -(remA - xa - a);\n\n                a = -k * 7.549789948768648E-8;\n                double b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                a = -k * 6.123233995736766E-17;\n                b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                if (remA > 0) {\n                    break;\n                }\n\n                \n                \n                \n                --k;\n            }\n\n            this.finalK = k;\n            this.finalRemA = remA;\n            this.finalRemB = remB;\n        }\n\n        \n        int getK() {\n            return finalK;\n        }\n        \n        double getRemA() {\n            return finalRemA;\n        }\n        \n        double getRemB() {\n            return finalRemB;\n        }\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.math3.util;\n\nimport java.io.PrintStream;\n\n\npublic class FastMath { private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE); public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9; public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8; static final int EXP_INT_TABLE_MAX_INDEX = 750; static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2; static final int LN_MANT_LEN = 1024; static final int EXP_FRAC_TABLE_LEN = 1025; private static final boolean RECOMPUTE_TABLES_AT_RUNTIME = false; private static final double LN_2_A = 0.693147063255310059; private static final double LN_2_B = 1.17304635250823482e-7; private static final double LN_QUICK_COEF[][] = {\n        {1.0, 5.669184079525E-24},\n        {-0.25, -0.25},\n        {0.3333333134651184, 1.986821492305628E-8},\n        {-0.25, -6.663542893624021E-14},\n        {0.19999998807907104, 1.1921056801463227E-8},\n        {-0.1666666567325592, -7.800414592973399E-9},\n        {0.1428571343421936, 5.650007086920087E-9},\n        {-0.12502530217170715, -7.44321345601866E-11},\n        {0.11113807559013367, 9.219544613762692E-9},\n    };\n\n    \n    private static final double LN_HI_PREC_COEF[][] = { {1.0, -6.032174644509064E-23}, {-0.25, -0.25}, {0.3333333134651184, 1.9868161777724352E-8}, {-0.2499999701976776, -2.957007209750105E-8}, {0.19999954104423523, 1.5830993332061267E-10}, {-0.16624879837036133, -2.6033824355191673E-8} }; private static final int SINE_TABLE_LEN = 14; private static final double SINE_TABLE_A[] = { +0.0d, +0.1246747374534607d, +0.24740394949913025d, +0.366272509098053d, +0.4794255495071411d, +0.5850973129272461d, +0.6816387176513672d, +0.7675435543060303d, +0.8414709568023682d, +0.902267575263977d, +0.9489846229553223d, +0.9808930158615112d, +0.9974949359893799d, +0.9985313415527344d, }; private static final double SINE_TABLE_B[] = { +0.0d, -4.068233003401932E-9d, +9.755392680573412E-9d, +1.9987994582857286E-8d, -1.0902938113007961E-8d, -3.9986783938944604E-8d, +4.23719669792332E-8d, -5.207000323380292E-8d, +2.800552834259E-8d, +1.883511811213715E-8d, -3.5997360512765566E-9d, +4.116164446561962E-8d, +5.0614674548127384E-8d, -1.0129027912496858E-9d, }; private static final double COSINE_TABLE_A[] = { +1.0d, +0.9921976327896118d, +0.9689123630523682d, +0.9305076599121094d, +0.8775825500488281d, +0.8109631538391113d, +0.7316888570785522d, +0.6409968137741089d, +0.5403022766113281d, +0.4311765432357788d, +0.3153223395347595d, +0.19454771280288696d, +0.07073719799518585d, -0.05417713522911072d, }; private static final double COSINE_TABLE_B[] = { +0.0d, +3.4439717236742845E-8d, +5.865827662008209E-8d, -3.7999795083850525E-8d, +1.184154459111628E-8d, -3.43338934259355E-8d, +1.1795268640216787E-8d, +4.438921624363781E-8d, +2.925681159240093E-8d, -2.6437112632041807E-8d, +2.2860509143963117E-8d, -4.813899778443457E-9d, +3.6725170580355583E-9d, +2.0217439756338078E-10d, }; private static final double TANGENT_TABLE_A[] = { +0.0d, +0.1256551444530487d, +0.25534194707870483d, +0.3936265707015991d, +0.5463024377822876d, +0.7214844226837158d, +0.9315965175628662d, +1.1974215507507324d, +1.5574076175689697d, +2.092571258544922d, +3.0095696449279785d, +5.041914939880371d, +14.101419448852539d, -18.430862426757812d, }; private static final double TANGENT_TABLE_B[] = { +0.0d, -7.877917738262007E-9d, -2.5857668567479893E-8d, +5.2240336371356666E-9d, +5.206150291559893E-8d, +1.8307188599677033E-8d, -5.7618793749770706E-8d, +7.848361555046424E-8d, +1.0708593250394448E-7d, +1.7827257129423813E-8d, +2.893485277253286E-8d, +3.1660099222737955E-7d, +4.983191803254889E-7d, -3.356118100840571E-7d, }; private static final long RECIP_2PI[] = new long[] { (0x28be60dbL << 32) | 0x9391054aL, (0x7f09d5f4L << 32) | 0x7d4d3770L, (0x36d8a566L << 32) | 0x4f10e410L, (0x7f9458eaL << 32) | 0xf7aef158L, (0x6dc91b8eL << 32) | 0x909374b8L, (0x01924bbaL << 32) | 0x82746487L, (0x3f877ac7L << 32) | 0x2c4a69cfL, (0xba208d7dL << 32) | 0x4baed121L, (0x3a671c09L << 32) | 0xad17df90L, (0x4e64758eL << 32) | 0x60d4ce7dL, (0x272117e2L << 32) | 0xef7e4a0eL, (0xc7fe25ffL << 32) | 0xf7816603L, (0xfbcbc462L << 32) | 0xd6829b47L, (0xdb4d9fb3L << 32) | 0xc9f2c26dL, (0xd3d18fd9L << 32) | 0xa797fa8bL, (0x5d49eeb1L << 32) | 0xfaf97c5eL, (0xcf41ce7dL << 32) | 0xe294a4baL, 0x9afed7ecL << 32 }; private static final long PI_O_4_BITS[] = new long[] {\n        (0xc90fdaa2L << 32) | 0x2168c234L,\n        (0xc4c6628bL << 32) | 0x80dc1cd1L };\n\n    \n    private static final double EIGHTHS[] = {0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625}; private static final double CBRTTWO[] = { 0.6299605249474366, 0.7937005259840998, 1.0, 1.2599210498948732, 1.5874010519681994 }; private static final long HEX_40000000 = 0x40000000L; private static final long MASK_30BITS = -1L - (HEX_40000000 -1); private static final double TWO_POWER_52 = 4503599627370496.0; private static final double F_1_3 = 1d / 3d; private static final double F_1_5 = 1d / 5d; private static final double F_1_7 = 1d / 7d; private static final double F_1_9 = 1d / 9d; private static final double F_1_11 = 1d / 11d; private static final double F_1_13 = 1d / 13d; private static final double F_1_15 = 1d / 15d; private static final double F_1_17 = 1d / 17d; private static final double F_3_4 = 3d / 4d; private static final double F_15_16 = 15d / 16d; private static final double F_13_14 = 13d / 14d; private static final double F_11_12 = 11d / 12d; private static final double F_9_10 = 9d / 10d; private static final double F_7_8 = 7d / 8d; private static final double F_5_6 = 5d / 6d; private static final double F_1_2 = 1d / 2d; private static final double F_1_4 = 1d / 4d; private FastMath() {}\n\n    \n\n    \n    private static double doubleHighPart(double d) {\n        if (d > -Precision.SAFE_MIN && d < Precision.SAFE_MIN){\n            return d; \n        }\n        long xl = Double.doubleToLongBits(d);\n        xl = xl & MASK_30BITS; \n        return Double.longBitsToDouble(xl);\n    }\n\n    \n    public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }\n\n    \n    public static double cosh(double x) {\n      if (x != x) {\n          return x;\n      }\n\n      \n\n      \n      \n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              \n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              \n              final double t = exp(-0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(-x);\n          }\n      }\n\n      final double hiPrec[] = new double[2];\n      if (x < 0.0) {\n          x = -x;\n      }\n      exp(x, 0.0, hiPrec);\n\n      double ya = hiPrec[0] + hiPrec[1];\n      double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n      double temp = ya * HEX_40000000;\n      double yaa = ya + temp - temp;\n      double yab = ya - yaa;\n\n      \n      double recip = 1.0/ya;\n      temp = recip * HEX_40000000;\n      double recipa = recip + temp - temp;\n      double recipb = recip - recipa;\n\n      \n      recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n      \n      recipb += -yb * recip * recip;\n\n      \n      temp = ya + recipa;\n      yb += -(temp - ya - recipa);\n      ya = temp;\n      temp = ya + recipb;\n      yb += -(temp - ya - recipb);\n      ya = temp;\n\n      double result = ya + yb;\n      result *= 0.5;\n      return result;\n    }\n\n    \n    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      \n\n      \n      \n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              \n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              \n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          \n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          \n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          \n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          \n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          \n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          \n          rb += yb*denomr;                        \n          rb += -ya * denomb * denomr * denomr;   \n\n          \n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }\n\n    \n    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      \n      \n      \n\n      \n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          \n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          \n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          \n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          \n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          \n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          \n          ratiob += nb / da;\n          \n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          \n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          \n          double na = ya;\n          double nb = yb;\n\n          \n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          \n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          \n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          \n          ratiob += nb / da;\n          \n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }\n\n    \n    public static double acosh(final double a) {\n        return FastMath.log(a + FastMath.sqrt(a * a - 1));\n    }\n\n    \n    public static double asinh(double a) {\n        boolean negative = false;\n        if (a < 0) {\n            negative = true;\n            a = -a;\n        }\n\n        double absAsinh;\n        if (a > 0.167) {\n            absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);\n        } else {\n            final double a2 = a * a;\n            if (a > 0.097) {\n                absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n            } else if (a > 0.036) {\n                absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n            } else if (a > 0.0036) {\n                absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n            } else {\n                absAsinh = a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2);\n            }\n        }\n\n        return negative ? -absAsinh : absAsinh;\n    }\n\n    \n    public static double atanh(double a) {\n        boolean negative = false;\n        if (a < 0) {\n            negative = true;\n            a = -a;\n        }\n\n        double absAtanh;\n        if (a > 0.15) {\n            absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n        } else {\n            final double a2 = a * a;\n            if (a > 0.087) {\n                absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));\n            } else if (a > 0.031) {\n                absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));\n            } else if (a > 0.003) {\n                absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));\n            } else {\n                absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5));\n            }\n        }\n\n        return negative ? -absAtanh : absAtanh;\n    }\n\n    \n    public static double signum(final double a) {\n        return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : a); \n    }\n\n    \n    public static float signum(final float a) {\n        return (a < 0.0f) ? -1.0f : ((a > 0.0f) ? 1.0f : a); \n    }\n\n    \n    public static double nextUp(final double a) {\n        return nextAfter(a, Double.POSITIVE_INFINITY);\n    }\n\n    \n    public static float nextUp(final float a) {\n        return nextAfter(a, Float.POSITIVE_INFINITY);\n    }\n\n    \n    public static double random() {\n        return Math.random();\n    }\n\n    \n    public static double exp(double x) {\n        return exp(x, 0.0, null);\n    }\n\n    \n    private static double exp(double x, double extra, double[] hiPrec) {\n        double intPartA;\n        double intPartB;\n        int intVal;\n\n        \n        if (x < 0.0) {\n            intVal = (int) -x;\n\n            if (intVal > 746) {\n                if (hiPrec != null) {\n                    hiPrec[0] = 0.0;\n                    hiPrec[1] = 0.0;\n                }\n                return 0.0;\n            }\n\n            if (intVal > 709) {\n                \n                final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;\n                if (hiPrec != null) {\n                    hiPrec[0] /= 285040095144011776.0;\n                    hiPrec[1] /= 285040095144011776.0;\n                }\n                return result;\n            }\n\n            if (intVal == 709) {\n                \n                final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;\n                if (hiPrec != null) {\n                    hiPrec[0] /= 4.455505956692756620;\n                    hiPrec[1] /= 4.455505956692756620;\n                }\n                return result;\n            }\n\n            intVal++;\n\n            intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal];\n            intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal];\n\n            intVal = -intVal;\n        } else {\n            intVal = (int) x;\n\n            if (intVal > 709) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.POSITIVE_INFINITY;\n                    hiPrec[1] = 0.0;\n                }\n                return Double.POSITIVE_INFINITY;\n            }\n\n            intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal];\n            intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal];\n        }\n\n        \n        final int intFrac = (int) ((x - intVal) * 1024.0);\n        final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac];\n        final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n\n        \n        final double epsilon = x - (intVal + intFrac / 1024.0);\n\n        \n\n        \n        double z = 0.04168701738764507;\n        z = z * epsilon + 0.1666666505023083;\n        z = z * epsilon + 0.5000000000042687;\n        z = z * epsilon + 1.0;\n        z = z * epsilon + -3.940510424527919E-20;\n\n        \n        double tempA = intPartA * fracPartA;\n        double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\n\n        \n        final double tempC = tempB + tempA;\n        final double result;\n        if (extra != 0.0) {\n            result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;\n        } else {\n            result = tempC*z + tempB + tempA;\n        }\n\n        if (hiPrec != null) {\n            \n            hiPrec[0] = tempA;\n            hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB;\n        }\n\n        return result;\n    }\n\n    \n    public static double expm1(double x) {\n      return expm1(x, null);\n    }\n\n    \n    private static double expm1(double x, double hiPrecOut[]) {\n        if (x != x || x == 0.0) { \n            return x;\n        }\n\n        if (x <= -1.0 || x >= 1.0) {\n            \n            \n            double hiPrec[] = new double[2];\n            exp(x, 0.0, hiPrec);\n            if (x > 0.0) {\n                return -1.0 + hiPrec[0] + hiPrec[1];\n            } else {\n                final double ra = -1.0 + hiPrec[0];\n                double rb = -(ra + 1.0 - hiPrec[0]);\n                rb += hiPrec[1];\n                return ra + rb;\n            }\n        }\n\n        double baseA;\n        double baseB;\n        double epsilon;\n        boolean negative = false;\n\n        if (x < 0.0) {\n            x = -x;\n            negative = true;\n        }\n\n        {\n            int intFrac = (int) (x * 1024.0);\n            double tempA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac] - 1.0;\n            double tempB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n\n            double temp = tempA + tempB;\n            tempB = -(temp - tempA - tempB);\n            tempA = temp;\n\n            temp = tempA * HEX_40000000;\n            baseA = tempA + temp - temp;\n            baseB = tempB + (tempA - baseA);\n\n            epsilon = x - intFrac/1024.0;\n        }\n\n\n        \n        double zb = 0.008336750013465571;\n        zb = zb * epsilon + 0.041666663879186654;\n        zb = zb * epsilon + 0.16666666666745392;\n        zb = zb * epsilon + 0.49999999999999994;\n        zb = zb * epsilon;\n        zb = zb * epsilon;\n\n        double za = epsilon;\n        double temp = za + zb;\n        zb = -(temp - za - zb);\n        za = temp;\n\n        temp = za * HEX_40000000;\n        temp = za + temp - temp;\n        zb += za - temp;\n        za = temp;\n\n        \n        double ya = za * baseA;\n        \n        temp = ya + za * baseB;\n        double yb = -(temp - ya - za * baseB);\n        ya = temp;\n\n        temp = ya + zb * baseA;\n        yb += -(temp - ya - zb * baseA);\n        ya = temp;\n\n        temp = ya + zb * baseB;\n        yb += -(temp - ya - zb*baseB);\n        ya = temp;\n\n        \n        \n        temp = ya + baseA;\n        yb += -(temp - baseA - ya);\n        ya = temp;\n\n        temp = ya + za;\n        \n        yb += -(temp - ya - za);\n        ya = temp;\n\n        temp = ya + baseB;\n        \n        yb += -(temp - ya - baseB);\n        ya = temp;\n\n        temp = ya + zb;\n        \n        yb += -(temp - ya - zb);\n        ya = temp;\n\n        if (negative) {\n            \n            double denom = 1.0 + ya;\n            double denomr = 1.0 / denom;\n            double denomb = -(denom - 1.0 - ya) + yb;\n            double ratio = ya * denomr;\n            temp = ratio * HEX_40000000;\n            final double ra = ratio + temp - temp;\n            double rb = ratio - ra;\n\n            temp = denom * HEX_40000000;\n            za = denom + temp - temp;\n            zb = denom - za;\n\n            rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;\n\n            \n            \n            \n            \n            \n            \n            \n\n            \n            rb += yb * denomr;                      \n            rb += -ya * denomb * denomr * denomr;   \n\n            \n            ya = -ra;\n            yb = -rb;\n        }\n\n        if (hiPrecOut != null) {\n            hiPrecOut[0] = ya;\n            hiPrecOut[1] = yb;\n        }\n\n        return ya + yb;\n    }\n\n    \n    public static double log(final double x) {\n        return log(x, null);\n    }\n\n    \n    private static double log(final double x, final double[] hiPrec) {\n        if (x==0) { \n            return Double.NEGATIVE_INFINITY;\n        }\n        long bits = Double.doubleToLongBits(x);\n\n        \n        if ((bits & 0x8000000000000000L) != 0 || x != x) {\n            if (x != 0.0) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NaN;\n                }\n\n                return Double.NaN;\n            }\n        }\n\n        \n        if (x == Double.POSITIVE_INFINITY) {\n            if (hiPrec != null) {\n                hiPrec[0] = Double.POSITIVE_INFINITY;\n            }\n\n            return Double.POSITIVE_INFINITY;\n        }\n\n        \n        int exp = (int)(bits >> 52)-1023;\n\n        if ((bits & 0x7ff0000000000000L) == 0) {\n            \n            if (x == 0) {\n                \n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.NEGATIVE_INFINITY;\n            }\n\n            \n            bits <<= 1;\n            while ( (bits & 0x0010000000000000L) == 0) {\n                --exp;\n                bits <<= 1;\n            }\n        }\n\n\n        if (exp == -1 || exp == 0) {\n            if (x < 1.01 && x > 0.99 && hiPrec == null) {\n                \n\n               \n                double xa = x - 1.0;\n                double xb = xa - x + 1.0;\n                double tmp = xa * HEX_40000000;\n                double aa = xa + tmp - tmp;\n                double ab = xa - aa;\n                xa = aa;\n                xb = ab;\n\n                final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];\n                double ya = lnCoef_last[0];\n                double yb = lnCoef_last[1];\n\n                for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\n                    \n                    aa = ya * xa;\n                    ab = ya * xb + yb * xa + yb * xb;\n                    \n                    tmp = aa * HEX_40000000;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n\n                    \n                    final double[] lnCoef_i = LN_QUICK_COEF[i];\n                    aa = ya + lnCoef_i[0];\n                    ab = yb + lnCoef_i[1];\n                    \n                    tmp = aa * HEX_40000000;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n                }\n\n                \n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                \n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                return ya + yb;\n            }\n        }\n\n        \n        final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n\n        \n\n        \n        \n        \n        final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\n\n        double lnza = 0.0;\n        double lnzb = 0.0;\n\n        if (hiPrec != null) {\n            \n            double tmp = epsilon * HEX_40000000;\n            double aa = epsilon + tmp - tmp;\n            double ab = epsilon - aa;\n            double xa = aa;\n            double xb = ab;\n\n            \n            final double numer = bits & 0x3ffffffffffL;\n            final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);\n            aa = numer - xa*denom - xb * denom;\n            xb += aa / denom;\n\n            \n            final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1];\n            double ya = lnCoef_last[0];\n            double yb = lnCoef_last[1];\n\n            for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {\n                \n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                \n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                \n                final double[] lnCoef_i = LN_HI_PREC_COEF[i];\n                aa = ya + lnCoef_i[0];\n                ab = yb + lnCoef_i[1];\n                \n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n            }\n\n            \n            aa = ya * xa;\n            ab = ya * xb + yb * xa + yb * xb;\n\n            \n            \n            lnza = aa + ab;\n            lnzb = -(lnza - aa - ab);\n        } else {\n            \n            lnza = -0.16624882440418567;\n            lnza = lnza * epsilon + 0.19999954120254515;\n            lnza = lnza * epsilon + -0.2499999997677497;\n            lnza = lnza * epsilon + 0.3333333333332802;\n            lnza = lnza * epsilon + -0.5;\n            lnza = lnza * epsilon + 1.0;\n            lnza = lnza * epsilon;\n        }\n\n        \n\n        \n\n        \n        double a = LN_2_A*exp;\n        double b = 0.0;\n        double c = a+lnm[0];\n        double d = -(c-a-lnm[0]);\n        a = c;\n        b = b + d;\n\n        c = a + lnza;\n        d = -(c - a - lnza);\n        a = c;\n        b = b + d;\n\n        c = a + LN_2_B*exp;\n        d = -(c - a - LN_2_B*exp);\n        a = c;\n        b = b + d;\n\n        c = a + lnm[1];\n        d = -(c - a - lnm[1]);\n        a = c;\n        b = b + d;\n\n        c = a + lnzb;\n        d = -(c - a - lnzb);\n        a = c;\n        b = b + d;\n\n        if (hiPrec != null) {\n            hiPrec[0] = a;\n            hiPrec[1] = b;\n        }\n\n        return a + b;\n    }\n\n    \n    public static double log1p(final double x) {\n        if (x == -1) {\n            return Double.NEGATIVE_INFINITY;\n        }\n\n        if (x == Double.POSITIVE_INFINITY) {\n            return Double.POSITIVE_INFINITY;\n        }\n\n        if (x > 1e-6 ||\n            x < -1e-6) {\n            final double xpa = 1 + x;\n            final double xpb = -(xpa - 1 - x);\n\n            final double[] hiPrec = new double[2];\n            final double lores = log(xpa, hiPrec);\n            if (Double.isInfinite(lores)) { \n                return lores;\n            }\n\n            \n            \n            final double fx1 = xpb / xpa;\n            final double epsilon = 0.5 * fx1 + 1;\n            return epsilon * fx1 + hiPrec[1] + hiPrec[0];\n        } else {\n            \n            final double y = (x * F_1_3 - F_1_2) * x + 1;\n            return y * x;\n        }\n    }\n\n    \n    public static double log10(final double x) {\n        final double hiPrec[] = new double[2];\n\n        final double lores = log(x, hiPrec);\n        if (Double.isInfinite(lores)){ \n            return lores;\n        }\n\n        final double tmp = hiPrec[0] * HEX_40000000;\n        final double lna = hiPrec[0] + tmp - tmp;\n        final double lnb = hiPrec[0] - lna + hiPrec[1];\n\n        final double rln10a = 0.4342944622039795;\n        final double rln10b = 1.9699272335463627E-8;\n\n        return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna;\n    }\n\n    \n    public static double log(double base, double x) {\n        return log(x) / log(base);\n    }\n\n    \n    public static double pow(double x, double y) {\n        final double lns[] = new double[2];\n\n        if (y == 0.0) {\n            return 1.0;\n        }\n\n        if (x != x) { \n            return x;\n        }\n\n\n        if (x == 0) {\n            long bits = Double.doubleToLongBits(x);\n            if ((bits & 0x8000000000000000L) != 0) {\n                \n                long yi = (long) y;\n\n                if (y < 0 && y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                if (y > 0 && y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n            }\n\n            if (y < 0) {\n                return Double.POSITIVE_INFINITY;\n            }\n            if (y > 0) {\n                return 0.0;\n            }\n\n            return Double.NaN;\n        }\n\n        if (x == Double.POSITIVE_INFINITY) {\n            if (y != y) { \n                return y;\n            }\n            if (y < 0.0) {\n                return 0.0;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.POSITIVE_INFINITY) {\n            if (x * x == 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x > 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        if (x == Double.NEGATIVE_INFINITY) {\n            if (y != y) { \n                return y;\n            }\n\n            if (y < 0) {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n\n                return 0.0;\n            }\n\n            if (y > 0)  {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.NEGATIVE_INFINITY) {\n\n            if (x * x == 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x < 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        \n        if (x < 0) {\n            \n            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n                return pow(-x, y);\n            }\n\n            if (y == (long) y) {\n                \n                return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n            } else {\n                return Double.NaN;\n            }\n        }\n\n        \n        double ya;\n        double yb;\n        if (y < 8e298 && y > -8e298) {\n            double tmp1 = y * HEX_40000000;\n            ya = y + tmp1 - tmp1;\n            yb = y - ya;\n        } else {\n            double tmp1 = y * 9.31322574615478515625E-10;\n            double tmp2 = tmp1 * 9.31322574615478515625E-10;\n            ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\n            yb = y - ya;\n        }\n\n        \n        final double lores = log(x, lns);\n        if (Double.isInfinite(lores)){ \n            return lores;\n        }\n\n        double lna = lns[0];\n        double lnb = lns[1];\n\n        \n        double tmp1 = lna * HEX_40000000;\n        double tmp2 = lna + tmp1 - tmp1;\n        lnb += lna - tmp2;\n        lna = tmp2;\n\n        \n        final double aa = lna * ya;\n        final double ab = lna * yb + lnb * ya + lnb * yb;\n\n        lna = aa+ab;\n        lnb = -(lna - aa - ab);\n\n        double z = 1.0 / 120.0;\n        z = z * lnb + (1.0 / 24.0);\n        z = z * lnb + (1.0 / 6.0);\n        z = z * lnb + 0.5;\n        z = z * lnb + 1.0;\n        z = z * lnb;\n\n        final double result = exp(lna, z, null);\n        \n        return result;\n    }\n\n\n    \n    public static double pow(double d, int e) {\n\n        if (e == 0) {\n            return 1.0;\n        } else if (e < 0) {\n            e = -e;\n            d = 1.0 / d;\n        }\n\n        \n        \n        final int splitFactor = 0x8000001;\n        final double cd       = splitFactor * d;\n        final double d1High   = cd - (cd - d);\n        final double d1Low    = d - d1High;\n\n        \n        double resultHigh = 1;\n        double resultLow  = 0;\n\n        \n        double d2p     = d;\n        double d2pHigh = d1High;\n        double d2pLow  = d1Low;\n\n        while (e != 0) {\n\n            if ((e & 0x1) != 0) {\n                \n                \n                final double tmpHigh = resultHigh * d2p;\n                final double cRH     = splitFactor * resultHigh;\n                final double rHH     = cRH - (cRH - resultHigh);\n                final double rHL     = resultHigh - rHH;\n                final double tmpLow  = rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow);\n                resultHigh = tmpHigh;\n                resultLow  = resultLow * d2p + tmpLow;\n            }\n\n            \n            \n            final double tmpHigh = d2pHigh * d2p;\n            final double cD2pH   = splitFactor * d2pHigh;\n            final double d2pHH   = cD2pH - (cD2pH - d2pHigh);\n            final double d2pHL   = d2pHigh - d2pHH;\n            final double tmpLow  = d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow);\n            final double cTmpH   = splitFactor * tmpHigh;\n            d2pHigh = cTmpH - (cTmpH - tmpHigh);\n            d2pLow  = d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh);\n            d2p     = d2pHigh + d2pLow;\n\n            e = e >> 1;\n\n        }\n\n        return resultHigh + resultLow;\n\n    }\n\n    \n    private static double polySine(final double x) {\n        double x2 = x*x;\n\n        double p = 2.7553817452272217E-6;\n        p = p * x2 + -1.9841269659586505E-4;\n        p = p * x2 + 0.008333333333329196;\n        p = p * x2 + -0.16666666666666666;\n        \n        \n        p = p * x2 * x;\n\n        return p;\n    }\n\n    \n    private static double polyCosine(double x) {\n        double x2 = x*x;\n\n        double p = 2.479773539153719E-5;\n        p = p * x2 + -0.0013888888689039883;\n        p = p * x2 + 0.041666666666621166;\n        p = p * x2 + -0.49999999999999994;\n        p *= x2;\n\n        return p;\n    }\n\n    \n    private static double sinQ(double xa, double xb) {\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; \n\n        \n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        \n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        \n        final double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        \n        double result;\n\n        \n\n        \n        \n\n        \n        \n        double a = 0;\n        double b = 0;\n\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA * sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA * cosEpsB + costA * sinEpsB;\n        \n\n        b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\n        \n\n        if (xb != 0.0) {\n            t = ((costA + costB) * (cosEpsA + cosEpsB) -\n                 (sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  \n            c = a + t;\n            d = -(c - a - t);\n            a = c;\n            b = b + d;\n        }\n\n        result = a + b;\n\n        return result;\n    }\n\n    \n    private static double cosQ(double xa, double xb) {\n        final double pi2a = 1.5707963267948966;\n        final double pi2b = 6.123233995736766E-17;\n\n        final double a = pi2a - xa;\n        double b = -(a - pi2a + xa);\n        b += pi2b - xb;\n\n        return sinQ(a, b);\n    }\n\n    \n    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; \n\n        \n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        \n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        \n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        \n\n        \n\n        \n        \n\n        \n        \n        double a = 0;\n        double b = 0;\n\n        \n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        \n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        \n        \n\n        \n\n        double est = sina/cosa;\n\n        \n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        \n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  \n        err += sinb/cosa;                     \n        err += -sina * cosb / cosa / cosa;    \n\n        if (xb != 0.0) {\n            \n            \n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }\n\n    \n    private static void reducePayneHanek(double x, double result[]) {\n        \n        long inbits = Double.doubleToLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        \n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        \n        exponent++;\n        inbits <<= 11;\n\n        \n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        \n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        \n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        \n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        \n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        \n\n        \n        int intPart = (int)(prodA >>> 62);\n\n        \n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        \n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        \n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        \n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        \n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        \n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        \n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        \n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  \n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; \n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        \n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }\n\n    \n    public static double sin(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n        double xa;\n        double xb = 0.0;\n\n        \n        xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        \n        if (xa == 0.0) {\n            long bits = Double.doubleToLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        \n        if (xa > 3294198.0) {\n            \n            \n            \n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa, xb);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (negative) {\n            quadrant ^= 2;  \n        }\n\n        switch (quadrant) {\n            case 0:\n                return sinQ(xa, xb);\n            case 1:\n                return cosQ(xa, xb);\n            case 2:\n                return -sinQ(xa, xb);\n            case 3:\n                return -cosQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }\n\n    \n    public static double cos(double x) {\n        int quadrant = 0;\n\n        \n        double xa = x;\n        if (x < 0) {\n            xa = -xa;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        \n        double xb = 0;\n        if (xa > 3294198.0) {\n            \n            \n            \n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa, xb);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        \n        \n\n        switch (quadrant) {\n            case 0:\n                return cosQ(xa, xb);\n            case 1:\n                return -sinQ(xa, xb);\n            case 2:\n                return -cosQ(xa, xb);\n            case 3:\n                return sinQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }\n\n    \n    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        \n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        \n        if (xa == 0.0) {\n            long bits = Double.doubleToLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        \n        double xb = 0;\n        if (xa > 3294198.0) {\n            \n            \n            \n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa, xb);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            \n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\n            result = -result;\n        }\n\n        return result;\n    }\n\n    \n    public static double atan(double x) {\n        return atan(x, 0.0, false);\n    }\n\n    \n    private static double atan(double xa, double xb, boolean leftPlane) {\n        boolean negate = false;\n        int idx;\n\n        if (xa == 0.0) { \n            return leftPlane ? copySign(Math.PI, xa) : xa;\n        }\n\n        if (xa < 0) {\n            \n            xa = -xa;\n            xb = -xb;\n            negate = true;\n        }\n\n        if (xa > 1.633123935319537E16) { \n            return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2);\n        }\n\n        \n        if (xa < 1) {\n            idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5);\n        } else {\n            final double oneOverXa = 1 / xa;\n            idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07);\n        }\n        double epsA = xa - TANGENT_TABLE_A[idx];\n        double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]);\n        epsB += xb - TANGENT_TABLE_B[idx];\n\n        double temp = epsA + epsB;\n        epsB = -(temp - epsA - epsB);\n        epsA = temp;\n\n        \n        temp = xa * HEX_40000000;\n        double ya = xa + temp - temp;\n        double yb = xb + xa - ya;\n        xa = ya;\n        xb += yb;\n\n        \n        if (idx == 0) {\n            \n            \n            final double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx]));\n            \n            ya = epsA * denom;\n            yb = epsB * denom;\n        } else {\n            double temp2 = xa * TANGENT_TABLE_A[idx];\n            double za = 1d + temp2;\n            double zb = -(za - 1d - temp2);\n            temp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx];\n            temp = za + temp2;\n            zb += -(temp - za - temp2);\n            za = temp;\n\n            zb += xb * TANGENT_TABLE_B[idx];\n            ya = epsA / za;\n\n            temp = ya * HEX_40000000;\n            final double yaa = (ya + temp) - temp;\n            final double yab = ya - yaa;\n\n            temp = za * HEX_40000000;\n            final double zaa = (za + temp) - temp;\n            final double zab = za - zaa;\n\n            \n            yb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za;\n\n            yb += -epsA * zb / za / za;\n            yb += epsB / za;\n        }\n\n\n        epsA = ya;\n        epsB = yb;\n\n        \n        final double epsA2 = epsA * epsA;\n\n        \n\n        yb = 0.07490822288864472;\n        yb = yb * epsA2 + -0.09088450866185192;\n        yb = yb * epsA2 + 0.11111095942313305;\n        yb = yb * epsA2 + -0.1428571423679182;\n        yb = yb * epsA2 + 0.19999999999923582;\n        yb = yb * epsA2 + -0.33333333333333287;\n        yb = yb * epsA2 * epsA;\n\n\n        ya = epsA;\n\n        temp = ya + yb;\n        yb = -(temp - ya - yb);\n        ya = temp;\n\n        \n        yb += epsB / (1d + epsA * epsA);\n\n        \n        double za = EIGHTHS[idx] + ya;\n        double zb = -(za - EIGHTHS[idx] - ya);\n        temp = za + yb;\n        zb += -(temp - za - yb);\n        za = temp;\n\n        double result = za + zb;\n        double resultb = -(result - za - zb);\n\n        if (leftPlane) {\n            \n            final double pia = 1.5707963267948966 * 2;\n            final double pib = 6.123233995736766E-17 * 2;\n\n            za = pia - result;\n            zb = -(za - pia + result);\n            zb += pib - resultb;\n\n            result = za + zb;\n            resultb = -(result - za - zb);\n        }\n\n\n        if (negate ^ leftPlane) {\n            result = -result;\n        }\n\n        return result;\n    }\n\n    \n    public static double atan2(double y, double x) {\n        if (x != x || y != y) {\n            return Double.NaN;\n        }\n\n        if (y == 0) {\n            final double result = x * y;\n            final double invx = 1d / x;\n            final double invy = 1d / y;\n\n            if (invx == 0) { \n                if (x > 0) {\n                    return y; \n                } else {\n                    return copySign(Math.PI, y);\n                }\n            }\n\n            if (x < 0 || invx < 0) {\n                if (y < 0 || invy < 0) {\n                    return -Math.PI;\n                } else {\n                    return Math.PI;\n                }\n            } else {\n                return result;\n            }\n        }\n\n        \n\n        if (y == Double.POSITIVE_INFINITY) {\n            if (x == Double.POSITIVE_INFINITY) {\n                return Math.PI * F_1_4;\n            }\n\n            if (x == Double.NEGATIVE_INFINITY) {\n                return Math.PI * F_3_4;\n            }\n\n            return Math.PI * F_1_2;\n        }\n\n        if (y == Double.NEGATIVE_INFINITY) {\n            if (x == Double.POSITIVE_INFINITY) {\n                return -Math.PI * F_1_4;\n            }\n\n            if (x == Double.NEGATIVE_INFINITY) {\n                return -Math.PI * F_3_4;\n            }\n\n            return -Math.PI * F_1_2;\n        }\n\n        if (x == Double.POSITIVE_INFINITY) {\n            if (y > 0 || 1 / y > 0) {\n                return 0d;\n            }\n\n            if (y < 0 || 1 / y < 0) {\n                return -0d;\n            }\n        }\n\n        if (x == Double.NEGATIVE_INFINITY)\n        {\n            if (y > 0.0 || 1 / y > 0.0) {\n                return Math.PI;\n            }\n\n            if (y < 0 || 1 / y < 0) {\n                return -Math.PI;\n            }\n        }\n\n        \n\n        if (x == 0) {\n            if (y > 0 || 1 / y > 0) {\n                return Math.PI * F_1_2;\n            }\n\n            if (y < 0 || 1 / y < 0) {\n                return -Math.PI * F_1_2;\n            }\n        }\n\n        \n        final double r = y / x;\n        if (Double.isInfinite(r)) { \n            return atan(r, 0, x < 0);\n        }\n\n        double ra = doubleHighPart(r);\n        double rb = r - ra;\n\n        \n        final double xa = doubleHighPart(x);\n        final double xb = x - xa;\n\n        rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n\n        final double temp = ra + rb;\n        rb = -(temp - ra - rb);\n        ra = temp;\n\n        if (ra == 0) { \n            ra = copySign(0d, y);\n        }\n\n        \n        final double result = atan(ra, rb, x < 0);\n\n        return result;\n    }\n\n    \n    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { \n          return x;\n      }\n\n      \n\n      \n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      \n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      \n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      \n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      \n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      \n      double dx = zb / (2.0*y);\n\n      \n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  \n      rb += -x * dx / y / y;  \n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }\n\n    \n    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      \n\n      \n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      \n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      \n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      \n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      \n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      \n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      \n      double r = y/x;\n\n      \n      if (Double.isInfinite(r)) { \n          return Math.PI/2; \n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  \n      rb += yb / x;  \n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }\n\n    \n    public static double cbrt(double x) {\n      \n      long inbits = Double.doubleToLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          \n          subnormal = true;\n          x *= 1.8014398509481984E16;  \n          inbits = Double.doubleToLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          \n          return x;\n      }\n\n      \n      int exp3 = exponent / 3;\n\n      \n      double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) |\n                                          (long)(((exp3 + 1023) & 0x7ff)) << 52);\n\n      \n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      \n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      \n      \n      \n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      \n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      \n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  \n      }\n\n      return est;\n    }\n\n    \n    public static double toRadians(double x) {\n        if (Double.isInfinite(x) || x == 0.0) { \n            return x;\n        }\n\n        \n        final double facta = 0.01745329052209854;\n        final double factb = 1.997844754509471E-9;\n\n        double xa = doubleHighPart(x);\n        double xb = x - xa;\n\n        double result = xb * factb + xb * facta + xa * factb + xa * facta;\n        if (result == 0) {\n            result = result * x; \n        }\n        return result;\n    }\n\n    \n    public static double toDegrees(double x) {\n        if (Double.isInfinite(x) || x == 0.0) { \n            return x;\n        }\n\n        \n        final double facta = 57.2957763671875;\n        final double factb = 3.145894820876798E-6;\n\n        double xa = doubleHighPart(x);\n        double xb = x - xa;\n\n        return xb * factb + xb * facta + xa * factb + xa * facta;\n    }\n\n    \n    public static int abs(final int x) {\n        return (x < 0) ? -x : x;\n    }\n\n    \n    public static long abs(final long x) {\n        return (x < 0l) ? -x : x;\n    }\n\n    \n    public static float abs(final float x) {\n        return (x < 0.0f) ? -x : (x == 0.0f) ? 0.0f : x; \n    }\n\n    \n    public static double abs(double x) {\n        return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; \n    }\n\n    \n    public static double ulp(double x) {\n        if (Double.isInfinite(x)) {\n            return Double.POSITIVE_INFINITY;\n        }\n        return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1));\n    }\n\n    \n    public static float ulp(float x) {\n        if (Float.isInfinite(x)) {\n            return Float.POSITIVE_INFINITY;\n        }\n        return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1));\n    }\n\n    \n    public static double scalb(final double d, final int n) {\n\n        \n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        \n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        \n        final long bits = Double.doubleToLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        \n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            \n            if (scaledExponent > 0) {\n                \n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                \n\n                \n                mantissa = mantissa | (1L << 52);\n\n                \n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    \n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                \n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            \n            if (exponent == 0) {\n\n                \n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }\n\n    \n    public static float scalb(final float f, final int n) {\n\n        \n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        \n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        \n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        \n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            \n            if (scaledExponent > 0) {\n                \n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                \n\n                \n                mantissa = mantissa | (1 << 23);\n\n                \n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    \n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                \n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            \n            if (exponent == 0) {\n\n                \n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }\n\n    \n    public static double nextAfter(double d, double direction) {\n\n        \n        if (Double.isNaN(d) || Double.isNaN(direction)) {\n            return Double.NaN;\n        } else if (d == direction) {\n            return direction;\n        } else if (Double.isInfinite(d)) {\n            return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE;\n        } else if (d == 0) {\n            return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n        }\n        \n        \n\n        final long bits = Double.doubleToLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        if ((direction < d) ^ (sign == 0L)) {\n            return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1));\n        } else {\n            return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1));\n        }\n\n    }\n\n    \n    public static float nextAfter(final float f, final double direction) {\n\n        \n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        \n        \n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) - 1));\n        }\n\n    }\n\n    \n    public static double floor(double x) {\n        long y;\n\n        if (x != x) { \n            return x;\n        }\n\n        if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) {\n            return x;\n        }\n\n        y = (long) x;\n        if (x < 0 && y != x) {\n            y--;\n        }\n\n        if (y == 0) {\n            return x*y;\n        }\n\n        return y;\n    }\n\n    \n    public static double ceil(double x) {\n        double y;\n\n        if (x != x) { \n            return x;\n        }\n\n        y = floor(x);\n        if (y == x) {\n            return y;\n        }\n\n        y += 1.0;\n\n        if (y == 0) {\n            return x*y;\n        }\n\n        return y;\n    }\n\n    \n    public static double rint(double x) {\n        double y = floor(x);\n        double d = x - y;\n\n        if (d > 0.5) {\n            if (y == -1.0) {\n                return -0.0; \n            }\n            return y+1.0;\n        }\n        if (d < 0.5) {\n            return y;\n        }\n\n        \n        long z = (long) y;\n        return (z & 1) == 0 ? y : y + 1.0;\n    }\n\n    \n    public static long round(double x) {\n        return (long) floor(x + 0.5);\n    }\n\n    \n    public static int round(final float x) {\n        return (int) floor(x + 0.5f);\n    }\n\n    \n    public static int min(final int a, final int b) {\n        return (a <= b) ? a : b;\n    }\n\n    \n    public static long min(final long a, final long b) {\n        return (a <= b) ? a : b;\n    }\n\n    \n    public static float min(final float a, final float b) {\n        if (a > b) {\n            return b;\n        }\n        if (a < b) {\n            return a;\n        }\n        \n        if (a != b) {\n            return Float.NaN;\n        }\n        \n        \n        int bits = Float.floatToRawIntBits(a);\n        if (bits == 0x80000000) {\n            return a;\n        }\n        return b;\n    }\n\n    \n    public static double min(final double a, final double b) {\n        if (a > b) {\n            return b;\n        }\n        if (a < b) {\n            return a;\n        }\n        \n        if (a != b) {\n            return Double.NaN;\n        }\n        \n        \n        long bits = Double.doubleToRawLongBits(a);\n        if (bits == 0x8000000000000000L) {\n            return a;\n        }\n        return b;\n    }\n\n    \n    public static int max(final int a, final int b) {\n        return (a <= b) ? b : a;\n    }\n\n    \n    public static long max(final long a, final long b) {\n        return (a <= b) ? b : a;\n    }\n\n    \n    public static float max(final float a, final float b) {\n        if (a > b) {\n            return a;\n        }\n        if (a < b) {\n            return b;\n        }\n        \n        if (a != b) {\n            return Float.NaN;\n        }\n        \n        \n        int bits = Float.floatToRawIntBits(a);\n        if (bits == 0x80000000) {\n            return b;\n        }\n        return a;\n    }\n\n    \n    public static double max(final double a, final double b) {\n        if (a > b) {\n            return a;\n        }\n        if (a < b) {\n            return b;\n        }\n        \n        if (a != b) {\n            return Double.NaN;\n        }\n        \n        \n        long bits = Double.doubleToRawLongBits(a);\n        if (bits == 0x8000000000000000L) {\n            return b;\n        }\n        return a;\n    }\n\n    \n    public static double hypot(final double x, final double y) {\n        if (Double.isInfinite(x) || Double.isInfinite(y)) {\n            return Double.POSITIVE_INFINITY;\n        } else if (Double.isNaN(x) || Double.isNaN(y)) {\n            return Double.NaN;\n        } else {\n\n            final int expX = getExponent(x);\n            final int expY = getExponent(y);\n            if (expX > expY + 27) {\n                \n                return abs(x);\n            } else if (expY > expX + 27) {\n                \n                return abs(y);\n            } else {\n\n                \n                final int middleExp = (expX + expY) / 2;\n\n                \n                final double scaledX = scalb(x, -middleExp);\n                final double scaledY = scalb(y, -middleExp);\n\n                \n                final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY);\n\n                \n                return scalb(scaledH, middleExp);\n\n            }\n\n        }\n    }\n\n    \n    public static double IEEEremainder(double dividend, double divisor) {\n        return StrictMath.IEEEremainder(dividend, divisor); \n    }\n\n    \n    public static double copySign(double magnitude, double sign) {\n        long m = Double.doubleToLongBits(magnitude);\n        long s = Double.doubleToLongBits(sign);\n        if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { \n            return magnitude;\n        }\n        return -magnitude; \n    }\n\n    \n    public static float copySign(float magnitude, float sign) {\n        int m = Float.floatToIntBits(magnitude);\n        int s = Float.floatToIntBits(sign);\n        if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { \n            return magnitude;\n        }\n        return -magnitude; \n    }\n\n    \n    public static int getExponent(final double d) {\n        return (int) ((Double.doubleToLongBits(d) >>> 52) & 0x7ff) - 1023;\n    }\n\n    \n    public static int getExponent(final float f) {\n        return ((Float.floatToIntBits(f) >>> 23) & 0xff) - 127;\n    }\n\n    \n    public static void main(String[] a) {\n        PrintStream out = System.out;\n        FastMathCalc.printarray(out, \"EXP_INT_TABLE_A\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A);\n        FastMathCalc.printarray(out, \"EXP_INT_TABLE_B\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B);\n        FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_A\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A);\n        FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_B\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B);\n        FastMathCalc.printarray(out, \"LN_MANT\",LN_MANT_LEN, lnMant.LN_MANT);\n        FastMathCalc.printarray(out, \"SINE_TABLE_A\", SINE_TABLE_LEN, SINE_TABLE_A);\n        FastMathCalc.printarray(out, \"SINE_TABLE_B\", SINE_TABLE_LEN, SINE_TABLE_B);\n        FastMathCalc.printarray(out, \"COSINE_TABLE_A\", SINE_TABLE_LEN, COSINE_TABLE_A);\n        FastMathCalc.printarray(out, \"COSINE_TABLE_B\", SINE_TABLE_LEN, COSINE_TABLE_B);\n        FastMathCalc.printarray(out, \"TANGENT_TABLE_A\", SINE_TABLE_LEN, TANGENT_TABLE_A);\n        FastMathCalc.printarray(out, \"TANGENT_TABLE_B\", SINE_TABLE_LEN, TANGENT_TABLE_B);\n    }\n\n    \n    private static class ExpIntTable { private static final double[] EXP_INT_TABLE_A; private static final double[] EXP_INT_TABLE_B; static { if (RECOMPUTE_TABLES_AT_RUNTIME) {\n                EXP_INT_TABLE_A = new double[FastMath.EXP_INT_TABLE_LEN];\n                EXP_INT_TABLE_B = new double[FastMath.EXP_INT_TABLE_LEN];\n\n                final double tmp[] = new double[2];\n                final double recip[] = new double[2];\n\n                \n                for (int i = 0; i < FastMath.EXP_INT_TABLE_MAX_INDEX; i++) {\n                    FastMathCalc.expint(i, tmp);\n                    EXP_INT_TABLE_A[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[0];\n                    EXP_INT_TABLE_B[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[1];\n\n                    if (i != 0) {\n                        \n                        FastMathCalc.splitReciprocal(tmp, recip);\n                        EXP_INT_TABLE_A[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[0];\n                        EXP_INT_TABLE_B[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[1];\n                    }\n                }\n            } else {\n                EXP_INT_TABLE_A = FastMathLiteralArrays.loadExpIntA();\n                EXP_INT_TABLE_B = FastMathLiteralArrays.loadExpIntB();\n            }\n        }\n    }\n\n    \n    private static class ExpFracTable { private static final double[] EXP_FRAC_TABLE_A; private static final double[] EXP_FRAC_TABLE_B; static { if (RECOMPUTE_TABLES_AT_RUNTIME) {\n                EXP_FRAC_TABLE_A = new double[FastMath.EXP_FRAC_TABLE_LEN];\n                EXP_FRAC_TABLE_B = new double[FastMath.EXP_FRAC_TABLE_LEN];\n\n                final double tmp[] = new double[2];\n\n                \n                final double factor = 1d / (EXP_FRAC_TABLE_LEN - 1);\n                for (int i = 0; i < EXP_FRAC_TABLE_A.length; i++) {\n                    FastMathCalc.slowexp(i * factor, tmp);\n                    EXP_FRAC_TABLE_A[i] = tmp[0];\n                    EXP_FRAC_TABLE_B[i] = tmp[1];\n                }\n            } else {\n                EXP_FRAC_TABLE_A = FastMathLiteralArrays.loadExpFracA();\n                EXP_FRAC_TABLE_B = FastMathLiteralArrays.loadExpFracB();\n            }\n        }\n    }\n\n    \n    private static class lnMant { private static final double[][] LN_MANT; static { if (RECOMPUTE_TABLES_AT_RUNTIME) {\n                LN_MANT = new double[FastMath.LN_MANT_LEN][];\n\n                \n                for (int i = 0; i < LN_MANT.length; i++) {\n                    final double d = Double.longBitsToDouble( (((long) i) << 42) | 0x3ff0000000000000L );\n                    LN_MANT[i] = FastMathCalc.slowLog(d);\n                }\n            } else {\n                LN_MANT = FastMathLiteralArrays.loadLnMant();\n            }\n        }\n    }\n\n    \n    private static class CodyWaite { private final int finalK; private final double finalRemA; private final double finalRemB; CodyWaite(double xa, double xb) {\n            \n            \n            int k = (int)(xa * 0.6366197723675814);\n\n            \n            double remA;\n            double remB;\n            while (true) {\n                double a = -k * 1.570796251296997;\n                remA = xa + a;\n                remB = -(remA - xa - a);\n\n                a = -k * 7.549789948768648E-8;\n                double b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                a = -k * 6.123233995736766E-17;\n                b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                if (remA > 0) {\n                    break;\n                }\n\n                \n                \n                \n                --k;\n            }\n\n            this.finalK = k;\n            this.finalRemA = remA;\n            this.finalRemB = remB;\n        }\n\n        \n        int getK() {\n            return finalK;\n        }\n        \n        double getRemA() {\n            return finalRemA;\n        }\n        \n        double getRemB() {\n            return finalRemB;\n        }\n    }\n}\n",
      "buggy_signatures": [
        "private static double doubleHighPart(double d)",
        "public static double sqrt(final double a)",
        "public static double cosh(double x)",
        "public static double sinh(double x)",
        "public static double tanh(double x)",
        "public static double acosh(final double a)",
        "public static double asinh(double a)",
        "public static double atanh(double a)",
        "public static double signum(final double a)",
        "public static float signum(final float a)",
        "public static double nextUp(final double a)",
        "public static float nextUp(final float a)",
        "public static double random()",
        "public static double exp(double x)",
        "private static double exp(double x, double extra, double[] hiPrec)",
        "public static double expm1(double x)",
        "private static double expm1(double x, double hiPrecOut[])",
        "public static double log(final double x)",
        "private static double log(final double x, final double[] hiPrec)",
        "public static double log1p(final double x)",
        "public static double log10(final double x)",
        "public static double log(double base, double x)",
        "public static double pow(double x, double y)",
        "public static double pow(double d, int e)",
        "private static double polySine(final double x)",
        "private static double polyCosine(double x)",
        "private static double sinQ(double xa, double xb)",
        "private static double cosQ(double xa, double xb)",
        "private static double tanQ(double xa, double xb, boolean cotanFlag)",
        "private static void reducePayneHanek(double x, double result[])",
        "public static double sin(double x)",
        "public static double cos(double x)",
        "public static double tan(double x)",
        "public static double atan(double x)",
        "private static double atan(double xa, double xb, boolean leftPlane)",
        "public static double atan2(double y, double x)",
        "public static double asin(double x)",
        "public static double acos(double x)",
        "public static double cbrt(double x)",
        "public static double toRadians(double x)",
        "public static double toDegrees(double x)",
        "public static int abs(final int x)",
        "public static long abs(final long x)",
        "public static float abs(final float x)",
        "public static double abs(double x)",
        "public static double ulp(double x)",
        "public static float ulp(float x)",
        "public static double scalb(final double d, final int n)",
        "public static float scalb(final float f, final int n)",
        "public static double nextAfter(double d, double direction)",
        "public static float nextAfter(final float f, final double direction)",
        "public static double floor(double x)",
        "public static double ceil(double x)",
        "public static double rint(double x)",
        "public static long round(double x)",
        "public static int round(final float x)",
        "public static int min(final int a, final int b)",
        "public static long min(final long a, final long b)",
        "public static float min(final float a, final float b)",
        "public static double min(final double a, final double b)",
        "public static int max(final int a, final int b)",
        "public static long max(final long a, final long b)",
        "public static float max(final float a, final float b)",
        "public static double max(final double a, final double b)",
        "public static double hypot(final double x, final double y)",
        "public static double IEEEremainder(double dividend, double divisor)",
        "public static double copySign(double magnitude, double sign)",
        "public static float copySign(float magnitude, float sign)",
        "public static int getExponent(final double d)",
        "public static int getExponent(final float f)",
        "public static void main(String[] a)",
        "private static class ExpIntTable { private static final double[] EXP_INT_TABLE_A; private static final double[] EXP_INT_TABLE_B; static { if (RECOMPUTE_TABLES_AT_RUNTIME)",
        "private static class ExpFracTable { private static final double[] EXP_FRAC_TABLE_A; private static final double[] EXP_FRAC_TABLE_B; static { if (RECOMPUTE_TABLES_AT_RUNTIME)",
        "private static class lnMant { private static final double[][] LN_MANT; static { if (RECOMPUTE_TABLES_AT_RUNTIME)",
        "private static class CodyWaite { private final int finalK; private final double finalRemA; private final double finalRemB; CodyWaite(double xa, double xb)"
      ],
      "fixed_signatures": [
        "private static double doubleHighPart(double d)",
        "public static double sqrt(final double a)",
        "public static double cosh(double x)",
        "public static double sinh(double x)",
        "public static double tanh(double x)",
        "public static double acosh(final double a)",
        "public static double asinh(double a)",
        "public static double atanh(double a)",
        "public static double signum(final double a)",
        "public static float signum(final float a)",
        "public static double nextUp(final double a)",
        "public static float nextUp(final float a)",
        "public static double random()",
        "public static double exp(double x)",
        "private static double exp(double x, double extra, double[] hiPrec)",
        "public static double expm1(double x)",
        "private static double expm1(double x, double hiPrecOut[])",
        "public static double log(final double x)",
        "private static double log(final double x, final double[] hiPrec)",
        "public static double log1p(final double x)",
        "public static double log10(final double x)",
        "public static double log(double base, double x)",
        "public static double pow(double x, double y)",
        "public static double pow(double d, int e)",
        "private static double polySine(final double x)",
        "private static double polyCosine(double x)",
        "private static double sinQ(double xa, double xb)",
        "private static double cosQ(double xa, double xb)",
        "private static double tanQ(double xa, double xb, boolean cotanFlag)",
        "private static void reducePayneHanek(double x, double result[])",
        "public static double sin(double x)",
        "public static double cos(double x)",
        "public static double tan(double x)",
        "public static double atan(double x)",
        "private static double atan(double xa, double xb, boolean leftPlane)",
        "public static double atan2(double y, double x)",
        "public static double asin(double x)",
        "public static double acos(double x)",
        "public static double cbrt(double x)",
        "public static double toRadians(double x)",
        "public static double toDegrees(double x)",
        "public static int abs(final int x)",
        "public static long abs(final long x)",
        "public static float abs(final float x)",
        "public static double abs(double x)",
        "public static double ulp(double x)",
        "public static float ulp(float x)",
        "public static double scalb(final double d, final int n)",
        "public static float scalb(final float f, final int n)",
        "public static double nextAfter(double d, double direction)",
        "public static float nextAfter(final float f, final double direction)",
        "public static double floor(double x)",
        "public static double ceil(double x)",
        "public static double rint(double x)",
        "public static long round(double x)",
        "public static int round(final float x)",
        "public static int min(final int a, final int b)",
        "public static long min(final long a, final long b)",
        "public static float min(final float a, final float b)",
        "public static double min(final double a, final double b)",
        "public static int max(final int a, final int b)",
        "public static long max(final long a, final long b)",
        "public static float max(final float a, final float b)",
        "public static double max(final double a, final double b)",
        "public static double hypot(final double x, final double y)",
        "public static double IEEEremainder(double dividend, double divisor)",
        "public static double copySign(double magnitude, double sign)",
        "public static float copySign(float magnitude, float sign)",
        "public static int getExponent(final double d)",
        "public static int getExponent(final float f)",
        "public static void main(String[] a)",
        "private static class ExpIntTable { private static final double[] EXP_INT_TABLE_A; private static final double[] EXP_INT_TABLE_B; static { if (RECOMPUTE_TABLES_AT_RUNTIME)",
        "private static class ExpFracTable { private static final double[] EXP_FRAC_TABLE_A; private static final double[] EXP_FRAC_TABLE_B; static { if (RECOMPUTE_TABLES_AT_RUNTIME)",
        "private static class lnMant { private static final double[][] LN_MANT; static { if (RECOMPUTE_TABLES_AT_RUNTIME)",
        "private static class CodyWaite { private final int finalK; private final double finalRemA; private final double finalRemB; CodyWaite(double xa, double xb)"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "  private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE); public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9; public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8; static final int EXP_INT_TABLE_MAX_INDEX = 750; static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2; static final int LN_MANT_LEN = 1024; static final int EXP_FRAC_TABLE_LEN = 1025; private static final boolean RECOMPUTE_TABLES_AT_RUNTIME = false; private static final double LN_2_A = 0.693147063255310059; private static final double LN_2_B = 1.17304635250823482e-7; private static final double LN_QUICK_COEF[][] = {\n  {1.0, 5.669184079525E-24},\n  {-0.25, -0.25},\n  {0.3333333134651184, 1.986821492305628E-8},\n  {-0.25, -6.663542893624021E-14},\n  {0.19999998807907104, 1.1921056801463227E-8},\n  {-0.1666666567325592, -7.800414592973399E-9},\n  {0.1428571343421936, 5.650007086920087E-9},\n  {-0.12502530217170715, -7.44321345601866E-11},\n  {0.11113807559013367, 9.219544613762692E-9},\n  };",
          "diff": [
            "@@ -79,6 +79,7 @@",
            "  */\n",
            " public class FastMath {\n",
            "     /** StrictMath.log(Double.MAX_VALUE): {@value} */\n",
            "+    private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE);\n",
            " \n",
            "     /** Archimede's constant PI, ratio of circle circumference to diameter. */\n",
            "     public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  public static double cosh(double x) {\n  if (x != x) {\n  return x;\n  }\n\n  \n\n  \n  \n\n  if (x > 20) {\n  \n  return 0.5 * exp(x);\n  }\n  if (x < -20) {\n  \n  return 0.5 * exp(-x);\n  }\n\n  final double hiPrec[] = new double[2];\n  if (x < 0.0) {\n  x = -x;\n  }\n  exp(x, 0.0, hiPrec);\n\n  double ya = hiPrec[0] + hiPrec[1];\n  double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n  double temp = ya * HEX_40000000;\n  double yaa = ya + temp - temp;\n  double yab = ya - yaa;\n\n  \n  double recip = 1.0/ya;\n  temp = recip * HEX_40000000;\n  double recipa = recip + temp - temp;\n  double recipb = recip - recipa;\n\n  \n  recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n  \n  recipb += -yb * recip * recip;\n\n  \n  temp = ya + recipa;\n  yb += -(temp - ya - recipa);\n  ya = temp;\n  temp = ya + recipb;\n  yb += -(temp - ya - recipb);\n  ya = temp;\n\n  double result = ya + yb;\n  result *= 0.5;\n  return result;\n  }",
          "fixed_method": "  public static double cosh(double x) {\n  if (x != x) {\n  return x;\n  }\n\n  \n\n  \n  \n\n  if (x > 20) {\n  if (x >= LOG_MAX_VALUE) {\n  \n  final double t = exp(0.5 * x);\n  return (0.5 * t) * t;\n  } else {\n  return 0.5 * exp(x);\n  }\n  } else if (x < -20) {\n  if (x <= -LOG_MAX_VALUE) {\n  \n  final double t = exp(-0.5 * x);\n  return (0.5 * t) * t;\n  } else {\n  return 0.5 * exp(-x);\n  }\n  }\n\n  final double hiPrec[] = new double[2];\n  if (x < 0.0) {\n  x = -x;\n  }\n  exp(x, 0.0, hiPrec);\n\n  double ya = hiPrec[0] + hiPrec[1];\n  double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n  double temp = ya * HEX_40000000;\n  double yaa = ya + temp - temp;\n  double yab = ya - yaa;\n\n  \n  double recip = 1.0/ya;\n  temp = recip * HEX_40000000;\n  double recipa = recip + temp - temp;\n  double recipb = recip - recipa;\n\n  \n  recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n  \n  recipb += -yb * recip * recip;\n\n  \n  temp = ya + recipa;\n  yb += -(temp - ya - recipa);\n  ya = temp;\n  temp = ya + recipb;\n  yb += -(temp - ya - recipb);\n  ya = temp;\n\n  double result = ya + yb;\n  result *= 0.5;\n  return result;\n  }",
          "diff": [
            "@@ -391,12 +392,21 @@",
            "       // exp(-z) can be ignored in comparison with exp(z)\n",
            " \n",
            "       if (x > 20) {\n",
            "+          if (x >= LOG_MAX_VALUE) {\n",
            "               // Avoid overflow (MATH-905).\n",
            "+              final double t = exp(0.5 * x);\n",
            "+              return (0.5 * t) * t;\n",
            "+          } else {\n",
            "               return 0.5 * exp(x);\n",
            "           }\n",
            "-      if (x < -20) {\n",
            "+      } else if (x < -20) {\n",
            "+          if (x <= -LOG_MAX_VALUE) {\n",
            "               // Avoid overflow (MATH-905).\n",
            "+              final double t = exp(-0.5 * x);\n",
            "+              return (0.5 * t) * t;\n",
            "+          } else {\n",
            "               return 0.5 * exp(-x);\n",
            "+          }\n",
            "       }\n",
            " \n",
            "       final double hiPrec[] = new double[2];\n"
          ],
          "changed_lines": 11
        },
        {
          "buggy_method": "  public static double sinh(double x) {\n  boolean negate = false;\n  if (x != x) {\n  return x;\n  }\n\n  \n\n  \n  \n\n  if (x > 20) {\n  \n  return 0.5 * exp(x);\n  }\n  if (x < -20) {\n  \n  return -0.5 * exp(-x);\n  }\n\n  if (x == 0) {\n  return x;\n  }\n\n  if (x < 0.0) {\n  x = -x;\n  negate = true;\n  }\n\n  double result;\n\n  if (x > 0.25) {\n  double hiPrec[] = new double[2];\n  exp(x, 0.0, hiPrec);\n\n  double ya = hiPrec[0] + hiPrec[1];\n  double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n  double temp = ya * HEX_40000000;\n  double yaa = ya + temp - temp;\n  double yab = ya - yaa;\n\n  \n  double recip = 1.0/ya;\n  temp = recip * HEX_40000000;\n  double recipa = recip + temp - temp;\n  double recipb = recip - recipa;\n\n  \n  recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n  \n  recipb += -yb * recip * recip;\n\n  recipa = -recipa;\n  recipb = -recipb;\n\n  \n  temp = ya + recipa;\n  yb += -(temp - ya - recipa);\n  ya = temp;\n  temp = ya + recipb;\n  yb += -(temp - ya - recipb);\n  ya = temp;\n\n  result = ya + yb;\n  result *= 0.5;\n  }\n  else {\n  double hiPrec[] = new double[2];\n  expm1(x, hiPrec);\n\n  double ya = hiPrec[0] + hiPrec[1];\n  double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n  \n  double denom = 1.0 + ya;\n  double denomr = 1.0 / denom;\n  double denomb = -(denom - 1.0 - ya) + yb;\n  double ratio = ya * denomr;\n  double temp = ratio * HEX_40000000;\n  double ra = ratio + temp - temp;\n  double rb = ratio - ra;\n\n  temp = denom * HEX_40000000;\n  double za = denom + temp - temp;\n  double zb = denom - za;\n\n  rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n  \n  rb += yb*denomr;  \n  rb += -ya * denomb * denomr * denomr;  \n\n  \n  temp = ya + ra;\n  yb += -(temp - ya - ra);\n  ya = temp;\n  temp = ya + rb;\n  yb += -(temp - ya - rb);\n  ya = temp;\n\n  result = ya + yb;\n  result *= 0.5;\n  }\n\n  if (negate) {\n  result = -result;\n  }\n\n  return result;\n  }",
          "fixed_method": "  public static double sinh(double x) {\n  boolean negate = false;\n  if (x != x) {\n  return x;\n  }\n\n  \n\n  \n  \n\n  if (x > 20) {\n  if (x >= LOG_MAX_VALUE) {\n  \n  final double t = exp(0.5 * x);\n  return (0.5 * t) * t;\n  } else {\n  return 0.5 * exp(x);\n  }\n  } else if (x < -20) {\n  if (x <= -LOG_MAX_VALUE) {\n  \n  final double t = exp(-0.5 * x);\n  return (-0.5 * t) * t;\n  } else {\n  return -0.5 * exp(-x);\n  }\n  }\n\n  if (x == 0) {\n  return x;\n  }\n\n  if (x < 0.0) {\n  x = -x;\n  negate = true;\n  }\n\n  double result;\n\n  if (x > 0.25) {\n  double hiPrec[] = new double[2];\n  exp(x, 0.0, hiPrec);\n\n  double ya = hiPrec[0] + hiPrec[1];\n  double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n  double temp = ya * HEX_40000000;\n  double yaa = ya + temp - temp;\n  double yab = ya - yaa;\n\n  \n  double recip = 1.0/ya;\n  temp = recip * HEX_40000000;\n  double recipa = recip + temp - temp;\n  double recipb = recip - recipa;\n\n  \n  recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n  \n  recipb += -yb * recip * recip;\n\n  recipa = -recipa;\n  recipb = -recipb;\n\n  \n  temp = ya + recipa;\n  yb += -(temp - ya - recipa);\n  ya = temp;\n  temp = ya + recipb;\n  yb += -(temp - ya - recipb);\n  ya = temp;\n\n  result = ya + yb;\n  result *= 0.5;\n  }\n  else {\n  double hiPrec[] = new double[2];\n  expm1(x, hiPrec);\n\n  double ya = hiPrec[0] + hiPrec[1];\n  double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n  \n  double denom = 1.0 + ya;\n  double denomr = 1.0 / denom;\n  double denomb = -(denom - 1.0 - ya) + yb;\n  double ratio = ya * denomr;\n  double temp = ratio * HEX_40000000;\n  double ra = ratio + temp - temp;\n  double rb = ratio - ra;\n\n  temp = denom * HEX_40000000;\n  double za = denom + temp - temp;\n  double zb = denom - za;\n\n  rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n  \n  rb += yb*denomr;  \n  rb += -ya * denomb * denomr * denomr;  \n\n  \n  temp = ya + ra;\n  yb += -(temp - ya - ra);\n  ya = temp;\n  temp = ya + rb;\n  yb += -(temp - ya - rb);\n  ya = temp;\n\n  result = ya + yb;\n  result *= 0.5;\n  }\n\n  if (negate) {\n  result = -result;\n  }\n\n  return result;\n  }",
          "diff": [
            "@@ -452,12 +462,21 @@",
            "       // exp(-z) can be ignored in comparison with exp(z)\n",
            " \n",
            "       if (x > 20) {\n",
            "+          if (x >= LOG_MAX_VALUE) {\n",
            "               // Avoid overflow (MATH-905).\n",
            "+              final double t = exp(0.5 * x);\n",
            "+              return (0.5 * t) * t;\n",
            "+          } else {\n",
            "               return 0.5 * exp(x);\n",
            "           }\n",
            "-      if (x < -20) {\n",
            "+      } else if (x < -20) {\n",
            "+          if (x <= -LOG_MAX_VALUE) {\n",
            "               // Avoid overflow (MATH-905).\n",
            "+              final double t = exp(-0.5 * x);\n",
            "+              return (-0.5 * t) * t;\n",
            "+          } else {\n",
            "               return -0.5 * exp(-x);\n",
            "+          }\n",
            "       }\n",
            " \n",
            "       if (x == 0) {\n"
          ],
          "changed_lines": 11
        }
      ]
    }
  ]
}
