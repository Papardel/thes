{
  "bug_id": "10",
  "failed_tests": {
    "org.jsoup.nodes.NodeTest": [
      {
        "methodName": "absHandlesRelativeQuery",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<...tp://jsoup.org/path/[file]?foo> but was:<...tp://jsoup.org/path/[]?foo>",
        "fail_line": "        assertEquals(\"http://jsoup.org/path/file?foo\", a1.absUrl(\"href\"));",
        "test_source": "",
        "stack": [
          "NodeTest.absHandlesRelativeQuery line 49"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/nodes/Node.java",
      "buggy_full_code": "package org.jsoup.nodes;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.select.NodeTraversor;\nimport org.jsoup.select.NodeVisitor;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n\npublic abstract class Node implements Cloneable { Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri; int siblingIndex; protected Node(String baseUri, Attributes attributes) {\n        Validate.notNull(baseUri);\n        Validate.notNull(attributes);\n        \n        childNodes = new ArrayList<Node>(4);\n        this.baseUri = baseUri.trim();\n        this.attributes = attributes;\n    }\n\n    protected Node(String baseUri) {\n        this(baseUri, new Attributes());\n    }\n\n    \n    protected Node() {\n        childNodes = Collections.EMPTY_LIST;\n        attributes = null;\n    }\n\n    \n    public abstract String nodeName(); public String attr(String attributeKey) {\n        Validate.notNull(attributeKey);\n\n        if (hasAttr(attributeKey))\n            return attributes.get(attributeKey);\n        else if (attributeKey.toLowerCase().startsWith(\"abs:\"))\n            return absUrl(attributeKey.substring(\"abs:\".length()));\n        else return \"\";\n    }\n\n    \n    public Attributes attributes() {\n        return attributes;\n    }\n\n    \n    public Node attr(String attributeKey, String attributeValue) {\n        attributes.put(attributeKey, attributeValue);\n        return this;\n    }\n\n    \n    public boolean hasAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        return attributes.hasKey(attributeKey);\n    }\n\n    \n    public Node removeAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        attributes.remove(attributeKey);\n        return this;\n    }\n\n    \n    public String baseUri() {\n        return baseUri;\n    }\n\n    \n    public void setBaseUri(String baseUri) {\n        Validate.notNull(baseUri);\n        this.baseUri = baseUri;\n    }\n\n    \n    public String absUrl(String attributeKey) {\n        Validate.notEmpty(attributeKey);\n\n        String relUrl = attr(attributeKey);\n        if (!hasAttr(attributeKey)) {\n            return \"\"; \n        } else {\n            URL base;\n            try {\n                try {\n                    base = new URL(baseUri);\n                } catch (MalformedURLException e) {\n                    \n                    URL abs = new URL(relUrl);\n                    return abs.toExternalForm();\n                }\n                \n                URL abs = new URL(base, relUrl);\n                return abs.toExternalForm();\n            } catch (MalformedURLException e) {\n                return \"\";\n            }\n        }\n    }\n\n    \n    public Node childNode(int index) {\n        return childNodes.get(index);\n    }\n\n    \n    public List<Node> childNodes() {\n        return Collections.unmodifiableList(childNodes);\n    }\n    \n    protected Node[] childNodesAsArray() {\n        return childNodes.toArray(new Node[childNodes().size()]);\n    }\n\n    \n    public Node parent() {\n        return parentNode;\n    }\n    \n    \n    public Document ownerDocument() {\n        if (this instanceof Document)\n            return (Document) this;\n        else if (parentNode == null)\n            return null;\n        else\n            return parentNode.ownerDocument();\n    }\n    \n    \n    public void remove() {\n        Validate.notNull(parentNode);\n        parentNode.removeChild(this);\n    }\n    \n    \n    public void replaceWith(Node in) {\n        Validate.notNull(in);\n        Validate.notNull(parentNode);\n        parentNode.replaceChild(this, in);\n    }\n\n    protected void setParentNode(Node parentNode) {\n        if (this.parentNode != null)\n            this.parentNode.removeChild(this);\n        this.parentNode = parentNode;\n    }\n\n    protected void replaceChild(Node out, Node in) {\n        Validate.isTrue(out.parentNode == this);\n        Validate.notNull(in);\n        if (in.parentNode != null)\n            in.parentNode.removeChild(in);\n        \n        Integer index = out.siblingIndex();\n        childNodes.set(index, in);\n        in.parentNode = this;\n        in.setSiblingIndex(index);\n        out.parentNode = null;\n    }\n\n    protected void removeChild(Node out) {\n        Validate.isTrue(out.parentNode == this);\n        int index = out.siblingIndex();\n        childNodes.remove(index);\n        reindexChildren();\n        out.parentNode = null;\n    }\n\n    protected void addChildren(Node... children) {\n        \n        for (Node child: children) {\n            reparentChild(child);\n            childNodes.add(child);\n            child.setSiblingIndex(childNodes.size()-1);\n        }\n    }\n\n    protected void addChildren(int index, Node... children) {\n        Validate.noNullElements(children);\n        for (int i = children.length - 1; i >= 0; i--) {\n            Node in = children[i];\n            reparentChild(in);\n            childNodes.add(index, in);\n        }\n        reindexChildren();\n    }\n\n    private void reparentChild(Node child) {\n        if (child.parentNode != null)\n            child.parentNode.removeChild(child);\n        child.setParentNode(this);\n    }\n    \n    private void reindexChildren() {\n        for (int i = 0; i < childNodes.size(); i++) {\n            childNodes.get(i).setSiblingIndex(i);\n        }\n    }\n    \n    \n    public List<Node> siblingNodes() {\n        return parent().childNodes(); \n    }\n\n    \n    public Node nextSibling() {\n        if (parentNode == null)\n            return null; \n        \n        List<Node> siblings = parentNode.childNodes;\n        Integer index = siblingIndex();\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }\n\n    \n    public Node previousSibling() {\n        List<Node> siblings = parentNode.childNodes;\n        Integer index = siblingIndex();\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }\n\n    \n    public Integer siblingIndex() {\n        return siblingIndex;\n    }\n    \n    protected void setSiblingIndex(int siblingIndex) {\n        this.siblingIndex = siblingIndex;\n    }\n\n    \n    public String outerHtml() {\n        StringBuilder accum = new StringBuilder(32*1024);\n        outerHtml(accum);\n        return accum.toString();\n    }\n\n    protected void outerHtml(StringBuilder accum) {\n        new NodeTraversor(new OuterHtmlVisitor(accum, getOutputSettings())).traverse(this);\n    }\n\n    \n    private Document.OutputSettings getOutputSettings() {\n        return ownerDocument() != null ? ownerDocument().outputSettings() : (new Document(\"\")).outputSettings();\n    }\n\n    \n    abstract void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out); abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out); public String toString() {\n        return outerHtml();\n    }\n\n    protected void indent(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"\\n\").append(StringUtil.padding(depth * out.indentAmount()));\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        \n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = parentNode != null ? parentNode.hashCode() : 0;\n        \n        result = 31 * result + (attributes != null ? attributes.hashCode() : 0);\n        return result;\n    }\n\n    \n    @Override\n    public Node clone() {\n        return doClone(null); \n    }\n\n    protected Node doClone(Node parent) {\n        Node clone;\n        try {\n            clone = (Node) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n\n        clone.parentNode = parent; \n        clone.siblingIndex = parent == null ? 0 : siblingIndex;\n        clone.attributes = attributes != null ? attributes.clone() : null;\n        clone.baseUri = baseUri;\n        clone.childNodes = new ArrayList<Node>(childNodes.size());\n        for (Node child: childNodes)\n            clone.childNodes.add(child.doClone(clone)); \n\n        return clone;\n    }\n\n    private static class OuterHtmlVisitor implements NodeVisitor { private StringBuilder accum; private Document.OutputSettings out; OuterHtmlVisitor(StringBuilder accum, Document.OutputSettings out) {\n            this.accum = accum;\n            this.out = out;\n        }\n\n        public void head(Node node, int depth) {\n            node.outerHtmlHead(accum, depth, out);\n        }\n\n        public void tail(Node node, int depth) {\n            if (!node.nodeName().equals(\"#text\")) \n                node.outerHtmlTail(accum, depth, out);\n        }\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.nodes;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.select.NodeTraversor;\nimport org.jsoup.select.NodeVisitor;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n\npublic abstract class Node implements Cloneable { Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri; int siblingIndex; protected Node(String baseUri, Attributes attributes) {\n        Validate.notNull(baseUri);\n        Validate.notNull(attributes);\n        \n        childNodes = new ArrayList<Node>(4);\n        this.baseUri = baseUri.trim();\n        this.attributes = attributes;\n    }\n\n    protected Node(String baseUri) {\n        this(baseUri, new Attributes());\n    }\n\n    \n    protected Node() {\n        childNodes = Collections.EMPTY_LIST;\n        attributes = null;\n    }\n\n    \n    public abstract String nodeName(); public String attr(String attributeKey) {\n        Validate.notNull(attributeKey);\n\n        if (hasAttr(attributeKey))\n            return attributes.get(attributeKey);\n        else if (attributeKey.toLowerCase().startsWith(\"abs:\"))\n            return absUrl(attributeKey.substring(\"abs:\".length()));\n        else return \"\";\n    }\n\n    \n    public Attributes attributes() {\n        return attributes;\n    }\n\n    \n    public Node attr(String attributeKey, String attributeValue) {\n        attributes.put(attributeKey, attributeValue);\n        return this;\n    }\n\n    \n    public boolean hasAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        return attributes.hasKey(attributeKey);\n    }\n\n    \n    public Node removeAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        attributes.remove(attributeKey);\n        return this;\n    }\n\n    \n    public String baseUri() {\n        return baseUri;\n    }\n\n    \n    public void setBaseUri(String baseUri) {\n        Validate.notNull(baseUri);\n        this.baseUri = baseUri;\n    }\n\n    \n    public String absUrl(String attributeKey) {\n        Validate.notEmpty(attributeKey);\n\n        String relUrl = attr(attributeKey);\n        if (!hasAttr(attributeKey)) {\n            return \"\"; \n        } else {\n            URL base;\n            try {\n                try {\n                    base = new URL(baseUri);\n                } catch (MalformedURLException e) {\n                    \n                    URL abs = new URL(relUrl);\n                    return abs.toExternalForm();\n                }\n                \n                if (relUrl.startsWith(\"?\"))\n                    relUrl = base.getPath() + relUrl;\n                URL abs = new URL(base, relUrl);\n                return abs.toExternalForm();\n            } catch (MalformedURLException e) {\n                return \"\";\n            }\n        }\n    }\n\n    \n    public Node childNode(int index) {\n        return childNodes.get(index);\n    }\n\n    \n    public List<Node> childNodes() {\n        return Collections.unmodifiableList(childNodes);\n    }\n    \n    protected Node[] childNodesAsArray() {\n        return childNodes.toArray(new Node[childNodes().size()]);\n    }\n\n    \n    public Node parent() {\n        return parentNode;\n    }\n    \n    \n    public Document ownerDocument() {\n        if (this instanceof Document)\n            return (Document) this;\n        else if (parentNode == null)\n            return null;\n        else\n            return parentNode.ownerDocument();\n    }\n    \n    \n    public void remove() {\n        Validate.notNull(parentNode);\n        parentNode.removeChild(this);\n    }\n    \n    \n    public void replaceWith(Node in) {\n        Validate.notNull(in);\n        Validate.notNull(parentNode);\n        parentNode.replaceChild(this, in);\n    }\n\n    protected void setParentNode(Node parentNode) {\n        if (this.parentNode != null)\n            this.parentNode.removeChild(this);\n        this.parentNode = parentNode;\n    }\n\n    protected void replaceChild(Node out, Node in) {\n        Validate.isTrue(out.parentNode == this);\n        Validate.notNull(in);\n        if (in.parentNode != null)\n            in.parentNode.removeChild(in);\n        \n        Integer index = out.siblingIndex();\n        childNodes.set(index, in);\n        in.parentNode = this;\n        in.setSiblingIndex(index);\n        out.parentNode = null;\n    }\n\n    protected void removeChild(Node out) {\n        Validate.isTrue(out.parentNode == this);\n        int index = out.siblingIndex();\n        childNodes.remove(index);\n        reindexChildren();\n        out.parentNode = null;\n    }\n\n    protected void addChildren(Node... children) {\n        \n        for (Node child: children) {\n            reparentChild(child);\n            childNodes.add(child);\n            child.setSiblingIndex(childNodes.size()-1);\n        }\n    }\n\n    protected void addChildren(int index, Node... children) {\n        Validate.noNullElements(children);\n        for (int i = children.length - 1; i >= 0; i--) {\n            Node in = children[i];\n            reparentChild(in);\n            childNodes.add(index, in);\n        }\n        reindexChildren();\n    }\n\n    private void reparentChild(Node child) {\n        if (child.parentNode != null)\n            child.parentNode.removeChild(child);\n        child.setParentNode(this);\n    }\n    \n    private void reindexChildren() {\n        for (int i = 0; i < childNodes.size(); i++) {\n            childNodes.get(i).setSiblingIndex(i);\n        }\n    }\n    \n    \n    public List<Node> siblingNodes() {\n        return parent().childNodes(); \n    }\n\n    \n    public Node nextSibling() {\n        if (parentNode == null)\n            return null; \n        \n        List<Node> siblings = parentNode.childNodes;\n        Integer index = siblingIndex();\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }\n\n    \n    public Node previousSibling() {\n        List<Node> siblings = parentNode.childNodes;\n        Integer index = siblingIndex();\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }\n\n    \n    public Integer siblingIndex() {\n        return siblingIndex;\n    }\n    \n    protected void setSiblingIndex(int siblingIndex) {\n        this.siblingIndex = siblingIndex;\n    }\n\n    \n    public String outerHtml() {\n        StringBuilder accum = new StringBuilder(32*1024);\n        outerHtml(accum);\n        return accum.toString();\n    }\n\n    protected void outerHtml(StringBuilder accum) {\n        new NodeTraversor(new OuterHtmlVisitor(accum, getOutputSettings())).traverse(this);\n    }\n\n    \n    private Document.OutputSettings getOutputSettings() {\n        return ownerDocument() != null ? ownerDocument().outputSettings() : (new Document(\"\")).outputSettings();\n    }\n\n    \n    abstract void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out); abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out); public String toString() {\n        return outerHtml();\n    }\n\n    protected void indent(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"\\n\").append(StringUtil.padding(depth * out.indentAmount()));\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        \n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = parentNode != null ? parentNode.hashCode() : 0;\n        \n        result = 31 * result + (attributes != null ? attributes.hashCode() : 0);\n        return result;\n    }\n\n    \n    @Override\n    public Node clone() {\n        return doClone(null); \n    }\n\n    protected Node doClone(Node parent) {\n        Node clone;\n        try {\n            clone = (Node) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n\n        clone.parentNode = parent; \n        clone.siblingIndex = parent == null ? 0 : siblingIndex;\n        clone.attributes = attributes != null ? attributes.clone() : null;\n        clone.baseUri = baseUri;\n        clone.childNodes = new ArrayList<Node>(childNodes.size());\n        for (Node child: childNodes)\n            clone.childNodes.add(child.doClone(clone)); \n\n        return clone;\n    }\n\n    private static class OuterHtmlVisitor implements NodeVisitor { private StringBuilder accum; private Document.OutputSettings out; OuterHtmlVisitor(StringBuilder accum, Document.OutputSettings out) {\n            this.accum = accum;\n            this.out = out;\n        }\n\n        public void head(Node node, int depth) {\n            node.outerHtmlHead(accum, depth, out);\n        }\n\n        public void tail(Node node, int depth) {\n            if (!node.nodeName().equals(\"#text\")) \n                node.outerHtmlTail(accum, depth, out);\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public abstract class Node implements Cloneable { Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri; int siblingIndex; protected Node(String baseUri, Attributes attributes)",
        "protected Node(String baseUri)",
        "protected Node()",
        "public abstract String nodeName(); public String attr(String attributeKey)",
        "public Attributes attributes()",
        "public Node attr(String attributeKey, String attributeValue)",
        "public boolean hasAttr(String attributeKey)",
        "public Node removeAttr(String attributeKey)",
        "public String baseUri()",
        "public void setBaseUri(String baseUri)",
        "public String absUrl(String attributeKey)",
        "public Node childNode(int index)",
        "public List<Node> childNodes()",
        "protected Node[] childNodesAsArray()",
        "public Node parent()",
        "public Document ownerDocument()",
        "public void remove()",
        "public void replaceWith(Node in)",
        "protected void setParentNode(Node parentNode)",
        "protected void replaceChild(Node out, Node in)",
        "protected void removeChild(Node out)",
        "protected void addChildren(Node... children)",
        "protected void addChildren(int index, Node... children)",
        "private void reparentChild(Node child)",
        "private void reindexChildren()",
        "public List<Node> siblingNodes()",
        "public Node nextSibling()",
        "public Node previousSibling()",
        "public Integer siblingIndex()",
        "protected void setSiblingIndex(int siblingIndex)",
        "public String outerHtml()",
        "protected void outerHtml(StringBuilder accum)",
        "private Document.OutputSettings getOutputSettings()",
        "abstract void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out); abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out); public String toString()",
        "protected void indent(StringBuilder accum, int depth, Document.OutputSettings out)",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "public Node clone()",
        "protected Node doClone(Node parent)",
        "private static class OuterHtmlVisitor implements NodeVisitor { private StringBuilder accum; private Document.OutputSettings out; OuterHtmlVisitor(StringBuilder accum, Document.OutputSettings out)",
        "public void head(Node node, int depth)",
        "public void tail(Node node, int depth)"
      ],
      "fixed_signatures": [
        "public abstract class Node implements Cloneable { Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri; int siblingIndex; protected Node(String baseUri, Attributes attributes)",
        "protected Node(String baseUri)",
        "protected Node()",
        "public abstract String nodeName(); public String attr(String attributeKey)",
        "public Attributes attributes()",
        "public Node attr(String attributeKey, String attributeValue)",
        "public boolean hasAttr(String attributeKey)",
        "public Node removeAttr(String attributeKey)",
        "public String baseUri()",
        "public void setBaseUri(String baseUri)",
        "public String absUrl(String attributeKey)",
        "public Node childNode(int index)",
        "public List<Node> childNodes()",
        "protected Node[] childNodesAsArray()",
        "public Node parent()",
        "public Document ownerDocument()",
        "public void remove()",
        "public void replaceWith(Node in)",
        "protected void setParentNode(Node parentNode)",
        "protected void replaceChild(Node out, Node in)",
        "protected void removeChild(Node out)",
        "protected void addChildren(Node... children)",
        "protected void addChildren(int index, Node... children)",
        "private void reparentChild(Node child)",
        "private void reindexChildren()",
        "public List<Node> siblingNodes()",
        "public Node nextSibling()",
        "public Node previousSibling()",
        "public Integer siblingIndex()",
        "protected void setSiblingIndex(int siblingIndex)",
        "public String outerHtml()",
        "protected void outerHtml(StringBuilder accum)",
        "private Document.OutputSettings getOutputSettings()",
        "abstract void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out); abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out); public String toString()",
        "protected void indent(StringBuilder accum, int depth, Document.OutputSettings out)",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "public Node clone()",
        "protected Node doClone(Node parent)",
        "private static class OuterHtmlVisitor implements NodeVisitor { private StringBuilder accum; private Document.OutputSettings out; OuterHtmlVisitor(StringBuilder accum, Document.OutputSettings out)",
        "public void head(Node node, int depth)",
        "public void tail(Node node, int depth)"
      ],
      "methods": [
        {
          "buggy_method": "  public String absUrl(String attributeKey) {\n  Validate.notEmpty(attributeKey);\n\n  String relUrl = attr(attributeKey);\n  if (!hasAttr(attributeKey)) {\n  return \"\"; \n  } else {\n  URL base;\n  try {\n  try {\n  base = new URL(baseUri);\n  } catch (MalformedURLException e) {\n  \n  URL abs = new URL(relUrl);\n  return abs.toExternalForm();\n  }\n  \n  URL abs = new URL(base, relUrl);\n  return abs.toExternalForm();\n  } catch (MalformedURLException e) {\n  return \"\";\n  }\n  }\n  }",
          "fixed_method": "  public String absUrl(String attributeKey) {\n  Validate.notEmpty(attributeKey);\n\n  String relUrl = attr(attributeKey);\n  if (!hasAttr(attributeKey)) {\n  return \"\"; \n  } else {\n  URL base;\n  try {\n  try {\n  base = new URL(baseUri);\n  } catch (MalformedURLException e) {\n  \n  URL abs = new URL(relUrl);\n  return abs.toExternalForm();\n  }\n  \n  if (relUrl.startsWith(\"?\"))\n  relUrl = base.getPath() + relUrl;\n  URL abs = new URL(base, relUrl);\n  return abs.toExternalForm();\n  } catch (MalformedURLException e) {\n  return \"\";\n  }\n  }\n  }",
          "diff": [
            "@@ -170,6 +170,8 @@",
            "                     return abs.toExternalForm();\n",
            "                 }\n",
            "                 // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired\n",
            "+                if (relUrl.startsWith(\"?\"))\n",
            "+                    relUrl = base.getPath() + relUrl;\n",
            "                 URL abs = new URL(base, relUrl);\n",
            "                 return abs.toExternalForm();\n",
            "             } catch (MalformedURLException e) {\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
