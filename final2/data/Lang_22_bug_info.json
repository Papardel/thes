{
  "bug_id": "22",
  "failed_tests": {
    "org.apache.commons.lang3.math.FractionTest": [
      {
        "methodName": "testReducedFactory_int_int",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<-1073741824> but was:<-2147483648>",
        "fail_line": "        assertEquals(Integer.MIN_VALUE / 2, f.getNumerator());",
        "test_source": "  public void testReducedFactory_int_int() {\n  Fraction f = null;\n  \n  // zero\n  f = Fraction.getReducedFraction(0, 1);\n  assertEquals(0, f.getNumerator());\n  assertEquals(1, f.getDenominator());\n  \n  // normal\n  f = Fraction.getReducedFraction(1, 1);\n  assertEquals(1, f.getNumerator());\n  assertEquals(1, f.getDenominator());\n  \n  f = Fraction.getReducedFraction(2, 1);\n  assertEquals(2, f.getNumerator());\n  assertEquals(1, f.getDenominator());\n  \n  // improper\n  f = Fraction.getReducedFraction(22, 7);\n  assertEquals(22, f.getNumerator());\n  assertEquals(7, f.getDenominator());\n  \n  // negatives\n  f = Fraction.getReducedFraction(-6, 10);\n  assertEquals(-3, f.getNumerator());\n  assertEquals(5, f.getDenominator());\n  \n  f = Fraction.getReducedFraction(6, -10);\n  assertEquals(-3, f.getNumerator());\n  assertEquals(5, f.getDenominator());\n  \n  f = Fraction.getReducedFraction(-6, -10);\n  assertEquals(3, f.getNumerator());\n  assertEquals(5, f.getDenominator());\n  \n  // zero denominator\n  try {\n  f = Fraction.getReducedFraction(1, 0);\n  fail(\"expecting ArithmeticException\");\n  } catch (ArithmeticException ex) {}\n  \n  try {\n  f = Fraction.getReducedFraction(2, 0);\n  fail(\"expecting ArithmeticException\");\n  } catch (ArithmeticException ex) {}\n  \n  try {\n  f = Fraction.getReducedFraction(-3, 0);\n  fail(\"expecting ArithmeticException\");\n  } catch (ArithmeticException ex) {}\n\n  // reduced  \n  f = Fraction.getReducedFraction(0, 2);\n  assertEquals(0, f.getNumerator());\n  assertEquals(1, f.getDenominator());\n  \n  f = Fraction.getReducedFraction(2, 2);\n  assertEquals(1, f.getNumerator());\n  assertEquals(1, f.getDenominator());\n  \n  f = Fraction.getReducedFraction(2, 4);\n  assertEquals(1, f.getNumerator());\n  assertEquals(2, f.getDenominator());\n  \n  f = Fraction.getReducedFraction(15, 10);\n  assertEquals(3, f.getNumerator());\n  assertEquals(2, f.getDenominator());\n  \n  f = Fraction.getReducedFraction(121, 22);\n  assertEquals(11, f.getNumerator());\n  assertEquals(2, f.getDenominator());\n  \n  // Extreme values \n  // OK, can reduce before negating\n  f = Fraction.getReducedFraction(-2, Integer.MIN_VALUE);\n  assertEquals(1, f.getNumerator());\n  assertEquals(-(Integer.MIN_VALUE / 2), f.getDenominator());\n  \n  // Can't reduce, negation will throw\n  try { \n  f = Fraction.getReducedFraction(-7, Integer.MIN_VALUE);  \n  fail(\"Expecting ArithmeticException\");\n  } catch (ArithmeticException ex) {}  \n\n  // LANG-662\n  f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2);\n  assertEquals(Integer.MIN_VALUE / 2, f.getNumerator());\n  assertEquals(1, f.getDenominator());\n  }",
        "stack": [
          "FractionTest.testReducedFactory_int_int line 336"
        ]
      },
      {
        "methodName": "testReduce",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<-1073741824> but was:<-2147483648>",
        "fail_line": "        assertEquals(Integer.MIN_VALUE / 2, result.getNumerator());",
        "test_source": "  public void testReduce() {\n  Fraction f = null;\n  \n  f = Fraction.getFraction(50, 75);\n  Fraction result = f.reduce();\n  assertEquals(2, result.getNumerator());\n  assertEquals(3, result.getDenominator());\n\n  f = Fraction.getFraction(-2, -3);\n  result = f.reduce();\n  assertEquals(2, result.getNumerator());\n  assertEquals(3, result.getDenominator());\n\n  f = Fraction.getFraction(2, -3);\n  result = f.reduce();\n  assertEquals(-2, result.getNumerator());\n  assertEquals(3, result.getDenominator());\n\n  f = Fraction.getFraction(-2, 3);\n  result = f.reduce();\n  assertEquals(-2, result.getNumerator());\n  assertEquals(3, result.getDenominator());\n  assertSame(f, result);\n\n  f = Fraction.getFraction(2, 3);\n  result = f.reduce();\n  assertEquals(2, result.getNumerator());\n  assertEquals(3, result.getDenominator());\n  assertSame(f, result);\n\n  f = Fraction.getFraction(0, 1);\n  result = f.reduce();\n  assertEquals(0, result.getNumerator());\n  assertEquals(1, result.getDenominator());\n  assertSame(f, result);\n\n  f = Fraction.getFraction(0, 100);\n  result = f.reduce();\n  assertEquals(0, result.getNumerator());\n  assertEquals(1, result.getDenominator());\n  assertSame(result, Fraction.ZERO);\n\n  f = Fraction.getFraction(Integer.MIN_VALUE, 2);\n  result = f.reduce();\n  assertEquals(Integer.MIN_VALUE / 2, result.getNumerator());\n  assertEquals(1, result.getDenominator());\n  }",
        "stack": [
          "FractionTest.testReduce line 654"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/lang3/math/Fraction.java",
      "buggy_full_code": "\npackage org.apache.commons.lang3.math;\n\nimport java.math.BigInteger;\n\n\npublic final class Fraction extends Number implements Comparable<Fraction> { private static final long serialVersionUID = 65382027393090L; public static final Fraction ZERO = new Fraction(0, 1); public static final Fraction ONE = new Fraction(1, 1); public static final Fraction ONE_HALF = new Fraction(1, 2); public static final Fraction ONE_THIRD = new Fraction(1, 3); public static final Fraction TWO_THIRDS = new Fraction(2, 3); public static final Fraction ONE_QUARTER = new Fraction(1, 4); public static final Fraction TWO_QUARTERS = new Fraction(2, 4); public static final Fraction THREE_QUARTERS = new Fraction(3, 4); public static final Fraction ONE_FIFTH = new Fraction(1, 5); public static final Fraction TWO_FIFTHS = new Fraction(2, 5); public static final Fraction THREE_FIFTHS = new Fraction(3, 5); public static final Fraction FOUR_FIFTHS = new Fraction(4, 5); private final int numerator; private final int denominator; private transient int hashCode = 0; private transient String toString = null; private transient String toProperString = null; private Fraction(int numerator, int denominator) {\n        super();\n        this.numerator = numerator;\n        this.denominator = denominator;\n    }\n\n    \n    public static Fraction getFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (denominator < 0) {\n            if (numerator==Integer.MIN_VALUE ||\n                    denominator==Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        return new Fraction(numerator, denominator);\n    }\n\n    \n    public static Fraction getFraction(int whole, int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (denominator < 0) {\n            throw new ArithmeticException(\"The denominator must not be negative\");\n        }\n        if (numerator < 0) {\n            throw new ArithmeticException(\"The numerator must not be negative\");\n        }\n        long numeratorValue;\n        if (whole < 0) {\n            numeratorValue = whole * (long)denominator - numerator;\n        } else {\n            numeratorValue = whole * (long)denominator + numerator;\n        }\n        if (numeratorValue < Integer.MIN_VALUE ||\n                numeratorValue > Integer.MAX_VALUE)  {\n            throw new ArithmeticException(\"Numerator too large to represent as an Integer.\");\n        }\n        return new Fraction((int) numeratorValue, denominator);\n    }\n\n    \n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (numerator==0) {\n            return ZERO; \n        }\n        \n        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n            numerator/=2; denominator/=2;\n        }\n        if (denominator < 0) {\n            if (numerator==Integer.MIN_VALUE ||\n                    denominator==Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        \n        int gcd = greatestCommonDivisor(numerator, denominator);\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }\n\n    \n    public static Fraction getFraction(double value) {\n        int sign = (value < 0 ? -1 : 1);\n        value = Math.abs(value);\n        if (value  > Integer.MAX_VALUE || Double.isNaN(value)) {\n            throw new ArithmeticException\n                (\"The value must not be greater than Integer.MAX_VALUE or NaN\");\n        }\n        int wholeNumber = (int) value;\n        value -= wholeNumber;\n        \n        int numer0 = 0;  \n        int denom0 = 1;  \n        int numer1 = 1;  \n        int denom1 = 0;  \n        int numer2 = 0;  \n        int denom2 = 0;  \n        int a1 = (int) value;\n        int a2 = 0;\n        double x1 = 1;\n        double x2 = 0;\n        double y1 = value - a1;\n        double y2 = 0;\n        double delta1, delta2 = Double.MAX_VALUE;\n        double fraction;\n        int i = 1;\n\n        do {\n            delta1 = delta2;\n            a2 = (int) (x1 / y1);\n            x2 = y1;\n            y2 = x1 - a2 * y1;\n            numer2 = a1 * numer1 + numer0;\n            denom2 = a1 * denom1 + denom0;\n            fraction = (double) numer2 / (double) denom2;\n            delta2 = Math.abs(value - fraction);\n\n            a1 = a2;\n            x1 = x2;\n            y1 = y2;\n            numer0 = numer1;\n            denom0 = denom1;\n            numer1 = numer2;\n            denom1 = denom2;\n            i++;\n\n        } while ((delta1 > delta2) && (denom2 <= 10000) && (denom2 > 0) && (i < 25));\n        if (i == 25) {\n            throw new ArithmeticException(\"Unable to convert double to fraction\");\n        }\n        return getReducedFraction((numer0 + wholeNumber * denom0) * sign, denom0);\n    }\n\n    \n    public static Fraction getFraction(String str) {\n        if (str == null) {\n            throw new IllegalArgumentException(\"The string must not be null\");\n        }\n        \n        int pos = str.indexOf('.');\n        if (pos >= 0) {\n            return getFraction(Double.parseDouble(str));\n        }\n\n        \n        pos = str.indexOf(' ');\n        if (pos > 0) {\n            int whole = Integer.parseInt(str.substring(0, pos));\n            str = str.substring(pos + 1);\n            pos = str.indexOf('/');\n            if (pos < 0) {\n                throw new NumberFormatException(\"The fraction could not be parsed as the format X Y/Z\");\n            } else {\n                int numer = Integer.parseInt(str.substring(0, pos));\n                int denom = Integer.parseInt(str.substring(pos + 1));\n                return getFraction(whole, numer, denom);\n            }\n        }\n\n        \n        pos = str.indexOf('/');\n        if (pos < 0) {\n            \n            return getFraction(Integer.parseInt(str), 1);\n        } else {\n            int numer = Integer.parseInt(str.substring(0, pos));\n            int denom = Integer.parseInt(str.substring(pos + 1));\n            return getFraction(numer, denom);\n        }\n    }\n\n    \n    \n\n    \n    public int getNumerator() {\n        return numerator;\n    }\n\n    \n    public int getDenominator() {\n        return denominator;\n    }\n\n    \n    public int getProperNumerator() {\n        return Math.abs(numerator % denominator);\n    }\n\n    \n    public int getProperWhole() {\n        return numerator / denominator;\n    }\n\n    \n    \n\n    \n    @Override\n    public int intValue() {\n        return numerator / denominator;\n    }\n\n    \n    @Override\n    public long longValue() {\n        return (long) numerator / denominator;\n    }\n\n    \n    @Override\n    public float floatValue() {\n        return ((float) numerator) / ((float) denominator);\n    }\n\n    \n    @Override\n    public double doubleValue() {\n        return ((double) numerator) / ((double) denominator);\n    }\n\n    \n    \n\n    \n    public Fraction reduce() {\n        if (numerator == 0) {\n            return equals(ZERO) ? this : ZERO;\n        }\n        int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n        if (gcd == 1) {\n            return this;\n        }\n        return Fraction.getFraction(numerator / gcd, denominator / gcd);\n    }\n\n    \n    public Fraction invert() {\n        if (numerator == 0) {\n            throw new ArithmeticException(\"Unable to invert zero.\");\n        }\n        if (numerator==Integer.MIN_VALUE) {\n            throw new ArithmeticException(\"overflow: can't negate numerator\");\n        }\n        if (numerator<0) {\n            return new Fraction(-denominator, -numerator);\n        } else {\n            return new Fraction(denominator, numerator);\n        }\n    }\n\n    \n    public Fraction negate() {\n        \n        if (numerator==Integer.MIN_VALUE) {\n            throw new ArithmeticException(\"overflow: too large to negate\");\n        }\n        return new Fraction(-numerator, denominator);\n    }\n\n    \n    public Fraction abs() {\n        if (numerator >= 0) {\n            return this;\n        }\n        return negate();\n    }\n\n    \n    public Fraction pow(int power) {\n        if (power == 1) {\n            return this;\n        } else if (power == 0) {\n            return ONE;\n        } else if (power < 0) {\n            if (power==Integer.MIN_VALUE) { \n                return this.invert().pow(2).pow(-(power/2));\n            }\n            return this.invert().pow(-power);\n        } else {\n            Fraction f = this.multiplyBy(this);\n            if ((power % 2) == 0) { \n                return f.pow(power/2);\n            } else { \n                return f.pow(power/2).multiplyBy(this);\n            }\n        }\n    }\n\n    \n    private static int greatestCommonDivisor(int u, int v) {\n        \n        \n        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n            return 1;\n        }\n        \n        \n        \n        \n        if (u>0) { u=-u; } \n        if (v>0) { v=-v; } \n        \n        int k=0;\n        while ((u&1)==0 && (v&1)==0 && k<31) { \n            u/=2; v/=2; k++; \n        }\n        if (k==31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        \n        \n        int t = ((u&1)==1) ? v : -(u/2);\n        \n        \n        do {\n            \n            \n            while ((t&1)==0) { \n                t/=2; \n            }\n            \n            if (t>0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            \n            t = (v - u)/2;\n            \n            \n        } while (t!=0);\n        return -u*(1<<k); \n    }\n\n    \n    \n\n    \n    private static int mulAndCheck(int x, int y) {\n        long m = ((long)x)*((long)y);\n        if (m < Integer.MIN_VALUE ||\n            m > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: mul\");\n        }\n        return (int)m;\n    }\n    \n    \n    private static int mulPosAndCheck(int x, int y) {\n        \n        long m = ((long)x)*((long)y);\n        if (m > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: mulPos\");\n        }\n        return (int)m;\n    }\n    \n    \n    private static int addAndCheck(int x, int y) {\n        long s = (long)x+(long)y;\n        if (s < Integer.MIN_VALUE ||\n            s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: add\");\n        }\n        return (int)s;\n    }\n    \n    \n    private static int subAndCheck(int x, int y) {\n        long s = (long)x-(long)y;\n        if (s < Integer.MIN_VALUE ||\n            s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: add\");\n        }\n        return (int)s;\n    }\n    \n    \n    public Fraction add(Fraction fraction) {\n        return addSub(fraction, true );\n    }\n\n    \n    public Fraction subtract(Fraction fraction) {\n        return addSub(fraction, false );\n    }\n\n    \n    private Fraction addSub(Fraction fraction, boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        \n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        \n        \n        int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            \n            int uvp = mulAndCheck(numerator, fraction.denominator);\n            int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        \n        \n        \n        BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\n        BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);\n        \n        \n        int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        int d2 = (tmodd1==0)?d1:greatestCommonDivisor(tmodd1, d1);\n\n        \n        BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }\n\n    \n    public Fraction multiplyBy(Fraction fraction) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        if (numerator == 0 || fraction.numerator == 0) {\n            return ZERO;\n        }\n        \n        \n        int d1 = greatestCommonDivisor(numerator, fraction.denominator);\n        int d2 = greatestCommonDivisor(fraction.numerator, denominator);\n        return getReducedFraction\n            (mulAndCheck(numerator/d1, fraction.numerator/d2),\n             mulPosAndCheck(denominator/d2, fraction.denominator/d1));\n    }\n\n    \n    public Fraction divideBy(Fraction fraction) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        if (fraction.numerator == 0) {\n            throw new ArithmeticException(\"The fraction to divide by must not be zero\");\n        }\n        return multiplyBy(fraction.invert());\n    }\n\n    \n    \n\n    \n    @Override\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (obj instanceof Fraction == false) {\n            return false;\n        }\n        Fraction other = (Fraction) obj;\n        return (getNumerator() == other.getNumerator() &&\n                getDenominator() == other.getDenominator());\n    }\n\n    \n    @Override\n    public int hashCode() {\n        if (hashCode == 0) {\n            \n            hashCode = 37 * (37 * 17 + getNumerator()) + getDenominator();\n        }\n        return hashCode;\n    }\n\n    \n    public int compareTo(Fraction other) {\n        if (this==other) {\n            return 0;\n        }\n        if (numerator == other.numerator && denominator == other.denominator) {\n            return 0;\n        }\n\n        \n        long first = (long) numerator * (long) other.denominator;\n        long second = (long) other.numerator * (long) denominator;\n        if (first == second) {\n            return 0;\n        } else if (first < second) {\n            return -1;\n        } else {\n            return 1;\n        }\n    }\n\n    \n    @Override\n    public String toString() {\n        if (toString == null) {\n            toString = new StringBuilder(32)\n                .append(getNumerator())\n                .append('/')\n                .append(getDenominator()).toString();\n        }\n        return toString;\n    }\n\n    \n    public String toProperString() {\n        if (toProperString == null) {\n            if (numerator == 0) {\n                toProperString = \"0\";\n            } else if (numerator == denominator) {\n                toProperString = \"1\";\n            } else if (numerator == -1 * denominator) {\n                toProperString = \"-1\";\n            } else if ((numerator>0?-numerator:numerator) < -denominator) {\n                \n                \n                \n                \n                int properNumerator = getProperNumerator();\n                if (properNumerator == 0) {\n                    toProperString = Integer.toString(getProperWhole());\n                } else {\n                    toProperString = new StringBuilder(32)\n                        .append(getProperWhole()).append(' ')\n                        .append(properNumerator).append('/')\n                        .append(getDenominator()).toString();\n                }\n            } else {\n                toProperString = new StringBuilder(32)\n                    .append(getNumerator()).append('/')\n                    .append(getDenominator()).toString();\n            }\n        }\n        return toProperString;\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.lang3.math;\n\nimport java.math.BigInteger;\n\n\npublic final class Fraction extends Number implements Comparable<Fraction> { private static final long serialVersionUID = 65382027393090L; public static final Fraction ZERO = new Fraction(0, 1); public static final Fraction ONE = new Fraction(1, 1); public static final Fraction ONE_HALF = new Fraction(1, 2); public static final Fraction ONE_THIRD = new Fraction(1, 3); public static final Fraction TWO_THIRDS = new Fraction(2, 3); public static final Fraction ONE_QUARTER = new Fraction(1, 4); public static final Fraction TWO_QUARTERS = new Fraction(2, 4); public static final Fraction THREE_QUARTERS = new Fraction(3, 4); public static final Fraction ONE_FIFTH = new Fraction(1, 5); public static final Fraction TWO_FIFTHS = new Fraction(2, 5); public static final Fraction THREE_FIFTHS = new Fraction(3, 5); public static final Fraction FOUR_FIFTHS = new Fraction(4, 5); private final int numerator; private final int denominator; private transient int hashCode = 0; private transient String toString = null; private transient String toProperString = null; private Fraction(int numerator, int denominator) {\n        super();\n        this.numerator = numerator;\n        this.denominator = denominator;\n    }\n\n    \n    public static Fraction getFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (denominator < 0) {\n            if (numerator==Integer.MIN_VALUE ||\n                    denominator==Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        return new Fraction(numerator, denominator);\n    }\n\n    \n    public static Fraction getFraction(int whole, int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (denominator < 0) {\n            throw new ArithmeticException(\"The denominator must not be negative\");\n        }\n        if (numerator < 0) {\n            throw new ArithmeticException(\"The numerator must not be negative\");\n        }\n        long numeratorValue;\n        if (whole < 0) {\n            numeratorValue = whole * (long)denominator - numerator;\n        } else {\n            numeratorValue = whole * (long)denominator + numerator;\n        }\n        if (numeratorValue < Integer.MIN_VALUE ||\n                numeratorValue > Integer.MAX_VALUE)  {\n            throw new ArithmeticException(\"Numerator too large to represent as an Integer.\");\n        }\n        return new Fraction((int) numeratorValue, denominator);\n    }\n\n    \n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (numerator==0) {\n            return ZERO; \n        }\n        \n        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n            numerator/=2; denominator/=2;\n        }\n        if (denominator < 0) {\n            if (numerator==Integer.MIN_VALUE ||\n                    denominator==Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        \n        int gcd = greatestCommonDivisor(numerator, denominator);\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }\n\n    \n    public static Fraction getFraction(double value) {\n        int sign = (value < 0 ? -1 : 1);\n        value = Math.abs(value);\n        if (value  > Integer.MAX_VALUE || Double.isNaN(value)) {\n            throw new ArithmeticException\n                (\"The value must not be greater than Integer.MAX_VALUE or NaN\");\n        }\n        int wholeNumber = (int) value;\n        value -= wholeNumber;\n        \n        int numer0 = 0;  \n        int denom0 = 1;  \n        int numer1 = 1;  \n        int denom1 = 0;  \n        int numer2 = 0;  \n        int denom2 = 0;  \n        int a1 = (int) value;\n        int a2 = 0;\n        double x1 = 1;\n        double x2 = 0;\n        double y1 = value - a1;\n        double y2 = 0;\n        double delta1, delta2 = Double.MAX_VALUE;\n        double fraction;\n        int i = 1;\n\n        do {\n            delta1 = delta2;\n            a2 = (int) (x1 / y1);\n            x2 = y1;\n            y2 = x1 - a2 * y1;\n            numer2 = a1 * numer1 + numer0;\n            denom2 = a1 * denom1 + denom0;\n            fraction = (double) numer2 / (double) denom2;\n            delta2 = Math.abs(value - fraction);\n\n            a1 = a2;\n            x1 = x2;\n            y1 = y2;\n            numer0 = numer1;\n            denom0 = denom1;\n            numer1 = numer2;\n            denom1 = denom2;\n            i++;\n\n        } while ((delta1 > delta2) && (denom2 <= 10000) && (denom2 > 0) && (i < 25));\n        if (i == 25) {\n            throw new ArithmeticException(\"Unable to convert double to fraction\");\n        }\n        return getReducedFraction((numer0 + wholeNumber * denom0) * sign, denom0);\n    }\n\n    \n    public static Fraction getFraction(String str) {\n        if (str == null) {\n            throw new IllegalArgumentException(\"The string must not be null\");\n        }\n        \n        int pos = str.indexOf('.');\n        if (pos >= 0) {\n            return getFraction(Double.parseDouble(str));\n        }\n\n        \n        pos = str.indexOf(' ');\n        if (pos > 0) {\n            int whole = Integer.parseInt(str.substring(0, pos));\n            str = str.substring(pos + 1);\n            pos = str.indexOf('/');\n            if (pos < 0) {\n                throw new NumberFormatException(\"The fraction could not be parsed as the format X Y/Z\");\n            } else {\n                int numer = Integer.parseInt(str.substring(0, pos));\n                int denom = Integer.parseInt(str.substring(pos + 1));\n                return getFraction(whole, numer, denom);\n            }\n        }\n\n        \n        pos = str.indexOf('/');\n        if (pos < 0) {\n            \n            return getFraction(Integer.parseInt(str), 1);\n        } else {\n            int numer = Integer.parseInt(str.substring(0, pos));\n            int denom = Integer.parseInt(str.substring(pos + 1));\n            return getFraction(numer, denom);\n        }\n    }\n\n    \n    \n\n    \n    public int getNumerator() {\n        return numerator;\n    }\n\n    \n    public int getDenominator() {\n        return denominator;\n    }\n\n    \n    public int getProperNumerator() {\n        return Math.abs(numerator % denominator);\n    }\n\n    \n    public int getProperWhole() {\n        return numerator / denominator;\n    }\n\n    \n    \n\n    \n    @Override\n    public int intValue() {\n        return numerator / denominator;\n    }\n\n    \n    @Override\n    public long longValue() {\n        return (long) numerator / denominator;\n    }\n\n    \n    @Override\n    public float floatValue() {\n        return ((float) numerator) / ((float) denominator);\n    }\n\n    \n    @Override\n    public double doubleValue() {\n        return ((double) numerator) / ((double) denominator);\n    }\n\n    \n    \n\n    \n    public Fraction reduce() {\n        if (numerator == 0) {\n            return equals(ZERO) ? this : ZERO;\n        }\n        int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n        if (gcd == 1) {\n            return this;\n        }\n        return Fraction.getFraction(numerator / gcd, denominator / gcd);\n    }\n\n    \n    public Fraction invert() {\n        if (numerator == 0) {\n            throw new ArithmeticException(\"Unable to invert zero.\");\n        }\n        if (numerator==Integer.MIN_VALUE) {\n            throw new ArithmeticException(\"overflow: can't negate numerator\");\n        }\n        if (numerator<0) {\n            return new Fraction(-denominator, -numerator);\n        } else {\n            return new Fraction(denominator, numerator);\n        }\n    }\n\n    \n    public Fraction negate() {\n        \n        if (numerator==Integer.MIN_VALUE) {\n            throw new ArithmeticException(\"overflow: too large to negate\");\n        }\n        return new Fraction(-numerator, denominator);\n    }\n\n    \n    public Fraction abs() {\n        if (numerator >= 0) {\n            return this;\n        }\n        return negate();\n    }\n\n    \n    public Fraction pow(int power) {\n        if (power == 1) {\n            return this;\n        } else if (power == 0) {\n            return ONE;\n        } else if (power < 0) {\n            if (power==Integer.MIN_VALUE) { \n                return this.invert().pow(2).pow(-(power/2));\n            }\n            return this.invert().pow(-power);\n        } else {\n            Fraction f = this.multiplyBy(this);\n            if ((power % 2) == 0) { \n                return f.pow(power/2);\n            } else { \n                return f.pow(power/2).multiplyBy(this);\n            }\n        }\n    }\n\n    \n    private static int greatestCommonDivisor(int u, int v) {\n        \n        if ((u == 0) || (v == 0)) {\n            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n                throw new ArithmeticException(\"overflow: gcd is 2^31\");\n            }\n            return Math.abs(u) + Math.abs(v);\n        }\n        \n        if (Math.abs(u) == 1 || Math.abs(v) == 1) {\n            return 1;\n        }\n        \n        \n        \n        \n        if (u>0) { u=-u; } \n        if (v>0) { v=-v; } \n        \n        int k=0;\n        while ((u&1)==0 && (v&1)==0 && k<31) { \n            u/=2; v/=2; k++; \n        }\n        if (k==31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        \n        \n        int t = ((u&1)==1) ? v : -(u/2);\n        \n        \n        do {\n            \n            \n            while ((t&1)==0) { \n                t/=2; \n            }\n            \n            if (t>0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            \n            t = (v - u)/2;\n            \n            \n        } while (t!=0);\n        return -u*(1<<k); \n    }\n\n    \n    \n\n    \n    private static int mulAndCheck(int x, int y) {\n        long m = ((long)x)*((long)y);\n        if (m < Integer.MIN_VALUE ||\n            m > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: mul\");\n        }\n        return (int)m;\n    }\n    \n    \n    private static int mulPosAndCheck(int x, int y) {\n        \n        long m = ((long)x)*((long)y);\n        if (m > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: mulPos\");\n        }\n        return (int)m;\n    }\n    \n    \n    private static int addAndCheck(int x, int y) {\n        long s = (long)x+(long)y;\n        if (s < Integer.MIN_VALUE ||\n            s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: add\");\n        }\n        return (int)s;\n    }\n    \n    \n    private static int subAndCheck(int x, int y) {\n        long s = (long)x-(long)y;\n        if (s < Integer.MIN_VALUE ||\n            s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: add\");\n        }\n        return (int)s;\n    }\n    \n    \n    public Fraction add(Fraction fraction) {\n        return addSub(fraction, true );\n    }\n\n    \n    public Fraction subtract(Fraction fraction) {\n        return addSub(fraction, false );\n    }\n\n    \n    private Fraction addSub(Fraction fraction, boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        \n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        \n        \n        int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            \n            int uvp = mulAndCheck(numerator, fraction.denominator);\n            int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        \n        \n        \n        BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\n        BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);\n        \n        \n        int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        int d2 = (tmodd1==0)?d1:greatestCommonDivisor(tmodd1, d1);\n\n        \n        BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }\n\n    \n    public Fraction multiplyBy(Fraction fraction) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        if (numerator == 0 || fraction.numerator == 0) {\n            return ZERO;\n        }\n        \n        \n        int d1 = greatestCommonDivisor(numerator, fraction.denominator);\n        int d2 = greatestCommonDivisor(fraction.numerator, denominator);\n        return getReducedFraction\n            (mulAndCheck(numerator/d1, fraction.numerator/d2),\n             mulPosAndCheck(denominator/d2, fraction.denominator/d1));\n    }\n\n    \n    public Fraction divideBy(Fraction fraction) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        if (fraction.numerator == 0) {\n            throw new ArithmeticException(\"The fraction to divide by must not be zero\");\n        }\n        return multiplyBy(fraction.invert());\n    }\n\n    \n    \n\n    \n    @Override\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (obj instanceof Fraction == false) {\n            return false;\n        }\n        Fraction other = (Fraction) obj;\n        return (getNumerator() == other.getNumerator() &&\n                getDenominator() == other.getDenominator());\n    }\n\n    \n    @Override\n    public int hashCode() {\n        if (hashCode == 0) {\n            \n            hashCode = 37 * (37 * 17 + getNumerator()) + getDenominator();\n        }\n        return hashCode;\n    }\n\n    \n    public int compareTo(Fraction other) {\n        if (this==other) {\n            return 0;\n        }\n        if (numerator == other.numerator && denominator == other.denominator) {\n            return 0;\n        }\n\n        \n        long first = (long) numerator * (long) other.denominator;\n        long second = (long) other.numerator * (long) denominator;\n        if (first == second) {\n            return 0;\n        } else if (first < second) {\n            return -1;\n        } else {\n            return 1;\n        }\n    }\n\n    \n    @Override\n    public String toString() {\n        if (toString == null) {\n            toString = new StringBuilder(32)\n                .append(getNumerator())\n                .append('/')\n                .append(getDenominator()).toString();\n        }\n        return toString;\n    }\n\n    \n    public String toProperString() {\n        if (toProperString == null) {\n            if (numerator == 0) {\n                toProperString = \"0\";\n            } else if (numerator == denominator) {\n                toProperString = \"1\";\n            } else if (numerator == -1 * denominator) {\n                toProperString = \"-1\";\n            } else if ((numerator>0?-numerator:numerator) < -denominator) {\n                \n                \n                \n                \n                int properNumerator = getProperNumerator();\n                if (properNumerator == 0) {\n                    toProperString = Integer.toString(getProperWhole());\n                } else {\n                    toProperString = new StringBuilder(32)\n                        .append(getProperWhole()).append(' ')\n                        .append(properNumerator).append('/')\n                        .append(getDenominator()).toString();\n                }\n            } else {\n                toProperString = new StringBuilder(32)\n                    .append(getNumerator()).append('/')\n                    .append(getDenominator()).toString();\n            }\n        }\n        return toProperString;\n    }\n}\n",
      "buggy_signatures": [
        "public static Fraction getFraction(int numerator, int denominator)",
        "public static Fraction getFraction(int whole, int numerator, int denominator)",
        "public static Fraction getReducedFraction(int numerator, int denominator)",
        "public static Fraction getFraction(double value)",
        "public static Fraction getFraction(String str)",
        "public int getNumerator()",
        "public int getDenominator()",
        "public int getProperNumerator()",
        "public int getProperWhole()",
        "public int intValue()",
        "public long longValue()",
        "public float floatValue()",
        "public double doubleValue()",
        "public Fraction reduce()",
        "public Fraction invert()",
        "public Fraction negate()",
        "public Fraction abs()",
        "public Fraction pow(int power)",
        "private static int greatestCommonDivisor(int u, int v)",
        "private static int mulAndCheck(int x, int y)",
        "private static int mulPosAndCheck(int x, int y)",
        "private static int addAndCheck(int x, int y)",
        "private static int subAndCheck(int x, int y)",
        "public Fraction add(Fraction fraction)",
        "public Fraction subtract(Fraction fraction)",
        "private Fraction addSub(Fraction fraction, boolean isAdd)",
        "public Fraction multiplyBy(Fraction fraction)",
        "public Fraction divideBy(Fraction fraction)",
        "public boolean equals(Object obj)",
        "public int hashCode()",
        "public int compareTo(Fraction other)",
        "public String toString()",
        "public String toProperString()"
      ],
      "fixed_signatures": [
        "public static Fraction getFraction(int numerator, int denominator)",
        "public static Fraction getFraction(int whole, int numerator, int denominator)",
        "public static Fraction getReducedFraction(int numerator, int denominator)",
        "public static Fraction getFraction(double value)",
        "public static Fraction getFraction(String str)",
        "public int getNumerator()",
        "public int getDenominator()",
        "public int getProperNumerator()",
        "public int getProperWhole()",
        "public int intValue()",
        "public long longValue()",
        "public float floatValue()",
        "public double doubleValue()",
        "public Fraction reduce()",
        "public Fraction invert()",
        "public Fraction negate()",
        "public Fraction abs()",
        "public Fraction pow(int power)",
        "private static int greatestCommonDivisor(int u, int v)",
        "private static int mulAndCheck(int x, int y)",
        "private static int mulPosAndCheck(int x, int y)",
        "private static int addAndCheck(int x, int y)",
        "private static int subAndCheck(int x, int y)",
        "public Fraction add(Fraction fraction)",
        "public Fraction subtract(Fraction fraction)",
        "private Fraction addSub(Fraction fraction, boolean isAdd)",
        "public Fraction multiplyBy(Fraction fraction)",
        "public Fraction divideBy(Fraction fraction)",
        "public boolean equals(Object obj)",
        "public int hashCode()",
        "public int compareTo(Fraction other)",
        "public String toString()",
        "public String toProperString()"
      ],
      "methods": [
        {
          "buggy_method": "  private static int greatestCommonDivisor(int u, int v) {\n  \n  \n  if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n  return 1;\n  }\n  \n  \n  \n  \n  if (u>0) { u=-u; } \n  if (v>0) { v=-v; } \n  \n  int k=0;\n  while ((u&1)==0 && (v&1)==0 && k<31) { \n  u/=2; v/=2; k++; \n  }\n  if (k==31) {\n  throw new ArithmeticException(\"overflow: gcd is 2^31\");\n  }\n  \n  \n  int t = ((u&1)==1) ? v : -(u/2);\n  \n  \n  do {\n  \n  \n  while ((t&1)==0) { \n  t/=2; \n  }\n  \n  if (t>0) {\n  u = -t;\n  } else {\n  v = t;\n  }\n  \n  t = (v - u)/2;\n  \n  \n  } while (t!=0);\n  return -u*(1<<k); \n  }",
          "fixed_method": "  private static int greatestCommonDivisor(int u, int v) {\n  \n  if ((u == 0) || (v == 0)) {\n  if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n  throw new ArithmeticException(\"overflow: gcd is 2^31\");\n  }\n  return Math.abs(u) + Math.abs(v);\n  }\n  \n  if (Math.abs(u) == 1 || Math.abs(v) == 1) {\n  return 1;\n  }\n  \n  \n  \n  \n  if (u>0) { u=-u; } \n  if (v>0) { v=-v; } \n  \n  int k=0;\n  while ((u&1)==0 && (v&1)==0 && k<31) { \n  u/=2; v/=2; k++; \n  }\n  if (k==31) {\n  throw new ArithmeticException(\"overflow: gcd is 2^31\");\n  }\n  \n  \n  int t = ((u&1)==1) ? v : -(u/2);\n  \n  \n  do {\n  \n  \n  while ((t&1)==0) { \n  t/=2; \n  }\n  \n  if (t>0) {\n  u = -t;\n  } else {\n  v = t;\n  }\n  \n  t = (v - u)/2;\n  \n  \n  } while (t!=0);\n  return -u*(1<<k); \n  }",
          "diff": [
            "@@ -580,8 +580,14 @@",
            "      */\n",
            "     private static int greatestCommonDivisor(int u, int v) {\n",
            "         // From Commons Math:\n",
            "+        if ((u == 0) || (v == 0)) {\n",
            "+            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n",
            "+                throw new ArithmeticException(\"overflow: gcd is 2^31\");\n",
            "+            }\n",
            "+            return Math.abs(u) + Math.abs(v);\n",
            "+        }\n",
            "         //if either operand is abs 1, return 1:\n",
            "-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n",
            "+        if (Math.abs(u) == 1 || Math.abs(v) == 1) {\n",
            "             return 1;\n",
            "         }\n",
            "         // keep u and v negative, as negative integers range down to\n"
          ],
          "changed_lines": 8
        }
      ]
    }
  ]
}
