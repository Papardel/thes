{
  "bug_id": "30",
  "failed_tests": {
    "com.fasterxml.jackson.databind.jsontype.TestExternalId": [
      {
        "methodName": "testBigDecimal965",
        "error": "junit.framework.AssertionFailedError",
        "message": "Expected BigDecimal = -10000000000.0000000001; got back BigDecimal = -1.0E+10",
        "fail_line": "        assertTrue(String.format(\"Expected %s = %s; got back %s = %s\",",
        "test_source": "  public void testBigDecimal965() throws Exception {\n\n  Wrapper965 w = new Wrapper965();\n  w.typeEnum = Type965.BIG_DECIMAL;\n  final String NUM_STR = \"-10000000000.0000000001\";\n  w.value = new BigDecimal(NUM_STR);\n\n  String json = MAPPER.writeValueAsString(w);\n\n  // simple sanity check so serialization is faithful\n  if (!json.contains(NUM_STR)) {\n  fail(\"JSON content should contain value '\"+NUM_STR+\"', does not appear to: \"+json);\n  }\n  \n  Wrapper965 w2 = MAPPER.readerFor(Wrapper965.class)\n  .with(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)\n  .readValue(json);\n\n  assertEquals(w.typeEnum, w2.typeEnum);\n  assertTrue(String.format(\"Expected %s = %s; got back %s = %s\",\n  w.value.getClass().getSimpleName(), w.value.toString(), w2.value.getClass().getSimpleName(), w2.value.toString()),\n  w.value.equals(w2.value));\n  }",
        "stack": [
          "TestExternalId.testBigDecimal965 line 564"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/ObjectMapper.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind;\n\nimport java.io.*;\nimport java.lang.reflect.Type;\nimport java.net.URL;\nimport java.text.DateFormat;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.*;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.CharacterEscapes;\nimport com.fasterxml.jackson.core.io.SegmentedStringWriter;\nimport com.fasterxml.jackson.core.type.ResolvedType;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.core.util.*;\nimport com.fasterxml.jackson.databind.cfg.BaseSettings;\nimport com.fasterxml.jackson.databind.cfg.ContextAttributes;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.deser.*;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\nimport com.fasterxml.jackson.databind.jsontype.*;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\nimport com.fasterxml.jackson.databind.node.*;\nimport com.fasterxml.jackson.databind.ser.*;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.RootNameLookup;\nimport com.fasterxml.jackson.databind.util.StdDateFormat;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n\npublic class ObjectMapper extends ObjectCodec implements Versioned, java.io.Serializable { private static final long serialVersionUID = 1L; public enum DefaultTyping { JAVA_LANG_OBJECT, OBJECT_AND_NON_CONCRETE, NON_CONCRETE_AND_ARRAYS, NON_FINAL } public static class DefaultTypeResolverBuilder extends StdTypeResolverBuilder implements java.io.Serializable { private static final long serialVersionUID = 1L; protected final DefaultTyping _appliesFor; public DefaultTypeResolverBuilder(DefaultTyping t) {\n            _appliesFor = t;\n        }\n\n        @Override\n        public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n            return useForType(baseType) ? super.buildTypeDeserializer(config, baseType, subtypes) : null;\n        }\n\n        @Override\n        public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n            return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes) : null;            \n        }\n\n        \n        public boolean useForType(JavaType t) {\n            switch (_appliesFor) {\n            case NON_CONCRETE_AND_ARRAYS:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                \n            case OBJECT_AND_NON_CONCRETE:\n                return t.isJavaLangObject()\n                        || (!t.isConcrete()\n                                \n                                && !TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n            case NON_FINAL:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                \n                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n            default:\n            \n                return t.isJavaLangObject();\n            }\n        }\n    }\n\n    \n    \n    \n    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class); protected final static AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR = new JacksonAnnotationIntrospector(); protected final static VisibilityChecker<?> STD_VISIBILITY_CHECKER = VisibilityChecker.Std.defaultInstance(); @Deprecated protected final static PrettyPrinter _defaultPrettyPrinter = new DefaultPrettyPrinter(); protected final static BaseSettings DEFAULT_BASE = new BaseSettings( null, DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(), null, StdDateFormat.instance, null, Locale.getDefault(), null, Base64Variants.getDefaultVariant() ); protected final JsonFactory _jsonFactory; protected TypeFactory _typeFactory; protected InjectableValues _injectableValues; protected SubtypeResolver _subtypeResolver; protected SimpleMixInResolver _mixIns; protected SerializationConfig _serializationConfig; protected DefaultSerializerProvider _serializerProvider; protected SerializerFactory _serializerFactory; protected DeserializationConfig _deserializationConfig; protected DefaultDeserializationContext _deserializationContext; protected Set<Object> _registeredModuleTypes; final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.6f, 2); public ObjectMapper() {\n        this(null, null, null);\n    }\n\n    \n    public ObjectMapper(JsonFactory jf) {\n        this(jf, null, null);\n    }\n\n    \n    protected ObjectMapper(ObjectMapper src) {\n        _jsonFactory = src._jsonFactory.copy();\n        _jsonFactory.setCodec(this);\n        _subtypeResolver = src._subtypeResolver;\n        _typeFactory = src._typeFactory;\n        _injectableValues = src._injectableValues;\n\n        SimpleMixInResolver mixins = src._mixIns.copy();\n        _mixIns = mixins;\n        RootNameLookup rootNames = new RootNameLookup();\n        _serializationConfig = new SerializationConfig(src._serializationConfig, mixins, rootNames);\n        _deserializationConfig = new DeserializationConfig(src._deserializationConfig, mixins, rootNames);\n        _serializerProvider = src._serializerProvider.copy();\n        _deserializationContext = src._deserializationContext.copy();\n\n        \n        _serializerFactory = src._serializerFactory;\n\n        \n        Set<Object> reg = _registeredModuleTypes;\n        if (reg == null) {\n            _registeredModuleTypes = null;\n        } else {\n            _registeredModuleTypes = new LinkedHashSet<Object>(reg);\n        }\n    }\n\n    \n    public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc) {\n        \n        if (jf == null) {\n            _jsonFactory = new MappingJsonFactory(this);\n        } else {\n            _jsonFactory = jf;\n            if (jf.getCodec() == null) { \n                _jsonFactory.setCodec(this);\n            }\n        }\n        _subtypeResolver = new StdSubtypeResolver();\n        RootNameLookup rootNames = new RootNameLookup();\n        \n        _typeFactory = TypeFactory.defaultInstance();\n\n        SimpleMixInResolver mixins = new SimpleMixInResolver(null);\n        _mixIns = mixins;\n\n        BaseSettings base = DEFAULT_BASE.withClassIntrospector(defaultClassIntrospector());\n        _serializationConfig = new SerializationConfig(base,\n                    _subtypeResolver, mixins, rootNames);\n        _deserializationConfig = new DeserializationConfig(base,\n                    _subtypeResolver, mixins, rootNames);\n\n        \n        final boolean needOrder = _jsonFactory.requiresPropertyOrdering();\n        if (needOrder ^ _serializationConfig.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY)) {\n            configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, needOrder);\n        }\n        \n        _serializerProvider = (sp == null) ? new DefaultSerializerProvider.Impl() : sp;\n        _deserializationContext = (dc == null) ?\n                new DefaultDeserializationContext.Impl(BeanDeserializerFactory.instance) : dc;\n\n        \n        _serializerFactory = BeanSerializerFactory.instance;\n    }\n\n    \n    protected ClassIntrospector defaultClassIntrospector() {\n        return new BasicClassIntrospector();\n    }\n\n    \n    \n    \n    public ObjectMapper copy() {\n        _checkInvalidCopy(ObjectMapper.class);\n        return new ObjectMapper(this);\n    }\n\n    \n    protected void _checkInvalidCopy(Class<?> exp) {\n        if (getClass() != exp) {\n            throw new IllegalStateException(\"Failed copy(): \"+getClass().getName()\n                    +\" (version: \"+version()+\") does not override copy(); it has to\");\n        }\n    }\n\n    \n    \n    \n    protected ObjectReader _newReader(DeserializationConfig config) {\n        return new ObjectReader(this, config);\n    }\n\n    \n    protected ObjectReader _newReader(DeserializationConfig config, JavaType valueType, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues) {\n        return new ObjectReader(this, config, valueType, valueToUpdate, schema, injectableValues);\n    }\n\n    \n    protected ObjectWriter _newWriter(SerializationConfig config) {\n        return new ObjectWriter(this, config);\n    }\n\n    \n    protected ObjectWriter _newWriter(SerializationConfig config, FormatSchema schema) {\n        return new ObjectWriter(this, config, schema);\n    }\n    \n    \n    protected ObjectWriter _newWriter(SerializationConfig config, JavaType rootType, PrettyPrinter pp) {\n        return new ObjectWriter(this, config, rootType, pp);\n    }\n\n    \n    \n    \n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    \n\n    \n    public ObjectMapper registerModule(Module module) {\n        if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {\n            Object typeId = module.getTypeId();\n            if (typeId != null) {\n                if (_registeredModuleTypes == null) {\n                    \n                    \n                    _registeredModuleTypes = new LinkedHashSet<Object>();\n                }\n                \n                if (!_registeredModuleTypes.add(typeId)) {\n                    return this;\n                }\n            }\n        }\n        \n        \n        String name = module.getModuleName();\n        if (name == null) {\n            throw new IllegalArgumentException(\"Module without defined name\");\n        }\n        Version version = module.version();\n        if (version == null) {\n            throw new IllegalArgumentException(\"Module without defined version\");\n        }\n\n        final ObjectMapper mapper = this;\n        \n        \n        module.setupModule(new Module.SetupContext()\n        {\n            \n\n            @Override\n            public Version getMapperVersion() {\n                return version();\n            }\n\n            @SuppressWarnings(\"unchecked\")\n            @Override\n            public <C extends ObjectCodec> C getOwner() {\n                \n                return (C) mapper;\n            }\n\n            @Override\n            public TypeFactory getTypeFactory() {\n                return _typeFactory;\n            }\n            \n            @Override\n            public boolean isEnabled(MapperFeature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(DeserializationFeature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            @Override\n            public boolean isEnabled(SerializationFeature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(JsonFactory.Feature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(JsonParser.Feature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            @Override\n            public boolean isEnabled(JsonGenerator.Feature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            \n            \n            @Override\n            public void addDeserializers(Deserializers d) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addKeyDeserializers(KeyDeserializers d) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n            \n            \n            \n            @Override\n            public void addSerializers(Serializers s) {\n                mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);\n            }\n\n            @Override\n            public void addKeySerializers(Serializers s) {\n                mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);\n            }\n            \n            @Override\n            public void addBeanSerializerModifier(BeanSerializerModifier modifier) {\n                mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);\n            }\n\n            \n            \n            @Override\n            public void addAbstractTypeResolver(AbstractTypeResolver resolver) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addTypeModifier(TypeModifier modifier) {\n                TypeFactory f = mapper._typeFactory;\n                f = f.withModifier(modifier);\n                mapper.setTypeFactory(f);\n            }\n\n            @Override\n            public void addValueInstantiators(ValueInstantiators instantiators) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void setClassIntrospector(ClassIntrospector ci) {\n                mapper._deserializationConfig = mapper._deserializationConfig.with(ci);\n                mapper._serializationConfig = mapper._serializationConfig.with(ci);\n            }\n\n            @Override\n            public void insertAnnotationIntrospector(AnnotationIntrospector ai) {\n                mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);\n                mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);\n            }\n            \n            @Override\n            public void appendAnnotationIntrospector(AnnotationIntrospector ai) {\n                mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);\n                mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);\n            }\n\n            @Override\n            public void registerSubtypes(Class<?>... subtypes) {\n                mapper.registerSubtypes(subtypes);\n            }\n\n            @Override\n            public void registerSubtypes(NamedType... subtypes) {\n                mapper.registerSubtypes(subtypes);\n            }\n            \n            @Override\n            public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n                mapper.addMixIn(target, mixinSource);\n            }\n            \n            @Override\n            public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {\n                mapper.addHandler(handler);\n            }\n\n            @Override\n            public void setNamingStrategy(PropertyNamingStrategy naming) {\n                mapper.setPropertyNamingStrategy(naming);\n            }\n        });\n        return this;\n    }\n\n    \n    public ObjectMapper registerModules(Module... modules) {\n        for (Module module : modules) {\n            registerModule(module);\n        }\n        return this;\n    }\n\n    \n    public ObjectMapper registerModules(Iterable<com.fasterxml.jackson.databind.Module> modules) {\n        for (Module module : modules) {\n            registerModule(module);\n        }\n        return this;\n    }\n    \n    \n    public static List<com.fasterxml.jackson.databind.Module> findModules() {\n        return findModules(null);\n    }\n\n    \n    public static List<com.fasterxml.jackson.databind.Module> findModules(ClassLoader classLoader) {\n        ArrayList<com.fasterxml.jackson.databind.Module> modules = new ArrayList<Module>();\n        ServiceLoader<com.fasterxml.jackson.databind.Module> loader = (classLoader == null) ?\n                ServiceLoader.load(Module.class) : ServiceLoader.load(Module.class, classLoader);\n        for (Module module : loader) {\n            modules.add(module);\n        }\n        return modules;\n    }\n\n    \n    public ObjectMapper findAndRegisterModules() {\n        return registerModules(findModules());\n    }\n    \n    \n\n    \n    public SerializationConfig getSerializationConfig() {\n        return _serializationConfig;\n    }\n\n    \n    public DeserializationConfig getDeserializationConfig() {\n        return _deserializationConfig;\n    }\n    \n    \n    public DeserializationContext getDeserializationContext() {\n        return _deserializationContext;\n    }\n\n    \n    \n    \n    public ObjectMapper setSerializerFactory(SerializerFactory f) {\n        _serializerFactory = f;\n        return this;\n    }\n\n    \n    public SerializerFactory getSerializerFactory() {\n        return _serializerFactory;\n    }\n\n    \n    public ObjectMapper setSerializerProvider(DefaultSerializerProvider p) {\n        _serializerProvider = p;\n        return this;\n    }\n\n    public SerializerProvider getSerializerProvider() {\n        return _serializerProvider;\n    }\n\n    \n\n    \n    public ObjectMapper setMixIns(Map<Class<?>, Class<?>> sourceMixins) {\n        \n        _mixIns.setLocalDefinitions(sourceMixins);\n        return this;\n    }\n\n    \n    public ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource) {\n        _mixIns.addLocalDefinition(target, mixinSource);\n        return this;\n    }\n\n    \n    public ObjectMapper setMixInResolver(ClassIntrospector.MixInResolver resolver) {\n        SimpleMixInResolver r = _mixIns.withOverrides(resolver);\n        if (r != _mixIns) {\n            _mixIns = r;\n            _deserializationConfig = new DeserializationConfig(_deserializationConfig, r);\n            _serializationConfig = new SerializationConfig(_serializationConfig, r);\n        }\n        return this;\n    }\n    \n    public Class<?> findMixInClassFor(Class<?> cls) {\n        return _mixIns.findMixInClassFor(cls);\n    }\n\n    \n    public int mixInCount() {\n        return _mixIns.localSize();\n    }\n\n    \n    @Deprecated\n    public void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins) {\n        setMixIns(sourceMixins);\n    }\n\n    \n    @Deprecated\n    public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n        addMixIn(target, mixinSource);\n    }\n    \n    \n\n    \n    public VisibilityChecker<?> getVisibilityChecker() {\n        return _serializationConfig.getDefaultVisibilityChecker();\n    }\n\n    \n    @Deprecated\n    public void setVisibilityChecker(VisibilityChecker<?> vc) {\n        setVisibility(vc);\n    }\n\n    \n    public ObjectMapper setVisibility(VisibilityChecker<?> vc) {\n        _deserializationConfig = _deserializationConfig.with(vc);\n        _serializationConfig = _serializationConfig.with(vc);\n        return this;\n    }\n    \n    \n    public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {\n        _deserializationConfig = _deserializationConfig.withVisibility(forMethod, visibility);\n        _serializationConfig = _serializationConfig.withVisibility(forMethod, visibility);\n        return this;\n    }\n    \n    \n    public SubtypeResolver getSubtypeResolver() {\n        return _subtypeResolver;\n    }\n\n    \n    public ObjectMapper setSubtypeResolver(SubtypeResolver str) {\n        _subtypeResolver = str;\n        _deserializationConfig = _deserializationConfig.with(str);\n        _serializationConfig = _serializationConfig.with(str);\n        return this;\n    }\n\n    \n    public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai) {\n        _serializationConfig = _serializationConfig.with(ai);\n        _deserializationConfig = _deserializationConfig.with(ai);\n        return this;\n    }\n\n    \n    public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI) {\n        _serializationConfig = _serializationConfig.with(serializerAI);\n        _deserializationConfig = _deserializationConfig.with(deserializerAI);\n        return this;\n    }\n    \n    \n    public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s) {\n        _serializationConfig = _serializationConfig.with(s);\n        _deserializationConfig = _deserializationConfig.with(s);\n        return this;\n    }\n\n    \n    public PropertyNamingStrategy getPropertyNamingStrategy() {\n        \n        return _serializationConfig.getPropertyNamingStrategy();\n    }\n    \n    \n    public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) {\n        _serializationConfig = _serializationConfig.withSerializationInclusion(incl);\n        return this;\n    }\n\n    \n    public ObjectMapper setDefaultPrettyPrinter(PrettyPrinter pp) {\n        _serializationConfig = _serializationConfig.withDefaultPrettyPrinter(pp);\n        return this;\n    }\n\n    \n\n    \n    public ObjectMapper enableDefaultTyping() {\n        return enableDefaultTyping(DefaultTyping.OBJECT_AND_NON_CONCRETE);\n    }\n\n    \n    public ObjectMapper enableDefaultTyping(DefaultTyping dti) {\n        return enableDefaultTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY);\n    }\n\n    \n    public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs) {\n        \n        if (includeAs == JsonTypeInfo.As.EXTERNAL_PROPERTY) {\n            throw new IllegalArgumentException(\"Can not use includeAs of \"+includeAs);\n        }\n        \n        TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n        \n        typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n        typer = typer.inclusion(includeAs);\n        return setDefaultTyping(typer);\n    }\n\n    \n    public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName) {\n        TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n        \n        typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n        typer = typer.inclusion(JsonTypeInfo.As.PROPERTY);\n        typer = typer.typeProperty(propertyName);\n        return setDefaultTyping(typer);\n    }\n    \n    \n    public ObjectMapper disableDefaultTyping() {\n        return setDefaultTyping(null);\n    }\n\n    \n    public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer) {\n        _deserializationConfig = _deserializationConfig.with(typer);\n        _serializationConfig = _serializationConfig.with(typer);\n        return this;\n    }\n\n    \n    public void registerSubtypes(Class<?>... classes) {\n        getSubtypeResolver().registerSubtypes(classes);\n    }\n\n    \n    public void registerSubtypes(NamedType... types) {\n        getSubtypeResolver().registerSubtypes(types);\n    }\n\n    \n\n    \n    public TypeFactory getTypeFactory() {\n        return _typeFactory;\n    }\n\n    \n    public ObjectMapper setTypeFactory(TypeFactory f) {\n        _typeFactory = f;\n        _deserializationConfig = _deserializationConfig.with(f);\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n    \n    \n    public JavaType constructType(Type t) {\n        return _typeFactory.constructType(t);\n    }\n    \n    \n\n    \n    public JsonNodeFactory getNodeFactory() {\n        return _deserializationConfig.getNodeFactory();\n    }\n    \n    \n    public ObjectMapper setNodeFactory(JsonNodeFactory f) {\n        _deserializationConfig = _deserializationConfig.with(f);\n        return this;\n    }\n\n    \n    public ObjectMapper addHandler(DeserializationProblemHandler h) {\n        _deserializationConfig = _deserializationConfig.withHandler(h);\n        return this;\n    }\n\n    \n    public ObjectMapper clearProblemHandlers() {\n        _deserializationConfig = _deserializationConfig.withNoProblemHandlers();\n        return this;\n    }\n\n    \n    public ObjectMapper setConfig(DeserializationConfig config) {\n    \t_deserializationConfig = config;\n    \treturn this;\n    }\n    \n    \n\n    \n    @Deprecated\n    public void setFilters(FilterProvider filterProvider) {\n        _serializationConfig = _serializationConfig.withFilters(filterProvider);\n    }\n\n    \n    public ObjectMapper setFilterProvider(FilterProvider filterProvider) {\n        _serializationConfig = _serializationConfig.withFilters(filterProvider);\n        return this;\n    }\n\n    \n    public ObjectMapper setBase64Variant(Base64Variant v) {\n        _serializationConfig = _serializationConfig.with(v);\n        _deserializationConfig = _deserializationConfig.with(v);\n        return this;\n    }\n\n    \n    public ObjectMapper setConfig(SerializationConfig config) {\n        _serializationConfig = config;\n        return this;\n    }\n    \n    \n\n    \n    @Override\n    public JsonFactory getFactory() { return _jsonFactory; }\n    \n    \n    @Deprecated\n    @Override\n    public JsonFactory getJsonFactory() { return getFactory(); }\n\n    \n    public ObjectMapper setDateFormat(DateFormat dateFormat) {\n        _deserializationConfig = _deserializationConfig.with(dateFormat);\n        _serializationConfig = _serializationConfig.with(dateFormat);\n        return this;\n    }\n\n    \n    public DateFormat getDateFormat() {\n        \n        return _serializationConfig.getDateFormat();\n    }\n    \n    \n    public Object setHandlerInstantiator(HandlerInstantiator hi) {\n        _deserializationConfig = _deserializationConfig.with(hi);\n        _serializationConfig = _serializationConfig.with(hi);\n        return this;\n    }\n    \n    \n    public ObjectMapper setInjectableValues(InjectableValues injectableValues) {\n        _injectableValues = injectableValues;\n        return this;\n    }\n\n    \n    public InjectableValues getInjectableValues() {\n        return _injectableValues;\n    }\n\n    \n    public ObjectMapper setLocale(Locale l) {\n        _deserializationConfig = _deserializationConfig.with(l);\n        _serializationConfig = _serializationConfig.with(l);\n        return this;\n    }\n\n    \n    public ObjectMapper setTimeZone(TimeZone tz) {\n        _deserializationConfig = _deserializationConfig.with(tz);\n        _serializationConfig = _serializationConfig.with(tz);\n        return this;\n    }\n    \n    \n\n    \n    public boolean isEnabled(MapperFeature f) {\n        \n        return _serializationConfig.isEnabled(f);\n    }\n    \n    \n    public ObjectMapper configure(MapperFeature f, boolean state) {\n        _serializationConfig = state ?\n                _serializationConfig.with(f) : _serializationConfig.without(f);\n        _deserializationConfig = state ?\n                _deserializationConfig.with(f) : _deserializationConfig.without(f);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(MapperFeature... f) {\n        _deserializationConfig = _deserializationConfig.with(f);\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n\n    \n    public ObjectMapper disable(MapperFeature... f) {\n        _deserializationConfig = _deserializationConfig.without(f);\n        _serializationConfig = _serializationConfig.without(f);\n        return this;\n    }\n    \n    \n\n    \n    public boolean isEnabled(SerializationFeature f) {\n        return _serializationConfig.isEnabled(f);\n    }\n\n    \n    public ObjectMapper configure(SerializationFeature f, boolean state) {\n        _serializationConfig = state ?\n                _serializationConfig.with(f) : _serializationConfig.without(f);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(SerializationFeature f) {\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(SerializationFeature first, SerializationFeature... f) {\n        _serializationConfig = _serializationConfig.with(first, f);\n        return this;\n    }\n    \n    \n    public ObjectMapper disable(SerializationFeature f) {\n        _serializationConfig = _serializationConfig.without(f);\n        return this;\n    }\n\n    \n    public ObjectMapper disable(SerializationFeature first, SerializationFeature... f) {\n        _serializationConfig = _serializationConfig.without(first, f);\n        return this;\n    }\n    \n    \n\n    \n    public boolean isEnabled(DeserializationFeature f) {\n        return _deserializationConfig.isEnabled(f);\n    }\n\n    \n    public ObjectMapper configure(DeserializationFeature f, boolean state) {\n        _deserializationConfig = state ?\n                _deserializationConfig.with(f) : _deserializationConfig.without(f);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(DeserializationFeature feature) {\n        _deserializationConfig = _deserializationConfig.with(feature);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f) {\n        _deserializationConfig = _deserializationConfig.with(first, f);\n        return this;\n    }\n    \n    \n    public ObjectMapper disable(DeserializationFeature feature) {\n        _deserializationConfig = _deserializationConfig.without(feature);\n        return this;\n    }\n\n    \n    public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f) {\n        _deserializationConfig = _deserializationConfig.without(first, f);\n        return this;\n    }\n    \n    \n\n    public boolean isEnabled(JsonParser.Feature f) {\n        return _deserializationConfig.isEnabled(f, _jsonFactory);\n    }\n\n    \n    public ObjectMapper configure(JsonParser.Feature f, boolean state) {\n        _jsonFactory.configure(f, state);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(JsonParser.Feature... features) {\n        for (JsonParser.Feature f : features) {\n            _jsonFactory.enable(f);\n        }\n        return this;\n    }\n    \n    \n    public ObjectMapper disable(JsonParser.Feature... features) {\n        for (JsonParser.Feature f : features) {\n            _jsonFactory.disable(f);\n        }\n        return this;\n    }\n    \n    \n\n    public boolean isEnabled(JsonGenerator.Feature f) {\n        return _serializationConfig.isEnabled(f, _jsonFactory);\n    }\n\n    \n    public ObjectMapper configure(JsonGenerator.Feature f, boolean state) {\n        _jsonFactory.configure(f,  state);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(JsonGenerator.Feature... features) {\n        for (JsonGenerator.Feature f : features) {\n            _jsonFactory.enable(f);\n        }\n        return this;\n    }\n\n    \n    public ObjectMapper disable(JsonGenerator.Feature... features) {\n        for (JsonGenerator.Feature f : features) {\n            _jsonFactory.disable(f);\n        }\n        return this;\n    }\n\n    \n    \n    \n    public boolean isEnabled(JsonFactory.Feature f) {\n        return _jsonFactory.isEnabled(f);\n    }\n\n    \n\n    \n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueType));\n    } \n\n    \n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueTypeRef));\n    }\n\n    \n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public final <T> T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readValue(getDeserializationConfig(), jp, (JavaType) valueType);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readValue(getDeserializationConfig(), jp, valueType);\n    }\n    \n    \n    @Override\n    public <T extends TreeNode> T readTree(JsonParser jp) throws IOException, JsonProcessingException {\n        \n        \n        DeserializationConfig cfg = getDeserializationConfig();\n        JsonToken t = jp.getCurrentToken();\n        if (t == null) {\n            t = jp.nextToken();\n            if (t == null) {\n                return null;\n            }\n        }\n        JsonNode n = (JsonNode) _readValue(cfg, jp, JSON_NODE_TYPE);\n        if (n == null) {\n            n = getNodeFactory().nullNode();\n        }\n        @SuppressWarnings(\"unchecked\")\n        T result = (T) n;\n        return result;\n    }\n\n    \n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException {\n        return readValues(jp, (JavaType) valueType);\n    }\n\n    \n    public <T> MappingIterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException {\n        DeserializationConfig config = getDeserializationConfig();\n        DeserializationContext ctxt = createDeserializationContext(jp, config);\n        JsonDeserializer<?> deser = _findRootDeserializer(ctxt, valueType);\n        \n        return new MappingIterator<T>(valueType, jp, ctxt, deser,\n                false, null);\n    }\n\n    \n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException {\n        return readValues(jp, _typeFactory.constructType(valueType));\n    }\n\n    \n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException {\n        return readValues(jp, _typeFactory.constructType(valueTypeRef));\n    }\n    \n    \n\n    \n    public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(in), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n    public JsonNode readTree(Reader r) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(r), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n    public JsonNode readTree(String content) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n    public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n    \n    \n    public JsonNode readTree(File file) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(file), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n    public JsonNode readTree(URL source) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(source), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n\n    \n    @Override\n    public void writeValue(JsonGenerator g, Object value) throws IOException, JsonGenerationException, JsonMappingException {\n        SerializationConfig config = getSerializationConfig();\n\n        \n        \n        if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n            if (g.getPrettyPrinter() == null) {\n                g.setPrettyPrinter(config.constructDefaultPrettyPrinter());\n            }\n        }\n        if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _writeCloseableValue(g, value, config);\n        } else {\n            _serializerProvider(config).serializeValue(g, value);\n            if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                g.flush();\n            }\n        }\n    }\n\n    \n\n    @Override\n    public void writeTree(JsonGenerator jgen, TreeNode rootNode) throws IOException, JsonProcessingException {\n        SerializationConfig config = getSerializationConfig();\n        _serializerProvider(config).serializeValue(jgen, rootNode);\n        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n            jgen.flush();\n        }\n    }\n    \n    \n    public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException {\n        SerializationConfig config = getSerializationConfig();\n        _serializerProvider(config).serializeValue(jgen, rootNode);\n        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n            jgen.flush();\n        }\n    }\n    \n    \n    @Override    \n    public ObjectNode createObjectNode() {\n        return _deserializationConfig.getNodeFactory().objectNode();\n    }\n\n    \n    @Override\n    public ArrayNode createArrayNode() {\n        return _deserializationConfig.getNodeFactory().arrayNode();\n    }\n\n    \n    @Override\n    public JsonParser treeAsTokens(TreeNode n) {\n        return new TreeTraversingParser((JsonNode) n, this);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException {\n        try {\n            \n            \n            if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) {\n                return (T) n;\n            }\n            return readValue(treeAsTokens(n), valueType);\n        } catch (JsonProcessingException e) {\n            throw e;\n        } catch (IOException e) { \n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }\n\n    \n    @SuppressWarnings({ \"unchecked\", \"resource\" })\n    public <T extends JsonNode> T valueToTree(Object fromValue) throws IllegalArgumentException {\n        if (fromValue == null) return null;\n        TokenBuffer buf = new TokenBuffer(this, false);\n        JsonNode result;\n        try {\n            writeValue(buf, fromValue);\n            JsonParser jp = buf.asParser();\n            result = readTree(jp);\n            jp.close();\n        } catch (IOException e) { \n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n        return (T) result;\n    } \n    \n    \n\n    \n    public boolean canSerialize(Class<?> type) {\n        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, null);\n    }\n\n    \n    public boolean canSerialize(Class<?> type, AtomicReference<Throwable> cause) {\n        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, cause);\n    }\n    \n    \n    public boolean canDeserialize(JavaType type) {\n        return createDeserializationContext(null,\n                getDeserializationConfig()).hasValueDeserializerFor(type, null);\n    }\n\n    \n    public boolean canDeserialize(JavaType type, AtomicReference<Throwable> cause) {\n        return createDeserializationContext(null,\n                getDeserializationConfig()).hasValueDeserializerFor(type, cause);\n    }\n    \n    \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    \n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(File src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n     \n\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    \n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n     \n\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueType));\n    } \n\n    \n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueTypeRef));\n    } \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n     \n\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n     \n\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n     \n\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n     \n\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n    \n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), valueType);\n    } \n    \n    \n\n    \n    public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException {\n        _configAndWriteValue(_jsonFactory.createGenerator(resultFile, JsonEncoding.UTF8), value);\n    }\n\n    \n    public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException {\n        _configAndWriteValue(_jsonFactory.createGenerator(out, JsonEncoding.UTF8), value);\n    }\n\n    \n    public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException {\n        _configAndWriteValue(_jsonFactory.createGenerator(w), value);\n    }\n\n    \n    @SuppressWarnings(\"resource\")\n    public String writeValueAsString(Object value) throws JsonProcessingException {        \n        \n        SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());\n        try {\n            _configAndWriteValue(_jsonFactory.createGenerator(sw), value);\n        } catch (JsonProcessingException e) { \n            throw e;\n        } catch (IOException e) { \n            throw JsonMappingException.fromUnexpectedIOE(e);\n        }\n        return sw.getAndClear();\n    }\n    \n    \n    @SuppressWarnings(\"resource\")\n    public byte[] writeValueAsBytes(Object value) throws JsonProcessingException {\n        ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());\n        try {\n            _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value);\n        } catch (JsonProcessingException e) { \n            throw e;\n        } catch (IOException e) { \n            throw JsonMappingException.fromUnexpectedIOE(e);\n        }\n        byte[] result = bb.toByteArray();\n        bb.release();\n        return result;\n    }\n\n    \n\n    \n    public ObjectWriter writer() {\n        return _newWriter(getSerializationConfig());\n    }\n\n    \n    public ObjectWriter writer(SerializationFeature feature) {\n        return _newWriter(getSerializationConfig().with(feature));\n    }\n\n    \n    public ObjectWriter writer(SerializationFeature first, SerializationFeature... other) {\n        return _newWriter(getSerializationConfig().with(first, other));\n    }\n    \n    \n    public ObjectWriter writer(DateFormat df) {\n        return _newWriter(getSerializationConfig().with(df));\n    }\n    \n    \n    public ObjectWriter writerWithView(Class<?> serializationView) {\n        return _newWriter(getSerializationConfig().withView(serializationView));\n    }\n    \n    \n    public ObjectWriter writerFor(Class<?> rootType) {\n        return _newWriter(getSerializationConfig(),\n                ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n                null);\n    }\n\n    \n    public ObjectWriter writerFor(TypeReference<?> rootType) {\n        return _newWriter(getSerializationConfig(),\n                ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n                null);\n    }\n\n    \n    public ObjectWriter writerFor(JavaType rootType) {\n        return _newWriter(getSerializationConfig(), rootType, null);\n    }\n\n    \n    public ObjectWriter writer(PrettyPrinter pp) {\n        if (pp == null) { \n            pp = ObjectWriter.NULL_PRETTY_PRINTER;\n        }\n        return _newWriter(getSerializationConfig(),  null, pp);\n    }\n    \n    \n    public ObjectWriter writerWithDefaultPrettyPrinter() {\n        SerializationConfig config = getSerializationConfig();\n        return _newWriter(config,\n                 null, config.getDefaultPrettyPrinter());\n    }\n    \n    \n    public ObjectWriter writer(FilterProvider filterProvider) {\n        return _newWriter(getSerializationConfig().withFilters(filterProvider));\n    }\n    \n    \n    public ObjectWriter writer(FormatSchema schema) {\n        _verifySchemaType(schema);\n        return _newWriter(getSerializationConfig(), schema);\n    }\n\n    \n    public ObjectWriter writer(Base64Variant defaultBase64) {\n        return _newWriter(getSerializationConfig().with(defaultBase64));\n    }\n\n    \n    public ObjectWriter writer(CharacterEscapes escapes) {\n        return _newWriter(getSerializationConfig()).with(escapes);\n    }\n\n    \n    public ObjectWriter writer(ContextAttributes attrs) {\n        return _newWriter(getSerializationConfig().with(attrs));\n    }\n\n    \n    @Deprecated\n    public ObjectWriter writerWithType(Class<?> rootType) {\n        return _newWriter(getSerializationConfig(),\n                \n                ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n                null);\n    }\n\n    \n    @Deprecated\n    public ObjectWriter writerWithType(TypeReference<?> rootType) {\n        return _newWriter(getSerializationConfig(),\n                \n                ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n                null);\n    }\n\n    \n    @Deprecated\n    public ObjectWriter writerWithType(JavaType rootType) {\n        return _newWriter(getSerializationConfig(), rootType, null);\n    }\n    \n    \n\n    \n    public ObjectReader reader() {\n        return _newReader(getDeserializationConfig()).with(_injectableValues);\n    }\n\n    \n    public ObjectReader reader(DeserializationFeature feature) {\n        return _newReader(getDeserializationConfig().with(feature));\n    }\n\n    \n    public ObjectReader reader(DeserializationFeature first, DeserializationFeature... other) {\n        return _newReader(getDeserializationConfig().with(first, other));\n    }\n    \n    \n    public ObjectReader readerForUpdating(Object valueToUpdate) {\n        JavaType t = _typeFactory.constructType(valueToUpdate.getClass());\n        return _newReader(getDeserializationConfig(), t, valueToUpdate,\n                null, _injectableValues);\n    }\n\n    \n    public ObjectReader readerFor(JavaType type) {\n        return _newReader(getDeserializationConfig(), type, null,\n                null, _injectableValues);\n    }\n\n    \n    public ObjectReader readerFor(Class<?> type) {\n        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                null, _injectableValues);\n    }\n\n    \n    public ObjectReader readerFor(TypeReference<?> type) {\n        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                null, _injectableValues);\n    }\n\n    \n    public ObjectReader reader(JsonNodeFactory f) {\n        return _newReader(getDeserializationConfig()).with(f);\n    }\n\n    \n    public ObjectReader reader(FormatSchema schema) {\n        _verifySchemaType(schema);\n        return _newReader(getDeserializationConfig(), null, null,\n                schema, _injectableValues);\n    }\n\n    \n    public ObjectReader reader(InjectableValues injectableValues) {\n        return _newReader(getDeserializationConfig(), null, null,\n                null, injectableValues);\n    }\n\n    \n    public ObjectReader readerWithView(Class<?> view) {\n        return _newReader(getDeserializationConfig().withView(view));\n    }\n\n    \n    public ObjectReader reader(Base64Variant defaultBase64) {\n        return _newReader(getDeserializationConfig().with(defaultBase64));\n    }\n\n    \n    public ObjectReader reader(ContextAttributes attrs) {\n        return _newReader(getDeserializationConfig().with(attrs));\n    }\n\n    \n    @Deprecated\n    public ObjectReader reader(JavaType type) {\n        return _newReader(getDeserializationConfig(), type, null,\n                null, _injectableValues);\n    }\n\n    \n    @Deprecated\n    public ObjectReader reader(Class<?> type) {\n        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                null, _injectableValues);\n    }\n\n    \n    @Deprecated\n    public ObjectReader reader(TypeReference<?> type) {\n        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                null, _injectableValues);\n    }\n\n    \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException {\n        \n        if (fromValue == null) return null;\n        return (T) _convert(fromValue, _typeFactory.constructType(toValueType));\n    } \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException {\n        return (T) convertValue(fromValue, _typeFactory.constructType(toValueTypeRef));\n    } \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException {\n        \n        if (fromValue == null) return null;\n        return (T) _convert(fromValue, toValueType);\n    } \n\n    \n    @SuppressWarnings(\"resource\")\n    protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException {        \n        \n        \n        Class<?> targetType = toValueType.getRawClass();\n        if (targetType != Object.class\n                && !toValueType.hasGenericTypes()\n                && targetType.isAssignableFrom(fromValue.getClass())) {\n            return fromValue;\n        }\n        \n        \n        TokenBuffer buf = new TokenBuffer(this, false);\n        try {\n            \n            \n            SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);\n            \n            _serializerProvider(config).serializeValue(buf, fromValue);\n\n            \n            final JsonParser jp = buf.asParser();\n            Object result;\n            \n            final DeserializationConfig deserConfig = getDeserializationConfig();\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt);\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else { \n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);\n                \n                result = deser.deserialize(jp, ctxt);\n            }\n            jp.close();\n            return result;\n        } catch (IOException e) { \n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }\n\n    \n\n    \n    @Deprecated\n    public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException {\n        return _serializerProvider(getSerializationConfig()).generateJsonSchema(t);\n    }\n\n    \n    public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException {\n        acceptJsonFormatVisitor(_typeFactory.constructType(type), visitor);\n    }\n    \n    \n    public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException {\n        if (type == null) {\n            throw new IllegalArgumentException(\"type must be provided\");\n        }\n        _serializerProvider(getSerializationConfig()).acceptJsonFormatVisitor(type, visitor);\n    }\n    \n    \n\n    \n    protected DefaultSerializerProvider _serializerProvider(SerializationConfig config) {\n        return _serializerProvider.createInstance(config, _serializerFactory);\n    }\n    \n    \n    @Deprecated\n    protected PrettyPrinter _defaultPrettyPrinter() {\n        return _serializationConfig.constructDefaultPrettyPrinter();\n    }\n\n    \n    protected final void _configAndWriteValue(JsonGenerator g, Object value) throws IOException {\n        SerializationConfig cfg = getSerializationConfig();\n        cfg.initialize(g); \n        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _configAndWriteCloseable(g, value, cfg);\n            return;\n        }\n        boolean closed = false;\n        try {\n            _serializerProvider(cfg).serializeValue(g, value);\n            closed = true;\n            g.close();\n        } finally {\n            \n            if (!closed) {\n                \n                g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    g.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n\n    protected final void _configAndWriteValue(JsonGenerator g, Object value, Class<?> viewClass) throws IOException {\n        SerializationConfig cfg = getSerializationConfig().withView(viewClass);\n        cfg.initialize(g); \n\n        \n        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _configAndWriteCloseable(g, value, cfg);\n            return;\n        }\n        boolean closed = false;\n        try {\n            _serializerProvider(cfg).serializeValue(g, value);\n            closed = true;\n            g.close();\n        } finally {\n            if (!closed) {\n                \n                \n                g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    g.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n\n    \n    private final void _configAndWriteCloseable(JsonGenerator g, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException {\n        Closeable toClose = (Closeable) value;\n        try {\n            _serializerProvider(cfg).serializeValue(g, value);\n            JsonGenerator tmpGen = g;\n            g = null;\n            tmpGen.close();\n            Closeable tmpToClose = toClose;\n            toClose = null;\n            tmpToClose.close();\n        } finally {\n            \n            if (g != null) {\n                \n                \n                g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    g.close();\n                } catch (IOException ioe) { }\n            }\n            if (toClose != null) {\n                try {\n                    toClose.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n    \n    \n    private final void _writeCloseableValue(JsonGenerator g, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException {\n        Closeable toClose = (Closeable) value;\n        try {\n            _serializerProvider(cfg).serializeValue(g, value);\n            if (cfg.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                g.flush();\n            }\n            Closeable tmpToClose = toClose;\n            toClose = null;\n            tmpToClose.close();\n        } finally {\n            if (toClose != null) {\n                try {\n                    toClose.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n\n    \n\n    \n    protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg) {\n        return _deserializationContext.createInstance(cfg, jp, _injectableValues);\n    }\n    \n    \n    protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        \n        Object result;\n        JsonToken t = _initForReading(jp);\n        if (t == JsonToken.VALUE_NULL) {\n            \n            DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n            result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt);\n        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = null;\n        } else { \n            DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n            \n            if (cfg.useRootWrapping()) {\n                result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser);\n            } else {\n                result = deser.deserialize(jp, ctxt);\n            }\n        }\n        \n        jp.clearCurrentToken();\n        return result;\n    }\n    \n    protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        try {\n            Object result;\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                \n                DeserializationContext ctxt = createDeserializationContext(jp,\n                        getDeserializationConfig());\n                result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt);\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else {\n                DeserializationConfig cfg = getDeserializationConfig();\n                DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n                if (cfg.useRootWrapping()) {\n                    result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser);\n                } else {\n                    result = deser.deserialize(jp, ctxt);\n                }\n                ctxt.checkUnresolvedObjectId();\n            }\n            \n            jp.clearCurrentToken();\n            return result;\n        } finally {\n            try {\n                jp.close();\n            } catch (IOException ioe) { }\n        }\n    }\n    \n    \n    protected JsonToken _initForReading(JsonParser p) throws IOException {\n        _deserializationConfig.initialize(p); \n\n        \n        JsonToken t = p.getCurrentToken();\n        if (t == null) {\n            \n            t = p.nextToken();\n            if (t == null) {\n                \n                throw JsonMappingException.from(p, \"No content to map due to end-of-input\");\n            }\n        }\n        return t;\n    }\n\n    protected Object _unwrapAndDeserialize(JsonParser p, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException {\n        PropertyName expRootName = config.findRootName(rootType);\n        \n        String expSimpleName = expRootName.getSimpleName();\n        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n            throw JsonMappingException.from(p, \"Current token not START_OBJECT (needed to unwrap root name '\"\n                    +expSimpleName+\"'), but \"+p.getCurrentToken());\n        }\n        if (p.nextToken() != JsonToken.FIELD_NAME) {\n            throw JsonMappingException.from(p, \"Current token not FIELD_NAME (to contain expected root name '\"\n                    +expSimpleName+\"'), but \"+p.getCurrentToken());\n        }\n        String actualName = p.getCurrentName();\n        if (!expSimpleName.equals(actualName)) {\n            throw JsonMappingException.from(p, \"Root name '\"+actualName+\"' does not match expected ('\"\n                    +expSimpleName+\"') for type \"+rootType);\n        }\n        \n        p.nextToken();\n        Object result = deser.deserialize(p, ctxt);\n        \n        if (p.nextToken() != JsonToken.END_OBJECT) {\n            throw JsonMappingException.from(p, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n                    +expSimpleName+\"'), but \"+p.getCurrentToken());\n        }\n        return result;\n    }\n    \n    \n\n    \n    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException {\n        \n        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n        if (deser != null) {\n            return deser;\n        }\n        \n        deser = ctxt.findRootValueDeserializer(valueType);\n        if (deser == null) { \n            throw new JsonMappingException(\"Can not find a deserializer for type \"+valueType);\n        }\n        _rootDeserializers.put(valueType, deser);\n        return deser;\n    }\n\n    \n    protected void _verifySchemaType(FormatSchema schema) {\n        if (schema != null) {\n            if (!_jsonFactory.canUseSchema(schema)) {\n                    throw new IllegalArgumentException(\"Can not use FormatSchema of type \"+schema.getClass().getName()\n                            +\" for format \"+_jsonFactory.getFormatName());\n            }\n        }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind;\n\nimport java.io.*;\nimport java.lang.reflect.Type;\nimport java.net.URL;\nimport java.text.DateFormat;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.*;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.CharacterEscapes;\nimport com.fasterxml.jackson.core.io.SegmentedStringWriter;\nimport com.fasterxml.jackson.core.type.ResolvedType;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.core.util.*;\nimport com.fasterxml.jackson.databind.cfg.BaseSettings;\nimport com.fasterxml.jackson.databind.cfg.ContextAttributes;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.deser.*;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\nimport com.fasterxml.jackson.databind.jsontype.*;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\nimport com.fasterxml.jackson.databind.node.*;\nimport com.fasterxml.jackson.databind.ser.*;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.RootNameLookup;\nimport com.fasterxml.jackson.databind.util.StdDateFormat;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n\npublic class ObjectMapper extends ObjectCodec implements Versioned, java.io.Serializable { private static final long serialVersionUID = 1L; public enum DefaultTyping { JAVA_LANG_OBJECT, OBJECT_AND_NON_CONCRETE, NON_CONCRETE_AND_ARRAYS, NON_FINAL } public static class DefaultTypeResolverBuilder extends StdTypeResolverBuilder implements java.io.Serializable { private static final long serialVersionUID = 1L; protected final DefaultTyping _appliesFor; public DefaultTypeResolverBuilder(DefaultTyping t) {\n            _appliesFor = t;\n        }\n\n        @Override\n        public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n            return useForType(baseType) ? super.buildTypeDeserializer(config, baseType, subtypes) : null;\n        }\n\n        @Override\n        public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n            return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes) : null;            \n        }\n\n        \n        public boolean useForType(JavaType t) {\n            switch (_appliesFor) {\n            case NON_CONCRETE_AND_ARRAYS:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                \n            case OBJECT_AND_NON_CONCRETE:\n                return t.isJavaLangObject()\n                        || (!t.isConcrete()\n                                \n                                && !TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n            case NON_FINAL:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                \n                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n            default:\n            \n                return t.isJavaLangObject();\n            }\n        }\n    }\n\n    \n    \n    \n    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class); protected final static AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR = new JacksonAnnotationIntrospector(); protected final static VisibilityChecker<?> STD_VISIBILITY_CHECKER = VisibilityChecker.Std.defaultInstance(); @Deprecated protected final static PrettyPrinter _defaultPrettyPrinter = new DefaultPrettyPrinter(); protected final static BaseSettings DEFAULT_BASE = new BaseSettings( null, DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(), null, StdDateFormat.instance, null, Locale.getDefault(), null, Base64Variants.getDefaultVariant() ); protected final JsonFactory _jsonFactory; protected TypeFactory _typeFactory; protected InjectableValues _injectableValues; protected SubtypeResolver _subtypeResolver; protected SimpleMixInResolver _mixIns; protected SerializationConfig _serializationConfig; protected DefaultSerializerProvider _serializerProvider; protected SerializerFactory _serializerFactory; protected DeserializationConfig _deserializationConfig; protected DefaultDeserializationContext _deserializationContext; protected Set<Object> _registeredModuleTypes; final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.6f, 2); public ObjectMapper() {\n        this(null, null, null);\n    }\n\n    \n    public ObjectMapper(JsonFactory jf) {\n        this(jf, null, null);\n    }\n\n    \n    protected ObjectMapper(ObjectMapper src) {\n        _jsonFactory = src._jsonFactory.copy();\n        _jsonFactory.setCodec(this);\n        _subtypeResolver = src._subtypeResolver;\n        _typeFactory = src._typeFactory;\n        _injectableValues = src._injectableValues;\n\n        SimpleMixInResolver mixins = src._mixIns.copy();\n        _mixIns = mixins;\n        RootNameLookup rootNames = new RootNameLookup();\n        _serializationConfig = new SerializationConfig(src._serializationConfig, mixins, rootNames);\n        _deserializationConfig = new DeserializationConfig(src._deserializationConfig, mixins, rootNames);\n        _serializerProvider = src._serializerProvider.copy();\n        _deserializationContext = src._deserializationContext.copy();\n\n        \n        _serializerFactory = src._serializerFactory;\n\n        \n        Set<Object> reg = _registeredModuleTypes;\n        if (reg == null) {\n            _registeredModuleTypes = null;\n        } else {\n            _registeredModuleTypes = new LinkedHashSet<Object>(reg);\n        }\n    }\n\n    \n    public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc) {\n        \n        if (jf == null) {\n            _jsonFactory = new MappingJsonFactory(this);\n        } else {\n            _jsonFactory = jf;\n            if (jf.getCodec() == null) { \n                _jsonFactory.setCodec(this);\n            }\n        }\n        _subtypeResolver = new StdSubtypeResolver();\n        RootNameLookup rootNames = new RootNameLookup();\n        \n        _typeFactory = TypeFactory.defaultInstance();\n\n        SimpleMixInResolver mixins = new SimpleMixInResolver(null);\n        _mixIns = mixins;\n\n        BaseSettings base = DEFAULT_BASE.withClassIntrospector(defaultClassIntrospector());\n        _serializationConfig = new SerializationConfig(base,\n                    _subtypeResolver, mixins, rootNames);\n        _deserializationConfig = new DeserializationConfig(base,\n                    _subtypeResolver, mixins, rootNames);\n\n        \n        final boolean needOrder = _jsonFactory.requiresPropertyOrdering();\n        if (needOrder ^ _serializationConfig.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY)) {\n            configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, needOrder);\n        }\n        \n        _serializerProvider = (sp == null) ? new DefaultSerializerProvider.Impl() : sp;\n        _deserializationContext = (dc == null) ?\n                new DefaultDeserializationContext.Impl(BeanDeserializerFactory.instance) : dc;\n\n        \n        _serializerFactory = BeanSerializerFactory.instance;\n    }\n\n    \n    protected ClassIntrospector defaultClassIntrospector() {\n        return new BasicClassIntrospector();\n    }\n\n    \n    \n    \n    public ObjectMapper copy() {\n        _checkInvalidCopy(ObjectMapper.class);\n        return new ObjectMapper(this);\n    }\n\n    \n    protected void _checkInvalidCopy(Class<?> exp) {\n        if (getClass() != exp) {\n            throw new IllegalStateException(\"Failed copy(): \"+getClass().getName()\n                    +\" (version: \"+version()+\") does not override copy(); it has to\");\n        }\n    }\n\n    \n    \n    \n    protected ObjectReader _newReader(DeserializationConfig config) {\n        return new ObjectReader(this, config);\n    }\n\n    \n    protected ObjectReader _newReader(DeserializationConfig config, JavaType valueType, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues) {\n        return new ObjectReader(this, config, valueType, valueToUpdate, schema, injectableValues);\n    }\n\n    \n    protected ObjectWriter _newWriter(SerializationConfig config) {\n        return new ObjectWriter(this, config);\n    }\n\n    \n    protected ObjectWriter _newWriter(SerializationConfig config, FormatSchema schema) {\n        return new ObjectWriter(this, config, schema);\n    }\n    \n    \n    protected ObjectWriter _newWriter(SerializationConfig config, JavaType rootType, PrettyPrinter pp) {\n        return new ObjectWriter(this, config, rootType, pp);\n    }\n\n    \n    \n    \n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    \n\n    \n    public ObjectMapper registerModule(Module module) {\n        if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {\n            Object typeId = module.getTypeId();\n            if (typeId != null) {\n                if (_registeredModuleTypes == null) {\n                    \n                    \n                    _registeredModuleTypes = new LinkedHashSet<Object>();\n                }\n                \n                if (!_registeredModuleTypes.add(typeId)) {\n                    return this;\n                }\n            }\n        }\n        \n        \n        String name = module.getModuleName();\n        if (name == null) {\n            throw new IllegalArgumentException(\"Module without defined name\");\n        }\n        Version version = module.version();\n        if (version == null) {\n            throw new IllegalArgumentException(\"Module without defined version\");\n        }\n\n        final ObjectMapper mapper = this;\n        \n        \n        module.setupModule(new Module.SetupContext()\n        {\n            \n\n            @Override\n            public Version getMapperVersion() {\n                return version();\n            }\n\n            @SuppressWarnings(\"unchecked\")\n            @Override\n            public <C extends ObjectCodec> C getOwner() {\n                \n                return (C) mapper;\n            }\n\n            @Override\n            public TypeFactory getTypeFactory() {\n                return _typeFactory;\n            }\n            \n            @Override\n            public boolean isEnabled(MapperFeature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(DeserializationFeature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            @Override\n            public boolean isEnabled(SerializationFeature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(JsonFactory.Feature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(JsonParser.Feature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            @Override\n            public boolean isEnabled(JsonGenerator.Feature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            \n            \n            @Override\n            public void addDeserializers(Deserializers d) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addKeyDeserializers(KeyDeserializers d) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n            \n            \n            \n            @Override\n            public void addSerializers(Serializers s) {\n                mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);\n            }\n\n            @Override\n            public void addKeySerializers(Serializers s) {\n                mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);\n            }\n            \n            @Override\n            public void addBeanSerializerModifier(BeanSerializerModifier modifier) {\n                mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);\n            }\n\n            \n            \n            @Override\n            public void addAbstractTypeResolver(AbstractTypeResolver resolver) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addTypeModifier(TypeModifier modifier) {\n                TypeFactory f = mapper._typeFactory;\n                f = f.withModifier(modifier);\n                mapper.setTypeFactory(f);\n            }\n\n            @Override\n            public void addValueInstantiators(ValueInstantiators instantiators) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void setClassIntrospector(ClassIntrospector ci) {\n                mapper._deserializationConfig = mapper._deserializationConfig.with(ci);\n                mapper._serializationConfig = mapper._serializationConfig.with(ci);\n            }\n\n            @Override\n            public void insertAnnotationIntrospector(AnnotationIntrospector ai) {\n                mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);\n                mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);\n            }\n            \n            @Override\n            public void appendAnnotationIntrospector(AnnotationIntrospector ai) {\n                mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);\n                mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);\n            }\n\n            @Override\n            public void registerSubtypes(Class<?>... subtypes) {\n                mapper.registerSubtypes(subtypes);\n            }\n\n            @Override\n            public void registerSubtypes(NamedType... subtypes) {\n                mapper.registerSubtypes(subtypes);\n            }\n            \n            @Override\n            public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n                mapper.addMixIn(target, mixinSource);\n            }\n            \n            @Override\n            public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {\n                mapper.addHandler(handler);\n            }\n\n            @Override\n            public void setNamingStrategy(PropertyNamingStrategy naming) {\n                mapper.setPropertyNamingStrategy(naming);\n            }\n        });\n        return this;\n    }\n\n    \n    public ObjectMapper registerModules(Module... modules) {\n        for (Module module : modules) {\n            registerModule(module);\n        }\n        return this;\n    }\n\n    \n    public ObjectMapper registerModules(Iterable<com.fasterxml.jackson.databind.Module> modules) {\n        for (Module module : modules) {\n            registerModule(module);\n        }\n        return this;\n    }\n    \n    \n    public static List<com.fasterxml.jackson.databind.Module> findModules() {\n        return findModules(null);\n    }\n\n    \n    public static List<com.fasterxml.jackson.databind.Module> findModules(ClassLoader classLoader) {\n        ArrayList<com.fasterxml.jackson.databind.Module> modules = new ArrayList<Module>();\n        ServiceLoader<com.fasterxml.jackson.databind.Module> loader = (classLoader == null) ?\n                ServiceLoader.load(Module.class) : ServiceLoader.load(Module.class, classLoader);\n        for (Module module : loader) {\n            modules.add(module);\n        }\n        return modules;\n    }\n\n    \n    public ObjectMapper findAndRegisterModules() {\n        return registerModules(findModules());\n    }\n    \n    \n\n    \n    public SerializationConfig getSerializationConfig() {\n        return _serializationConfig;\n    }\n\n    \n    public DeserializationConfig getDeserializationConfig() {\n        return _deserializationConfig;\n    }\n    \n    \n    public DeserializationContext getDeserializationContext() {\n        return _deserializationContext;\n    }\n\n    \n    \n    \n    public ObjectMapper setSerializerFactory(SerializerFactory f) {\n        _serializerFactory = f;\n        return this;\n    }\n\n    \n    public SerializerFactory getSerializerFactory() {\n        return _serializerFactory;\n    }\n\n    \n    public ObjectMapper setSerializerProvider(DefaultSerializerProvider p) {\n        _serializerProvider = p;\n        return this;\n    }\n\n    public SerializerProvider getSerializerProvider() {\n        return _serializerProvider;\n    }\n\n    \n\n    \n    public ObjectMapper setMixIns(Map<Class<?>, Class<?>> sourceMixins) {\n        \n        _mixIns.setLocalDefinitions(sourceMixins);\n        return this;\n    }\n\n    \n    public ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource) {\n        _mixIns.addLocalDefinition(target, mixinSource);\n        return this;\n    }\n\n    \n    public ObjectMapper setMixInResolver(ClassIntrospector.MixInResolver resolver) {\n        SimpleMixInResolver r = _mixIns.withOverrides(resolver);\n        if (r != _mixIns) {\n            _mixIns = r;\n            _deserializationConfig = new DeserializationConfig(_deserializationConfig, r);\n            _serializationConfig = new SerializationConfig(_serializationConfig, r);\n        }\n        return this;\n    }\n    \n    public Class<?> findMixInClassFor(Class<?> cls) {\n        return _mixIns.findMixInClassFor(cls);\n    }\n\n    \n    public int mixInCount() {\n        return _mixIns.localSize();\n    }\n\n    \n    @Deprecated\n    public void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins) {\n        setMixIns(sourceMixins);\n    }\n\n    \n    @Deprecated\n    public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n        addMixIn(target, mixinSource);\n    }\n    \n    \n\n    \n    public VisibilityChecker<?> getVisibilityChecker() {\n        return _serializationConfig.getDefaultVisibilityChecker();\n    }\n\n    \n    @Deprecated\n    public void setVisibilityChecker(VisibilityChecker<?> vc) {\n        setVisibility(vc);\n    }\n\n    \n    public ObjectMapper setVisibility(VisibilityChecker<?> vc) {\n        _deserializationConfig = _deserializationConfig.with(vc);\n        _serializationConfig = _serializationConfig.with(vc);\n        return this;\n    }\n    \n    \n    public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {\n        _deserializationConfig = _deserializationConfig.withVisibility(forMethod, visibility);\n        _serializationConfig = _serializationConfig.withVisibility(forMethod, visibility);\n        return this;\n    }\n    \n    \n    public SubtypeResolver getSubtypeResolver() {\n        return _subtypeResolver;\n    }\n\n    \n    public ObjectMapper setSubtypeResolver(SubtypeResolver str) {\n        _subtypeResolver = str;\n        _deserializationConfig = _deserializationConfig.with(str);\n        _serializationConfig = _serializationConfig.with(str);\n        return this;\n    }\n\n    \n    public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai) {\n        _serializationConfig = _serializationConfig.with(ai);\n        _deserializationConfig = _deserializationConfig.with(ai);\n        return this;\n    }\n\n    \n    public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI) {\n        _serializationConfig = _serializationConfig.with(serializerAI);\n        _deserializationConfig = _deserializationConfig.with(deserializerAI);\n        return this;\n    }\n    \n    \n    public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s) {\n        _serializationConfig = _serializationConfig.with(s);\n        _deserializationConfig = _deserializationConfig.with(s);\n        return this;\n    }\n\n    \n    public PropertyNamingStrategy getPropertyNamingStrategy() {\n        \n        return _serializationConfig.getPropertyNamingStrategy();\n    }\n    \n    \n    public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) {\n        _serializationConfig = _serializationConfig.withSerializationInclusion(incl);\n        return this;\n    }\n\n    \n    public ObjectMapper setDefaultPrettyPrinter(PrettyPrinter pp) {\n        _serializationConfig = _serializationConfig.withDefaultPrettyPrinter(pp);\n        return this;\n    }\n\n    \n\n    \n    public ObjectMapper enableDefaultTyping() {\n        return enableDefaultTyping(DefaultTyping.OBJECT_AND_NON_CONCRETE);\n    }\n\n    \n    public ObjectMapper enableDefaultTyping(DefaultTyping dti) {\n        return enableDefaultTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY);\n    }\n\n    \n    public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs) {\n        \n        if (includeAs == JsonTypeInfo.As.EXTERNAL_PROPERTY) {\n            throw new IllegalArgumentException(\"Can not use includeAs of \"+includeAs);\n        }\n        \n        TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n        \n        typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n        typer = typer.inclusion(includeAs);\n        return setDefaultTyping(typer);\n    }\n\n    \n    public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName) {\n        TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n        \n        typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n        typer = typer.inclusion(JsonTypeInfo.As.PROPERTY);\n        typer = typer.typeProperty(propertyName);\n        return setDefaultTyping(typer);\n    }\n    \n    \n    public ObjectMapper disableDefaultTyping() {\n        return setDefaultTyping(null);\n    }\n\n    \n    public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer) {\n        _deserializationConfig = _deserializationConfig.with(typer);\n        _serializationConfig = _serializationConfig.with(typer);\n        return this;\n    }\n\n    \n    public void registerSubtypes(Class<?>... classes) {\n        getSubtypeResolver().registerSubtypes(classes);\n    }\n\n    \n    public void registerSubtypes(NamedType... types) {\n        getSubtypeResolver().registerSubtypes(types);\n    }\n\n    \n\n    \n    public TypeFactory getTypeFactory() {\n        return _typeFactory;\n    }\n\n    \n    public ObjectMapper setTypeFactory(TypeFactory f) {\n        _typeFactory = f;\n        _deserializationConfig = _deserializationConfig.with(f);\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n    \n    \n    public JavaType constructType(Type t) {\n        return _typeFactory.constructType(t);\n    }\n    \n    \n\n    \n    public JsonNodeFactory getNodeFactory() {\n        return _deserializationConfig.getNodeFactory();\n    }\n    \n    \n    public ObjectMapper setNodeFactory(JsonNodeFactory f) {\n        _deserializationConfig = _deserializationConfig.with(f);\n        return this;\n    }\n\n    \n    public ObjectMapper addHandler(DeserializationProblemHandler h) {\n        _deserializationConfig = _deserializationConfig.withHandler(h);\n        return this;\n    }\n\n    \n    public ObjectMapper clearProblemHandlers() {\n        _deserializationConfig = _deserializationConfig.withNoProblemHandlers();\n        return this;\n    }\n\n    \n    public ObjectMapper setConfig(DeserializationConfig config) {\n    \t_deserializationConfig = config;\n    \treturn this;\n    }\n    \n    \n\n    \n    @Deprecated\n    public void setFilters(FilterProvider filterProvider) {\n        _serializationConfig = _serializationConfig.withFilters(filterProvider);\n    }\n\n    \n    public ObjectMapper setFilterProvider(FilterProvider filterProvider) {\n        _serializationConfig = _serializationConfig.withFilters(filterProvider);\n        return this;\n    }\n\n    \n    public ObjectMapper setBase64Variant(Base64Variant v) {\n        _serializationConfig = _serializationConfig.with(v);\n        _deserializationConfig = _deserializationConfig.with(v);\n        return this;\n    }\n\n    \n    public ObjectMapper setConfig(SerializationConfig config) {\n        _serializationConfig = config;\n        return this;\n    }\n    \n    \n\n    \n    @Override\n    public JsonFactory getFactory() { return _jsonFactory; }\n    \n    \n    @Deprecated\n    @Override\n    public JsonFactory getJsonFactory() { return getFactory(); }\n\n    \n    public ObjectMapper setDateFormat(DateFormat dateFormat) {\n        _deserializationConfig = _deserializationConfig.with(dateFormat);\n        _serializationConfig = _serializationConfig.with(dateFormat);\n        return this;\n    }\n\n    \n    public DateFormat getDateFormat() {\n        \n        return _serializationConfig.getDateFormat();\n    }\n    \n    \n    public Object setHandlerInstantiator(HandlerInstantiator hi) {\n        _deserializationConfig = _deserializationConfig.with(hi);\n        _serializationConfig = _serializationConfig.with(hi);\n        return this;\n    }\n    \n    \n    public ObjectMapper setInjectableValues(InjectableValues injectableValues) {\n        _injectableValues = injectableValues;\n        return this;\n    }\n\n    \n    public InjectableValues getInjectableValues() {\n        return _injectableValues;\n    }\n\n    \n    public ObjectMapper setLocale(Locale l) {\n        _deserializationConfig = _deserializationConfig.with(l);\n        _serializationConfig = _serializationConfig.with(l);\n        return this;\n    }\n\n    \n    public ObjectMapper setTimeZone(TimeZone tz) {\n        _deserializationConfig = _deserializationConfig.with(tz);\n        _serializationConfig = _serializationConfig.with(tz);\n        return this;\n    }\n    \n    \n\n    \n    public boolean isEnabled(MapperFeature f) {\n        \n        return _serializationConfig.isEnabled(f);\n    }\n    \n    \n    public ObjectMapper configure(MapperFeature f, boolean state) {\n        _serializationConfig = state ?\n                _serializationConfig.with(f) : _serializationConfig.without(f);\n        _deserializationConfig = state ?\n                _deserializationConfig.with(f) : _deserializationConfig.without(f);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(MapperFeature... f) {\n        _deserializationConfig = _deserializationConfig.with(f);\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n\n    \n    public ObjectMapper disable(MapperFeature... f) {\n        _deserializationConfig = _deserializationConfig.without(f);\n        _serializationConfig = _serializationConfig.without(f);\n        return this;\n    }\n    \n    \n\n    \n    public boolean isEnabled(SerializationFeature f) {\n        return _serializationConfig.isEnabled(f);\n    }\n\n    \n    public ObjectMapper configure(SerializationFeature f, boolean state) {\n        _serializationConfig = state ?\n                _serializationConfig.with(f) : _serializationConfig.without(f);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(SerializationFeature f) {\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(SerializationFeature first, SerializationFeature... f) {\n        _serializationConfig = _serializationConfig.with(first, f);\n        return this;\n    }\n    \n    \n    public ObjectMapper disable(SerializationFeature f) {\n        _serializationConfig = _serializationConfig.without(f);\n        return this;\n    }\n\n    \n    public ObjectMapper disable(SerializationFeature first, SerializationFeature... f) {\n        _serializationConfig = _serializationConfig.without(first, f);\n        return this;\n    }\n    \n    \n\n    \n    public boolean isEnabled(DeserializationFeature f) {\n        return _deserializationConfig.isEnabled(f);\n    }\n\n    \n    public ObjectMapper configure(DeserializationFeature f, boolean state) {\n        _deserializationConfig = state ?\n                _deserializationConfig.with(f) : _deserializationConfig.without(f);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(DeserializationFeature feature) {\n        _deserializationConfig = _deserializationConfig.with(feature);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f) {\n        _deserializationConfig = _deserializationConfig.with(first, f);\n        return this;\n    }\n    \n    \n    public ObjectMapper disable(DeserializationFeature feature) {\n        _deserializationConfig = _deserializationConfig.without(feature);\n        return this;\n    }\n\n    \n    public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f) {\n        _deserializationConfig = _deserializationConfig.without(first, f);\n        return this;\n    }\n    \n    \n\n    public boolean isEnabled(JsonParser.Feature f) {\n        return _deserializationConfig.isEnabled(f, _jsonFactory);\n    }\n\n    \n    public ObjectMapper configure(JsonParser.Feature f, boolean state) {\n        _jsonFactory.configure(f, state);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(JsonParser.Feature... features) {\n        for (JsonParser.Feature f : features) {\n            _jsonFactory.enable(f);\n        }\n        return this;\n    }\n    \n    \n    public ObjectMapper disable(JsonParser.Feature... features) {\n        for (JsonParser.Feature f : features) {\n            _jsonFactory.disable(f);\n        }\n        return this;\n    }\n    \n    \n\n    public boolean isEnabled(JsonGenerator.Feature f) {\n        return _serializationConfig.isEnabled(f, _jsonFactory);\n    }\n\n    \n    public ObjectMapper configure(JsonGenerator.Feature f, boolean state) {\n        _jsonFactory.configure(f,  state);\n        return this;\n    }\n\n    \n    public ObjectMapper enable(JsonGenerator.Feature... features) {\n        for (JsonGenerator.Feature f : features) {\n            _jsonFactory.enable(f);\n        }\n        return this;\n    }\n\n    \n    public ObjectMapper disable(JsonGenerator.Feature... features) {\n        for (JsonGenerator.Feature f : features) {\n            _jsonFactory.disable(f);\n        }\n        return this;\n    }\n\n    \n    \n    \n    public boolean isEnabled(JsonFactory.Feature f) {\n        return _jsonFactory.isEnabled(f);\n    }\n\n    \n\n    \n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueType));\n    } \n\n    \n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueTypeRef));\n    }\n\n    \n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public final <T> T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readValue(getDeserializationConfig(), jp, (JavaType) valueType);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readValue(getDeserializationConfig(), jp, valueType);\n    }\n    \n    \n    @Override\n    public <T extends TreeNode> T readTree(JsonParser jp) throws IOException, JsonProcessingException {\n        \n        \n        DeserializationConfig cfg = getDeserializationConfig();\n        JsonToken t = jp.getCurrentToken();\n        if (t == null) {\n            t = jp.nextToken();\n            if (t == null) {\n                return null;\n            }\n        }\n        JsonNode n = (JsonNode) _readValue(cfg, jp, JSON_NODE_TYPE);\n        if (n == null) {\n            n = getNodeFactory().nullNode();\n        }\n        @SuppressWarnings(\"unchecked\")\n        T result = (T) n;\n        return result;\n    }\n\n    \n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException {\n        return readValues(jp, (JavaType) valueType);\n    }\n\n    \n    public <T> MappingIterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException {\n        DeserializationConfig config = getDeserializationConfig();\n        DeserializationContext ctxt = createDeserializationContext(jp, config);\n        JsonDeserializer<?> deser = _findRootDeserializer(ctxt, valueType);\n        \n        return new MappingIterator<T>(valueType, jp, ctxt, deser,\n                false, null);\n    }\n\n    \n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException {\n        return readValues(jp, _typeFactory.constructType(valueType));\n    }\n\n    \n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException {\n        return readValues(jp, _typeFactory.constructType(valueTypeRef));\n    }\n    \n    \n\n    \n    public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(in), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n    public JsonNode readTree(Reader r) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(r), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n    public JsonNode readTree(String content) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n    public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n    \n    \n    public JsonNode readTree(File file) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(file), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n    public JsonNode readTree(URL source) throws IOException, JsonProcessingException {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(source), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    \n\n    \n    @Override\n    public void writeValue(JsonGenerator g, Object value) throws IOException, JsonGenerationException, JsonMappingException {\n        SerializationConfig config = getSerializationConfig();\n\n        \n        \n        if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n            if (g.getPrettyPrinter() == null) {\n                g.setPrettyPrinter(config.constructDefaultPrettyPrinter());\n            }\n        }\n        if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _writeCloseableValue(g, value, config);\n        } else {\n            _serializerProvider(config).serializeValue(g, value);\n            if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                g.flush();\n            }\n        }\n    }\n\n    \n\n    @Override\n    public void writeTree(JsonGenerator jgen, TreeNode rootNode) throws IOException, JsonProcessingException {\n        SerializationConfig config = getSerializationConfig();\n        _serializerProvider(config).serializeValue(jgen, rootNode);\n        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n            jgen.flush();\n        }\n    }\n    \n    \n    public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException {\n        SerializationConfig config = getSerializationConfig();\n        _serializerProvider(config).serializeValue(jgen, rootNode);\n        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n            jgen.flush();\n        }\n    }\n    \n    \n    @Override    \n    public ObjectNode createObjectNode() {\n        return _deserializationConfig.getNodeFactory().objectNode();\n    }\n\n    \n    @Override\n    public ArrayNode createArrayNode() {\n        return _deserializationConfig.getNodeFactory().arrayNode();\n    }\n\n    \n    @Override\n    public JsonParser treeAsTokens(TreeNode n) {\n        return new TreeTraversingParser((JsonNode) n, this);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException {\n        try {\n            \n            \n            if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) {\n                return (T) n;\n            }\n            return readValue(treeAsTokens(n), valueType);\n        } catch (JsonProcessingException e) {\n            throw e;\n        } catch (IOException e) { \n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }\n\n    \n    @SuppressWarnings({ \"unchecked\", \"resource\" })\n    public <T extends JsonNode> T valueToTree(Object fromValue) throws IllegalArgumentException {\n        if (fromValue == null) return null;\n        TokenBuffer buf = new TokenBuffer(this, false);\n        if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n            buf = buf.forceUseOfBigDecimal(true);\n        }\n        JsonNode result;\n        try {\n            writeValue(buf, fromValue);\n            JsonParser jp = buf.asParser();\n            result = readTree(jp);\n            jp.close();\n        } catch (IOException e) { \n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n        return (T) result;\n    } \n    \n    \n\n    \n    public boolean canSerialize(Class<?> type) {\n        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, null);\n    }\n\n    \n    public boolean canSerialize(Class<?> type, AtomicReference<Throwable> cause) {\n        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, cause);\n    }\n    \n    \n    public boolean canDeserialize(JavaType type) {\n        return createDeserializationContext(null,\n                getDeserializationConfig()).hasValueDeserializerFor(type, null);\n    }\n\n    \n    public boolean canDeserialize(JavaType type, AtomicReference<Throwable> cause) {\n        return createDeserializationContext(null,\n                getDeserializationConfig()).hasValueDeserializerFor(type, cause);\n    }\n    \n    \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    \n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(File src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n     \n\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    \n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n     \n\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueType));\n    } \n\n    \n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueTypeRef));\n    } \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n     \n\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n     \n\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n     \n\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException {\n     \n\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n    \n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), valueType);\n    } \n    \n    \n\n    \n    public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException {\n        _configAndWriteValue(_jsonFactory.createGenerator(resultFile, JsonEncoding.UTF8), value);\n    }\n\n    \n    public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException {\n        _configAndWriteValue(_jsonFactory.createGenerator(out, JsonEncoding.UTF8), value);\n    }\n\n    \n    public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException {\n        _configAndWriteValue(_jsonFactory.createGenerator(w), value);\n    }\n\n    \n    @SuppressWarnings(\"resource\")\n    public String writeValueAsString(Object value) throws JsonProcessingException {        \n        \n        SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());\n        try {\n            _configAndWriteValue(_jsonFactory.createGenerator(sw), value);\n        } catch (JsonProcessingException e) { \n            throw e;\n        } catch (IOException e) { \n            throw JsonMappingException.fromUnexpectedIOE(e);\n        }\n        return sw.getAndClear();\n    }\n    \n    \n    @SuppressWarnings(\"resource\")\n    public byte[] writeValueAsBytes(Object value) throws JsonProcessingException {\n        ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());\n        try {\n            _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value);\n        } catch (JsonProcessingException e) { \n            throw e;\n        } catch (IOException e) { \n            throw JsonMappingException.fromUnexpectedIOE(e);\n        }\n        byte[] result = bb.toByteArray();\n        bb.release();\n        return result;\n    }\n\n    \n\n    \n    public ObjectWriter writer() {\n        return _newWriter(getSerializationConfig());\n    }\n\n    \n    public ObjectWriter writer(SerializationFeature feature) {\n        return _newWriter(getSerializationConfig().with(feature));\n    }\n\n    \n    public ObjectWriter writer(SerializationFeature first, SerializationFeature... other) {\n        return _newWriter(getSerializationConfig().with(first, other));\n    }\n    \n    \n    public ObjectWriter writer(DateFormat df) {\n        return _newWriter(getSerializationConfig().with(df));\n    }\n    \n    \n    public ObjectWriter writerWithView(Class<?> serializationView) {\n        return _newWriter(getSerializationConfig().withView(serializationView));\n    }\n    \n    \n    public ObjectWriter writerFor(Class<?> rootType) {\n        return _newWriter(getSerializationConfig(),\n                ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n                null);\n    }\n\n    \n    public ObjectWriter writerFor(TypeReference<?> rootType) {\n        return _newWriter(getSerializationConfig(),\n                ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n                null);\n    }\n\n    \n    public ObjectWriter writerFor(JavaType rootType) {\n        return _newWriter(getSerializationConfig(), rootType, null);\n    }\n\n    \n    public ObjectWriter writer(PrettyPrinter pp) {\n        if (pp == null) { \n            pp = ObjectWriter.NULL_PRETTY_PRINTER;\n        }\n        return _newWriter(getSerializationConfig(),  null, pp);\n    }\n    \n    \n    public ObjectWriter writerWithDefaultPrettyPrinter() {\n        SerializationConfig config = getSerializationConfig();\n        return _newWriter(config,\n                 null, config.getDefaultPrettyPrinter());\n    }\n    \n    \n    public ObjectWriter writer(FilterProvider filterProvider) {\n        return _newWriter(getSerializationConfig().withFilters(filterProvider));\n    }\n    \n    \n    public ObjectWriter writer(FormatSchema schema) {\n        _verifySchemaType(schema);\n        return _newWriter(getSerializationConfig(), schema);\n    }\n\n    \n    public ObjectWriter writer(Base64Variant defaultBase64) {\n        return _newWriter(getSerializationConfig().with(defaultBase64));\n    }\n\n    \n    public ObjectWriter writer(CharacterEscapes escapes) {\n        return _newWriter(getSerializationConfig()).with(escapes);\n    }\n\n    \n    public ObjectWriter writer(ContextAttributes attrs) {\n        return _newWriter(getSerializationConfig().with(attrs));\n    }\n\n    \n    @Deprecated\n    public ObjectWriter writerWithType(Class<?> rootType) {\n        return _newWriter(getSerializationConfig(),\n                \n                ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n                null);\n    }\n\n    \n    @Deprecated\n    public ObjectWriter writerWithType(TypeReference<?> rootType) {\n        return _newWriter(getSerializationConfig(),\n                \n                ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n                null);\n    }\n\n    \n    @Deprecated\n    public ObjectWriter writerWithType(JavaType rootType) {\n        return _newWriter(getSerializationConfig(), rootType, null);\n    }\n    \n    \n\n    \n    public ObjectReader reader() {\n        return _newReader(getDeserializationConfig()).with(_injectableValues);\n    }\n\n    \n    public ObjectReader reader(DeserializationFeature feature) {\n        return _newReader(getDeserializationConfig().with(feature));\n    }\n\n    \n    public ObjectReader reader(DeserializationFeature first, DeserializationFeature... other) {\n        return _newReader(getDeserializationConfig().with(first, other));\n    }\n    \n    \n    public ObjectReader readerForUpdating(Object valueToUpdate) {\n        JavaType t = _typeFactory.constructType(valueToUpdate.getClass());\n        return _newReader(getDeserializationConfig(), t, valueToUpdate,\n                null, _injectableValues);\n    }\n\n    \n    public ObjectReader readerFor(JavaType type) {\n        return _newReader(getDeserializationConfig(), type, null,\n                null, _injectableValues);\n    }\n\n    \n    public ObjectReader readerFor(Class<?> type) {\n        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                null, _injectableValues);\n    }\n\n    \n    public ObjectReader readerFor(TypeReference<?> type) {\n        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                null, _injectableValues);\n    }\n\n    \n    public ObjectReader reader(JsonNodeFactory f) {\n        return _newReader(getDeserializationConfig()).with(f);\n    }\n\n    \n    public ObjectReader reader(FormatSchema schema) {\n        _verifySchemaType(schema);\n        return _newReader(getDeserializationConfig(), null, null,\n                schema, _injectableValues);\n    }\n\n    \n    public ObjectReader reader(InjectableValues injectableValues) {\n        return _newReader(getDeserializationConfig(), null, null,\n                null, injectableValues);\n    }\n\n    \n    public ObjectReader readerWithView(Class<?> view) {\n        return _newReader(getDeserializationConfig().withView(view));\n    }\n\n    \n    public ObjectReader reader(Base64Variant defaultBase64) {\n        return _newReader(getDeserializationConfig().with(defaultBase64));\n    }\n\n    \n    public ObjectReader reader(ContextAttributes attrs) {\n        return _newReader(getDeserializationConfig().with(attrs));\n    }\n\n    \n    @Deprecated\n    public ObjectReader reader(JavaType type) {\n        return _newReader(getDeserializationConfig(), type, null,\n                null, _injectableValues);\n    }\n\n    \n    @Deprecated\n    public ObjectReader reader(Class<?> type) {\n        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                null, _injectableValues);\n    }\n\n    \n    @Deprecated\n    public ObjectReader reader(TypeReference<?> type) {\n        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                null, _injectableValues);\n    }\n\n    \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException {\n        \n        if (fromValue == null) return null;\n        return (T) _convert(fromValue, _typeFactory.constructType(toValueType));\n    } \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException {\n        return (T) convertValue(fromValue, _typeFactory.constructType(toValueTypeRef));\n    } \n\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException {\n        \n        if (fromValue == null) return null;\n        return (T) _convert(fromValue, toValueType);\n    } \n\n    \n    @SuppressWarnings(\"resource\")\n    protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException {        \n        \n        \n        Class<?> targetType = toValueType.getRawClass();\n        if (targetType != Object.class\n                && !toValueType.hasGenericTypes()\n                && targetType.isAssignableFrom(fromValue.getClass())) {\n            return fromValue;\n        }\n        \n        \n        TokenBuffer buf = new TokenBuffer(this, false);\n        if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n            buf = buf.forceUseOfBigDecimal(true);\n        }\n        try {\n            \n            \n            SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);\n            \n            _serializerProvider(config).serializeValue(buf, fromValue);\n\n            \n            final JsonParser jp = buf.asParser();\n            Object result;\n            \n            final DeserializationConfig deserConfig = getDeserializationConfig();\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt);\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else { \n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);\n                \n                result = deser.deserialize(jp, ctxt);\n            }\n            jp.close();\n            return result;\n        } catch (IOException e) { \n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }\n\n    \n\n    \n    @Deprecated\n    public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException {\n        return _serializerProvider(getSerializationConfig()).generateJsonSchema(t);\n    }\n\n    \n    public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException {\n        acceptJsonFormatVisitor(_typeFactory.constructType(type), visitor);\n    }\n    \n    \n    public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException {\n        if (type == null) {\n            throw new IllegalArgumentException(\"type must be provided\");\n        }\n        _serializerProvider(getSerializationConfig()).acceptJsonFormatVisitor(type, visitor);\n    }\n    \n    \n\n    \n    protected DefaultSerializerProvider _serializerProvider(SerializationConfig config) {\n        return _serializerProvider.createInstance(config, _serializerFactory);\n    }\n    \n    \n    @Deprecated\n    protected PrettyPrinter _defaultPrettyPrinter() {\n        return _serializationConfig.constructDefaultPrettyPrinter();\n    }\n\n    \n    protected final void _configAndWriteValue(JsonGenerator g, Object value) throws IOException {\n        SerializationConfig cfg = getSerializationConfig();\n        cfg.initialize(g); \n        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _configAndWriteCloseable(g, value, cfg);\n            return;\n        }\n        boolean closed = false;\n        try {\n            _serializerProvider(cfg).serializeValue(g, value);\n            closed = true;\n            g.close();\n        } finally {\n            \n            if (!closed) {\n                \n                g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    g.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n\n    protected final void _configAndWriteValue(JsonGenerator g, Object value, Class<?> viewClass) throws IOException {\n        SerializationConfig cfg = getSerializationConfig().withView(viewClass);\n        cfg.initialize(g); \n\n        \n        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _configAndWriteCloseable(g, value, cfg);\n            return;\n        }\n        boolean closed = false;\n        try {\n            _serializerProvider(cfg).serializeValue(g, value);\n            closed = true;\n            g.close();\n        } finally {\n            if (!closed) {\n                \n                \n                g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    g.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n\n    \n    private final void _configAndWriteCloseable(JsonGenerator g, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException {\n        Closeable toClose = (Closeable) value;\n        try {\n            _serializerProvider(cfg).serializeValue(g, value);\n            JsonGenerator tmpGen = g;\n            g = null;\n            tmpGen.close();\n            Closeable tmpToClose = toClose;\n            toClose = null;\n            tmpToClose.close();\n        } finally {\n            \n            if (g != null) {\n                \n                \n                g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    g.close();\n                } catch (IOException ioe) { }\n            }\n            if (toClose != null) {\n                try {\n                    toClose.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n    \n    \n    private final void _writeCloseableValue(JsonGenerator g, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException {\n        Closeable toClose = (Closeable) value;\n        try {\n            _serializerProvider(cfg).serializeValue(g, value);\n            if (cfg.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                g.flush();\n            }\n            Closeable tmpToClose = toClose;\n            toClose = null;\n            tmpToClose.close();\n        } finally {\n            if (toClose != null) {\n                try {\n                    toClose.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n\n    \n\n    \n    protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg) {\n        return _deserializationContext.createInstance(cfg, jp, _injectableValues);\n    }\n    \n    \n    protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        \n        Object result;\n        JsonToken t = _initForReading(jp);\n        if (t == JsonToken.VALUE_NULL) {\n            \n            DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n            result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt);\n        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = null;\n        } else { \n            DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n            \n            if (cfg.useRootWrapping()) {\n                result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser);\n            } else {\n                result = deser.deserialize(jp, ctxt);\n            }\n        }\n        \n        jp.clearCurrentToken();\n        return result;\n    }\n    \n    protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {\n        try {\n            Object result;\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                \n                DeserializationContext ctxt = createDeserializationContext(jp,\n                        getDeserializationConfig());\n                result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt);\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else {\n                DeserializationConfig cfg = getDeserializationConfig();\n                DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n                if (cfg.useRootWrapping()) {\n                    result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser);\n                } else {\n                    result = deser.deserialize(jp, ctxt);\n                }\n                ctxt.checkUnresolvedObjectId();\n            }\n            \n            jp.clearCurrentToken();\n            return result;\n        } finally {\n            try {\n                jp.close();\n            } catch (IOException ioe) { }\n        }\n    }\n    \n    \n    protected JsonToken _initForReading(JsonParser p) throws IOException {\n        _deserializationConfig.initialize(p); \n\n        \n        JsonToken t = p.getCurrentToken();\n        if (t == null) {\n            \n            t = p.nextToken();\n            if (t == null) {\n                \n                throw JsonMappingException.from(p, \"No content to map due to end-of-input\");\n            }\n        }\n        return t;\n    }\n\n    protected Object _unwrapAndDeserialize(JsonParser p, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException {\n        PropertyName expRootName = config.findRootName(rootType);\n        \n        String expSimpleName = expRootName.getSimpleName();\n        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n            throw JsonMappingException.from(p, \"Current token not START_OBJECT (needed to unwrap root name '\"\n                    +expSimpleName+\"'), but \"+p.getCurrentToken());\n        }\n        if (p.nextToken() != JsonToken.FIELD_NAME) {\n            throw JsonMappingException.from(p, \"Current token not FIELD_NAME (to contain expected root name '\"\n                    +expSimpleName+\"'), but \"+p.getCurrentToken());\n        }\n        String actualName = p.getCurrentName();\n        if (!expSimpleName.equals(actualName)) {\n            throw JsonMappingException.from(p, \"Root name '\"+actualName+\"' does not match expected ('\"\n                    +expSimpleName+\"') for type \"+rootType);\n        }\n        \n        p.nextToken();\n        Object result = deser.deserialize(p, ctxt);\n        \n        if (p.nextToken() != JsonToken.END_OBJECT) {\n            throw JsonMappingException.from(p, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n                    +expSimpleName+\"'), but \"+p.getCurrentToken());\n        }\n        return result;\n    }\n    \n    \n\n    \n    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException {\n        \n        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n        if (deser != null) {\n            return deser;\n        }\n        \n        deser = ctxt.findRootValueDeserializer(valueType);\n        if (deser == null) { \n            throw new JsonMappingException(\"Can not find a deserializer for type \"+valueType);\n        }\n        _rootDeserializers.put(valueType, deser);\n        return deser;\n    }\n\n    \n    protected void _verifySchemaType(FormatSchema schema) {\n        if (schema != null) {\n            if (!_jsonFactory.canUseSchema(schema)) {\n                    throw new IllegalArgumentException(\"Can not use FormatSchema of type \"+schema.getClass().getName()\n                            +\" for format \"+_jsonFactory.getFormatName());\n            }\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes)",
        "public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes)",
        "public boolean useForType(JavaType t)",
        "public ObjectMapper(JsonFactory jf)",
        "protected ObjectMapper(ObjectMapper src)",
        "public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc)",
        "protected ClassIntrospector defaultClassIntrospector()",
        "public ObjectMapper copy()",
        "protected void _checkInvalidCopy(Class<?> exp)",
        "protected ObjectReader _newReader(DeserializationConfig config)",
        "protected ObjectReader _newReader(DeserializationConfig config, JavaType valueType, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues)",
        "protected ObjectWriter _newWriter(SerializationConfig config)",
        "protected ObjectWriter _newWriter(SerializationConfig config, FormatSchema schema)",
        "protected ObjectWriter _newWriter(SerializationConfig config, JavaType rootType, PrettyPrinter pp)",
        "public Version version()",
        "public ObjectMapper registerModule(Module module)",
        "public Version getMapperVersion()",
        "public <C extends ObjectCodec> C getOwner()",
        "public TypeFactory getTypeFactory()",
        "public boolean isEnabled(MapperFeature f)",
        "public boolean isEnabled(DeserializationFeature f)",
        "public boolean isEnabled(SerializationFeature f)",
        "public boolean isEnabled(JsonFactory.Feature f)",
        "public boolean isEnabled(JsonParser.Feature f)",
        "public boolean isEnabled(JsonGenerator.Feature f)",
        "public void addDeserializers(Deserializers d)",
        "public void addKeyDeserializers(KeyDeserializers d)",
        "public void addBeanDeserializerModifier(BeanDeserializerModifier modifier)",
        "public void addSerializers(Serializers s)",
        "public void addKeySerializers(Serializers s)",
        "public void addBeanSerializerModifier(BeanSerializerModifier modifier)",
        "public void addAbstractTypeResolver(AbstractTypeResolver resolver)",
        "public void addTypeModifier(TypeModifier modifier)",
        "public void addValueInstantiators(ValueInstantiators instantiators)",
        "public void setClassIntrospector(ClassIntrospector ci)",
        "public void insertAnnotationIntrospector(AnnotationIntrospector ai)",
        "public void appendAnnotationIntrospector(AnnotationIntrospector ai)",
        "public void registerSubtypes(Class<?>... subtypes)",
        "public void registerSubtypes(NamedType... subtypes)",
        "public void setMixInAnnotations(Class<?> target, Class<?> mixinSource)",
        "public void addDeserializationProblemHandler(DeserializationProblemHandler handler)",
        "public void setNamingStrategy(PropertyNamingStrategy naming)",
        "public ObjectMapper registerModules(Module... modules)",
        "public ObjectMapper registerModules(Iterable<com.fasterxml.jackson.databind.Module> modules)",
        "public static List<com.fasterxml.jackson.databind.Module> findModules()",
        "public static List<com.fasterxml.jackson.databind.Module> findModules(ClassLoader classLoader)",
        "public ObjectMapper findAndRegisterModules()",
        "public SerializationConfig getSerializationConfig()",
        "public DeserializationConfig getDeserializationConfig()",
        "public DeserializationContext getDeserializationContext()",
        "public ObjectMapper setSerializerFactory(SerializerFactory f)",
        "public SerializerFactory getSerializerFactory()",
        "public ObjectMapper setSerializerProvider(DefaultSerializerProvider p)",
        "public SerializerProvider getSerializerProvider()",
        "public ObjectMapper setMixIns(Map<Class<?>, Class<?>> sourceMixins)",
        "public ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource)",
        "public ObjectMapper setMixInResolver(ClassIntrospector.MixInResolver resolver)",
        "public Class<?> findMixInClassFor(Class<?> cls)",
        "public int mixInCount()",
        "public void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins)",
        "public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource)",
        "public VisibilityChecker<?> getVisibilityChecker()",
        "public void setVisibilityChecker(VisibilityChecker<?> vc)",
        "public ObjectMapper setVisibility(VisibilityChecker<?> vc)",
        "public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility)",
        "public SubtypeResolver getSubtypeResolver()",
        "public ObjectMapper setSubtypeResolver(SubtypeResolver str)",
        "public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai)",
        "public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI)",
        "public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s)",
        "public PropertyNamingStrategy getPropertyNamingStrategy()",
        "public ObjectMapper setSerializationInclusion(JsonInclude.Include incl)",
        "public ObjectMapper setDefaultPrettyPrinter(PrettyPrinter pp)",
        "public ObjectMapper enableDefaultTyping()",
        "public ObjectMapper enableDefaultTyping(DefaultTyping dti)",
        "public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs)",
        "public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName)",
        "public ObjectMapper disableDefaultTyping()",
        "public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer)",
        "public void registerSubtypes(Class<?>... classes)",
        "public void registerSubtypes(NamedType... types)",
        "public TypeFactory getTypeFactory()",
        "public ObjectMapper setTypeFactory(TypeFactory f)",
        "public JavaType constructType(Type t)",
        "public JsonNodeFactory getNodeFactory()",
        "public ObjectMapper setNodeFactory(JsonNodeFactory f)",
        "public ObjectMapper addHandler(DeserializationProblemHandler h)",
        "public ObjectMapper clearProblemHandlers()",
        "public ObjectMapper setConfig(DeserializationConfig config)",
        "public void setFilters(FilterProvider filterProvider)",
        "public ObjectMapper setFilterProvider(FilterProvider filterProvider)",
        "public ObjectMapper setBase64Variant(Base64Variant v)",
        "public ObjectMapper setConfig(SerializationConfig config)",
        "public JsonFactory getFactory()",
        "public JsonFactory getJsonFactory()",
        "public ObjectMapper setDateFormat(DateFormat dateFormat)",
        "public DateFormat getDateFormat()",
        "public Object setHandlerInstantiator(HandlerInstantiator hi)",
        "public ObjectMapper setInjectableValues(InjectableValues injectableValues)",
        "public InjectableValues getInjectableValues()",
        "public ObjectMapper setLocale(Locale l)",
        "public ObjectMapper setTimeZone(TimeZone tz)",
        "public boolean isEnabled(MapperFeature f)",
        "public ObjectMapper configure(MapperFeature f, boolean state)",
        "public ObjectMapper enable(MapperFeature... f)",
        "public ObjectMapper disable(MapperFeature... f)",
        "public boolean isEnabled(SerializationFeature f)",
        "public ObjectMapper configure(SerializationFeature f, boolean state)",
        "public ObjectMapper enable(SerializationFeature f)",
        "public ObjectMapper enable(SerializationFeature first, SerializationFeature... f)",
        "public ObjectMapper disable(SerializationFeature f)",
        "public ObjectMapper disable(SerializationFeature first, SerializationFeature... f)",
        "public boolean isEnabled(DeserializationFeature f)",
        "public ObjectMapper configure(DeserializationFeature f, boolean state)",
        "public ObjectMapper enable(DeserializationFeature feature)",
        "public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f)",
        "public ObjectMapper disable(DeserializationFeature feature)",
        "public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f)",
        "public boolean isEnabled(JsonParser.Feature f)",
        "public ObjectMapper configure(JsonParser.Feature f, boolean state)",
        "public ObjectMapper enable(JsonParser.Feature... features)",
        "public ObjectMapper disable(JsonParser.Feature... features)",
        "public boolean isEnabled(JsonGenerator.Feature f)",
        "public ObjectMapper configure(JsonGenerator.Feature f, boolean state)",
        "public ObjectMapper enable(JsonGenerator.Feature... features)",
        "public ObjectMapper disable(JsonGenerator.Feature... features)",
        "public boolean isEnabled(JsonFactory.Feature f)",
        "public <T> T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public final <T> T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T extends TreeNode> T readTree(JsonParser jp) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException",
        "public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException",
        "public JsonNode readTree(Reader r) throws IOException, JsonProcessingException",
        "public JsonNode readTree(String content) throws IOException, JsonProcessingException",
        "public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException",
        "public JsonNode readTree(File file) throws IOException, JsonProcessingException",
        "public JsonNode readTree(URL source) throws IOException, JsonProcessingException",
        "public void writeValue(JsonGenerator g, Object value) throws IOException, JsonGenerationException, JsonMappingException",
        "public void writeTree(JsonGenerator jgen, TreeNode rootNode) throws IOException, JsonProcessingException",
        "public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException",
        "public ObjectNode createObjectNode()",
        "public ArrayNode createArrayNode()",
        "public JsonParser treeAsTokens(TreeNode n)",
        "public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException",
        "public <T extends JsonNode> T valueToTree(Object fromValue) throws IllegalArgumentException",
        "public boolean canSerialize(Class<?> type)",
        "public boolean canSerialize(Class<?> type, AtomicReference<Throwable> cause)",
        "public boolean canDeserialize(JavaType type)",
        "public boolean canDeserialize(JavaType type, AtomicReference<Throwable> cause)",
        "public <T> T readValue(File src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(File src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(URL src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(String content, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(Reader src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(InputStream src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, int offset, int len, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException",
        "public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException",
        "public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException",
        "public String writeValueAsString(Object value) throws JsonProcessingException",
        "public byte[] writeValueAsBytes(Object value) throws JsonProcessingException",
        "public ObjectWriter writer()",
        "public ObjectWriter writer(SerializationFeature feature)",
        "public ObjectWriter writer(SerializationFeature first, SerializationFeature... other)",
        "public ObjectWriter writer(DateFormat df)",
        "public ObjectWriter writerWithView(Class<?> serializationView)",
        "public ObjectWriter writerFor(Class<?> rootType)",
        "public ObjectWriter writerFor(TypeReference<?> rootType)",
        "public ObjectWriter writerFor(JavaType rootType)",
        "public ObjectWriter writer(PrettyPrinter pp)",
        "public ObjectWriter writerWithDefaultPrettyPrinter()",
        "public ObjectWriter writer(FilterProvider filterProvider)",
        "public ObjectWriter writer(FormatSchema schema)",
        "public ObjectWriter writer(Base64Variant defaultBase64)",
        "public ObjectWriter writer(CharacterEscapes escapes)",
        "public ObjectWriter writer(ContextAttributes attrs)",
        "public ObjectWriter writerWithType(Class<?> rootType)",
        "public ObjectWriter writerWithType(TypeReference<?> rootType)",
        "public ObjectWriter writerWithType(JavaType rootType)",
        "public ObjectReader reader()",
        "public ObjectReader reader(DeserializationFeature feature)",
        "public ObjectReader reader(DeserializationFeature first, DeserializationFeature... other)",
        "public ObjectReader readerForUpdating(Object valueToUpdate)",
        "public ObjectReader readerFor(JavaType type)",
        "public ObjectReader readerFor(Class<?> type)",
        "public ObjectReader readerFor(TypeReference<?> type)",
        "public ObjectReader reader(JsonNodeFactory f)",
        "public ObjectReader reader(FormatSchema schema)",
        "public ObjectReader reader(InjectableValues injectableValues)",
        "public ObjectReader readerWithView(Class<?> view)",
        "public ObjectReader reader(Base64Variant defaultBase64)",
        "public ObjectReader reader(ContextAttributes attrs)",
        "public ObjectReader reader(JavaType type)",
        "public ObjectReader reader(Class<?> type)",
        "public ObjectReader reader(TypeReference<?> type)",
        "public <T> T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException",
        "public <T> T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException",
        "public <T> T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException",
        "protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException",
        "public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException",
        "public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException",
        "public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException",
        "protected DefaultSerializerProvider _serializerProvider(SerializationConfig config)",
        "protected PrettyPrinter _defaultPrettyPrinter()",
        "protected final void _configAndWriteValue(JsonGenerator g, Object value) throws IOException",
        "protected final void _configAndWriteValue(JsonGenerator g, Object value, Class<?> viewClass) throws IOException",
        "private final void _configAndWriteCloseable(JsonGenerator g, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException",
        "private final void _writeCloseableValue(JsonGenerator g, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException",
        "protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg)",
        "protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "protected JsonToken _initForReading(JsonParser p) throws IOException",
        "protected Object _unwrapAndDeserialize(JsonParser p, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException",
        "protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException",
        "protected void _verifySchemaType(FormatSchema schema)"
      ],
      "fixed_signatures": [
        "public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes)",
        "public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes)",
        "public boolean useForType(JavaType t)",
        "public ObjectMapper(JsonFactory jf)",
        "protected ObjectMapper(ObjectMapper src)",
        "public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc)",
        "protected ClassIntrospector defaultClassIntrospector()",
        "public ObjectMapper copy()",
        "protected void _checkInvalidCopy(Class<?> exp)",
        "protected ObjectReader _newReader(DeserializationConfig config)",
        "protected ObjectReader _newReader(DeserializationConfig config, JavaType valueType, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues)",
        "protected ObjectWriter _newWriter(SerializationConfig config)",
        "protected ObjectWriter _newWriter(SerializationConfig config, FormatSchema schema)",
        "protected ObjectWriter _newWriter(SerializationConfig config, JavaType rootType, PrettyPrinter pp)",
        "public Version version()",
        "public ObjectMapper registerModule(Module module)",
        "public Version getMapperVersion()",
        "public <C extends ObjectCodec> C getOwner()",
        "public TypeFactory getTypeFactory()",
        "public boolean isEnabled(MapperFeature f)",
        "public boolean isEnabled(DeserializationFeature f)",
        "public boolean isEnabled(SerializationFeature f)",
        "public boolean isEnabled(JsonFactory.Feature f)",
        "public boolean isEnabled(JsonParser.Feature f)",
        "public boolean isEnabled(JsonGenerator.Feature f)",
        "public void addDeserializers(Deserializers d)",
        "public void addKeyDeserializers(KeyDeserializers d)",
        "public void addBeanDeserializerModifier(BeanDeserializerModifier modifier)",
        "public void addSerializers(Serializers s)",
        "public void addKeySerializers(Serializers s)",
        "public void addBeanSerializerModifier(BeanSerializerModifier modifier)",
        "public void addAbstractTypeResolver(AbstractTypeResolver resolver)",
        "public void addTypeModifier(TypeModifier modifier)",
        "public void addValueInstantiators(ValueInstantiators instantiators)",
        "public void setClassIntrospector(ClassIntrospector ci)",
        "public void insertAnnotationIntrospector(AnnotationIntrospector ai)",
        "public void appendAnnotationIntrospector(AnnotationIntrospector ai)",
        "public void registerSubtypes(Class<?>... subtypes)",
        "public void registerSubtypes(NamedType... subtypes)",
        "public void setMixInAnnotations(Class<?> target, Class<?> mixinSource)",
        "public void addDeserializationProblemHandler(DeserializationProblemHandler handler)",
        "public void setNamingStrategy(PropertyNamingStrategy naming)",
        "public ObjectMapper registerModules(Module... modules)",
        "public ObjectMapper registerModules(Iterable<com.fasterxml.jackson.databind.Module> modules)",
        "public static List<com.fasterxml.jackson.databind.Module> findModules()",
        "public static List<com.fasterxml.jackson.databind.Module> findModules(ClassLoader classLoader)",
        "public ObjectMapper findAndRegisterModules()",
        "public SerializationConfig getSerializationConfig()",
        "public DeserializationConfig getDeserializationConfig()",
        "public DeserializationContext getDeserializationContext()",
        "public ObjectMapper setSerializerFactory(SerializerFactory f)",
        "public SerializerFactory getSerializerFactory()",
        "public ObjectMapper setSerializerProvider(DefaultSerializerProvider p)",
        "public SerializerProvider getSerializerProvider()",
        "public ObjectMapper setMixIns(Map<Class<?>, Class<?>> sourceMixins)",
        "public ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource)",
        "public ObjectMapper setMixInResolver(ClassIntrospector.MixInResolver resolver)",
        "public Class<?> findMixInClassFor(Class<?> cls)",
        "public int mixInCount()",
        "public void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins)",
        "public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource)",
        "public VisibilityChecker<?> getVisibilityChecker()",
        "public void setVisibilityChecker(VisibilityChecker<?> vc)",
        "public ObjectMapper setVisibility(VisibilityChecker<?> vc)",
        "public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility)",
        "public SubtypeResolver getSubtypeResolver()",
        "public ObjectMapper setSubtypeResolver(SubtypeResolver str)",
        "public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai)",
        "public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI)",
        "public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s)",
        "public PropertyNamingStrategy getPropertyNamingStrategy()",
        "public ObjectMapper setSerializationInclusion(JsonInclude.Include incl)",
        "public ObjectMapper setDefaultPrettyPrinter(PrettyPrinter pp)",
        "public ObjectMapper enableDefaultTyping()",
        "public ObjectMapper enableDefaultTyping(DefaultTyping dti)",
        "public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs)",
        "public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName)",
        "public ObjectMapper disableDefaultTyping()",
        "public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer)",
        "public void registerSubtypes(Class<?>... classes)",
        "public void registerSubtypes(NamedType... types)",
        "public TypeFactory getTypeFactory()",
        "public ObjectMapper setTypeFactory(TypeFactory f)",
        "public JavaType constructType(Type t)",
        "public JsonNodeFactory getNodeFactory()",
        "public ObjectMapper setNodeFactory(JsonNodeFactory f)",
        "public ObjectMapper addHandler(DeserializationProblemHandler h)",
        "public ObjectMapper clearProblemHandlers()",
        "public ObjectMapper setConfig(DeserializationConfig config)",
        "public void setFilters(FilterProvider filterProvider)",
        "public ObjectMapper setFilterProvider(FilterProvider filterProvider)",
        "public ObjectMapper setBase64Variant(Base64Variant v)",
        "public ObjectMapper setConfig(SerializationConfig config)",
        "public JsonFactory getFactory()",
        "public JsonFactory getJsonFactory()",
        "public ObjectMapper setDateFormat(DateFormat dateFormat)",
        "public DateFormat getDateFormat()",
        "public Object setHandlerInstantiator(HandlerInstantiator hi)",
        "public ObjectMapper setInjectableValues(InjectableValues injectableValues)",
        "public InjectableValues getInjectableValues()",
        "public ObjectMapper setLocale(Locale l)",
        "public ObjectMapper setTimeZone(TimeZone tz)",
        "public boolean isEnabled(MapperFeature f)",
        "public ObjectMapper configure(MapperFeature f, boolean state)",
        "public ObjectMapper enable(MapperFeature... f)",
        "public ObjectMapper disable(MapperFeature... f)",
        "public boolean isEnabled(SerializationFeature f)",
        "public ObjectMapper configure(SerializationFeature f, boolean state)",
        "public ObjectMapper enable(SerializationFeature f)",
        "public ObjectMapper enable(SerializationFeature first, SerializationFeature... f)",
        "public ObjectMapper disable(SerializationFeature f)",
        "public ObjectMapper disable(SerializationFeature first, SerializationFeature... f)",
        "public boolean isEnabled(DeserializationFeature f)",
        "public ObjectMapper configure(DeserializationFeature f, boolean state)",
        "public ObjectMapper enable(DeserializationFeature feature)",
        "public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f)",
        "public ObjectMapper disable(DeserializationFeature feature)",
        "public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f)",
        "public boolean isEnabled(JsonParser.Feature f)",
        "public ObjectMapper configure(JsonParser.Feature f, boolean state)",
        "public ObjectMapper enable(JsonParser.Feature... features)",
        "public ObjectMapper disable(JsonParser.Feature... features)",
        "public boolean isEnabled(JsonGenerator.Feature f)",
        "public ObjectMapper configure(JsonGenerator.Feature f, boolean state)",
        "public ObjectMapper enable(JsonGenerator.Feature... features)",
        "public ObjectMapper disable(JsonGenerator.Feature... features)",
        "public boolean isEnabled(JsonFactory.Feature f)",
        "public <T> T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public final <T> T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T extends TreeNode> T readTree(JsonParser jp) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException",
        "public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException",
        "public JsonNode readTree(Reader r) throws IOException, JsonProcessingException",
        "public JsonNode readTree(String content) throws IOException, JsonProcessingException",
        "public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException",
        "public JsonNode readTree(File file) throws IOException, JsonProcessingException",
        "public JsonNode readTree(URL source) throws IOException, JsonProcessingException",
        "public void writeValue(JsonGenerator g, Object value) throws IOException, JsonGenerationException, JsonMappingException",
        "public void writeTree(JsonGenerator jgen, TreeNode rootNode) throws IOException, JsonProcessingException",
        "public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException",
        "public ObjectNode createObjectNode()",
        "public ArrayNode createArrayNode()",
        "public JsonParser treeAsTokens(TreeNode n)",
        "public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException",
        "public <T extends JsonNode> T valueToTree(Object fromValue) throws IllegalArgumentException",
        "public boolean canSerialize(Class<?> type)",
        "public boolean canSerialize(Class<?> type, AtomicReference<Throwable> cause)",
        "public boolean canDeserialize(JavaType type)",
        "public boolean canDeserialize(JavaType type, AtomicReference<Throwable> cause)",
        "public <T> T readValue(File src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(File src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(URL src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(String content, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(Reader src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(InputStream src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, int offset, int len, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public <T> T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException",
        "public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException",
        "public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException",
        "public String writeValueAsString(Object value) throws JsonProcessingException",
        "public byte[] writeValueAsBytes(Object value) throws JsonProcessingException",
        "public ObjectWriter writer()",
        "public ObjectWriter writer(SerializationFeature feature)",
        "public ObjectWriter writer(SerializationFeature first, SerializationFeature... other)",
        "public ObjectWriter writer(DateFormat df)",
        "public ObjectWriter writerWithView(Class<?> serializationView)",
        "public ObjectWriter writerFor(Class<?> rootType)",
        "public ObjectWriter writerFor(TypeReference<?> rootType)",
        "public ObjectWriter writerFor(JavaType rootType)",
        "public ObjectWriter writer(PrettyPrinter pp)",
        "public ObjectWriter writerWithDefaultPrettyPrinter()",
        "public ObjectWriter writer(FilterProvider filterProvider)",
        "public ObjectWriter writer(FormatSchema schema)",
        "public ObjectWriter writer(Base64Variant defaultBase64)",
        "public ObjectWriter writer(CharacterEscapes escapes)",
        "public ObjectWriter writer(ContextAttributes attrs)",
        "public ObjectWriter writerWithType(Class<?> rootType)",
        "public ObjectWriter writerWithType(TypeReference<?> rootType)",
        "public ObjectWriter writerWithType(JavaType rootType)",
        "public ObjectReader reader()",
        "public ObjectReader reader(DeserializationFeature feature)",
        "public ObjectReader reader(DeserializationFeature first, DeserializationFeature... other)",
        "public ObjectReader readerForUpdating(Object valueToUpdate)",
        "public ObjectReader readerFor(JavaType type)",
        "public ObjectReader readerFor(Class<?> type)",
        "public ObjectReader readerFor(TypeReference<?> type)",
        "public ObjectReader reader(JsonNodeFactory f)",
        "public ObjectReader reader(FormatSchema schema)",
        "public ObjectReader reader(InjectableValues injectableValues)",
        "public ObjectReader readerWithView(Class<?> view)",
        "public ObjectReader reader(Base64Variant defaultBase64)",
        "public ObjectReader reader(ContextAttributes attrs)",
        "public ObjectReader reader(JavaType type)",
        "public ObjectReader reader(Class<?> type)",
        "public ObjectReader reader(TypeReference<?> type)",
        "public <T> T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException",
        "public <T> T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException",
        "public <T> T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException",
        "protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException",
        "public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException",
        "public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException",
        "public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException",
        "protected DefaultSerializerProvider _serializerProvider(SerializationConfig config)",
        "protected PrettyPrinter _defaultPrettyPrinter()",
        "protected final void _configAndWriteValue(JsonGenerator g, Object value) throws IOException",
        "protected final void _configAndWriteValue(JsonGenerator g, Object value, Class<?> viewClass) throws IOException",
        "private final void _configAndWriteCloseable(JsonGenerator g, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException",
        "private final void _writeCloseableValue(JsonGenerator g, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException",
        "protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg)",
        "protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException",
        "protected JsonToken _initForReading(JsonParser p) throws IOException",
        "protected Object _unwrapAndDeserialize(JsonParser p, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException",
        "protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException",
        "protected void _verifySchemaType(FormatSchema schema)"
      ],
      "methods": [
        {
          "buggy_method": "  public <T extends JsonNode> T valueToTree(Object fromValue) throws IllegalArgumentException {\n  if (fromValue == null) return null;\n  TokenBuffer buf = new TokenBuffer(this, false);\n  JsonNode result;\n  try {\n  writeValue(buf, fromValue);\n  JsonParser jp = buf.asParser();\n  result = readTree(jp);\n  jp.close();\n  } catch (IOException e) { \n  throw new IllegalArgumentException(e.getMessage(), e);\n  }\n  return (T) result;\n  } ",
          "fixed_method": "  public <T extends JsonNode> T valueToTree(Object fromValue) throws IllegalArgumentException {\n  if (fromValue == null) return null;\n  TokenBuffer buf = new TokenBuffer(this, false);\n  if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n  buf = buf.forceUseOfBigDecimal(true);\n  }\n  JsonNode result;\n  try {\n  writeValue(buf, fromValue);\n  JsonParser jp = buf.asParser();\n  result = readTree(jp);\n  jp.close();\n  } catch (IOException e) { \n  throw new IllegalArgumentException(e.getMessage(), e);\n  }\n  return (T) result;\n  } ",
          "diff": [
            "@@ -2507,6 +2507,9 @@",
            "     {\n",
            "         if (fromValue == null) return null;\n",
            "         TokenBuffer buf = new TokenBuffer(this, false);\n",
            "+        if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n",
            "+            buf = buf.forceUseOfBigDecimal(true);\n",
            "+        }\n",
            "         JsonNode result;\n",
            "         try {\n",
            "             writeValue(buf, fromValue);\n"
          ],
          "changed_lines": 3
        },
        {
          "buggy_method": "  protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException {  \n  \n  \n  Class<?> targetType = toValueType.getRawClass();\n  if (targetType != Object.class\n  && !toValueType.hasGenericTypes()\n  && targetType.isAssignableFrom(fromValue.getClass())) {\n  return fromValue;\n  }\n  \n  \n  TokenBuffer buf = new TokenBuffer(this, false);\n  try {\n  \n  \n  SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);\n  \n  _serializerProvider(config).serializeValue(buf, fromValue);\n\n  \n  final JsonParser jp = buf.asParser();\n  Object result;\n  \n  final DeserializationConfig deserConfig = getDeserializationConfig();\n  JsonToken t = _initForReading(jp);\n  if (t == JsonToken.VALUE_NULL) {\n  DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n  result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt);\n  } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n  result = null;\n  } else { \n  DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n  JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);\n  \n  result = deser.deserialize(jp, ctxt);\n  }\n  jp.close();\n  return result;\n  } catch (IOException e) { \n  throw new IllegalArgumentException(e.getMessage(), e);\n  }\n  }",
          "fixed_method": "  protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException {  \n  \n  \n  Class<?> targetType = toValueType.getRawClass();\n  if (targetType != Object.class\n  && !toValueType.hasGenericTypes()\n  && targetType.isAssignableFrom(fromValue.getClass())) {\n  return fromValue;\n  }\n  \n  \n  TokenBuffer buf = new TokenBuffer(this, false);\n  if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n  buf = buf.forceUseOfBigDecimal(true);\n  }\n  try {\n  \n  \n  SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);\n  \n  _serializerProvider(config).serializeValue(buf, fromValue);\n\n  \n  final JsonParser jp = buf.asParser();\n  Object result;\n  \n  final DeserializationConfig deserConfig = getDeserializationConfig();\n  JsonToken t = _initForReading(jp);\n  if (t == JsonToken.VALUE_NULL) {\n  DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n  result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt);\n  } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n  result = null;\n  } else { \n  DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n  JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);\n  \n  result = deser.deserialize(jp, ctxt);\n  }\n  jp.close();\n  return result;\n  } catch (IOException e) { \n  throw new IllegalArgumentException(e.getMessage(), e);\n  }\n  }",
          "diff": [
            "@@ -3423,6 +3426,9 @@",
            "         \n",
            "         // Then use TokenBuffer, which is a JsonGenerator:\n",
            "         TokenBuffer buf = new TokenBuffer(this, false);\n",
            "+        if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n",
            "+            buf = buf.forceUseOfBigDecimal(true);\n",
            "+        }\n",
            "         try {\n",
            "             // inlined 'writeValue' with minor changes:\n",
            "             // first: disable wrapping when writing\n"
          ],
          "changed_lines": 3
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/util/TokenBuffer.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.util;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.TreeMap;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserMinimalBase;\nimport com.fasterxml.jackson.core.json.JsonReadContext;\nimport com.fasterxml.jackson.core.json.JsonWriteContext;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.databind.*;\n\n\npublic class TokenBuffer extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected Segment _first; protected Segment _last; protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) {\n        this(codec, false);\n    }\n\n    \n    public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) {\n        _objectCodec = codec;\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        \n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = hasNativeIds;\n        _hasNativeObjectIds = hasNativeIds;\n\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n    }\n\n    \n    public TokenBuffer(JsonParser p) {\n        this(p, null);\n    }\n\n    \n    public TokenBuffer(JsonParser p, DeserializationContext ctxt) {\n        _objectCodec = p.getCodec();\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        \n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = p.canReadTypeId();\n        _hasNativeObjectIds = p.canReadObjectId();\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n    }\n\n    \n\n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    \n    public JsonParser asParser() {\n        return asParser(_objectCodec);\n    }\n\n    \n    public JsonParser asParser(ObjectCodec codec) {\n        return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds);\n    }\n\n    \n    public JsonParser asParser(JsonParser src) {\n        Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds);\n        p.setLocation(src.getTokenLocation());\n        return p;\n    }\n    \n    \n\n    public JsonToken firstToken() {\n        if (_first != null) {\n            return _first.type(0);\n        }\n        return null;\n    }\n    \n    \n\n    \n    @SuppressWarnings(\"resource\")\n    public TokenBuffer append(TokenBuffer other) throws IOException {\n        \n        if (!_hasNativeTypeIds) {  \n            _hasNativeTypeIds = other.canWriteTypeId();\n        }\n        if (!_hasNativeObjectIds) {\n            _hasNativeObjectIds = other.canWriteObjectId();\n        }\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n        \n        JsonParser p = other.asParser();\n        while (p.nextToken() != null) {\n            copyCurrentStructure(p);\n        }\n        return this;\n    }\n    \n    \n    public void serialize(JsonGenerator gen) throws IOException {\n        Segment segment = _first;\n        int ptr = -1;\n\n        final boolean checkIds = _mayHaveNativeIds;\n        boolean hasIds = checkIds && (segment.hasIds());\n\n        while (true) {\n            if (++ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                segment = segment.next();\n                if (segment == null) break;\n                hasIds = checkIds && (segment.hasIds());\n            }\n            JsonToken t = segment.type(ptr);\n            if (t == null) break;\n\n            if (hasIds) {\n                Object id = segment.findObjectId(ptr);\n                if (id != null) {\n                    gen.writeObjectId(id);\n                }\n                id = segment.findTypeId(ptr);\n                if (id != null) {\n                    gen.writeTypeId(id);\n                }\n            }\n            \n            \n            switch (t) {\n            case START_OBJECT:\n                gen.writeStartObject();\n                break;\n            case END_OBJECT:\n                gen.writeEndObject();\n                break;\n            case START_ARRAY:\n                gen.writeStartArray();\n                break;\n            case END_ARRAY:\n                gen.writeEndArray();\n                break;\n            case FIELD_NAME:\n            {\n                \n                Object ob = segment.get(ptr);\n                if (ob instanceof SerializableString) {\n                    gen.writeFieldName((SerializableString) ob);\n                } else {\n                    gen.writeFieldName((String) ob);\n                }\n            }\n                break;\n            case VALUE_STRING:\n                {\n                    Object ob = segment.get(ptr);\n                    if (ob instanceof SerializableString) {\n                        gen.writeString((SerializableString) ob);\n                    } else {\n                        gen.writeString((String) ob);\n                    }\n                }\n                break;\n            case VALUE_NUMBER_INT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Integer) {\n                        gen.writeNumber((Integer) n);\n                    } else if (n instanceof BigInteger) {\n                        gen.writeNumber((BigInteger) n);\n                    } else if (n instanceof Long) {\n                        gen.writeNumber((Long) n);\n                    } else if (n instanceof Short) {\n                        gen.writeNumber((Short) n);\n                    } else {\n                        gen.writeNumber(((Number) n).intValue());\n                    }\n                }\n                break;\n            case VALUE_NUMBER_FLOAT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Double) {\n                        gen.writeNumber(((Double) n).doubleValue());\n                    } else if (n instanceof BigDecimal) {\n                        gen.writeNumber((BigDecimal) n);\n                    } else if (n instanceof Float) {\n                        gen.writeNumber(((Float) n).floatValue());\n                    } else if (n == null) {\n                        gen.writeNull();\n                    } else if (n instanceof String) {\n                        gen.writeNumber((String) n);\n                    } else {\n                        throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\");\n                    }\n                }\n                break;\n            case VALUE_TRUE:\n                gen.writeBoolean(true);\n                break;\n            case VALUE_FALSE:\n                gen.writeBoolean(false);\n                break;\n            case VALUE_NULL:\n                gen.writeNull();\n                break;\n            case VALUE_EMBEDDED_OBJECT:\n                {\n                    Object value = segment.get(ptr);\n                    if (value instanceof RawValue) {\n                        ((RawValue) value).serialize(gen);\n                    } else {\n                        gen.writeObject(value);\n                    }\n                }\n                break;\n            default:\n                throw new RuntimeException(\"Internal error: should never end up through this code path\");\n            }\n        }\n    }\n\n    \n    public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n        if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) {\n            copyCurrentStructure(p);\n            return this;\n        }\n        \n        JsonToken t;\n        writeStartObject();\n        do {\n            copyCurrentStructure(p);\n        } while ((t = p.nextToken()) == JsonToken.FIELD_NAME);\n        if (t != JsonToken.END_OBJECT) {\n            throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t);\n        }\n        writeEndObject();\n        return this;\n    }\n\n    @Override\n    @SuppressWarnings(\"resource\")\n    public String toString() {\n        \n        final int MAX_COUNT = 100;\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[TokenBuffer: \");\n\n        \n        \n        JsonParser jp = asParser();\n        int count = 0;\n        final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;\n\n        while (true) {\n            JsonToken t;\n            try {\n                t = jp.nextToken();\n                if (t == null) break;\n\n                if (hasNativeIds) {\n                    _appendNativeIds(sb);\n                }\n                        \n                if (count < MAX_COUNT) {\n                    if (count > 0) {\n                        sb.append(\", \");\n                    }\n                    sb.append(t.toString());\n                    if (t == JsonToken.FIELD_NAME) {\n                        sb.append('(');\n                        sb.append(jp.getCurrentName());\n                        sb.append(')');\n                    }\n                }\n            } catch (IOException ioe) { \n                throw new IllegalStateException(ioe);\n            }\n            ++count;\n        }\n\n        if (count >= MAX_COUNT) {\n            sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\");\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n\n    private final void _appendNativeIds(StringBuilder sb) {\n        Object objectId = _last.findObjectId(_appendAt-1);\n        if (objectId != null) {\n            sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']');\n        }\n        Object typeId = _last.findTypeId(_appendAt-1);\n        if (typeId != null) {\n            sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']');\n        }\n    }\n    \n    \n\n    @Override\n    public JsonGenerator enable(Feature f) {\n        _generatorFeatures |= f.getMask();\n        return this;\n    }\n\n    @Override\n    public JsonGenerator disable(Feature f) {\n        _generatorFeatures &= ~f.getMask();\n        return this;\n    }\n\n    \n\n    @Override\n    public boolean isEnabled(Feature f) {\n        return (_generatorFeatures & f.getMask()) != 0;\n    }\n\n    @Override\n    public int getFeatureMask() {\n        return _generatorFeatures;\n    }\n\n    @Override\n    public JsonGenerator setFeatureMask(int mask) {\n        _generatorFeatures = mask;\n        return this;\n    }\n    \n    @Override\n    public JsonGenerator useDefaultPrettyPrinter() {\n        \n        return this;\n    }\n\n    @Override\n    public JsonGenerator setCodec(ObjectCodec oc) {\n        _objectCodec = oc;\n        return this;\n    }\n\n    @Override\n    public ObjectCodec getCodec() { return _objectCodec; }\n\n    @Override\n    public final JsonWriteContext getOutputContext() { return _writeContext; }\n\n    \n    \n    \n    @Override\n    public boolean canWriteBinaryNatively() {\n        return true;\n    }\n    \n    \n\n    @Override\n    public void flush() throws IOException {  }\n\n    @Override\n    public void close() throws IOException {\n        _closed = true;\n    }\n\n    @Override\n    public boolean isClosed() { return _closed; }\n\n    \n\n    @Override\n    public final void writeStartArray() throws IOException {\n        _append(JsonToken.START_ARRAY);\n        _writeContext = _writeContext.createChildArrayContext();\n    }\n\n    @Override\n    public final void writeEndArray() throws IOException {\n        _append(JsonToken.END_ARRAY);\n        \n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n            _writeContext = c;\n        }\n    }\n\n    @Override\n    public final void writeStartObject() throws IOException {\n        _append(JsonToken.START_OBJECT);\n        _writeContext = _writeContext.createChildObjectContext();\n    }\n\n    @Override\n    public final void writeEndObject() throws IOException {\n        _append(JsonToken.END_OBJECT);\n        \n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n            _writeContext = c;\n        }\n    }\n\n    @Override\n    public final void writeFieldName(String name) throws IOException {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name);\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name.getValue());\n    }\n    \n    \n\n    @Override\n    public void writeString(String text) throws IOException {\n        if (text == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_STRING, text);\n        }\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException {\n        writeString(new String(text, offset, len));\n    }\n\n    @Override\n    public void writeString(SerializableString text) throws IOException {\n        if (text == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_STRING, text);\n        }\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException {\n        \n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int length) throws IOException {\n        \n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(SerializableString text) throws IOException {\n        _reportUnsupportedOperation();\n    }\n    \n    @Override\n    public void writeRaw(char[] text, int offset, int len) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(char c) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(String text) throws IOException {\n        _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));\n    }\n\n    @Override\n    public void writeRawValue(String text, int offset, int len) throws IOException {\n        if (offset > 0 || len != text.length()) {\n            text = text.substring(offset, offset+len);\n        }\n        _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));\n    }\n\n    @Override\n    public void writeRawValue(char[] text, int offset, int len) throws IOException {\n        _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len));\n    }\n\n    \n\n    @Override\n    public void writeNumber(short i) throws IOException {\n        _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i));\n    }\n\n    @Override\n    public void writeNumber(int i) throws IOException {\n        _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i));\n    }\n\n    @Override\n    public void writeNumber(long l) throws IOException {\n        _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l));\n    }\n\n    @Override\n    public void writeNumber(double d) throws IOException {\n        _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException {\n        _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal dec) throws IOException {\n        if (dec == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_NUMBER_FLOAT, dec);\n        }\n    }\n\n    @Override\n    public void writeNumber(BigInteger v) throws IOException {\n        if (v == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_NUMBER_INT, v);\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException {\n        \n        _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue);\n    }\n\n    @Override\n    public void writeBoolean(boolean state) throws IOException {\n        _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);\n    }\n\n    @Override\n    public void writeNull() throws IOException {\n        _append(JsonToken.VALUE_NULL);\n    }\n\n    \n\n    @Override\n    public void writeObject(Object value) throws IOException {\n        if (value == null) {\n            writeNull();\n            return;\n        }\n        Class<?> raw = value.getClass();\n        if (raw == byte[].class || (value instanceof RawValue)) {\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n            return;\n        }\n        if (_objectCodec == null) {\n            \n\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n        } else {\n            _objectCodec.writeValue(this, value);\n        }\n    }\n\n    @Override\n    public void writeTree(TreeNode node) throws IOException {\n        if (node == null) {\n            writeNull();\n            return;\n        }\n\n        if (_objectCodec == null) {\n            \n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, node);\n        } else {\n            _objectCodec.writeTree(this, node);\n        }\n    }\n\n    \n\n    @Override\n    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException {\n        \n        byte[] copy = new byte[len];\n        System.arraycopy(data, offset, copy, 0, len);\n        writeObject(copy);\n    }\n\n    \n    @Override\n    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) {\n        throw new UnsupportedOperationException();\n    }\n\n    \n\n    @Override\n    public boolean canWriteTypeId() {\n        return _hasNativeTypeIds;\n    }\n\n    @Override\n    public boolean canWriteObjectId() {\n        return _hasNativeObjectIds;\n    }\n    \n    @Override\n    public void writeTypeId(Object id) {\n        _typeId = id;\n        _hasNativeId = true;\n    }\n    \n    @Override\n    public void writeObjectId(Object id) {\n        _objectId = id;\n        _hasNativeId = true;\n    }\n\n    \n\n    @Override\n    public void copyCurrentEvent(JsonParser p) throws IOException {\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(p);\n        }\n        switch (p.getCurrentToken()) {\n        case START_OBJECT:\n            writeStartObject();\n            break;\n        case END_OBJECT:\n            writeEndObject();\n            break;\n        case START_ARRAY:\n            writeStartArray();\n            break;\n        case END_ARRAY:\n            writeEndArray();\n            break;\n        case FIELD_NAME:\n            writeFieldName(p.getCurrentName());\n            break;\n        case VALUE_STRING:\n            if (p.hasTextCharacters()) {\n                writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());\n            } else {\n                writeString(p.getText());\n            }\n            break;\n        case VALUE_NUMBER_INT:\n            switch (p.getNumberType()) {\n            case INT:\n                writeNumber(p.getIntValue());\n                break;\n            case BIG_INTEGER:\n                writeNumber(p.getBigIntegerValue());\n                break;\n            default:\n                writeNumber(p.getLongValue());\n            }\n            break;\n        case VALUE_NUMBER_FLOAT:\n                \n                switch (p.getNumberType()) {\n                case BIG_DECIMAL:\n                    writeNumber(p.getDecimalValue());\n                    break;\n                case FLOAT:\n                    writeNumber(p.getFloatValue());\n                    break;\n                default:\n                    writeNumber(p.getDoubleValue());\n            }\n            break;\n        case VALUE_TRUE:\n            writeBoolean(true);\n            break;\n        case VALUE_FALSE:\n            writeBoolean(false);\n            break;\n        case VALUE_NULL:\n            writeNull();\n            break;\n        case VALUE_EMBEDDED_OBJECT:\n            writeObject(p.getEmbeddedObject());\n            break;\n        default:\n            throw new RuntimeException(\"Internal error: should never end up through this code path\");\n        }\n    }\n    \n    @Override\n    public void copyCurrentStructure(JsonParser jp) throws IOException {\n        JsonToken t = jp.getCurrentToken();\n\n        \n        if (t == JsonToken.FIELD_NAME) {\n            if (_mayHaveNativeIds) {\n                _checkNativeIds(jp);\n            }\n            writeFieldName(jp.getCurrentName());\n            t = jp.nextToken();\n            \n        }\n\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(jp);\n        }\n        \n        switch (t) {\n        case START_ARRAY:\n            writeStartArray();\n            while (jp.nextToken() != JsonToken.END_ARRAY) {\n                copyCurrentStructure(jp);\n            }\n            writeEndArray();\n            break;\n        case START_OBJECT:\n            writeStartObject();\n            while (jp.nextToken() != JsonToken.END_OBJECT) {\n                copyCurrentStructure(jp);\n            }\n            writeEndObject();\n            break;\n        default: \n            copyCurrentEvent(jp);\n        }\n    }\n\n    \n    private final void _checkNativeIds(JsonParser jp) throws IOException {\n        if ((_typeId = jp.getTypeId()) != null) {\n            _hasNativeId = true;\n        }\n        if ((_objectId = jp.getObjectId()) != null) {\n            _hasNativeId = true;\n        }\n    }\n    \n    \n\n    protected final void _append(JsonToken type) {\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, _objectId, _typeId)\n                : _last.append(_appendAt, type);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1; \n        }\n    }\n\n    protected final void _append(JsonToken type, Object value) {\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, value, _objectId, _typeId)\n                : _last.append(_appendAt, type, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }\n\n    protected final void _appendRaw(int rawType, Object value) {\n        Segment next = _hasNativeId\n                ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId)\n                : _last.appendRaw(_appendAt, rawType, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }\n\n    @Override\n    protected void _reportUnsupportedOperation() {\n        throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\");\n    }\n    \n    \n\n    protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds) {\n            super(0);\n            _segment = firstSeg;\n            _segmentPtr = -1; \n            _codec = codec;\n            _parsingContext = JsonReadContext.createRootContext(null);\n            _hasNativeTypeIds = hasNativeTypeIds;\n            _hasNativeObjectIds = hasNativeObjectIds;\n            _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds);\n        }\n\n        public void setLocation(JsonLocation l) {\n            _location = l;\n        }\n        \n        @Override\n        public ObjectCodec getCodec() { return _codec; }\n\n        @Override\n        public void setCodec(ObjectCodec c) { _codec = c; }\n\n        @Override\n        public Version version() {\n            return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n        }\n\n        \n        \n        public JsonToken peekNextToken() throws IOException {\n            \n            if (_closed) return null;\n            Segment seg = _segment;\n            int ptr = _segmentPtr+1;\n            if (ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                seg = (seg == null) ? null : seg.next();\n            }\n            return (seg == null) ? null : seg.type(ptr);\n        }\n        \n        \n\n        @Override\n        public void close() throws IOException {\n            if (!_closed) {\n                _closed = true;\n            }\n        }\n\n        \n        \n        @Override\n        public JsonToken nextToken() throws IOException {\n            \n            if (_closed || (_segment == null)) return null;\n\n            \n            if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) {\n                _segmentPtr = 0;\n                _segment = _segment.next();\n                if (_segment == null) {\n                    return null;\n                }\n            }\n            _currToken = _segment.type(_segmentPtr);\n            \n            if (_currToken == JsonToken.FIELD_NAME) {\n                Object ob = _currentObject();\n                String name = (ob instanceof String) ? ((String) ob) : ob.toString();\n                _parsingContext.setCurrentName(name);\n            } else if (_currToken == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            } else if (_currToken == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n            } else if (_currToken == JsonToken.END_OBJECT\n                    || _currToken == JsonToken.END_ARRAY) {\n                \n                _parsingContext = _parsingContext.getParent();\n                \n                if (_parsingContext == null) {\n                    _parsingContext = JsonReadContext.createRootContext(null);\n                }\n            }\n            return _currToken;\n        }\n\n        @Override\n        public String nextFieldName() throws IOException {\n            \n            if (_closed || (_segment == null)) return null;\n\n            int ptr = _segmentPtr+1;\n            if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) {\n                _segmentPtr = ptr;\n                Object ob = _segment.get(ptr); \n                String name = (ob instanceof String) ? ((String) ob) : ob.toString();\n                _parsingContext.setCurrentName(name);\n                return name;\n            }\n            return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null;\n        }\n\n        @Override\n        public boolean isClosed() { return _closed; }\n\n        \n\n        @Override\n        public JsonStreamContext getParsingContext() { return _parsingContext; }\n\n        @Override\n        public JsonLocation getTokenLocation() { return getCurrentLocation(); }\n\n        @Override\n        public JsonLocation getCurrentLocation() {\n            return (_location == null) ? JsonLocation.NA : _location;\n        }\n\n        @Override\n        public String getCurrentName() {\n            \n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                JsonReadContext parent = _parsingContext.getParent();\n                return parent.getCurrentName();\n            }\n            return _parsingContext.getCurrentName();\n        }\n\n        @Override\n        public void overrideCurrentName(String name) {\n            \n            JsonReadContext ctxt = _parsingContext;\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                ctxt = ctxt.getParent();\n            }\n            try {\n                ctxt.setCurrentName(name);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        \n\n        @Override\n        public String getText() {\n            \n            if (_currToken == JsonToken.VALUE_STRING\n                    || _currToken == JsonToken.FIELD_NAME) {\n                Object ob = _currentObject();\n                if (ob instanceof String) {\n                    return (String) ob;\n                }\n                return (ob == null) ? null : ob.toString();\n            }\n            if (_currToken == null) {\n                return null;\n            }\n            switch (_currToken) {\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                Object ob = _currentObject();\n                return (ob == null) ? null : ob.toString();\n            default:\n            \treturn _currToken.asString();\n            }\n        }\n\n        @Override\n        public char[] getTextCharacters() {\n            String str = getText();\n            return (str == null) ? null : str.toCharArray();\n        }\n\n        @Override\n        public int getTextLength() {\n            String str = getText();\n            return (str == null) ? 0 : str.length();\n        }\n\n        @Override\n        public int getTextOffset() { return 0; }\n\n        @Override\n        public boolean hasTextCharacters() {\n            \n            return false;\n        }\n        \n        \n\n        @Override\n        public BigInteger getBigIntegerValue() throws IOException {\n            Number n = getNumberValue();\n            if (n instanceof BigInteger) {\n                return (BigInteger) n;\n            }\n            if (getNumberType() == NumberType.BIG_DECIMAL) {\n                return ((BigDecimal) n).toBigInteger();\n            }\n            \n            return BigInteger.valueOf(n.longValue());\n        }\n\n        @Override\n        public BigDecimal getDecimalValue() throws IOException {\n            Number n = getNumberValue();\n            if (n instanceof BigDecimal) {\n                return (BigDecimal) n;\n            }\n            switch (getNumberType()) {\n            case INT:\n            case LONG:\n                return BigDecimal.valueOf(n.longValue());\n            case BIG_INTEGER:\n                return new BigDecimal((BigInteger) n);\n            default:\n            }\n            \n            return BigDecimal.valueOf(n.doubleValue());\n        }\n\n        @Override\n        public double getDoubleValue() throws IOException {\n            return getNumberValue().doubleValue();\n        }\n\n        @Override\n        public float getFloatValue() throws IOException {\n            return getNumberValue().floatValue();\n        }\n\n        @Override\n        public int getIntValue() throws IOException {\n            \n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                return ((Number) _currentObject()).intValue();\n            }\n            return getNumberValue().intValue();\n        }\n\n        @Override\n        public long getLongValue() throws IOException {\n            return getNumberValue().longValue();\n        }\n\n        @Override\n        public NumberType getNumberType() throws IOException {\n            Number n = getNumberValue();\n            if (n instanceof Integer) return NumberType.INT;\n            if (n instanceof Long) return NumberType.LONG;\n            if (n instanceof Double) return NumberType.DOUBLE;\n            if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL;\n            if (n instanceof BigInteger) return NumberType.BIG_INTEGER;\n            if (n instanceof Float) return NumberType.FLOAT;\n            if (n instanceof Short) return NumberType.INT;       \n            return null;\n        }\n\n        @Override\n        public final Number getNumberValue() throws IOException {\n            _checkIsNumber();\n            Object value = _currentObject();\n            if (value instanceof Number) {\n                return (Number) value;\n            }\n            \n            \n            \n            if (value instanceof String) {\n                String str = (String) value;\n                if (str.indexOf('.') >= 0) {\n                    return Double.parseDouble(str);\n                }\n                return Long.parseLong(str);\n            }\n            if (value == null) {\n                return null;\n            }\n            throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \"\n                    +value.getClass().getName());\n        }\n\n        \n\n        @Override\n        public Object getEmbeddedObject() {\n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                return _currentObject();\n            }\n            return null;\n        }\n\n        @Override\n        @SuppressWarnings(\"resource\")\n        public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException {\n            \n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                \n                Object ob = _currentObject();\n                if (ob instanceof byte[]) {\n                    return (byte[]) ob;\n                }\n                \n            }\n            if (_currToken != JsonToken.VALUE_STRING) {\n                throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\");\n            }\n            final String str = getText();\n            if (str == null) {\n                return null;\n            }\n            ByteArrayBuilder builder = _byteBuilder;\n            if (builder == null) {\n                _byteBuilder = builder = new ByteArrayBuilder(100);\n            } else {\n                _byteBuilder.reset();\n            }\n            _decodeBase64(str, builder, b64variant);\n            return builder.toByteArray();\n        }\n\n        @Override\n        public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException {\n            byte[] data = getBinaryValue(b64variant);\n            if (data != null) {\n                out.write(data, 0, data.length);\n                return data.length;\n            }\n            return 0;\n        }\n\n        \n\n        @Override\n        public boolean canReadObjectId() {\n            return _hasNativeObjectIds;\n        }\n\n        @Override\n        public boolean canReadTypeId() {\n            return _hasNativeTypeIds;\n        }\n\n        @Override\n        public Object getTypeId() {\n            return _segment.findTypeId(_segmentPtr);\n        }\n\n        @Override\n        public Object getObjectId() {\n            return _segment.findObjectId(_segmentPtr);\n        }\n        \n        \n\n        protected final Object _currentObject() {\n            return _segment.get(_segmentPtr);\n        }\n\n        protected final void _checkIsNumber() throws JsonParseException {\n            if (_currToken == null || !_currToken.isNumeric()) {\n                throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");\n            }\n        }\n\n        @Override\n        protected void _handleEOF() throws JsonParseException {\n            _throwInternal();\n        }\n    }\n    \n    \n    protected final static class Segment { public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { }\n\n        \n\n        public JsonToken type(int index) {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return TOKEN_TYPES_BY_INDEX[ix];\n        }\n\n        public int rawType(int index) {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return ix;\n        }\n        \n        public Object get(int index) {\n            return _tokens[index];\n        }\n\n        public Segment next() { return _next; }\n\n        \n        public boolean hasIds() {\n            return _nativeIds != null;\n        }\n        \n        \n        \n        public Segment append(int index, JsonToken tokenType) {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, objectId, typeId);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object value) {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, value);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, value);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, value, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, value, objectId, typeId);\n            return _next;\n        }\n\n        public Segment appendRaw(int index, int rawTokenType, Object value) {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, rawTokenType, value);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, rawTokenType, value);\n            return _next;\n        }\n\n        public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, rawTokenType, value, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, rawTokenType, value, objectId, typeId);\n            return _next;\n        }\n\n        private void set(int index, JsonToken tokenType) {\n            \n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, JsonToken tokenType, Object objectId, Object typeId) {\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private void set(int index, JsonToken tokenType, Object value) {\n            _tokens[index] = value;\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) {\n            _tokens[index] = value;\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private void set(int index, int rawTokenType, Object value) {\n            _tokens[index] = value;\n            long typeCode = (long) rawTokenType;\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) {\n            _tokens[index] = value;\n            long typeCode = (long) rawTokenType;\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private final void assignNativeIds(int index, Object objectId, Object typeId) {\n            if (_nativeIds == null) {\n                _nativeIds = new TreeMap<Integer,Object>();\n            }\n            if (objectId != null) {\n                _nativeIds.put(_objectIdIndex(index), objectId);\n            }\n            if (typeId != null) {\n                _nativeIds.put(_typeIdIndex(index), typeId);\n            }\n        }\n\n        \n        public Object findObjectId(int index) {\n            return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index));\n        }\n        \n        \n        public Object findTypeId(int index) {\n            return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index));\n        }\n\n        private final int _typeIdIndex(int i) { return i+i; }\n        private final int _objectIdIndex(int i) { return i+i+1; }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.util;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.TreeMap;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserMinimalBase;\nimport com.fasterxml.jackson.core.json.JsonReadContext;\nimport com.fasterxml.jackson.core.json.JsonWriteContext;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.databind.*;\n\n\npublic class TokenBuffer extends JsonGenerator { protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; protected int _generatorFeatures; protected boolean _closed; protected boolean _hasNativeTypeIds; protected boolean _hasNativeObjectIds; protected boolean _mayHaveNativeIds; protected boolean _forceBigDecimal; protected Segment _first; protected Segment _last; protected int _appendAt; protected Object _typeId; protected Object _objectId; protected boolean _hasNativeId = false; protected JsonWriteContext _writeContext; @Deprecated public TokenBuffer(ObjectCodec codec) {\n        this(codec, false);\n    }\n\n    \n    public TokenBuffer(ObjectCodec codec, boolean hasNativeIds) {\n        _objectCodec = codec;\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        \n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = hasNativeIds;\n        _hasNativeObjectIds = hasNativeIds;\n\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n    }\n\n    \n    public TokenBuffer(JsonParser p) {\n        this(p, null);\n    }\n\n    \n    public TokenBuffer(JsonParser p, DeserializationContext ctxt) {\n        _objectCodec = p.getCodec();\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        \n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = p.canReadTypeId();\n        _hasNativeObjectIds = p.canReadObjectId();\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n        _forceBigDecimal = (ctxt == null) ? false\n                : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS);\n    }\n\n    \n    public TokenBuffer forceUseOfBigDecimal(boolean b) {\n        _forceBigDecimal = b;\n        return this;\n    }\n\n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    \n    public JsonParser asParser() {\n        return asParser(_objectCodec);\n    }\n\n    \n    public JsonParser asParser(ObjectCodec codec) {\n        return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds);\n    }\n\n    \n    public JsonParser asParser(JsonParser src) {\n        Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds);\n        p.setLocation(src.getTokenLocation());\n        return p;\n    }\n    \n    \n\n    public JsonToken firstToken() {\n        if (_first != null) {\n            return _first.type(0);\n        }\n        return null;\n    }\n    \n    \n\n    \n    @SuppressWarnings(\"resource\")\n    public TokenBuffer append(TokenBuffer other) throws IOException {\n        \n        if (!_hasNativeTypeIds) {  \n            _hasNativeTypeIds = other.canWriteTypeId();\n        }\n        if (!_hasNativeObjectIds) {\n            _hasNativeObjectIds = other.canWriteObjectId();\n        }\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n        \n        JsonParser p = other.asParser();\n        while (p.nextToken() != null) {\n            copyCurrentStructure(p);\n        }\n        return this;\n    }\n    \n    \n    public void serialize(JsonGenerator gen) throws IOException {\n        Segment segment = _first;\n        int ptr = -1;\n\n        final boolean checkIds = _mayHaveNativeIds;\n        boolean hasIds = checkIds && (segment.hasIds());\n\n        while (true) {\n            if (++ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                segment = segment.next();\n                if (segment == null) break;\n                hasIds = checkIds && (segment.hasIds());\n            }\n            JsonToken t = segment.type(ptr);\n            if (t == null) break;\n\n            if (hasIds) {\n                Object id = segment.findObjectId(ptr);\n                if (id != null) {\n                    gen.writeObjectId(id);\n                }\n                id = segment.findTypeId(ptr);\n                if (id != null) {\n                    gen.writeTypeId(id);\n                }\n            }\n            \n            \n            switch (t) {\n            case START_OBJECT:\n                gen.writeStartObject();\n                break;\n            case END_OBJECT:\n                gen.writeEndObject();\n                break;\n            case START_ARRAY:\n                gen.writeStartArray();\n                break;\n            case END_ARRAY:\n                gen.writeEndArray();\n                break;\n            case FIELD_NAME:\n            {\n                \n                Object ob = segment.get(ptr);\n                if (ob instanceof SerializableString) {\n                    gen.writeFieldName((SerializableString) ob);\n                } else {\n                    gen.writeFieldName((String) ob);\n                }\n            }\n                break;\n            case VALUE_STRING:\n                {\n                    Object ob = segment.get(ptr);\n                    if (ob instanceof SerializableString) {\n                        gen.writeString((SerializableString) ob);\n                    } else {\n                        gen.writeString((String) ob);\n                    }\n                }\n                break;\n            case VALUE_NUMBER_INT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Integer) {\n                        gen.writeNumber((Integer) n);\n                    } else if (n instanceof BigInteger) {\n                        gen.writeNumber((BigInteger) n);\n                    } else if (n instanceof Long) {\n                        gen.writeNumber((Long) n);\n                    } else if (n instanceof Short) {\n                        gen.writeNumber((Short) n);\n                    } else {\n                        gen.writeNumber(((Number) n).intValue());\n                    }\n                }\n                break;\n            case VALUE_NUMBER_FLOAT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Double) {\n                        gen.writeNumber(((Double) n).doubleValue());\n                    } else if (n instanceof BigDecimal) {\n                        gen.writeNumber((BigDecimal) n);\n                    } else if (n instanceof Float) {\n                        gen.writeNumber(((Float) n).floatValue());\n                    } else if (n == null) {\n                        gen.writeNull();\n                    } else if (n instanceof String) {\n                        gen.writeNumber((String) n);\n                    } else {\n                        throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\");\n                    }\n                }\n                break;\n            case VALUE_TRUE:\n                gen.writeBoolean(true);\n                break;\n            case VALUE_FALSE:\n                gen.writeBoolean(false);\n                break;\n            case VALUE_NULL:\n                gen.writeNull();\n                break;\n            case VALUE_EMBEDDED_OBJECT:\n                {\n                    Object value = segment.get(ptr);\n                    if (value instanceof RawValue) {\n                        ((RawValue) value).serialize(gen);\n                    } else {\n                        gen.writeObject(value);\n                    }\n                }\n                break;\n            default:\n                throw new RuntimeException(\"Internal error: should never end up through this code path\");\n            }\n        }\n    }\n\n    \n    public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n        if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) {\n            copyCurrentStructure(p);\n            return this;\n        }\n        \n        JsonToken t;\n        writeStartObject();\n        do {\n            copyCurrentStructure(p);\n        } while ((t = p.nextToken()) == JsonToken.FIELD_NAME);\n        if (t != JsonToken.END_OBJECT) {\n            throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t);\n        }\n        writeEndObject();\n        return this;\n    }\n\n    @Override\n    @SuppressWarnings(\"resource\")\n    public String toString() {\n        \n        final int MAX_COUNT = 100;\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[TokenBuffer: \");\n\n        \n        \n        JsonParser jp = asParser();\n        int count = 0;\n        final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;\n\n        while (true) {\n            JsonToken t;\n            try {\n                t = jp.nextToken();\n                if (t == null) break;\n\n                if (hasNativeIds) {\n                    _appendNativeIds(sb);\n                }\n                        \n                if (count < MAX_COUNT) {\n                    if (count > 0) {\n                        sb.append(\", \");\n                    }\n                    sb.append(t.toString());\n                    if (t == JsonToken.FIELD_NAME) {\n                        sb.append('(');\n                        sb.append(jp.getCurrentName());\n                        sb.append(')');\n                    }\n                }\n            } catch (IOException ioe) { \n                throw new IllegalStateException(ioe);\n            }\n            ++count;\n        }\n\n        if (count >= MAX_COUNT) {\n            sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\");\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n\n    private final void _appendNativeIds(StringBuilder sb) {\n        Object objectId = _last.findObjectId(_appendAt-1);\n        if (objectId != null) {\n            sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']');\n        }\n        Object typeId = _last.findTypeId(_appendAt-1);\n        if (typeId != null) {\n            sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']');\n        }\n    }\n    \n    \n\n    @Override\n    public JsonGenerator enable(Feature f) {\n        _generatorFeatures |= f.getMask();\n        return this;\n    }\n\n    @Override\n    public JsonGenerator disable(Feature f) {\n        _generatorFeatures &= ~f.getMask();\n        return this;\n    }\n\n    \n\n    @Override\n    public boolean isEnabled(Feature f) {\n        return (_generatorFeatures & f.getMask()) != 0;\n    }\n\n    @Override\n    public int getFeatureMask() {\n        return _generatorFeatures;\n    }\n\n    @Override\n    public JsonGenerator setFeatureMask(int mask) {\n        _generatorFeatures = mask;\n        return this;\n    }\n    \n    @Override\n    public JsonGenerator useDefaultPrettyPrinter() {\n        \n        return this;\n    }\n\n    @Override\n    public JsonGenerator setCodec(ObjectCodec oc) {\n        _objectCodec = oc;\n        return this;\n    }\n\n    @Override\n    public ObjectCodec getCodec() { return _objectCodec; }\n\n    @Override\n    public final JsonWriteContext getOutputContext() { return _writeContext; }\n\n    \n    \n    \n    @Override\n    public boolean canWriteBinaryNatively() {\n        return true;\n    }\n    \n    \n\n    @Override\n    public void flush() throws IOException {  }\n\n    @Override\n    public void close() throws IOException {\n        _closed = true;\n    }\n\n    @Override\n    public boolean isClosed() { return _closed; }\n\n    \n\n    @Override\n    public final void writeStartArray() throws IOException {\n        _append(JsonToken.START_ARRAY);\n        _writeContext = _writeContext.createChildArrayContext();\n    }\n\n    @Override\n    public final void writeEndArray() throws IOException {\n        _append(JsonToken.END_ARRAY);\n        \n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n            _writeContext = c;\n        }\n    }\n\n    @Override\n    public final void writeStartObject() throws IOException {\n        _append(JsonToken.START_OBJECT);\n        _writeContext = _writeContext.createChildObjectContext();\n    }\n\n    @Override\n    public final void writeEndObject() throws IOException {\n        _append(JsonToken.END_OBJECT);\n        \n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n            _writeContext = c;\n        }\n    }\n\n    @Override\n    public final void writeFieldName(String name) throws IOException {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name);\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name.getValue());\n    }\n    \n    \n\n    @Override\n    public void writeString(String text) throws IOException {\n        if (text == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_STRING, text);\n        }\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException {\n        writeString(new String(text, offset, len));\n    }\n\n    @Override\n    public void writeString(SerializableString text) throws IOException {\n        if (text == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_STRING, text);\n        }\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException {\n        \n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int length) throws IOException {\n        \n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(SerializableString text) throws IOException {\n        _reportUnsupportedOperation();\n    }\n    \n    @Override\n    public void writeRaw(char[] text, int offset, int len) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(char c) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(String text) throws IOException {\n        _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));\n    }\n\n    @Override\n    public void writeRawValue(String text, int offset, int len) throws IOException {\n        if (offset > 0 || len != text.length()) {\n            text = text.substring(offset, offset+len);\n        }\n        _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));\n    }\n\n    @Override\n    public void writeRawValue(char[] text, int offset, int len) throws IOException {\n        _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len));\n    }\n\n    \n\n    @Override\n    public void writeNumber(short i) throws IOException {\n        _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i));\n    }\n\n    @Override\n    public void writeNumber(int i) throws IOException {\n        _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i));\n    }\n\n    @Override\n    public void writeNumber(long l) throws IOException {\n        _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l));\n    }\n\n    @Override\n    public void writeNumber(double d) throws IOException {\n        _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException {\n        _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal dec) throws IOException {\n        if (dec == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_NUMBER_FLOAT, dec);\n        }\n    }\n\n    @Override\n    public void writeNumber(BigInteger v) throws IOException {\n        if (v == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_NUMBER_INT, v);\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException {\n        \n        _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue);\n    }\n\n    @Override\n    public void writeBoolean(boolean state) throws IOException {\n        _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);\n    }\n\n    @Override\n    public void writeNull() throws IOException {\n        _append(JsonToken.VALUE_NULL);\n    }\n\n    \n\n    @Override\n    public void writeObject(Object value) throws IOException {\n        if (value == null) {\n            writeNull();\n            return;\n        }\n        Class<?> raw = value.getClass();\n        if (raw == byte[].class || (value instanceof RawValue)) {\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n            return;\n        }\n        if (_objectCodec == null) {\n            \n\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n        } else {\n            _objectCodec.writeValue(this, value);\n        }\n    }\n\n    @Override\n    public void writeTree(TreeNode node) throws IOException {\n        if (node == null) {\n            writeNull();\n            return;\n        }\n\n        if (_objectCodec == null) {\n            \n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, node);\n        } else {\n            _objectCodec.writeTree(this, node);\n        }\n    }\n\n    \n\n    @Override\n    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException {\n        \n        byte[] copy = new byte[len];\n        System.arraycopy(data, offset, copy, 0, len);\n        writeObject(copy);\n    }\n\n    \n    @Override\n    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) {\n        throw new UnsupportedOperationException();\n    }\n\n    \n\n    @Override\n    public boolean canWriteTypeId() {\n        return _hasNativeTypeIds;\n    }\n\n    @Override\n    public boolean canWriteObjectId() {\n        return _hasNativeObjectIds;\n    }\n    \n    @Override\n    public void writeTypeId(Object id) {\n        _typeId = id;\n        _hasNativeId = true;\n    }\n    \n    @Override\n    public void writeObjectId(Object id) {\n        _objectId = id;\n        _hasNativeId = true;\n    }\n\n    \n\n    @Override\n    public void copyCurrentEvent(JsonParser p) throws IOException {\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(p);\n        }\n        switch (p.getCurrentToken()) {\n        case START_OBJECT:\n            writeStartObject();\n            break;\n        case END_OBJECT:\n            writeEndObject();\n            break;\n        case START_ARRAY:\n            writeStartArray();\n            break;\n        case END_ARRAY:\n            writeEndArray();\n            break;\n        case FIELD_NAME:\n            writeFieldName(p.getCurrentName());\n            break;\n        case VALUE_STRING:\n            if (p.hasTextCharacters()) {\n                writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());\n            } else {\n                writeString(p.getText());\n            }\n            break;\n        case VALUE_NUMBER_INT:\n            switch (p.getNumberType()) {\n            case INT:\n                writeNumber(p.getIntValue());\n                break;\n            case BIG_INTEGER:\n                writeNumber(p.getBigIntegerValue());\n                break;\n            default:\n                writeNumber(p.getLongValue());\n            }\n            break;\n        case VALUE_NUMBER_FLOAT:\n            if (_forceBigDecimal) {\n                \n                writeNumber(p.getDecimalValue());\n            } else {\n                switch (p.getNumberType()) {\n                case BIG_DECIMAL:\n                    writeNumber(p.getDecimalValue());\n                    break;\n                case FLOAT:\n                    writeNumber(p.getFloatValue());\n                    break;\n                default:\n                    writeNumber(p.getDoubleValue());\n                }\n            }\n            break;\n        case VALUE_TRUE:\n            writeBoolean(true);\n            break;\n        case VALUE_FALSE:\n            writeBoolean(false);\n            break;\n        case VALUE_NULL:\n            writeNull();\n            break;\n        case VALUE_EMBEDDED_OBJECT:\n            writeObject(p.getEmbeddedObject());\n            break;\n        default:\n            throw new RuntimeException(\"Internal error: should never end up through this code path\");\n        }\n    }\n    \n    @Override\n    public void copyCurrentStructure(JsonParser jp) throws IOException {\n        JsonToken t = jp.getCurrentToken();\n\n        \n        if (t == JsonToken.FIELD_NAME) {\n            if (_mayHaveNativeIds) {\n                _checkNativeIds(jp);\n            }\n            writeFieldName(jp.getCurrentName());\n            t = jp.nextToken();\n            \n        }\n\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(jp);\n        }\n        \n        switch (t) {\n        case START_ARRAY:\n            writeStartArray();\n            while (jp.nextToken() != JsonToken.END_ARRAY) {\n                copyCurrentStructure(jp);\n            }\n            writeEndArray();\n            break;\n        case START_OBJECT:\n            writeStartObject();\n            while (jp.nextToken() != JsonToken.END_OBJECT) {\n                copyCurrentStructure(jp);\n            }\n            writeEndObject();\n            break;\n        default: \n            copyCurrentEvent(jp);\n        }\n    }\n\n    \n    private final void _checkNativeIds(JsonParser jp) throws IOException {\n        if ((_typeId = jp.getTypeId()) != null) {\n            _hasNativeId = true;\n        }\n        if ((_objectId = jp.getObjectId()) != null) {\n            _hasNativeId = true;\n        }\n    }\n    \n    \n\n    protected final void _append(JsonToken type) {\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, _objectId, _typeId)\n                : _last.append(_appendAt, type);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1; \n        }\n    }\n\n    protected final void _append(JsonToken type, Object value) {\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, value, _objectId, _typeId)\n                : _last.append(_appendAt, type, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }\n\n    protected final void _appendRaw(int rawType, Object value) {\n        Segment next = _hasNativeId\n                ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId)\n                : _last.appendRaw(_appendAt, rawType, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }\n\n    @Override\n    protected void _reportUnsupportedOperation() {\n        throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\");\n    }\n    \n    \n\n    protected final static class Parser extends ParserMinimalBase { protected ObjectCodec _codec; protected final boolean _hasNativeTypeIds; protected final boolean _hasNativeObjectIds; protected final boolean _hasNativeIds; protected Segment _segment; protected int _segmentPtr; protected JsonReadContext _parsingContext; protected boolean _closed; protected transient ByteArrayBuilder _byteBuilder; protected JsonLocation _location = null; public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds, boolean hasNativeObjectIds) {\n            super(0);\n            _segment = firstSeg;\n            _segmentPtr = -1; \n            _codec = codec;\n            _parsingContext = JsonReadContext.createRootContext(null);\n            _hasNativeTypeIds = hasNativeTypeIds;\n            _hasNativeObjectIds = hasNativeObjectIds;\n            _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds);\n        }\n\n        public void setLocation(JsonLocation l) {\n            _location = l;\n        }\n        \n        @Override\n        public ObjectCodec getCodec() { return _codec; }\n\n        @Override\n        public void setCodec(ObjectCodec c) { _codec = c; }\n\n        @Override\n        public Version version() {\n            return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n        }\n\n        \n        \n        public JsonToken peekNextToken() throws IOException {\n            \n            if (_closed) return null;\n            Segment seg = _segment;\n            int ptr = _segmentPtr+1;\n            if (ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                seg = (seg == null) ? null : seg.next();\n            }\n            return (seg == null) ? null : seg.type(ptr);\n        }\n        \n        \n\n        @Override\n        public void close() throws IOException {\n            if (!_closed) {\n                _closed = true;\n            }\n        }\n\n        \n        \n        @Override\n        public JsonToken nextToken() throws IOException {\n            \n            if (_closed || (_segment == null)) return null;\n\n            \n            if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) {\n                _segmentPtr = 0;\n                _segment = _segment.next();\n                if (_segment == null) {\n                    return null;\n                }\n            }\n            _currToken = _segment.type(_segmentPtr);\n            \n            if (_currToken == JsonToken.FIELD_NAME) {\n                Object ob = _currentObject();\n                String name = (ob instanceof String) ? ((String) ob) : ob.toString();\n                _parsingContext.setCurrentName(name);\n            } else if (_currToken == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            } else if (_currToken == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n            } else if (_currToken == JsonToken.END_OBJECT\n                    || _currToken == JsonToken.END_ARRAY) {\n                \n                _parsingContext = _parsingContext.getParent();\n                \n                if (_parsingContext == null) {\n                    _parsingContext = JsonReadContext.createRootContext(null);\n                }\n            }\n            return _currToken;\n        }\n\n        @Override\n        public String nextFieldName() throws IOException {\n            \n            if (_closed || (_segment == null)) return null;\n\n            int ptr = _segmentPtr+1;\n            if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) {\n                _segmentPtr = ptr;\n                Object ob = _segment.get(ptr); \n                String name = (ob instanceof String) ? ((String) ob) : ob.toString();\n                _parsingContext.setCurrentName(name);\n                return name;\n            }\n            return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null;\n        }\n\n        @Override\n        public boolean isClosed() { return _closed; }\n\n        \n\n        @Override\n        public JsonStreamContext getParsingContext() { return _parsingContext; }\n\n        @Override\n        public JsonLocation getTokenLocation() { return getCurrentLocation(); }\n\n        @Override\n        public JsonLocation getCurrentLocation() {\n            return (_location == null) ? JsonLocation.NA : _location;\n        }\n\n        @Override\n        public String getCurrentName() {\n            \n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                JsonReadContext parent = _parsingContext.getParent();\n                return parent.getCurrentName();\n            }\n            return _parsingContext.getCurrentName();\n        }\n\n        @Override\n        public void overrideCurrentName(String name) {\n            \n            JsonReadContext ctxt = _parsingContext;\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                ctxt = ctxt.getParent();\n            }\n            try {\n                ctxt.setCurrentName(name);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        \n\n        @Override\n        public String getText() {\n            \n            if (_currToken == JsonToken.VALUE_STRING\n                    || _currToken == JsonToken.FIELD_NAME) {\n                Object ob = _currentObject();\n                if (ob instanceof String) {\n                    return (String) ob;\n                }\n                return (ob == null) ? null : ob.toString();\n            }\n            if (_currToken == null) {\n                return null;\n            }\n            switch (_currToken) {\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                Object ob = _currentObject();\n                return (ob == null) ? null : ob.toString();\n            default:\n            \treturn _currToken.asString();\n            }\n        }\n\n        @Override\n        public char[] getTextCharacters() {\n            String str = getText();\n            return (str == null) ? null : str.toCharArray();\n        }\n\n        @Override\n        public int getTextLength() {\n            String str = getText();\n            return (str == null) ? 0 : str.length();\n        }\n\n        @Override\n        public int getTextOffset() { return 0; }\n\n        @Override\n        public boolean hasTextCharacters() {\n            \n            return false;\n        }\n        \n        \n\n        @Override\n        public BigInteger getBigIntegerValue() throws IOException {\n            Number n = getNumberValue();\n            if (n instanceof BigInteger) {\n                return (BigInteger) n;\n            }\n            if (getNumberType() == NumberType.BIG_DECIMAL) {\n                return ((BigDecimal) n).toBigInteger();\n            }\n            \n            return BigInteger.valueOf(n.longValue());\n        }\n\n        @Override\n        public BigDecimal getDecimalValue() throws IOException {\n            Number n = getNumberValue();\n            if (n instanceof BigDecimal) {\n                return (BigDecimal) n;\n            }\n            switch (getNumberType()) {\n            case INT:\n            case LONG:\n                return BigDecimal.valueOf(n.longValue());\n            case BIG_INTEGER:\n                return new BigDecimal((BigInteger) n);\n            default:\n            }\n            \n            return BigDecimal.valueOf(n.doubleValue());\n        }\n\n        @Override\n        public double getDoubleValue() throws IOException {\n            return getNumberValue().doubleValue();\n        }\n\n        @Override\n        public float getFloatValue() throws IOException {\n            return getNumberValue().floatValue();\n        }\n\n        @Override\n        public int getIntValue() throws IOException {\n            \n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                return ((Number) _currentObject()).intValue();\n            }\n            return getNumberValue().intValue();\n        }\n\n        @Override\n        public long getLongValue() throws IOException {\n            return getNumberValue().longValue();\n        }\n\n        @Override\n        public NumberType getNumberType() throws IOException {\n            Number n = getNumberValue();\n            if (n instanceof Integer) return NumberType.INT;\n            if (n instanceof Long) return NumberType.LONG;\n            if (n instanceof Double) return NumberType.DOUBLE;\n            if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL;\n            if (n instanceof BigInteger) return NumberType.BIG_INTEGER;\n            if (n instanceof Float) return NumberType.FLOAT;\n            if (n instanceof Short) return NumberType.INT;       \n            return null;\n        }\n\n        @Override\n        public final Number getNumberValue() throws IOException {\n            _checkIsNumber();\n            Object value = _currentObject();\n            if (value instanceof Number) {\n                return (Number) value;\n            }\n            \n            \n            \n            if (value instanceof String) {\n                String str = (String) value;\n                if (str.indexOf('.') >= 0) {\n                    return Double.parseDouble(str);\n                }\n                return Long.parseLong(str);\n            }\n            if (value == null) {\n                return null;\n            }\n            throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \"\n                    +value.getClass().getName());\n        }\n\n        \n\n        @Override\n        public Object getEmbeddedObject() {\n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                return _currentObject();\n            }\n            return null;\n        }\n\n        @Override\n        @SuppressWarnings(\"resource\")\n        public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException {\n            \n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                \n                Object ob = _currentObject();\n                if (ob instanceof byte[]) {\n                    return (byte[]) ob;\n                }\n                \n            }\n            if (_currToken != JsonToken.VALUE_STRING) {\n                throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\");\n            }\n            final String str = getText();\n            if (str == null) {\n                return null;\n            }\n            ByteArrayBuilder builder = _byteBuilder;\n            if (builder == null) {\n                _byteBuilder = builder = new ByteArrayBuilder(100);\n            } else {\n                _byteBuilder.reset();\n            }\n            _decodeBase64(str, builder, b64variant);\n            return builder.toByteArray();\n        }\n\n        @Override\n        public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException {\n            byte[] data = getBinaryValue(b64variant);\n            if (data != null) {\n                out.write(data, 0, data.length);\n                return data.length;\n            }\n            return 0;\n        }\n\n        \n\n        @Override\n        public boolean canReadObjectId() {\n            return _hasNativeObjectIds;\n        }\n\n        @Override\n        public boolean canReadTypeId() {\n            return _hasNativeTypeIds;\n        }\n\n        @Override\n        public Object getTypeId() {\n            return _segment.findTypeId(_segmentPtr);\n        }\n\n        @Override\n        public Object getObjectId() {\n            return _segment.findObjectId(_segmentPtr);\n        }\n        \n        \n\n        protected final Object _currentObject() {\n            return _segment.get(_segmentPtr);\n        }\n\n        protected final void _checkIsNumber() throws JsonParseException {\n            if (_currToken == null || !_currToken.isNumeric()) {\n                throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");\n            }\n        }\n\n        @Override\n        protected void _handleEOF() throws JsonParseException {\n            _throwInternal();\n        }\n    }\n    \n    \n    protected final static class Segment { public final static int TOKENS_PER_SEGMENT = 16; private final static JsonToken[] TOKEN_TYPES_BY_INDEX; static { TOKEN_TYPES_BY_INDEX = new JsonToken[16]; JsonToken[] t = JsonToken.values(); System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1)); } protected Segment _next; protected long _tokenTypes; protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT]; protected TreeMap<Integer,Object> _nativeIds; public Segment() { }\n\n        \n\n        public JsonToken type(int index) {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return TOKEN_TYPES_BY_INDEX[ix];\n        }\n\n        public int rawType(int index) {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return ix;\n        }\n        \n        public Object get(int index) {\n            return _tokens[index];\n        }\n\n        public Segment next() { return _next; }\n\n        \n        public boolean hasIds() {\n            return _nativeIds != null;\n        }\n        \n        \n        \n        public Segment append(int index, JsonToken tokenType) {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId) {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, objectId, typeId);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object value) {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, value);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, value);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, value, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, value, objectId, typeId);\n            return _next;\n        }\n\n        public Segment appendRaw(int index, int rawTokenType, Object value) {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, rawTokenType, value);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, rawTokenType, value);\n            return _next;\n        }\n\n        public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId) {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, rawTokenType, value, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, rawTokenType, value, objectId, typeId);\n            return _next;\n        }\n\n        private void set(int index, JsonToken tokenType) {\n            \n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, JsonToken tokenType, Object objectId, Object typeId) {\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private void set(int index, JsonToken tokenType, Object value) {\n            _tokens[index] = value;\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId) {\n            _tokens[index] = value;\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private void set(int index, int rawTokenType, Object value) {\n            _tokens[index] = value;\n            long typeCode = (long) rawTokenType;\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId) {\n            _tokens[index] = value;\n            long typeCode = (long) rawTokenType;\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private final void assignNativeIds(int index, Object objectId, Object typeId) {\n            if (_nativeIds == null) {\n                _nativeIds = new TreeMap<Integer,Object>();\n            }\n            if (objectId != null) {\n                _nativeIds.put(_objectIdIndex(index), objectId);\n            }\n            if (typeId != null) {\n                _nativeIds.put(_typeIdIndex(index), typeId);\n            }\n        }\n\n        \n        public Object findObjectId(int index) {\n            return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index));\n        }\n        \n        \n        public Object findTypeId(int index) {\n            return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index));\n        }\n\n        private final int _typeIdIndex(int i) { return i+i; }\n        private final int _objectIdIndex(int i) { return i+i+1; }\n    }\n}\n",
      "buggy_signatures": [
        "public TokenBuffer(ObjectCodec codec, boolean hasNativeIds)",
        "public TokenBuffer(JsonParser p)",
        "public TokenBuffer(JsonParser p, DeserializationContext ctxt)",
        "public Version version()",
        "public JsonParser asParser()",
        "public JsonParser asParser(ObjectCodec codec)",
        "public JsonParser asParser(JsonParser src)",
        "public JsonToken firstToken()",
        "public TokenBuffer append(TokenBuffer other) throws IOException",
        "public void serialize(JsonGenerator gen) throws IOException",
        "public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public String toString()",
        "private final void _appendNativeIds(StringBuilder sb)",
        "public JsonGenerator enable(Feature f)",
        "public JsonGenerator disable(Feature f)",
        "public boolean isEnabled(Feature f)",
        "public int getFeatureMask()",
        "public JsonGenerator setFeatureMask(int mask)",
        "public JsonGenerator useDefaultPrettyPrinter()",
        "public JsonGenerator setCodec(ObjectCodec oc)",
        "public ObjectCodec getCodec()",
        "public final JsonWriteContext getOutputContext()",
        "public boolean canWriteBinaryNatively()",
        "public void flush() throws IOException",
        "public void close() throws IOException",
        "public boolean isClosed()",
        "public final void writeStartArray() throws IOException",
        "public final void writeEndArray() throws IOException",
        "public final void writeStartObject() throws IOException",
        "public final void writeEndObject() throws IOException",
        "public final void writeFieldName(String name) throws IOException",
        "public void writeFieldName(SerializableString name) throws IOException",
        "public void writeString(String text) throws IOException",
        "public void writeString(char[] text, int offset, int len) throws IOException",
        "public void writeString(SerializableString text) throws IOException",
        "public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException",
        "public void writeUTF8String(byte[] text, int offset, int length) throws IOException",
        "public void writeRaw(String text) throws IOException",
        "public void writeRaw(String text, int offset, int len) throws IOException",
        "public void writeRaw(SerializableString text) throws IOException",
        "public void writeRaw(char[] text, int offset, int len) throws IOException",
        "public void writeRaw(char c) throws IOException",
        "public void writeRawValue(String text) throws IOException",
        "public void writeRawValue(String text, int offset, int len) throws IOException",
        "public void writeRawValue(char[] text, int offset, int len) throws IOException",
        "public void writeNumber(short i) throws IOException",
        "public void writeNumber(int i) throws IOException",
        "public void writeNumber(long l) throws IOException",
        "public void writeNumber(double d) throws IOException",
        "public void writeNumber(float f) throws IOException",
        "public void writeNumber(BigDecimal dec) throws IOException",
        "public void writeNumber(BigInteger v) throws IOException",
        "public void writeNumber(String encodedValue) throws IOException",
        "public void writeBoolean(boolean state) throws IOException",
        "public void writeNull() throws IOException",
        "public void writeObject(Object value) throws IOException",
        "public void writeTree(TreeNode node) throws IOException",
        "public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException",
        "public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength)",
        "public boolean canWriteTypeId()",
        "public boolean canWriteObjectId()",
        "public void writeTypeId(Object id)",
        "public void writeObjectId(Object id)",
        "public void copyCurrentEvent(JsonParser p) throws IOException",
        "public void copyCurrentStructure(JsonParser jp) throws IOException",
        "private final void _checkNativeIds(JsonParser jp) throws IOException",
        "protected final void _append(JsonToken type)",
        "protected final void _append(JsonToken type, Object value)",
        "protected final void _appendRaw(int rawType, Object value)",
        "protected void _reportUnsupportedOperation()",
        "public void setLocation(JsonLocation l)",
        "public ObjectCodec getCodec()",
        "public void setCodec(ObjectCodec c)",
        "public Version version()",
        "public JsonToken peekNextToken() throws IOException",
        "public void close() throws IOException",
        "public JsonToken nextToken() throws IOException",
        "public String nextFieldName() throws IOException",
        "public boolean isClosed()",
        "public JsonStreamContext getParsingContext()",
        "public JsonLocation getTokenLocation()",
        "public JsonLocation getCurrentLocation()",
        "public String getCurrentName()",
        "public void overrideCurrentName(String name)",
        "public String getText()",
        "public char[] getTextCharacters()",
        "public int getTextLength()",
        "public int getTextOffset()",
        "public boolean hasTextCharacters()",
        "public BigInteger getBigIntegerValue() throws IOException",
        "public BigDecimal getDecimalValue() throws IOException",
        "public double getDoubleValue() throws IOException",
        "public float getFloatValue() throws IOException",
        "public int getIntValue() throws IOException",
        "public long getLongValue() throws IOException",
        "public NumberType getNumberType() throws IOException",
        "public final Number getNumberValue() throws IOException",
        "public Object getEmbeddedObject()",
        "public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException",
        "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException",
        "public boolean canReadObjectId()",
        "public boolean canReadTypeId()",
        "public Object getTypeId()",
        "public Object getObjectId()",
        "protected final Object _currentObject()",
        "protected final void _checkIsNumber() throws JsonParseException",
        "protected void _handleEOF() throws JsonParseException",
        "public JsonToken type(int index)",
        "public int rawType(int index)",
        "public Object get(int index)",
        "public Segment next()",
        "public boolean hasIds()",
        "public Segment append(int index, JsonToken tokenType)",
        "public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId)",
        "public Segment append(int index, JsonToken tokenType, Object value)",
        "public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId)",
        "public Segment appendRaw(int index, int rawTokenType, Object value)",
        "public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId)",
        "private void set(int index, JsonToken tokenType)",
        "private void set(int index, JsonToken tokenType, Object objectId, Object typeId)",
        "private void set(int index, JsonToken tokenType, Object value)",
        "private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId)",
        "private void set(int index, int rawTokenType, Object value)",
        "private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId)",
        "private final void assignNativeIds(int index, Object objectId, Object typeId)",
        "public Object findObjectId(int index)",
        "public Object findTypeId(int index)",
        "private final int _typeIdIndex(int i)",
        "private final int _objectIdIndex(int i)"
      ],
      "fixed_signatures": [
        "public TokenBuffer(ObjectCodec codec, boolean hasNativeIds)",
        "public TokenBuffer(JsonParser p)",
        "public TokenBuffer(JsonParser p, DeserializationContext ctxt)",
        "public TokenBuffer forceUseOfBigDecimal(boolean b)",
        "public Version version()",
        "public JsonParser asParser()",
        "public JsonParser asParser(ObjectCodec codec)",
        "public JsonParser asParser(JsonParser src)",
        "public JsonToken firstToken()",
        "public TokenBuffer append(TokenBuffer other) throws IOException",
        "public void serialize(JsonGenerator gen) throws IOException",
        "public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "public String toString()",
        "private final void _appendNativeIds(StringBuilder sb)",
        "public JsonGenerator enable(Feature f)",
        "public JsonGenerator disable(Feature f)",
        "public boolean isEnabled(Feature f)",
        "public int getFeatureMask()",
        "public JsonGenerator setFeatureMask(int mask)",
        "public JsonGenerator useDefaultPrettyPrinter()",
        "public JsonGenerator setCodec(ObjectCodec oc)",
        "public ObjectCodec getCodec()",
        "public final JsonWriteContext getOutputContext()",
        "public boolean canWriteBinaryNatively()",
        "public void flush() throws IOException",
        "public void close() throws IOException",
        "public boolean isClosed()",
        "public final void writeStartArray() throws IOException",
        "public final void writeEndArray() throws IOException",
        "public final void writeStartObject() throws IOException",
        "public final void writeEndObject() throws IOException",
        "public final void writeFieldName(String name) throws IOException",
        "public void writeFieldName(SerializableString name) throws IOException",
        "public void writeString(String text) throws IOException",
        "public void writeString(char[] text, int offset, int len) throws IOException",
        "public void writeString(SerializableString text) throws IOException",
        "public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException",
        "public void writeUTF8String(byte[] text, int offset, int length) throws IOException",
        "public void writeRaw(String text) throws IOException",
        "public void writeRaw(String text, int offset, int len) throws IOException",
        "public void writeRaw(SerializableString text) throws IOException",
        "public void writeRaw(char[] text, int offset, int len) throws IOException",
        "public void writeRaw(char c) throws IOException",
        "public void writeRawValue(String text) throws IOException",
        "public void writeRawValue(String text, int offset, int len) throws IOException",
        "public void writeRawValue(char[] text, int offset, int len) throws IOException",
        "public void writeNumber(short i) throws IOException",
        "public void writeNumber(int i) throws IOException",
        "public void writeNumber(long l) throws IOException",
        "public void writeNumber(double d) throws IOException",
        "public void writeNumber(float f) throws IOException",
        "public void writeNumber(BigDecimal dec) throws IOException",
        "public void writeNumber(BigInteger v) throws IOException",
        "public void writeNumber(String encodedValue) throws IOException",
        "public void writeBoolean(boolean state) throws IOException",
        "public void writeNull() throws IOException",
        "public void writeObject(Object value) throws IOException",
        "public void writeTree(TreeNode node) throws IOException",
        "public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException",
        "public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength)",
        "public boolean canWriteTypeId()",
        "public boolean canWriteObjectId()",
        "public void writeTypeId(Object id)",
        "public void writeObjectId(Object id)",
        "public void copyCurrentEvent(JsonParser p) throws IOException",
        "public void copyCurrentStructure(JsonParser jp) throws IOException",
        "private final void _checkNativeIds(JsonParser jp) throws IOException",
        "protected final void _append(JsonToken type)",
        "protected final void _append(JsonToken type, Object value)",
        "protected final void _appendRaw(int rawType, Object value)",
        "protected void _reportUnsupportedOperation()",
        "public void setLocation(JsonLocation l)",
        "public ObjectCodec getCodec()",
        "public void setCodec(ObjectCodec c)",
        "public Version version()",
        "public JsonToken peekNextToken() throws IOException",
        "public void close() throws IOException",
        "public JsonToken nextToken() throws IOException",
        "public String nextFieldName() throws IOException",
        "public boolean isClosed()",
        "public JsonStreamContext getParsingContext()",
        "public JsonLocation getTokenLocation()",
        "public JsonLocation getCurrentLocation()",
        "public String getCurrentName()",
        "public void overrideCurrentName(String name)",
        "public String getText()",
        "public char[] getTextCharacters()",
        "public int getTextLength()",
        "public int getTextOffset()",
        "public boolean hasTextCharacters()",
        "public BigInteger getBigIntegerValue() throws IOException",
        "public BigDecimal getDecimalValue() throws IOException",
        "public double getDoubleValue() throws IOException",
        "public float getFloatValue() throws IOException",
        "public int getIntValue() throws IOException",
        "public long getLongValue() throws IOException",
        "public NumberType getNumberType() throws IOException",
        "public final Number getNumberValue() throws IOException",
        "public Object getEmbeddedObject()",
        "public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException",
        "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException",
        "public boolean canReadObjectId()",
        "public boolean canReadTypeId()",
        "public Object getTypeId()",
        "public Object getObjectId()",
        "protected final Object _currentObject()",
        "protected final void _checkIsNumber() throws JsonParseException",
        "protected void _handleEOF() throws JsonParseException",
        "public JsonToken type(int index)",
        "public int rawType(int index)",
        "public Object get(int index)",
        "public Segment next()",
        "public boolean hasIds()",
        "public Segment append(int index, JsonToken tokenType)",
        "public Segment append(int index, JsonToken tokenType, Object objectId, Object typeId)",
        "public Segment append(int index, JsonToken tokenType, Object value)",
        "public Segment append(int index, JsonToken tokenType, Object value, Object objectId, Object typeId)",
        "public Segment appendRaw(int index, int rawTokenType, Object value)",
        "public Segment appendRaw(int index, int rawTokenType, Object value, Object objectId, Object typeId)",
        "private void set(int index, JsonToken tokenType)",
        "private void set(int index, JsonToken tokenType, Object objectId, Object typeId)",
        "private void set(int index, JsonToken tokenType, Object value)",
        "private void set(int index, JsonToken tokenType, Object value, Object objectId, Object typeId)",
        "private void set(int index, int rawTokenType, Object value)",
        "private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId)",
        "private final void assignNativeIds(int index, Object objectId, Object typeId)",
        "public Object findObjectId(int index)",
        "public Object findTypeId(int index)",
        "private final int _typeIdIndex(int i)",
        "private final int _objectIdIndex(int i)"
      ],
      "methods": [
        {
          "buggy_method": "  protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; /** * Bit flag composed of bits that indicate which * {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s",
          "fixed_method": "  protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults(); protected ObjectCodec _objectCodec; /** * Bit flag composed of bits that indicate which * {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s",
          "diff": [
            "@@ -77,6 +77,7 @@",
            "      *\n",
            "      * @since 2.7\n",
            "      */\n",
            "+    protected boolean _forceBigDecimal;\n",
            "     \n",
            "     /*\n",
            "     /**********************************************************\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  public Version version() {\n  return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n  }",
          "fixed_method": "  public TokenBuffer forceUseOfBigDecimal(boolean b) {\n  _forceBigDecimal = b;\n  return this;\n  }",
          "diff": [
            "@@ -185,11 +186,17 @@",
            "         _hasNativeTypeIds = p.canReadTypeId();\n",
            "         _hasNativeObjectIds = p.canReadObjectId();\n",
            "         _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n",
            "+        _forceBigDecimal = (ctxt == null) ? false\n",
            "+                : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS);\n",
            "     }\n",
            " \n",
            "     /**\n",
            "      * @since 2.7\n",
            "      */\n",
            "+    public TokenBuffer forceUseOfBigDecimal(boolean b) {\n",
            "+        _forceBigDecimal = b;\n",
            "+        return this;\n",
            "+    }\n",
            " \n",
            "     @Override\n",
            "     public Version version() {\n"
          ],
          "changed_lines": 6
        },
        {
          "buggy_method": "  public void copyCurrentEvent(JsonParser p) throws IOException {\n  if (_mayHaveNativeIds) {\n  _checkNativeIds(p);\n  }\n  switch (p.getCurrentToken()) {\n  case START_OBJECT:\n  writeStartObject();\n  break;\n  case END_OBJECT:\n  writeEndObject();\n  break;\n  case START_ARRAY:\n  writeStartArray();\n  break;\n  case END_ARRAY:\n  writeEndArray();\n  break;\n  case FIELD_NAME:\n  writeFieldName(p.getCurrentName());\n  break;\n  case VALUE_STRING:\n  if (p.hasTextCharacters()) {\n  writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());\n  } else {\n  writeString(p.getText());\n  }\n  break;\n  case VALUE_NUMBER_INT:\n  switch (p.getNumberType()) {\n  case INT:\n  writeNumber(p.getIntValue());\n  break;\n  case BIG_INTEGER:\n  writeNumber(p.getBigIntegerValue());\n  break;\n  default:\n  writeNumber(p.getLongValue());\n  }\n  break;\n  case VALUE_NUMBER_FLOAT:\n  \n  switch (p.getNumberType()) {\n  case BIG_DECIMAL:\n  writeNumber(p.getDecimalValue());\n  break;\n  case FLOAT:\n  writeNumber(p.getFloatValue());\n  break;\n  default:\n  writeNumber(p.getDoubleValue());\n  }\n  break;\n  case VALUE_TRUE:\n  writeBoolean(true);\n  break;\n  case VALUE_FALSE:\n  writeBoolean(false);\n  break;\n  case VALUE_NULL:\n  writeNull();\n  break;\n  case VALUE_EMBEDDED_OBJECT:\n  writeObject(p.getEmbeddedObject());\n  break;\n  default:\n  throw new RuntimeException(\"Internal error: should never end up through this code path\");\n  }\n  }",
          "fixed_method": "  public void copyCurrentEvent(JsonParser p) throws IOException {\n  if (_mayHaveNativeIds) {\n  _checkNativeIds(p);\n  }\n  switch (p.getCurrentToken()) {\n  case START_OBJECT:\n  writeStartObject();\n  break;\n  case END_OBJECT:\n  writeEndObject();\n  break;\n  case START_ARRAY:\n  writeStartArray();\n  break;\n  case END_ARRAY:\n  writeEndArray();\n  break;\n  case FIELD_NAME:\n  writeFieldName(p.getCurrentName());\n  break;\n  case VALUE_STRING:\n  if (p.hasTextCharacters()) {\n  writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());\n  } else {\n  writeString(p.getText());\n  }\n  break;\n  case VALUE_NUMBER_INT:\n  switch (p.getNumberType()) {\n  case INT:\n  writeNumber(p.getIntValue());\n  break;\n  case BIG_INTEGER:\n  writeNumber(p.getBigIntegerValue());\n  break;\n  default:\n  writeNumber(p.getLongValue());\n  }\n  break;\n  case VALUE_NUMBER_FLOAT:\n  if (_forceBigDecimal) {\n  \n  writeNumber(p.getDecimalValue());\n  } else {\n  switch (p.getNumberType()) {\n  case BIG_DECIMAL:\n  writeNumber(p.getDecimalValue());\n  break;\n  case FLOAT:\n  writeNumber(p.getFloatValue());\n  break;\n  default:\n  writeNumber(p.getDoubleValue());\n  }\n  }\n  break;\n  case VALUE_TRUE:\n  writeBoolean(true);\n  break;\n  case VALUE_FALSE:\n  writeBoolean(false);\n  break;\n  case VALUE_NULL:\n  writeNull();\n  break;\n  case VALUE_EMBEDDED_OBJECT:\n  writeObject(p.getEmbeddedObject());\n  break;\n  default:\n  throw new RuntimeException(\"Internal error: should never end up through this code path\");\n  }\n  }",
          "diff": [
            "@@ -956,11 +963,14 @@",
            "             }\n",
            "             break;\n",
            "         case VALUE_NUMBER_FLOAT:\n",
            "+            if (_forceBigDecimal) {\n",
            "                 /* 10-Oct-2015, tatu: Ideally we would first determine whether underlying\n",
            "                  *   number is already decoded into a number (in which case might as well\n",
            "                  *   access as number); or is still retained as text (in which case we\n",
            "                  *   should further defer decoding that may not need BigDecimal):\n",
            "                  */\n",
            "+                writeNumber(p.getDecimalValue());\n",
            "+            } else {\n",
            "                 switch (p.getNumberType()) {\n",
            "                 case BIG_DECIMAL:\n",
            "                     writeNumber(p.getDecimalValue());\n",
            "@@ -970,6 +980,7 @@",
            "                     break;\n",
            "                 default:\n",
            "                     writeNumber(p.getDoubleValue());\n",
            "+                }\n",
            "             }\n",
            "             break;\n",
            "         case VALUE_TRUE:\n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
