{
  "bug_id": "21",
  "failed_tests": {
    "org.apache.commons.lang3.time.DateUtilsTest": [
      {
        "methodName": "testIsSameLocalTime_Cal",
        "error": "junit.framework.AssertionFailedError",
        "message": "LANG-677",
        "fail_line": "        assertFalse(\"LANG-677\", DateUtils.isSameLocalTime(cal3, cal4));",
        "test_source": "  public void testIsSameLocalTime_Cal() {\n  GregorianCalendar cal1 = new GregorianCalendar(TimeZone.getTimeZone(\"GMT+1\"));\n  GregorianCalendar cal2 = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-1\"));\n  cal1.set(2004, 6, 9, 13, 45, 0);\n  cal1.set(Calendar.MILLISECOND, 0);\n  cal2.set(2004, 6, 9, 13, 45, 0);\n  cal2.set(Calendar.MILLISECOND, 0);\n  assertEquals(true, DateUtils.isSameLocalTime(cal1, cal2));\n\n  Calendar cal3 = Calendar.getInstance();\n  Calendar cal4 = Calendar.getInstance();\n  cal3.set(2004, 6, 9, 4,  0, 0);\n  cal4.set(2004, 6, 9, 16, 0, 0);\n  cal3.set(Calendar.MILLISECOND, 0);\n  cal4.set(Calendar.MILLISECOND, 0);\n  assertFalse(\"LANG-677\", DateUtils.isSameLocalTime(cal3, cal4));\n  \n  cal2.set(2004, 6, 9, 11, 45, 0);\n  assertEquals(false, DateUtils.isSameLocalTime(cal1, cal2));\n  try {\n  DateUtils.isSameLocalTime((Calendar) null, (Calendar) null);\n  fail();\n  } catch (IllegalArgumentException ex) {}\n  }",
        "stack": [
          "DateUtilsTest.testIsSameLocalTime_Cal line 237"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/lang3/time/DateUtils.java",
      "buggy_full_code": "\npackage org.apache.commons.lang3.time;\n\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.TimeZone;\n\n\npublic class DateUtils { public static final TimeZone UTC_TIME_ZONE = TimeZone.getTimeZone(\"GMT\"); public static final long MILLIS_PER_SECOND = 1000; public static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND; public static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE; public static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR; public final static int SEMI_MONTH = 1001; private static final int[][] fields = {\n            {Calendar.MILLISECOND},\n            {Calendar.SECOND},\n            {Calendar.MINUTE},\n            {Calendar.HOUR_OF_DAY, Calendar.HOUR},\n            {Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM \n                \n            },\n            {Calendar.MONTH, DateUtils.SEMI_MONTH},\n            {Calendar.YEAR},\n            {Calendar.ERA}};\n\n    \n    public final static int RANGE_WEEK_SUNDAY = 1; public final static int RANGE_WEEK_MONDAY = 2; public final static int RANGE_WEEK_RELATIVE = 3; public final static int RANGE_WEEK_CENTER = 4; public final static int RANGE_MONTH_SUNDAY = 5; public final static int RANGE_MONTH_MONDAY = 6; public final static int MODIFY_TRUNCATE = 0; public final static int MODIFY_ROUND = 1; public final static int MODIFY_CEILING= 2; public DateUtils() {\n        super();\n    }\n\n    \n    \n    public static boolean isSameDay(Date date1, Date date2) {\n        if (date1 == null || date2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar cal1 = Calendar.getInstance();\n        cal1.setTime(date1);\n        Calendar cal2 = Calendar.getInstance();\n        cal2.setTime(date2);\n        return isSameDay(cal1, cal2);\n    }\n\n    \n    public static boolean isSameDay(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));\n    }\n\n    \n    \n    public static boolean isSameInstant(Date date1, Date date2) {\n        if (date1 == null || date2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return date1.getTime() == date2.getTime();\n    }\n\n    \n    public static boolean isSameInstant(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return cal1.getTime().getTime() == cal2.getTime().getTime();\n    }\n\n    \n    \n    public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());\n    }\n\n    \n    \n    public static Date parseDate(String str, String... parsePatterns) throws ParseException {\n        return parseDateWithLeniency(str, parsePatterns, true);\n    }\n    \n  \n    \n    public static Date parseDateStrictly(String str, String... parsePatterns) throws ParseException {\n        return parseDateWithLeniency(str, parsePatterns, false);\n    }\n\n    \n    private static Date parseDateWithLeniency(String str, String[] parsePatterns, boolean lenient) throws ParseException {\n        if (str == null || parsePatterns == null) {\n            throw new IllegalArgumentException(\"Date and Patterns must not be null\");\n        }\n        \n        SimpleDateFormat parser = new SimpleDateFormat();\n        parser.setLenient(lenient);\n        ParsePosition pos = new ParsePosition(0);\n        for (int i = 0; i < parsePatterns.length; i++) {\n\n            String pattern = parsePatterns[i];\n\n            \n            if (parsePatterns[i].endsWith(\"ZZ\")) {\n                pattern = pattern.substring(0, pattern.length() - 1);\n            }\n            \n            parser.applyPattern(pattern);\n            pos.setIndex(0);\n\n            String str2 = str;\n            \n            if (parsePatterns[i].endsWith(\"ZZ\")) {\n                str2 = str.replaceAll(\"([-+][0-9][0-9]):([0-9][0-9])$\", \"$1$2\"); \n            }\n\n            Date date = parser.parse(str2, pos);\n            if (date != null && pos.getIndex() == str2.length()) {\n                return date;\n            }\n        }\n        throw new ParseException(\"Unable to parse the date: \" + str, -1);\n    }\n\n    \n    \n    public static Date addYears(Date date, int amount) {\n        return add(date, Calendar.YEAR, amount);\n    }\n\n    \n    \n    public static Date addMonths(Date date, int amount) {\n        return add(date, Calendar.MONTH, amount);\n    }\n\n    \n    \n    public static Date addWeeks(Date date, int amount) {\n        return add(date, Calendar.WEEK_OF_YEAR, amount);\n    }\n\n    \n    \n    public static Date addDays(Date date, int amount) {\n        return add(date, Calendar.DAY_OF_MONTH, amount);\n    }\n\n    \n    \n    public static Date addHours(Date date, int amount) {\n        return add(date, Calendar.HOUR_OF_DAY, amount);\n    }\n\n    \n    \n    public static Date addMinutes(Date date, int amount) {\n        return add(date, Calendar.MINUTE, amount);\n    }\n\n    \n    \n    public static Date addSeconds(Date date, int amount) {\n        return add(date, Calendar.SECOND, amount);\n    }\n\n    \n    \n    public static Date addMilliseconds(Date date, int amount) {\n        return add(date, Calendar.MILLISECOND, amount);\n    }\n\n    \n    \n    private static Date add(Date date, int calendarField, int amount) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar c = Calendar.getInstance();\n        c.setTime(date);\n        c.add(calendarField, amount);\n        return c.getTime();\n    }\n    \n    \n    \n    public static Date setYears(Date date, int amount) {\n        return set(date, Calendar.YEAR, amount);\n    }\n\n    \n    \n    public static Date setMonths(Date date, int amount) {\n        return set(date, Calendar.MONTH, amount);\n    }\n\n    \n    \n    public static Date setDays(Date date, int amount) {\n        return set(date, Calendar.DAY_OF_MONTH, amount);\n    }\n\n    \n    \n    public static Date setHours(Date date, int amount) {\n        return set(date, Calendar.HOUR_OF_DAY, amount);\n    }\n\n    \n    \n    public static Date setMinutes(Date date, int amount) {\n        return set(date, Calendar.MINUTE, amount);\n    }\n    \n    \n    \n    public static Date setSeconds(Date date, int amount) {\n        return set(date, Calendar.SECOND, amount);\n    }\n\n    \n    \n    public static Date setMilliseconds(Date date, int amount) {\n        return set(date, Calendar.MILLISECOND, amount);\n    } \n    \n    \n    \n    private static Date set(Date date, int calendarField, int amount) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        \n        Calendar c = Calendar.getInstance();\n        c.setLenient(false);\n        c.setTime(date);\n        c.set(calendarField, amount);\n        return c.getTime();\n    }   \n\n    \n    \n    public static Calendar toCalendar(Date date) {\n        Calendar c = Calendar.getInstance();\n        c.setTime(date);\n        return c;\n    }\n    \n    \n    \n    public static Date round(Date date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(date);\n        modify(gval, field, MODIFY_ROUND);\n        return gval.getTime();\n    }\n\n    \n    public static Calendar round(Calendar date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar rounded = (Calendar) date.clone();\n        modify(rounded, field, MODIFY_ROUND);\n        return rounded;\n    }\n\n    \n    public static Date round(Object date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (date instanceof Date) {\n            return round((Date) date, field);\n        } else if (date instanceof Calendar) {\n            return round((Calendar) date, field).getTime();\n        } else {\n            throw new ClassCastException(\"Could not round \" + date);\n        }\n    }\n\n    \n    \n    public static Date truncate(Date date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(date);\n        modify(gval, field, MODIFY_TRUNCATE);\n        return gval.getTime();\n    }\n\n    \n    public static Calendar truncate(Calendar date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar truncated = (Calendar) date.clone();\n        modify(truncated, field, MODIFY_TRUNCATE);\n        return truncated;\n    }\n\n    \n    public static Date truncate(Object date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (date instanceof Date) {\n            return truncate((Date) date, field);\n        } else if (date instanceof Calendar) {\n            return truncate((Calendar) date, field).getTime();\n        } else {\n            throw new ClassCastException(\"Could not truncate \" + date);\n        }\n    }\n    \n  \n    \n    public static Date ceiling(Date date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(date);\n        modify(gval, field, MODIFY_CEILING);\n        return gval.getTime();\n    }\n\n    \n    public static Calendar ceiling(Calendar date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar ceiled = (Calendar) date.clone();\n        modify(ceiled, field, MODIFY_CEILING);\n        return ceiled;\n    }\n\n    \n    public static Date ceiling(Object date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (date instanceof Date) {\n            return ceiling((Date) date, field);\n        } else if (date instanceof Calendar) {\n            return ceiling((Calendar) date, field).getTime();\n        } else {\n            throw new ClassCastException(\"Could not find ceiling of for type: \" + date.getClass());\n        }\n    }\n\n    \n    \n    private static void modify(Calendar val, int field, int modType) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field == Calendar.MILLISECOND) {\n            return;\n        }\n\n        \n        \n        \n        \n        \n\n        Date date = val.getTime();\n        long time = date.getTime();\n        boolean done = false;\n\n        \n        int millisecs = val.get(Calendar.MILLISECOND);\n        if (MODIFY_TRUNCATE == modType || millisecs < 500) {\n            time = time - millisecs;\n        }\n        if (field == Calendar.SECOND) {\n            done = true;\n        }\n\n        \n        int seconds = val.get(Calendar.SECOND);\n        if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) {\n            time = time - (seconds * 1000L);\n        }\n        if (field == Calendar.MINUTE) {\n            done = true;\n        }\n\n        \n        int minutes = val.get(Calendar.MINUTE);\n        if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) {\n            time = time - (minutes * 60000L);\n        }\n\n        \n        if (date.getTime() != time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        \n\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    \n                    if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            \n                            \n                            \n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n\n                        } else if (field == Calendar.AM_PM) {\n                            \n                            \n                            \n                            if (val.get(Calendar.HOUR_OF_DAY) == 0) {\n                                val.add(Calendar.HOUR_OF_DAY, 12);\n                            } else {\n                                val.add(Calendar.HOUR_OF_DAY, -12);\n                                val.add(Calendar.DATE, 1);\n                            }\n\n                        } else {\n                            \n                            \n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            \n            int offset = 0;\n            boolean offsetSet = false;\n            \n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE) {\n                        \n                        \n                        \n                        offset = val.get(Calendar.DATE) - 1;\n                        \n                        \n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        \n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                        \n                        \n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset >= 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min = val.getActualMinimum(fields[i][0]);\n                int max = val.getActualMaximum(fields[i][0]);\n                \n                offset = val.get(fields[i][0]) - min;\n                \n                roundUp = offset > ((max - min) / 2);\n            }\n            \n            if (offset != 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }\n\n    \n    \n    public static Iterator<Calendar> iterator(Date focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(focus);\n        return iterator(gval, rangeStyle);\n    }\n\n    \n    public static Iterator<Calendar> iterator(Calendar focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar start = null;\n        Calendar end = null;\n        int startCutoff = Calendar.SUNDAY;\n        int endCutoff = Calendar.SATURDAY;\n        switch (rangeStyle) {\n            case RANGE_MONTH_SUNDAY:\n            case RANGE_MONTH_MONDAY:\n                \n                start = truncate(focus, Calendar.MONTH);\n                \n                end = (Calendar) start.clone();\n                end.add(Calendar.MONTH, 1);\n                end.add(Calendar.DATE, -1);\n                \n                if (rangeStyle == RANGE_MONTH_MONDAY) {\n                    startCutoff = Calendar.MONDAY;\n                    endCutoff = Calendar.SUNDAY;\n                }\n                break;\n            case RANGE_WEEK_SUNDAY:\n            case RANGE_WEEK_MONDAY:\n            case RANGE_WEEK_RELATIVE:\n            case RANGE_WEEK_CENTER:\n                \n                start = truncate(focus, Calendar.DATE);\n                end = truncate(focus, Calendar.DATE);\n                switch (rangeStyle) {\n                    case RANGE_WEEK_SUNDAY:\n                        \n                        break;\n                    case RANGE_WEEK_MONDAY:\n                        startCutoff = Calendar.MONDAY;\n                        endCutoff = Calendar.SUNDAY;\n                        break;\n                    case RANGE_WEEK_RELATIVE:\n                        startCutoff = focus.get(Calendar.DAY_OF_WEEK);\n                        endCutoff = startCutoff - 1;\n                        break;\n                    case RANGE_WEEK_CENTER:\n                        startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3;\n                        endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3;\n                        break;\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"The range style \" + rangeStyle + \" is not valid.\");\n        }\n        if (startCutoff < Calendar.SUNDAY) {\n            startCutoff += 7;\n        }\n        if (startCutoff > Calendar.SATURDAY) {\n            startCutoff -= 7;\n        }\n        if (endCutoff < Calendar.SUNDAY) {\n            endCutoff += 7;\n        }\n        if (endCutoff > Calendar.SATURDAY) {\n            endCutoff -= 7;\n        }\n        while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) {\n            start.add(Calendar.DATE, -1);\n        }\n        while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) {\n            end.add(Calendar.DATE, 1);\n        }\n        return new DateIterator(start, end);\n    }\n\n    \n    public static Iterator<?> iterator(Object focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (focus instanceof Date) {\n            return iterator((Date) focus, rangeStyle);\n        } else if (focus instanceof Calendar) {\n            return iterator((Calendar) focus, rangeStyle);\n        } else {\n            throw new ClassCastException(\"Could not iterate based on \" + focus);\n        }\n    }\n    \n    \n    public static long getFragmentInMilliseconds(Date date, int fragment) {\n        return getFragment(date, fragment, Calendar.MILLISECOND);    \n    }\n    \n    \n    public static long getFragmentInSeconds(Date date, int fragment) {\n        return getFragment(date, fragment, Calendar.SECOND);\n    }\n    \n    \n    public static long getFragmentInMinutes(Date date, int fragment) {\n        return getFragment(date, fragment, Calendar.MINUTE);\n    }\n    \n    \n    public static long getFragmentInHours(Date date, int fragment) {\n        return getFragment(date, fragment, Calendar.HOUR_OF_DAY);\n    }\n    \n    \n    public static long getFragmentInDays(Date date, int fragment) {\n        return getFragment(date, fragment, Calendar.DAY_OF_YEAR);\n    }\n\n    \n  public static long getFragmentInMilliseconds(Calendar calendar, int fragment) {\n    return getFragment(calendar, fragment, Calendar.MILLISECOND);\n  }\n    \n    public static long getFragmentInSeconds(Calendar calendar, int fragment) {\n        return getFragment(calendar, fragment, Calendar.SECOND);\n    }\n    \n    \n    public static long getFragmentInMinutes(Calendar calendar, int fragment) {\n        return getFragment(calendar, fragment, Calendar.MINUTE);\n    }\n    \n    \n    public static long getFragmentInHours(Calendar calendar, int fragment) {\n        return getFragment(calendar, fragment, Calendar.HOUR_OF_DAY);\n    }\n    \n    \n    public static long getFragmentInDays(Calendar calendar, int fragment) {\n        return getFragment(calendar, fragment, Calendar.DAY_OF_YEAR);\n    }\n    \n    \n    private static long getFragment(Date date, int fragment, int unit) {\n        if(date == null) {\n            throw  new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        return getFragment(calendar, fragment, unit);\n    }\n\n    \n    private static long getFragment(Calendar calendar, int fragment, int unit) {\n        if(calendar == null) {\n            throw  new IllegalArgumentException(\"The date must not be null\"); \n        }\n        long millisPerUnit = getMillisPerUnit(unit);\n        long result = 0;\n        \n        \n        switch (fragment) {\n            case Calendar.YEAR:\n                result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit;\n                break;\n            case Calendar.MONTH:\n                result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit;\n                break;\n        }\n\n        switch (fragment) {\n            \n            case Calendar.YEAR:\n            case Calendar.MONTH:\n            \n            \n            case Calendar.DAY_OF_YEAR:\n            case Calendar.DATE:\n                result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit;\n                \n            case Calendar.HOUR_OF_DAY:\n                result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit;\n                \n            case Calendar.MINUTE:\n                result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit;\n                \n            case Calendar.SECOND:\n                result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit;\n                break;\n            case Calendar.MILLISECOND: break;\n                default: throw new IllegalArgumentException(\"The fragment \" + fragment + \" is not supported\");\n        }\n        return result;\n    }\n    \n    \n    public static boolean truncatedEquals(Calendar cal1, Calendar cal2, int field) {\n        return truncatedCompareTo(cal1, cal2, field) == 0;\n    }\n\n    \n    public static boolean truncatedEquals(Date date1, Date date2, int field) {\n        return truncatedCompareTo(date1, date2, field) == 0;\n    }\n\n    \n    public static int truncatedCompareTo(Calendar cal1, Calendar cal2, int field) {\n        Calendar truncatedCal1 = truncate(cal1, field);\n        Calendar truncatedCal2 = truncate(cal2, field);\n        return truncatedCal1.compareTo(truncatedCal2);\n    }\n\n    \n    public static int truncatedCompareTo(Date date1, Date date2, int field) {\n        Date truncatedDate1 = truncate(date1, field);\n        Date truncatedDate2 = truncate(date2, field);\n        return truncatedDate1.compareTo(truncatedDate2);\n    }\n    \n    \n    private static long getMillisPerUnit(int unit) {\n        long result = Long.MAX_VALUE;\n        switch (unit) {\n            case Calendar.DAY_OF_YEAR:\n            case Calendar.DATE:\n                result = MILLIS_PER_DAY;\n                break;\n            case Calendar.HOUR_OF_DAY:\n                result = MILLIS_PER_HOUR;\n                break;\n            case Calendar.MINUTE:\n                result = MILLIS_PER_MINUTE;\n                break;\n            case Calendar.SECOND:\n                result = MILLIS_PER_SECOND;\n                break;\n            case Calendar.MILLISECOND:\n                result = 1;\n                break;\n            default: throw new IllegalArgumentException(\"The unit \" + unit + \" cannot be represented is milleseconds\");\n        }\n        return result;\n    }\n\n    \n    static class DateIterator implements Iterator<Calendar> { private final Calendar endFinal; private final Calendar spot; DateIterator(Calendar startFinal, Calendar endFinal) {\n            super();\n            this.endFinal = endFinal;\n            spot = startFinal;\n            spot.add(Calendar.DATE, -1);\n        }\n\n        \n        public boolean hasNext() {\n            return spot.before(endFinal);\n        }\n\n        \n        public Calendar next() {\n            if (spot.equals(endFinal)) {\n                throw new NoSuchElementException();\n            }\n            spot.add(Calendar.DATE, 1);\n            return (Calendar) spot.clone();\n        }\n\n        \n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n    \n}\n",
      "fixed_full_code": "\npackage org.apache.commons.lang3.time;\n\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.TimeZone;\n\n\npublic class DateUtils { public static final TimeZone UTC_TIME_ZONE = TimeZone.getTimeZone(\"GMT\"); public static final long MILLIS_PER_SECOND = 1000; public static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND; public static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE; public static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR; public final static int SEMI_MONTH = 1001; private static final int[][] fields = {\n            {Calendar.MILLISECOND},\n            {Calendar.SECOND},\n            {Calendar.MINUTE},\n            {Calendar.HOUR_OF_DAY, Calendar.HOUR},\n            {Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM \n                \n            },\n            {Calendar.MONTH, DateUtils.SEMI_MONTH},\n            {Calendar.YEAR},\n            {Calendar.ERA}};\n\n    \n    public final static int RANGE_WEEK_SUNDAY = 1; public final static int RANGE_WEEK_MONDAY = 2; public final static int RANGE_WEEK_RELATIVE = 3; public final static int RANGE_WEEK_CENTER = 4; public final static int RANGE_MONTH_SUNDAY = 5; public final static int RANGE_MONTH_MONDAY = 6; public final static int MODIFY_TRUNCATE = 0; public final static int MODIFY_ROUND = 1; public final static int MODIFY_CEILING= 2; public DateUtils() {\n        super();\n    }\n\n    \n    \n    public static boolean isSameDay(Date date1, Date date2) {\n        if (date1 == null || date2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar cal1 = Calendar.getInstance();\n        cal1.setTime(date1);\n        Calendar cal2 = Calendar.getInstance();\n        cal2.setTime(date2);\n        return isSameDay(cal1, cal2);\n    }\n\n    \n    public static boolean isSameDay(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));\n    }\n\n    \n    \n    public static boolean isSameInstant(Date date1, Date date2) {\n        if (date1 == null || date2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return date1.getTime() == date2.getTime();\n    }\n\n    \n    public static boolean isSameInstant(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return cal1.getTime().getTime() == cal2.getTime().getTime();\n    }\n\n    \n    \n    public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());\n    }\n\n    \n    \n    public static Date parseDate(String str, String... parsePatterns) throws ParseException {\n        return parseDateWithLeniency(str, parsePatterns, true);\n    }\n    \n  \n    \n    public static Date parseDateStrictly(String str, String... parsePatterns) throws ParseException {\n        return parseDateWithLeniency(str, parsePatterns, false);\n    }\n\n    \n    private static Date parseDateWithLeniency(String str, String[] parsePatterns, boolean lenient) throws ParseException {\n        if (str == null || parsePatterns == null) {\n            throw new IllegalArgumentException(\"Date and Patterns must not be null\");\n        }\n        \n        SimpleDateFormat parser = new SimpleDateFormat();\n        parser.setLenient(lenient);\n        ParsePosition pos = new ParsePosition(0);\n        for (int i = 0; i < parsePatterns.length; i++) {\n\n            String pattern = parsePatterns[i];\n\n            \n            if (parsePatterns[i].endsWith(\"ZZ\")) {\n                pattern = pattern.substring(0, pattern.length() - 1);\n            }\n            \n            parser.applyPattern(pattern);\n            pos.setIndex(0);\n\n            String str2 = str;\n            \n            if (parsePatterns[i].endsWith(\"ZZ\")) {\n                str2 = str.replaceAll(\"([-+][0-9][0-9]):([0-9][0-9])$\", \"$1$2\"); \n            }\n\n            Date date = parser.parse(str2, pos);\n            if (date != null && pos.getIndex() == str2.length()) {\n                return date;\n            }\n        }\n        throw new ParseException(\"Unable to parse the date: \" + str, -1);\n    }\n\n    \n    \n    public static Date addYears(Date date, int amount) {\n        return add(date, Calendar.YEAR, amount);\n    }\n\n    \n    \n    public static Date addMonths(Date date, int amount) {\n        return add(date, Calendar.MONTH, amount);\n    }\n\n    \n    \n    public static Date addWeeks(Date date, int amount) {\n        return add(date, Calendar.WEEK_OF_YEAR, amount);\n    }\n\n    \n    \n    public static Date addDays(Date date, int amount) {\n        return add(date, Calendar.DAY_OF_MONTH, amount);\n    }\n\n    \n    \n    public static Date addHours(Date date, int amount) {\n        return add(date, Calendar.HOUR_OF_DAY, amount);\n    }\n\n    \n    \n    public static Date addMinutes(Date date, int amount) {\n        return add(date, Calendar.MINUTE, amount);\n    }\n\n    \n    \n    public static Date addSeconds(Date date, int amount) {\n        return add(date, Calendar.SECOND, amount);\n    }\n\n    \n    \n    public static Date addMilliseconds(Date date, int amount) {\n        return add(date, Calendar.MILLISECOND, amount);\n    }\n\n    \n    \n    private static Date add(Date date, int calendarField, int amount) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar c = Calendar.getInstance();\n        c.setTime(date);\n        c.add(calendarField, amount);\n        return c.getTime();\n    }\n    \n    \n    \n    public static Date setYears(Date date, int amount) {\n        return set(date, Calendar.YEAR, amount);\n    }\n\n    \n    \n    public static Date setMonths(Date date, int amount) {\n        return set(date, Calendar.MONTH, amount);\n    }\n\n    \n    \n    public static Date setDays(Date date, int amount) {\n        return set(date, Calendar.DAY_OF_MONTH, amount);\n    }\n\n    \n    \n    public static Date setHours(Date date, int amount) {\n        return set(date, Calendar.HOUR_OF_DAY, amount);\n    }\n\n    \n    \n    public static Date setMinutes(Date date, int amount) {\n        return set(date, Calendar.MINUTE, amount);\n    }\n    \n    \n    \n    public static Date setSeconds(Date date, int amount) {\n        return set(date, Calendar.SECOND, amount);\n    }\n\n    \n    \n    public static Date setMilliseconds(Date date, int amount) {\n        return set(date, Calendar.MILLISECOND, amount);\n    } \n    \n    \n    \n    private static Date set(Date date, int calendarField, int amount) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        \n        Calendar c = Calendar.getInstance();\n        c.setLenient(false);\n        c.setTime(date);\n        c.set(calendarField, amount);\n        return c.getTime();\n    }   \n\n    \n    \n    public static Calendar toCalendar(Date date) {\n        Calendar c = Calendar.getInstance();\n        c.setTime(date);\n        return c;\n    }\n    \n    \n    \n    public static Date round(Date date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(date);\n        modify(gval, field, MODIFY_ROUND);\n        return gval.getTime();\n    }\n\n    \n    public static Calendar round(Calendar date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar rounded = (Calendar) date.clone();\n        modify(rounded, field, MODIFY_ROUND);\n        return rounded;\n    }\n\n    \n    public static Date round(Object date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (date instanceof Date) {\n            return round((Date) date, field);\n        } else if (date instanceof Calendar) {\n            return round((Calendar) date, field).getTime();\n        } else {\n            throw new ClassCastException(\"Could not round \" + date);\n        }\n    }\n\n    \n    \n    public static Date truncate(Date date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(date);\n        modify(gval, field, MODIFY_TRUNCATE);\n        return gval.getTime();\n    }\n\n    \n    public static Calendar truncate(Calendar date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar truncated = (Calendar) date.clone();\n        modify(truncated, field, MODIFY_TRUNCATE);\n        return truncated;\n    }\n\n    \n    public static Date truncate(Object date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (date instanceof Date) {\n            return truncate((Date) date, field);\n        } else if (date instanceof Calendar) {\n            return truncate((Calendar) date, field).getTime();\n        } else {\n            throw new ClassCastException(\"Could not truncate \" + date);\n        }\n    }\n    \n  \n    \n    public static Date ceiling(Date date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(date);\n        modify(gval, field, MODIFY_CEILING);\n        return gval.getTime();\n    }\n\n    \n    public static Calendar ceiling(Calendar date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar ceiled = (Calendar) date.clone();\n        modify(ceiled, field, MODIFY_CEILING);\n        return ceiled;\n    }\n\n    \n    public static Date ceiling(Object date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (date instanceof Date) {\n            return ceiling((Date) date, field);\n        } else if (date instanceof Calendar) {\n            return ceiling((Calendar) date, field).getTime();\n        } else {\n            throw new ClassCastException(\"Could not find ceiling of for type: \" + date.getClass());\n        }\n    }\n\n    \n    \n    private static void modify(Calendar val, int field, int modType) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field == Calendar.MILLISECOND) {\n            return;\n        }\n\n        \n        \n        \n        \n        \n\n        Date date = val.getTime();\n        long time = date.getTime();\n        boolean done = false;\n\n        \n        int millisecs = val.get(Calendar.MILLISECOND);\n        if (MODIFY_TRUNCATE == modType || millisecs < 500) {\n            time = time - millisecs;\n        }\n        if (field == Calendar.SECOND) {\n            done = true;\n        }\n\n        \n        int seconds = val.get(Calendar.SECOND);\n        if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) {\n            time = time - (seconds * 1000L);\n        }\n        if (field == Calendar.MINUTE) {\n            done = true;\n        }\n\n        \n        int minutes = val.get(Calendar.MINUTE);\n        if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) {\n            time = time - (minutes * 60000L);\n        }\n\n        \n        if (date.getTime() != time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        \n\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    \n                    if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            \n                            \n                            \n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n\n                        } else if (field == Calendar.AM_PM) {\n                            \n                            \n                            \n                            if (val.get(Calendar.HOUR_OF_DAY) == 0) {\n                                val.add(Calendar.HOUR_OF_DAY, 12);\n                            } else {\n                                val.add(Calendar.HOUR_OF_DAY, -12);\n                                val.add(Calendar.DATE, 1);\n                            }\n\n                        } else {\n                            \n                            \n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            \n            int offset = 0;\n            boolean offsetSet = false;\n            \n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE) {\n                        \n                        \n                        \n                        offset = val.get(Calendar.DATE) - 1;\n                        \n                        \n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        \n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                        \n                        \n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset >= 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min = val.getActualMinimum(fields[i][0]);\n                int max = val.getActualMaximum(fields[i][0]);\n                \n                offset = val.get(fields[i][0]) - min;\n                \n                roundUp = offset > ((max - min) / 2);\n            }\n            \n            if (offset != 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }\n\n    \n    \n    public static Iterator<Calendar> iterator(Date focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(focus);\n        return iterator(gval, rangeStyle);\n    }\n\n    \n    public static Iterator<Calendar> iterator(Calendar focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar start = null;\n        Calendar end = null;\n        int startCutoff = Calendar.SUNDAY;\n        int endCutoff = Calendar.SATURDAY;\n        switch (rangeStyle) {\n            case RANGE_MONTH_SUNDAY:\n            case RANGE_MONTH_MONDAY:\n                \n                start = truncate(focus, Calendar.MONTH);\n                \n                end = (Calendar) start.clone();\n                end.add(Calendar.MONTH, 1);\n                end.add(Calendar.DATE, -1);\n                \n                if (rangeStyle == RANGE_MONTH_MONDAY) {\n                    startCutoff = Calendar.MONDAY;\n                    endCutoff = Calendar.SUNDAY;\n                }\n                break;\n            case RANGE_WEEK_SUNDAY:\n            case RANGE_WEEK_MONDAY:\n            case RANGE_WEEK_RELATIVE:\n            case RANGE_WEEK_CENTER:\n                \n                start = truncate(focus, Calendar.DATE);\n                end = truncate(focus, Calendar.DATE);\n                switch (rangeStyle) {\n                    case RANGE_WEEK_SUNDAY:\n                        \n                        break;\n                    case RANGE_WEEK_MONDAY:\n                        startCutoff = Calendar.MONDAY;\n                        endCutoff = Calendar.SUNDAY;\n                        break;\n                    case RANGE_WEEK_RELATIVE:\n                        startCutoff = focus.get(Calendar.DAY_OF_WEEK);\n                        endCutoff = startCutoff - 1;\n                        break;\n                    case RANGE_WEEK_CENTER:\n                        startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3;\n                        endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3;\n                        break;\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"The range style \" + rangeStyle + \" is not valid.\");\n        }\n        if (startCutoff < Calendar.SUNDAY) {\n            startCutoff += 7;\n        }\n        if (startCutoff > Calendar.SATURDAY) {\n            startCutoff -= 7;\n        }\n        if (endCutoff < Calendar.SUNDAY) {\n            endCutoff += 7;\n        }\n        if (endCutoff > Calendar.SATURDAY) {\n            endCutoff -= 7;\n        }\n        while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) {\n            start.add(Calendar.DATE, -1);\n        }\n        while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) {\n            end.add(Calendar.DATE, 1);\n        }\n        return new DateIterator(start, end);\n    }\n\n    \n    public static Iterator<?> iterator(Object focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (focus instanceof Date) {\n            return iterator((Date) focus, rangeStyle);\n        } else if (focus instanceof Calendar) {\n            return iterator((Calendar) focus, rangeStyle);\n        } else {\n            throw new ClassCastException(\"Could not iterate based on \" + focus);\n        }\n    }\n    \n    \n    public static long getFragmentInMilliseconds(Date date, int fragment) {\n        return getFragment(date, fragment, Calendar.MILLISECOND);    \n    }\n    \n    \n    public static long getFragmentInSeconds(Date date, int fragment) {\n        return getFragment(date, fragment, Calendar.SECOND);\n    }\n    \n    \n    public static long getFragmentInMinutes(Date date, int fragment) {\n        return getFragment(date, fragment, Calendar.MINUTE);\n    }\n    \n    \n    public static long getFragmentInHours(Date date, int fragment) {\n        return getFragment(date, fragment, Calendar.HOUR_OF_DAY);\n    }\n    \n    \n    public static long getFragmentInDays(Date date, int fragment) {\n        return getFragment(date, fragment, Calendar.DAY_OF_YEAR);\n    }\n\n    \n  public static long getFragmentInMilliseconds(Calendar calendar, int fragment) {\n    return getFragment(calendar, fragment, Calendar.MILLISECOND);\n  }\n    \n    public static long getFragmentInSeconds(Calendar calendar, int fragment) {\n        return getFragment(calendar, fragment, Calendar.SECOND);\n    }\n    \n    \n    public static long getFragmentInMinutes(Calendar calendar, int fragment) {\n        return getFragment(calendar, fragment, Calendar.MINUTE);\n    }\n    \n    \n    public static long getFragmentInHours(Calendar calendar, int fragment) {\n        return getFragment(calendar, fragment, Calendar.HOUR_OF_DAY);\n    }\n    \n    \n    public static long getFragmentInDays(Calendar calendar, int fragment) {\n        return getFragment(calendar, fragment, Calendar.DAY_OF_YEAR);\n    }\n    \n    \n    private static long getFragment(Date date, int fragment, int unit) {\n        if(date == null) {\n            throw  new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        return getFragment(calendar, fragment, unit);\n    }\n\n    \n    private static long getFragment(Calendar calendar, int fragment, int unit) {\n        if(calendar == null) {\n            throw  new IllegalArgumentException(\"The date must not be null\"); \n        }\n        long millisPerUnit = getMillisPerUnit(unit);\n        long result = 0;\n        \n        \n        switch (fragment) {\n            case Calendar.YEAR:\n                result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit;\n                break;\n            case Calendar.MONTH:\n                result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit;\n                break;\n        }\n\n        switch (fragment) {\n            \n            case Calendar.YEAR:\n            case Calendar.MONTH:\n            \n            \n            case Calendar.DAY_OF_YEAR:\n            case Calendar.DATE:\n                result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit;\n                \n            case Calendar.HOUR_OF_DAY:\n                result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit;\n                \n            case Calendar.MINUTE:\n                result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit;\n                \n            case Calendar.SECOND:\n                result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit;\n                break;\n            case Calendar.MILLISECOND: break;\n                default: throw new IllegalArgumentException(\"The fragment \" + fragment + \" is not supported\");\n        }\n        return result;\n    }\n    \n    \n    public static boolean truncatedEquals(Calendar cal1, Calendar cal2, int field) {\n        return truncatedCompareTo(cal1, cal2, field) == 0;\n    }\n\n    \n    public static boolean truncatedEquals(Date date1, Date date2, int field) {\n        return truncatedCompareTo(date1, date2, field) == 0;\n    }\n\n    \n    public static int truncatedCompareTo(Calendar cal1, Calendar cal2, int field) {\n        Calendar truncatedCal1 = truncate(cal1, field);\n        Calendar truncatedCal2 = truncate(cal2, field);\n        return truncatedCal1.compareTo(truncatedCal2);\n    }\n\n    \n    public static int truncatedCompareTo(Date date1, Date date2, int field) {\n        Date truncatedDate1 = truncate(date1, field);\n        Date truncatedDate2 = truncate(date2, field);\n        return truncatedDate1.compareTo(truncatedDate2);\n    }\n    \n    \n    private static long getMillisPerUnit(int unit) {\n        long result = Long.MAX_VALUE;\n        switch (unit) {\n            case Calendar.DAY_OF_YEAR:\n            case Calendar.DATE:\n                result = MILLIS_PER_DAY;\n                break;\n            case Calendar.HOUR_OF_DAY:\n                result = MILLIS_PER_HOUR;\n                break;\n            case Calendar.MINUTE:\n                result = MILLIS_PER_MINUTE;\n                break;\n            case Calendar.SECOND:\n                result = MILLIS_PER_SECOND;\n                break;\n            case Calendar.MILLISECOND:\n                result = 1;\n                break;\n            default: throw new IllegalArgumentException(\"The unit \" + unit + \" cannot be represented is milleseconds\");\n        }\n        return result;\n    }\n\n    \n    static class DateIterator implements Iterator<Calendar> { private final Calendar endFinal; private final Calendar spot; DateIterator(Calendar startFinal, Calendar endFinal) {\n            super();\n            this.endFinal = endFinal;\n            spot = startFinal;\n            spot.add(Calendar.DATE, -1);\n        }\n\n        \n        public boolean hasNext() {\n            return spot.before(endFinal);\n        }\n\n        \n        public Calendar next() {\n            if (spot.equals(endFinal)) {\n                throw new NoSuchElementException();\n            }\n            spot.add(Calendar.DATE, 1);\n            return (Calendar) spot.clone();\n        }\n\n        \n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n    \n}\n",
      "buggy_signatures": [
        "public static boolean isSameDay(Date date1, Date date2)",
        "public static boolean isSameDay(Calendar cal1, Calendar cal2)",
        "public static boolean isSameInstant(Date date1, Date date2)",
        "public static boolean isSameInstant(Calendar cal1, Calendar cal2)",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2)",
        "public static Date parseDate(String str, String... parsePatterns) throws ParseException",
        "public static Date parseDateStrictly(String str, String... parsePatterns) throws ParseException",
        "private static Date parseDateWithLeniency(String str, String[] parsePatterns, boolean lenient) throws ParseException",
        "public static Date addYears(Date date, int amount)",
        "public static Date addMonths(Date date, int amount)",
        "public static Date addWeeks(Date date, int amount)",
        "public static Date addDays(Date date, int amount)",
        "public static Date addHours(Date date, int amount)",
        "public static Date addMinutes(Date date, int amount)",
        "public static Date addSeconds(Date date, int amount)",
        "public static Date addMilliseconds(Date date, int amount)",
        "private static Date add(Date date, int calendarField, int amount)",
        "public static Date setYears(Date date, int amount)",
        "public static Date setMonths(Date date, int amount)",
        "public static Date setDays(Date date, int amount)",
        "public static Date setHours(Date date, int amount)",
        "public static Date setMinutes(Date date, int amount)",
        "public static Date setSeconds(Date date, int amount)",
        "public static Date setMilliseconds(Date date, int amount)",
        "private static Date set(Date date, int calendarField, int amount)",
        "public static Calendar toCalendar(Date date)",
        "public static Date round(Date date, int field)",
        "public static Calendar round(Calendar date, int field)",
        "public static Date round(Object date, int field)",
        "public static Date truncate(Date date, int field)",
        "public static Calendar truncate(Calendar date, int field)",
        "public static Date truncate(Object date, int field)",
        "public static Date ceiling(Date date, int field)",
        "public static Calendar ceiling(Calendar date, int field)",
        "public static Date ceiling(Object date, int field)",
        "private static void modify(Calendar val, int field, int modType)",
        "public static Iterator<Calendar> iterator(Date focus, int rangeStyle)",
        "public static Iterator<Calendar> iterator(Calendar focus, int rangeStyle)",
        "public static Iterator<?> iterator(Object focus, int rangeStyle)",
        "public static long getFragmentInMilliseconds(Date date, int fragment)",
        "public static long getFragmentInSeconds(Date date, int fragment)",
        "public static long getFragmentInMinutes(Date date, int fragment)",
        "public static long getFragmentInHours(Date date, int fragment)",
        "public static long getFragmentInDays(Date date, int fragment)",
        "public static long getFragmentInMilliseconds(Calendar calendar, int fragment)",
        "public static long getFragmentInSeconds(Calendar calendar, int fragment)",
        "public static long getFragmentInMinutes(Calendar calendar, int fragment)",
        "public static long getFragmentInHours(Calendar calendar, int fragment)",
        "public static long getFragmentInDays(Calendar calendar, int fragment)",
        "private static long getFragment(Date date, int fragment, int unit)",
        "private static long getFragment(Calendar calendar, int fragment, int unit)",
        "public static boolean truncatedEquals(Calendar cal1, Calendar cal2, int field)",
        "public static boolean truncatedEquals(Date date1, Date date2, int field)",
        "public static int truncatedCompareTo(Calendar cal1, Calendar cal2, int field)",
        "public static int truncatedCompareTo(Date date1, Date date2, int field)",
        "private static long getMillisPerUnit(int unit)",
        "static class DateIterator implements Iterator<Calendar> { private final Calendar endFinal; private final Calendar spot; DateIterator(Calendar startFinal, Calendar endFinal)",
        "public boolean hasNext()",
        "public Calendar next()",
        "public void remove()"
      ],
      "fixed_signatures": [
        "public static boolean isSameDay(Date date1, Date date2)",
        "public static boolean isSameDay(Calendar cal1, Calendar cal2)",
        "public static boolean isSameInstant(Date date1, Date date2)",
        "public static boolean isSameInstant(Calendar cal1, Calendar cal2)",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2)",
        "public static Date parseDate(String str, String... parsePatterns) throws ParseException",
        "public static Date parseDateStrictly(String str, String... parsePatterns) throws ParseException",
        "private static Date parseDateWithLeniency(String str, String[] parsePatterns, boolean lenient) throws ParseException",
        "public static Date addYears(Date date, int amount)",
        "public static Date addMonths(Date date, int amount)",
        "public static Date addWeeks(Date date, int amount)",
        "public static Date addDays(Date date, int amount)",
        "public static Date addHours(Date date, int amount)",
        "public static Date addMinutes(Date date, int amount)",
        "public static Date addSeconds(Date date, int amount)",
        "public static Date addMilliseconds(Date date, int amount)",
        "private static Date add(Date date, int calendarField, int amount)",
        "public static Date setYears(Date date, int amount)",
        "public static Date setMonths(Date date, int amount)",
        "public static Date setDays(Date date, int amount)",
        "public static Date setHours(Date date, int amount)",
        "public static Date setMinutes(Date date, int amount)",
        "public static Date setSeconds(Date date, int amount)",
        "public static Date setMilliseconds(Date date, int amount)",
        "private static Date set(Date date, int calendarField, int amount)",
        "public static Calendar toCalendar(Date date)",
        "public static Date round(Date date, int field)",
        "public static Calendar round(Calendar date, int field)",
        "public static Date round(Object date, int field)",
        "public static Date truncate(Date date, int field)",
        "public static Calendar truncate(Calendar date, int field)",
        "public static Date truncate(Object date, int field)",
        "public static Date ceiling(Date date, int field)",
        "public static Calendar ceiling(Calendar date, int field)",
        "public static Date ceiling(Object date, int field)",
        "private static void modify(Calendar val, int field, int modType)",
        "public static Iterator<Calendar> iterator(Date focus, int rangeStyle)",
        "public static Iterator<Calendar> iterator(Calendar focus, int rangeStyle)",
        "public static Iterator<?> iterator(Object focus, int rangeStyle)",
        "public static long getFragmentInMilliseconds(Date date, int fragment)",
        "public static long getFragmentInSeconds(Date date, int fragment)",
        "public static long getFragmentInMinutes(Date date, int fragment)",
        "public static long getFragmentInHours(Date date, int fragment)",
        "public static long getFragmentInDays(Date date, int fragment)",
        "public static long getFragmentInMilliseconds(Calendar calendar, int fragment)",
        "public static long getFragmentInSeconds(Calendar calendar, int fragment)",
        "public static long getFragmentInMinutes(Calendar calendar, int fragment)",
        "public static long getFragmentInHours(Calendar calendar, int fragment)",
        "public static long getFragmentInDays(Calendar calendar, int fragment)",
        "private static long getFragment(Date date, int fragment, int unit)",
        "private static long getFragment(Calendar calendar, int fragment, int unit)",
        "public static boolean truncatedEquals(Calendar cal1, Calendar cal2, int field)",
        "public static boolean truncatedEquals(Date date1, Date date2, int field)",
        "public static int truncatedCompareTo(Calendar cal1, Calendar cal2, int field)",
        "public static int truncatedCompareTo(Date date1, Date date2, int field)",
        "private static long getMillisPerUnit(int unit)",
        "static class DateIterator implements Iterator<Calendar> { private final Calendar endFinal; private final Calendar spot; DateIterator(Calendar startFinal, Calendar endFinal)",
        "public boolean hasNext()",
        "public Calendar next()",
        "public void remove()"
      ],
      "methods": [
        {
          "buggy_method": "  public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n  if (cal1 == null || cal2 == null) {\n  throw new IllegalArgumentException(\"The date must not be null\");\n  }\n  return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n  cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n  cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n  cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n  cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n  cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n  cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n  cal1.getClass() == cal2.getClass());\n  }",
          "fixed_method": "  public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n  if (cal1 == null || cal2 == null) {\n  throw new IllegalArgumentException(\"The date must not be null\");\n  }\n  return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n  cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n  cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n  cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n  cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n  cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n  cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n  cal1.getClass() == cal2.getClass());\n  }",
          "diff": [
            "@@ -262,7 +262,7 @@",
            "         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n",
            "                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n",
            "                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n",
            "-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n",
            "+                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n",
            "                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n",
            "                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n",
            "                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
