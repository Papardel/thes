{
  "bug_id": "25",
  "failed_tests": {
    "org.apache.commons.math3.optimization.fitting.HarmonicFitterTest": [
      {
        "methodName": "testMath844",
        "error": "junit.framework.AssertionFailedError",
        "message": "Expected exception: org.apache.commons.math3.exception.MathIllegalStateException",
        "fail_line": "",
        "test_source": "  public void testMath844() {\n  final double[] y = { 0, 1, 2, 3, 2, 1,\n  0, -1, -2, -3, -2, -1,\n  0, 1, 2, 3, 2, 1,\n  0, -1, -2, -3, -2, -1,\n  0, 1, 2, 3, 2, 1, 0 };\n  final int len = y.length;\n  final WeightedObservedPoint[] points = new WeightedObservedPoint[len];\n  for (int i = 0; i < len; i++) {\n  points[i] = new WeightedObservedPoint(1, i, y[i]);\n  }\n\n  final HarmonicFitter.ParameterGuesser guesser\n  = new HarmonicFitter.ParameterGuesser(points);\n\n  // The guesser fails because the function is far from an harmonic\n  // function: It is a triangular periodic function with amplitude 3\n  // and period 12, and all sample points are taken at integer abscissae\n  // so function values all belong to the integer subset {-3, -2, -1, 0,\n  // 1, 2, 3}.\n  guesser.guess();\n  }",
        "stack": [
          ""
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math3/optimization/fitting/HarmonicFitter.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math3.optimization.fitting;\n\nimport org.apache.commons.math3.optimization.DifferentiableMultivariateVectorOptimizer;\nimport org.apache.commons.math3.analysis.function.HarmonicOscillator;\nimport org.apache.commons.math3.exception.ZeroException;\nimport org.apache.commons.math3.exception.NumberIsTooSmallException;\nimport org.apache.commons.math3.exception.MathIllegalStateException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.util.FastMath;\n\n\npublic class HarmonicFitter extends CurveFitter<HarmonicOscillator.Parametric> { public HarmonicFitter(final DifferentiableMultivariateVectorOptimizer optimizer) {\n        super(optimizer);\n    }\n\n    \n    public double[] fit(double[] initialGuess) {\n        return fit(new HarmonicOscillator.Parametric(), initialGuess);\n    }\n\n    \n    public double[] fit() {\n        return fit((new ParameterGuesser(getObservations())).guess());\n    }\n\n    \n    public static class ParameterGuesser { private final WeightedObservedPoint[] observations; private double a; private double omega; private double phi; public ParameterGuesser(WeightedObservedPoint[] observations) {\n            if (observations.length < 4) {\n                throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE,\n                                                    observations.length, 4, true);\n            }\n\n            this.observations = observations.clone();\n        }\n\n        \n        public double[] guess() {\n            sortObservations();\n            guessAOmega();\n            guessPhi();\n            return new double[] { a, omega, phi };\n        }\n\n        \n        private void sortObservations() {\n            \n            \n            \n            WeightedObservedPoint curr = observations[0];\n            for (int j = 1; j < observations.length; ++j) {\n                WeightedObservedPoint prec = curr;\n                curr = observations[j];\n                if (curr.getX() < prec.getX()) {\n                    \n                    int i = j - 1;\n                    WeightedObservedPoint mI = observations[i];\n                    while ((i >= 0) && (curr.getX() < mI.getX())) {\n                        observations[i + 1] = mI;\n                        if (i-- != 0) {\n                            mI = observations[i];\n                        }\n                    }\n                    observations[i + 1] = curr;\n                    curr = observations[j];\n                }\n            }\n        }\n\n        \n        private void guessAOmega() {\n            \n            double sx2 = 0;\n            double sy2 = 0;\n            double sxy = 0;\n            double sxz = 0;\n            double syz = 0;\n\n            double currentX = observations[0].getX();\n            double currentY = observations[0].getY();\n            double f2Integral = 0;\n            double fPrime2Integral = 0;\n            final double startX = currentX;\n            for (int i = 1; i < observations.length; ++i) {\n                \n                final double previousX = currentX;\n                final double previousY = currentY;\n                currentX = observations[i].getX();\n                currentY = observations[i].getY();\n\n                \n                \n                final double dx = currentX - previousX;\n                final double dy = currentY - previousY;\n                final double f2StepIntegral =\n                    dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\n                final double fPrime2StepIntegral = dy * dy / dx;\n\n                final double x = currentX - startX;\n                f2Integral += f2StepIntegral;\n                fPrime2Integral += fPrime2StepIntegral;\n\n                sx2 += x * x;\n                sy2 += f2Integral * f2Integral;\n                sxy += x * f2Integral;\n                sxz += x * fPrime2Integral;\n                syz += f2Integral * fPrime2Integral;\n            }\n\n            \n            double c1 = sy2 * sxz - sxy * syz;\n            double c2 = sxy * sxz - sx2 * syz;\n            double c3 = sx2 * sy2 - sxy * sxy;\n            if ((c1 / c2 < 0) || (c2 / c3 < 0)) {\n                final int last = observations.length - 1;\n                \n                \n                final double xRange = observations[last].getX() - observations[0].getX();\n                if (xRange == 0) {\n                    throw new ZeroException();\n                }\n                omega = 2 * Math.PI / xRange;\n\n                double yMin = Double.POSITIVE_INFINITY;\n                double yMax = Double.NEGATIVE_INFINITY;\n                for (int i = 1; i < observations.length; ++i) {\n                    final double y = observations[i].getY();\n                    if (y < yMin) {\n                        yMin = y;\n                    }\n                    if (y > yMax) {\n                        yMax = y;\n                    }\n                }\n                a = 0.5 * (yMax - yMin);\n            } else {\n                    \n                    \n\n                a = FastMath.sqrt(c1 / c2);\n                omega = FastMath.sqrt(c2 / c3);\n            }\n        }\n\n        \n        private void guessPhi() {\n            \n            double fcMean = 0;\n            double fsMean = 0;\n\n            double currentX = observations[0].getX();\n            double currentY = observations[0].getY();\n            for (int i = 1; i < observations.length; ++i) {\n                \n                final double previousX = currentX;\n                final double previousY = currentY;\n                currentX = observations[i].getX();\n                currentY = observations[i].getY();\n                final double currentYPrime = (currentY - previousY) / (currentX - previousX);\n\n                double omegaX = omega * currentX;\n                double cosine = FastMath.cos(omegaX);\n                double sine = FastMath.sin(omegaX);\n                fcMean += omega * currentY * cosine - currentYPrime * sine;\n                fsMean += omega * currentY * sine + currentYPrime * cosine;\n            }\n\n            phi = FastMath.atan2(-fsMean, fcMean);\n        }\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math3.optimization.fitting;\n\nimport org.apache.commons.math3.optimization.DifferentiableMultivariateVectorOptimizer;\nimport org.apache.commons.math3.analysis.function.HarmonicOscillator;\nimport org.apache.commons.math3.exception.ZeroException;\nimport org.apache.commons.math3.exception.NumberIsTooSmallException;\nimport org.apache.commons.math3.exception.MathIllegalStateException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.util.FastMath;\n\n\npublic class HarmonicFitter extends CurveFitter<HarmonicOscillator.Parametric> { public HarmonicFitter(final DifferentiableMultivariateVectorOptimizer optimizer) {\n        super(optimizer);\n    }\n\n    \n    public double[] fit(double[] initialGuess) {\n        return fit(new HarmonicOscillator.Parametric(), initialGuess);\n    }\n\n    \n    public double[] fit() {\n        return fit((new ParameterGuesser(getObservations())).guess());\n    }\n\n    \n    public static class ParameterGuesser { private final WeightedObservedPoint[] observations; private double a; private double omega; private double phi; public ParameterGuesser(WeightedObservedPoint[] observations) {\n            if (observations.length < 4) {\n                throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE,\n                                                    observations.length, 4, true);\n            }\n\n            this.observations = observations.clone();\n        }\n\n        \n        public double[] guess() {\n            sortObservations();\n            guessAOmega();\n            guessPhi();\n            return new double[] { a, omega, phi };\n        }\n\n        \n        private void sortObservations() {\n            \n            \n            \n            WeightedObservedPoint curr = observations[0];\n            for (int j = 1; j < observations.length; ++j) {\n                WeightedObservedPoint prec = curr;\n                curr = observations[j];\n                if (curr.getX() < prec.getX()) {\n                    \n                    int i = j - 1;\n                    WeightedObservedPoint mI = observations[i];\n                    while ((i >= 0) && (curr.getX() < mI.getX())) {\n                        observations[i + 1] = mI;\n                        if (i-- != 0) {\n                            mI = observations[i];\n                        }\n                    }\n                    observations[i + 1] = curr;\n                    curr = observations[j];\n                }\n            }\n        }\n\n        \n        private void guessAOmega() {\n            \n            double sx2 = 0;\n            double sy2 = 0;\n            double sxy = 0;\n            double sxz = 0;\n            double syz = 0;\n\n            double currentX = observations[0].getX();\n            double currentY = observations[0].getY();\n            double f2Integral = 0;\n            double fPrime2Integral = 0;\n            final double startX = currentX;\n            for (int i = 1; i < observations.length; ++i) {\n                \n                final double previousX = currentX;\n                final double previousY = currentY;\n                currentX = observations[i].getX();\n                currentY = observations[i].getY();\n\n                \n                \n                final double dx = currentX - previousX;\n                final double dy = currentY - previousY;\n                final double f2StepIntegral =\n                    dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\n                final double fPrime2StepIntegral = dy * dy / dx;\n\n                final double x = currentX - startX;\n                f2Integral += f2StepIntegral;\n                fPrime2Integral += fPrime2StepIntegral;\n\n                sx2 += x * x;\n                sy2 += f2Integral * f2Integral;\n                sxy += x * f2Integral;\n                sxz += x * fPrime2Integral;\n                syz += f2Integral * fPrime2Integral;\n            }\n\n            \n            double c1 = sy2 * sxz - sxy * syz;\n            double c2 = sxy * sxz - sx2 * syz;\n            double c3 = sx2 * sy2 - sxy * sxy;\n            if ((c1 / c2 < 0) || (c2 / c3 < 0)) {\n                final int last = observations.length - 1;\n                \n                \n                final double xRange = observations[last].getX() - observations[0].getX();\n                if (xRange == 0) {\n                    throw new ZeroException();\n                }\n                omega = 2 * Math.PI / xRange;\n\n                double yMin = Double.POSITIVE_INFINITY;\n                double yMax = Double.NEGATIVE_INFINITY;\n                for (int i = 1; i < observations.length; ++i) {\n                    final double y = observations[i].getY();\n                    if (y < yMin) {\n                        yMin = y;\n                    }\n                    if (y > yMax) {\n                        yMax = y;\n                    }\n                }\n                a = 0.5 * (yMax - yMin);\n            } else {\n                if (c2 == 0) {\n                    \n                    \n                    throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR);\n                }\n\n                a = FastMath.sqrt(c1 / c2);\n                omega = FastMath.sqrt(c2 / c3);\n            }\n        }\n\n        \n        private void guessPhi() {\n            \n            double fcMean = 0;\n            double fsMean = 0;\n\n            double currentX = observations[0].getX();\n            double currentY = observations[0].getY();\n            for (int i = 1; i < observations.length; ++i) {\n                \n                final double previousX = currentX;\n                final double previousY = currentY;\n                currentX = observations[i].getX();\n                currentY = observations[i].getY();\n                final double currentYPrime = (currentY - previousY) / (currentX - previousX);\n\n                double omegaX = omega * currentX;\n                double cosine = FastMath.cos(omegaX);\n                double sine = FastMath.sin(omegaX);\n                fcMean += omega * currentY * cosine - currentYPrime * sine;\n                fsMean += omega * currentY * sine + currentYPrime * cosine;\n            }\n\n            phi = FastMath.atan2(-fsMean, fcMean);\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public class HarmonicFitter extends CurveFitter<HarmonicOscillator.Parametric> { public HarmonicFitter(final DifferentiableMultivariateVectorOptimizer optimizer)",
        "public double[] fit(double[] initialGuess)",
        "public double[] fit()",
        "public static class ParameterGuesser { private final WeightedObservedPoint[] observations; private double a; private double omega; private double phi; public ParameterGuesser(WeightedObservedPoint[] observations)",
        "public double[] guess()",
        "private void sortObservations()",
        "private void guessAOmega()",
        "private void guessPhi()"
      ],
      "fixed_signatures": [
        "public class HarmonicFitter extends CurveFitter<HarmonicOscillator.Parametric> { public HarmonicFitter(final DifferentiableMultivariateVectorOptimizer optimizer)",
        "public double[] fit(double[] initialGuess)",
        "public double[] fit()",
        "public static class ParameterGuesser { private final WeightedObservedPoint[] observations; private double a; private double omega; private double phi; public ParameterGuesser(WeightedObservedPoint[] observations)",
        "public double[] guess()",
        "private void sortObservations()",
        "private void guessAOmega()",
        "private void guessPhi()"
      ],
      "methods": [
        {
          "buggy_method": "  private void guessAOmega() {\n  \n  double sx2 = 0;\n  double sy2 = 0;\n  double sxy = 0;\n  double sxz = 0;\n  double syz = 0;\n\n  double currentX = observations[0].getX();\n  double currentY = observations[0].getY();\n  double f2Integral = 0;\n  double fPrime2Integral = 0;\n  final double startX = currentX;\n  for (int i = 1; i < observations.length; ++i) {\n  \n  final double previousX = currentX;\n  final double previousY = currentY;\n  currentX = observations[i].getX();\n  currentY = observations[i].getY();\n\n  \n  \n  final double dx = currentX - previousX;\n  final double dy = currentY - previousY;\n  final double f2StepIntegral =\n  dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\n  final double fPrime2StepIntegral = dy * dy / dx;\n\n  final double x = currentX - startX;\n  f2Integral += f2StepIntegral;\n  fPrime2Integral += fPrime2StepIntegral;\n\n  sx2 += x * x;\n  sy2 += f2Integral * f2Integral;\n  sxy += x * f2Integral;\n  sxz += x * fPrime2Integral;\n  syz += f2Integral * fPrime2Integral;\n  }\n\n  \n  double c1 = sy2 * sxz - sxy * syz;\n  double c2 = sxy * sxz - sx2 * syz;\n  double c3 = sx2 * sy2 - sxy * sxy;\n  if ((c1 / c2 < 0) || (c2 / c3 < 0)) {\n  final int last = observations.length - 1;\n  \n  \n  final double xRange = observations[last].getX() - observations[0].getX();\n  if (xRange == 0) {\n  throw new ZeroException();\n  }\n  omega = 2 * Math.PI / xRange;\n\n  double yMin = Double.POSITIVE_INFINITY;\n  double yMax = Double.NEGATIVE_INFINITY;\n  for (int i = 1; i < observations.length; ++i) {\n  final double y = observations[i].getY();\n  if (y < yMin) {\n  yMin = y;\n  }\n  if (y > yMax) {\n  yMax = y;\n  }\n  }\n  a = 0.5 * (yMax - yMin);\n  } else {\n  \n  \n\n  a = FastMath.sqrt(c1 / c2);\n  omega = FastMath.sqrt(c2 / c3);\n  }\n  }",
          "fixed_method": "  private void guessAOmega() {\n  \n  double sx2 = 0;\n  double sy2 = 0;\n  double sxy = 0;\n  double sxz = 0;\n  double syz = 0;\n\n  double currentX = observations[0].getX();\n  double currentY = observations[0].getY();\n  double f2Integral = 0;\n  double fPrime2Integral = 0;\n  final double startX = currentX;\n  for (int i = 1; i < observations.length; ++i) {\n  \n  final double previousX = currentX;\n  final double previousY = currentY;\n  currentX = observations[i].getX();\n  currentY = observations[i].getY();\n\n  \n  \n  final double dx = currentX - previousX;\n  final double dy = currentY - previousY;\n  final double f2StepIntegral =\n  dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\n  final double fPrime2StepIntegral = dy * dy / dx;\n\n  final double x = currentX - startX;\n  f2Integral += f2StepIntegral;\n  fPrime2Integral += fPrime2StepIntegral;\n\n  sx2 += x * x;\n  sy2 += f2Integral * f2Integral;\n  sxy += x * f2Integral;\n  sxz += x * fPrime2Integral;\n  syz += f2Integral * fPrime2Integral;\n  }\n\n  \n  double c1 = sy2 * sxz - sxy * syz;\n  double c2 = sxy * sxz - sx2 * syz;\n  double c3 = sx2 * sy2 - sxy * sxy;\n  if ((c1 / c2 < 0) || (c2 / c3 < 0)) {\n  final int last = observations.length - 1;\n  \n  \n  final double xRange = observations[last].getX() - observations[0].getX();\n  if (xRange == 0) {\n  throw new ZeroException();\n  }\n  omega = 2 * Math.PI / xRange;\n\n  double yMin = Double.POSITIVE_INFINITY;\n  double yMax = Double.NEGATIVE_INFINITY;\n  for (int i = 1; i < observations.length; ++i) {\n  final double y = observations[i].getY();\n  if (y < yMin) {\n  yMin = y;\n  }\n  if (y > yMax) {\n  yMax = y;\n  }\n  }\n  a = 0.5 * (yMax - yMin);\n  } else {\n  if (c2 == 0) {\n  \n  \n  throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR);\n  }\n\n  a = FastMath.sqrt(c1 / c2);\n  omega = FastMath.sqrt(c2 / c3);\n  }\n  }",
          "diff": [
            "@@ -320,8 +320,11 @@",
            "                 }\n",
            "                 a = 0.5 * (yMax - yMin);\n",
            "             } else {\n",
            "+                if (c2 == 0) {\n",
            "                     // In some ill-conditioned cases (cf. MATH-844), the guesser\n",
            "                     // procedure cannot produce sensible results.\n",
            "+                    throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR);\n",
            "+                }\n",
            " \n",
            "                 a = FastMath.sqrt(c1 / c2);\n",
            "                 omega = FastMath.sqrt(c2 / c3);\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
