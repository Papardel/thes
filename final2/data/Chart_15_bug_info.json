{
  "bug_id": "15",
  "failed_tests": {
    "org.jfree.chart.plot.junit.PiePlot3DTests": [
      {
        "methodName": "testDrawWithNullDataset",
        "error": "junit.framework.AssertionFailedError",
        "message": "",
        "fail_line": "        assertTrue(success);",
        "test_source": "  public void testDrawWithNullDataset() {\n  JFreeChart chart = ChartFactory.createPieChart3D(\"Test\", null, true, \n  false, false);\n  boolean success = false;\n  try {\n  BufferedImage image = new BufferedImage(200 , 100, \n  BufferedImage.TYPE_INT_RGB);\n  Graphics2D g2 = image.createGraphics();\n  chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, null);\n  g2.dispose();\n  success = true;\n  }\n  catch (Exception e) {\n  success = false;\n  }\n  assertTrue(success);\n  }",
        "stack": [
          "PiePlot3DTests.testDrawWithNullDataset line 151"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jfree/chart/plot/PiePlot.java",
      "buggy_full_code": "\n\npackage org.jfree.chart.plot;\n\nimport java.awt.AlphaComposite;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Composite;\nimport java.awt.Font;\nimport java.awt.FontMetrics;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ResourceBundle;\nimport java.util.TreeMap;\n\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.PaintMap;\nimport org.jfree.chart.StrokeMap;\nimport org.jfree.chart.entity.EntityCollection;\nimport org.jfree.chart.entity.PieSectionEntity;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.labels.PieSectionLabelGenerator;\nimport org.jfree.chart.labels.PieToolTipGenerator;\nimport org.jfree.chart.labels.StandardPieSectionLabelGenerator;\nimport org.jfree.chart.text.G2TextMeasurer;\nimport org.jfree.chart.text.TextAnchor;\nimport org.jfree.chart.text.TextBlock;\nimport org.jfree.chart.text.TextBox;\nimport org.jfree.chart.text.TextUtilities;\nimport org.jfree.chart.urls.PieURLGenerator;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.RectangleAnchor;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.Rotation;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.jfree.chart.util.UnitType;\nimport org.jfree.data.DefaultKeyedValues;\nimport org.jfree.data.KeyedValues;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\nimport org.jfree.data.general.PieDataset;\n\n\npublic class PiePlot extends Plot implements Cloneable, Serializable { private static final long serialVersionUID = -795612466005590431L; public static final double DEFAULT_INTERIOR_GAP = 0.08; public static final double MAX_INTERIOR_GAP = 0.40; public static final double DEFAULT_START_ANGLE = 90.0; public static final Font DEFAULT_LABEL_FONT = new Font(\"SansSerif\", Font.PLAIN, 10); public static final Paint DEFAULT_LABEL_PAINT = Color.black; public static final Paint DEFAULT_LABEL_BACKGROUND_PAINT = new Color(255, 255, 192); public static final Paint DEFAULT_LABEL_OUTLINE_PAINT = Color.black; public static final Stroke DEFAULT_LABEL_OUTLINE_STROKE = new BasicStroke( 0.5f); public static final Paint DEFAULT_LABEL_SHADOW_PAINT = new Color(151, 151, 151, 128); public static final double DEFAULT_MINIMUM_ARC_ANGLE_TO_DRAW = 0.00001; private PieDataset dataset; private int pieIndex; private double interiorGap; private boolean circular; private double startAngle; private Rotation direction; private PaintMap sectionPaintMap; private transient Paint baseSectionPaint; private boolean sectionOutlinesVisible; private PaintMap sectionOutlinePaintMap; private transient Paint baseSectionOutlinePaint; private StrokeMap sectionOutlineStrokeMap; private transient Stroke baseSectionOutlineStroke; private transient Paint shadowPaint = Color.gray; private double shadowXOffset = 4.0f; private double shadowYOffset = 4.0f; private Map explodePercentages; private PieSectionLabelGenerator labelGenerator; private Font labelFont; private transient Paint labelPaint; private transient Paint labelBackgroundPaint; private transient Paint labelOutlinePaint; private transient Stroke labelOutlineStroke; private transient Paint labelShadowPaint; private boolean simpleLabels = true; private RectangleInsets labelPadding; private RectangleInsets simpleLabelOffset; private double maximumLabelWidth = 0.14; private double labelGap = 0.025; private boolean labelLinksVisible; private double labelLinkMargin = 0.025; private transient Paint labelLinkPaint = Color.black; private transient Stroke labelLinkStroke = new BasicStroke(0.5f); private AbstractPieLabelDistributor labelDistributor; private PieToolTipGenerator toolTipGenerator; private PieURLGenerator urlGenerator; private PieSectionLabelGenerator legendLabelGenerator; private PieSectionLabelGenerator legendLabelToolTipGenerator; private PieURLGenerator legendLabelURLGenerator; private boolean ignoreNullValues; private boolean ignoreZeroValues; private transient Shape legendItemShape; private double minimumArcAngleToDraw; protected static ResourceBundle localizationResources = ResourceBundle.getBundle(\"org.jfree.chart.plot.LocalizationBundle\"); static final boolean DEBUG_DRAW_INTERIOR = false; static final boolean DEBUG_DRAW_LINK_AREA = false; static final boolean DEBUG_DRAW_PIE_AREA = false; public PiePlot() {\n        this(null);\n    }\n\n    \n    public PiePlot(PieDataset dataset) {\n        super();\n        this.dataset = dataset;\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n        this.pieIndex = 0;\n        \n        this.interiorGap = DEFAULT_INTERIOR_GAP;\n        this.circular = true;\n        this.startAngle = DEFAULT_START_ANGLE;\n        this.direction = Rotation.CLOCKWISE;\n        this.minimumArcAngleToDraw = DEFAULT_MINIMUM_ARC_ANGLE_TO_DRAW;\n\n        this.sectionPaintMap = new PaintMap();\n        this.baseSectionPaint = Color.gray;\n\n        this.sectionOutlinesVisible = true;\n        this.sectionOutlinePaintMap = new PaintMap();\n        this.baseSectionOutlinePaint = DEFAULT_OUTLINE_PAINT;\n\n        this.sectionOutlineStrokeMap = new StrokeMap();\n        this.baseSectionOutlineStroke = DEFAULT_OUTLINE_STROKE;\n        \n        this.explodePercentages = new TreeMap();\n\n        this.labelGenerator = new StandardPieSectionLabelGenerator();\n        this.labelFont = DEFAULT_LABEL_FONT;\n        this.labelPaint = DEFAULT_LABEL_PAINT;\n        this.labelBackgroundPaint = DEFAULT_LABEL_BACKGROUND_PAINT;\n        this.labelOutlinePaint = DEFAULT_LABEL_OUTLINE_PAINT;\n        this.labelOutlineStroke = DEFAULT_LABEL_OUTLINE_STROKE;\n        this.labelShadowPaint = DEFAULT_LABEL_SHADOW_PAINT;\n        this.labelLinksVisible = true;\n        this.labelDistributor = new PieLabelDistributor(0);\n        \n        this.simpleLabels = false;\n        this.simpleLabelOffset = new RectangleInsets(UnitType.RELATIVE, 0.18, \n                0.18, 0.18, 0.18);\n        this.labelPadding = new RectangleInsets(2, 2, 2, 2);\n        \n        this.toolTipGenerator = null;\n        this.urlGenerator = null;\n        this.legendLabelGenerator = new StandardPieSectionLabelGenerator();\n        this.legendLabelToolTipGenerator = null;\n        this.legendLabelURLGenerator = null;\n        this.legendItemShape = Plot.DEFAULT_LEGEND_ITEM_CIRCLE;\n        \n        this.ignoreNullValues = false;\n        this.ignoreZeroValues = false;\n    }\n\n    \n    public PieDataset getDataset() {\n        return this.dataset;\n    }\n\n    \n    public void setDataset(PieDataset dataset) {\n        \n        \n        PieDataset existing = this.dataset;\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n\n        \n        this.dataset = dataset;\n        if (dataset != null) {\n            setDatasetGroup(dataset.getGroup());\n            dataset.addChangeListener(this);\n        }\n\n        \n        DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n        datasetChanged(event);\n    }\n    \n    \n    public int getPieIndex() {\n        return this.pieIndex;\n    }\n    \n    \n    public void setPieIndex(int index) {\n        this.pieIndex = index;\n    }\n    \n    \n    public double getStartAngle() {\n        return this.startAngle;\n    }\n\n    \n    public void setStartAngle(double angle) {\n        this.startAngle = angle;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public Rotation getDirection() {\n        return this.direction;\n    }\n\n    \n    public void setDirection(Rotation direction) {\n        if (direction == null) {\n            throw new IllegalArgumentException(\"Null 'direction' argument.\");\n        }\n        this.direction = direction;\n        notifyListeners(new PlotChangeEvent(this));\n\n    }\n\n    \n    public double getInteriorGap() {\n        return this.interiorGap;\n    }\n\n    \n    public void setInteriorGap(double percent) {\n\n        if ((percent < 0.0) || (percent > MAX_INTERIOR_GAP)) {\n            throw new IllegalArgumentException(\n                \"Invalid 'percent' (\" + percent + \") argument.\");\n        }\n\n        if (this.interiorGap != percent) {\n            this.interiorGap = percent;\n            notifyListeners(new PlotChangeEvent(this));\n        }\n\n    }\n\n    \n    public boolean isCircular() {\n        return this.circular;\n    }\n\n    \n    public void setCircular(boolean flag) {\n        setCircular(flag, true);\n    }\n\n    \n    public void setCircular(boolean circular, boolean notify) {\n        this.circular = circular;\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));   \n        }\n    }\n\n    \n    public boolean getIgnoreNullValues() {\n        return this.ignoreNullValues;   \n    }\n    \n    \n    public void setIgnoreNullValues(boolean flag) {\n        this.ignoreNullValues = flag;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public boolean getIgnoreZeroValues() {\n        return this.ignoreZeroValues;   \n    }\n    \n    \n    public void setIgnoreZeroValues(boolean flag) {\n        this.ignoreZeroValues = flag;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n\n    \n    protected Paint lookupSectionPaint(Comparable key) {\n        return lookupSectionPaint(key, false);        \n    }\n    \n    \n    protected Paint lookupSectionPaint(Comparable key, boolean autoPopulate) {\n        Paint result = null;\n        \n        \n        result = this.sectionPaintMap.getPaint(key);\n        if (result != null) {\n            return result;\n        }\n        \n        \n        if (autoPopulate) {\n            DrawingSupplier ds = getDrawingSupplier();\n            if (ds != null) {\n                result = ds.getNextPaint();\n                this.sectionPaintMap.put(key, result);\n            }\n            else {\n                result = this.baseSectionPaint;\n            }\n        }\n        else {\n            result = this.baseSectionPaint;\n        }\n        return result;\n    }\n    \n    \n    protected Comparable getSectionKey(int section) {\n        Comparable key = null;\n        if (this.dataset != null) {\n            if (section >= 0 && section < this.dataset.getItemCount()) {\n                key = this.dataset.getKey(section);\n            }\n        }\n        if (key == null) {\n            key = new Integer(section);\n        }\n        return key;\n    }\n    \n    \n    public Paint getSectionPaint(Comparable key) {\n        \n        return this.sectionPaintMap.getPaint(key);\n    }\n    \n    \n    public void setSectionPaint(Comparable key, Paint paint) {\n        \n        this.sectionPaintMap.put(key, paint);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public Paint getBaseSectionPaint() {\n        return this.baseSectionPaint;   \n    }\n    \n    \n    public void setBaseSectionPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.baseSectionPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n\n    \n    public boolean getSectionOutlinesVisible() {\n        return this.sectionOutlinesVisible;\n    }\n    \n    \n    public void setSectionOutlinesVisible(boolean visible) {\n        this.sectionOutlinesVisible = visible;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    protected Paint lookupSectionOutlinePaint(Comparable key) {\n        return lookupSectionOutlinePaint(key, false);        \n    }\n    \n    \n    protected Paint lookupSectionOutlinePaint(Comparable key, boolean autoPopulate) {\n        \n        Paint result = null;\n        \n        \n        result = this.sectionOutlinePaintMap.getPaint(key);\n        if (result != null) {\n            return result;\n        }\n        \n        \n        if (autoPopulate) {\n            DrawingSupplier ds = getDrawingSupplier();\n            if (ds != null) {\n                result = ds.getNextOutlinePaint();\n                this.sectionOutlinePaintMap.put(key, result);\n            }\n            else {\n                result = this.baseSectionOutlinePaint;\n            }\n        }\n        else {\n            result = this.baseSectionOutlinePaint;\n        }\n        return result;\n    }\n\n    \n    public Paint getSectionOutlinePaint(Comparable key) {\n        \n        return this.sectionOutlinePaintMap.getPaint(key);\n    }\n    \n    \n    public void setSectionOutlinePaint(Comparable key, Paint paint) {\n        \n        this.sectionOutlinePaintMap.put(key, paint);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public Paint getBaseSectionOutlinePaint() {\n        return this.baseSectionOutlinePaint;   \n    }\n    \n    \n    public void setBaseSectionOutlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.baseSectionOutlinePaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n\n    \n    protected Stroke lookupSectionOutlineStroke(Comparable key) {\n        return lookupSectionOutlineStroke(key, false);        \n    }\n    \n    \n    protected Stroke lookupSectionOutlineStroke(Comparable key, boolean autoPopulate) {\n        \n        Stroke result = null;\n        \n        \n        result = this.sectionOutlineStrokeMap.getStroke(key);\n        if (result != null) {\n            return result;\n        }\n        \n        \n        if (autoPopulate) {\n            DrawingSupplier ds = getDrawingSupplier();\n            if (ds != null) {\n                result = ds.getNextOutlineStroke();\n                this.sectionOutlineStrokeMap.put(key, result);\n            }\n            else {\n                result = this.baseSectionOutlineStroke;\n            }\n        }\n        else {\n            result = this.baseSectionOutlineStroke;\n        }\n        return result;\n    }\n    \n    \n    public Stroke getSectionOutlineStroke(Comparable key) {\n        \n        return this.sectionOutlineStrokeMap.getStroke(key);\n    }\n    \n    \n    public void setSectionOutlineStroke(Comparable key, Stroke stroke) {\n        \n        this.sectionOutlineStrokeMap.put(key, stroke);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public Stroke getBaseSectionOutlineStroke() {\n        return this.baseSectionOutlineStroke;   \n    }\n    \n    \n    public void setBaseSectionOutlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");   \n        }\n        this.baseSectionOutlineStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public Paint getShadowPaint() {\n        return this.shadowPaint;   \n    }\n    \n    \n    public void setShadowPaint(Paint paint) {\n        this.shadowPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public double getShadowXOffset() {\n        return this.shadowXOffset;\n    }\n    \n    \n    public void setShadowXOffset(double offset) {\n        this.shadowXOffset = offset;   \n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public double getShadowYOffset() {\n        return this.shadowYOffset;\n    }\n    \n    \n    public void setShadowYOffset(double offset) {\n        this.shadowYOffset = offset;   \n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public double getExplodePercent(Comparable key) {\n        double result = 0.0;\n        if (this.explodePercentages != null) {\n            Number percent = (Number) this.explodePercentages.get(key);\n            if (percent != null) {\n                result = percent.doubleValue();\n            }\n        }\n        return result;\n    }\n    \n    \n    public void setExplodePercent(Comparable key, double percent) {\n        if (key == null) { \n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (this.explodePercentages == null) {\n            this.explodePercentages = new TreeMap();\n        }\n        this.explodePercentages.put(key, new Double(percent));\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public double getMaximumExplodePercent() {\n        double result = 0.0;\n        Iterator iterator = this.dataset.getKeys().iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            Number explode = (Number) this.explodePercentages.get(key);\n            if (explode != null) {\n                result = Math.max(result, explode.doubleValue());   \n            }\n        }\n        return result;\n    }\n    \n    \n    public PieSectionLabelGenerator getLabelGenerator() {\n        return this.labelGenerator;   \n    }\n    \n    \n    public void setLabelGenerator(PieSectionLabelGenerator generator) {\n        this.labelGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public double getLabelGap() {\n        return this.labelGap;   \n    }\n    \n    \n    public void setLabelGap(double gap) {\n        this.labelGap = gap;   \n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public double getMaximumLabelWidth() {\n        return this.maximumLabelWidth;   \n    }\n    \n    \n    public void setMaximumLabelWidth(double width) {\n        this.maximumLabelWidth = width;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public boolean getLabelLinksVisible() {\n        return this.labelLinksVisible;\n    }\n    \n    \n    public void setLabelLinksVisible(boolean visible) {\n        this.labelLinksVisible = visible;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public double getLabelLinkMargin() {\n        return this.labelLinkMargin;   \n    }\n    \n    \n    public void setLabelLinkMargin(double margin) {\n        this.labelLinkMargin = margin;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public Paint getLabelLinkPaint() {\n        return this.labelLinkPaint;   \n    }\n    \n    \n    public void setLabelLinkPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.labelLinkPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public Stroke getLabelLinkStroke() {\n        return this.labelLinkStroke;   \n    }\n    \n    \n    public void setLabelLinkStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.labelLinkStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public Font getLabelFont() {\n        return this.labelFont;\n    }\n\n    \n    public void setLabelFont(Font font) {\n        if (font == null) {\n            throw new IllegalArgumentException(\"Null 'font' argument.\");\n        }\n        this.labelFont = font;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public Paint getLabelPaint() {\n        return this.labelPaint;\n    }\n\n    \n    public void setLabelPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.labelPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public Paint getLabelBackgroundPaint() {\n        return this.labelBackgroundPaint;\n    }\n\n    \n    public void setLabelBackgroundPaint(Paint paint) {\n        this.labelBackgroundPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public Paint getLabelOutlinePaint() {\n        return this.labelOutlinePaint;\n    }\n\n    \n    public void setLabelOutlinePaint(Paint paint) {\n        this.labelOutlinePaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public Stroke getLabelOutlineStroke() {\n        return this.labelOutlineStroke;\n    }\n\n    \n    public void setLabelOutlineStroke(Stroke stroke) {\n        this.labelOutlineStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public Paint getLabelShadowPaint() {\n        return this.labelShadowPaint;\n    }\n\n    \n    public void setLabelShadowPaint(Paint paint) {\n        this.labelShadowPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public RectangleInsets getLabelPadding() {\n        return this.labelPadding;\n    }\n    \n    \n    public void setLabelPadding(RectangleInsets padding) {\n        if (padding == null) {\n            throw new IllegalArgumentException(\"Null 'padding' argument.\");\n        }\n        this.labelPadding = padding;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public boolean getSimpleLabels() {\n        return this.simpleLabels;\n    }\n    \n    \n    public void setSimpleLabels(boolean simple) {\n        this.simpleLabels = simple;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public RectangleInsets getSimpleLabelOffset() {\n        return this.simpleLabelOffset;\n    }\n    \n    \n    public void setSimpleLabelOffset(RectangleInsets offset) {\n        if (offset == null) {\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");\n        }\n        this.simpleLabelOffset = offset;\n        notifyListeners(new PlotChangeEvent(this));        \n    }\n    \n    \n    public AbstractPieLabelDistributor getLabelDistributor() {\n        return this.labelDistributor;\n    }\n    \n    \n    public void setLabelDistributor(AbstractPieLabelDistributor distributor) {\n        if (distributor == null) {\n            throw new IllegalArgumentException(\"Null 'distributor' argument.\");\n        }\n        this.labelDistributor = distributor;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public PieToolTipGenerator getToolTipGenerator() {\n        return this.toolTipGenerator;\n    }\n\n    \n    public void setToolTipGenerator(PieToolTipGenerator generator) {\n        this.toolTipGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public PieURLGenerator getURLGenerator() {\n        return this.urlGenerator;\n    }\n\n    \n    public void setURLGenerator(PieURLGenerator generator) {\n        this.urlGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public double getMinimumArcAngleToDraw() {\n        return this.minimumArcAngleToDraw;\n    }\n\n    \n    public void setMinimumArcAngleToDraw(double angle) {\n        this.minimumArcAngleToDraw = angle;\n    }\n    \n    \n    public Shape getLegendItemShape() {\n        return this.legendItemShape;\n    }\n\n    \n    public void setLegendItemShape(Shape shape) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        this.legendItemShape = shape;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public PieSectionLabelGenerator getLegendLabelGenerator() {\n        return this.legendLabelGenerator;\n    }\n    \n    \n    public void setLegendLabelGenerator(PieSectionLabelGenerator generator) {\n        if (generator == null) {\n            throw new IllegalArgumentException(\"Null 'generator' argument.\");\n        }\n        this.legendLabelGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public PieSectionLabelGenerator getLegendLabelToolTipGenerator() {\n        return this.legendLabelToolTipGenerator;\n    }\n    \n    \n    public void setLegendLabelToolTipGenerator( PieSectionLabelGenerator generator) {\n        this.legendLabelToolTipGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public PieURLGenerator getLegendLabelURLGenerator() {\n        return this.legendLabelURLGenerator;\n    }\n    \n    \n    public void setLegendLabelURLGenerator(PieURLGenerator generator) {\n        this.legendLabelURLGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea, PiePlot plot, Integer index, PlotRenderingInfo info) {\n     \n        PiePlotState state = new PiePlotState(info);\n        state.setPassesRequired(2);\n            state.setTotal(DatasetUtilities.calculatePieDatasetTotal(\n                    plot.getDataset()));\n        state.setLatestAngle(plot.getStartAngle());\n        return state;\n        \n    }\n    \n    \n    public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo info) {\n\n        \n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n\n        if (info != null) {\n            info.setPlotArea(area);\n            info.setDataArea(area);\n        }\n\n        drawBackground(g2, area);\n        drawOutline(g2, area);\n\n        Shape savedClip = g2.getClip();\n        g2.clip(area);\n\n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n                getForegroundAlpha()));\n\n        if (!DatasetUtilities.isEmptyOrNull(this.dataset)) {\n            drawPie(g2, area, info);\n        }\n        else {\n            drawNoDataMessage(g2, area);\n        }\n\n        g2.setClip(savedClip);\n        g2.setComposite(originalComposite);\n\n        drawOutline(g2, area);\n\n    }\n\n    \n    protected void drawPie(Graphics2D g2, Rectangle2D plotArea, PlotRenderingInfo info) {\n\n        PiePlotState state = initialise(g2, plotArea, this, null, info);\n\n        \n        double labelReserve = 0.0;\n        if (this.labelGenerator != null && !this.simpleLabels) {\n            labelReserve = this.labelGap + this.maximumLabelWidth;    \n        }\n        double gapHorizontal = plotArea.getWidth() * (this.interiorGap \n                + labelReserve) * 2.0;\n        double gapVertical = plotArea.getHeight() * this.interiorGap * 2.0;\n\n        \n        if (DEBUG_DRAW_INTERIOR) {\n            double hGap = plotArea.getWidth() * this.interiorGap;\n            double vGap = plotArea.getHeight() * this.interiorGap;\n        \n            double igx1 = plotArea.getX() + hGap;\n            double igx2 = plotArea.getMaxX() - hGap;\n            double igy1 = plotArea.getY() + vGap;\n            double igy2 = plotArea.getMaxY() - vGap;\n            g2.setPaint(Color.gray);\n            g2.draw(new Rectangle2D.Double(igx1, igy1, igx2 - igx1, \n                    igy2 - igy1));\n        }\n        \n        double linkX = plotArea.getX() + gapHorizontal / 2;\n        double linkY = plotArea.getY() + gapVertical / 2;\n        double linkW = plotArea.getWidth() - gapHorizontal;\n        double linkH = plotArea.getHeight() - gapVertical;\n        \n        \n        if (this.circular) {\n            double min = Math.min(linkW, linkH) / 2;\n            linkX = (linkX + linkX + linkW) / 2 - min;\n            linkY = (linkY + linkY + linkH) / 2 - min;\n            linkW = 2 * min;\n            linkH = 2 * min;\n        }\n\n        \n        \n        Rectangle2D linkArea = new Rectangle2D.Double(linkX, linkY, linkW, \n                linkH);\n        state.setLinkArea(linkArea);\n\n        if (DEBUG_DRAW_LINK_AREA) {\n            g2.setPaint(Color.blue);\n            g2.draw(linkArea);\n            g2.setPaint(Color.yellow);\n            g2.draw(new Ellipse2D.Double(linkArea.getX(), linkArea.getY(), \n                    linkArea.getWidth(), linkArea.getHeight()));\n        }\n        \n        \n        \n        \n        double lm = 0.0;\n        if (!this.simpleLabels) {\n            lm = this.labelLinkMargin;\n        }\n        double hh = linkArea.getWidth() * lm * 2.0;\n        double vv = linkArea.getHeight() * lm * 2.0;\n        Rectangle2D explodeArea = new Rectangle2D.Double(linkX + hh / 2.0, \n                linkY + vv / 2.0, linkW - hh, linkH - vv);\n       \n        state.setExplodedPieArea(explodeArea);\n        \n        \n        \n        \n        double maximumExplodePercent = getMaximumExplodePercent();\n        double percent = maximumExplodePercent / (1.0 + maximumExplodePercent);\n        \n        double h1 = explodeArea.getWidth() * percent;\n        double v1 = explodeArea.getHeight() * percent;\n        Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX() \n                + h1 / 2.0, explodeArea.getY() + v1 / 2.0, \n                explodeArea.getWidth() - h1, explodeArea.getHeight() - v1);\n\n        if (DEBUG_DRAW_PIE_AREA) {\n            g2.setPaint(Color.green);\n            g2.draw(pieArea);\n        }\n        state.setPieArea(pieArea);\n        state.setPieCenterX(pieArea.getCenterX());\n        state.setPieCenterY(pieArea.getCenterY());\n        state.setPieWRadius(pieArea.getWidth() / 2.0);\n        state.setPieHRadius(pieArea.getHeight() / 2.0);\n        \n        \n        if ((this.dataset != null) && (this.dataset.getKeys().size() > 0)) {\n\n            List keys = this.dataset.getKeys();\n            double totalValue = DatasetUtilities.calculatePieDatasetTotal(\n                    this.dataset);\n\n            int passesRequired = state.getPassesRequired();\n            for (int pass = 0; pass < passesRequired; pass++) {\n                double runningTotal = 0.0;\n                for (int section = 0; section < keys.size(); section++) {\n                    Number n = this.dataset.getValue(section);\n                    if (n != null) {\n                        double value = n.doubleValue();\n                        if (value > 0.0) {\n                            runningTotal += value;\n                            drawItem(g2, section, explodeArea, state, pass);\n                        }\n                    } \n                }\n            }\n            if (this.simpleLabels) {\n                drawSimpleLabels(g2, keys, totalValue, plotArea, linkArea, \n                        state);\n            }\n            else {\n                drawLabels(g2, keys, totalValue, plotArea, linkArea, state);\n            }\n\n        }\n        else {\n            drawNoDataMessage(g2, plotArea);\n        }\n    }\n    \n    \n    protected void drawItem(Graphics2D g2, int section, Rectangle2D dataArea, PiePlotState state, int currentPass) {\n    \n        Number n = this.dataset.getValue(section);\n        if (n == null) {\n            return;   \n        }\n        double value = n.doubleValue();\n        double angle1 = 0.0;\n        double angle2 = 0.0;\n        \n        if (this.direction == Rotation.CLOCKWISE) {\n            angle1 = state.getLatestAngle();\n            angle2 = angle1 - value / state.getTotal() * 360.0;\n        }\n        else if (this.direction == Rotation.ANTICLOCKWISE) {\n            angle1 = state.getLatestAngle();\n            angle2 = angle1 + value / state.getTotal() * 360.0;         \n        }\n        else {\n            throw new IllegalStateException(\"Rotation type not recognised.\");   \n        }\n        \n        double angle = (angle2 - angle1);\n        if (Math.abs(angle) > getMinimumArcAngleToDraw()) {\n            double ep = 0.0;\n            double mep = getMaximumExplodePercent();\n            if (mep > 0.0) {\n                ep = getExplodePercent(getSectionKey(section)) / mep;                \n            }\n            Rectangle2D arcBounds = getArcBounds(state.getPieArea(), \n                    state.getExplodedPieArea(), angle1, angle, ep);\n            Arc2D.Double arc = new Arc2D.Double(arcBounds, angle1, angle, \n                    Arc2D.PIE);\n            \n            if (currentPass == 0) {\n                if (this.shadowPaint != null) {\n                    Shape shadowArc = ShapeUtilities.createTranslatedShape(\n                            arc, (float) this.shadowXOffset, \n                            (float) this.shadowYOffset);\n                    g2.setPaint(this.shadowPaint);\n                    g2.fill(shadowArc);\n                }\n            }\n            else if (currentPass == 1) {\n                Comparable key = getSectionKey(section);\n                Paint paint = lookupSectionPaint(key, true);\n                g2.setPaint(paint);\n                g2.fill(arc);\n\n                Paint outlinePaint = lookupSectionOutlinePaint(key);\n                Stroke outlineStroke = lookupSectionOutlineStroke(key);\n                if (this.sectionOutlinesVisible) {\n                    g2.setPaint(outlinePaint);\n                    g2.setStroke(outlineStroke);\n                    g2.draw(arc);\n                }\n                \n                \n                \n                if (state.getInfo() != null) {\n                    EntityCollection entities = state.getEntityCollection();\n                    if (entities != null) {\n                        String tip = null;\n                        if (this.toolTipGenerator != null) {\n                            tip = this.toolTipGenerator.generateToolTip(\n                                    this.dataset, key);\n                        }\n                        String url = null;\n                        if (this.urlGenerator != null) {\n                            url = this.urlGenerator.generateURL(this.dataset, \n                                    key, this.pieIndex);\n                        }\n                        PieSectionEntity entity = new PieSectionEntity(\n                                arc, this.dataset, this.pieIndex, section, key,\n                                tip, url);\n                        entities.add(entity);\n                    }\n                }\n            }\n        }    \n        state.setLatestAngle(angle2);\n    }\n    \n    \n    protected void drawSimpleLabels(Graphics2D g2, List keys, double totalValue, Rectangle2D plotArea, Rectangle2D pieArea, PiePlotState state) {\n        \n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n                1.0f));\n\n        RectangleInsets labelInsets = new RectangleInsets(UnitType.RELATIVE, \n                0.18, 0.18, 0.18, 0.18);\n        Rectangle2D labelsArea = labelInsets.createInsetRectangle(pieArea);\n        double runningTotal = 0.0;\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            boolean include = true;\n            double v = 0.0;\n            Number n = getDataset().getValue(key);\n            if (n == null) {\n                include = !getIgnoreNullValues();\n            }\n            else {\n                v = n.doubleValue();\n                include = getIgnoreZeroValues() ? v > 0.0 : v >= 0.0;\n            }\n\n            if (include) {\n                runningTotal = runningTotal + v;\n                \n                \n                double mid = getStartAngle() + (getDirection().getFactor()\n                        * ((runningTotal - v / 2.0) * 360) / totalValue);\n                \n                Arc2D arc = new Arc2D.Double(labelsArea, getStartAngle(), \n                        mid - getStartAngle(), Arc2D.OPEN);\n                int x = (int) arc.getEndPoint().getX();\n                int y = (int) arc.getEndPoint().getY();\n                \n                PieSectionLabelGenerator labelGenerator = getLabelGenerator();\n                if (labelGenerator == null) {\n                    continue;\n                }\n                String label = labelGenerator.generateSectionLabel(\n                        this.dataset, key);\n                if (label == null) {\n                    continue;\n                }\n                g2.setFont(this.labelFont);\n                FontMetrics fm = g2.getFontMetrics();\n                Rectangle2D bounds = TextUtilities.getTextBounds(label, g2, fm);\n                Rectangle2D out = this.labelPadding.createOutsetRectangle(\n                        bounds);\n                Shape bg = ShapeUtilities.createTranslatedShape(out, \n                        x - bounds.getCenterX(), y - bounds.getCenterY());\n                if (this.labelShadowPaint != null) {\n                    Shape shadow = ShapeUtilities.createTranslatedShape(bg, \n                            this.shadowXOffset, this.shadowYOffset);\n                    g2.setPaint(this.labelShadowPaint);\n                    g2.fill(shadow);\n                }\n                if (this.labelBackgroundPaint != null) {\n                    g2.setPaint(this.labelBackgroundPaint);\n                    g2.fill(bg);\n                }\n                if (this.labelOutlinePaint != null \n                        && this.labelOutlineStroke != null) {\n                    g2.setPaint(this.labelOutlinePaint);\n                    g2.setStroke(this.labelOutlineStroke);\n                    g2.draw(bg);\n                }\n                \n                g2.setPaint(this.labelPaint);\n                g2.setFont(this.labelFont);\n                TextUtilities.drawAlignedString(getLabelGenerator()\n                        .generateSectionLabel(getDataset(), key), g2, x, y, \n                        TextAnchor.CENTER);\n                \n            }\n        }\n       \n        g2.setComposite(originalComposite);\n\n    }\n\n    \n    protected void drawLabels(Graphics2D g2, List keys, double totalValue, Rectangle2D plotArea, Rectangle2D linkArea, PiePlotState state) {   \n\n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n                1.0f));\n\n        \n        DefaultKeyedValues leftKeys = new DefaultKeyedValues();\n        DefaultKeyedValues rightKeys = new DefaultKeyedValues();\n       \n        double runningTotal = 0.0;\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            boolean include = true;\n            double v = 0.0;\n            Number n = this.dataset.getValue(key);\n            if (n == null) {\n                include = !this.ignoreNullValues;\n            }\n            else {\n                v = n.doubleValue();\n                include = this.ignoreZeroValues ? v > 0.0 : v >= 0.0;\n            }\n\n            if (include) {\n                runningTotal = runningTotal + v;\n                \n                \n                double mid = this.startAngle + (this.direction.getFactor()\n                        * ((runningTotal - v / 2.0) * 360) / totalValue);\n                if (Math.cos(Math.toRadians(mid)) < 0.0) {\n                    leftKeys.addValue(key, new Double(mid));\n                }\n                else {\n                    rightKeys.addValue(key, new Double(mid));\n                }\n            }\n        }\n       \n        g2.setFont(getLabelFont());\n        \n        \n        \n        double marginX = plotArea.getX() + this.interiorGap * plotArea.getWidth();\n        double gap = plotArea.getWidth() * this.labelGap;\n        double ww = linkArea.getX() - gap - marginX;\n        float labelWidth = (float) this.labelPadding.trimWidth(ww);\n        \n        \n        if (this.labelGenerator != null) {\n            drawLeftLabels(leftKeys, g2, plotArea, linkArea, labelWidth, \n                    state);\n            drawRightLabels(rightKeys, g2, plotArea, linkArea, labelWidth, \n                    state);\n        }\n        g2.setComposite(originalComposite);\n\n    }\n\n    \n    protected void drawLeftLabels(KeyedValues leftKeys, Graphics2D g2, Rectangle2D plotArea, Rectangle2D linkArea, float maxLabelWidth, PiePlotState state) {\n        \n        this.labelDistributor.clear();\n        double lGap = plotArea.getWidth() * this.labelGap;\n        double verticalLinkRadius = state.getLinkArea().getHeight() / 2.0;\n        for (int i = 0; i < leftKeys.getItemCount(); i++) {   \n            String label = this.labelGenerator.generateSectionLabel(\n                    this.dataset, leftKeys.getKey(i));\n            if (label != null) {\n                TextBlock block = TextUtilities.createTextBlock(label, \n                        this.labelFont, this.labelPaint, maxLabelWidth, \n                        new G2TextMeasurer(g2));\n                TextBox labelBox = new TextBox(block);\n                labelBox.setBackgroundPaint(this.labelBackgroundPaint);\n                labelBox.setOutlinePaint(this.labelOutlinePaint);\n                labelBox.setOutlineStroke(this.labelOutlineStroke);\n                labelBox.setShadowPaint(this.labelShadowPaint);\n                labelBox.setInteriorGap(this.labelPadding);\n                double theta = Math.toRadians(\n                        leftKeys.getValue(i).doubleValue());\n                double baseY = state.getPieCenterY() - Math.sin(theta) \n                               * verticalLinkRadius;\n                double hh = labelBox.getHeight(g2);\n\n                this.labelDistributor.addPieLabelRecord(new PieLabelRecord(\n                        leftKeys.getKey(i), theta, baseY, labelBox, hh,\n                        lGap / 2.0 + lGap / 2.0 * -Math.cos(theta), 0.9 \n                        + getExplodePercent(leftKeys.getKey(i))));\n            }\n        }\n        this.labelDistributor.distributeLabels(plotArea.getMinY(), \n                plotArea.getHeight());\n        for (int i = 0; i < this.labelDistributor.getItemCount(); i++) {\n            drawLeftLabel(g2, state, \n                    this.labelDistributor.getPieLabelRecord(i));\n        }\n    }\n    \n    \n    protected void drawRightLabels(KeyedValues keys, Graphics2D g2, Rectangle2D plotArea, Rectangle2D linkArea, float maxLabelWidth, PiePlotState state) {\n\n        \n        this.labelDistributor.clear();\n        double lGap = plotArea.getWidth() * this.labelGap;\n        double verticalLinkRadius = state.getLinkArea().getHeight() / 2.0;\n\n        for (int i = 0; i < keys.getItemCount(); i++) {\n            String label = this.labelGenerator.generateSectionLabel(\n                    this.dataset, keys.getKey(i));\n\n            if (label != null) {\n                TextBlock block = TextUtilities.createTextBlock(label, \n                        this.labelFont, this.labelPaint, maxLabelWidth, \n                        new G2TextMeasurer(g2));\n                TextBox labelBox = new TextBox(block);\n                labelBox.setBackgroundPaint(this.labelBackgroundPaint);\n                labelBox.setOutlinePaint(this.labelOutlinePaint);\n                labelBox.setOutlineStroke(this.labelOutlineStroke);\n                labelBox.setShadowPaint(this.labelShadowPaint);\n                labelBox.setInteriorGap(this.labelPadding);\n                double theta = Math.toRadians(keys.getValue(i).doubleValue());\n                double baseY = state.getPieCenterY() \n                              - Math.sin(theta) * verticalLinkRadius;\n                double hh = labelBox.getHeight(g2);\n                this.labelDistributor.addPieLabelRecord(new PieLabelRecord(\n                        keys.getKey(i), theta, baseY, labelBox, hh,\n                        lGap / 2.0 + lGap / 2.0 * Math.cos(theta), \n                        0.9 + getExplodePercent(keys.getKey(i))));\n            }\n        }\n        this.labelDistributor.distributeLabels(plotArea.getMinY(), \n                plotArea.getHeight());\n        for (int i = 0; i < this.labelDistributor.getItemCount(); i++) {\n            drawRightLabel(g2, state, \n                    this.labelDistributor.getPieLabelRecord(i));\n        }\n\n    }\n    \n    \n    public LegendItemCollection getLegendItems() {\n\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.dataset == null) {\n            return result;\n        }\n        List keys = this.dataset.getKeys();\n        int section = 0;\n        Shape shape = getLegendItemShape();\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            Number n = this.dataset.getValue(key);\n            boolean include = true;\n            if (n == null) {\n                include = !this.ignoreNullValues;   \n            }\n            else {\n                double v = n.doubleValue();\n                if (v == 0.0) {\n                    include = !this.ignoreZeroValues;   \n                }\n                else {\n                    include = v > 0.0;   \n                }\n            }\n            if (include) {\n                String label = this.legendLabelGenerator.generateSectionLabel(\n                        this.dataset, key);\n                if (label != null) {\n                    String description = label;\n                    String toolTipText = null;\n                    if (this.legendLabelToolTipGenerator != null) {\n                        toolTipText = this.legendLabelToolTipGenerator\n                                .generateSectionLabel(this.dataset, key);\n                    }\n                    String urlText = null;\n                    if (this.legendLabelURLGenerator != null) {\n                        urlText = this.legendLabelURLGenerator.generateURL(\n                                this.dataset, key, this.pieIndex);\n                    }\n                    Paint paint = lookupSectionPaint(key, true);\n                    Paint outlinePaint = lookupSectionOutlinePaint(key);\n                    Stroke outlineStroke = lookupSectionOutlineStroke(key);\n                    LegendItem item = new LegendItem(label, description, \n                            toolTipText, urlText, true, shape, true, paint, \n                            true, outlinePaint, outlineStroke, \n                            false,          \n                            new Line2D.Float(), new BasicStroke(), Color.black);\n                    item.setDataset(getDataset());\n                    result.add(item);\n                }\n                section++;\n            }\n            else {\n                section++;\n            }\n        }\n        return result;\n    }\n\n    \n    public String getPlotType() {\n        return localizationResources.getString(\"Pie_Plot\");\n    }\n\n    \n    protected Rectangle2D getArcBounds(Rectangle2D unexploded, Rectangle2D exploded, double angle, double extent, double explodePercent) {\n\n        if (explodePercent == 0.0) {\n            return unexploded;\n        }\n        else {\n            Arc2D arc1 = new Arc2D.Double(unexploded, angle, extent / 2, \n                    Arc2D.OPEN);\n            Point2D point1 = arc1.getEndPoint();\n            Arc2D.Double arc2 = new Arc2D.Double(exploded, angle, extent / 2, \n                    Arc2D.OPEN);\n            Point2D point2 = arc2.getEndPoint();\n            double deltaX = (point1.getX() - point2.getX()) * explodePercent;\n            double deltaY = (point1.getY() - point2.getY()) * explodePercent;\n            return new Rectangle2D.Double(unexploded.getX() - deltaX, \n                    unexploded.getY() - deltaY, unexploded.getWidth(), \n                    unexploded.getHeight());\n        }\n    }\n    \n    \n    protected void drawLeftLabel(Graphics2D g2, PiePlotState state, PieLabelRecord record) {\n\n        double anchorX = state.getLinkArea().getMinX();\n        double targetX = anchorX - record.getGap();\n        double targetY = record.getAllocatedY();\n        \n        if (this.labelLinksVisible) {\n            double theta = record.getAngle();\n            double linkX = state.getPieCenterX() + Math.cos(theta) \n                    * state.getPieWRadius() * record.getLinkPercent();\n            double linkY = state.getPieCenterY() - Math.sin(theta) \n                    * state.getPieHRadius() * record.getLinkPercent();\n            double elbowX = state.getPieCenterX() + Math.cos(theta) \n                    * state.getLinkArea().getWidth() / 2.0;\n            double elbowY = state.getPieCenterY() - Math.sin(theta) \n                    * state.getLinkArea().getHeight() / 2.0;\n            double anchorY = elbowY;\n            g2.setPaint(this.labelLinkPaint);\n            g2.setStroke(this.labelLinkStroke);\n            g2.draw(new Line2D.Double(linkX, linkY, elbowX, elbowY));\n            g2.draw(new Line2D.Double(anchorX, anchorY, elbowX, elbowY));\n            g2.draw(new Line2D.Double(anchorX, anchorY, targetX, targetY));\n        }\n        TextBox tb = record.getLabel();\n        tb.draw(g2, (float) targetX, (float) targetY, RectangleAnchor.RIGHT);\n        \n    }\n\n    \n    protected void drawRightLabel(Graphics2D g2, PiePlotState state, PieLabelRecord record) {\n        \n        double anchorX = state.getLinkArea().getMaxX();\n        double targetX = anchorX + record.getGap();\n        double targetY = record.getAllocatedY();\n        \n        if (this.labelLinksVisible) {\n            double theta = record.getAngle();\n            double linkX = state.getPieCenterX() + Math.cos(theta) \n                    * state.getPieWRadius() * record.getLinkPercent();\n            double linkY = state.getPieCenterY() - Math.sin(theta) \n                    * state.getPieHRadius() * record.getLinkPercent();\n            double elbowX = state.getPieCenterX() + Math.cos(theta) \n                    * state.getLinkArea().getWidth() / 2.0;\n            double elbowY = state.getPieCenterY() - Math.sin(theta) \n                    * state.getLinkArea().getHeight() / 2.0;\n            double anchorY = elbowY;\n            g2.setPaint(this.labelLinkPaint);\n            g2.setStroke(this.labelLinkStroke);\n            g2.draw(new Line2D.Double(linkX, linkY, elbowX, elbowY));\n            g2.draw(new Line2D.Double(anchorX, anchorY, elbowX, elbowY));\n            g2.draw(new Line2D.Double(anchorX, anchorY, targetX, targetY));\n        }\n        \n        TextBox tb = record.getLabel();\n        tb.draw(g2, (float) targetX, (float) targetY, RectangleAnchor.LEFT);\n    \n    }\n\n    \n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof PiePlot)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        PiePlot that = (PiePlot) obj;\n        if (this.pieIndex != that.pieIndex) {\n            return false;\n        }\n        if (this.interiorGap != that.interiorGap) {\n            return false;\n        }\n        if (this.circular != that.circular) {\n            return false;\n        }\n        if (this.startAngle != that.startAngle) {\n            return false;\n        }\n        if (this.direction != that.direction) {\n            return false;\n        }\n        if (this.ignoreZeroValues != that.ignoreZeroValues) {\n            return false;\n        }\n        if (this.ignoreNullValues != that.ignoreNullValues) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.sectionPaintMap, \n                that.sectionPaintMap)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.baseSectionPaint, \n                that.baseSectionPaint)) {\n            return false;\n        }\n        if (this.sectionOutlinesVisible != that.sectionOutlinesVisible) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.sectionOutlinePaintMap, \n                that.sectionOutlinePaintMap)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(\n            this.baseSectionOutlinePaint, that.baseSectionOutlinePaint\n        )) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.sectionOutlineStrokeMap, \n                that.sectionOutlineStrokeMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(\n            this.baseSectionOutlineStroke, that.baseSectionOutlineStroke\n        )) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.shadowPaint, that.shadowPaint)) {\n            return false;\n        }\n        if (!(this.shadowXOffset == that.shadowXOffset)) {\n            return false;\n        }\n        if (!(this.shadowYOffset == that.shadowYOffset)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.explodePercentages, \n                that.explodePercentages)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelGenerator, \n                that.labelGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelFont, that.labelFont)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelPaint, that.labelPaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelBackgroundPaint, \n                that.labelBackgroundPaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelOutlinePaint, \n                that.labelOutlinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelOutlineStroke, \n                that.labelOutlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelShadowPaint, \n                that.labelShadowPaint)) {\n            return false;\n        }\n        if (this.simpleLabels != that.simpleLabels) {\n            return false;\n        }\n        if (!this.simpleLabelOffset.equals(that.simpleLabelOffset)) {\n            return false;\n        }\n        if (!this.labelPadding.equals(that.labelPadding)) {\n            return false;\n        }\n        if (!(this.maximumLabelWidth == that.maximumLabelWidth)) {\n            return false;\n        }\n        if (!(this.labelGap == that.labelGap)) {\n            return false;\n        }\n        if (!(this.labelLinkMargin == that.labelLinkMargin)) {\n            return false;\n        }\n        if (this.labelLinksVisible != that.labelLinksVisible) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelLinkPaint, that.labelLinkPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelLinkStroke, \n                that.labelLinkStroke)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.toolTipGenerator, \n                that.toolTipGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.urlGenerator, that.urlGenerator)) {\n            return false;\n        }\n        if (!(this.minimumArcAngleToDraw == that.minimumArcAngleToDraw)) {\n            return false;\n        }\n        if (!ShapeUtilities.equal(this.legendItemShape, that.legendItemShape)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.legendLabelGenerator, \n                that.legendLabelGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.legendLabelToolTipGenerator,\n                that.legendLabelToolTipGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.legendLabelURLGenerator,\n                that.legendLabelURLGenerator)) {\n            return false;\n        }\n        \n        return true;\n    }\n\n    \n    public Object clone() throws CloneNotSupportedException {\n        PiePlot clone = (PiePlot) super.clone();\n        if (clone.dataset != null) {\n            clone.dataset.addChangeListener(clone);\n        }\n        if (this.urlGenerator instanceof PublicCloneable) {\n            clone.urlGenerator = (PieURLGenerator) ObjectUtilities.clone(\n                    this.urlGenerator);\n        }\n        clone.legendItemShape = ShapeUtilities.clone(this.legendItemShape);\n        if (this.legendLabelGenerator != null) {\n            clone.legendLabelGenerator = (PieSectionLabelGenerator) \n                    ObjectUtilities.clone(this.legendLabelGenerator);\n        }\n        if (this.legendLabelToolTipGenerator != null) {\n            clone.legendLabelToolTipGenerator = (PieSectionLabelGenerator) \n                    ObjectUtilities.clone(this.legendLabelToolTipGenerator);\n        }\n        if (this.legendLabelURLGenerator instanceof PublicCloneable) {\n            clone.legendLabelURLGenerator = (PieURLGenerator) \n                    ObjectUtilities.clone(this.legendLabelURLGenerator);\n        }\n        return clone;\n    }\n\n    \n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writePaint(this.baseSectionPaint, stream);\n        SerialUtilities.writePaint(this.baseSectionOutlinePaint, stream);\n        SerialUtilities.writeStroke(this.baseSectionOutlineStroke, stream);\n        SerialUtilities.writePaint(this.shadowPaint, stream);\n        SerialUtilities.writePaint(this.labelPaint, stream);\n        SerialUtilities.writePaint(this.labelBackgroundPaint, stream);\n        SerialUtilities.writePaint(this.labelOutlinePaint, stream);\n        SerialUtilities.writeStroke(this.labelOutlineStroke, stream);\n        SerialUtilities.writePaint(this.labelShadowPaint, stream);\n        SerialUtilities.writePaint(this.labelLinkPaint, stream);\n        SerialUtilities.writeStroke(this.labelLinkStroke, stream);\n        SerialUtilities.writeShape(this.legendItemShape, stream);\n    }\n\n    \n    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.baseSectionPaint = SerialUtilities.readPaint(stream);\n        this.baseSectionOutlinePaint = SerialUtilities.readPaint(stream);\n        this.baseSectionOutlineStroke = SerialUtilities.readStroke(stream);\n        this.shadowPaint = SerialUtilities.readPaint(stream);\n        this.labelPaint = SerialUtilities.readPaint(stream);\n        this.labelBackgroundPaint = SerialUtilities.readPaint(stream);\n        this.labelOutlinePaint = SerialUtilities.readPaint(stream);\n        this.labelOutlineStroke = SerialUtilities.readStroke(stream);\n        this.labelShadowPaint = SerialUtilities.readPaint(stream);\n        this.labelLinkPaint = SerialUtilities.readPaint(stream);\n        this.labelLinkStroke = SerialUtilities.readStroke(stream);\n        this.legendItemShape = SerialUtilities.readShape(stream);\n    }\n\n}\n",
      "fixed_full_code": "\n\npackage org.jfree.chart.plot;\n\nimport java.awt.AlphaComposite;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Composite;\nimport java.awt.Font;\nimport java.awt.FontMetrics;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ResourceBundle;\nimport java.util.TreeMap;\n\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.PaintMap;\nimport org.jfree.chart.StrokeMap;\nimport org.jfree.chart.entity.EntityCollection;\nimport org.jfree.chart.entity.PieSectionEntity;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.labels.PieSectionLabelGenerator;\nimport org.jfree.chart.labels.PieToolTipGenerator;\nimport org.jfree.chart.labels.StandardPieSectionLabelGenerator;\nimport org.jfree.chart.text.G2TextMeasurer;\nimport org.jfree.chart.text.TextAnchor;\nimport org.jfree.chart.text.TextBlock;\nimport org.jfree.chart.text.TextBox;\nimport org.jfree.chart.text.TextUtilities;\nimport org.jfree.chart.urls.PieURLGenerator;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.RectangleAnchor;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.Rotation;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.jfree.chart.util.UnitType;\nimport org.jfree.data.DefaultKeyedValues;\nimport org.jfree.data.KeyedValues;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\nimport org.jfree.data.general.PieDataset;\n\n\npublic class PiePlot extends Plot implements Cloneable, Serializable { private static final long serialVersionUID = -795612466005590431L; public static final double DEFAULT_INTERIOR_GAP = 0.08; public static final double MAX_INTERIOR_GAP = 0.40; public static final double DEFAULT_START_ANGLE = 90.0; public static final Font DEFAULT_LABEL_FONT = new Font(\"SansSerif\", Font.PLAIN, 10); public static final Paint DEFAULT_LABEL_PAINT = Color.black; public static final Paint DEFAULT_LABEL_BACKGROUND_PAINT = new Color(255, 255, 192); public static final Paint DEFAULT_LABEL_OUTLINE_PAINT = Color.black; public static final Stroke DEFAULT_LABEL_OUTLINE_STROKE = new BasicStroke( 0.5f); public static final Paint DEFAULT_LABEL_SHADOW_PAINT = new Color(151, 151, 151, 128); public static final double DEFAULT_MINIMUM_ARC_ANGLE_TO_DRAW = 0.00001; private PieDataset dataset; private int pieIndex; private double interiorGap; private boolean circular; private double startAngle; private Rotation direction; private PaintMap sectionPaintMap; private transient Paint baseSectionPaint; private boolean sectionOutlinesVisible; private PaintMap sectionOutlinePaintMap; private transient Paint baseSectionOutlinePaint; private StrokeMap sectionOutlineStrokeMap; private transient Stroke baseSectionOutlineStroke; private transient Paint shadowPaint = Color.gray; private double shadowXOffset = 4.0f; private double shadowYOffset = 4.0f; private Map explodePercentages; private PieSectionLabelGenerator labelGenerator; private Font labelFont; private transient Paint labelPaint; private transient Paint labelBackgroundPaint; private transient Paint labelOutlinePaint; private transient Stroke labelOutlineStroke; private transient Paint labelShadowPaint; private boolean simpleLabels = true; private RectangleInsets labelPadding; private RectangleInsets simpleLabelOffset; private double maximumLabelWidth = 0.14; private double labelGap = 0.025; private boolean labelLinksVisible; private double labelLinkMargin = 0.025; private transient Paint labelLinkPaint = Color.black; private transient Stroke labelLinkStroke = new BasicStroke(0.5f); private AbstractPieLabelDistributor labelDistributor; private PieToolTipGenerator toolTipGenerator; private PieURLGenerator urlGenerator; private PieSectionLabelGenerator legendLabelGenerator; private PieSectionLabelGenerator legendLabelToolTipGenerator; private PieURLGenerator legendLabelURLGenerator; private boolean ignoreNullValues; private boolean ignoreZeroValues; private transient Shape legendItemShape; private double minimumArcAngleToDraw; protected static ResourceBundle localizationResources = ResourceBundle.getBundle(\"org.jfree.chart.plot.LocalizationBundle\"); static final boolean DEBUG_DRAW_INTERIOR = false; static final boolean DEBUG_DRAW_LINK_AREA = false; static final boolean DEBUG_DRAW_PIE_AREA = false; public PiePlot() {\n        this(null);\n    }\n\n    \n    public PiePlot(PieDataset dataset) {\n        super();\n        this.dataset = dataset;\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n        this.pieIndex = 0;\n        \n        this.interiorGap = DEFAULT_INTERIOR_GAP;\n        this.circular = true;\n        this.startAngle = DEFAULT_START_ANGLE;\n        this.direction = Rotation.CLOCKWISE;\n        this.minimumArcAngleToDraw = DEFAULT_MINIMUM_ARC_ANGLE_TO_DRAW;\n\n        this.sectionPaintMap = new PaintMap();\n        this.baseSectionPaint = Color.gray;\n\n        this.sectionOutlinesVisible = true;\n        this.sectionOutlinePaintMap = new PaintMap();\n        this.baseSectionOutlinePaint = DEFAULT_OUTLINE_PAINT;\n\n        this.sectionOutlineStrokeMap = new StrokeMap();\n        this.baseSectionOutlineStroke = DEFAULT_OUTLINE_STROKE;\n        \n        this.explodePercentages = new TreeMap();\n\n        this.labelGenerator = new StandardPieSectionLabelGenerator();\n        this.labelFont = DEFAULT_LABEL_FONT;\n        this.labelPaint = DEFAULT_LABEL_PAINT;\n        this.labelBackgroundPaint = DEFAULT_LABEL_BACKGROUND_PAINT;\n        this.labelOutlinePaint = DEFAULT_LABEL_OUTLINE_PAINT;\n        this.labelOutlineStroke = DEFAULT_LABEL_OUTLINE_STROKE;\n        this.labelShadowPaint = DEFAULT_LABEL_SHADOW_PAINT;\n        this.labelLinksVisible = true;\n        this.labelDistributor = new PieLabelDistributor(0);\n        \n        this.simpleLabels = false;\n        this.simpleLabelOffset = new RectangleInsets(UnitType.RELATIVE, 0.18, \n                0.18, 0.18, 0.18);\n        this.labelPadding = new RectangleInsets(2, 2, 2, 2);\n        \n        this.toolTipGenerator = null;\n        this.urlGenerator = null;\n        this.legendLabelGenerator = new StandardPieSectionLabelGenerator();\n        this.legendLabelToolTipGenerator = null;\n        this.legendLabelURLGenerator = null;\n        this.legendItemShape = Plot.DEFAULT_LEGEND_ITEM_CIRCLE;\n        \n        this.ignoreNullValues = false;\n        this.ignoreZeroValues = false;\n    }\n\n    \n    public PieDataset getDataset() {\n        return this.dataset;\n    }\n\n    \n    public void setDataset(PieDataset dataset) {\n        \n        \n        PieDataset existing = this.dataset;\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n\n        \n        this.dataset = dataset;\n        if (dataset != null) {\n            setDatasetGroup(dataset.getGroup());\n            dataset.addChangeListener(this);\n        }\n\n        \n        DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n        datasetChanged(event);\n    }\n    \n    \n    public int getPieIndex() {\n        return this.pieIndex;\n    }\n    \n    \n    public void setPieIndex(int index) {\n        this.pieIndex = index;\n    }\n    \n    \n    public double getStartAngle() {\n        return this.startAngle;\n    }\n\n    \n    public void setStartAngle(double angle) {\n        this.startAngle = angle;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public Rotation getDirection() {\n        return this.direction;\n    }\n\n    \n    public void setDirection(Rotation direction) {\n        if (direction == null) {\n            throw new IllegalArgumentException(\"Null 'direction' argument.\");\n        }\n        this.direction = direction;\n        notifyListeners(new PlotChangeEvent(this));\n\n    }\n\n    \n    public double getInteriorGap() {\n        return this.interiorGap;\n    }\n\n    \n    public void setInteriorGap(double percent) {\n\n        if ((percent < 0.0) || (percent > MAX_INTERIOR_GAP)) {\n            throw new IllegalArgumentException(\n                \"Invalid 'percent' (\" + percent + \") argument.\");\n        }\n\n        if (this.interiorGap != percent) {\n            this.interiorGap = percent;\n            notifyListeners(new PlotChangeEvent(this));\n        }\n\n    }\n\n    \n    public boolean isCircular() {\n        return this.circular;\n    }\n\n    \n    public void setCircular(boolean flag) {\n        setCircular(flag, true);\n    }\n\n    \n    public void setCircular(boolean circular, boolean notify) {\n        this.circular = circular;\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));   \n        }\n    }\n\n    \n    public boolean getIgnoreNullValues() {\n        return this.ignoreNullValues;   \n    }\n    \n    \n    public void setIgnoreNullValues(boolean flag) {\n        this.ignoreNullValues = flag;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public boolean getIgnoreZeroValues() {\n        return this.ignoreZeroValues;   \n    }\n    \n    \n    public void setIgnoreZeroValues(boolean flag) {\n        this.ignoreZeroValues = flag;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n\n    \n    protected Paint lookupSectionPaint(Comparable key) {\n        return lookupSectionPaint(key, false);        \n    }\n    \n    \n    protected Paint lookupSectionPaint(Comparable key, boolean autoPopulate) {\n        Paint result = null;\n        \n        \n        result = this.sectionPaintMap.getPaint(key);\n        if (result != null) {\n            return result;\n        }\n        \n        \n        if (autoPopulate) {\n            DrawingSupplier ds = getDrawingSupplier();\n            if (ds != null) {\n                result = ds.getNextPaint();\n                this.sectionPaintMap.put(key, result);\n            }\n            else {\n                result = this.baseSectionPaint;\n            }\n        }\n        else {\n            result = this.baseSectionPaint;\n        }\n        return result;\n    }\n    \n    \n    protected Comparable getSectionKey(int section) {\n        Comparable key = null;\n        if (this.dataset != null) {\n            if (section >= 0 && section < this.dataset.getItemCount()) {\n                key = this.dataset.getKey(section);\n            }\n        }\n        if (key == null) {\n            key = new Integer(section);\n        }\n        return key;\n    }\n    \n    \n    public Paint getSectionPaint(Comparable key) {\n        \n        return this.sectionPaintMap.getPaint(key);\n    }\n    \n    \n    public void setSectionPaint(Comparable key, Paint paint) {\n        \n        this.sectionPaintMap.put(key, paint);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public Paint getBaseSectionPaint() {\n        return this.baseSectionPaint;   \n    }\n    \n    \n    public void setBaseSectionPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.baseSectionPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n\n    \n    public boolean getSectionOutlinesVisible() {\n        return this.sectionOutlinesVisible;\n    }\n    \n    \n    public void setSectionOutlinesVisible(boolean visible) {\n        this.sectionOutlinesVisible = visible;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    protected Paint lookupSectionOutlinePaint(Comparable key) {\n        return lookupSectionOutlinePaint(key, false);        \n    }\n    \n    \n    protected Paint lookupSectionOutlinePaint(Comparable key, boolean autoPopulate) {\n        \n        Paint result = null;\n        \n        \n        result = this.sectionOutlinePaintMap.getPaint(key);\n        if (result != null) {\n            return result;\n        }\n        \n        \n        if (autoPopulate) {\n            DrawingSupplier ds = getDrawingSupplier();\n            if (ds != null) {\n                result = ds.getNextOutlinePaint();\n                this.sectionOutlinePaintMap.put(key, result);\n            }\n            else {\n                result = this.baseSectionOutlinePaint;\n            }\n        }\n        else {\n            result = this.baseSectionOutlinePaint;\n        }\n        return result;\n    }\n\n    \n    public Paint getSectionOutlinePaint(Comparable key) {\n        \n        return this.sectionOutlinePaintMap.getPaint(key);\n    }\n    \n    \n    public void setSectionOutlinePaint(Comparable key, Paint paint) {\n        \n        this.sectionOutlinePaintMap.put(key, paint);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public Paint getBaseSectionOutlinePaint() {\n        return this.baseSectionOutlinePaint;   \n    }\n    \n    \n    public void setBaseSectionOutlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.baseSectionOutlinePaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n\n    \n    protected Stroke lookupSectionOutlineStroke(Comparable key) {\n        return lookupSectionOutlineStroke(key, false);        \n    }\n    \n    \n    protected Stroke lookupSectionOutlineStroke(Comparable key, boolean autoPopulate) {\n        \n        Stroke result = null;\n        \n        \n        result = this.sectionOutlineStrokeMap.getStroke(key);\n        if (result != null) {\n            return result;\n        }\n        \n        \n        if (autoPopulate) {\n            DrawingSupplier ds = getDrawingSupplier();\n            if (ds != null) {\n                result = ds.getNextOutlineStroke();\n                this.sectionOutlineStrokeMap.put(key, result);\n            }\n            else {\n                result = this.baseSectionOutlineStroke;\n            }\n        }\n        else {\n            result = this.baseSectionOutlineStroke;\n        }\n        return result;\n    }\n    \n    \n    public Stroke getSectionOutlineStroke(Comparable key) {\n        \n        return this.sectionOutlineStrokeMap.getStroke(key);\n    }\n    \n    \n    public void setSectionOutlineStroke(Comparable key, Stroke stroke) {\n        \n        this.sectionOutlineStrokeMap.put(key, stroke);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public Stroke getBaseSectionOutlineStroke() {\n        return this.baseSectionOutlineStroke;   \n    }\n    \n    \n    public void setBaseSectionOutlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");   \n        }\n        this.baseSectionOutlineStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public Paint getShadowPaint() {\n        return this.shadowPaint;   \n    }\n    \n    \n    public void setShadowPaint(Paint paint) {\n        this.shadowPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public double getShadowXOffset() {\n        return this.shadowXOffset;\n    }\n    \n    \n    public void setShadowXOffset(double offset) {\n        this.shadowXOffset = offset;   \n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public double getShadowYOffset() {\n        return this.shadowYOffset;\n    }\n    \n    \n    public void setShadowYOffset(double offset) {\n        this.shadowYOffset = offset;   \n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public double getExplodePercent(Comparable key) {\n        double result = 0.0;\n        if (this.explodePercentages != null) {\n            Number percent = (Number) this.explodePercentages.get(key);\n            if (percent != null) {\n                result = percent.doubleValue();\n            }\n        }\n        return result;\n    }\n    \n    \n    public void setExplodePercent(Comparable key, double percent) {\n        if (key == null) { \n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (this.explodePercentages == null) {\n            this.explodePercentages = new TreeMap();\n        }\n        this.explodePercentages.put(key, new Double(percent));\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public double getMaximumExplodePercent() {\n        if (this.dataset == null) {\n            return 0.0;\n        }\n        double result = 0.0;\n        Iterator iterator = this.dataset.getKeys().iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            Number explode = (Number) this.explodePercentages.get(key);\n            if (explode != null) {\n                result = Math.max(result, explode.doubleValue());   \n            }\n        }\n        return result;\n    }\n    \n    \n    public PieSectionLabelGenerator getLabelGenerator() {\n        return this.labelGenerator;   \n    }\n    \n    \n    public void setLabelGenerator(PieSectionLabelGenerator generator) {\n        this.labelGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public double getLabelGap() {\n        return this.labelGap;   \n    }\n    \n    \n    public void setLabelGap(double gap) {\n        this.labelGap = gap;   \n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public double getMaximumLabelWidth() {\n        return this.maximumLabelWidth;   \n    }\n    \n    \n    public void setMaximumLabelWidth(double width) {\n        this.maximumLabelWidth = width;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public boolean getLabelLinksVisible() {\n        return this.labelLinksVisible;\n    }\n    \n    \n    public void setLabelLinksVisible(boolean visible) {\n        this.labelLinksVisible = visible;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public double getLabelLinkMargin() {\n        return this.labelLinkMargin;   \n    }\n    \n    \n    public void setLabelLinkMargin(double margin) {\n        this.labelLinkMargin = margin;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public Paint getLabelLinkPaint() {\n        return this.labelLinkPaint;   \n    }\n    \n    \n    public void setLabelLinkPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.labelLinkPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public Stroke getLabelLinkStroke() {\n        return this.labelLinkStroke;   \n    }\n    \n    \n    public void setLabelLinkStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.labelLinkStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public Font getLabelFont() {\n        return this.labelFont;\n    }\n\n    \n    public void setLabelFont(Font font) {\n        if (font == null) {\n            throw new IllegalArgumentException(\"Null 'font' argument.\");\n        }\n        this.labelFont = font;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public Paint getLabelPaint() {\n        return this.labelPaint;\n    }\n\n    \n    public void setLabelPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.labelPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public Paint getLabelBackgroundPaint() {\n        return this.labelBackgroundPaint;\n    }\n\n    \n    public void setLabelBackgroundPaint(Paint paint) {\n        this.labelBackgroundPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public Paint getLabelOutlinePaint() {\n        return this.labelOutlinePaint;\n    }\n\n    \n    public void setLabelOutlinePaint(Paint paint) {\n        this.labelOutlinePaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public Stroke getLabelOutlineStroke() {\n        return this.labelOutlineStroke;\n    }\n\n    \n    public void setLabelOutlineStroke(Stroke stroke) {\n        this.labelOutlineStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public Paint getLabelShadowPaint() {\n        return this.labelShadowPaint;\n    }\n\n    \n    public void setLabelShadowPaint(Paint paint) {\n        this.labelShadowPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public RectangleInsets getLabelPadding() {\n        return this.labelPadding;\n    }\n    \n    \n    public void setLabelPadding(RectangleInsets padding) {\n        if (padding == null) {\n            throw new IllegalArgumentException(\"Null 'padding' argument.\");\n        }\n        this.labelPadding = padding;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public boolean getSimpleLabels() {\n        return this.simpleLabels;\n    }\n    \n    \n    public void setSimpleLabels(boolean simple) {\n        this.simpleLabels = simple;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public RectangleInsets getSimpleLabelOffset() {\n        return this.simpleLabelOffset;\n    }\n    \n    \n    public void setSimpleLabelOffset(RectangleInsets offset) {\n        if (offset == null) {\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");\n        }\n        this.simpleLabelOffset = offset;\n        notifyListeners(new PlotChangeEvent(this));        \n    }\n    \n    \n    public AbstractPieLabelDistributor getLabelDistributor() {\n        return this.labelDistributor;\n    }\n    \n    \n    public void setLabelDistributor(AbstractPieLabelDistributor distributor) {\n        if (distributor == null) {\n            throw new IllegalArgumentException(\"Null 'distributor' argument.\");\n        }\n        this.labelDistributor = distributor;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public PieToolTipGenerator getToolTipGenerator() {\n        return this.toolTipGenerator;\n    }\n\n    \n    public void setToolTipGenerator(PieToolTipGenerator generator) {\n        this.toolTipGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public PieURLGenerator getURLGenerator() {\n        return this.urlGenerator;\n    }\n\n    \n    public void setURLGenerator(PieURLGenerator generator) {\n        this.urlGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public double getMinimumArcAngleToDraw() {\n        return this.minimumArcAngleToDraw;\n    }\n\n    \n    public void setMinimumArcAngleToDraw(double angle) {\n        this.minimumArcAngleToDraw = angle;\n    }\n    \n    \n    public Shape getLegendItemShape() {\n        return this.legendItemShape;\n    }\n\n    \n    public void setLegendItemShape(Shape shape) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        this.legendItemShape = shape;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public PieSectionLabelGenerator getLegendLabelGenerator() {\n        return this.legendLabelGenerator;\n    }\n    \n    \n    public void setLegendLabelGenerator(PieSectionLabelGenerator generator) {\n        if (generator == null) {\n            throw new IllegalArgumentException(\"Null 'generator' argument.\");\n        }\n        this.legendLabelGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public PieSectionLabelGenerator getLegendLabelToolTipGenerator() {\n        return this.legendLabelToolTipGenerator;\n    }\n    \n    \n    public void setLegendLabelToolTipGenerator( PieSectionLabelGenerator generator) {\n        this.legendLabelToolTipGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public PieURLGenerator getLegendLabelURLGenerator() {\n        return this.legendLabelURLGenerator;\n    }\n    \n    \n    public void setLegendLabelURLGenerator(PieURLGenerator generator) {\n        this.legendLabelURLGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea, PiePlot plot, Integer index, PlotRenderingInfo info) {\n     \n        PiePlotState state = new PiePlotState(info);\n        state.setPassesRequired(2);\n        if (this.dataset != null) {\n            state.setTotal(DatasetUtilities.calculatePieDatasetTotal(\n                    plot.getDataset()));\n        }\n        state.setLatestAngle(plot.getStartAngle());\n        return state;\n        \n    }\n    \n    \n    public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo info) {\n\n        \n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n\n        if (info != null) {\n            info.setPlotArea(area);\n            info.setDataArea(area);\n        }\n\n        drawBackground(g2, area);\n        drawOutline(g2, area);\n\n        Shape savedClip = g2.getClip();\n        g2.clip(area);\n\n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n                getForegroundAlpha()));\n\n        if (!DatasetUtilities.isEmptyOrNull(this.dataset)) {\n            drawPie(g2, area, info);\n        }\n        else {\n            drawNoDataMessage(g2, area);\n        }\n\n        g2.setClip(savedClip);\n        g2.setComposite(originalComposite);\n\n        drawOutline(g2, area);\n\n    }\n\n    \n    protected void drawPie(Graphics2D g2, Rectangle2D plotArea, PlotRenderingInfo info) {\n\n        PiePlotState state = initialise(g2, plotArea, this, null, info);\n\n        \n        double labelReserve = 0.0;\n        if (this.labelGenerator != null && !this.simpleLabels) {\n            labelReserve = this.labelGap + this.maximumLabelWidth;    \n        }\n        double gapHorizontal = plotArea.getWidth() * (this.interiorGap \n                + labelReserve) * 2.0;\n        double gapVertical = plotArea.getHeight() * this.interiorGap * 2.0;\n\n        \n        if (DEBUG_DRAW_INTERIOR) {\n            double hGap = plotArea.getWidth() * this.interiorGap;\n            double vGap = plotArea.getHeight() * this.interiorGap;\n        \n            double igx1 = plotArea.getX() + hGap;\n            double igx2 = plotArea.getMaxX() - hGap;\n            double igy1 = plotArea.getY() + vGap;\n            double igy2 = plotArea.getMaxY() - vGap;\n            g2.setPaint(Color.gray);\n            g2.draw(new Rectangle2D.Double(igx1, igy1, igx2 - igx1, \n                    igy2 - igy1));\n        }\n        \n        double linkX = plotArea.getX() + gapHorizontal / 2;\n        double linkY = plotArea.getY() + gapVertical / 2;\n        double linkW = plotArea.getWidth() - gapHorizontal;\n        double linkH = plotArea.getHeight() - gapVertical;\n        \n        \n        if (this.circular) {\n            double min = Math.min(linkW, linkH) / 2;\n            linkX = (linkX + linkX + linkW) / 2 - min;\n            linkY = (linkY + linkY + linkH) / 2 - min;\n            linkW = 2 * min;\n            linkH = 2 * min;\n        }\n\n        \n        \n        Rectangle2D linkArea = new Rectangle2D.Double(linkX, linkY, linkW, \n                linkH);\n        state.setLinkArea(linkArea);\n\n        if (DEBUG_DRAW_LINK_AREA) {\n            g2.setPaint(Color.blue);\n            g2.draw(linkArea);\n            g2.setPaint(Color.yellow);\n            g2.draw(new Ellipse2D.Double(linkArea.getX(), linkArea.getY(), \n                    linkArea.getWidth(), linkArea.getHeight()));\n        }\n        \n        \n        \n        \n        double lm = 0.0;\n        if (!this.simpleLabels) {\n            lm = this.labelLinkMargin;\n        }\n        double hh = linkArea.getWidth() * lm * 2.0;\n        double vv = linkArea.getHeight() * lm * 2.0;\n        Rectangle2D explodeArea = new Rectangle2D.Double(linkX + hh / 2.0, \n                linkY + vv / 2.0, linkW - hh, linkH - vv);\n       \n        state.setExplodedPieArea(explodeArea);\n        \n        \n        \n        \n        double maximumExplodePercent = getMaximumExplodePercent();\n        double percent = maximumExplodePercent / (1.0 + maximumExplodePercent);\n        \n        double h1 = explodeArea.getWidth() * percent;\n        double v1 = explodeArea.getHeight() * percent;\n        Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX() \n                + h1 / 2.0, explodeArea.getY() + v1 / 2.0, \n                explodeArea.getWidth() - h1, explodeArea.getHeight() - v1);\n\n        if (DEBUG_DRAW_PIE_AREA) {\n            g2.setPaint(Color.green);\n            g2.draw(pieArea);\n        }\n        state.setPieArea(pieArea);\n        state.setPieCenterX(pieArea.getCenterX());\n        state.setPieCenterY(pieArea.getCenterY());\n        state.setPieWRadius(pieArea.getWidth() / 2.0);\n        state.setPieHRadius(pieArea.getHeight() / 2.0);\n        \n        \n        if ((this.dataset != null) && (this.dataset.getKeys().size() > 0)) {\n\n            List keys = this.dataset.getKeys();\n            double totalValue = DatasetUtilities.calculatePieDatasetTotal(\n                    this.dataset);\n\n            int passesRequired = state.getPassesRequired();\n            for (int pass = 0; pass < passesRequired; pass++) {\n                double runningTotal = 0.0;\n                for (int section = 0; section < keys.size(); section++) {\n                    Number n = this.dataset.getValue(section);\n                    if (n != null) {\n                        double value = n.doubleValue();\n                        if (value > 0.0) {\n                            runningTotal += value;\n                            drawItem(g2, section, explodeArea, state, pass);\n                        }\n                    } \n                }\n            }\n            if (this.simpleLabels) {\n                drawSimpleLabels(g2, keys, totalValue, plotArea, linkArea, \n                        state);\n            }\n            else {\n                drawLabels(g2, keys, totalValue, plotArea, linkArea, state);\n            }\n\n        }\n        else {\n            drawNoDataMessage(g2, plotArea);\n        }\n    }\n    \n    \n    protected void drawItem(Graphics2D g2, int section, Rectangle2D dataArea, PiePlotState state, int currentPass) {\n    \n        Number n = this.dataset.getValue(section);\n        if (n == null) {\n            return;   \n        }\n        double value = n.doubleValue();\n        double angle1 = 0.0;\n        double angle2 = 0.0;\n        \n        if (this.direction == Rotation.CLOCKWISE) {\n            angle1 = state.getLatestAngle();\n            angle2 = angle1 - value / state.getTotal() * 360.0;\n        }\n        else if (this.direction == Rotation.ANTICLOCKWISE) {\n            angle1 = state.getLatestAngle();\n            angle2 = angle1 + value / state.getTotal() * 360.0;         \n        }\n        else {\n            throw new IllegalStateException(\"Rotation type not recognised.\");   \n        }\n        \n        double angle = (angle2 - angle1);\n        if (Math.abs(angle) > getMinimumArcAngleToDraw()) {\n            double ep = 0.0;\n            double mep = getMaximumExplodePercent();\n            if (mep > 0.0) {\n                ep = getExplodePercent(getSectionKey(section)) / mep;                \n            }\n            Rectangle2D arcBounds = getArcBounds(state.getPieArea(), \n                    state.getExplodedPieArea(), angle1, angle, ep);\n            Arc2D.Double arc = new Arc2D.Double(arcBounds, angle1, angle, \n                    Arc2D.PIE);\n            \n            if (currentPass == 0) {\n                if (this.shadowPaint != null) {\n                    Shape shadowArc = ShapeUtilities.createTranslatedShape(\n                            arc, (float) this.shadowXOffset, \n                            (float) this.shadowYOffset);\n                    g2.setPaint(this.shadowPaint);\n                    g2.fill(shadowArc);\n                }\n            }\n            else if (currentPass == 1) {\n                Comparable key = getSectionKey(section);\n                Paint paint = lookupSectionPaint(key, true);\n                g2.setPaint(paint);\n                g2.fill(arc);\n\n                Paint outlinePaint = lookupSectionOutlinePaint(key);\n                Stroke outlineStroke = lookupSectionOutlineStroke(key);\n                if (this.sectionOutlinesVisible) {\n                    g2.setPaint(outlinePaint);\n                    g2.setStroke(outlineStroke);\n                    g2.draw(arc);\n                }\n                \n                \n                \n                if (state.getInfo() != null) {\n                    EntityCollection entities = state.getEntityCollection();\n                    if (entities != null) {\n                        String tip = null;\n                        if (this.toolTipGenerator != null) {\n                            tip = this.toolTipGenerator.generateToolTip(\n                                    this.dataset, key);\n                        }\n                        String url = null;\n                        if (this.urlGenerator != null) {\n                            url = this.urlGenerator.generateURL(this.dataset, \n                                    key, this.pieIndex);\n                        }\n                        PieSectionEntity entity = new PieSectionEntity(\n                                arc, this.dataset, this.pieIndex, section, key,\n                                tip, url);\n                        entities.add(entity);\n                    }\n                }\n            }\n        }    \n        state.setLatestAngle(angle2);\n    }\n    \n    \n    protected void drawSimpleLabels(Graphics2D g2, List keys, double totalValue, Rectangle2D plotArea, Rectangle2D pieArea, PiePlotState state) {\n        \n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n                1.0f));\n\n        RectangleInsets labelInsets = new RectangleInsets(UnitType.RELATIVE, \n                0.18, 0.18, 0.18, 0.18);\n        Rectangle2D labelsArea = labelInsets.createInsetRectangle(pieArea);\n        double runningTotal = 0.0;\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            boolean include = true;\n            double v = 0.0;\n            Number n = getDataset().getValue(key);\n            if (n == null) {\n                include = !getIgnoreNullValues();\n            }\n            else {\n                v = n.doubleValue();\n                include = getIgnoreZeroValues() ? v > 0.0 : v >= 0.0;\n            }\n\n            if (include) {\n                runningTotal = runningTotal + v;\n                \n                \n                double mid = getStartAngle() + (getDirection().getFactor()\n                        * ((runningTotal - v / 2.0) * 360) / totalValue);\n                \n                Arc2D arc = new Arc2D.Double(labelsArea, getStartAngle(), \n                        mid - getStartAngle(), Arc2D.OPEN);\n                int x = (int) arc.getEndPoint().getX();\n                int y = (int) arc.getEndPoint().getY();\n                \n                PieSectionLabelGenerator labelGenerator = getLabelGenerator();\n                if (labelGenerator == null) {\n                    continue;\n                }\n                String label = labelGenerator.generateSectionLabel(\n                        this.dataset, key);\n                if (label == null) {\n                    continue;\n                }\n                g2.setFont(this.labelFont);\n                FontMetrics fm = g2.getFontMetrics();\n                Rectangle2D bounds = TextUtilities.getTextBounds(label, g2, fm);\n                Rectangle2D out = this.labelPadding.createOutsetRectangle(\n                        bounds);\n                Shape bg = ShapeUtilities.createTranslatedShape(out, \n                        x - bounds.getCenterX(), y - bounds.getCenterY());\n                if (this.labelShadowPaint != null) {\n                    Shape shadow = ShapeUtilities.createTranslatedShape(bg, \n                            this.shadowXOffset, this.shadowYOffset);\n                    g2.setPaint(this.labelShadowPaint);\n                    g2.fill(shadow);\n                }\n                if (this.labelBackgroundPaint != null) {\n                    g2.setPaint(this.labelBackgroundPaint);\n                    g2.fill(bg);\n                }\n                if (this.labelOutlinePaint != null \n                        && this.labelOutlineStroke != null) {\n                    g2.setPaint(this.labelOutlinePaint);\n                    g2.setStroke(this.labelOutlineStroke);\n                    g2.draw(bg);\n                }\n                \n                g2.setPaint(this.labelPaint);\n                g2.setFont(this.labelFont);\n                TextUtilities.drawAlignedString(getLabelGenerator()\n                        .generateSectionLabel(getDataset(), key), g2, x, y, \n                        TextAnchor.CENTER);\n                \n            }\n        }\n       \n        g2.setComposite(originalComposite);\n\n    }\n\n    \n    protected void drawLabels(Graphics2D g2, List keys, double totalValue, Rectangle2D plotArea, Rectangle2D linkArea, PiePlotState state) {   \n\n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n                1.0f));\n\n        \n        DefaultKeyedValues leftKeys = new DefaultKeyedValues();\n        DefaultKeyedValues rightKeys = new DefaultKeyedValues();\n       \n        double runningTotal = 0.0;\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            boolean include = true;\n            double v = 0.0;\n            Number n = this.dataset.getValue(key);\n            if (n == null) {\n                include = !this.ignoreNullValues;\n            }\n            else {\n                v = n.doubleValue();\n                include = this.ignoreZeroValues ? v > 0.0 : v >= 0.0;\n            }\n\n            if (include) {\n                runningTotal = runningTotal + v;\n                \n                \n                double mid = this.startAngle + (this.direction.getFactor()\n                        * ((runningTotal - v / 2.0) * 360) / totalValue);\n                if (Math.cos(Math.toRadians(mid)) < 0.0) {\n                    leftKeys.addValue(key, new Double(mid));\n                }\n                else {\n                    rightKeys.addValue(key, new Double(mid));\n                }\n            }\n        }\n       \n        g2.setFont(getLabelFont());\n        \n        \n        \n        double marginX = plotArea.getX() + this.interiorGap * plotArea.getWidth();\n        double gap = plotArea.getWidth() * this.labelGap;\n        double ww = linkArea.getX() - gap - marginX;\n        float labelWidth = (float) this.labelPadding.trimWidth(ww);\n        \n        \n        if (this.labelGenerator != null) {\n            drawLeftLabels(leftKeys, g2, plotArea, linkArea, labelWidth, \n                    state);\n            drawRightLabels(rightKeys, g2, plotArea, linkArea, labelWidth, \n                    state);\n        }\n        g2.setComposite(originalComposite);\n\n    }\n\n    \n    protected void drawLeftLabels(KeyedValues leftKeys, Graphics2D g2, Rectangle2D plotArea, Rectangle2D linkArea, float maxLabelWidth, PiePlotState state) {\n        \n        this.labelDistributor.clear();\n        double lGap = plotArea.getWidth() * this.labelGap;\n        double verticalLinkRadius = state.getLinkArea().getHeight() / 2.0;\n        for (int i = 0; i < leftKeys.getItemCount(); i++) {   \n            String label = this.labelGenerator.generateSectionLabel(\n                    this.dataset, leftKeys.getKey(i));\n            if (label != null) {\n                TextBlock block = TextUtilities.createTextBlock(label, \n                        this.labelFont, this.labelPaint, maxLabelWidth, \n                        new G2TextMeasurer(g2));\n                TextBox labelBox = new TextBox(block);\n                labelBox.setBackgroundPaint(this.labelBackgroundPaint);\n                labelBox.setOutlinePaint(this.labelOutlinePaint);\n                labelBox.setOutlineStroke(this.labelOutlineStroke);\n                labelBox.setShadowPaint(this.labelShadowPaint);\n                labelBox.setInteriorGap(this.labelPadding);\n                double theta = Math.toRadians(\n                        leftKeys.getValue(i).doubleValue());\n                double baseY = state.getPieCenterY() - Math.sin(theta) \n                               * verticalLinkRadius;\n                double hh = labelBox.getHeight(g2);\n\n                this.labelDistributor.addPieLabelRecord(new PieLabelRecord(\n                        leftKeys.getKey(i), theta, baseY, labelBox, hh,\n                        lGap / 2.0 + lGap / 2.0 * -Math.cos(theta), 0.9 \n                        + getExplodePercent(leftKeys.getKey(i))));\n            }\n        }\n        this.labelDistributor.distributeLabels(plotArea.getMinY(), \n                plotArea.getHeight());\n        for (int i = 0; i < this.labelDistributor.getItemCount(); i++) {\n            drawLeftLabel(g2, state, \n                    this.labelDistributor.getPieLabelRecord(i));\n        }\n    }\n    \n    \n    protected void drawRightLabels(KeyedValues keys, Graphics2D g2, Rectangle2D plotArea, Rectangle2D linkArea, float maxLabelWidth, PiePlotState state) {\n\n        \n        this.labelDistributor.clear();\n        double lGap = plotArea.getWidth() * this.labelGap;\n        double verticalLinkRadius = state.getLinkArea().getHeight() / 2.0;\n\n        for (int i = 0; i < keys.getItemCount(); i++) {\n            String label = this.labelGenerator.generateSectionLabel(\n                    this.dataset, keys.getKey(i));\n\n            if (label != null) {\n                TextBlock block = TextUtilities.createTextBlock(label, \n                        this.labelFont, this.labelPaint, maxLabelWidth, \n                        new G2TextMeasurer(g2));\n                TextBox labelBox = new TextBox(block);\n                labelBox.setBackgroundPaint(this.labelBackgroundPaint);\n                labelBox.setOutlinePaint(this.labelOutlinePaint);\n                labelBox.setOutlineStroke(this.labelOutlineStroke);\n                labelBox.setShadowPaint(this.labelShadowPaint);\n                labelBox.setInteriorGap(this.labelPadding);\n                double theta = Math.toRadians(keys.getValue(i).doubleValue());\n                double baseY = state.getPieCenterY() \n                              - Math.sin(theta) * verticalLinkRadius;\n                double hh = labelBox.getHeight(g2);\n                this.labelDistributor.addPieLabelRecord(new PieLabelRecord(\n                        keys.getKey(i), theta, baseY, labelBox, hh,\n                        lGap / 2.0 + lGap / 2.0 * Math.cos(theta), \n                        0.9 + getExplodePercent(keys.getKey(i))));\n            }\n        }\n        this.labelDistributor.distributeLabels(plotArea.getMinY(), \n                plotArea.getHeight());\n        for (int i = 0; i < this.labelDistributor.getItemCount(); i++) {\n            drawRightLabel(g2, state, \n                    this.labelDistributor.getPieLabelRecord(i));\n        }\n\n    }\n    \n    \n    public LegendItemCollection getLegendItems() {\n\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.dataset == null) {\n            return result;\n        }\n        List keys = this.dataset.getKeys();\n        int section = 0;\n        Shape shape = getLegendItemShape();\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            Number n = this.dataset.getValue(key);\n            boolean include = true;\n            if (n == null) {\n                include = !this.ignoreNullValues;   \n            }\n            else {\n                double v = n.doubleValue();\n                if (v == 0.0) {\n                    include = !this.ignoreZeroValues;   \n                }\n                else {\n                    include = v > 0.0;   \n                }\n            }\n            if (include) {\n                String label = this.legendLabelGenerator.generateSectionLabel(\n                        this.dataset, key);\n                if (label != null) {\n                    String description = label;\n                    String toolTipText = null;\n                    if (this.legendLabelToolTipGenerator != null) {\n                        toolTipText = this.legendLabelToolTipGenerator\n                                .generateSectionLabel(this.dataset, key);\n                    }\n                    String urlText = null;\n                    if (this.legendLabelURLGenerator != null) {\n                        urlText = this.legendLabelURLGenerator.generateURL(\n                                this.dataset, key, this.pieIndex);\n                    }\n                    Paint paint = lookupSectionPaint(key, true);\n                    Paint outlinePaint = lookupSectionOutlinePaint(key);\n                    Stroke outlineStroke = lookupSectionOutlineStroke(key);\n                    LegendItem item = new LegendItem(label, description, \n                            toolTipText, urlText, true, shape, true, paint, \n                            true, outlinePaint, outlineStroke, \n                            false,          \n                            new Line2D.Float(), new BasicStroke(), Color.black);\n                    item.setDataset(getDataset());\n                    result.add(item);\n                }\n                section++;\n            }\n            else {\n                section++;\n            }\n        }\n        return result;\n    }\n\n    \n    public String getPlotType() {\n        return localizationResources.getString(\"Pie_Plot\");\n    }\n\n    \n    protected Rectangle2D getArcBounds(Rectangle2D unexploded, Rectangle2D exploded, double angle, double extent, double explodePercent) {\n\n        if (explodePercent == 0.0) {\n            return unexploded;\n        }\n        else {\n            Arc2D arc1 = new Arc2D.Double(unexploded, angle, extent / 2, \n                    Arc2D.OPEN);\n            Point2D point1 = arc1.getEndPoint();\n            Arc2D.Double arc2 = new Arc2D.Double(exploded, angle, extent / 2, \n                    Arc2D.OPEN);\n            Point2D point2 = arc2.getEndPoint();\n            double deltaX = (point1.getX() - point2.getX()) * explodePercent;\n            double deltaY = (point1.getY() - point2.getY()) * explodePercent;\n            return new Rectangle2D.Double(unexploded.getX() - deltaX, \n                    unexploded.getY() - deltaY, unexploded.getWidth(), \n                    unexploded.getHeight());\n        }\n    }\n    \n    \n    protected void drawLeftLabel(Graphics2D g2, PiePlotState state, PieLabelRecord record) {\n\n        double anchorX = state.getLinkArea().getMinX();\n        double targetX = anchorX - record.getGap();\n        double targetY = record.getAllocatedY();\n        \n        if (this.labelLinksVisible) {\n            double theta = record.getAngle();\n            double linkX = state.getPieCenterX() + Math.cos(theta) \n                    * state.getPieWRadius() * record.getLinkPercent();\n            double linkY = state.getPieCenterY() - Math.sin(theta) \n                    * state.getPieHRadius() * record.getLinkPercent();\n            double elbowX = state.getPieCenterX() + Math.cos(theta) \n                    * state.getLinkArea().getWidth() / 2.0;\n            double elbowY = state.getPieCenterY() - Math.sin(theta) \n                    * state.getLinkArea().getHeight() / 2.0;\n            double anchorY = elbowY;\n            g2.setPaint(this.labelLinkPaint);\n            g2.setStroke(this.labelLinkStroke);\n            g2.draw(new Line2D.Double(linkX, linkY, elbowX, elbowY));\n            g2.draw(new Line2D.Double(anchorX, anchorY, elbowX, elbowY));\n            g2.draw(new Line2D.Double(anchorX, anchorY, targetX, targetY));\n        }\n        TextBox tb = record.getLabel();\n        tb.draw(g2, (float) targetX, (float) targetY, RectangleAnchor.RIGHT);\n        \n    }\n\n    \n    protected void drawRightLabel(Graphics2D g2, PiePlotState state, PieLabelRecord record) {\n        \n        double anchorX = state.getLinkArea().getMaxX();\n        double targetX = anchorX + record.getGap();\n        double targetY = record.getAllocatedY();\n        \n        if (this.labelLinksVisible) {\n            double theta = record.getAngle();\n            double linkX = state.getPieCenterX() + Math.cos(theta) \n                    * state.getPieWRadius() * record.getLinkPercent();\n            double linkY = state.getPieCenterY() - Math.sin(theta) \n                    * state.getPieHRadius() * record.getLinkPercent();\n            double elbowX = state.getPieCenterX() + Math.cos(theta) \n                    * state.getLinkArea().getWidth() / 2.0;\n            double elbowY = state.getPieCenterY() - Math.sin(theta) \n                    * state.getLinkArea().getHeight() / 2.0;\n            double anchorY = elbowY;\n            g2.setPaint(this.labelLinkPaint);\n            g2.setStroke(this.labelLinkStroke);\n            g2.draw(new Line2D.Double(linkX, linkY, elbowX, elbowY));\n            g2.draw(new Line2D.Double(anchorX, anchorY, elbowX, elbowY));\n            g2.draw(new Line2D.Double(anchorX, anchorY, targetX, targetY));\n        }\n        \n        TextBox tb = record.getLabel();\n        tb.draw(g2, (float) targetX, (float) targetY, RectangleAnchor.LEFT);\n    \n    }\n\n    \n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof PiePlot)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        PiePlot that = (PiePlot) obj;\n        if (this.pieIndex != that.pieIndex) {\n            return false;\n        }\n        if (this.interiorGap != that.interiorGap) {\n            return false;\n        }\n        if (this.circular != that.circular) {\n            return false;\n        }\n        if (this.startAngle != that.startAngle) {\n            return false;\n        }\n        if (this.direction != that.direction) {\n            return false;\n        }\n        if (this.ignoreZeroValues != that.ignoreZeroValues) {\n            return false;\n        }\n        if (this.ignoreNullValues != that.ignoreNullValues) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.sectionPaintMap, \n                that.sectionPaintMap)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.baseSectionPaint, \n                that.baseSectionPaint)) {\n            return false;\n        }\n        if (this.sectionOutlinesVisible != that.sectionOutlinesVisible) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.sectionOutlinePaintMap, \n                that.sectionOutlinePaintMap)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(\n            this.baseSectionOutlinePaint, that.baseSectionOutlinePaint\n        )) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.sectionOutlineStrokeMap, \n                that.sectionOutlineStrokeMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(\n            this.baseSectionOutlineStroke, that.baseSectionOutlineStroke\n        )) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.shadowPaint, that.shadowPaint)) {\n            return false;\n        }\n        if (!(this.shadowXOffset == that.shadowXOffset)) {\n            return false;\n        }\n        if (!(this.shadowYOffset == that.shadowYOffset)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.explodePercentages, \n                that.explodePercentages)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelGenerator, \n                that.labelGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelFont, that.labelFont)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelPaint, that.labelPaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelBackgroundPaint, \n                that.labelBackgroundPaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelOutlinePaint, \n                that.labelOutlinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelOutlineStroke, \n                that.labelOutlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelShadowPaint, \n                that.labelShadowPaint)) {\n            return false;\n        }\n        if (this.simpleLabels != that.simpleLabels) {\n            return false;\n        }\n        if (!this.simpleLabelOffset.equals(that.simpleLabelOffset)) {\n            return false;\n        }\n        if (!this.labelPadding.equals(that.labelPadding)) {\n            return false;\n        }\n        if (!(this.maximumLabelWidth == that.maximumLabelWidth)) {\n            return false;\n        }\n        if (!(this.labelGap == that.labelGap)) {\n            return false;\n        }\n        if (!(this.labelLinkMargin == that.labelLinkMargin)) {\n            return false;\n        }\n        if (this.labelLinksVisible != that.labelLinksVisible) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelLinkPaint, that.labelLinkPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelLinkStroke, \n                that.labelLinkStroke)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.toolTipGenerator, \n                that.toolTipGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.urlGenerator, that.urlGenerator)) {\n            return false;\n        }\n        if (!(this.minimumArcAngleToDraw == that.minimumArcAngleToDraw)) {\n            return false;\n        }\n        if (!ShapeUtilities.equal(this.legendItemShape, that.legendItemShape)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.legendLabelGenerator, \n                that.legendLabelGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.legendLabelToolTipGenerator,\n                that.legendLabelToolTipGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.legendLabelURLGenerator,\n                that.legendLabelURLGenerator)) {\n            return false;\n        }\n        \n        return true;\n    }\n\n    \n    public Object clone() throws CloneNotSupportedException {\n        PiePlot clone = (PiePlot) super.clone();\n        if (clone.dataset != null) {\n            clone.dataset.addChangeListener(clone);\n        }\n        if (this.urlGenerator instanceof PublicCloneable) {\n            clone.urlGenerator = (PieURLGenerator) ObjectUtilities.clone(\n                    this.urlGenerator);\n        }\n        clone.legendItemShape = ShapeUtilities.clone(this.legendItemShape);\n        if (this.legendLabelGenerator != null) {\n            clone.legendLabelGenerator = (PieSectionLabelGenerator) \n                    ObjectUtilities.clone(this.legendLabelGenerator);\n        }\n        if (this.legendLabelToolTipGenerator != null) {\n            clone.legendLabelToolTipGenerator = (PieSectionLabelGenerator) \n                    ObjectUtilities.clone(this.legendLabelToolTipGenerator);\n        }\n        if (this.legendLabelURLGenerator instanceof PublicCloneable) {\n            clone.legendLabelURLGenerator = (PieURLGenerator) \n                    ObjectUtilities.clone(this.legendLabelURLGenerator);\n        }\n        return clone;\n    }\n\n    \n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writePaint(this.baseSectionPaint, stream);\n        SerialUtilities.writePaint(this.baseSectionOutlinePaint, stream);\n        SerialUtilities.writeStroke(this.baseSectionOutlineStroke, stream);\n        SerialUtilities.writePaint(this.shadowPaint, stream);\n        SerialUtilities.writePaint(this.labelPaint, stream);\n        SerialUtilities.writePaint(this.labelBackgroundPaint, stream);\n        SerialUtilities.writePaint(this.labelOutlinePaint, stream);\n        SerialUtilities.writeStroke(this.labelOutlineStroke, stream);\n        SerialUtilities.writePaint(this.labelShadowPaint, stream);\n        SerialUtilities.writePaint(this.labelLinkPaint, stream);\n        SerialUtilities.writeStroke(this.labelLinkStroke, stream);\n        SerialUtilities.writeShape(this.legendItemShape, stream);\n    }\n\n    \n    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.baseSectionPaint = SerialUtilities.readPaint(stream);\n        this.baseSectionOutlinePaint = SerialUtilities.readPaint(stream);\n        this.baseSectionOutlineStroke = SerialUtilities.readStroke(stream);\n        this.shadowPaint = SerialUtilities.readPaint(stream);\n        this.labelPaint = SerialUtilities.readPaint(stream);\n        this.labelBackgroundPaint = SerialUtilities.readPaint(stream);\n        this.labelOutlinePaint = SerialUtilities.readPaint(stream);\n        this.labelOutlineStroke = SerialUtilities.readStroke(stream);\n        this.labelShadowPaint = SerialUtilities.readPaint(stream);\n        this.labelLinkPaint = SerialUtilities.readPaint(stream);\n        this.labelLinkStroke = SerialUtilities.readStroke(stream);\n        this.legendItemShape = SerialUtilities.readShape(stream);\n    }\n\n}\n",
      "buggy_signatures": [
        "public PiePlot(PieDataset dataset)",
        "public PieDataset getDataset()",
        "public void setDataset(PieDataset dataset)",
        "public int getPieIndex()",
        "public void setPieIndex(int index)",
        "public double getStartAngle()",
        "public void setStartAngle(double angle)",
        "public Rotation getDirection()",
        "public void setDirection(Rotation direction)",
        "public double getInteriorGap()",
        "public void setInteriorGap(double percent)",
        "public boolean isCircular()",
        "public void setCircular(boolean flag)",
        "public void setCircular(boolean circular, boolean notify)",
        "public boolean getIgnoreNullValues()",
        "public void setIgnoreNullValues(boolean flag)",
        "public boolean getIgnoreZeroValues()",
        "public void setIgnoreZeroValues(boolean flag)",
        "protected Paint lookupSectionPaint(Comparable key)",
        "protected Paint lookupSectionPaint(Comparable key, boolean autoPopulate)",
        "protected Comparable getSectionKey(int section)",
        "public Paint getSectionPaint(Comparable key)",
        "public void setSectionPaint(Comparable key, Paint paint)",
        "public Paint getBaseSectionPaint()",
        "public void setBaseSectionPaint(Paint paint)",
        "public boolean getSectionOutlinesVisible()",
        "public void setSectionOutlinesVisible(boolean visible)",
        "protected Paint lookupSectionOutlinePaint(Comparable key)",
        "protected Paint lookupSectionOutlinePaint(Comparable key, boolean autoPopulate)",
        "public Paint getSectionOutlinePaint(Comparable key)",
        "public void setSectionOutlinePaint(Comparable key, Paint paint)",
        "public Paint getBaseSectionOutlinePaint()",
        "public void setBaseSectionOutlinePaint(Paint paint)",
        "protected Stroke lookupSectionOutlineStroke(Comparable key)",
        "protected Stroke lookupSectionOutlineStroke(Comparable key, boolean autoPopulate)",
        "public Stroke getSectionOutlineStroke(Comparable key)",
        "public void setSectionOutlineStroke(Comparable key, Stroke stroke)",
        "public Stroke getBaseSectionOutlineStroke()",
        "public void setBaseSectionOutlineStroke(Stroke stroke)",
        "public Paint getShadowPaint()",
        "public void setShadowPaint(Paint paint)",
        "public double getShadowXOffset()",
        "public void setShadowXOffset(double offset)",
        "public double getShadowYOffset()",
        "public void setShadowYOffset(double offset)",
        "public double getExplodePercent(Comparable key)",
        "public void setExplodePercent(Comparable key, double percent)",
        "public double getMaximumExplodePercent()",
        "public PieSectionLabelGenerator getLabelGenerator()",
        "public void setLabelGenerator(PieSectionLabelGenerator generator)",
        "public double getLabelGap()",
        "public void setLabelGap(double gap)",
        "public double getMaximumLabelWidth()",
        "public void setMaximumLabelWidth(double width)",
        "public boolean getLabelLinksVisible()",
        "public void setLabelLinksVisible(boolean visible)",
        "public double getLabelLinkMargin()",
        "public void setLabelLinkMargin(double margin)",
        "public Paint getLabelLinkPaint()",
        "public void setLabelLinkPaint(Paint paint)",
        "public Stroke getLabelLinkStroke()",
        "public void setLabelLinkStroke(Stroke stroke)",
        "public Font getLabelFont()",
        "public void setLabelFont(Font font)",
        "public Paint getLabelPaint()",
        "public void setLabelPaint(Paint paint)",
        "public Paint getLabelBackgroundPaint()",
        "public void setLabelBackgroundPaint(Paint paint)",
        "public Paint getLabelOutlinePaint()",
        "public void setLabelOutlinePaint(Paint paint)",
        "public Stroke getLabelOutlineStroke()",
        "public void setLabelOutlineStroke(Stroke stroke)",
        "public Paint getLabelShadowPaint()",
        "public void setLabelShadowPaint(Paint paint)",
        "public RectangleInsets getLabelPadding()",
        "public void setLabelPadding(RectangleInsets padding)",
        "public boolean getSimpleLabels()",
        "public void setSimpleLabels(boolean simple)",
        "public RectangleInsets getSimpleLabelOffset()",
        "public void setSimpleLabelOffset(RectangleInsets offset)",
        "public AbstractPieLabelDistributor getLabelDistributor()",
        "public void setLabelDistributor(AbstractPieLabelDistributor distributor)",
        "public PieToolTipGenerator getToolTipGenerator()",
        "public void setToolTipGenerator(PieToolTipGenerator generator)",
        "public PieURLGenerator getURLGenerator()",
        "public void setURLGenerator(PieURLGenerator generator)",
        "public double getMinimumArcAngleToDraw()",
        "public void setMinimumArcAngleToDraw(double angle)",
        "public Shape getLegendItemShape()",
        "public void setLegendItemShape(Shape shape)",
        "public PieSectionLabelGenerator getLegendLabelGenerator()",
        "public void setLegendLabelGenerator(PieSectionLabelGenerator generator)",
        "public PieSectionLabelGenerator getLegendLabelToolTipGenerator()",
        "public void setLegendLabelToolTipGenerator( PieSectionLabelGenerator generator)",
        "public PieURLGenerator getLegendLabelURLGenerator()",
        "public void setLegendLabelURLGenerator(PieURLGenerator generator)",
        "public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea, PiePlot plot, Integer index, PlotRenderingInfo info)",
        "public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo info)",
        "protected void drawPie(Graphics2D g2, Rectangle2D plotArea, PlotRenderingInfo info)",
        "protected void drawItem(Graphics2D g2, int section, Rectangle2D dataArea, PiePlotState state, int currentPass)",
        "protected void drawSimpleLabels(Graphics2D g2, List keys, double totalValue, Rectangle2D plotArea, Rectangle2D pieArea, PiePlotState state)",
        "protected void drawLabels(Graphics2D g2, List keys, double totalValue, Rectangle2D plotArea, Rectangle2D linkArea, PiePlotState state)",
        "protected void drawLeftLabels(KeyedValues leftKeys, Graphics2D g2, Rectangle2D plotArea, Rectangle2D linkArea, float maxLabelWidth, PiePlotState state)",
        "protected void drawRightLabels(KeyedValues keys, Graphics2D g2, Rectangle2D plotArea, Rectangle2D linkArea, float maxLabelWidth, PiePlotState state)",
        "public LegendItemCollection getLegendItems()",
        "public String getPlotType()",
        "protected Rectangle2D getArcBounds(Rectangle2D unexploded, Rectangle2D exploded, double angle, double extent, double explodePercent)",
        "protected void drawLeftLabel(Graphics2D g2, PiePlotState state, PieLabelRecord record)",
        "protected void drawRightLabel(Graphics2D g2, PiePlotState state, PieLabelRecord record)",
        "public boolean equals(Object obj)",
        "public Object clone() throws CloneNotSupportedException",
        "private void writeObject(ObjectOutputStream stream) throws IOException",
        "private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException"
      ],
      "fixed_signatures": [
        "public PiePlot(PieDataset dataset)",
        "public PieDataset getDataset()",
        "public void setDataset(PieDataset dataset)",
        "public int getPieIndex()",
        "public void setPieIndex(int index)",
        "public double getStartAngle()",
        "public void setStartAngle(double angle)",
        "public Rotation getDirection()",
        "public void setDirection(Rotation direction)",
        "public double getInteriorGap()",
        "public void setInteriorGap(double percent)",
        "public boolean isCircular()",
        "public void setCircular(boolean flag)",
        "public void setCircular(boolean circular, boolean notify)",
        "public boolean getIgnoreNullValues()",
        "public void setIgnoreNullValues(boolean flag)",
        "public boolean getIgnoreZeroValues()",
        "public void setIgnoreZeroValues(boolean flag)",
        "protected Paint lookupSectionPaint(Comparable key)",
        "protected Paint lookupSectionPaint(Comparable key, boolean autoPopulate)",
        "protected Comparable getSectionKey(int section)",
        "public Paint getSectionPaint(Comparable key)",
        "public void setSectionPaint(Comparable key, Paint paint)",
        "public Paint getBaseSectionPaint()",
        "public void setBaseSectionPaint(Paint paint)",
        "public boolean getSectionOutlinesVisible()",
        "public void setSectionOutlinesVisible(boolean visible)",
        "protected Paint lookupSectionOutlinePaint(Comparable key)",
        "protected Paint lookupSectionOutlinePaint(Comparable key, boolean autoPopulate)",
        "public Paint getSectionOutlinePaint(Comparable key)",
        "public void setSectionOutlinePaint(Comparable key, Paint paint)",
        "public Paint getBaseSectionOutlinePaint()",
        "public void setBaseSectionOutlinePaint(Paint paint)",
        "protected Stroke lookupSectionOutlineStroke(Comparable key)",
        "protected Stroke lookupSectionOutlineStroke(Comparable key, boolean autoPopulate)",
        "public Stroke getSectionOutlineStroke(Comparable key)",
        "public void setSectionOutlineStroke(Comparable key, Stroke stroke)",
        "public Stroke getBaseSectionOutlineStroke()",
        "public void setBaseSectionOutlineStroke(Stroke stroke)",
        "public Paint getShadowPaint()",
        "public void setShadowPaint(Paint paint)",
        "public double getShadowXOffset()",
        "public void setShadowXOffset(double offset)",
        "public double getShadowYOffset()",
        "public void setShadowYOffset(double offset)",
        "public double getExplodePercent(Comparable key)",
        "public void setExplodePercent(Comparable key, double percent)",
        "public double getMaximumExplodePercent()",
        "public PieSectionLabelGenerator getLabelGenerator()",
        "public void setLabelGenerator(PieSectionLabelGenerator generator)",
        "public double getLabelGap()",
        "public void setLabelGap(double gap)",
        "public double getMaximumLabelWidth()",
        "public void setMaximumLabelWidth(double width)",
        "public boolean getLabelLinksVisible()",
        "public void setLabelLinksVisible(boolean visible)",
        "public double getLabelLinkMargin()",
        "public void setLabelLinkMargin(double margin)",
        "public Paint getLabelLinkPaint()",
        "public void setLabelLinkPaint(Paint paint)",
        "public Stroke getLabelLinkStroke()",
        "public void setLabelLinkStroke(Stroke stroke)",
        "public Font getLabelFont()",
        "public void setLabelFont(Font font)",
        "public Paint getLabelPaint()",
        "public void setLabelPaint(Paint paint)",
        "public Paint getLabelBackgroundPaint()",
        "public void setLabelBackgroundPaint(Paint paint)",
        "public Paint getLabelOutlinePaint()",
        "public void setLabelOutlinePaint(Paint paint)",
        "public Stroke getLabelOutlineStroke()",
        "public void setLabelOutlineStroke(Stroke stroke)",
        "public Paint getLabelShadowPaint()",
        "public void setLabelShadowPaint(Paint paint)",
        "public RectangleInsets getLabelPadding()",
        "public void setLabelPadding(RectangleInsets padding)",
        "public boolean getSimpleLabels()",
        "public void setSimpleLabels(boolean simple)",
        "public RectangleInsets getSimpleLabelOffset()",
        "public void setSimpleLabelOffset(RectangleInsets offset)",
        "public AbstractPieLabelDistributor getLabelDistributor()",
        "public void setLabelDistributor(AbstractPieLabelDistributor distributor)",
        "public PieToolTipGenerator getToolTipGenerator()",
        "public void setToolTipGenerator(PieToolTipGenerator generator)",
        "public PieURLGenerator getURLGenerator()",
        "public void setURLGenerator(PieURLGenerator generator)",
        "public double getMinimumArcAngleToDraw()",
        "public void setMinimumArcAngleToDraw(double angle)",
        "public Shape getLegendItemShape()",
        "public void setLegendItemShape(Shape shape)",
        "public PieSectionLabelGenerator getLegendLabelGenerator()",
        "public void setLegendLabelGenerator(PieSectionLabelGenerator generator)",
        "public PieSectionLabelGenerator getLegendLabelToolTipGenerator()",
        "public void setLegendLabelToolTipGenerator( PieSectionLabelGenerator generator)",
        "public PieURLGenerator getLegendLabelURLGenerator()",
        "public void setLegendLabelURLGenerator(PieURLGenerator generator)",
        "public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea, PiePlot plot, Integer index, PlotRenderingInfo info)",
        "public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo info)",
        "protected void drawPie(Graphics2D g2, Rectangle2D plotArea, PlotRenderingInfo info)",
        "protected void drawItem(Graphics2D g2, int section, Rectangle2D dataArea, PiePlotState state, int currentPass)",
        "protected void drawSimpleLabels(Graphics2D g2, List keys, double totalValue, Rectangle2D plotArea, Rectangle2D pieArea, PiePlotState state)",
        "protected void drawLabels(Graphics2D g2, List keys, double totalValue, Rectangle2D plotArea, Rectangle2D linkArea, PiePlotState state)",
        "protected void drawLeftLabels(KeyedValues leftKeys, Graphics2D g2, Rectangle2D plotArea, Rectangle2D linkArea, float maxLabelWidth, PiePlotState state)",
        "protected void drawRightLabels(KeyedValues keys, Graphics2D g2, Rectangle2D plotArea, Rectangle2D linkArea, float maxLabelWidth, PiePlotState state)",
        "public LegendItemCollection getLegendItems()",
        "public String getPlotType()",
        "protected Rectangle2D getArcBounds(Rectangle2D unexploded, Rectangle2D exploded, double angle, double extent, double explodePercent)",
        "protected void drawLeftLabel(Graphics2D g2, PiePlotState state, PieLabelRecord record)",
        "protected void drawRightLabel(Graphics2D g2, PiePlotState state, PieLabelRecord record)",
        "public boolean equals(Object obj)",
        "public Object clone() throws CloneNotSupportedException",
        "private void writeObject(ObjectOutputStream stream) throws IOException",
        "private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException"
      ],
      "methods": [
        {
          "buggy_method": "  public double getMaximumExplodePercent() {\n  double result = 0.0;\n  Iterator iterator = this.dataset.getKeys().iterator();\n  while (iterator.hasNext()) {\n  Comparable key = (Comparable) iterator.next();\n  Number explode = (Number) this.explodePercentages.get(key);\n  if (explode != null) {\n  result = Math.max(result, explode.doubleValue());  \n  }\n  }\n  return result;\n  }",
          "fixed_method": "  public double getMaximumExplodePercent() {\n  if (this.dataset == null) {\n  return 0.0;\n  }\n  double result = 0.0;\n  Iterator iterator = this.dataset.getKeys().iterator();\n  while (iterator.hasNext()) {\n  Comparable key = (Comparable) iterator.next();\n  Number explode = (Number) this.explodePercentages.get(key);\n  if (explode != null) {\n  result = Math.max(result, explode.doubleValue());  \n  }\n  }\n  return result;\n  }",
          "diff": [
            "@@ -1375,6 +1375,9 @@",
            "      * @return The percent.\n",
            "      */\n",
            "     public double getMaximumExplodePercent() {\n",
            "+        if (this.dataset == null) {\n",
            "+            return 0.0;\n",
            "+        }\n",
            "         double result = 0.0;\n",
            "         Iterator iterator = this.dataset.getKeys().iterator();\n",
            "         while (iterator.hasNext()) {\n"
          ],
          "changed_lines": 3
        },
        {
          "buggy_method": "  public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea, PiePlot plot, Integer index, PlotRenderingInfo info) {\n  \n  PiePlotState state = new PiePlotState(info);\n  state.setPassesRequired(2);\n  state.setTotal(DatasetUtilities.calculatePieDatasetTotal(\n  plot.getDataset()));\n  state.setLatestAngle(plot.getStartAngle());\n  return state;\n  \n  }",
          "fixed_method": "  public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea, PiePlot plot, Integer index, PlotRenderingInfo info) {\n  \n  PiePlotState state = new PiePlotState(info);\n  state.setPassesRequired(2);\n  if (this.dataset != null) {\n  state.setTotal(DatasetUtilities.calculatePieDatasetTotal(\n  plot.getDataset()));\n  }\n  state.setLatestAngle(plot.getStartAngle());\n  return state;\n  \n  }",
          "diff": [
            "@@ -2048,8 +2051,10 @@",
            "      \n",
            "         PiePlotState state = new PiePlotState(info);\n",
            "         state.setPassesRequired(2);\n",
            "+        if (this.dataset != null) {\n",
            "             state.setTotal(DatasetUtilities.calculatePieDatasetTotal(\n",
            "                     plot.getDataset()));\n",
            "+        }\n",
            "         state.setLatestAngle(plot.getStartAngle());\n",
            "         return state;\n",
            "         \n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
