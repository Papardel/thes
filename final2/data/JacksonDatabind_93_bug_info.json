{
  "bug_id": "93",
  "failed_tests": {
    "com.fasterxml.jackson.databind.interop.IllegalTypesCheckTest": [
      {
        "methodName": "testJDKTypes1872",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "        Authentication1872 result = mapper.readValue(json, Authentication1872.class);",
        "test_source": "  public void testJDKTypes1872() throws Exception {\n  ObjectMapper mapper = new ObjectMapper();\n  mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\n  \n  String json = aposToQuotes(String.format(\"{'@class':'%s','authorities':['java.util.ArrayList',[]]}\",\n  Authentication1872.class.getName()));\n  Authentication1872 result = mapper.readValue(json, Authentication1872.class);\n  assertNotNull(result);\n  }",
        "stack": [
          "SubTypeValidator.validateSubType line 85, BeanDeserializerFactory._validateSubType line 866, BeanDeserializerFactory.createBeanDeserializer line 142, DeserializerCache._createDeserializer2 line 403, DeserializerCache._createDeserializer line 349, DeserializerCache._createAndCache2 line 264, DeserializerCache._createAndCacheValueDeserializer line 244, DeserializerCache.findValueDeserializer line 142, DeserializationContext.findContextualValueDeserializer line 443, CollectionDeserializer.createContextual line 206, CollectionDeserializer.createContextual line 26, DeserializationContext.handlePrimaryContextualization line 650, BeanDeserializerBase.resolve line 490, DeserializerCache._createAndCache2 line 293, DeserializerCache._createAndCacheValueDeserializer line 244, DeserializerCache.findValueDeserializer line 142, DeserializationContext.findRootValueDeserializer line 476, ObjectMapper._findRootDeserializer line 3915, ObjectMapper._readMapAndClose line 3810, ObjectMapper.readValue line 2858, IllegalTypesCheckTest.testJDKTypes1872 line 112"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\n\n\npublic class SubTypeValidator { protected final static String PREFIX_STRING = \"org.springframework.\"; protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES; static { Set<String> s = new HashSet<String>(); s.add(\"org.apache.commons.collections.functors.InvokerTransformer\"); s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\"); s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\"); s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\"); s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\"); s.add(\"org.codehaus.groovy.runtime.MethodClosure\"); s.add(\"org.springframework.beans.factory.ObjectFactory\"); s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\"); s.add(\"org.apache.xalan.xsltc.trax.TemplatesImpl\"); s.add(\"com.sun.rowset.JdbcRowSetImpl\"); s.add(\"java.util.logging.FileHandler\"); s.add(\"java.rmi.server.UnicastRemoteObject\"); s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\"); s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\"); s.add(\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\"); s.add(\"com.sun.org.apache.bcel.internal.util.ClassLoader\"); DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s); } protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES; private final static SubTypeValidator instance = new SubTypeValidator(); protected SubTypeValidator() { }\n\n    public static SubTypeValidator instance() { return instance; }\n\n    public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        \n        \n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            \n            \n            \n            if (full.startsWith(PREFIX_STRING)) {\n                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n                    String name = cls.getSimpleName();\n                    \n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            \n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            }\n            return;\n        } while (false);\n\n        throw JsonMappingException.from(ctxt,\n                String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\n\n\npublic class SubTypeValidator { protected final static String PREFIX_STRING = \"org.springframework.\"; protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES; static { Set<String> s = new HashSet<String>(); s.add(\"org.apache.commons.collections.functors.InvokerTransformer\"); s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\"); s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\"); s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\"); s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\"); s.add(\"org.codehaus.groovy.runtime.MethodClosure\"); s.add(\"org.springframework.beans.factory.ObjectFactory\"); s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\"); s.add(\"org.apache.xalan.xsltc.trax.TemplatesImpl\"); s.add(\"com.sun.rowset.JdbcRowSetImpl\"); s.add(\"java.util.logging.FileHandler\"); s.add(\"java.rmi.server.UnicastRemoteObject\"); s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\"); s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\"); s.add(\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\"); s.add(\"com.sun.org.apache.bcel.internal.util.ClassLoader\"); DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s); } protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES; private final static SubTypeValidator instance = new SubTypeValidator(); protected SubTypeValidator() { }\n\n    public static SubTypeValidator instance() { return instance; }\n\n    public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        \n        \n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            \n            \n            \n            if (!raw.isInterface() && full.startsWith(PREFIX_STRING)) {\n                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()) {\n                    String name = cls.getSimpleName();\n                    \n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            \n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            }\n            return;\n        } while (false);\n\n        throw JsonMappingException.from(ctxt,\n                String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n    }\n}\n",
      "buggy_signatures": [
        "public static SubTypeValidator instance()",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException"
      ],
      "fixed_signatures": [
        "public static SubTypeValidator instance()",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException"
      ],
      "methods": [
        {
          "buggy_method": "  public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n  \n  \n  final Class<?> raw = type.getRawClass();\n  String full = raw.getName();\n\n  main_check:\n  do {\n  if (_cfgIllegalClassNames.contains(full)) {\n  break;\n  }\n\n  \n  \n  \n  if (full.startsWith(PREFIX_STRING)) {\n  for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n  String name = cls.getSimpleName();\n  \n  if (\"AbstractPointcutAdvisor\".equals(name)\n  \n  || \"AbstractApplicationContext\".equals(name)) {\n  break main_check;\n  }\n  }\n  }\n  return;\n  } while (false);\n\n  throw JsonMappingException.from(ctxt,\n  String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n  }",
          "fixed_method": "  public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n  \n  \n  final Class<?> raw = type.getRawClass();\n  String full = raw.getName();\n\n  main_check:\n  do {\n  if (_cfgIllegalClassNames.contains(full)) {\n  break;\n  }\n\n  \n  \n  \n  if (!raw.isInterface() && full.startsWith(PREFIX_STRING)) {\n  for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()) {\n  String name = cls.getSimpleName();\n  \n  if (\"AbstractPointcutAdvisor\".equals(name)\n  \n  || \"AbstractApplicationContext\".equals(name)) {\n  break main_check;\n  }\n  }\n  }\n  return;\n  } while (false);\n\n  throw JsonMappingException.from(ctxt,\n  String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n  }",
          "diff": [
            "@@ -80,8 +80,8 @@",
            "             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n",
            "             //    for some Spring framework types\n",
            "             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n",
            "-            if (full.startsWith(PREFIX_STRING)) {\n",
            "-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n",
            "+            if (!raw.isInterface() && full.startsWith(PREFIX_STRING)) {\n",
            "+                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()) {\n",
            "                     String name = cls.getSimpleName();\n",
            "                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n",
            "                     if (\"AbstractPointcutAdvisor\".equals(name)\n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
