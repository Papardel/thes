{
  "bug_id": "96",
  "failed_tests": {
    "com.fasterxml.jackson.databind.deser.creators.CreatorWithNamingStrategyTest": [
      {
        "methodName": "testSnakeCaseWithOneArg",
        "error": "com.fasterxml.jackson.databind.exc.InvalidDefinitionException",
        "message": "Invalid definition for property `param_name0` (of type `com.fasterxml.jackson.databind.deser.creators.CreatorWithNamingStrategyTest$OneProperty`): Could not find creator property with name 'param_name0' (known Creator properties: [paramName0])",
        "fail_line": "        OneProperty actual = MAPPER.readValue(",
        "test_source": "  public void testSnakeCaseWithOneArg() throws Exception {\n  final String MSG = \"1st\";\n  OneProperty actual = MAPPER.readValue(\n  \"{\\\"param_name0\\\":\\\"\"+MSG+\"\\\"}\",\n  OneProperty.class);\n  assertEquals(\"CTOR:\"+MSG, actual.paramName0);\n  }",
        "stack": [
          "InvalidDefinitionException.from line 62, DeserializationContext.reportBadPropertyDefinition line 1446, BeanDeserializerFactory.addBeanProps line 567, BeanDeserializerFactory.buildBeanDeserializer line 227, BeanDeserializerFactory.createBeanDeserializer line 137, DeserializerCache._createDeserializer2 line 411, DeserializerCache._createDeserializer line 349, DeserializerCache._createAndCache2 line 264, DeserializerCache._createAndCacheValueDeserializer line 244, DeserializerCache.findValueDeserializer line 142, DeserializationContext.findRootValueDeserializer line 477, ObjectMapper._findRootDeserializer line 4190, ObjectMapper._readMapAndClose line 4009, ObjectMapper.readValue line 3004, CreatorWithNamingStrategyTest.testSnakeCaseWithOneArg line 49"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.deser;\n\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.JacksonInject;\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonCreator.Mode;\nimport com.fasterxml.jackson.core.JsonLocation;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.deser.impl.CreatorCandidate;\nimport com.fasterxml.jackson.databind.deser.impl.CreatorCollector;\nimport com.fasterxml.jackson.databind.deser.impl.JavaUtilCollectionsDeserializers;\nimport com.fasterxml.jackson.databind.deser.std.*;\nimport com.fasterxml.jackson.databind.exc.InvalidDefinitionException;\nimport com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.*;\n\n\n@SuppressWarnings(\"serial\")\npublic abstract class BasicDeserializerFactory extends DeserializerFactory implements java.io.Serializable { private final static Class<?> CLASS_OBJECT = Object.class; private final static Class<?> CLASS_STRING = String.class; private final static Class<?> CLASS_CHAR_SEQUENCE = CharSequence.class; private final static Class<?> CLASS_ITERABLE = Iterable.class; private final static Class<?> CLASS_MAP_ENTRY = Map.Entry.class; protected final static PropertyName UNWRAPPED_CREATOR_PARAM_NAME = new PropertyName(\"@JsonUnwrapped\"); @SuppressWarnings(\"rawtypes\") final static HashMap<String, Class<? extends Map>> _mapFallbacks = new HashMap<String, Class<? extends Map>>(); static {\n        _mapFallbacks.put(Map.class.getName(), LinkedHashMap.class);\n        _mapFallbacks.put(ConcurrentMap.class.getName(), ConcurrentHashMap.class);\n        _mapFallbacks.put(SortedMap.class.getName(), TreeMap.class);\n\n        _mapFallbacks.put(java.util.NavigableMap.class.getName(), TreeMap.class);\n        _mapFallbacks.put(java.util.concurrent.ConcurrentNavigableMap.class.getName(),\n                java.util.concurrent.ConcurrentSkipListMap.class);\n    }\n\n    \n    @SuppressWarnings(\"rawtypes\")\n    final static HashMap<String, Class<? extends Collection>> _collectionFallbacks = new HashMap<String, Class<? extends Collection>>(); static {\n        _collectionFallbacks.put(Collection.class.getName(), ArrayList.class);\n        _collectionFallbacks.put(List.class.getName(), ArrayList.class);\n        _collectionFallbacks.put(Set.class.getName(), HashSet.class);\n        _collectionFallbacks.put(SortedSet.class.getName(), TreeSet.class);\n        _collectionFallbacks.put(Queue.class.getName(), LinkedList.class);\n\n        \n        \n        _collectionFallbacks.put(\"java.util.Deque\", LinkedList.class);\n        _collectionFallbacks.put(\"java.util.NavigableSet\", TreeSet.class);\n    }\n\n    \n    \n    \n    protected final DeserializerFactoryConfig _factoryConfig; protected BasicDeserializerFactory(DeserializerFactoryConfig config) {\n        _factoryConfig = config;\n    }\n    \n    \n    public DeserializerFactoryConfig getFactoryConfig() {\n        return _factoryConfig;\n    }\n\n    protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); @Override public final DeserializerFactory withAdditionalDeserializers(Deserializers additional) {\n        return withConfig(_factoryConfig.withAdditionalDeserializers(additional));\n    }\n\n    \n    @Override\n    public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional) {\n        return withConfig(_factoryConfig.withAdditionalKeyDeserializers(additional));\n    }\n    \n    \n    @Override\n    public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier) {\n        return withConfig(_factoryConfig.withDeserializerModifier(modifier));\n    }\n\n    \n    @Override\n    public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver) {\n        return withConfig(_factoryConfig.withAbstractTypeResolver(resolver));\n    }\n\n    \n    @Override\n    public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators) {\n        return withConfig(_factoryConfig.withValueInstantiators(instantiators));\n    }\n\n    \n\n    @Override\n    public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException {\n        \n        while (true) {\n            JavaType next = _mapAbstractType2(config, type);\n            if (next == null) {\n                return type;\n            }\n            \n            \n            Class<?> prevCls = type.getRawClass();\n            Class<?> nextCls = next.getRawClass();\n            if ((prevCls == nextCls) || !prevCls.isAssignableFrom(nextCls)) {\n                throw new IllegalArgumentException(\"Invalid abstract type resolution from \"+type+\" to \"+next+\": latter is not a subtype of former\"); } type = next; } } private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) throws JsonMappingException {\n        Class<?> currClass = type.getRawClass();\n        if (_factoryConfig.hasAbstractTypeResolvers()) {\n            for (AbstractTypeResolver resolver : _factoryConfig.abstractTypeResolvers()) {\n                JavaType concrete = resolver.findTypeMapping(config, type);\n                if ((concrete != null) && !concrete.hasRawClass(currClass)) {\n                    return concrete;\n                }\n            }\n        }\n        return null;\n    }\n\n    \n\n    \n    @Override\n    public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n\n        ValueInstantiator instantiator = null;\n        \n        AnnotatedClass ac = beanDesc.getClassInfo();\n        Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac);\n        if (instDef != null) {\n            instantiator = _valueInstantiatorInstance(config, ac, instDef);\n        }\n        if (instantiator == null) {\n            \n            \n            instantiator = _findStdValueInstantiator(config, beanDesc);\n            if (instantiator == null) {\n                instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc);\n            }\n        }\n\n        \n        if (_factoryConfig.hasValueInstantiators()) {\n            for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) {\n                instantiator = insts.findValueInstantiator(config, beanDesc, instantiator);\n                \n                if (instantiator == null) {\n                    ctxt.reportBadTypeDefinition(beanDesc,\n\t\t\t\t\t\t\"Broken registered ValueInstantiators (of type %s): returned null ValueInstantiator\",\n\t\t\t\t\t\tinsts.getClass().getName());\n                }\n            }\n        }\n\n        \n        if (instantiator.getIncompleteParameter() != null) {\n            final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter();\n            final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner();\n            throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()\n                +\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n        }\n\n        return instantiator;\n    }\n\n    private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        Class<?> raw = beanDesc.getBeanClass();\n        if (raw == JsonLocation.class) {\n            return new JsonLocationInstantiator();\n        }\n        \n        if (Collection.class.isAssignableFrom(raw)) {\n            if (Collections.EMPTY_SET.getClass() == raw) {\n                return new ConstantValueInstantiator(Collections.EMPTY_SET);\n            }\n            if (Collections.EMPTY_LIST.getClass() == raw) {\n                return new ConstantValueInstantiator(Collections.EMPTY_LIST);\n            }\n        } else if (Map.class.isAssignableFrom(raw)) {\n            if (Collections.EMPTY_MAP.getClass() == raw) {\n                return new ConstantValueInstantiator(Collections.EMPTY_MAP);\n            }\n        }\n        return null;\n    }\n\n    \n    protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException {\n        CreatorCollector creators = new CreatorCollector(beanDesc, ctxt.getConfig());\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        \n        \n        final DeserializationConfig config = ctxt.getConfig();\n        VisibilityChecker<?> vchecker = config.getDefaultVisibilityChecker(beanDesc.getBeanClass(),\n                beanDesc.getClassInfo());\n\n        \n        \n        Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorDefs = _findCreatorsFromProperties(ctxt,\n                beanDesc);\n        \n        \n        _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n        \n        if (beanDesc.getType().isConcrete()) {\n            _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n        }\n        return creators.constructValueInstantiator(ctxt);\n    }\n\n    protected Map<AnnotatedWithParams,BeanPropertyDefinition[]> _findCreatorsFromProperties(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException {\n        Map<AnnotatedWithParams,BeanPropertyDefinition[]> result = Collections.emptyMap();\n        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {\n            Iterator<AnnotatedParameter> it = propDef.getConstructorParameters();\n            while (it.hasNext()) {\n                AnnotatedParameter param = it.next();\n                AnnotatedWithParams owner = param.getOwner();\n                BeanPropertyDefinition[] defs = result.get(owner);\n                final int index = param.getIndex();\n                \n                if (defs == null) {\n                    if (result.isEmpty()) { \n                        result = new LinkedHashMap<AnnotatedWithParams,BeanPropertyDefinition[]>();\n                    }\n                    defs = new BeanPropertyDefinition[owner.getParameterCount()];\n                    result.put(owner, defs);\n                } else {\n                    if (defs[index] != null) {\n                        ctxt.reportBadTypeDefinition(beanDesc,\n\"Conflict: parameter #%d of %s bound to more than one property; %s vs %s\",\nindex, owner, defs[index], propDef);\n                    }\n                }\n                defs[index] = propDef;\n            }\n        }\n        return result;\n    }\n    \n    public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException {\n        if (instDef == null) {\n            return null;\n        }\n\n        ValueInstantiator inst;\n        \n        if (instDef instanceof ValueInstantiator) {\n            return (ValueInstantiator) instDef;\n        }\n        if (!(instDef instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned key deserializer definition of type \"\n                    +instDef.getClass().getName()\n                    +\"; expected type KeyDeserializer or Class<KeyDeserializer> instead\");\n        }\n        Class<?> instClass = (Class<?>)instDef;\n        if (ClassUtil.isBogusClass(instClass)) {\n            return null;\n        }\n        if (!ValueInstantiator.class.isAssignableFrom(instClass)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+instClass.getName()\n                    +\"; expected Class<ValueInstantiator>\");\n        }\n        HandlerInstantiator hi = config.getHandlerInstantiator();\n        if (hi != null) {\n            inst = hi.valueInstantiatorInstance(config, annotated, instClass);\n            if (inst != null) {\n                return inst;\n            }\n        }\n        return (ValueInstantiator) ClassUtil.createInstance(instClass,\n                config.canOverrideAccessModifiers());\n    }\n\n    \n\n    protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException {\n        \n        \n        \n        final boolean isNonStaticInnerClass = beanDesc.isNonStaticInnerClass();\n        if (isNonStaticInnerClass) {\n            \n            return;\n        }\n\n        \n        \n        \n        AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor();\n        if (defaultCtor != null) {\n            if (!creators.hasDefaultCreator() || _hasCreatorAnnotation(ctxt, defaultCtor)) {\n                creators.setDefaultCreator(defaultCtor);\n            }\n        }\n        \n        List<CreatorCandidate> nonAnnotated = new LinkedList<>();\n        int explCount = 0;\n        for (AnnotatedConstructor ctor : beanDesc.getConstructors()) {\n            JsonCreator.Mode creatorMode = intr.findCreatorAnnotation(ctxt.getConfig(), ctor);\n            if (Mode.DISABLED == creatorMode) {\n                continue;\n            }\n            if (creatorMode == null) {\n                \n                if (vchecker.isCreatorVisible(ctor)) {\n                    nonAnnotated.add(CreatorCandidate.construct(intr, ctor, creatorParams.get(ctor)));\n                }\n                continue;\n            }\n            switch (creatorMode) {\n            case DELEGATING:\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators,\n                        CreatorCandidate.construct(intr, ctor, null));\n                break;\n            case PROPERTIES:\n                _addExplicitPropertyCreator(ctxt, beanDesc, creators,\n                        CreatorCandidate.construct(intr, ctor, creatorParams.get(ctor)));\n                break;\n            default:\n                _addExplicitAnyCreator(ctxt, beanDesc, creators,\n                        CreatorCandidate.construct(intr, ctor, creatorParams.get(ctor)));\n                break;\n            }\n            ++explCount;\n        }\n        \n        if (explCount > 0) { \n            return;\n        }\n        List<AnnotatedWithParams> implicitCtors = null;\n        for (CreatorCandidate candidate : nonAnnotated) {\n            final int argCount = candidate.paramCount();\n            final AnnotatedWithParams ctor = candidate.creator();\n\n            \n            if (argCount == 1) {\n                BeanPropertyDefinition propDef = candidate.propertyDef(0);\n                boolean useProps = _checkIfCreatorPropertyBased(intr, ctor, propDef);\n\n                if (useProps) {\n                    SettableBeanProperty[] properties = new SettableBeanProperty[1];\n                    PropertyName name = candidate.paramName(0);\n                    properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0,\n                            candidate.parameter(0), candidate.injection(0));\n                    creators.addPropertyCreator(ctor, false, properties);\n                } else {\n                     _handleSingleArgumentCreator(creators,\n                            ctor, false,\n                            vchecker.isCreatorVisible(ctor));\n                    \n                    \n                    if (propDef != null) {\n                        ((POJOPropertyBuilder) propDef).removeConstructors();\n                    }\n                }\n                \n                continue;\n            }\n\n            \n            \n            \n\n            int nonAnnotatedParamIndex = -1;\n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            int explicitNameCount = 0;\n            int implicitWithCreatorCount = 0;\n            int injectCount = 0;\n\n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = ctor.getParameter(i);\n                BeanPropertyDefinition propDef = candidate.propertyDef(i);\n                JacksonInject.Value injectId = intr.findInjectableValue(param);\n                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n\n                if (propDef != null && propDef.isExplicitlyNamed()) {\n                    ++explicitNameCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                if (injectId != null) {\n                    ++injectCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    _reportUnwrappedCreatorProperty(ctxt, beanDesc, param);\n                    \n                    continue;\n                }\n                \n                \n                if (nonAnnotatedParamIndex < 0) {\n                    nonAnnotatedParamIndex = i;\n                }\n            }\n\n            final int namedCount = explicitNameCount + implicitWithCreatorCount;\n            \n            if ((explicitNameCount > 0) || (injectCount > 0)) {\n                \n                if ((namedCount + injectCount) == argCount) {\n                    creators.addPropertyCreator(ctor, false, properties);\n                    continue;\n                }\n                if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                    \n                    creators.addDelegatingCreator(ctor, false, properties, 0);\n                    continue;\n                }\n                \n                \n                \n                PropertyName impl = candidate.findImplicitParamName(nonAnnotatedParamIndex);\n                if (impl == null || impl.isEmpty()) {\n                    \n                    \n                    \n                    ctxt.reportBadTypeDefinition(beanDesc,\n\"Argument #%d of constructor %s has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\",\nnonAnnotatedParamIndex, ctor);\n                }\n            }\n            \n            if (!creators.hasDefaultCreator()) {\n                if (implicitCtors == null) {\n                    implicitCtors = new LinkedList<>();\n                }\n                implicitCtors.add(ctor);\n            }\n        }\n        \n        \n        if ((implicitCtors != null) && !creators.hasDelegatingCreator()\n                && !creators.hasPropertyBasedCreator()) {\n            _checkImplicitlyNamedConstructors(ctxt, beanDesc, vchecker, intr,\n                    creators, implicitCtors);\n        }\n    }\n\n    \n    protected void _addExplicitDelegatingCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException {\n        \n        \n\n        int ix = -1;\n        final int argCount = candidate.paramCount();\n        SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n        for (int i = 0; i < argCount; ++i) {\n            AnnotatedParameter param = candidate.parameter(i);\n            JacksonInject.Value injectId = candidate.injection(i);\n            if (injectId != null) {\n                properties[i] = constructCreatorProperty(ctxt, beanDesc, null, i, param, injectId);\n                continue;\n            }\n            if (ix < 0) {\n                ix = i;\n                continue;\n            }\n            \n            ctxt.reportBadTypeDefinition(beanDesc,\n                    \"More than one argument (#%d and #%d) left as delegating for Creator %s: only one allowed\",\n                    ix, i, candidate);\n        }\n        \n        if (ix < 0) {\n            ctxt.reportBadTypeDefinition(beanDesc,\n                    \"No argument left as delegating for Creator %s: exactly one required\", candidate);\n        }\n        \n        \n        if (argCount == 1) {\n            _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n            \n            \n            BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n            if (paramDef != null) {\n                ((POJOPropertyBuilder) paramDef).removeConstructors();\n            }\n            return;\n        }\n        creators.addDelegatingCreator(candidate.creator(), true, properties, ix);\n    }\n\n    \n    protected void _addExplicitPropertyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException {\n        final int paramCount = candidate.paramCount();\n        SettableBeanProperty[] properties = new SettableBeanProperty[paramCount];\n\n        for (int i = 0; i < paramCount; ++i) {\n            JacksonInject.Value injectId = candidate.injection(i);\n            AnnotatedParameter param = candidate.parameter(i);\n            PropertyName name = candidate.paramName(i);\n            if (name == null) {\n                \n                \n                NameTransformer unwrapper = ctxt.getAnnotationIntrospector().findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    _reportUnwrappedCreatorProperty(ctxt, beanDesc, param);\n                    \n                }\n                name = candidate.findImplicitParamName(i);\n                \n                if ((name == null) && (injectId == null)) {\n                    ctxt.reportBadTypeDefinition(beanDesc,\n\"Argument #%d has no property name, is not Injectable: can not use as Creator %s\", i, candidate);\n                }\n            }\n            properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n        }\n        creators.addPropertyCreator(candidate.creator(), true, properties);\n    }\n\n    \n    protected void _addExplicitAnyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException {\n        \n        if (1 != candidate.paramCount()) {\n            \n            \n            int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n            if (oneNotInjected >= 0) {\n                \n                if (candidate.paramName(oneNotInjected) == null) {\n                    _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                    return;\n                }\n            }\n            _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n            return;\n        }\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n\n        \n        boolean useProps = (paramName != null) || (injectId != null);\n        if (!useProps && (paramDef != null)) {\n            \n            \n\n            \n            \n\n            paramName = candidate.findImplicitParamName(0);\n            useProps = (paramName != null) && paramDef.couldSerialize();\n        }\n        if (useProps) {\n            SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                    constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n            };\n            creators.addPropertyCreator(candidate.creator(), true, properties);\n            return;\n        }\n        _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n\n        \n        \n        if (paramDef != null) {\n            ((POJOPropertyBuilder) paramDef).removeConstructors();\n        }\n    }\n\n    private boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr, AnnotatedWithParams creator, BeanPropertyDefinition propDef) {\n        \n        if (((propDef != null) && propDef.isExplicitlyNamed())\n                || (intr.findInjectableValue(creator.getParameter(0)) != null)) {\n            return true;\n        }\n        if (propDef != null) {\n            \n            \n            String implName = propDef.getName();\n            if (implName != null && !implName.isEmpty()) {\n                if (propDef.couldSerialize()) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n\n    private void _checkImplicitlyNamedConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, List<AnnotatedWithParams> implicitCtors) throws JsonMappingException {\n        AnnotatedWithParams found = null;\n        SettableBeanProperty[] foundProps = null;\n\n        \n        \n        \n\n        main_loop:\n        for (AnnotatedWithParams ctor : implicitCtors) {\n            if (!vchecker.isCreatorVisible(ctor)) {\n                continue;\n            }\n            \n            final int argCount = ctor.getParameterCount();\n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = ctor.getParameter(i);\n                final PropertyName name = _findParamName(param, intr);\n\n                \n                if (name == null || name.isEmpty()) {\n                    continue main_loop;\n                }\n                properties[i] = constructCreatorProperty(ctxt, beanDesc, name, param.getIndex(),\n                        param,  null);\n            }\n            if (found != null) { \n                found = null;\n                break;\n            }\n            found = ctor;\n            foundProps = properties;\n        }\n        \n        if (found != null) {\n            creators.addPropertyCreator(found,  false, foundProps);\n            BasicBeanDescription bbd = (BasicBeanDescription) beanDesc;\n            \n            for (SettableBeanProperty prop : foundProps) {\n                PropertyName pn = prop.getFullName();\n                if (!bbd.hasProperty(pn)) {\n                    BeanPropertyDefinition newDef = SimpleBeanPropertyDefinition.construct(\n                            ctxt.getConfig(), prop.getMember(), pn);\n                    bbd.addProperty(newDef);\n                }\n            }\n        }\n    }\n\n    protected void _addDeserializerFactoryMethods (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException {\n        List<CreatorCandidate> nonAnnotated = new LinkedList<>();\n        int explCount = 0;\n\n        \n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            JsonCreator.Mode creatorMode = intr.findCreatorAnnotation(ctxt.getConfig(), factory);\n            final int argCount = factory.getParameterCount();\n            if (creatorMode == null) {\n                \n                if ((argCount == 1) && vchecker.isCreatorVisible(factory)) {\n                    nonAnnotated.add(CreatorCandidate.construct(intr, factory, null));\n                }\n                continue;\n            }\n            if (creatorMode == Mode.DISABLED) {\n                continue;\n            }\n            \n            \n            if (argCount == 0) {\n                creators.setDefaultCreator(factory);\n                continue;\n            }\n\n            switch (creatorMode) {\n            case DELEGATING:\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators,\n                        CreatorCandidate.construct(intr, factory, null));\n                break;\n            case PROPERTIES:\n                _addExplicitPropertyCreator(ctxt, beanDesc, creators,\n                        CreatorCandidate.construct(intr, factory, creatorParams.get(factory)));\n                break;\n            case DEFAULT:\n            default:\n                _addExplicitAnyCreator(ctxt, beanDesc, creators,\n                        CreatorCandidate.construct(intr, factory, creatorParams.get(factory)));\n                break;\n            }\n            ++explCount;\n        }\n        \n        if (explCount > 0) { \n            return;\n        }\n        \n        for (CreatorCandidate candidate : nonAnnotated) {\n            final int argCount = candidate.paramCount();\n            AnnotatedWithParams factory = candidate.creator();\n            final BeanPropertyDefinition[] propDefs = creatorParams.get(factory);\n            \n            if (argCount != 1) {\n                continue; \n            }\n            BeanPropertyDefinition argDef = candidate.propertyDef(0);\n            boolean useProps = _checkIfCreatorPropertyBased(intr, factory, argDef);\n            if (!useProps) { \n                 _handleSingleArgumentCreator(creators,\n                        factory, false, vchecker.isCreatorVisible(factory));\n                \n                \n                if (argDef != null) {\n                    ((POJOPropertyBuilder) argDef).removeConstructors();\n                }\n                continue;\n            }\n            AnnotatedParameter nonAnnotatedParam = null;            \n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            int implicitNameCount = 0;\n            int explicitNameCount = 0;\n            int injectCount = 0;\n            \n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = factory.getParameter(i);\n                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i];\n                JacksonInject.Value injectable = intr.findInjectableValue(param);\n                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n\n                if (propDef != null && propDef.isExplicitlyNamed()) {\n                    ++explicitNameCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectable);\n                    continue;\n                }\n                if (injectable != null) {\n                    ++injectCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectable);\n                    continue;\n                }\n                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    _reportUnwrappedCreatorProperty(ctxt, beanDesc, param);\n                    \n                    continue;\n                }\n                \n                \n                \n                \n                if (nonAnnotatedParam == null) {\n                    nonAnnotatedParam = param;\n                }\n            }\n            final int namedCount = explicitNameCount + implicitNameCount;\n            \n            \n            if (explicitNameCount > 0 || injectCount > 0) {\n                \n                if ((namedCount + injectCount) == argCount) {\n                    creators.addPropertyCreator(factory, false, properties);\n                } else if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                    \n                    creators.addDelegatingCreator(factory, false, properties, 0);\n                } else { \n                    ctxt.reportBadTypeDefinition(beanDesc,\n\"Argument #%d of factory method %s has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\",\n                    nonAnnotatedParam.getIndex(), factory);\n                }\n            }\n        }\n    }\n\n    protected boolean _handleSingleArgumentCreator(CreatorCollector creators, AnnotatedWithParams ctor, boolean isCreator, boolean isVisible) {\n        \n        Class<?> type = ctor.getRawParameterType(0);\n        if (type == String.class || type == CLASS_CHAR_SEQUENCE) {\n            if (isCreator || isVisible) {\n                creators.addStringCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == int.class || type == Integer.class) {\n            if (isCreator || isVisible) {\n                creators.addIntCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == long.class || type == Long.class) {\n            if (isCreator || isVisible) {\n                creators.addLongCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == double.class || type == Double.class) {\n            if (isCreator || isVisible) {\n                creators.addDoubleCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == boolean.class || type == Boolean.class) {\n            if (isCreator || isVisible) {\n                creators.addBooleanCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        \n        if (isCreator) {\n            creators.addDelegatingCreator(ctor, isCreator, null, 0);\n            return true;\n        }\n        return false;\n    }\n\n    \n    \n    protected void _reportUnwrappedCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedParameter param) throws JsonMappingException {\n        ctxt.reportBadDefinition(beanDesc.getType(), String.format(\n                \"Cannot define Creator parameter %d as `@JsonUnwrapped`: combination not yet supported\",\n                param.getIndex()));\n    }\n\n    \n    protected SettableBeanProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, PropertyName name, int index, AnnotatedParameter param, JacksonInject.Value injectable) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        PropertyMetadata metadata;\n        {\n            if (intr == null) {\n                metadata = PropertyMetadata.STD_REQUIRED_OR_OPTIONAL;\n            } else {\n                Boolean b = intr.hasRequiredMarker(param);\n                String desc = intr.findPropertyDescription(param);\n                Integer idx = intr.findPropertyIndex(param);\n                String def = intr.findPropertyDefaultValue(param);\n                metadata = PropertyMetadata.construct(b, desc, idx, def);\n            }\n        }\n        JavaType type = resolveMemberAndTypeAnnotations(ctxt, param, param.getType());\n        BeanProperty.Std property = new BeanProperty.Std(name, type,\n                intr.findWrapperName(param), param, metadata);\n        \n        TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler();\n        \n        if (typeDeser == null) {\n            typeDeser = findTypeDeserializer(config, type);\n        }\n        \n        \n\n        Object injectableValueId = (injectable == null) ? null : injectable.getId();\n        \n        SettableBeanProperty prop = new CreatorProperty(name, type, property.getWrapperName(),\n                typeDeser, beanDesc.getClassAnnotations(), param, index, injectableValueId,\n                metadata);\n        JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, param);\n        if (deser == null) {\n            deser = type.getValueHandler();\n        }\n        if (deser != null) {\n            \n            deser = ctxt.handlePrimaryContextualization(deser, prop, type);\n            prop = prop.withValueDeserializer(deser);\n        }\n        return prop;\n    }\n\n    private PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr) {\n        if (param != null && intr != null) {\n            PropertyName name = intr.findNameForDeserialization(param);\n            if (name != null) {\n                return name;\n            }\n            \n            \n\n            String str = intr.findImplicitPropertyName(param);\n            if (str != null && !str.isEmpty()) {\n                return PropertyName.construct(str);\n            }\n        }\n        return null;\n    }\n\n    \n        \n    @Override\n    public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        JavaType elemType = type.getContentType();\n        \n        \n        JsonDeserializer<Object> contentDeser = elemType.getValueHandler();\n        \n        TypeDeserializer elemTypeDeser = elemType.getTypeHandler();\n        \n        if (elemTypeDeser == null) {\n            elemTypeDeser = findTypeDeserializer(config, elemType);\n        }\n        \n        JsonDeserializer<?>  deser = _findCustomArrayDeserializer(type,\n                config, beanDesc, elemTypeDeser, contentDeser);\n        if (deser == null) {\n            if (contentDeser == null) {\n                Class<?> raw = elemType.getRawClass();\n                if (elemType.isPrimitive()) {\n                    return PrimitiveArrayDeserializers.forType(raw);\n                }\n                if (raw == String.class) {\n                    return StringArrayDeserializer.instance;\n                }\n            }\n            deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser);\n        }\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    \n\n    @Override\n    public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException {\n        JavaType contentType = type.getContentType();\n        \n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        \n        JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type,\n                config, beanDesc, contentTypeDeser, contentDeser);\n        if (deser == null) {\n            Class<?> collectionClass = type.getRawClass();\n            if (contentDeser == null) { \n                \n                if (EnumSet.class.isAssignableFrom(collectionClass)) {\n                    deser = new EnumSetDeserializer(contentType, null);\n                }\n            }\n        }\n\n        \n        if (deser == null) {\n            if (type.isInterface() || type.isAbstract()) {\n                CollectionType implType = _mapAbstractCollectionType(type, config);\n                if (implType == null) {\n                    \n                    if (type.getTypeHandler() == null) {\n                        throw new IllegalArgumentException(\"Cannot find a deserializer for non-concrete Collection type \"+type);\n                    }\n                    deser = AbstractDeserializer.constructForNonPOJO(beanDesc);\n                } else {\n                    type = implType;\n                    \n                    beanDesc = config.introspectForCreation(type);\n                }\n            }\n            if (deser == null) {\n                ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n                if (!inst.canCreateUsingDefault()) {\n                    \n                    if (type.hasRawClass(ArrayBlockingQueue.class)) {\n                        return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst);\n                    }\n                    \n                    deser = JavaUtilCollectionsDeserializers.findForCollection(ctxt, type);\n                    if (deser != null) {\n                        return deser;\n                    }\n                }\n                \n                if (contentType.hasRawClass(String.class)) {\n                    \n                    deser = new StringCollectionDeserializer(type, contentDeser, inst);\n                } else {\n                    deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst);\n                }\n            }\n        }\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config) {\n        Class<?> collectionClass = type.getRawClass();\n        collectionClass = _collectionFallbacks.get(collectionClass.getName());\n        if (collectionClass == null) {\n            return null;\n        }\n        return (CollectionType) config.constructSpecializedType(type, collectionClass);\n    }\n    \n    \n    @Override\n    public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException {\n        JavaType contentType = type.getContentType();\n        \n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomCollectionLikeDeserializer(type, config, beanDesc,\n                contentTypeDeser, contentDeser);\n        if (deser != null) {\n            \n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyCollectionLikeDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    \n\n    @Override\n    public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        JavaType keyType = type.getKeyType();\n        JavaType contentType = type.getContentType();\n        \n        \n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();\n\n        \n        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n\n        \n        JsonDeserializer<?> deser = _findCustomMapDeserializer(type, config, beanDesc,\n                keyDes, contentTypeDeser, contentDeser);\n\n        if (deser == null) {\n            \n            Class<?> mapClass = type.getRawClass();\n            if (EnumMap.class.isAssignableFrom(mapClass)) {\n                ValueInstantiator inst;\n\n                \n                \n                if (mapClass == EnumMap.class) {\n                    inst = null;\n                } else {\n                    inst = findValueInstantiator(ctxt, beanDesc);\n                }\n                Class<?> kt = keyType.getRawClass();\n                if (kt == null || !kt.isEnum()) {\n                    throw new IllegalArgumentException(\"Cannot construct EnumMap; generic (key) type not available\");\n                }\n                deser = new EnumMapDeserializer(type, inst, null,\n                        contentDeser, contentTypeDeser, null);\n            }\n\n            \n    \n            \n            if (deser == null) {\n                if (type.isInterface() || type.isAbstract()) {\n                    @SuppressWarnings(\"rawtypes\")\n                    Class<? extends Map> fallback = _mapFallbacks.get(mapClass.getName());\n                    if (fallback != null) {\n                        mapClass = fallback;\n                        type = (MapType) config.constructSpecializedType(type, mapClass);\n                        \n                        beanDesc = config.introspectForCreation(type);\n                    } else {\n                        \n                        if (type.getTypeHandler() == null) {\n                            throw new IllegalArgumentException(\"Cannot find a deserializer for non-concrete Map type \"+type);\n                        }\n                        deser = AbstractDeserializer.constructForNonPOJO(beanDesc);\n                    }\n                } else {\n                    \n                    deser = JavaUtilCollectionsDeserializers.findForMap(ctxt, type);\n                    if (deser != null) {\n                        return deser;\n                    }\n                }\n                if (deser == null) {\n                    ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n                    \n                    \n                    \n                    \n                    MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser);\n                    JsonIgnoreProperties.Value ignorals = config.getDefaultPropertyIgnorals(Map.class,\n                            beanDesc.getClassInfo());\n                    Set<String> ignored = (ignorals == null) ? null\n                            : ignorals.findIgnoredForDeserialization();\n                    md.setIgnorableProperties(ignored);\n                    deser = md;\n                }\n            }\n        }\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyMapDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    \n    @Override\n    public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException {\n        JavaType keyType = type.getKeyType();\n        JavaType contentType = type.getContentType();\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        \n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();\n        \n        \n        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n        \n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomMapLikeDeserializer(type, config,\n                beanDesc, keyDes, contentTypeDeser, contentDeser);\n        if (deser != null) {\n            \n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyMapLikeDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    \n    \n    \n    @Override\n    public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        final Class<?> enumClass = type.getRawClass();\n        \n        JsonDeserializer<?> deser = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n\n        if (deser == null) {\n            ValueInstantiator valueInstantiator = _constructDefaultValueInstantiator(ctxt, beanDesc);\n            SettableBeanProperty[] creatorProps = (valueInstantiator == null) ? null\n                    : valueInstantiator.getFromObjectArguments(ctxt.getConfig());\n            \n            for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n                if (_hasCreatorAnnotation(ctxt, factory)) {\n                    if (factory.getParameterCount() == 0) { \n                        deser = EnumDeserializer.deserializerForNoArgsCreator(config, enumClass, factory);\n                        break;\n                    }\n                    Class<?> returnType = factory.getRawReturnType();\n                    \n                    if (returnType.isAssignableFrom(enumClass)) {\n                        deser = EnumDeserializer.deserializerForCreator(config, enumClass, factory, valueInstantiator, creatorProps);\n                        break;\n                    }\n                }\n            }\n           \n            \n            if (deser == null) {\n                deser = new EnumDeserializer(constructEnumResolver(enumClass,\n                        config, beanDesc.findJsonValueAccessor()),\n                        config.isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_ENUMS));\n            }\n        }\n\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyEnumDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    @Override\n    public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException {\n        @SuppressWarnings(\"unchecked\")\n        Class<? extends JsonNode> nodeClass = (Class<? extends JsonNode>) nodeType.getRawClass();\n        \n        JsonDeserializer<?> custom = _findCustomTreeNodeDeserializer(nodeClass, config,\n                beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        return JsonNodeDeserializer.getDeserializer(nodeClass);\n    }\n\n    @Override\n    public JsonDeserializer<?> createReferenceDeserializer(DeserializationContext ctxt, ReferenceType type, BeanDescription beanDesc) throws JsonMappingException {\n        JavaType contentType = type.getContentType();\n        \n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        if (contentTypeDeser == null) { \n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomReferenceDeserializer(type, config, beanDesc,\n                contentTypeDeser, contentDeser);\n\n        if (deser == null) {\n            \n            if (type.isTypeOrSubTypeOf(AtomicReference.class)) {\n                Class<?> rawType = type.getRawClass();\n                ValueInstantiator inst;\n                if (rawType == AtomicReference.class) {\n                    inst = null;\n                } else {\n                    \n                    inst = findValueInstantiator(ctxt, beanDesc);\n                }\n                return new AtomicReferenceDeserializer(type, inst, contentTypeDeser, contentDeser);\n            }\n        }\n        if (deser != null) {\n            \n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyReferenceDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    \n\n    @Override\n    public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n        BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n        AnnotatedClass ac = bean.getClassInfo();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n\n        \n        \n        Collection<NamedType> subtypes = null;\n        if (b == null) {\n            b = config.getDefaultTyper(baseType);\n            if (b == null) {\n                return null;\n            }\n        } else {\n            subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n        }\n        \n        \n        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n            JavaType defaultType = mapAbstractType(config, baseType);\n            if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n                b = b.defaultImpl(defaultType.getRawClass());\n            }\n        }\n        \n        \n        try {\n            return b.buildTypeDeserializer(config, baseType, subtypes);\n        } catch (IllegalArgumentException e0) {\n            InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null,\n                    e0.getMessage(), baseType);\n            e.initCause(e0);\n            throw e;\n        }\n    }\n\n    \n    protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        return OptionalHandlerFactory.instance.findDeserializer(type, ctxt.getConfig(), beanDesc);\n    }\n    \n    \n    \n    @Override\n    public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        KeyDeserializer deser = null;\n        if (_factoryConfig.hasKeyDeserializers()) {\n            BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n            for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n                deser = d.findKeyDeserializer(type, config, beanDesc);\n                if (deser != null) {\n                    break;\n                }\n            }\n        }\n        \n        if (deser == null) {\n            if (type.isEnumType()) {\n                deser = _createEnumKeyDeserializer(ctxt, type);\n            } else {\n                deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n            }\n        }\n        \n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyKeyDeserializer(config, type, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        Class<?> enumClass = type.getRawClass();\n\n        BeanDescription beanDesc = config.introspect(type);\n        \n        KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n            return des;\n        } else {\n            \n            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n            if (custom != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n            }\n            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n            if (valueDesForKey != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);\n            }\n        }\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueAccessor());\n        \n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (_hasCreatorAnnotation(ctxt, factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n                    Class<?> returnType = factory.getRawReturnType();\n                    \n                    if (returnType.isAssignableFrom(enumClass)) {\n                        \n                        if (factory.getRawParameterType(0) != String.class) {\n                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n                        }\n                        if (config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(factory.getMember(),\n                                    ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                        }\n                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                    }\n                }\n                throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n                        +enumClass.getName()+\")\");\n            }\n        }\n        \n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }\n\n    \n\n    \n    public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, annotated, baseType);        \n        \n        if (b == null) {\n            return findTypeDeserializer(config, baseType);\n        }\n        \n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(\n                config, annotated, baseType);\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    }\n    \n        \n    public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, propertyEntity, containerType);        \n        JavaType contentType = containerType.getContentType();\n        \n        if (b == null) {\n            return findTypeDeserializer(config, contentType);\n        }\n        \n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(\n                config, propertyEntity, contentType);\n        return b.buildTypeDeserializer(config, contentType, subtypes);\n    }\n\n    \n    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        Class<?> rawType = type.getRawClass();\n        \n        if (rawType == CLASS_OBJECT) {\n            \n            DeserializationConfig config = ctxt.getConfig();\n            JavaType lt, mt;\n            \n            if (_factoryConfig.hasAbstractTypeResolvers()) {\n                lt = _findRemappedType(config, List.class);\n                mt = _findRemappedType(config, Map.class);\n            } else {\n                lt = mt = null;\n            }\n            return new UntypedObjectDeserializer(lt, mt);\n        }\n        if (rawType == CLASS_STRING || rawType == CLASS_CHAR_SEQUENCE) {\n            return StringDeserializer.instance;\n        }\n        if (rawType == CLASS_ITERABLE) {\n            \n            TypeFactory tf = ctxt.getTypeFactory();\n            JavaType[] tps = tf.findTypeParameters(type, CLASS_ITERABLE);\n            JavaType elemType = (tps == null || tps.length != 1) ? TypeFactory.unknownType() : tps[0];\n            CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n            \n            return createCollectionDeserializer(ctxt, ct, beanDesc);\n        }\n        if (rawType == CLASS_MAP_ENTRY) {\n            \n            JavaType kt = type.containedTypeOrUnknown(0);\n            JavaType vt = type.containedTypeOrUnknown(1);\n            TypeDeserializer vts = (TypeDeserializer) vt.getTypeHandler();\n            if (vts == null) {\n                vts = findTypeDeserializer(ctxt.getConfig(), vt);\n            }\n            JsonDeserializer<Object> valueDeser = vt.getValueHandler();\n            KeyDeserializer keyDes = (KeyDeserializer) kt.getValueHandler();\n            return new MapEntryDeserializer(type, keyDes, valueDeser, vts);\n        }\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            \n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n            }\n            if (deser != null) {\n                return deser;\n            }\n        }\n        \n        if (rawType == TokenBuffer.class) {\n            return new TokenBufferDeserializer();\n        }\n        JsonDeserializer<?> deser = findOptionalStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n        return JdkDeserializers.find(rawType, clsName);\n    }\n\n    protected JavaType _findRemappedType(DeserializationConfig config, Class<?> rawType) throws JsonMappingException {\n        JavaType type = mapAbstractType(config, config.constructType(rawType));\n        return (type == null || type.hasRawClass(rawType)) ? null : type;\n    }\n\n    \n\n    protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomReferenceDeserializer(ReferenceType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer contentTypeDeserializer, JsonDeserializer<?> contentDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findReferenceDeserializer(type, config, beanDesc,\n                    contentTypeDeserializer, contentDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findBeanDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return (JsonDeserializer<Object>) deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findArrayDeserializer(type, config,\n                    beanDesc, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findCollectionDeserializer(type, config, beanDesc,\n                    elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findCollectionLikeDeserializer(type, config, beanDesc,\n                    elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findMapDeserializer(type, config, beanDesc,\n                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findMapLikeDeserializer(type, config, beanDesc,\n                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    \n    \n    \n    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n            Object deserDef = intr.findDeserializer(ann);\n            if (deserDef != null) {\n                return ctxt.deserializerInstance(ann, deserDef);\n            }\n        }\n        return null;\n    }\n\n    \n    protected KeyDeserializer findKeyDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n            Object deserDef = intr.findKeyDeserializer(ann);\n            if (deserDef != null) {\n                return ctxt.keyDeserializerInstance(ann, deserDef);\n            }\n        }\n        return null;\n    }\n\n    \n    protected JsonDeserializer<Object> findContentDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n            Object deserDef = intr.findContentDeserializer(ann);\n            if (deserDef != null) {\n                return ctxt.deserializerInstance(ann, deserDef);\n            }\n        }\n        return null;\n    }\n    \n    \n    protected JavaType resolveMemberAndTypeAnnotations(DeserializationContext ctxt, AnnotatedMember member, JavaType type) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr == null) {\n            return type;\n        }\n\n        \n        \n\n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            if (keyType != null) {\n                Object kdDef = intr.findKeyDeserializer(member);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); \n                }\n            }\n        }\n\n        if (type.hasContentType()) { \n            Object cdDef = intr.findContentDeserializer(member);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef);\n            if (cd != null) {\n                type = type.withContentValueHandler(cd);\n            }\n            TypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(\n                    ctxt.getConfig(), type, (AnnotatedMember) member);            \t\n            if (contentTypeDeser != null) {\n                type = type.withContentTypeHandler(contentTypeDeser);\n            }\n        }\n        TypeDeserializer valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(),\n                    type, (AnnotatedMember) member);\n        if (valueTypeDeser != null) {\n            type = type.withTypeHandler(valueTypeDeser);\n        }\n\n        \n\n        \n        \n        \n        type = intr.refineDeserializationType(ctxt.getConfig(), member, type);\n        return type;\n    }\n\n    protected EnumResolver constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMember jsonValueAccessor) {\n        if (jsonValueAccessor != null) {\n            if (config.canOverrideAccessModifiers()) {\n                ClassUtil.checkAndFixAccess(jsonValueAccessor.getMember(),\n                        config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n            return EnumResolver.constructUnsafeUsingMethod(enumClass,\n                    jsonValueAccessor, config.getAnnotationIntrospector());\n        }\n        \n        \n        return EnumResolver.constructUnsafe(enumClass, config.getAnnotationIntrospector());\n    }\n\n    \n    protected boolean _hasCreatorAnnotation(DeserializationContext ctxt, Annotated ann) {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n            JsonCreator.Mode mode = intr.findCreatorAnnotation(ctxt.getConfig(), ann);\n            return (mode != null) && (mode != JsonCreator.Mode.DISABLED); \n        }\n        return false;\n    }\n    \n    \n    \n    \n    @Deprecated\n    protected JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr == null) {\n            return type;\n        }\n        return intr.refineDeserializationType(ctxt.getConfig(), a, type);\n    }\n\n    \n    @Deprecated \n    protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException {\n        return resolveMemberAndTypeAnnotations(ctxt, member, type);\n    }\n\n    \n    @Deprecated \n    protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType) {\n        if (enumType == null) {\n            return null;\n        }\n        BeanDescription beanDesc = config.introspect(enumType);\n        return beanDesc.findJsonValueMethod();\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.deser;\n\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.JacksonInject;\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonCreator.Mode;\nimport com.fasterxml.jackson.core.JsonLocation;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.deser.impl.CreatorCandidate;\nimport com.fasterxml.jackson.databind.deser.impl.CreatorCollector;\nimport com.fasterxml.jackson.databind.deser.impl.JavaUtilCollectionsDeserializers;\nimport com.fasterxml.jackson.databind.deser.std.*;\nimport com.fasterxml.jackson.databind.exc.InvalidDefinitionException;\nimport com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.*;\n\n\n@SuppressWarnings(\"serial\")\npublic abstract class BasicDeserializerFactory extends DeserializerFactory implements java.io.Serializable { private final static Class<?> CLASS_OBJECT = Object.class; private final static Class<?> CLASS_STRING = String.class; private final static Class<?> CLASS_CHAR_SEQUENCE = CharSequence.class; private final static Class<?> CLASS_ITERABLE = Iterable.class; private final static Class<?> CLASS_MAP_ENTRY = Map.Entry.class; protected final static PropertyName UNWRAPPED_CREATOR_PARAM_NAME = new PropertyName(\"@JsonUnwrapped\"); @SuppressWarnings(\"rawtypes\") final static HashMap<String, Class<? extends Map>> _mapFallbacks = new HashMap<String, Class<? extends Map>>(); static {\n        _mapFallbacks.put(Map.class.getName(), LinkedHashMap.class);\n        _mapFallbacks.put(ConcurrentMap.class.getName(), ConcurrentHashMap.class);\n        _mapFallbacks.put(SortedMap.class.getName(), TreeMap.class);\n\n        _mapFallbacks.put(java.util.NavigableMap.class.getName(), TreeMap.class);\n        _mapFallbacks.put(java.util.concurrent.ConcurrentNavigableMap.class.getName(),\n                java.util.concurrent.ConcurrentSkipListMap.class);\n    }\n\n    \n    @SuppressWarnings(\"rawtypes\")\n    final static HashMap<String, Class<? extends Collection>> _collectionFallbacks = new HashMap<String, Class<? extends Collection>>(); static {\n        _collectionFallbacks.put(Collection.class.getName(), ArrayList.class);\n        _collectionFallbacks.put(List.class.getName(), ArrayList.class);\n        _collectionFallbacks.put(Set.class.getName(), HashSet.class);\n        _collectionFallbacks.put(SortedSet.class.getName(), TreeSet.class);\n        _collectionFallbacks.put(Queue.class.getName(), LinkedList.class);\n\n        \n        \n        _collectionFallbacks.put(\"java.util.Deque\", LinkedList.class);\n        _collectionFallbacks.put(\"java.util.NavigableSet\", TreeSet.class);\n    }\n\n    \n    \n    \n    protected final DeserializerFactoryConfig _factoryConfig; protected BasicDeserializerFactory(DeserializerFactoryConfig config) {\n        _factoryConfig = config;\n    }\n    \n    \n    public DeserializerFactoryConfig getFactoryConfig() {\n        return _factoryConfig;\n    }\n\n    protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); @Override public final DeserializerFactory withAdditionalDeserializers(Deserializers additional) {\n        return withConfig(_factoryConfig.withAdditionalDeserializers(additional));\n    }\n\n    \n    @Override\n    public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional) {\n        return withConfig(_factoryConfig.withAdditionalKeyDeserializers(additional));\n    }\n    \n    \n    @Override\n    public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier) {\n        return withConfig(_factoryConfig.withDeserializerModifier(modifier));\n    }\n\n    \n    @Override\n    public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver) {\n        return withConfig(_factoryConfig.withAbstractTypeResolver(resolver));\n    }\n\n    \n    @Override\n    public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators) {\n        return withConfig(_factoryConfig.withValueInstantiators(instantiators));\n    }\n\n    \n\n    @Override\n    public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException {\n        \n        while (true) {\n            JavaType next = _mapAbstractType2(config, type);\n            if (next == null) {\n                return type;\n            }\n            \n            \n            Class<?> prevCls = type.getRawClass();\n            Class<?> nextCls = next.getRawClass();\n            if ((prevCls == nextCls) || !prevCls.isAssignableFrom(nextCls)) {\n                throw new IllegalArgumentException(\"Invalid abstract type resolution from \"+type+\" to \"+next+\": latter is not a subtype of former\"); } type = next; } } private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) throws JsonMappingException {\n        Class<?> currClass = type.getRawClass();\n        if (_factoryConfig.hasAbstractTypeResolvers()) {\n            for (AbstractTypeResolver resolver : _factoryConfig.abstractTypeResolvers()) {\n                JavaType concrete = resolver.findTypeMapping(config, type);\n                if ((concrete != null) && !concrete.hasRawClass(currClass)) {\n                    return concrete;\n                }\n            }\n        }\n        return null;\n    }\n\n    \n\n    \n    @Override\n    public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n\n        ValueInstantiator instantiator = null;\n        \n        AnnotatedClass ac = beanDesc.getClassInfo();\n        Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac);\n        if (instDef != null) {\n            instantiator = _valueInstantiatorInstance(config, ac, instDef);\n        }\n        if (instantiator == null) {\n            \n            \n            instantiator = _findStdValueInstantiator(config, beanDesc);\n            if (instantiator == null) {\n                instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc);\n            }\n        }\n\n        \n        if (_factoryConfig.hasValueInstantiators()) {\n            for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) {\n                instantiator = insts.findValueInstantiator(config, beanDesc, instantiator);\n                \n                if (instantiator == null) {\n                    ctxt.reportBadTypeDefinition(beanDesc,\n\t\t\t\t\t\t\"Broken registered ValueInstantiators (of type %s): returned null ValueInstantiator\",\n\t\t\t\t\t\tinsts.getClass().getName());\n                }\n            }\n        }\n\n        \n        if (instantiator.getIncompleteParameter() != null) {\n            final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter();\n            final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner();\n            throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()\n                +\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n        }\n\n        return instantiator;\n    }\n\n    private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        Class<?> raw = beanDesc.getBeanClass();\n        if (raw == JsonLocation.class) {\n            return new JsonLocationInstantiator();\n        }\n        \n        if (Collection.class.isAssignableFrom(raw)) {\n            if (Collections.EMPTY_SET.getClass() == raw) {\n                return new ConstantValueInstantiator(Collections.EMPTY_SET);\n            }\n            if (Collections.EMPTY_LIST.getClass() == raw) {\n                return new ConstantValueInstantiator(Collections.EMPTY_LIST);\n            }\n        } else if (Map.class.isAssignableFrom(raw)) {\n            if (Collections.EMPTY_MAP.getClass() == raw) {\n                return new ConstantValueInstantiator(Collections.EMPTY_MAP);\n            }\n        }\n        return null;\n    }\n\n    \n    protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException {\n        CreatorCollector creators = new CreatorCollector(beanDesc, ctxt.getConfig());\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        \n        \n        final DeserializationConfig config = ctxt.getConfig();\n        VisibilityChecker<?> vchecker = config.getDefaultVisibilityChecker(beanDesc.getBeanClass(),\n                beanDesc.getClassInfo());\n\n        \n        \n        Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorDefs = _findCreatorsFromProperties(ctxt,\n                beanDesc);\n        \n        \n        _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n        \n        if (beanDesc.getType().isConcrete()) {\n            _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n        }\n        return creators.constructValueInstantiator(ctxt);\n    }\n\n    protected Map<AnnotatedWithParams,BeanPropertyDefinition[]> _findCreatorsFromProperties(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException {\n        Map<AnnotatedWithParams,BeanPropertyDefinition[]> result = Collections.emptyMap();\n        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {\n            Iterator<AnnotatedParameter> it = propDef.getConstructorParameters();\n            while (it.hasNext()) {\n                AnnotatedParameter param = it.next();\n                AnnotatedWithParams owner = param.getOwner();\n                BeanPropertyDefinition[] defs = result.get(owner);\n                final int index = param.getIndex();\n                \n                if (defs == null) {\n                    if (result.isEmpty()) { \n                        result = new LinkedHashMap<AnnotatedWithParams,BeanPropertyDefinition[]>();\n                    }\n                    defs = new BeanPropertyDefinition[owner.getParameterCount()];\n                    result.put(owner, defs);\n                } else {\n                    if (defs[index] != null) {\n                        ctxt.reportBadTypeDefinition(beanDesc,\n\"Conflict: parameter #%d of %s bound to more than one property; %s vs %s\",\nindex, owner, defs[index], propDef);\n                    }\n                }\n                defs[index] = propDef;\n            }\n        }\n        return result;\n    }\n    \n    public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException {\n        if (instDef == null) {\n            return null;\n        }\n\n        ValueInstantiator inst;\n        \n        if (instDef instanceof ValueInstantiator) {\n            return (ValueInstantiator) instDef;\n        }\n        if (!(instDef instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned key deserializer definition of type \"\n                    +instDef.getClass().getName()\n                    +\"; expected type KeyDeserializer or Class<KeyDeserializer> instead\");\n        }\n        Class<?> instClass = (Class<?>)instDef;\n        if (ClassUtil.isBogusClass(instClass)) {\n            return null;\n        }\n        if (!ValueInstantiator.class.isAssignableFrom(instClass)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+instClass.getName()\n                    +\"; expected Class<ValueInstantiator>\");\n        }\n        HandlerInstantiator hi = config.getHandlerInstantiator();\n        if (hi != null) {\n            inst = hi.valueInstantiatorInstance(config, annotated, instClass);\n            if (inst != null) {\n                return inst;\n            }\n        }\n        return (ValueInstantiator) ClassUtil.createInstance(instClass,\n                config.canOverrideAccessModifiers());\n    }\n\n    \n\n    protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException {\n        \n        \n        \n        final boolean isNonStaticInnerClass = beanDesc.isNonStaticInnerClass();\n        if (isNonStaticInnerClass) {\n            \n            return;\n        }\n\n        \n        \n        \n        AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor();\n        if (defaultCtor != null) {\n            if (!creators.hasDefaultCreator() || _hasCreatorAnnotation(ctxt, defaultCtor)) {\n                creators.setDefaultCreator(defaultCtor);\n            }\n        }\n        \n        List<CreatorCandidate> nonAnnotated = new LinkedList<>();\n        int explCount = 0;\n        for (AnnotatedConstructor ctor : beanDesc.getConstructors()) {\n            JsonCreator.Mode creatorMode = intr.findCreatorAnnotation(ctxt.getConfig(), ctor);\n            if (Mode.DISABLED == creatorMode) {\n                continue;\n            }\n            if (creatorMode == null) {\n                \n                if (vchecker.isCreatorVisible(ctor)) {\n                    nonAnnotated.add(CreatorCandidate.construct(intr, ctor, creatorParams.get(ctor)));\n                }\n                continue;\n            }\n            switch (creatorMode) {\n            case DELEGATING:\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators,\n                        CreatorCandidate.construct(intr, ctor, null));\n                break;\n            case PROPERTIES:\n                _addExplicitPropertyCreator(ctxt, beanDesc, creators,\n                        CreatorCandidate.construct(intr, ctor, creatorParams.get(ctor)));\n                break;\n            default:\n                _addExplicitAnyCreator(ctxt, beanDesc, creators,\n                        CreatorCandidate.construct(intr, ctor, creatorParams.get(ctor)));\n                break;\n            }\n            ++explCount;\n        }\n        \n        if (explCount > 0) { \n            return;\n        }\n        List<AnnotatedWithParams> implicitCtors = null;\n        for (CreatorCandidate candidate : nonAnnotated) {\n            final int argCount = candidate.paramCount();\n            final AnnotatedWithParams ctor = candidate.creator();\n\n            \n            if (argCount == 1) {\n                BeanPropertyDefinition propDef = candidate.propertyDef(0);\n                boolean useProps = _checkIfCreatorPropertyBased(intr, ctor, propDef);\n\n                if (useProps) {\n                    SettableBeanProperty[] properties = new SettableBeanProperty[1];\n                    PropertyName name = candidate.paramName(0);\n                    properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0,\n                            candidate.parameter(0), candidate.injection(0));\n                    creators.addPropertyCreator(ctor, false, properties);\n                } else {\n                     _handleSingleArgumentCreator(creators,\n                            ctor, false,\n                            vchecker.isCreatorVisible(ctor));\n                    \n                    \n                    if (propDef != null) {\n                        ((POJOPropertyBuilder) propDef).removeConstructors();\n                    }\n                }\n                \n                continue;\n            }\n\n            \n            \n            \n\n            int nonAnnotatedParamIndex = -1;\n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            int explicitNameCount = 0;\n            int implicitWithCreatorCount = 0;\n            int injectCount = 0;\n\n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = ctor.getParameter(i);\n                BeanPropertyDefinition propDef = candidate.propertyDef(i);\n                JacksonInject.Value injectId = intr.findInjectableValue(param);\n                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n\n                if (propDef != null && propDef.isExplicitlyNamed()) {\n                    ++explicitNameCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                if (injectId != null) {\n                    ++injectCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    _reportUnwrappedCreatorProperty(ctxt, beanDesc, param);\n                    \n                    continue;\n                }\n                \n                \n                if (nonAnnotatedParamIndex < 0) {\n                    nonAnnotatedParamIndex = i;\n                }\n            }\n\n            final int namedCount = explicitNameCount + implicitWithCreatorCount;\n            \n            if ((explicitNameCount > 0) || (injectCount > 0)) {\n                \n                if ((namedCount + injectCount) == argCount) {\n                    creators.addPropertyCreator(ctor, false, properties);\n                    continue;\n                }\n                if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                    \n                    creators.addDelegatingCreator(ctor, false, properties, 0);\n                    continue;\n                }\n                \n                \n                \n                PropertyName impl = candidate.findImplicitParamName(nonAnnotatedParamIndex);\n                if (impl == null || impl.isEmpty()) {\n                    \n                    \n                    \n                    ctxt.reportBadTypeDefinition(beanDesc,\n\"Argument #%d of constructor %s has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\",\nnonAnnotatedParamIndex, ctor);\n                }\n            }\n            \n            if (!creators.hasDefaultCreator()) {\n                if (implicitCtors == null) {\n                    implicitCtors = new LinkedList<>();\n                }\n                implicitCtors.add(ctor);\n            }\n        }\n        \n        \n        if ((implicitCtors != null) && !creators.hasDelegatingCreator()\n                && !creators.hasPropertyBasedCreator()) {\n            _checkImplicitlyNamedConstructors(ctxt, beanDesc, vchecker, intr,\n                    creators, implicitCtors);\n        }\n    }\n\n    \n    protected void _addExplicitDelegatingCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException {\n        \n        \n\n        int ix = -1;\n        final int argCount = candidate.paramCount();\n        SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n        for (int i = 0; i < argCount; ++i) {\n            AnnotatedParameter param = candidate.parameter(i);\n            JacksonInject.Value injectId = candidate.injection(i);\n            if (injectId != null) {\n                properties[i] = constructCreatorProperty(ctxt, beanDesc, null, i, param, injectId);\n                continue;\n            }\n            if (ix < 0) {\n                ix = i;\n                continue;\n            }\n            \n            ctxt.reportBadTypeDefinition(beanDesc,\n                    \"More than one argument (#%d and #%d) left as delegating for Creator %s: only one allowed\",\n                    ix, i, candidate);\n        }\n        \n        if (ix < 0) {\n            ctxt.reportBadTypeDefinition(beanDesc,\n                    \"No argument left as delegating for Creator %s: exactly one required\", candidate);\n        }\n        \n        \n        if (argCount == 1) {\n            _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n            \n            \n            BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n            if (paramDef != null) {\n                ((POJOPropertyBuilder) paramDef).removeConstructors();\n            }\n            return;\n        }\n        creators.addDelegatingCreator(candidate.creator(), true, properties, ix);\n    }\n\n    \n    protected void _addExplicitPropertyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException {\n        final int paramCount = candidate.paramCount();\n        SettableBeanProperty[] properties = new SettableBeanProperty[paramCount];\n\n        for (int i = 0; i < paramCount; ++i) {\n            JacksonInject.Value injectId = candidate.injection(i);\n            AnnotatedParameter param = candidate.parameter(i);\n            PropertyName name = candidate.paramName(i);\n            if (name == null) {\n                \n                \n                NameTransformer unwrapper = ctxt.getAnnotationIntrospector().findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    _reportUnwrappedCreatorProperty(ctxt, beanDesc, param);\n                    \n                }\n                name = candidate.findImplicitParamName(i);\n                \n                if ((name == null) && (injectId == null)) {\n                    ctxt.reportBadTypeDefinition(beanDesc,\n\"Argument #%d has no property name, is not Injectable: can not use as Creator %s\", i, candidate);\n                }\n            }\n            properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n        }\n        creators.addPropertyCreator(candidate.creator(), true, properties);\n    }\n\n    \n    protected void _addExplicitAnyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException {\n        \n        if (1 != candidate.paramCount()) {\n            \n            \n            int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n            if (oneNotInjected >= 0) {\n                \n                if (candidate.paramName(oneNotInjected) == null) {\n                    _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                    return;\n                }\n            }\n            _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n            return;\n        }\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n\n        \n        boolean useProps = (paramName != null) || (injectId != null);\n        if (!useProps && (paramDef != null)) {\n            \n            \n\n            \n            \n\n            paramName = candidate.paramName(0);\n            useProps = (paramName != null) && paramDef.couldSerialize();\n        }\n        if (useProps) {\n            SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                    constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n            };\n            creators.addPropertyCreator(candidate.creator(), true, properties);\n            return;\n        }\n        _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n\n        \n        \n        if (paramDef != null) {\n            ((POJOPropertyBuilder) paramDef).removeConstructors();\n        }\n    }\n\n    private boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr, AnnotatedWithParams creator, BeanPropertyDefinition propDef) {\n        \n        if (((propDef != null) && propDef.isExplicitlyNamed())\n                || (intr.findInjectableValue(creator.getParameter(0)) != null)) {\n            return true;\n        }\n        if (propDef != null) {\n            \n            \n            String implName = propDef.getName();\n            if (implName != null && !implName.isEmpty()) {\n                if (propDef.couldSerialize()) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n\n    private void _checkImplicitlyNamedConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, List<AnnotatedWithParams> implicitCtors) throws JsonMappingException {\n        AnnotatedWithParams found = null;\n        SettableBeanProperty[] foundProps = null;\n\n        \n        \n        \n\n        main_loop:\n        for (AnnotatedWithParams ctor : implicitCtors) {\n            if (!vchecker.isCreatorVisible(ctor)) {\n                continue;\n            }\n            \n            final int argCount = ctor.getParameterCount();\n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = ctor.getParameter(i);\n                final PropertyName name = _findParamName(param, intr);\n\n                \n                if (name == null || name.isEmpty()) {\n                    continue main_loop;\n                }\n                properties[i] = constructCreatorProperty(ctxt, beanDesc, name, param.getIndex(),\n                        param,  null);\n            }\n            if (found != null) { \n                found = null;\n                break;\n            }\n            found = ctor;\n            foundProps = properties;\n        }\n        \n        if (found != null) {\n            creators.addPropertyCreator(found,  false, foundProps);\n            BasicBeanDescription bbd = (BasicBeanDescription) beanDesc;\n            \n            for (SettableBeanProperty prop : foundProps) {\n                PropertyName pn = prop.getFullName();\n                if (!bbd.hasProperty(pn)) {\n                    BeanPropertyDefinition newDef = SimpleBeanPropertyDefinition.construct(\n                            ctxt.getConfig(), prop.getMember(), pn);\n                    bbd.addProperty(newDef);\n                }\n            }\n        }\n    }\n\n    protected void _addDeserializerFactoryMethods (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException {\n        List<CreatorCandidate> nonAnnotated = new LinkedList<>();\n        int explCount = 0;\n\n        \n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            JsonCreator.Mode creatorMode = intr.findCreatorAnnotation(ctxt.getConfig(), factory);\n            final int argCount = factory.getParameterCount();\n            if (creatorMode == null) {\n                \n                if ((argCount == 1) && vchecker.isCreatorVisible(factory)) {\n                    nonAnnotated.add(CreatorCandidate.construct(intr, factory, null));\n                }\n                continue;\n            }\n            if (creatorMode == Mode.DISABLED) {\n                continue;\n            }\n            \n            \n            if (argCount == 0) {\n                creators.setDefaultCreator(factory);\n                continue;\n            }\n\n            switch (creatorMode) {\n            case DELEGATING:\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators,\n                        CreatorCandidate.construct(intr, factory, null));\n                break;\n            case PROPERTIES:\n                _addExplicitPropertyCreator(ctxt, beanDesc, creators,\n                        CreatorCandidate.construct(intr, factory, creatorParams.get(factory)));\n                break;\n            case DEFAULT:\n            default:\n                _addExplicitAnyCreator(ctxt, beanDesc, creators,\n                        CreatorCandidate.construct(intr, factory, creatorParams.get(factory)));\n                break;\n            }\n            ++explCount;\n        }\n        \n        if (explCount > 0) { \n            return;\n        }\n        \n        for (CreatorCandidate candidate : nonAnnotated) {\n            final int argCount = candidate.paramCount();\n            AnnotatedWithParams factory = candidate.creator();\n            final BeanPropertyDefinition[] propDefs = creatorParams.get(factory);\n            \n            if (argCount != 1) {\n                continue; \n            }\n            BeanPropertyDefinition argDef = candidate.propertyDef(0);\n            boolean useProps = _checkIfCreatorPropertyBased(intr, factory, argDef);\n            if (!useProps) { \n                 _handleSingleArgumentCreator(creators,\n                        factory, false, vchecker.isCreatorVisible(factory));\n                \n                \n                if (argDef != null) {\n                    ((POJOPropertyBuilder) argDef).removeConstructors();\n                }\n                continue;\n            }\n            AnnotatedParameter nonAnnotatedParam = null;            \n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            int implicitNameCount = 0;\n            int explicitNameCount = 0;\n            int injectCount = 0;\n            \n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = factory.getParameter(i);\n                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i];\n                JacksonInject.Value injectable = intr.findInjectableValue(param);\n                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n\n                if (propDef != null && propDef.isExplicitlyNamed()) {\n                    ++explicitNameCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectable);\n                    continue;\n                }\n                if (injectable != null) {\n                    ++injectCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectable);\n                    continue;\n                }\n                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    _reportUnwrappedCreatorProperty(ctxt, beanDesc, param);\n                    \n                    continue;\n                }\n                \n                \n                \n                \n                if (nonAnnotatedParam == null) {\n                    nonAnnotatedParam = param;\n                }\n            }\n            final int namedCount = explicitNameCount + implicitNameCount;\n            \n            \n            if (explicitNameCount > 0 || injectCount > 0) {\n                \n                if ((namedCount + injectCount) == argCount) {\n                    creators.addPropertyCreator(factory, false, properties);\n                } else if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                    \n                    creators.addDelegatingCreator(factory, false, properties, 0);\n                } else { \n                    ctxt.reportBadTypeDefinition(beanDesc,\n\"Argument #%d of factory method %s has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\",\n                    nonAnnotatedParam.getIndex(), factory);\n                }\n            }\n        }\n    }\n\n    protected boolean _handleSingleArgumentCreator(CreatorCollector creators, AnnotatedWithParams ctor, boolean isCreator, boolean isVisible) {\n        \n        Class<?> type = ctor.getRawParameterType(0);\n        if (type == String.class || type == CLASS_CHAR_SEQUENCE) {\n            if (isCreator || isVisible) {\n                creators.addStringCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == int.class || type == Integer.class) {\n            if (isCreator || isVisible) {\n                creators.addIntCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == long.class || type == Long.class) {\n            if (isCreator || isVisible) {\n                creators.addLongCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == double.class || type == Double.class) {\n            if (isCreator || isVisible) {\n                creators.addDoubleCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == boolean.class || type == Boolean.class) {\n            if (isCreator || isVisible) {\n                creators.addBooleanCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        \n        if (isCreator) {\n            creators.addDelegatingCreator(ctor, isCreator, null, 0);\n            return true;\n        }\n        return false;\n    }\n\n    \n    \n    protected void _reportUnwrappedCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedParameter param) throws JsonMappingException {\n        ctxt.reportBadDefinition(beanDesc.getType(), String.format(\n                \"Cannot define Creator parameter %d as `@JsonUnwrapped`: combination not yet supported\",\n                param.getIndex()));\n    }\n\n    \n    protected SettableBeanProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, PropertyName name, int index, AnnotatedParameter param, JacksonInject.Value injectable) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        PropertyMetadata metadata;\n        {\n            if (intr == null) {\n                metadata = PropertyMetadata.STD_REQUIRED_OR_OPTIONAL;\n            } else {\n                Boolean b = intr.hasRequiredMarker(param);\n                String desc = intr.findPropertyDescription(param);\n                Integer idx = intr.findPropertyIndex(param);\n                String def = intr.findPropertyDefaultValue(param);\n                metadata = PropertyMetadata.construct(b, desc, idx, def);\n            }\n        }\n        JavaType type = resolveMemberAndTypeAnnotations(ctxt, param, param.getType());\n        BeanProperty.Std property = new BeanProperty.Std(name, type,\n                intr.findWrapperName(param), param, metadata);\n        \n        TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler();\n        \n        if (typeDeser == null) {\n            typeDeser = findTypeDeserializer(config, type);\n        }\n        \n        \n\n        Object injectableValueId = (injectable == null) ? null : injectable.getId();\n        \n        SettableBeanProperty prop = new CreatorProperty(name, type, property.getWrapperName(),\n                typeDeser, beanDesc.getClassAnnotations(), param, index, injectableValueId,\n                metadata);\n        JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, param);\n        if (deser == null) {\n            deser = type.getValueHandler();\n        }\n        if (deser != null) {\n            \n            deser = ctxt.handlePrimaryContextualization(deser, prop, type);\n            prop = prop.withValueDeserializer(deser);\n        }\n        return prop;\n    }\n\n    private PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr) {\n        if (param != null && intr != null) {\n            PropertyName name = intr.findNameForDeserialization(param);\n            if (name != null) {\n                return name;\n            }\n            \n            \n\n            String str = intr.findImplicitPropertyName(param);\n            if (str != null && !str.isEmpty()) {\n                return PropertyName.construct(str);\n            }\n        }\n        return null;\n    }\n\n    \n        \n    @Override\n    public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        JavaType elemType = type.getContentType();\n        \n        \n        JsonDeserializer<Object> contentDeser = elemType.getValueHandler();\n        \n        TypeDeserializer elemTypeDeser = elemType.getTypeHandler();\n        \n        if (elemTypeDeser == null) {\n            elemTypeDeser = findTypeDeserializer(config, elemType);\n        }\n        \n        JsonDeserializer<?>  deser = _findCustomArrayDeserializer(type,\n                config, beanDesc, elemTypeDeser, contentDeser);\n        if (deser == null) {\n            if (contentDeser == null) {\n                Class<?> raw = elemType.getRawClass();\n                if (elemType.isPrimitive()) {\n                    return PrimitiveArrayDeserializers.forType(raw);\n                }\n                if (raw == String.class) {\n                    return StringArrayDeserializer.instance;\n                }\n            }\n            deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser);\n        }\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    \n\n    @Override\n    public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException {\n        JavaType contentType = type.getContentType();\n        \n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        \n        JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type,\n                config, beanDesc, contentTypeDeser, contentDeser);\n        if (deser == null) {\n            Class<?> collectionClass = type.getRawClass();\n            if (contentDeser == null) { \n                \n                if (EnumSet.class.isAssignableFrom(collectionClass)) {\n                    deser = new EnumSetDeserializer(contentType, null);\n                }\n            }\n        }\n\n        \n        if (deser == null) {\n            if (type.isInterface() || type.isAbstract()) {\n                CollectionType implType = _mapAbstractCollectionType(type, config);\n                if (implType == null) {\n                    \n                    if (type.getTypeHandler() == null) {\n                        throw new IllegalArgumentException(\"Cannot find a deserializer for non-concrete Collection type \"+type);\n                    }\n                    deser = AbstractDeserializer.constructForNonPOJO(beanDesc);\n                } else {\n                    type = implType;\n                    \n                    beanDesc = config.introspectForCreation(type);\n                }\n            }\n            if (deser == null) {\n                ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n                if (!inst.canCreateUsingDefault()) {\n                    \n                    if (type.hasRawClass(ArrayBlockingQueue.class)) {\n                        return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst);\n                    }\n                    \n                    deser = JavaUtilCollectionsDeserializers.findForCollection(ctxt, type);\n                    if (deser != null) {\n                        return deser;\n                    }\n                }\n                \n                if (contentType.hasRawClass(String.class)) {\n                    \n                    deser = new StringCollectionDeserializer(type, contentDeser, inst);\n                } else {\n                    deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst);\n                }\n            }\n        }\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config) {\n        Class<?> collectionClass = type.getRawClass();\n        collectionClass = _collectionFallbacks.get(collectionClass.getName());\n        if (collectionClass == null) {\n            return null;\n        }\n        return (CollectionType) config.constructSpecializedType(type, collectionClass);\n    }\n    \n    \n    @Override\n    public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException {\n        JavaType contentType = type.getContentType();\n        \n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomCollectionLikeDeserializer(type, config, beanDesc,\n                contentTypeDeser, contentDeser);\n        if (deser != null) {\n            \n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyCollectionLikeDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    \n\n    @Override\n    public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        JavaType keyType = type.getKeyType();\n        JavaType contentType = type.getContentType();\n        \n        \n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();\n\n        \n        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n\n        \n        JsonDeserializer<?> deser = _findCustomMapDeserializer(type, config, beanDesc,\n                keyDes, contentTypeDeser, contentDeser);\n\n        if (deser == null) {\n            \n            Class<?> mapClass = type.getRawClass();\n            if (EnumMap.class.isAssignableFrom(mapClass)) {\n                ValueInstantiator inst;\n\n                \n                \n                if (mapClass == EnumMap.class) {\n                    inst = null;\n                } else {\n                    inst = findValueInstantiator(ctxt, beanDesc);\n                }\n                Class<?> kt = keyType.getRawClass();\n                if (kt == null || !kt.isEnum()) {\n                    throw new IllegalArgumentException(\"Cannot construct EnumMap; generic (key) type not available\");\n                }\n                deser = new EnumMapDeserializer(type, inst, null,\n                        contentDeser, contentTypeDeser, null);\n            }\n\n            \n    \n            \n            if (deser == null) {\n                if (type.isInterface() || type.isAbstract()) {\n                    @SuppressWarnings(\"rawtypes\")\n                    Class<? extends Map> fallback = _mapFallbacks.get(mapClass.getName());\n                    if (fallback != null) {\n                        mapClass = fallback;\n                        type = (MapType) config.constructSpecializedType(type, mapClass);\n                        \n                        beanDesc = config.introspectForCreation(type);\n                    } else {\n                        \n                        if (type.getTypeHandler() == null) {\n                            throw new IllegalArgumentException(\"Cannot find a deserializer for non-concrete Map type \"+type);\n                        }\n                        deser = AbstractDeserializer.constructForNonPOJO(beanDesc);\n                    }\n                } else {\n                    \n                    deser = JavaUtilCollectionsDeserializers.findForMap(ctxt, type);\n                    if (deser != null) {\n                        return deser;\n                    }\n                }\n                if (deser == null) {\n                    ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n                    \n                    \n                    \n                    \n                    MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser);\n                    JsonIgnoreProperties.Value ignorals = config.getDefaultPropertyIgnorals(Map.class,\n                            beanDesc.getClassInfo());\n                    Set<String> ignored = (ignorals == null) ? null\n                            : ignorals.findIgnoredForDeserialization();\n                    md.setIgnorableProperties(ignored);\n                    deser = md;\n                }\n            }\n        }\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyMapDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    \n    @Override\n    public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException {\n        JavaType keyType = type.getKeyType();\n        JavaType contentType = type.getContentType();\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        \n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();\n        \n        \n        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n        \n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomMapLikeDeserializer(type, config,\n                beanDesc, keyDes, contentTypeDeser, contentDeser);\n        if (deser != null) {\n            \n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyMapLikeDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    \n    \n    \n    @Override\n    public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        final Class<?> enumClass = type.getRawClass();\n        \n        JsonDeserializer<?> deser = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n\n        if (deser == null) {\n            ValueInstantiator valueInstantiator = _constructDefaultValueInstantiator(ctxt, beanDesc);\n            SettableBeanProperty[] creatorProps = (valueInstantiator == null) ? null\n                    : valueInstantiator.getFromObjectArguments(ctxt.getConfig());\n            \n            for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n                if (_hasCreatorAnnotation(ctxt, factory)) {\n                    if (factory.getParameterCount() == 0) { \n                        deser = EnumDeserializer.deserializerForNoArgsCreator(config, enumClass, factory);\n                        break;\n                    }\n                    Class<?> returnType = factory.getRawReturnType();\n                    \n                    if (returnType.isAssignableFrom(enumClass)) {\n                        deser = EnumDeserializer.deserializerForCreator(config, enumClass, factory, valueInstantiator, creatorProps);\n                        break;\n                    }\n                }\n            }\n           \n            \n            if (deser == null) {\n                deser = new EnumDeserializer(constructEnumResolver(enumClass,\n                        config, beanDesc.findJsonValueAccessor()),\n                        config.isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_ENUMS));\n            }\n        }\n\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyEnumDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    @Override\n    public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException {\n        @SuppressWarnings(\"unchecked\")\n        Class<? extends JsonNode> nodeClass = (Class<? extends JsonNode>) nodeType.getRawClass();\n        \n        JsonDeserializer<?> custom = _findCustomTreeNodeDeserializer(nodeClass, config,\n                beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        return JsonNodeDeserializer.getDeserializer(nodeClass);\n    }\n\n    @Override\n    public JsonDeserializer<?> createReferenceDeserializer(DeserializationContext ctxt, ReferenceType type, BeanDescription beanDesc) throws JsonMappingException {\n        JavaType contentType = type.getContentType();\n        \n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        if (contentTypeDeser == null) { \n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomReferenceDeserializer(type, config, beanDesc,\n                contentTypeDeser, contentDeser);\n\n        if (deser == null) {\n            \n            if (type.isTypeOrSubTypeOf(AtomicReference.class)) {\n                Class<?> rawType = type.getRawClass();\n                ValueInstantiator inst;\n                if (rawType == AtomicReference.class) {\n                    inst = null;\n                } else {\n                    \n                    inst = findValueInstantiator(ctxt, beanDesc);\n                }\n                return new AtomicReferenceDeserializer(type, inst, contentTypeDeser, contentDeser);\n            }\n        }\n        if (deser != null) {\n            \n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyReferenceDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    \n\n    @Override\n    public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n        BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n        AnnotatedClass ac = bean.getClassInfo();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n\n        \n        \n        Collection<NamedType> subtypes = null;\n        if (b == null) {\n            b = config.getDefaultTyper(baseType);\n            if (b == null) {\n                return null;\n            }\n        } else {\n            subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n        }\n        \n        \n        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n            JavaType defaultType = mapAbstractType(config, baseType);\n            if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n                b = b.defaultImpl(defaultType.getRawClass());\n            }\n        }\n        \n        \n        try {\n            return b.buildTypeDeserializer(config, baseType, subtypes);\n        } catch (IllegalArgumentException e0) {\n            InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null,\n                    e0.getMessage(), baseType);\n            e.initCause(e0);\n            throw e;\n        }\n    }\n\n    \n    protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        return OptionalHandlerFactory.instance.findDeserializer(type, ctxt.getConfig(), beanDesc);\n    }\n    \n    \n    \n    @Override\n    public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        KeyDeserializer deser = null;\n        if (_factoryConfig.hasKeyDeserializers()) {\n            BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n            for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n                deser = d.findKeyDeserializer(type, config, beanDesc);\n                if (deser != null) {\n                    break;\n                }\n            }\n        }\n        \n        if (deser == null) {\n            if (type.isEnumType()) {\n                deser = _createEnumKeyDeserializer(ctxt, type);\n            } else {\n                deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n            }\n        }\n        \n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyKeyDeserializer(config, type, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        Class<?> enumClass = type.getRawClass();\n\n        BeanDescription beanDesc = config.introspect(type);\n        \n        KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n            return des;\n        } else {\n            \n            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n            if (custom != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n            }\n            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n            if (valueDesForKey != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);\n            }\n        }\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueAccessor());\n        \n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (_hasCreatorAnnotation(ctxt, factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n                    Class<?> returnType = factory.getRawReturnType();\n                    \n                    if (returnType.isAssignableFrom(enumClass)) {\n                        \n                        if (factory.getRawParameterType(0) != String.class) {\n                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n                        }\n                        if (config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(factory.getMember(),\n                                    ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                        }\n                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                    }\n                }\n                throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n                        +enumClass.getName()+\")\");\n            }\n        }\n        \n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }\n\n    \n\n    \n    public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, annotated, baseType);        \n        \n        if (b == null) {\n            return findTypeDeserializer(config, baseType);\n        }\n        \n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(\n                config, annotated, baseType);\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    }\n    \n        \n    public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, propertyEntity, containerType);        \n        JavaType contentType = containerType.getContentType();\n        \n        if (b == null) {\n            return findTypeDeserializer(config, contentType);\n        }\n        \n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(\n                config, propertyEntity, contentType);\n        return b.buildTypeDeserializer(config, contentType, subtypes);\n    }\n\n    \n    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        Class<?> rawType = type.getRawClass();\n        \n        if (rawType == CLASS_OBJECT) {\n            \n            DeserializationConfig config = ctxt.getConfig();\n            JavaType lt, mt;\n            \n            if (_factoryConfig.hasAbstractTypeResolvers()) {\n                lt = _findRemappedType(config, List.class);\n                mt = _findRemappedType(config, Map.class);\n            } else {\n                lt = mt = null;\n            }\n            return new UntypedObjectDeserializer(lt, mt);\n        }\n        if (rawType == CLASS_STRING || rawType == CLASS_CHAR_SEQUENCE) {\n            return StringDeserializer.instance;\n        }\n        if (rawType == CLASS_ITERABLE) {\n            \n            TypeFactory tf = ctxt.getTypeFactory();\n            JavaType[] tps = tf.findTypeParameters(type, CLASS_ITERABLE);\n            JavaType elemType = (tps == null || tps.length != 1) ? TypeFactory.unknownType() : tps[0];\n            CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n            \n            return createCollectionDeserializer(ctxt, ct, beanDesc);\n        }\n        if (rawType == CLASS_MAP_ENTRY) {\n            \n            JavaType kt = type.containedTypeOrUnknown(0);\n            JavaType vt = type.containedTypeOrUnknown(1);\n            TypeDeserializer vts = (TypeDeserializer) vt.getTypeHandler();\n            if (vts == null) {\n                vts = findTypeDeserializer(ctxt.getConfig(), vt);\n            }\n            JsonDeserializer<Object> valueDeser = vt.getValueHandler();\n            KeyDeserializer keyDes = (KeyDeserializer) kt.getValueHandler();\n            return new MapEntryDeserializer(type, keyDes, valueDeser, vts);\n        }\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            \n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n            }\n            if (deser != null) {\n                return deser;\n            }\n        }\n        \n        if (rawType == TokenBuffer.class) {\n            return new TokenBufferDeserializer();\n        }\n        JsonDeserializer<?> deser = findOptionalStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n        return JdkDeserializers.find(rawType, clsName);\n    }\n\n    protected JavaType _findRemappedType(DeserializationConfig config, Class<?> rawType) throws JsonMappingException {\n        JavaType type = mapAbstractType(config, config.constructType(rawType));\n        return (type == null || type.hasRawClass(rawType)) ? null : type;\n    }\n\n    \n\n    protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomReferenceDeserializer(ReferenceType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer contentTypeDeserializer, JsonDeserializer<?> contentDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findReferenceDeserializer(type, config, beanDesc,\n                    contentTypeDeserializer, contentDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findBeanDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return (JsonDeserializer<Object>) deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findArrayDeserializer(type, config,\n                    beanDesc, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findCollectionDeserializer(type, config, beanDesc,\n                    elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findCollectionLikeDeserializer(type, config, beanDesc,\n                    elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findMapDeserializer(type, config, beanDesc,\n                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findMapLikeDeserializer(type, config, beanDesc,\n                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    \n    \n    \n    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n            Object deserDef = intr.findDeserializer(ann);\n            if (deserDef != null) {\n                return ctxt.deserializerInstance(ann, deserDef);\n            }\n        }\n        return null;\n    }\n\n    \n    protected KeyDeserializer findKeyDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n            Object deserDef = intr.findKeyDeserializer(ann);\n            if (deserDef != null) {\n                return ctxt.keyDeserializerInstance(ann, deserDef);\n            }\n        }\n        return null;\n    }\n\n    \n    protected JsonDeserializer<Object> findContentDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n            Object deserDef = intr.findContentDeserializer(ann);\n            if (deserDef != null) {\n                return ctxt.deserializerInstance(ann, deserDef);\n            }\n        }\n        return null;\n    }\n    \n    \n    protected JavaType resolveMemberAndTypeAnnotations(DeserializationContext ctxt, AnnotatedMember member, JavaType type) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr == null) {\n            return type;\n        }\n\n        \n        \n\n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            if (keyType != null) {\n                Object kdDef = intr.findKeyDeserializer(member);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); \n                }\n            }\n        }\n\n        if (type.hasContentType()) { \n            Object cdDef = intr.findContentDeserializer(member);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef);\n            if (cd != null) {\n                type = type.withContentValueHandler(cd);\n            }\n            TypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(\n                    ctxt.getConfig(), type, (AnnotatedMember) member);            \t\n            if (contentTypeDeser != null) {\n                type = type.withContentTypeHandler(contentTypeDeser);\n            }\n        }\n        TypeDeserializer valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(),\n                    type, (AnnotatedMember) member);\n        if (valueTypeDeser != null) {\n            type = type.withTypeHandler(valueTypeDeser);\n        }\n\n        \n\n        \n        \n        \n        type = intr.refineDeserializationType(ctxt.getConfig(), member, type);\n        return type;\n    }\n\n    protected EnumResolver constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMember jsonValueAccessor) {\n        if (jsonValueAccessor != null) {\n            if (config.canOverrideAccessModifiers()) {\n                ClassUtil.checkAndFixAccess(jsonValueAccessor.getMember(),\n                        config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n            return EnumResolver.constructUnsafeUsingMethod(enumClass,\n                    jsonValueAccessor, config.getAnnotationIntrospector());\n        }\n        \n        \n        return EnumResolver.constructUnsafe(enumClass, config.getAnnotationIntrospector());\n    }\n\n    \n    protected boolean _hasCreatorAnnotation(DeserializationContext ctxt, Annotated ann) {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n            JsonCreator.Mode mode = intr.findCreatorAnnotation(ctxt.getConfig(), ann);\n            return (mode != null) && (mode != JsonCreator.Mode.DISABLED); \n        }\n        return false;\n    }\n    \n    \n    \n    \n    @Deprecated\n    protected JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr == null) {\n            return type;\n        }\n        return intr.refineDeserializationType(ctxt.getConfig(), a, type);\n    }\n\n    \n    @Deprecated \n    protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException {\n        return resolveMemberAndTypeAnnotations(ctxt, member, type);\n    }\n\n    \n    @Deprecated \n    protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType) {\n        if (enumType == null) {\n            return null;\n        }\n        BeanDescription beanDesc = config.introspect(enumType);\n        return beanDesc.findJsonValueMethod();\n    }\n}\n",
      "buggy_signatures": [
        "protected final DeserializerFactoryConfig _factoryConfig; protected BasicDeserializerFactory(DeserializerFactoryConfig config)",
        "public DeserializerFactoryConfig getFactoryConfig()",
        "protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); @Override public final DeserializerFactory withAdditionalDeserializers(Deserializers additional)",
        "public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional)",
        "public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier)",
        "public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver)",
        "public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators)",
        "public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException",
        "public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException",
        "private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException",
        "protected Map<AnnotatedWithParams,BeanPropertyDefinition[]> _findCreatorsFromProperties(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException",
        "public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException",
        "protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException",
        "protected void _addExplicitDelegatingCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException",
        "protected void _addExplicitPropertyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException",
        "private boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr, AnnotatedWithParams creator, BeanPropertyDefinition propDef)",
        "private void _checkImplicitlyNamedConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, List<AnnotatedWithParams> implicitCtors) throws JsonMappingException",
        "protected void _addDeserializerFactoryMethods (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException",
        "protected boolean _handleSingleArgumentCreator(CreatorCollector creators, AnnotatedWithParams ctor, boolean isCreator, boolean isVisible)",
        "protected void _reportUnwrappedCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedParameter param) throws JsonMappingException",
        "protected SettableBeanProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, PropertyName name, int index, AnnotatedParameter param, JacksonInject.Value injectable) throws JsonMappingException",
        "private PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr)",
        "public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config)",
        "public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createReferenceDeserializer(DeserializationContext ctxt, ReferenceType type, BeanDescription beanDesc) throws JsonMappingException",
        "public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException",
        "protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException",
        "private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException",
        "public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException",
        "public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException",
        "public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected JavaType _findRemappedType(DeserializationConfig config, Class<?> rawType) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomReferenceDeserializer(ReferenceType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer contentTypeDeserializer, JsonDeserializer<?> contentDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException",
        "protected KeyDeserializer findKeyDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException",
        "protected JsonDeserializer<Object> findContentDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException",
        "protected JavaType resolveMemberAndTypeAnnotations(DeserializationContext ctxt, AnnotatedMember member, JavaType type) throws JsonMappingException",
        "protected EnumResolver constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMember jsonValueAccessor)",
        "protected boolean _hasCreatorAnnotation(DeserializationContext ctxt, Annotated ann)",
        "protected JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException",
        "protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException",
        "protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType)"
      ],
      "fixed_signatures": [
        "protected final DeserializerFactoryConfig _factoryConfig; protected BasicDeserializerFactory(DeserializerFactoryConfig config)",
        "public DeserializerFactoryConfig getFactoryConfig()",
        "protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); @Override public final DeserializerFactory withAdditionalDeserializers(Deserializers additional)",
        "public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional)",
        "public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier)",
        "public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver)",
        "public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators)",
        "public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException",
        "public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException",
        "private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException",
        "protected Map<AnnotatedWithParams,BeanPropertyDefinition[]> _findCreatorsFromProperties(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException",
        "public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException",
        "protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException",
        "protected void _addExplicitDelegatingCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException",
        "protected void _addExplicitPropertyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException",
        "private boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr, AnnotatedWithParams creator, BeanPropertyDefinition propDef)",
        "private void _checkImplicitlyNamedConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, List<AnnotatedWithParams> implicitCtors) throws JsonMappingException",
        "protected void _addDeserializerFactoryMethods (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException",
        "protected boolean _handleSingleArgumentCreator(CreatorCollector creators, AnnotatedWithParams ctor, boolean isCreator, boolean isVisible)",
        "protected void _reportUnwrappedCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedParameter param) throws JsonMappingException",
        "protected SettableBeanProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, PropertyName name, int index, AnnotatedParameter param, JacksonInject.Value injectable) throws JsonMappingException",
        "private PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr)",
        "public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config)",
        "public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createReferenceDeserializer(DeserializationContext ctxt, ReferenceType type, BeanDescription beanDesc) throws JsonMappingException",
        "public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException",
        "protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException",
        "private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException",
        "public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException",
        "public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException",
        "public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected JavaType _findRemappedType(DeserializationConfig config, Class<?> rawType) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomReferenceDeserializer(ReferenceType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer contentTypeDeserializer, JsonDeserializer<?> contentDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException",
        "protected KeyDeserializer findKeyDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException",
        "protected JsonDeserializer<Object> findContentDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException",
        "protected JavaType resolveMemberAndTypeAnnotations(DeserializationContext ctxt, AnnotatedMember member, JavaType type) throws JsonMappingException",
        "protected EnumResolver constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMember jsonValueAccessor)",
        "protected boolean _hasCreatorAnnotation(DeserializationContext ctxt, Annotated ann)",
        "protected JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException",
        "protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException",
        "protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType)"
      ],
      "methods": [
        {
          "buggy_method": "  protected void _addExplicitAnyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException {\n  \n  if (1 != candidate.paramCount()) {\n  \n  \n  int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n  if (oneNotInjected >= 0) {\n  \n  if (candidate.paramName(oneNotInjected) == null) {\n  _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n  return;\n  }\n  }\n  _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n  return;\n  }\n  AnnotatedParameter param = candidate.parameter(0);\n  JacksonInject.Value injectId = candidate.injection(0);\n  PropertyName paramName = candidate.explicitParamName(0);\n  BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n\n  \n  boolean useProps = (paramName != null) || (injectId != null);\n  if (!useProps && (paramDef != null)) {\n  \n  \n\n  \n  \n\n  paramName = candidate.findImplicitParamName(0);\n  useProps = (paramName != null) && paramDef.couldSerialize();\n  }\n  if (useProps) {\n  SettableBeanProperty[] properties = new SettableBeanProperty[] {\n  constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n  };\n  creators.addPropertyCreator(candidate.creator(), true, properties);\n  return;\n  }\n  _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n\n  \n  \n  if (paramDef != null) {\n  ((POJOPropertyBuilder) paramDef).removeConstructors();\n  }\n  }",
          "fixed_method": "  protected void _addExplicitAnyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException {\n  \n  if (1 != candidate.paramCount()) {\n  \n  \n  int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n  if (oneNotInjected >= 0) {\n  \n  if (candidate.paramName(oneNotInjected) == null) {\n  _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n  return;\n  }\n  }\n  _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n  return;\n  }\n  AnnotatedParameter param = candidate.parameter(0);\n  JacksonInject.Value injectId = candidate.injection(0);\n  PropertyName paramName = candidate.explicitParamName(0);\n  BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n\n  \n  boolean useProps = (paramName != null) || (injectId != null);\n  if (!useProps && (paramDef != null)) {\n  \n  \n\n  \n  \n\n  paramName = candidate.paramName(0);\n  useProps = (paramName != null) && paramDef.couldSerialize();\n  }\n  if (useProps) {\n  SettableBeanProperty[] properties = new SettableBeanProperty[] {\n  constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n  };\n  creators.addPropertyCreator(candidate.creator(), true, properties);\n  return;\n  }\n  _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n\n  \n  \n  if (paramDef != null) {\n  ((POJOPropertyBuilder) paramDef).removeConstructors();\n  }\n  }",
          "diff": [
            "@@ -732,7 +732,7 @@",
            "             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n",
            "             //    not implicit name, but name with possible strategy-based-rename\n",
            " //            paramName = candidate.findImplicitParamName(0);\n",
            "-            paramName = candidate.findImplicitParamName(0);\n",
            "+            paramName = candidate.paramName(0);\n",
            "             useProps = (paramName != null) && paramDef.couldSerialize();\n",
            "         }\n",
            "         if (useProps) {\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
