{
  "bug_id": "74",
  "failed_tests": {
    "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest": [
      {
        "methodName": "polynomial",
        "error": "junit.framework.AssertionFailedError",
        "message": "",
        "fail_line": "                assertTrue(integ.getEvaluations() < 90);",
        "test_source": "  public void polynomial() throws DerivativeException, IntegratorException {\n  TestProblem6 pb = new TestProblem6();\n  double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n\n  for (int nSteps = 1; nSteps < 7; ++nSteps) {\n  AdamsMoultonIntegrator integ =\n  new AdamsMoultonIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-9, 1.0e-9);\n  TestProblemHandler handler = new TestProblemHandler(pb, integ);\n  integ.addStepHandler(handler);\n  integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n  pb.getFinalTime(), new double[pb.getDimension()]);\n  if (nSteps < 4) {\n  assertTrue(integ.getEvaluations() > 140);\n  } else {\n  assertTrue(integ.getEvaluations() < 90);\n  }\n  }\n\n  }",
        "stack": [
          "AdamsMoultonIntegratorTest.polynomial line 150"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.ode.nonstiff;\n\nimport org.apache.commons.math.ode.DerivativeException;\nimport org.apache.commons.math.ode.FirstOrderDifferentialEquations;\nimport org.apache.commons.math.ode.IntegratorException;\nimport org.apache.commons.math.ode.events.CombinedEventsManager;\nimport org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\nimport org.apache.commons.math.ode.sampling.DummyStepInterpolator;\nimport org.apache.commons.math.ode.sampling.StepHandler;\n\n\n\npublic abstract class EmbeddedRungeKuttaIntegrator extends AdaptiveStepsizeIntegrator { private final boolean fsal; private final double[] c; private final double[][] a; private final double[] b; private final RungeKuttaStepInterpolator prototype; private final double exp; private double safety; private double minReduction; private double maxGrowth; protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double scalAbsoluteTolerance, final double scalRelativeTolerance) {\n\n    super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    \n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n\n  }\n\n  \n  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance) {\n\n    super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    \n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n\n  }\n\n  \n  public abstract int getOrder(); public double getSafety() {\n    return safety;\n  }\n\n  \n  public void setSafety(final double safety) {\n    this.safety = safety;\n  }\n\n  \n  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    \n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    \n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, forward);\n    }\n    interpolator.storeTime(t0);\n\n    \n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    \n    while (!lastStep) {\n\n      interpolator.shift();\n\n      double error = 0;\n      for (boolean loop = true; loop;) {\n\n        if (firstTime || !fsal) {\n          \n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale;\n          if (vecAbsoluteTolerance == null) {\n              scale = new double[y0.length];\n              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n            } else {\n              scale = vecAbsoluteTolerance;\n            }\n          hNew = initializeStep(equations, forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        \n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        \n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        \n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error <= 1.0) {\n\n          \n          interpolator.storeTime(stepStart + stepSize);\n          if (manager.evaluateStep(interpolator)) {\n              final double dt = manager.getEventTime() - stepStart;\n              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                  \n                  loop = false;\n              } else {\n                  \n                  hNew = dt;\n              }\n          } else {\n            \n            loop = false;\n          }\n\n        } else {\n          \n          final double factor =\n              Math.min(maxGrowth,\n                       Math.max(minReduction, safety * Math.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      \n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      \n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (fsal) {\n        \n        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n      }\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        \n        \n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (! lastStep) {\n        \n        \n        \n          stepSize = filterStep(stepSize, forward, true);\n\n        \n        final double factor = Math.min(maxGrowth,\n                                       Math.max(minReduction,\n                                                safety * Math.pow(error, exp)));\n        final double  scaledH    = stepSize * factor;\n        final double  nextT      = stepStart + scaledH;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        hNew = filterStep(scaledH, forward, nextIsLast);\n      }\n\n    }\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n\n  }\n\n  \n  public double getMinReduction() {\n    return minReduction;\n  }\n\n  \n  public void setMinReduction(final double minReduction) {\n    this.minReduction = minReduction;\n  }\n\n  \n  public double getMaxGrowth() {\n    return maxGrowth;\n  }\n\n  \n  public void setMaxGrowth(final double maxGrowth) {\n    this.maxGrowth = maxGrowth;\n  }\n\n  \n  protected abstract double estimateError(double[][] yDotK,\n                                          double[] y0, double[] y1,\n                                          double h);\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.ode.nonstiff;\n\nimport org.apache.commons.math.ode.DerivativeException;\nimport org.apache.commons.math.ode.FirstOrderDifferentialEquations;\nimport org.apache.commons.math.ode.IntegratorException;\nimport org.apache.commons.math.ode.events.CombinedEventsManager;\nimport org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\nimport org.apache.commons.math.ode.sampling.DummyStepInterpolator;\nimport org.apache.commons.math.ode.sampling.StepHandler;\n\n\n\npublic abstract class EmbeddedRungeKuttaIntegrator extends AdaptiveStepsizeIntegrator { private final boolean fsal; private final double[] c; private final double[][] a; private final double[] b; private final RungeKuttaStepInterpolator prototype; private final double exp; private double safety; private double minReduction; private double maxGrowth; protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double scalAbsoluteTolerance, final double scalRelativeTolerance) {\n\n    super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    \n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n\n  }\n\n  \n  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance) {\n\n    super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    \n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n\n  }\n\n  \n  public abstract int getOrder(); public double getSafety() {\n    return safety;\n  }\n\n  \n  public void setSafety(final double safety) {\n    this.safety = safety;\n  }\n\n  \n  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    \n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    \n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, forward);\n    }\n    interpolator.storeTime(t0);\n\n    \n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    \n    while (!lastStep) {\n\n      interpolator.shift();\n\n      double error = 0;\n      for (boolean loop = true; loop;) {\n\n        if (firstTime || !fsal) {\n          \n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale = new double[y0.length];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n              }\n            } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n              }\n            }\n          hNew = initializeStep(equations, forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        \n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        \n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        \n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error <= 1.0) {\n\n          \n          interpolator.storeTime(stepStart + stepSize);\n          if (manager.evaluateStep(interpolator)) {\n              final double dt = manager.getEventTime() - stepStart;\n              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                  \n                  loop = false;\n              } else {\n                  \n                  hNew = dt;\n              }\n          } else {\n            \n            loop = false;\n          }\n\n        } else {\n          \n          final double factor =\n              Math.min(maxGrowth,\n                       Math.max(minReduction, safety * Math.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      \n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      \n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (fsal) {\n        \n        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n      }\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        \n        \n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (! lastStep) {\n        \n        \n        \n          stepSize = filterStep(stepSize, forward, true);\n\n        \n        final double factor = Math.min(maxGrowth,\n                                       Math.max(minReduction,\n                                                safety * Math.pow(error, exp)));\n        final double  scaledH    = stepSize * factor;\n        final double  nextT      = stepStart + scaledH;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        hNew = filterStep(scaledH, forward, nextIsLast);\n      }\n\n    }\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n\n  }\n\n  \n  public double getMinReduction() {\n    return minReduction;\n  }\n\n  \n  public void setMinReduction(final double minReduction) {\n    this.minReduction = minReduction;\n  }\n\n  \n  public double getMaxGrowth() {\n    return maxGrowth;\n  }\n\n  \n  public void setMaxGrowth(final double maxGrowth) {\n    this.maxGrowth = maxGrowth;\n  }\n\n  \n  protected abstract double estimateError(double[][] yDotK,\n                                          double[] y0, double[] y1,\n                                          double h);\n\n}\n",
      "buggy_signatures": [
        "public abstract class EmbeddedRungeKuttaIntegrator extends AdaptiveStepsizeIntegrator { private final boolean fsal; private final double[] c; private final double[][] a; private final double[] b; private final RungeKuttaStepInterpolator prototype; private final double exp; private double safety; private double minReduction; private double maxGrowth; protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double scalAbsoluteTolerance, final double scalRelativeTolerance)",
        "protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance)",
        "public abstract int getOrder(); public double getSafety()",
        "public void setSafety(final double safety)",
        "public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException",
        "public double getMinReduction()",
        "public void setMinReduction(final double minReduction)",
        "public double getMaxGrowth()",
        "public void setMaxGrowth(final double maxGrowth)"
      ],
      "fixed_signatures": [
        "public abstract class EmbeddedRungeKuttaIntegrator extends AdaptiveStepsizeIntegrator { private final boolean fsal; private final double[] c; private final double[][] a; private final double[] b; private final RungeKuttaStepInterpolator prototype; private final double exp; private double safety; private double minReduction; private double maxGrowth; protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double scalAbsoluteTolerance, final double scalRelativeTolerance)",
        "protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance)",
        "public abstract int getOrder(); public double getSafety()",
        "public void setSafety(final double safety)",
        "public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException",
        "public double getMinReduction()",
        "public void setMinReduction(final double minReduction)",
        "public double getMaxGrowth()",
        "public void setMaxGrowth(final double maxGrowth)"
      ],
      "methods": [
        {
          "buggy_method": "  public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  \n  final int stages = c.length + 1;\n  if (y != y0) {\n  System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][y0.length];\n  final double[] yTmp = new double[y0.length];\n\n  \n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n  final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n  rki.reinitialize(this, yTmp, yDotK, forward);\n  interpolator = rki;\n  } else {\n  interpolator = new DummyStepInterpolator(yTmp, forward);\n  }\n  interpolator.storeTime(t0);\n\n  \n  stepStart  = t0;\n  double  hNew  = 0;\n  boolean firstTime = true;\n  for (StepHandler handler : stepHandlers) {\n  handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  \n  while (!lastStep) {\n\n  interpolator.shift();\n\n  double error = 0;\n  for (boolean loop = true; loop;) {\n\n  if (firstTime || !fsal) {\n  \n  computeDerivatives(stepStart, y, yDotK[0]);\n  }\n\n  if (firstTime) {\n  final double[] scale;\n  if (vecAbsoluteTolerance == null) {\n  scale = new double[y0.length];\n  java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n  } else {\n  scale = vecAbsoluteTolerance;\n  }\n  hNew = initializeStep(equations, forward, getOrder(), scale,\n  stepStart, y, yDotK[0], yTmp, yDotK[1]);\n  firstTime = false;\n  }\n\n  stepSize = hNew;\n\n  \n  for (int k = 1; k < stages; ++k) {\n\n  for (int j = 0; j < y0.length; ++j) {\n  double sum = a[k-1][0] * yDotK[0][j];\n  for (int l = 1; l < k; ++l) {\n  sum += a[k-1][l] * yDotK[l][j];\n  }\n  yTmp[j] = y[j] + stepSize * sum;\n  }\n\n  computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n  }\n\n  \n  for (int j = 0; j < y0.length; ++j) {\n  double sum  = b[0] * yDotK[0][j];\n  for (int l = 1; l < stages; ++l) {\n  sum  += b[l] * yDotK[l][j];\n  }\n  yTmp[j] = y[j] + stepSize * sum;\n  }\n\n  \n  error = estimateError(yDotK, y, yTmp, stepSize);\n  if (error <= 1.0) {\n\n  \n  interpolator.storeTime(stepStart + stepSize);\n  if (manager.evaluateStep(interpolator)) {\n  final double dt = manager.getEventTime() - stepStart;\n  if (Math.abs(dt) <= Math.ulp(stepStart)) {\n  \n  loop = false;\n  } else {\n  \n  hNew = dt;\n  }\n  } else {\n  \n  loop = false;\n  }\n\n  } else {\n  \n  final double factor =\n  Math.min(maxGrowth,\n  Math.max(minReduction, safety * Math.pow(error, exp)));\n  hNew = filterStep(stepSize * factor, forward, false);\n  }\n\n  }\n\n  \n  final double nextStep = stepStart + stepSize;\n  System.arraycopy(yTmp, 0, y, 0, y0.length);\n  manager.stepAccepted(nextStep, y);\n  lastStep = manager.stop();\n\n  \n  interpolator.storeTime(nextStep);\n  for (StepHandler handler : stepHandlers) {\n  handler.handleStep(interpolator, lastStep);\n  }\n  stepStart = nextStep;\n\n  if (fsal) {\n  \n  System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n  }\n\n  if (manager.reset(stepStart, y) && ! lastStep) {\n  \n  \n  computeDerivatives(stepStart, y, yDotK[0]);\n  }\n\n  if (! lastStep) {\n  \n  \n  \n  stepSize = filterStep(stepSize, forward, true);\n\n  \n  final double factor = Math.min(maxGrowth,\n  Math.max(minReduction,\n  safety * Math.pow(error, exp)));\n  final double  scaledH  = stepSize * factor;\n  final double  nextT  = stepStart + scaledH;\n  final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n  hNew = filterStep(scaledH, forward, nextIsLast);\n  }\n\n  }\n\n  final double stopTime = stepStart;\n  resetInternalState();\n  return stopTime;\n\n  }",
          "fixed_method": "  public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  \n  final int stages = c.length + 1;\n  if (y != y0) {\n  System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][y0.length];\n  final double[] yTmp = new double[y0.length];\n\n  \n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n  final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n  rki.reinitialize(this, yTmp, yDotK, forward);\n  interpolator = rki;\n  } else {\n  interpolator = new DummyStepInterpolator(yTmp, forward);\n  }\n  interpolator.storeTime(t0);\n\n  \n  stepStart  = t0;\n  double  hNew  = 0;\n  boolean firstTime = true;\n  for (StepHandler handler : stepHandlers) {\n  handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  \n  while (!lastStep) {\n\n  interpolator.shift();\n\n  double error = 0;\n  for (boolean loop = true; loop;) {\n\n  if (firstTime || !fsal) {\n  \n  computeDerivatives(stepStart, y, yDotK[0]);\n  }\n\n  if (firstTime) {\n  final double[] scale = new double[y0.length];\n  if (vecAbsoluteTolerance == null) {\n  for (int i = 0; i < scale.length; ++i) {\n  scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n  }\n  } else {\n  for (int i = 0; i < scale.length; ++i) {\n  scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n  }\n  }\n  hNew = initializeStep(equations, forward, getOrder(), scale,\n  stepStart, y, yDotK[0], yTmp, yDotK[1]);\n  firstTime = false;\n  }\n\n  stepSize = hNew;\n\n  \n  for (int k = 1; k < stages; ++k) {\n\n  for (int j = 0; j < y0.length; ++j) {\n  double sum = a[k-1][0] * yDotK[0][j];\n  for (int l = 1; l < k; ++l) {\n  sum += a[k-1][l] * yDotK[l][j];\n  }\n  yTmp[j] = y[j] + stepSize * sum;\n  }\n\n  computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n  }\n\n  \n  for (int j = 0; j < y0.length; ++j) {\n  double sum  = b[0] * yDotK[0][j];\n  for (int l = 1; l < stages; ++l) {\n  sum  += b[l] * yDotK[l][j];\n  }\n  yTmp[j] = y[j] + stepSize * sum;\n  }\n\n  \n  error = estimateError(yDotK, y, yTmp, stepSize);\n  if (error <= 1.0) {\n\n  \n  interpolator.storeTime(stepStart + stepSize);\n  if (manager.evaluateStep(interpolator)) {\n  final double dt = manager.getEventTime() - stepStart;\n  if (Math.abs(dt) <= Math.ulp(stepStart)) {\n  \n  loop = false;\n  } else {\n  \n  hNew = dt;\n  }\n  } else {\n  \n  loop = false;\n  }\n\n  } else {\n  \n  final double factor =\n  Math.min(maxGrowth,\n  Math.max(minReduction, safety * Math.pow(error, exp)));\n  hNew = filterStep(stepSize * factor, forward, false);\n  }\n\n  }\n\n  \n  final double nextStep = stepStart + stepSize;\n  System.arraycopy(yTmp, 0, y, 0, y0.length);\n  manager.stepAccepted(nextStep, y);\n  lastStep = manager.stop();\n\n  \n  interpolator.storeTime(nextStep);\n  for (StepHandler handler : stepHandlers) {\n  handler.handleStep(interpolator, lastStep);\n  }\n  stepStart = nextStep;\n\n  if (fsal) {\n  \n  System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n  }\n\n  if (manager.reset(stepStart, y) && ! lastStep) {\n  \n  \n  computeDerivatives(stepStart, y, yDotK[0]);\n  }\n\n  if (! lastStep) {\n  \n  \n  \n  stepSize = filterStep(stepSize, forward, true);\n\n  \n  final double factor = Math.min(maxGrowth,\n  Math.max(minReduction,\n  safety * Math.pow(error, exp)));\n  final double  scaledH  = stepSize * factor;\n  final double  nextT  = stepStart + scaledH;\n  final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n  hNew = filterStep(scaledH, forward, nextIsLast);\n  }\n\n  }\n\n  final double stopTime = stepStart;\n  resetInternalState();\n  return stopTime;\n\n  }",
          "diff": [
            "@@ -242,12 +242,15 @@",
            "         }\n",
            " \n",
            "         if (firstTime) {\n",
            "-          final double[] scale;\n",
            "+          final double[] scale = new double[y0.length];\n",
            "           if (vecAbsoluteTolerance == null) {\n",
            "-              scale = new double[y0.length];\n",
            "-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n",
            "+              for (int i = 0; i < scale.length; ++i) {\n",
            "+                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n",
            "+              }\n",
            "             } else {\n",
            "-              scale = vecAbsoluteTolerance;\n",
            "+              for (int i = 0; i < scale.length; ++i) {\n",
            "+                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n",
            "+              }\n",
            "             }\n",
            "           hNew = initializeStep(equations, forward, getOrder(), scale,\n",
            "                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n"
          ],
          "changed_lines": 11
        }
      ]
    }
  ]
}
