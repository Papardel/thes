{
  "bug_id": "25",
  "failed_tests": {
    "com.fasterxml.jackson.databind.deser.TestArrayDeserialization": [
      {
        "methodName": "testByteArrayTypeOverride890",
        "error": "com.fasterxml.jackson.databind.JsonMappingException",
        "message": "Can not deserialize Class [B (of type array) as a Bean",
        "fail_line": "        HiddenBinaryBean890 result = MAPPER.readValue(",
        "test_source": "  public void testByteArrayTypeOverride890() throws Exception {\n  HiddenBinaryBean890 result = MAPPER.readValue(\n  aposToQuotes(\"{'someBytes':'AQIDBA=='}\"), HiddenBinaryBean890.class);\n  assertNotNull(result);\n  assertNotNull(result.someBytes);\n  assertEquals(byte[].class, result.someBytes.getClass());\n  }",
        "stack": [
          "DeserializerCache._createAndCache2 line 269, DeserializerCache._createAndCacheValueDeserializer line 244, DeserializerCache.findValueDeserializer line 142, DeserializationContext.findContextualValueDeserializer line 428, StdDeserializer.findDeserializer line 947, BeanDeserializerBase.resolve line 439, DeserializerCache._createAndCache2 line 296, DeserializerCache._createAndCacheValueDeserializer line 244, DeserializerCache.findValueDeserializer line 142, DeserializationContext.findRootValueDeserializer line 461, ObjectMapper._findRootDeserializer line 3804, ObjectMapper._readMapAndClose line 3698, ObjectMapper.readValue line 2714, TestArrayDeserialization.testByteArrayTypeOverride890 line 563, BeanDeserializerFactory.isPotentialBeanType line 808, BeanDeserializerFactory.createBeanDeserializer line 138, DeserializerCache._createDeserializer2 line 403, DeserializerCache._createDeserializer line 352, DeserializerCache._createAndCache2 line 264"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.deser;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\n\nimport com.fasterxml.jackson.core.JsonLocation;\n\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.deser.impl.CreatorCollector;\nimport com.fasterxml.jackson.databind.deser.std.*;\nimport com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.*;\n\n\n@SuppressWarnings(\"serial\")\npublic abstract class BasicDeserializerFactory extends DeserializerFactory implements java.io.Serializable { private final static Class<?> CLASS_OBJECT = Object.class; private final static Class<?> CLASS_STRING = String.class; private final static Class<?> CLASS_CHAR_BUFFER = CharSequence.class; private final static Class<?> CLASS_ITERABLE = Iterable.class; private final static Class<?> CLASS_MAP_ENTRY = Map.Entry.class; protected final static PropertyName UNWRAPPED_CREATOR_PARAM_NAME = new PropertyName(\"@JsonUnwrapped\"); @SuppressWarnings(\"rawtypes\") final static HashMap<String, Class<? extends Map>> _mapFallbacks = new HashMap<String, Class<? extends Map>>(); static {\n        _mapFallbacks.put(Map.class.getName(), LinkedHashMap.class);\n        _mapFallbacks.put(ConcurrentMap.class.getName(), ConcurrentHashMap.class);\n        _mapFallbacks.put(SortedMap.class.getName(), TreeMap.class);\n\n        _mapFallbacks.put(java.util.NavigableMap.class.getName(), TreeMap.class);\n        _mapFallbacks.put(java.util.concurrent.ConcurrentNavigableMap.class.getName(),\n                java.util.concurrent.ConcurrentSkipListMap.class);\n    }\n\n    \n    @SuppressWarnings(\"rawtypes\")\n    final static HashMap<String, Class<? extends Collection>> _collectionFallbacks = new HashMap<String, Class<? extends Collection>>(); static {\n        _collectionFallbacks.put(Collection.class.getName(), ArrayList.class);\n        _collectionFallbacks.put(List.class.getName(), ArrayList.class);\n        _collectionFallbacks.put(Set.class.getName(), HashSet.class);\n        _collectionFallbacks.put(SortedSet.class.getName(), TreeSet.class);\n        _collectionFallbacks.put(Queue.class.getName(), LinkedList.class);\n\n        \n        \n        _collectionFallbacks.put(\"java.util.Deque\", LinkedList.class);\n        _collectionFallbacks.put(\"java.util.NavigableSet\", TreeSet.class);\n    }\n    \n    \n    \n    \n    protected final DeserializerFactoryConfig _factoryConfig; protected BasicDeserializerFactory(DeserializerFactoryConfig config) {\n        _factoryConfig = config;\n    }\n    \n    \n    public DeserializerFactoryConfig getFactoryConfig() {\n        return _factoryConfig;\n    }\n\n    protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); @Override public final DeserializerFactory withAdditionalDeserializers(Deserializers additional) {\n        return withConfig(_factoryConfig.withAdditionalDeserializers(additional));\n    }\n\n    \n    @Override\n    public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional) {\n        return withConfig(_factoryConfig.withAdditionalKeyDeserializers(additional));\n    }\n    \n    \n    @Override\n    public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier) {\n        return withConfig(_factoryConfig.withDeserializerModifier(modifier));\n    }\n\n    \n    @Override\n    public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver) {\n        return withConfig(_factoryConfig.withAbstractTypeResolver(resolver));\n    }\n\n    \n    @Override\n    public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators) {\n        return withConfig(_factoryConfig.withValueInstantiators(instantiators));\n    }\n\n    \n\n    @Override\n    public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException {\n        \n        while (true) {\n            JavaType next = _mapAbstractType2(config, type);\n            if (next == null) {\n                return type;\n            }\n            \n            \n            Class<?> prevCls = type.getRawClass();\n            Class<?> nextCls = next.getRawClass();\n            if ((prevCls == nextCls) || !prevCls.isAssignableFrom(nextCls)) {\n                throw new IllegalArgumentException(\"Invalid abstract type resolution from \"+type+\" to \"+next+\": latter is not a subtype of former\"); } type = next; } } private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) throws JsonMappingException {\n        Class<?> currClass = type.getRawClass();\n        if (_factoryConfig.hasAbstractTypeResolvers()) {\n            for (AbstractTypeResolver resolver : _factoryConfig.abstractTypeResolvers()) {\n                JavaType concrete = resolver.findTypeMapping(config, type);\n                if (concrete != null && concrete.getRawClass() != currClass) {\n                    return concrete;\n                }\n            }\n        }\n        return null;\n    }\n    \n    \n\n    \n    @Override\n    public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n\n        ValueInstantiator instantiator = null;\n        \n        AnnotatedClass ac = beanDesc.getClassInfo();\n        Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac);\n        if (instDef != null) {\n            instantiator = _valueInstantiatorInstance(config, ac, instDef);\n        }\n        if (instantiator == null) {\n            \n            instantiator = _findStdValueInstantiator(config, beanDesc);\n            if (instantiator == null) {\n                instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc);\n            }\n        }\n        \n        \n        if (_factoryConfig.hasValueInstantiators()) {\n            for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) {\n                instantiator = insts.findValueInstantiator(config, beanDesc, instantiator);\n                \n                if (instantiator == null) {\n                    throw new JsonMappingException(\"Broken registered ValueInstantiators (of type \"\n                            +insts.getClass().getName()+\"): returned null ValueInstantiator\");\n                }\n            }\n        }\n\n        \n        if (instantiator.getIncompleteParameter() != null) {\n            final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter();\n            final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner();\n            throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()+\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n        }\n\n        return instantiator;\n    }\n\n    private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        if (beanDesc.getBeanClass() == JsonLocation.class) {\n            return new JsonLocationInstantiator();\n        }\n        return null;\n    }\n\n    \n    protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException {\n        boolean fixAccess = ctxt.canOverrideAccessModifiers();\n        CreatorCollector creators =  new CreatorCollector(beanDesc, fixAccess);\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        \n        \n        final DeserializationConfig config = ctxt.getConfig();\n        VisibilityChecker<?> vchecker = config.getDefaultVisibilityChecker();\n        vchecker = intr.findAutoDetectVisibility(beanDesc.getClassInfo(), vchecker);\n\n        \n        \n        Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorDefs = _findCreatorsFromProperties(ctxt,\n                beanDesc);\n\n        \n        _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n        \n        if (beanDesc.getType().isConcrete()) {\n            _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n        }\n        return creators.constructValueInstantiator(config);\n    }\n\n    protected Map<AnnotatedWithParams,BeanPropertyDefinition[]> _findCreatorsFromProperties(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException {\n        Map<AnnotatedWithParams,BeanPropertyDefinition[]> result = Collections.emptyMap();\n        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {\n            Iterator<AnnotatedParameter> it = propDef.getConstructorParameters();\n            while (it.hasNext()) {\n                AnnotatedParameter param = it.next();\n                AnnotatedWithParams owner = param.getOwner();\n                BeanPropertyDefinition[] defs = result.get(owner);\n                final int index = param.getIndex();\n                \n                if (defs == null) {\n                    if (result.isEmpty()) { \n                        result = new LinkedHashMap<AnnotatedWithParams,BeanPropertyDefinition[]>();\n                    }\n                    defs = new BeanPropertyDefinition[owner.getParameterCount()];\n                    result.put(owner, defs);\n                } else {\n                    if (defs[index] != null) {\n                        throw new IllegalStateException(\"Conflict: parameter #\"+index+\" of \"+owner\n                                +\" bound to more than one property; \"+defs[index]+\" vs \"+propDef);\n                    }\n                }\n                defs[index] = propDef;\n            }\n        }\n        return result;\n    }\n    \n    public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException {\n        if (instDef == null) {\n            return null;\n        }\n\n        ValueInstantiator inst;\n        \n        if (instDef instanceof ValueInstantiator) {\n            return (ValueInstantiator) instDef;\n        }\n        if (!(instDef instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned key deserializer definition of type \"\n                    +instDef.getClass().getName()\n                    +\"; expected type KeyDeserializer or Class<KeyDeserializer> instead\");\n        }\n        Class<?> instClass = (Class<?>)instDef;\n        if (ClassUtil.isBogusClass(instClass)) {\n            return null;\n        }\n        if (!ValueInstantiator.class.isAssignableFrom(instClass)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+instClass.getName()\n                    +\"; expected Class<ValueInstantiator>\");\n        }\n        HandlerInstantiator hi = config.getHandlerInstantiator();\n        if (hi != null) {\n            inst = hi.valueInstantiatorInstance(config, annotated, instClass);\n            if (inst != null) {\n                return inst;\n            }\n        }\n        return (ValueInstantiator) ClassUtil.createInstance(instClass,\n                config.canOverrideAccessModifiers());\n    }\n\n    protected void _addDeserializerConstructors (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException {\n        \n        \n        \n        AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor();\n        if (defaultCtor != null) {\n            if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) {\n                creators.setDefaultCreator(defaultCtor);\n            }\n        }\n\n        \n        List<AnnotatedConstructor> implicitCtors = null;\n        for (AnnotatedConstructor ctor : beanDesc.getConstructors()) {\n            final boolean isCreator = intr.hasCreatorAnnotation(ctor);\n            BeanPropertyDefinition[] propDefs = creatorParams.get(ctor);\n            final int argCount = ctor.getParameterCount();\n\n            \n            if (argCount == 1) {\n                BeanPropertyDefinition argDef = (propDefs == null) ? null : propDefs[0];\n                boolean useProps = _checkIfCreatorPropertyBased(intr, ctor, argDef);\n\n                if (useProps) {\n                    SettableBeanProperty[] properties = new SettableBeanProperty[1];\n                    PropertyName name = (argDef == null) ? null : argDef.getFullName();\n                    AnnotatedParameter arg = ctor.getParameter(0);\n                    properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, arg,\n                            intr.findInjectableValueId(arg));\n                    creators.addPropertyCreator(ctor, isCreator, properties);\n                } else {\n                     _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators,\n                            ctor, isCreator,\n                            vchecker.isCreatorVisible(ctor));\n                    \n                    \n                    if (argDef != null) {\n                        ((POJOPropertyBuilder) argDef).removeConstructors();\n                    }\n                }\n                \n                continue;\n            }\n\n            \n            \n            \n\n            AnnotatedParameter nonAnnotatedParam = null;\n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            int explicitNameCount = 0;\n            int implicitWithCreatorCount = 0;\n            int injectCount = 0;\n\n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = ctor.getParameter(i);\n                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i];\n                Object injectId = intr.findInjectableValueId(param);\n                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n\n                if (propDef != null && propDef.isExplicitlyNamed()) {\n                    ++explicitNameCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                if (injectId != null) {\n                    ++injectCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n                    ++explicitNameCount;\n                    continue;\n                }\n                \n                if (isCreator && (name != null && !name.isEmpty())) {\n                    ++implicitWithCreatorCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                if (nonAnnotatedParam == null) {\n                    nonAnnotatedParam = param;\n                }\n            }\n\n            final int namedCount = explicitNameCount + implicitWithCreatorCount;\n            \n            if (isCreator || (explicitNameCount > 0) || (injectCount > 0)) {\n                \n                if ((namedCount + injectCount) == argCount) {\n                    creators.addPropertyCreator(ctor, isCreator, properties);\n                    continue;\n                }\n                if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                    \n                    creators.addDelegatingCreator(ctor, isCreator, properties);\n                    continue;\n                }\n                \n                \n                \n                PropertyName impl = _findImplicitParamName(nonAnnotatedParam, intr);\n                if (impl == null || impl.isEmpty()) {\n                    \n                    int ix = nonAnnotatedParam.getIndex();\n                    if ((ix == 0) && ClassUtil.isNonStaticInnerClass(ctor.getDeclaringClass())) {\n                        throw new IllegalArgumentException(\"Non-static inner classes like \" +ctor.getDeclaringClass().getName()+\" can not use @JsonCreator for constructors\"); } throw new IllegalArgumentException(\"Argument #\"+ix +\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\"); } } if (!creators.hasDefaultCreator()) {\n                if (implicitCtors == null) {\n                    implicitCtors = new LinkedList<AnnotatedConstructor>();\n                }\n                implicitCtors.add(ctor);\n            }\n        }\n        \n        \n        if ((implicitCtors != null) && !creators.hasDelegatingCreator()\n                && !creators.hasPropertyBasedCreator()) {\n            _checkImplicitlyNamedConstructors(ctxt, beanDesc, vchecker, intr,\n                    creators, implicitCtors);\n        }\n    }\n\n    protected void _checkImplicitlyNamedConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, List<AnnotatedConstructor> implicitCtors) throws JsonMappingException {\n        AnnotatedConstructor found = null;\n        SettableBeanProperty[] foundProps = null;\n\n        \n        \n        \n\n        main_loop:\n        for (AnnotatedConstructor ctor : implicitCtors) {\n            if (!vchecker.isCreatorVisible(ctor)) {\n                continue;\n            }\n            \n            final int argCount = ctor.getParameterCount();\n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = ctor.getParameter(i);\n                final PropertyName name = _findParamName(param, intr);\n\n                \n                if (name == null || name.isEmpty()) {\n                    continue main_loop;\n                }\n                properties[i] = constructCreatorProperty(ctxt, beanDesc, name, param.getIndex(),\n                        param,  null);\n            }\n            if (found != null) { \n                found = null;\n                break;\n            }\n            found = ctor;\n            foundProps = properties;\n        }\n        \n        if (found != null) {\n            creators.addPropertyCreator(found,  false, foundProps);\n            BasicBeanDescription bbd = (BasicBeanDescription) beanDesc;\n            \n            for (SettableBeanProperty prop : foundProps) {\n                PropertyName pn = prop.getFullName();\n                if (!bbd.hasProperty(pn)) {\n                    BeanPropertyDefinition newDef = SimpleBeanPropertyDefinition.construct(\n                            ctxt.getConfig(), prop.getMember(), pn);\n                    bbd.addProperty(newDef);\n                }\n            }\n        }\n    }\n\n    protected boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr, AnnotatedWithParams creator, BeanPropertyDefinition propDef) {\n        JsonCreator.Mode mode = intr.findCreatorBinding(creator);\n\n        if (mode == JsonCreator.Mode.PROPERTIES) {\n            return true;\n        }\n        if (mode == JsonCreator.Mode.DELEGATING) {\n            return false;\n        }\n        \n        if (((propDef != null) && propDef.isExplicitlyNamed())\n                || (intr.findInjectableValueId(creator.getParameter(0)) != null)) {\n            return true;\n        }\n        if (propDef != null) {\n            \n            \n            String implName = propDef.getName();\n            if (implName != null && !implName.isEmpty()) {\n                if (propDef.couldSerialize()) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible) throws JsonMappingException {\n        \n        Class<?> type = ctor.getRawParameterType(0);\n        if (type == String.class || type == CharSequence.class) {\n            if (isCreator || isVisible) {\n                creators.addStringCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == int.class || type == Integer.class) {\n            if (isCreator || isVisible) {\n                creators.addIntCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == long.class || type == Long.class) {\n            if (isCreator || isVisible) {\n                creators.addLongCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == double.class || type == Double.class) {\n            if (isCreator || isVisible) {\n                creators.addDoubleCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == boolean.class || type == Boolean.class) {\n            if (isCreator || isVisible) {\n                creators.addBooleanCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        \n        if (isCreator) {\n            creators.addDelegatingCreator(ctor, isCreator, null);\n            return true;\n        }\n        return false;\n    }\n\n    protected void _addDeserializerFactoryMethods (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            final boolean isCreator = intr.hasCreatorAnnotation(factory);\n            final int argCount = factory.getParameterCount();\n            \n            if (argCount == 0) {\n                if (isCreator) {\n                    creators.setDefaultCreator(factory);\n                }\n                continue;\n            }\n\n            final BeanPropertyDefinition[] propDefs = creatorParams.get(factory);\n            \n            if (argCount == 1) {\n                BeanPropertyDefinition argDef = (propDefs == null) ? null : propDefs[0];\n                boolean useProps = _checkIfCreatorPropertyBased(intr, factory, argDef);\n                if (!useProps) { \n                     _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators,\n                            factory, isCreator);\n                    \n                    continue;\n                }\n                \n            } else {\n                \n                if (!isCreator) {\n                    continue;\n                }\n            }\n            \n            AnnotatedParameter nonAnnotatedParam = null;            \n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            int implicitNameCount = 0;\n            int explicitNameCount = 0;\n            int injectCount = 0;\n            \n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = factory.getParameter(i);\n                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i];\n                Object injectId = intr.findInjectableValueId(param);\n                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n\n                if (propDef != null && propDef.isExplicitlyNamed()) {\n                    ++explicitNameCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                if (injectId != null) {\n                    ++injectCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n                    ++implicitNameCount;\n                    continue;\n                }\n                \n                if (isCreator) {\n                    if (name != null && !name.isEmpty()) {\n                        ++implicitNameCount;\n                        properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                        continue;\n                    }\n                }\n                \n                \n                if (nonAnnotatedParam == null) {\n                    nonAnnotatedParam = param;\n                }\n            }\n            final int namedCount = explicitNameCount + implicitNameCount;\n            \n            \n            if (isCreator || explicitNameCount > 0 || injectCount > 0) {\n                \n                if ((namedCount + injectCount) == argCount) {\n                    creators.addPropertyCreator(factory, isCreator, properties);\n                } else if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                    \n                    creators.addDelegatingCreator(factory, isCreator, properties);\n                } else { \n                    throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()\n                            +\" of factory method \"+factory+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n                }\n            }\n        }\n    }\n\n    protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException {\n        Class<?> type = factory.getRawParameterType(0);\n        \n        if (type == String.class || type == CharSequence.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addStringCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == int.class || type == Integer.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addIntCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == long.class || type == Long.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addLongCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == double.class || type == Double.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addDoubleCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == boolean.class || type == Boolean.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addBooleanCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (isCreator) {\n            creators.addDelegatingCreator(factory, isCreator, null);\n            return true;\n        }\n        return false;\n    }\n\n    \n    protected SettableBeanProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, PropertyName name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        PropertyMetadata metadata;\n        {\n            if (intr == null) {\n                metadata = PropertyMetadata.STD_REQUIRED_OR_OPTIONAL;\n            } else {\n                Boolean b = intr.hasRequiredMarker(param);\n                boolean req = (b != null && b.booleanValue());\n                String desc = intr.findPropertyDescription(param);\n                Integer idx = intr.findPropertyIndex(param);\n                String def = intr.findPropertyDefaultValue(param);\n                metadata = PropertyMetadata.construct(req, desc, idx, def);\n            }\n        }\n            \n        JavaType t0 = config.getTypeFactory().constructType(param.getParameterType(), beanDesc.bindingsForBeanType());\n        BeanProperty.Std property = new BeanProperty.Std(name, t0,\n                intr.findWrapperName(param),\n                beanDesc.getClassAnnotations(), param, metadata);\n        JavaType type = resolveType(ctxt, beanDesc, t0, param);\n        if (type != t0) {\n            property = property.withType(type);\n        }\n        \n        JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, param);\n\n        \n        type = modifyTypeByAnnotation(ctxt, param, type);\n\n        \n        TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler();\n        \n        if (typeDeser == null) {\n            typeDeser = findTypeDeserializer(config, type);\n        }\n        \n        \n        SettableBeanProperty prop = new CreatorProperty(name, type, property.getWrapperName(),\n                typeDeser, beanDesc.getClassAnnotations(), param, index, injectableValueId,\n                metadata);\n        if (deser != null) {\n            \n            deser = ctxt.handlePrimaryContextualization(deser, prop, type);\n            prop = prop.withValueDeserializer(deser);\n        }\n        return prop;\n    }\n\n    protected PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr) {\n        if (param != null && intr != null) {\n            PropertyName name = intr.findNameForDeserialization(param);\n            if (name != null) {\n                return name;\n            }\n            \n            \n\n            String str = intr.findImplicitPropertyName(param);\n            if (str != null && !str.isEmpty()) {\n                return PropertyName.construct(str);\n            }\n        }\n        return null;\n    }\n\n    protected PropertyName _findImplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr) {\n        String str = intr.findImplicitPropertyName(param);\n        if (str != null && !str.isEmpty()) {\n            return PropertyName.construct(str);\n        }\n        return null;\n    }\n\n    @Deprecated \n    protected PropertyName _findExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr) {\n        if (param != null && intr != null) {\n            return intr.findNameForDeserialization(param);\n        }\n        return null;\n    }\n\n    @Deprecated \n    protected boolean _hasExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr) {\n        if (param != null && intr != null) {\n            PropertyName n = intr.findNameForDeserialization(param);\n            return (n != null) && n.hasSimpleName();\n        }\n        return false;\n    }\n\n    \n        \n    @Override\n    public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        JavaType elemType = type.getContentType();\n        \n        \n        JsonDeserializer<Object> contentDeser = elemType.getValueHandler();\n        \n        TypeDeserializer elemTypeDeser = elemType.getTypeHandler();\n        \n        if (elemTypeDeser == null) {\n            elemTypeDeser = findTypeDeserializer(config, elemType);\n        }\n        \n        JsonDeserializer<?>  deser = _findCustomArrayDeserializer(type,\n                config, beanDesc, elemTypeDeser, contentDeser);\n        if (deser == null) {\n            if (contentDeser == null) {\n                Class<?> raw = elemType.getRawClass();\n                if (elemType.isPrimitive()) {\n                    return PrimitiveArrayDeserializers.forType(raw);\n                } else if (raw == String.class) {\n                    return StringArrayDeserializer.instance;\n                }\n            }\n            deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser);\n        }\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    \n\n    @Override\n    public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException {\n        JavaType contentType = type.getContentType();\n        \n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n\n        \n        JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type,\n                config, beanDesc, contentTypeDeser, contentDeser);\n        if (deser == null) {\n            Class<?> collectionClass = type.getRawClass();\n            if (contentDeser == null) { \n                \n                if (EnumSet.class.isAssignableFrom(collectionClass)) {\n                    deser = new EnumSetDeserializer(contentType, null);\n                }\n            }\n        }\n        \n        \n        if (deser == null) {\n            if (type.isInterface() || type.isAbstract()) {\n                CollectionType implType = _mapAbstractCollectionType(type, config);\n                if (implType == null) {\n                    \n                    if (type.getTypeHandler() == null) {\n                        throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Collection type \"+type);\n                    }\n                    deser = AbstractDeserializer.constructForNonPOJO(beanDesc);\n                } else {\n                    type = implType;\n                    \n                    beanDesc = config.introspectForCreation(type);\n                }\n            }\n            if (deser == null) {\n                ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n                if (!inst.canCreateUsingDefault()) {\n                    \n                    if (type.getRawClass() == ArrayBlockingQueue.class) {\n                        return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null);\n                    }\n                }\n                \n                if (contentType.getRawClass() == String.class) {\n                    \n                    deser = new StringCollectionDeserializer(type, contentDeser, inst);\n                } else {\n                    deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst);\n                }\n            }\n        }\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config) {\n        Class<?> collectionClass = type.getRawClass();\n        collectionClass = _collectionFallbacks.get(collectionClass.getName());\n        if (collectionClass == null) {\n            return null;\n        }\n        return (CollectionType) config.constructSpecializedType(type, collectionClass);\n    }\n    \n    \n    @Override\n    public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException {\n        JavaType contentType = type.getContentType();\n        \n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomCollectionLikeDeserializer(type, config, beanDesc,\n                contentTypeDeser, contentDeser);\n        if (deser != null) {\n            \n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyCollectionLikeDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    \n\n    @Override\n    public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        JavaType keyType = type.getKeyType();\n        JavaType contentType = type.getContentType();\n        \n        \n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();\n        \n        \n        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        \n        \n        JsonDeserializer<?> deser = _findCustomMapDeserializer(type, config, beanDesc,\n                keyDes, contentTypeDeser, contentDeser);\n\n        if (deser == null) {\n            \n            Class<?> mapClass = type.getRawClass();\n            if (EnumMap.class.isAssignableFrom(mapClass)) {\n                Class<?> kt = keyType.getRawClass();\n                if (kt == null || !kt.isEnum()) {\n                    throw new IllegalArgumentException(\"Can not construct EnumMap; generic (key) type not available\");\n                }\n                deser = new EnumMapDeserializer(type, null, contentDeser, contentTypeDeser);\n            }\n\n            \n    \n            \n            if (deser == null) {\n                if (type.isInterface() || type.isAbstract()) {\n                    @SuppressWarnings(\"rawtypes\")\n                    Class<? extends Map> fallback = _mapFallbacks.get(mapClass.getName());\n                    if (fallback != null) {\n                        mapClass = fallback;\n                        type = (MapType) config.constructSpecializedType(type, mapClass);\n                        \n                        beanDesc = config.introspectForCreation(type);\n                    } else {\n                        \n                        if (type.getTypeHandler() == null) {\n                            throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Map type \"+type);\n                        }\n                        deser = AbstractDeserializer.constructForNonPOJO(beanDesc);\n                    }\n                }\n                if (deser == null) {\n                    ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n                    MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser);\n                    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n                    md.setIgnorableProperties(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), false));\n                    deser = md;\n                }\n            }\n        }\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyMapDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    \n    @Override\n    public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException {\n        JavaType keyType = type.getKeyType();\n        JavaType contentType = type.getContentType();\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        \n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();\n        \n        \n        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n        \n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomMapLikeDeserializer(type, config,\n                beanDesc, keyDes, contentTypeDeser, contentDeser);\n        if (deser != null) {\n            \n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyMapLikeDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    \n    \n    \n    @Override\n    public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        final Class<?> enumClass = type.getRawClass();\n        \n        JsonDeserializer<?> deser = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n        if (deser == null) {\n            \n            for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n                if (ctxt.getAnnotationIntrospector().hasCreatorAnnotation(factory)) {\n                    int argCount = factory.getParameterCount();\n                    if (argCount == 1) {\n                        Class<?> returnType = factory.getRawReturnType();\n                        \n                        if (returnType.isAssignableFrom(enumClass)) {\n                            deser = EnumDeserializer.deserializerForCreator(config, enumClass, factory);\n                            break;\n                        }\n                    }\n                    throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n                            +enumClass.getName()+\")\");\n                }\n            }\n            \n            if (deser == null) {\n                deser = new EnumDeserializer(constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod()));\n            }\n        }\n\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyEnumDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n    \n    \n    \n    @Override\n    public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException {\n        @SuppressWarnings(\"unchecked\")\n        Class<? extends JsonNode> nodeClass = (Class<? extends JsonNode>) nodeType.getRawClass();\n        \n        JsonDeserializer<?> custom = _findCustomTreeNodeDeserializer(nodeClass, config,\n                beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        return JsonNodeDeserializer.getDeserializer(nodeClass);\n    }\n    \n    \n\n    @Override\n    public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n        BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n        AnnotatedClass ac = bean.getClassInfo();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n\n        \n        Collection<NamedType> subtypes = null;\n        if (b == null) {\n            b = config.getDefaultTyper(baseType);\n            if (b == null) {\n                return null;\n            }\n        } else {\n            subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n        }\n        \n        \n        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n            JavaType defaultType = mapAbstractType(config, baseType);\n            if (defaultType != null && defaultType.getRawClass() != baseType.getRawClass()) {\n                b = b.defaultImpl(defaultType.getRawClass());\n            }\n        }\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    }\n\n    \n    protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        return OptionalHandlerFactory.instance.findDeserializer(type, ctxt.getConfig(), beanDesc);\n    }\n    \n    \n    \n    @Override\n    public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        KeyDeserializer deser = null;\n        if (_factoryConfig.hasKeyDeserializers()) {\n            BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n            for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n                deser = d.findKeyDeserializer(type, config, beanDesc);\n                if (deser != null) {\n                    break;\n                }\n            }\n        }\n        \n        if (deser == null) {\n            if (type.isEnumType()) {\n                return _createEnumKeyDeserializer(ctxt, type);\n            }\n            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n        }\n        \n        \n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyKeyDeserializer(config, type, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        BeanDescription beanDesc = config.introspect(type);\n        JsonDeserializer<?> des = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n            return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des);\n        }\n        Class<?> enumClass = type.getRawClass();\n        \n        JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n        if (custom != null) {\n            return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n        }\n\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n        \n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (config.getAnnotationIntrospector().hasCreatorAnnotation(factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n                    Class<?> returnType = factory.getRawReturnType();\n                    \n                    if (returnType.isAssignableFrom(enumClass)) {\n                        \n                        if (factory.getGenericParameterType(0) != String.class) {\n                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n                        }\n                        if (config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(factory.getMember());\n                        }\n                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                    }\n                }\n                throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n                        +enumClass.getName()+\")\");\n            }\n        }\n        \n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }\n\n    \n\n    \n    public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, annotated, baseType);        \n        \n        if (b == null) {\n            return findTypeDeserializer(config, baseType);\n        }\n        \n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(\n                config, annotated, baseType);\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    }\n    \n        \n    public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, propertyEntity, containerType);        \n        JavaType contentType = containerType.getContentType();\n        \n        if (b == null) {\n            return findTypeDeserializer(config, contentType);\n        }\n        \n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(\n                config, propertyEntity, contentType);\n        return b.buildTypeDeserializer(config, contentType, subtypes);\n    }\n\n    \n    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        Class<?> rawType = type.getRawClass();\n        \n        if (rawType == CLASS_OBJECT) {\n            \n            DeserializationConfig config = ctxt.getConfig();\n            JavaType lt, mt;\n            \n            if (_factoryConfig.hasAbstractTypeResolvers()) {\n                lt = _findRemappedType(config, List.class);\n                mt = _findRemappedType(config, Map.class);\n            } else {\n                lt = mt = null;\n            }\n            return new UntypedObjectDeserializer(lt, mt);\n        }\n        if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n            return StringDeserializer.instance;\n        }\n        \n        if (type.isReferenceType()) {\n            JavaType referencedType = type.getReferencedType();\n            if (AtomicReference.class.isAssignableFrom(rawType)) {\n                TypeDeserializer vts = findTypeDeserializer(ctxt.getConfig(), referencedType);\n                BeanDescription refdDesc = ctxt.getConfig().introspectClassAnnotations(referencedType);\n                JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, refdDesc.getClassInfo());\n                return new AtomicReferenceDeserializer(referencedType, vts, deser);\n            }\n            \n        }\n        if (rawType == CLASS_ITERABLE) {\n            \n            TypeFactory tf = ctxt.getTypeFactory();\n            JavaType[] tps = tf.findTypeParameters(type, CLASS_ITERABLE);\n            JavaType elemType = (tps == null || tps.length != 1) ? TypeFactory.unknownType() : tps[0];\n            CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n            \n            return createCollectionDeserializer(ctxt, ct, beanDesc);\n        }\n        if (rawType == CLASS_MAP_ENTRY) {\n            \n            JavaType kt = type.containedType(0);\n            if (kt == null) {\n                kt = TypeFactory.unknownType();\n            }\n            JavaType vt = type.containedType(1);\n            if (vt == null) {\n                vt = TypeFactory.unknownType();\n            }\n            TypeDeserializer vts = (TypeDeserializer) vt.getTypeHandler();\n            if (vts == null) {\n                vts = findTypeDeserializer(ctxt.getConfig(), vt);\n            }\n            JsonDeserializer<Object> valueDeser = vt.getValueHandler();\n            KeyDeserializer keyDes = (KeyDeserializer) kt.getValueHandler();\n            return new MapEntryDeserializer(type, keyDes, valueDeser, vts);\n        }\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            \n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n            }\n            if (deser != null) {\n                return deser;\n            }\n        }\n        \n        if (rawType == TokenBuffer.class) {\n            return new TokenBufferDeserializer();\n        }\n        JsonDeserializer<?> deser = findOptionalStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n        return JdkDeserializers.find(rawType, clsName);\n    }\n\n    protected JavaType _findRemappedType(DeserializationConfig config, Class<?> rawType) throws JsonMappingException {\n        JavaType type = mapAbstractType(config, config.constructType(rawType));\n        return (type == null || type.hasRawClass(rawType)) ? null : type;\n    }\n\n    \n\n    protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findArrayDeserializer(type, config,\n                    beanDesc, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findBeanDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return (JsonDeserializer<Object>) deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findCollectionDeserializer(type, config, beanDesc,\n                    elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findCollectionLikeDeserializer(type, config, beanDesc,\n                    elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findMapDeserializer(type, config, beanDesc,\n                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findMapLikeDeserializer(type, config, beanDesc,\n                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    \n    \n    \n    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException {\n        Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann);\n        if (deserDef == null) {\n            return null;\n        }\n        return ctxt.deserializerInstance(ann, deserDef);\n    }\n\n    \n    @SuppressWarnings({ \"unchecked\" })\n    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n        \n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        Class<?> subclass = intr.findDeserializationType(a, type);\n        if (subclass != null) {\n            try {\n                type = (T) type.narrowBy(subclass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n            }\n        }\n\n        \n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                \n                if (!(type instanceof MapLikeType)) {\n                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n                }\n                try {\n                    type = (T) ((MapLikeType) type).narrowKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            JavaType keyType = type.getKeyType();\n            \n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); \n                }\n            }            \n           \n           \n           Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n           if (cc != null) {\n               try {\n                   type = (T) type.narrowContentsBy(cc);\n               } catch (IllegalArgumentException iae) {\n                   throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n               }\n           }\n           \n           JavaType contentType = type.getContentType();\n           if (contentType.getValueHandler() == null) { \n               Object cdDef = intr.findContentDeserializer(a);\n                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n                if (cd != null) {\n                    type = (T) type.withContentValueHandler(cd);\n                }\n            }\n        }\n        return type;\n    }\n    \n    \n    protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException {\n        \n        if (type.isContainerType()) {\n            AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n            JavaType keyType = type.getKeyType();\n            if (keyType != null) {\n                Object kdDef = intr.findKeyDeserializer(member);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); \n                }\n            }\n            \n            Object cdDef = intr.findContentDeserializer(member);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef);\n            if (cd != null) {\n                type = type.withContentValueHandler(cd);\n            }\n            \n            if (member instanceof AnnotatedMember) {\n            \tTypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(\n            \t        ctxt.getConfig(), type, (AnnotatedMember) member);            \t\n            \tif (contentTypeDeser != null) {\n            \t    type = type.withContentTypeHandler(contentTypeDeser);\n            \t}\n            }\n        }\n        TypeDeserializer valueTypeDeser;\n\n        if (member instanceof AnnotatedMember) { \n            valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(),\n                    type, (AnnotatedMember) member);\n        } else { \n            \n            valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), type);\n        }\n        if (valueTypeDeser != null) {\n            type = type.withTypeHandler(valueTypeDeser);\n        }\n        return type;\n    }\n    \n    protected EnumResolver constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMethod jsonValueMethod) {\n        if (jsonValueMethod != null) {\n            Method accessor = jsonValueMethod.getAnnotated();\n            if (config.canOverrideAccessModifiers()) {\n                ClassUtil.checkAndFixAccess(accessor);\n            }\n            return EnumResolver.constructUnsafeUsingMethod(enumClass, accessor);\n        }\n        \n        if (config.isEnabled(DeserializationFeature.READ_ENUMS_USING_TO_STRING)) {\n            return EnumResolver.constructUnsafeUsingToString(enumClass);\n        }\n        return EnumResolver.constructUnsafe(enumClass, config.getAnnotationIntrospector());\n    }\n\n    protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType) {\n        if (enumType == null) {\n            return null;\n        }\n        BeanDescription beanDesc = config.introspect(enumType);\n        return beanDesc.findJsonValueMethod();\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.deser;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\n\nimport com.fasterxml.jackson.core.JsonLocation;\n\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.deser.impl.CreatorCollector;\nimport com.fasterxml.jackson.databind.deser.std.*;\nimport com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.*;\n\n\n@SuppressWarnings(\"serial\")\npublic abstract class BasicDeserializerFactory extends DeserializerFactory implements java.io.Serializable { private final static Class<?> CLASS_OBJECT = Object.class; private final static Class<?> CLASS_STRING = String.class; private final static Class<?> CLASS_CHAR_BUFFER = CharSequence.class; private final static Class<?> CLASS_ITERABLE = Iterable.class; private final static Class<?> CLASS_MAP_ENTRY = Map.Entry.class; protected final static PropertyName UNWRAPPED_CREATOR_PARAM_NAME = new PropertyName(\"@JsonUnwrapped\"); @SuppressWarnings(\"rawtypes\") final static HashMap<String, Class<? extends Map>> _mapFallbacks = new HashMap<String, Class<? extends Map>>(); static {\n        _mapFallbacks.put(Map.class.getName(), LinkedHashMap.class);\n        _mapFallbacks.put(ConcurrentMap.class.getName(), ConcurrentHashMap.class);\n        _mapFallbacks.put(SortedMap.class.getName(), TreeMap.class);\n\n        _mapFallbacks.put(java.util.NavigableMap.class.getName(), TreeMap.class);\n        _mapFallbacks.put(java.util.concurrent.ConcurrentNavigableMap.class.getName(),\n                java.util.concurrent.ConcurrentSkipListMap.class);\n    }\n\n    \n    @SuppressWarnings(\"rawtypes\")\n    final static HashMap<String, Class<? extends Collection>> _collectionFallbacks = new HashMap<String, Class<? extends Collection>>(); static {\n        _collectionFallbacks.put(Collection.class.getName(), ArrayList.class);\n        _collectionFallbacks.put(List.class.getName(), ArrayList.class);\n        _collectionFallbacks.put(Set.class.getName(), HashSet.class);\n        _collectionFallbacks.put(SortedSet.class.getName(), TreeSet.class);\n        _collectionFallbacks.put(Queue.class.getName(), LinkedList.class);\n\n        \n        \n        _collectionFallbacks.put(\"java.util.Deque\", LinkedList.class);\n        _collectionFallbacks.put(\"java.util.NavigableSet\", TreeSet.class);\n    }\n    \n    \n    \n    \n    protected final DeserializerFactoryConfig _factoryConfig; protected BasicDeserializerFactory(DeserializerFactoryConfig config) {\n        _factoryConfig = config;\n    }\n    \n    \n    public DeserializerFactoryConfig getFactoryConfig() {\n        return _factoryConfig;\n    }\n\n    protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); @Override public final DeserializerFactory withAdditionalDeserializers(Deserializers additional) {\n        return withConfig(_factoryConfig.withAdditionalDeserializers(additional));\n    }\n\n    \n    @Override\n    public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional) {\n        return withConfig(_factoryConfig.withAdditionalKeyDeserializers(additional));\n    }\n    \n    \n    @Override\n    public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier) {\n        return withConfig(_factoryConfig.withDeserializerModifier(modifier));\n    }\n\n    \n    @Override\n    public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver) {\n        return withConfig(_factoryConfig.withAbstractTypeResolver(resolver));\n    }\n\n    \n    @Override\n    public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators) {\n        return withConfig(_factoryConfig.withValueInstantiators(instantiators));\n    }\n\n    \n\n    @Override\n    public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException {\n        \n        while (true) {\n            JavaType next = _mapAbstractType2(config, type);\n            if (next == null) {\n                return type;\n            }\n            \n            \n            Class<?> prevCls = type.getRawClass();\n            Class<?> nextCls = next.getRawClass();\n            if ((prevCls == nextCls) || !prevCls.isAssignableFrom(nextCls)) {\n                throw new IllegalArgumentException(\"Invalid abstract type resolution from \"+type+\" to \"+next+\": latter is not a subtype of former\"); } type = next; } } private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) throws JsonMappingException {\n        Class<?> currClass = type.getRawClass();\n        if (_factoryConfig.hasAbstractTypeResolvers()) {\n            for (AbstractTypeResolver resolver : _factoryConfig.abstractTypeResolvers()) {\n                JavaType concrete = resolver.findTypeMapping(config, type);\n                if (concrete != null && concrete.getRawClass() != currClass) {\n                    return concrete;\n                }\n            }\n        }\n        return null;\n    }\n    \n    \n\n    \n    @Override\n    public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n\n        ValueInstantiator instantiator = null;\n        \n        AnnotatedClass ac = beanDesc.getClassInfo();\n        Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac);\n        if (instDef != null) {\n            instantiator = _valueInstantiatorInstance(config, ac, instDef);\n        }\n        if (instantiator == null) {\n            \n            instantiator = _findStdValueInstantiator(config, beanDesc);\n            if (instantiator == null) {\n                instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc);\n            }\n        }\n        \n        \n        if (_factoryConfig.hasValueInstantiators()) {\n            for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) {\n                instantiator = insts.findValueInstantiator(config, beanDesc, instantiator);\n                \n                if (instantiator == null) {\n                    throw new JsonMappingException(\"Broken registered ValueInstantiators (of type \"\n                            +insts.getClass().getName()+\"): returned null ValueInstantiator\");\n                }\n            }\n        }\n\n        \n        if (instantiator.getIncompleteParameter() != null) {\n            final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter();\n            final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner();\n            throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()+\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n        }\n\n        return instantiator;\n    }\n\n    private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        if (beanDesc.getBeanClass() == JsonLocation.class) {\n            return new JsonLocationInstantiator();\n        }\n        return null;\n    }\n\n    \n    protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException {\n        boolean fixAccess = ctxt.canOverrideAccessModifiers();\n        CreatorCollector creators =  new CreatorCollector(beanDesc, fixAccess);\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        \n        \n        final DeserializationConfig config = ctxt.getConfig();\n        VisibilityChecker<?> vchecker = config.getDefaultVisibilityChecker();\n        vchecker = intr.findAutoDetectVisibility(beanDesc.getClassInfo(), vchecker);\n\n        \n        \n        Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorDefs = _findCreatorsFromProperties(ctxt,\n                beanDesc);\n\n        \n        _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n        \n        if (beanDesc.getType().isConcrete()) {\n            _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n        }\n        return creators.constructValueInstantiator(config);\n    }\n\n    protected Map<AnnotatedWithParams,BeanPropertyDefinition[]> _findCreatorsFromProperties(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException {\n        Map<AnnotatedWithParams,BeanPropertyDefinition[]> result = Collections.emptyMap();\n        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {\n            Iterator<AnnotatedParameter> it = propDef.getConstructorParameters();\n            while (it.hasNext()) {\n                AnnotatedParameter param = it.next();\n                AnnotatedWithParams owner = param.getOwner();\n                BeanPropertyDefinition[] defs = result.get(owner);\n                final int index = param.getIndex();\n                \n                if (defs == null) {\n                    if (result.isEmpty()) { \n                        result = new LinkedHashMap<AnnotatedWithParams,BeanPropertyDefinition[]>();\n                    }\n                    defs = new BeanPropertyDefinition[owner.getParameterCount()];\n                    result.put(owner, defs);\n                } else {\n                    if (defs[index] != null) {\n                        throw new IllegalStateException(\"Conflict: parameter #\"+index+\" of \"+owner\n                                +\" bound to more than one property; \"+defs[index]+\" vs \"+propDef);\n                    }\n                }\n                defs[index] = propDef;\n            }\n        }\n        return result;\n    }\n    \n    public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException {\n        if (instDef == null) {\n            return null;\n        }\n\n        ValueInstantiator inst;\n        \n        if (instDef instanceof ValueInstantiator) {\n            return (ValueInstantiator) instDef;\n        }\n        if (!(instDef instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned key deserializer definition of type \"\n                    +instDef.getClass().getName()\n                    +\"; expected type KeyDeserializer or Class<KeyDeserializer> instead\");\n        }\n        Class<?> instClass = (Class<?>)instDef;\n        if (ClassUtil.isBogusClass(instClass)) {\n            return null;\n        }\n        if (!ValueInstantiator.class.isAssignableFrom(instClass)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+instClass.getName()\n                    +\"; expected Class<ValueInstantiator>\");\n        }\n        HandlerInstantiator hi = config.getHandlerInstantiator();\n        if (hi != null) {\n            inst = hi.valueInstantiatorInstance(config, annotated, instClass);\n            if (inst != null) {\n                return inst;\n            }\n        }\n        return (ValueInstantiator) ClassUtil.createInstance(instClass,\n                config.canOverrideAccessModifiers());\n    }\n\n    protected void _addDeserializerConstructors (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException {\n        \n        \n        \n        AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor();\n        if (defaultCtor != null) {\n            if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) {\n                creators.setDefaultCreator(defaultCtor);\n            }\n        }\n\n        \n        List<AnnotatedConstructor> implicitCtors = null;\n        for (AnnotatedConstructor ctor : beanDesc.getConstructors()) {\n            final boolean isCreator = intr.hasCreatorAnnotation(ctor);\n            BeanPropertyDefinition[] propDefs = creatorParams.get(ctor);\n            final int argCount = ctor.getParameterCount();\n\n            \n            if (argCount == 1) {\n                BeanPropertyDefinition argDef = (propDefs == null) ? null : propDefs[0];\n                boolean useProps = _checkIfCreatorPropertyBased(intr, ctor, argDef);\n\n                if (useProps) {\n                    SettableBeanProperty[] properties = new SettableBeanProperty[1];\n                    PropertyName name = (argDef == null) ? null : argDef.getFullName();\n                    AnnotatedParameter arg = ctor.getParameter(0);\n                    properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, arg,\n                            intr.findInjectableValueId(arg));\n                    creators.addPropertyCreator(ctor, isCreator, properties);\n                } else {\n                     _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators,\n                            ctor, isCreator,\n                            vchecker.isCreatorVisible(ctor));\n                    \n                    \n                    if (argDef != null) {\n                        ((POJOPropertyBuilder) argDef).removeConstructors();\n                    }\n                }\n                \n                continue;\n            }\n\n            \n            \n            \n\n            AnnotatedParameter nonAnnotatedParam = null;\n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            int explicitNameCount = 0;\n            int implicitWithCreatorCount = 0;\n            int injectCount = 0;\n\n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = ctor.getParameter(i);\n                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i];\n                Object injectId = intr.findInjectableValueId(param);\n                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n\n                if (propDef != null && propDef.isExplicitlyNamed()) {\n                    ++explicitNameCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                if (injectId != null) {\n                    ++injectCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n                    ++explicitNameCount;\n                    continue;\n                }\n                \n                if (isCreator && (name != null && !name.isEmpty())) {\n                    ++implicitWithCreatorCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                if (nonAnnotatedParam == null) {\n                    nonAnnotatedParam = param;\n                }\n            }\n\n            final int namedCount = explicitNameCount + implicitWithCreatorCount;\n            \n            if (isCreator || (explicitNameCount > 0) || (injectCount > 0)) {\n                \n                if ((namedCount + injectCount) == argCount) {\n                    creators.addPropertyCreator(ctor, isCreator, properties);\n                    continue;\n                }\n                if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                    \n                    creators.addDelegatingCreator(ctor, isCreator, properties);\n                    continue;\n                }\n                \n                \n                \n                PropertyName impl = _findImplicitParamName(nonAnnotatedParam, intr);\n                if (impl == null || impl.isEmpty()) {\n                    \n                    int ix = nonAnnotatedParam.getIndex();\n                    if ((ix == 0) && ClassUtil.isNonStaticInnerClass(ctor.getDeclaringClass())) {\n                        throw new IllegalArgumentException(\"Non-static inner classes like \" +ctor.getDeclaringClass().getName()+\" can not use @JsonCreator for constructors\"); } throw new IllegalArgumentException(\"Argument #\"+ix +\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\"); } } if (!creators.hasDefaultCreator()) {\n                if (implicitCtors == null) {\n                    implicitCtors = new LinkedList<AnnotatedConstructor>();\n                }\n                implicitCtors.add(ctor);\n            }\n        }\n        \n        \n        if ((implicitCtors != null) && !creators.hasDelegatingCreator()\n                && !creators.hasPropertyBasedCreator()) {\n            _checkImplicitlyNamedConstructors(ctxt, beanDesc, vchecker, intr,\n                    creators, implicitCtors);\n        }\n    }\n\n    protected void _checkImplicitlyNamedConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, List<AnnotatedConstructor> implicitCtors) throws JsonMappingException {\n        AnnotatedConstructor found = null;\n        SettableBeanProperty[] foundProps = null;\n\n        \n        \n        \n\n        main_loop:\n        for (AnnotatedConstructor ctor : implicitCtors) {\n            if (!vchecker.isCreatorVisible(ctor)) {\n                continue;\n            }\n            \n            final int argCount = ctor.getParameterCount();\n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = ctor.getParameter(i);\n                final PropertyName name = _findParamName(param, intr);\n\n                \n                if (name == null || name.isEmpty()) {\n                    continue main_loop;\n                }\n                properties[i] = constructCreatorProperty(ctxt, beanDesc, name, param.getIndex(),\n                        param,  null);\n            }\n            if (found != null) { \n                found = null;\n                break;\n            }\n            found = ctor;\n            foundProps = properties;\n        }\n        \n        if (found != null) {\n            creators.addPropertyCreator(found,  false, foundProps);\n            BasicBeanDescription bbd = (BasicBeanDescription) beanDesc;\n            \n            for (SettableBeanProperty prop : foundProps) {\n                PropertyName pn = prop.getFullName();\n                if (!bbd.hasProperty(pn)) {\n                    BeanPropertyDefinition newDef = SimpleBeanPropertyDefinition.construct(\n                            ctxt.getConfig(), prop.getMember(), pn);\n                    bbd.addProperty(newDef);\n                }\n            }\n        }\n    }\n\n    protected boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr, AnnotatedWithParams creator, BeanPropertyDefinition propDef) {\n        JsonCreator.Mode mode = intr.findCreatorBinding(creator);\n\n        if (mode == JsonCreator.Mode.PROPERTIES) {\n            return true;\n        }\n        if (mode == JsonCreator.Mode.DELEGATING) {\n            return false;\n        }\n        \n        if (((propDef != null) && propDef.isExplicitlyNamed())\n                || (intr.findInjectableValueId(creator.getParameter(0)) != null)) {\n            return true;\n        }\n        if (propDef != null) {\n            \n            \n            String implName = propDef.getName();\n            if (implName != null && !implName.isEmpty()) {\n                if (propDef.couldSerialize()) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible) throws JsonMappingException {\n        \n        Class<?> type = ctor.getRawParameterType(0);\n        if (type == String.class || type == CharSequence.class) {\n            if (isCreator || isVisible) {\n                creators.addStringCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == int.class || type == Integer.class) {\n            if (isCreator || isVisible) {\n                creators.addIntCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == long.class || type == Long.class) {\n            if (isCreator || isVisible) {\n                creators.addLongCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == double.class || type == Double.class) {\n            if (isCreator || isVisible) {\n                creators.addDoubleCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == boolean.class || type == Boolean.class) {\n            if (isCreator || isVisible) {\n                creators.addBooleanCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        \n        if (isCreator) {\n            creators.addDelegatingCreator(ctor, isCreator, null);\n            return true;\n        }\n        return false;\n    }\n\n    protected void _addDeserializerFactoryMethods (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            final boolean isCreator = intr.hasCreatorAnnotation(factory);\n            final int argCount = factory.getParameterCount();\n            \n            if (argCount == 0) {\n                if (isCreator) {\n                    creators.setDefaultCreator(factory);\n                }\n                continue;\n            }\n\n            final BeanPropertyDefinition[] propDefs = creatorParams.get(factory);\n            \n            if (argCount == 1) {\n                BeanPropertyDefinition argDef = (propDefs == null) ? null : propDefs[0];\n                boolean useProps = _checkIfCreatorPropertyBased(intr, factory, argDef);\n                if (!useProps) { \n                     _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators,\n                            factory, isCreator);\n                    \n                    continue;\n                }\n                \n            } else {\n                \n                if (!isCreator) {\n                    continue;\n                }\n            }\n            \n            AnnotatedParameter nonAnnotatedParam = null;            \n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            int implicitNameCount = 0;\n            int explicitNameCount = 0;\n            int injectCount = 0;\n            \n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = factory.getParameter(i);\n                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i];\n                Object injectId = intr.findInjectableValueId(param);\n                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n\n                if (propDef != null && propDef.isExplicitlyNamed()) {\n                    ++explicitNameCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                if (injectId != null) {\n                    ++injectCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n                    ++implicitNameCount;\n                    continue;\n                }\n                \n                if (isCreator) {\n                    if (name != null && !name.isEmpty()) {\n                        ++implicitNameCount;\n                        properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                        continue;\n                    }\n                }\n                \n                \n                if (nonAnnotatedParam == null) {\n                    nonAnnotatedParam = param;\n                }\n            }\n            final int namedCount = explicitNameCount + implicitNameCount;\n            \n            \n            if (isCreator || explicitNameCount > 0 || injectCount > 0) {\n                \n                if ((namedCount + injectCount) == argCount) {\n                    creators.addPropertyCreator(factory, isCreator, properties);\n                } else if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                    \n                    creators.addDelegatingCreator(factory, isCreator, properties);\n                } else { \n                    throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()\n                            +\" of factory method \"+factory+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n                }\n            }\n        }\n    }\n\n    protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException {\n        Class<?> type = factory.getRawParameterType(0);\n        \n        if (type == String.class || type == CharSequence.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addStringCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == int.class || type == Integer.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addIntCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == long.class || type == Long.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addLongCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == double.class || type == Double.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addDoubleCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == boolean.class || type == Boolean.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addBooleanCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (isCreator) {\n            creators.addDelegatingCreator(factory, isCreator, null);\n            return true;\n        }\n        return false;\n    }\n\n    \n    protected SettableBeanProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, PropertyName name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        PropertyMetadata metadata;\n        {\n            if (intr == null) {\n                metadata = PropertyMetadata.STD_REQUIRED_OR_OPTIONAL;\n            } else {\n                Boolean b = intr.hasRequiredMarker(param);\n                boolean req = (b != null && b.booleanValue());\n                String desc = intr.findPropertyDescription(param);\n                Integer idx = intr.findPropertyIndex(param);\n                String def = intr.findPropertyDefaultValue(param);\n                metadata = PropertyMetadata.construct(req, desc, idx, def);\n            }\n        }\n            \n        JavaType t0 = config.getTypeFactory().constructType(param.getParameterType(), beanDesc.bindingsForBeanType());\n        BeanProperty.Std property = new BeanProperty.Std(name, t0,\n                intr.findWrapperName(param),\n                beanDesc.getClassAnnotations(), param, metadata);\n        JavaType type = resolveType(ctxt, beanDesc, t0, param);\n        if (type != t0) {\n            property = property.withType(type);\n        }\n        \n        JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, param);\n\n        \n        type = modifyTypeByAnnotation(ctxt, param, type);\n\n        \n        TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler();\n        \n        if (typeDeser == null) {\n            typeDeser = findTypeDeserializer(config, type);\n        }\n        \n        \n        SettableBeanProperty prop = new CreatorProperty(name, type, property.getWrapperName(),\n                typeDeser, beanDesc.getClassAnnotations(), param, index, injectableValueId,\n                metadata);\n        if (deser != null) {\n            \n            deser = ctxt.handlePrimaryContextualization(deser, prop, type);\n            prop = prop.withValueDeserializer(deser);\n        }\n        return prop;\n    }\n\n    protected PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr) {\n        if (param != null && intr != null) {\n            PropertyName name = intr.findNameForDeserialization(param);\n            if (name != null) {\n                return name;\n            }\n            \n            \n\n            String str = intr.findImplicitPropertyName(param);\n            if (str != null && !str.isEmpty()) {\n                return PropertyName.construct(str);\n            }\n        }\n        return null;\n    }\n\n    protected PropertyName _findImplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr) {\n        String str = intr.findImplicitPropertyName(param);\n        if (str != null && !str.isEmpty()) {\n            return PropertyName.construct(str);\n        }\n        return null;\n    }\n\n    @Deprecated \n    protected PropertyName _findExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr) {\n        if (param != null && intr != null) {\n            return intr.findNameForDeserialization(param);\n        }\n        return null;\n    }\n\n    @Deprecated \n    protected boolean _hasExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr) {\n        if (param != null && intr != null) {\n            PropertyName n = intr.findNameForDeserialization(param);\n            return (n != null) && n.hasSimpleName();\n        }\n        return false;\n    }\n\n    \n        \n    @Override\n    public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        JavaType elemType = type.getContentType();\n        \n        \n        JsonDeserializer<Object> contentDeser = elemType.getValueHandler();\n        \n        TypeDeserializer elemTypeDeser = elemType.getTypeHandler();\n        \n        if (elemTypeDeser == null) {\n            elemTypeDeser = findTypeDeserializer(config, elemType);\n        }\n        \n        JsonDeserializer<?>  deser = _findCustomArrayDeserializer(type,\n                config, beanDesc, elemTypeDeser, contentDeser);\n        if (deser == null) {\n            if (contentDeser == null) {\n                Class<?> raw = elemType.getRawClass();\n                if (elemType.isPrimitive()) {\n                    return PrimitiveArrayDeserializers.forType(raw);\n                } else if (raw == String.class) {\n                    return StringArrayDeserializer.instance;\n                }\n            }\n            deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser);\n        }\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    \n\n    @Override\n    public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException {\n        JavaType contentType = type.getContentType();\n        \n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n\n        \n        JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type,\n                config, beanDesc, contentTypeDeser, contentDeser);\n        if (deser == null) {\n            Class<?> collectionClass = type.getRawClass();\n            if (contentDeser == null) { \n                \n                if (EnumSet.class.isAssignableFrom(collectionClass)) {\n                    deser = new EnumSetDeserializer(contentType, null);\n                }\n            }\n        }\n        \n        \n        if (deser == null) {\n            if (type.isInterface() || type.isAbstract()) {\n                CollectionType implType = _mapAbstractCollectionType(type, config);\n                if (implType == null) {\n                    \n                    if (type.getTypeHandler() == null) {\n                        throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Collection type \"+type);\n                    }\n                    deser = AbstractDeserializer.constructForNonPOJO(beanDesc);\n                } else {\n                    type = implType;\n                    \n                    beanDesc = config.introspectForCreation(type);\n                }\n            }\n            if (deser == null) {\n                ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n                if (!inst.canCreateUsingDefault()) {\n                    \n                    if (type.getRawClass() == ArrayBlockingQueue.class) {\n                        return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null);\n                    }\n                }\n                \n                if (contentType.getRawClass() == String.class) {\n                    \n                    deser = new StringCollectionDeserializer(type, contentDeser, inst);\n                } else {\n                    deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst);\n                }\n            }\n        }\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config) {\n        Class<?> collectionClass = type.getRawClass();\n        collectionClass = _collectionFallbacks.get(collectionClass.getName());\n        if (collectionClass == null) {\n            return null;\n        }\n        return (CollectionType) config.constructSpecializedType(type, collectionClass);\n    }\n    \n    \n    @Override\n    public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException {\n        JavaType contentType = type.getContentType();\n        \n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomCollectionLikeDeserializer(type, config, beanDesc,\n                contentTypeDeser, contentDeser);\n        if (deser != null) {\n            \n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyCollectionLikeDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    \n\n    @Override\n    public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        JavaType keyType = type.getKeyType();\n        JavaType contentType = type.getContentType();\n        \n        \n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();\n        \n        \n        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        \n        \n        JsonDeserializer<?> deser = _findCustomMapDeserializer(type, config, beanDesc,\n                keyDes, contentTypeDeser, contentDeser);\n\n        if (deser == null) {\n            \n            Class<?> mapClass = type.getRawClass();\n            if (EnumMap.class.isAssignableFrom(mapClass)) {\n                Class<?> kt = keyType.getRawClass();\n                if (kt == null || !kt.isEnum()) {\n                    throw new IllegalArgumentException(\"Can not construct EnumMap; generic (key) type not available\");\n                }\n                deser = new EnumMapDeserializer(type, null, contentDeser, contentTypeDeser);\n            }\n\n            \n    \n            \n            if (deser == null) {\n                if (type.isInterface() || type.isAbstract()) {\n                    @SuppressWarnings(\"rawtypes\")\n                    Class<? extends Map> fallback = _mapFallbacks.get(mapClass.getName());\n                    if (fallback != null) {\n                        mapClass = fallback;\n                        type = (MapType) config.constructSpecializedType(type, mapClass);\n                        \n                        beanDesc = config.introspectForCreation(type);\n                    } else {\n                        \n                        if (type.getTypeHandler() == null) {\n                            throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Map type \"+type);\n                        }\n                        deser = AbstractDeserializer.constructForNonPOJO(beanDesc);\n                    }\n                }\n                if (deser == null) {\n                    ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n                    MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser);\n                    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n                    md.setIgnorableProperties(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), false));\n                    deser = md;\n                }\n            }\n        }\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyMapDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    \n    @Override\n    public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException {\n        JavaType keyType = type.getKeyType();\n        JavaType contentType = type.getContentType();\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        \n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();\n        \n        \n        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n        \n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomMapLikeDeserializer(type, config,\n                beanDesc, keyDes, contentTypeDeser, contentDeser);\n        if (deser != null) {\n            \n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyMapLikeDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    \n    \n    \n    @Override\n    public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        final Class<?> enumClass = type.getRawClass();\n        \n        JsonDeserializer<?> deser = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n        if (deser == null) {\n            \n            for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n                if (ctxt.getAnnotationIntrospector().hasCreatorAnnotation(factory)) {\n                    int argCount = factory.getParameterCount();\n                    if (argCount == 1) {\n                        Class<?> returnType = factory.getRawReturnType();\n                        \n                        if (returnType.isAssignableFrom(enumClass)) {\n                            deser = EnumDeserializer.deserializerForCreator(config, enumClass, factory);\n                            break;\n                        }\n                    }\n                    throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n                            +enumClass.getName()+\")\");\n                }\n            }\n            \n            if (deser == null) {\n                deser = new EnumDeserializer(constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod()));\n            }\n        }\n\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyEnumDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n    \n    \n    \n    @Override\n    public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException {\n        @SuppressWarnings(\"unchecked\")\n        Class<? extends JsonNode> nodeClass = (Class<? extends JsonNode>) nodeType.getRawClass();\n        \n        JsonDeserializer<?> custom = _findCustomTreeNodeDeserializer(nodeClass, config,\n                beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        return JsonNodeDeserializer.getDeserializer(nodeClass);\n    }\n    \n    \n\n    @Override\n    public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n        BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n        AnnotatedClass ac = bean.getClassInfo();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n\n        \n        Collection<NamedType> subtypes = null;\n        if (b == null) {\n            b = config.getDefaultTyper(baseType);\n            if (b == null) {\n                return null;\n            }\n        } else {\n            subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n        }\n        \n        \n        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n            JavaType defaultType = mapAbstractType(config, baseType);\n            if (defaultType != null && defaultType.getRawClass() != baseType.getRawClass()) {\n                b = b.defaultImpl(defaultType.getRawClass());\n            }\n        }\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    }\n\n    \n    protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        return OptionalHandlerFactory.instance.findDeserializer(type, ctxt.getConfig(), beanDesc);\n    }\n    \n    \n    \n    @Override\n    public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        KeyDeserializer deser = null;\n        if (_factoryConfig.hasKeyDeserializers()) {\n            BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n            for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n                deser = d.findKeyDeserializer(type, config, beanDesc);\n                if (deser != null) {\n                    break;\n                }\n            }\n        }\n        \n        if (deser == null) {\n            if (type.isEnumType()) {\n                return _createEnumKeyDeserializer(ctxt, type);\n            }\n            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n        }\n        \n        \n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyKeyDeserializer(config, type, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        BeanDescription beanDesc = config.introspect(type);\n        JsonDeserializer<?> des = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n            return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des);\n        }\n        Class<?> enumClass = type.getRawClass();\n        \n        JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n        if (custom != null) {\n            return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n        }\n\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n        \n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (config.getAnnotationIntrospector().hasCreatorAnnotation(factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n                    Class<?> returnType = factory.getRawReturnType();\n                    \n                    if (returnType.isAssignableFrom(enumClass)) {\n                        \n                        if (factory.getGenericParameterType(0) != String.class) {\n                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n                        }\n                        if (config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(factory.getMember());\n                        }\n                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                    }\n                }\n                throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n                        +enumClass.getName()+\")\");\n            }\n        }\n        \n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }\n\n    \n\n    \n    public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, annotated, baseType);        \n        \n        if (b == null) {\n            return findTypeDeserializer(config, baseType);\n        }\n        \n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(\n                config, annotated, baseType);\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    }\n    \n        \n    public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, propertyEntity, containerType);        \n        JavaType contentType = containerType.getContentType();\n        \n        if (b == null) {\n            return findTypeDeserializer(config, contentType);\n        }\n        \n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(\n                config, propertyEntity, contentType);\n        return b.buildTypeDeserializer(config, contentType, subtypes);\n    }\n\n    \n    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        Class<?> rawType = type.getRawClass();\n        \n        if (rawType == CLASS_OBJECT) {\n            \n            DeserializationConfig config = ctxt.getConfig();\n            JavaType lt, mt;\n            \n            if (_factoryConfig.hasAbstractTypeResolvers()) {\n                lt = _findRemappedType(config, List.class);\n                mt = _findRemappedType(config, Map.class);\n            } else {\n                lt = mt = null;\n            }\n            return new UntypedObjectDeserializer(lt, mt);\n        }\n        if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n            return StringDeserializer.instance;\n        }\n        \n        if (type.isReferenceType()) {\n            JavaType referencedType = type.getReferencedType();\n            if (AtomicReference.class.isAssignableFrom(rawType)) {\n                TypeDeserializer vts = findTypeDeserializer(ctxt.getConfig(), referencedType);\n                BeanDescription refdDesc = ctxt.getConfig().introspectClassAnnotations(referencedType);\n                JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, refdDesc.getClassInfo());\n                return new AtomicReferenceDeserializer(referencedType, vts, deser);\n            }\n            \n        }\n        if (rawType == CLASS_ITERABLE) {\n            \n            TypeFactory tf = ctxt.getTypeFactory();\n            JavaType[] tps = tf.findTypeParameters(type, CLASS_ITERABLE);\n            JavaType elemType = (tps == null || tps.length != 1) ? TypeFactory.unknownType() : tps[0];\n            CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n            \n            return createCollectionDeserializer(ctxt, ct, beanDesc);\n        }\n        if (rawType == CLASS_MAP_ENTRY) {\n            \n            JavaType kt = type.containedType(0);\n            if (kt == null) {\n                kt = TypeFactory.unknownType();\n            }\n            JavaType vt = type.containedType(1);\n            if (vt == null) {\n                vt = TypeFactory.unknownType();\n            }\n            TypeDeserializer vts = (TypeDeserializer) vt.getTypeHandler();\n            if (vts == null) {\n                vts = findTypeDeserializer(ctxt.getConfig(), vt);\n            }\n            JsonDeserializer<Object> valueDeser = vt.getValueHandler();\n            KeyDeserializer keyDes = (KeyDeserializer) kt.getValueHandler();\n            return new MapEntryDeserializer(type, keyDes, valueDeser, vts);\n        }\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            \n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n            }\n            if (deser != null) {\n                return deser;\n            }\n        }\n        \n        if (rawType == TokenBuffer.class) {\n            return new TokenBufferDeserializer();\n        }\n        JsonDeserializer<?> deser = findOptionalStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n        return JdkDeserializers.find(rawType, clsName);\n    }\n\n    protected JavaType _findRemappedType(DeserializationConfig config, Class<?> rawType) throws JsonMappingException {\n        JavaType type = mapAbstractType(config, config.constructType(rawType));\n        return (type == null || type.hasRawClass(rawType)) ? null : type;\n    }\n\n    \n\n    protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findArrayDeserializer(type, config,\n                    beanDesc, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findBeanDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return (JsonDeserializer<Object>) deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findCollectionDeserializer(type, config, beanDesc,\n                    elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findCollectionLikeDeserializer(type, config, beanDesc,\n                    elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findMapDeserializer(type, config, beanDesc,\n                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findMapLikeDeserializer(type, config, beanDesc,\n                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    \n    \n    \n    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException {\n        Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann);\n        if (deserDef == null) {\n            return null;\n        }\n        return ctxt.deserializerInstance(ann, deserDef);\n    }\n\n    \n    @SuppressWarnings({ \"unchecked\" })\n    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n        \n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        Class<?> subclass = intr.findDeserializationType(a, type);\n        if (subclass != null) {\n            try {\n                type = (T) ctxt.getTypeFactory().constructSpecializedType(type, subclass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n            }\n        }\n\n        \n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                \n                if (!(type instanceof MapLikeType)) {\n                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n                }\n                try {\n                    type = (T) ((MapLikeType) type).narrowKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            JavaType keyType = type.getKeyType();\n            \n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); \n                }\n            }            \n           \n           \n           Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n           if (cc != null) {\n               try {\n                   type = (T) type.narrowContentsBy(cc);\n               } catch (IllegalArgumentException iae) {\n                   throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n               }\n           }\n           \n           JavaType contentType = type.getContentType();\n           if (contentType.getValueHandler() == null) { \n               Object cdDef = intr.findContentDeserializer(a);\n                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n                if (cd != null) {\n                    type = (T) type.withContentValueHandler(cd);\n                }\n            }\n        }\n        return type;\n    }\n    \n    \n    protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException {\n        \n        if (type.isContainerType()) {\n            AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n            JavaType keyType = type.getKeyType();\n            if (keyType != null) {\n                Object kdDef = intr.findKeyDeserializer(member);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); \n                }\n            }\n            \n            Object cdDef = intr.findContentDeserializer(member);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef);\n            if (cd != null) {\n                type = type.withContentValueHandler(cd);\n            }\n            \n            if (member instanceof AnnotatedMember) {\n            \tTypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(\n            \t        ctxt.getConfig(), type, (AnnotatedMember) member);            \t\n            \tif (contentTypeDeser != null) {\n            \t    type = type.withContentTypeHandler(contentTypeDeser);\n            \t}\n            }\n        }\n        TypeDeserializer valueTypeDeser;\n\n        if (member instanceof AnnotatedMember) { \n            valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(),\n                    type, (AnnotatedMember) member);\n        } else { \n            \n            valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), type);\n        }\n        if (valueTypeDeser != null) {\n            type = type.withTypeHandler(valueTypeDeser);\n        }\n        return type;\n    }\n    \n    protected EnumResolver constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMethod jsonValueMethod) {\n        if (jsonValueMethod != null) {\n            Method accessor = jsonValueMethod.getAnnotated();\n            if (config.canOverrideAccessModifiers()) {\n                ClassUtil.checkAndFixAccess(accessor);\n            }\n            return EnumResolver.constructUnsafeUsingMethod(enumClass, accessor);\n        }\n        \n        if (config.isEnabled(DeserializationFeature.READ_ENUMS_USING_TO_STRING)) {\n            return EnumResolver.constructUnsafeUsingToString(enumClass);\n        }\n        return EnumResolver.constructUnsafe(enumClass, config.getAnnotationIntrospector());\n    }\n\n    protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType) {\n        if (enumType == null) {\n            return null;\n        }\n        BeanDescription beanDesc = config.introspect(enumType);\n        return beanDesc.findJsonValueMethod();\n    }\n}\n",
      "buggy_signatures": [
        "protected final DeserializerFactoryConfig _factoryConfig; protected BasicDeserializerFactory(DeserializerFactoryConfig config)",
        "public DeserializerFactoryConfig getFactoryConfig()",
        "protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); @Override public final DeserializerFactory withAdditionalDeserializers(Deserializers additional)",
        "public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional)",
        "public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier)",
        "public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver)",
        "public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators)",
        "public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException",
        "public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException",
        "private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException",
        "protected Map<AnnotatedWithParams,BeanPropertyDefinition[]> _findCreatorsFromProperties(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException",
        "public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException",
        "protected void _addDeserializerConstructors (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException",
        "static inner classes like \" +ctor.getDeclaringClass().getName()+\" can not use @JsonCreator for constructors\"); } throw new IllegalArgumentException(\"Argument #\"+ix +\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\"); } } if (!creators.hasDefaultCreator())",
        "protected void _checkImplicitlyNamedConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, List<AnnotatedConstructor> implicitCtors) throws JsonMappingException",
        "protected boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr, AnnotatedWithParams creator, BeanPropertyDefinition propDef)",
        "protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible) throws JsonMappingException",
        "protected void _addDeserializerFactoryMethods (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException",
        "protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException",
        "protected SettableBeanProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, PropertyName name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException",
        "protected PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr)",
        "protected PropertyName _findImplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)",
        "protected PropertyName _findExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)",
        "protected boolean _hasExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)",
        "public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config)",
        "public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException",
        "public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException",
        "protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException",
        "private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException",
        "public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException",
        "public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException",
        "public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected JavaType _findRemappedType(DeserializationConfig config, Class<?> rawType) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException",
        "protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException",
        "protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException",
        "protected EnumResolver constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMethod jsonValueMethod)",
        "protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType)"
      ],
      "fixed_signatures": [
        "protected final DeserializerFactoryConfig _factoryConfig; protected BasicDeserializerFactory(DeserializerFactoryConfig config)",
        "public DeserializerFactoryConfig getFactoryConfig()",
        "protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); @Override public final DeserializerFactory withAdditionalDeserializers(Deserializers additional)",
        "public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional)",
        "public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier)",
        "public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver)",
        "public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators)",
        "public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException",
        "public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException",
        "private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException",
        "protected Map<AnnotatedWithParams,BeanPropertyDefinition[]> _findCreatorsFromProperties(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException",
        "public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException",
        "protected void _addDeserializerConstructors (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException",
        "static inner classes like \" +ctor.getDeclaringClass().getName()+\" can not use @JsonCreator for constructors\"); } throw new IllegalArgumentException(\"Argument #\"+ix +\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\"); } } if (!creators.hasDefaultCreator())",
        "protected void _checkImplicitlyNamedConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, List<AnnotatedConstructor> implicitCtors) throws JsonMappingException",
        "protected boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr, AnnotatedWithParams creator, BeanPropertyDefinition propDef)",
        "protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible) throws JsonMappingException",
        "protected void _addDeserializerFactoryMethods (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException",
        "protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException",
        "protected SettableBeanProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, PropertyName name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException",
        "protected PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr)",
        "protected PropertyName _findImplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)",
        "protected PropertyName _findExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)",
        "protected boolean _hasExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)",
        "public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config)",
        "public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException",
        "public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException",
        "protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException",
        "private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException",
        "public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException",
        "public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException",
        "public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected JavaType _findRemappedType(DeserializationConfig config, Class<?> rawType) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException",
        "protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException",
        "protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException",
        "protected EnumResolver constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMethod jsonValueMethod)",
        "protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType)"
      ],
      "methods": [
        {
          "buggy_method": "  protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n  \n  AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n  Class<?> subclass = intr.findDeserializationType(a, type);\n  if (subclass != null) {\n  try {\n  type = (T) type.narrowBy(subclass);\n  } catch (IllegalArgumentException iae) {\n  throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n  }\n  }\n\n  \n  if (type.isContainerType()) {\n  Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n  if (keyClass != null) {\n  \n  if (!(type instanceof MapLikeType)) {\n  throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n  }\n  try {\n  type = (T) ((MapLikeType) type).narrowKey(keyClass);\n  } catch (IllegalArgumentException iae) {\n  throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n  }\n  }\n  JavaType keyType = type.getKeyType();\n  \n  if (keyType != null && keyType.getValueHandler() == null) {\n  Object kdDef = intr.findKeyDeserializer(a);\n  KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n  if (kd != null) {\n  type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n  keyType = type.getKeyType(); \n  }\n  }  \n  \n  \n  Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n  if (cc != null) {\n  try {\n  type = (T) type.narrowContentsBy(cc);\n  } catch (IllegalArgumentException iae) {\n  throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n  }\n  }\n  \n  JavaType contentType = type.getContentType();\n  if (contentType.getValueHandler() == null) { \n  Object cdDef = intr.findContentDeserializer(a);\n  JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n  if (cd != null) {\n  type = (T) type.withContentValueHandler(cd);\n  }\n  }\n  }\n  return type;\n  }",
          "fixed_method": "  protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n  \n  AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n  Class<?> subclass = intr.findDeserializationType(a, type);\n  if (subclass != null) {\n  try {\n  type = (T) ctxt.getTypeFactory().constructSpecializedType(type, subclass);\n  } catch (IllegalArgumentException iae) {\n  throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n  }\n  }\n\n  \n  if (type.isContainerType()) {\n  Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n  if (keyClass != null) {\n  \n  if (!(type instanceof MapLikeType)) {\n  throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n  }\n  try {\n  type = (T) ((MapLikeType) type).narrowKey(keyClass);\n  } catch (IllegalArgumentException iae) {\n  throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n  }\n  }\n  JavaType keyType = type.getKeyType();\n  \n  if (keyType != null && keyType.getValueHandler() == null) {\n  Object kdDef = intr.findKeyDeserializer(a);\n  KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n  if (kd != null) {\n  type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n  keyType = type.getKeyType(); \n  }\n  }  \n  \n  \n  Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n  if (cc != null) {\n  try {\n  type = (T) type.narrowContentsBy(cc);\n  } catch (IllegalArgumentException iae) {\n  throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n  }\n  }\n  \n  JavaType contentType = type.getContentType();\n  if (contentType.getValueHandler() == null) { \n  Object cdDef = intr.findContentDeserializer(a);\n  JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n  if (cd != null) {\n  type = (T) type.withContentValueHandler(cd);\n  }\n  }\n  }\n  return type;\n  }",
          "diff": [
            "@@ -1754,7 +1754,7 @@",
            "         Class<?> subclass = intr.findDeserializationType(a, type);\n",
            "         if (subclass != null) {\n",
            "             try {\n",
            "-                type = (T) type.narrowBy(subclass);\n",
            "+                type = (T) ctxt.getTypeFactory().constructSpecializedType(type, subclass);\n",
            "             } catch (IllegalArgumentException iae) {\n",
            "                 throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n",
            "             }\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/deser/DeserializerCache.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.deser;\n\nimport java.util.HashMap;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer;\nimport com.fasterxml.jackson.databind.introspect.Annotated;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.Converter;\n\n\npublic final class DeserializerCache implements java.io.Serializable { private static final long serialVersionUID = 1L; final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _cachedDeserializers = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.75f, 4); final protected HashMap<JavaType, JsonDeserializer<Object>> _incompleteDeserializers = new HashMap<JavaType, JsonDeserializer<Object>>(8); public DeserializerCache() { }\n\n    \n\n    Object writeReplace() {\n        \n        _incompleteDeserializers.clear();\n        \n        return this;\n    }\n    \n    \n\n    \n    public int cachedDeserializersCount() {\n        return _cachedDeserializers.size();\n    }\n\n    \n    public void flushCachedDeserializers() {\n        _cachedDeserializers.clear();       \n    }\n\n    \n\n    \n    public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType propertyType) throws JsonMappingException {\n        JsonDeserializer<Object> deser = _findCachedDeserializer(propertyType);\n        if (deser == null) {\n            \n            deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType);\n            if (deser == null) {\n                \n                deser = _handleUnknownValueDeserializer(propertyType);\n            }\n        }\n        return deser;\n    }\n\n    \n    public KeyDeserializer findKeyDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n        KeyDeserializer kd = factory.createKeyDeserializer(ctxt, type);\n        if (kd == null) { \n            return _handleUnknownKeyDeserializer(type);\n        }\n        \n        if (kd instanceof ResolvableDeserializer) {\n            ((ResolvableDeserializer) kd).resolve(ctxt);\n        }\n        return kd;\n    }\n\n    \n    public boolean hasValueDeserializerFor(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n        \n        JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n        if (deser == null) {\n            deser = _createAndCacheValueDeserializer(ctxt, factory, type);\n        }\n        return (deser != null);\n    }\n\n    \n\n    protected JsonDeserializer<Object> _findCachedDeserializer(JavaType type) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"Null JavaType passed\");\n        }\n        if (_hasCustomValueHandler(type)) {\n            return null;\n        }\n        return _cachedDeserializers.get(type);\n    }\n\n    \n    protected JsonDeserializer<Object> _createAndCacheValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n        \n        synchronized (_incompleteDeserializers) {\n            \n            JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n            if (deser != null) {\n                return deser;\n            }\n            int count = _incompleteDeserializers.size();\n            \n            if (count > 0) {\n                deser = _incompleteDeserializers.get(type);\n                if (deser != null) {\n                    return deser;\n                }\n            }\n            \n            try {\n                return _createAndCache2(ctxt, factory, type);\n            } finally {\n                \n                if (count == 0 && _incompleteDeserializers.size() > 0) {\n                    _incompleteDeserializers.clear();\n                }\n            }\n        }\n    }\n\n    \n    protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n        JsonDeserializer<Object> deser;\n        try {\n            deser = _createDeserializer(ctxt, factory, type);\n        } catch (IllegalArgumentException iae) {\n            \n            throw new JsonMappingException(iae.getMessage(), null, iae);\n        }\n        if (deser == null) {\n            return null;\n        }\n        \n        \n        boolean isResolvable = (deser instanceof ResolvableDeserializer);\n        \n        boolean addToCache = !_hasCustomValueHandler(type) && deser.isCachable();\n\n        \n        \n        \n        if (isResolvable) {\n            _incompleteDeserializers.put(type, deser);\n            ((ResolvableDeserializer)deser).resolve(ctxt);\n            _incompleteDeserializers.remove(type);\n        }\n        if (addToCache) {\n            _cachedDeserializers.put(type, deser);\n        }\n        return deser;\n    }\n\n    \n    \n    \n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n\n        \n        if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) {\n            type = factory.mapAbstractType(config, type);\n        }\n        BeanDescription beanDesc = config.introspect(type);\n        \n        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt,\n                beanDesc.getClassInfo());\n        if (deser != null) {\n            return deser;\n        }\n\n        \n        JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type);\n        if (newType != type) {\n            type = newType;\n            beanDesc = config.introspect(newType);\n        }\n\n        \n        Class<?> builder = beanDesc.findPOJOBuilder();\n        if (builder != null) {\n            return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(\n            \t\tctxt, type, beanDesc, builder);\n        }\n\n        \n        Converter<Object,Object> conv = beanDesc.findDeserializationConverter();\n        if (conv == null) { \n            return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc);\n        }\n        \n        JavaType delegateType = conv.getInputType(ctxt.getTypeFactory());\n        \n        if (!delegateType.hasRawClass(type.getRawClass())) {\n            beanDesc = config.introspect(delegateType);\n        }\n        return new StdDelegatingDeserializer<Object>(conv, delegateType,\n                _createDeserializer2(ctxt, factory, delegateType, beanDesc));\n    }\n\n    protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        if (type.isEnumType()) {\n            return factory.createEnumDeserializer(ctxt, type, beanDesc);\n        }\n        if (type.isContainerType()) {\n            if (type.isArrayType()) {\n                return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc);\n            }\n            if (type.isMapLikeType()) {\n                MapLikeType mlt = (MapLikeType) type;\n                if (mlt.isTrueMapType()) {\n                    return factory.createMapDeserializer(ctxt,(MapType) mlt, beanDesc);\n                }\n                return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc);\n            }\n            if (type.isCollectionLikeType()) {\n                \n                JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n                if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) {\n                    CollectionLikeType clt = (CollectionLikeType) type;\n                    if (clt.isTrueCollectionType()) {\n                        return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc);\n                    }\n                    return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc);\n                }\n            }\n        }\n        if (JsonNode.class.isAssignableFrom(type.getRawClass())) {\n            return factory.createTreeDeserializer(config, type, beanDesc);\n        }\n        return factory.createBeanDeserializer(ctxt, type, beanDesc);\n    }\n\n    \n    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException {\n        Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann);\n        if (deserDef == null) {\n            return null;\n        }\n        JsonDeserializer<Object> deser = ctxt.deserializerInstance(ann, deserDef);\n        \n        return findConvertingDeserializer(ctxt, ann, deser);\n    }\n\n    \n    protected JsonDeserializer<Object> findConvertingDeserializer(DeserializationContext ctxt, Annotated a, JsonDeserializer<Object> deser) throws JsonMappingException {\n        Converter<Object,Object> conv = findConverter(ctxt, a);\n        if (conv == null) {\n            return deser;\n        }\n        JavaType delegateType = conv.getInputType(ctxt.getTypeFactory());\n        return (JsonDeserializer<Object>) new StdDelegatingDeserializer<Object>(conv, delegateType, deser);\n    }\n\n    protected Converter<Object,Object> findConverter(DeserializationContext ctxt, Annotated a) throws JsonMappingException {\n        Object convDef = ctxt.getAnnotationIntrospector().findDeserializationConverter(a);\n        if (convDef == null) {\n            return null;\n        }\n        return ctxt.converterInstance(a, convDef);\n    }    \n    \n    private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n        \n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        Class<?> subclass = intr.findDeserializationType(a, type);\n        if (subclass != null) {\n            try {\n                type = type.narrowBy(subclass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n            }\n        }\n\n        \n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                \n                if (!(type instanceof MapLikeType)) {\n                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n                }\n                try {\n                    type = ((MapLikeType) type).narrowKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            JavaType keyType = type.getKeyType();\n            \n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                if (kdDef != null) {\n                    KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                    if (kd != null) {\n                        type = ((MapLikeType) type).withKeyValueHandler(kd);\n                        keyType = type.getKeyType(); \n                    }\n                }\n            }            \n            \n            \n            Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n            if (cc != null) {\n                try {\n                    type = type.narrowContentsBy(cc);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            \n            JavaType contentType = type.getContentType();\n            if (contentType.getValueHandler() == null) { \n                Object cdDef = intr.findContentDeserializer(a);\n                if (cdDef != null) {\n                    JsonDeserializer<?> cd = null;\n                    if (cdDef instanceof JsonDeserializer<?>) {\n                        cdDef = (JsonDeserializer<?>) cdDef;\n                    } else {\n                        Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                        if (cdClass != null) {\n                            cd = ctxt.deserializerInstance(a, cdClass);\n                        }\n                    }\n                    if (cd != null) {\n                        type = type.withContentValueHandler(cd);\n                    }\n                }\n            }\n        }\n        return type;\n    }\n\n    \n\n    \n    private boolean _hasCustomValueHandler(JavaType t) {\n        if (t.isContainerType()) {\n            JavaType ct = t.getContentType();\n            if (ct != null) {\n                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n            }\n        }\n        return false;\n    }\n\n    private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) {\n        if (src == null) {\n            return null;\n        }\n        if (!(src instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\");\n        }\n        Class<?> cls = (Class<?>) src;\n        if (cls == noneClass || ClassUtil.isBogusClass(cls)) {\n            return null;\n        }\n        return cls;\n    }\n\n    \n\n    protected JsonDeserializer<Object> _handleUnknownValueDeserializer(JavaType type) throws JsonMappingException {\n        \n        Class<?> rawClass = type.getRawClass();\n        if (!ClassUtil.isConcrete(rawClass)) {\n            throw new JsonMappingException(\"Can not find a Value deserializer for abstract type \"+type); } throw new JsonMappingException(\"Can not find a Value deserializer for type \"+type); } protected KeyDeserializer _handleUnknownKeyDeserializer(JavaType type) throws JsonMappingException {\n        throw new JsonMappingException(\"Can not find a (Map) Key deserializer for type \"+type);\n    }\n\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.deser;\n\nimport java.util.HashMap;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer;\nimport com.fasterxml.jackson.databind.introspect.Annotated;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.Converter;\n\n\npublic final class DeserializerCache implements java.io.Serializable { private static final long serialVersionUID = 1L; final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _cachedDeserializers = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.75f, 4); final protected HashMap<JavaType, JsonDeserializer<Object>> _incompleteDeserializers = new HashMap<JavaType, JsonDeserializer<Object>>(8); public DeserializerCache() { }\n\n    \n\n    Object writeReplace() {\n        \n        _incompleteDeserializers.clear();\n        \n        return this;\n    }\n    \n    \n\n    \n    public int cachedDeserializersCount() {\n        return _cachedDeserializers.size();\n    }\n\n    \n    public void flushCachedDeserializers() {\n        _cachedDeserializers.clear();       \n    }\n\n    \n\n    \n    public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType propertyType) throws JsonMappingException {\n        JsonDeserializer<Object> deser = _findCachedDeserializer(propertyType);\n        if (deser == null) {\n            \n            deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType);\n            if (deser == null) {\n                \n                deser = _handleUnknownValueDeserializer(propertyType);\n            }\n        }\n        return deser;\n    }\n\n    \n    public KeyDeserializer findKeyDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n        KeyDeserializer kd = factory.createKeyDeserializer(ctxt, type);\n        if (kd == null) { \n            return _handleUnknownKeyDeserializer(type);\n        }\n        \n        if (kd instanceof ResolvableDeserializer) {\n            ((ResolvableDeserializer) kd).resolve(ctxt);\n        }\n        return kd;\n    }\n\n    \n    public boolean hasValueDeserializerFor(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n        \n        JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n        if (deser == null) {\n            deser = _createAndCacheValueDeserializer(ctxt, factory, type);\n        }\n        return (deser != null);\n    }\n\n    \n\n    protected JsonDeserializer<Object> _findCachedDeserializer(JavaType type) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"Null JavaType passed\");\n        }\n        if (_hasCustomValueHandler(type)) {\n            return null;\n        }\n        return _cachedDeserializers.get(type);\n    }\n\n    \n    protected JsonDeserializer<Object> _createAndCacheValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n        \n        synchronized (_incompleteDeserializers) {\n            \n            JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n            if (deser != null) {\n                return deser;\n            }\n            int count = _incompleteDeserializers.size();\n            \n            if (count > 0) {\n                deser = _incompleteDeserializers.get(type);\n                if (deser != null) {\n                    return deser;\n                }\n            }\n            \n            try {\n                return _createAndCache2(ctxt, factory, type);\n            } finally {\n                \n                if (count == 0 && _incompleteDeserializers.size() > 0) {\n                    _incompleteDeserializers.clear();\n                }\n            }\n        }\n    }\n\n    \n    protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n        JsonDeserializer<Object> deser;\n        try {\n            deser = _createDeserializer(ctxt, factory, type);\n        } catch (IllegalArgumentException iae) {\n            \n            throw new JsonMappingException(iae.getMessage(), null, iae);\n        }\n        if (deser == null) {\n            return null;\n        }\n        \n        \n        boolean isResolvable = (deser instanceof ResolvableDeserializer);\n        \n        boolean addToCache = !_hasCustomValueHandler(type) && deser.isCachable();\n\n        \n        \n        \n        if (isResolvable) {\n            _incompleteDeserializers.put(type, deser);\n            ((ResolvableDeserializer)deser).resolve(ctxt);\n            _incompleteDeserializers.remove(type);\n        }\n        if (addToCache) {\n            _cachedDeserializers.put(type, deser);\n        }\n        return deser;\n    }\n\n    \n    \n    \n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n\n        \n        if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) {\n            type = factory.mapAbstractType(config, type);\n        }\n        BeanDescription beanDesc = config.introspect(type);\n        \n        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt,\n                beanDesc.getClassInfo());\n        if (deser != null) {\n            return deser;\n        }\n\n        \n        JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type);\n        if (newType != type) {\n            type = newType;\n            beanDesc = config.introspect(newType);\n        }\n\n        \n        Class<?> builder = beanDesc.findPOJOBuilder();\n        if (builder != null) {\n            return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(\n            \t\tctxt, type, beanDesc, builder);\n        }\n\n        \n        Converter<Object,Object> conv = beanDesc.findDeserializationConverter();\n        if (conv == null) { \n            return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc);\n        }\n        \n        JavaType delegateType = conv.getInputType(ctxt.getTypeFactory());\n        \n        if (!delegateType.hasRawClass(type.getRawClass())) {\n            beanDesc = config.introspect(delegateType);\n        }\n        return new StdDelegatingDeserializer<Object>(conv, delegateType,\n                _createDeserializer2(ctxt, factory, delegateType, beanDesc));\n    }\n\n    protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        if (type.isEnumType()) {\n            return factory.createEnumDeserializer(ctxt, type, beanDesc);\n        }\n        if (type.isContainerType()) {\n            if (type.isArrayType()) {\n                return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc);\n            }\n            if (type.isMapLikeType()) {\n                MapLikeType mlt = (MapLikeType) type;\n                if (mlt.isTrueMapType()) {\n                    return factory.createMapDeserializer(ctxt,(MapType) mlt, beanDesc);\n                }\n                return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc);\n            }\n            if (type.isCollectionLikeType()) {\n                \n                JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n                if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) {\n                    CollectionLikeType clt = (CollectionLikeType) type;\n                    if (clt.isTrueCollectionType()) {\n                        return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc);\n                    }\n                    return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc);\n                }\n            }\n        }\n        if (JsonNode.class.isAssignableFrom(type.getRawClass())) {\n            return factory.createTreeDeserializer(config, type, beanDesc);\n        }\n        return factory.createBeanDeserializer(ctxt, type, beanDesc);\n    }\n\n    \n    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException {\n        Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann);\n        if (deserDef == null) {\n            return null;\n        }\n        JsonDeserializer<Object> deser = ctxt.deserializerInstance(ann, deserDef);\n        \n        return findConvertingDeserializer(ctxt, ann, deser);\n    }\n\n    \n    protected JsonDeserializer<Object> findConvertingDeserializer(DeserializationContext ctxt, Annotated a, JsonDeserializer<Object> deser) throws JsonMappingException {\n        Converter<Object,Object> conv = findConverter(ctxt, a);\n        if (conv == null) {\n            return deser;\n        }\n        JavaType delegateType = conv.getInputType(ctxt.getTypeFactory());\n        return (JsonDeserializer<Object>) new StdDelegatingDeserializer<Object>(conv, delegateType, deser);\n    }\n\n    protected Converter<Object,Object> findConverter(DeserializationContext ctxt, Annotated a) throws JsonMappingException {\n        Object convDef = ctxt.getAnnotationIntrospector().findDeserializationConverter(a);\n        if (convDef == null) {\n            return null;\n        }\n        return ctxt.converterInstance(a, convDef);\n    }    \n    \n    private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n        \n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        Class<?> subclass = intr.findDeserializationType(a, type);\n        if (subclass != null) {\n            try {\n                type = ctxt.getTypeFactory().constructSpecializedType(type, subclass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n            }\n        }\n\n        \n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                \n                if (!(type instanceof MapLikeType)) {\n                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n                }\n                try {\n                    type = ((MapLikeType) type).narrowKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            JavaType keyType = type.getKeyType();\n            \n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                if (kdDef != null) {\n                    KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                    if (kd != null) {\n                        type = ((MapLikeType) type).withKeyValueHandler(kd);\n                        keyType = type.getKeyType(); \n                    }\n                }\n            }            \n            \n            \n            Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n            if (cc != null) {\n                try {\n                    type = type.narrowContentsBy(cc);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            \n            JavaType contentType = type.getContentType();\n            if (contentType.getValueHandler() == null) { \n                Object cdDef = intr.findContentDeserializer(a);\n                if (cdDef != null) {\n                    JsonDeserializer<?> cd = null;\n                    if (cdDef instanceof JsonDeserializer<?>) {\n                        cdDef = (JsonDeserializer<?>) cdDef;\n                    } else {\n                        Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                        if (cdClass != null) {\n                            cd = ctxt.deserializerInstance(a, cdClass);\n                        }\n                    }\n                    if (cd != null) {\n                        type = type.withContentValueHandler(cd);\n                    }\n                }\n            }\n        }\n        return type;\n    }\n\n    \n\n    \n    private boolean _hasCustomValueHandler(JavaType t) {\n        if (t.isContainerType()) {\n            JavaType ct = t.getContentType();\n            if (ct != null) {\n                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n            }\n        }\n        return false;\n    }\n\n    private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) {\n        if (src == null) {\n            return null;\n        }\n        if (!(src instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\");\n        }\n        Class<?> cls = (Class<?>) src;\n        if (cls == noneClass || ClassUtil.isBogusClass(cls)) {\n            return null;\n        }\n        return cls;\n    }\n\n    \n\n    protected JsonDeserializer<Object> _handleUnknownValueDeserializer(JavaType type) throws JsonMappingException {\n        \n        Class<?> rawClass = type.getRawClass();\n        if (!ClassUtil.isConcrete(rawClass)) {\n            throw new JsonMappingException(\"Can not find a Value deserializer for abstract type \"+type); } throw new JsonMappingException(\"Can not find a Value deserializer for type \"+type); } protected KeyDeserializer _handleUnknownKeyDeserializer(JavaType type) throws JsonMappingException {\n        throw new JsonMappingException(\"Can not find a (Map) Key deserializer for type \"+type);\n    }\n\n}\n",
      "buggy_signatures": [
        "public int cachedDeserializersCount()",
        "public void flushCachedDeserializers()",
        "public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType propertyType) throws JsonMappingException",
        "public KeyDeserializer findKeyDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException",
        "public boolean hasValueDeserializerFor(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException",
        "protected JsonDeserializer<Object> _findCachedDeserializer(JavaType type)",
        "protected JsonDeserializer<Object> _createAndCacheValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException",
        "synchronized (_incompleteDeserializers)",
        "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException",
        "protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException",
        "protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException",
        "protected JsonDeserializer<Object> findConvertingDeserializer(DeserializationContext ctxt, Annotated a, JsonDeserializer<Object> deser) throws JsonMappingException",
        "protected Converter<Object,Object> findConverter(DeserializationContext ctxt, Annotated a) throws JsonMappingException",
        "private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException",
        "private boolean _hasCustomValueHandler(JavaType t)",
        "private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass)",
        "protected JsonDeserializer<Object> _handleUnknownValueDeserializer(JavaType type) throws JsonMappingException",
        "abstract type \"+type); } throw new JsonMappingException(\"Can not find a Value deserializer for type \"+type); } protected KeyDeserializer _handleUnknownKeyDeserializer(JavaType type) throws JsonMappingException"
      ],
      "fixed_signatures": [
        "public int cachedDeserializersCount()",
        "public void flushCachedDeserializers()",
        "public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType propertyType) throws JsonMappingException",
        "public KeyDeserializer findKeyDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException",
        "public boolean hasValueDeserializerFor(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException",
        "protected JsonDeserializer<Object> _findCachedDeserializer(JavaType type)",
        "protected JsonDeserializer<Object> _createAndCacheValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException",
        "synchronized (_incompleteDeserializers)",
        "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException",
        "protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException",
        "protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException",
        "protected JsonDeserializer<Object> findConvertingDeserializer(DeserializationContext ctxt, Annotated a, JsonDeserializer<Object> deser) throws JsonMappingException",
        "protected Converter<Object,Object> findConverter(DeserializationContext ctxt, Annotated a) throws JsonMappingException",
        "private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException",
        "private boolean _hasCustomValueHandler(JavaType t)",
        "private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass)",
        "protected JsonDeserializer<Object> _handleUnknownValueDeserializer(JavaType type) throws JsonMappingException",
        "abstract type \"+type); } throw new JsonMappingException(\"Can not find a Value deserializer for type \"+type); } protected KeyDeserializer _handleUnknownKeyDeserializer(JavaType type) throws JsonMappingException"
      ],
      "methods": [
        {
          "buggy_method": "  private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n  \n  AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n  Class<?> subclass = intr.findDeserializationType(a, type);\n  if (subclass != null) {\n  try {\n  type = type.narrowBy(subclass);\n  } catch (IllegalArgumentException iae) {\n  throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n  }\n  }\n\n  \n  if (type.isContainerType()) {\n  Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n  if (keyClass != null) {\n  \n  if (!(type instanceof MapLikeType)) {\n  throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n  }\n  try {\n  type = ((MapLikeType) type).narrowKey(keyClass);\n  } catch (IllegalArgumentException iae) {\n  throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n  }\n  }\n  JavaType keyType = type.getKeyType();\n  \n  if (keyType != null && keyType.getValueHandler() == null) {\n  Object kdDef = intr.findKeyDeserializer(a);\n  if (kdDef != null) {\n  KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n  if (kd != null) {\n  type = ((MapLikeType) type).withKeyValueHandler(kd);\n  keyType = type.getKeyType(); \n  }\n  }\n  }  \n  \n  \n  Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n  if (cc != null) {\n  try {\n  type = type.narrowContentsBy(cc);\n  } catch (IllegalArgumentException iae) {\n  throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n  }\n  }\n  \n  JavaType contentType = type.getContentType();\n  if (contentType.getValueHandler() == null) { \n  Object cdDef = intr.findContentDeserializer(a);\n  if (cdDef != null) {\n  JsonDeserializer<?> cd = null;\n  if (cdDef instanceof JsonDeserializer<?>) {\n  cdDef = (JsonDeserializer<?>) cdDef;\n  } else {\n  Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n  if (cdClass != null) {\n  cd = ctxt.deserializerInstance(a, cdClass);\n  }\n  }\n  if (cd != null) {\n  type = type.withContentValueHandler(cd);\n  }\n  }\n  }\n  }\n  return type;\n  }",
          "fixed_method": "  private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n  \n  AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n  Class<?> subclass = intr.findDeserializationType(a, type);\n  if (subclass != null) {\n  try {\n  type = ctxt.getTypeFactory().constructSpecializedType(type, subclass);\n  } catch (IllegalArgumentException iae) {\n  throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n  }\n  }\n\n  \n  if (type.isContainerType()) {\n  Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n  if (keyClass != null) {\n  \n  if (!(type instanceof MapLikeType)) {\n  throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n  }\n  try {\n  type = ((MapLikeType) type).narrowKey(keyClass);\n  } catch (IllegalArgumentException iae) {\n  throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n  }\n  }\n  JavaType keyType = type.getKeyType();\n  \n  if (keyType != null && keyType.getValueHandler() == null) {\n  Object kdDef = intr.findKeyDeserializer(a);\n  if (kdDef != null) {\n  KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n  if (kd != null) {\n  type = ((MapLikeType) type).withKeyValueHandler(kd);\n  keyType = type.getKeyType(); \n  }\n  }\n  }  \n  \n  \n  Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n  if (cc != null) {\n  try {\n  type = type.narrowContentsBy(cc);\n  } catch (IllegalArgumentException iae) {\n  throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n  }\n  }\n  \n  JavaType contentType = type.getContentType();\n  if (contentType.getValueHandler() == null) { \n  Object cdDef = intr.findContentDeserializer(a);\n  if (cdDef != null) {\n  JsonDeserializer<?> cd = null;\n  if (cdDef instanceof JsonDeserializer<?>) {\n  cdDef = (JsonDeserializer<?>) cdDef;\n  } else {\n  Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n  if (cdClass != null) {\n  cd = ctxt.deserializerInstance(a, cdClass);\n  }\n  }\n  if (cd != null) {\n  type = type.withContentValueHandler(cd);\n  }\n  }\n  }\n  }\n  return type;\n  }",
          "diff": [
            "@@ -474,7 +474,7 @@",
            "         Class<?> subclass = intr.findDeserializationType(a, type);\n",
            "         if (subclass != null) {\n",
            "             try {\n",
            "-                type = type.narrowBy(subclass);\n",
            "+                type = ctxt.getTypeFactory().constructSpecializedType(type, subclass);\n",
            "             } catch (IllegalArgumentException iae) {\n",
            "                 throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n",
            "             }\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.BeanProperty;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonDeserializer;\nimport com.fasterxml.jackson.databind.deser.std.NullifyingDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\npublic abstract class TypeDeserializerBase extends TypeDeserializer implements java.io.Serializable { private static final long serialVersionUID = 1; protected final TypeIdResolver _idResolver; protected final JavaType _baseType; protected final BeanProperty _property; protected final JavaType _defaultImpl; protected final String _typePropertyName; protected final boolean _typeIdVisible; protected final Map<String,JsonDeserializer<Object>> _deserializers; protected JsonDeserializer<Object> _defaultImplDeserializer; protected TypeDeserializerBase(JavaType baseType, TypeIdResolver idRes, String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl) {\n        _baseType = baseType;\n        _idResolver = idRes;\n        _typePropertyName = typePropertyName;\n        _typeIdVisible = typeIdVisible;\n        \n        _deserializers = new ConcurrentHashMap<String, JsonDeserializer<Object>>(16, 0.75f, 4);\n        if (defaultImpl == null) {\n            _defaultImpl = null;\n        } else {\n            \n            _defaultImpl = baseType.forcedNarrowBy(defaultImpl);\n        }\n        _property = null;\n    }\n\n    protected TypeDeserializerBase(TypeDeserializerBase src, BeanProperty property) {\n        _baseType = src._baseType;\n        _idResolver = src._idResolver;\n        _typePropertyName = src._typePropertyName;\n        _typeIdVisible = src._typeIdVisible;\n        _deserializers = src._deserializers;\n        _defaultImpl = src._defaultImpl;\n        _defaultImplDeserializer = src._defaultImplDeserializer;\n        _property = property;\n    }\n\n    @Override\n    public abstract TypeDeserializer forProperty(BeanProperty prop); @Override public abstract JsonTypeInfo.As getTypeInclusion(); public String baseTypeName() { return _baseType.getRawClass().getName(); }\n\n    @Override\n    public final String getPropertyName() { return _typePropertyName; }\n    \n    @Override    \n    public TypeIdResolver getTypeIdResolver() { return _idResolver; }\n\n    @Override    \n    public Class<?> getDefaultImpl() {\n        return (_defaultImpl == null) ? null : _defaultImpl.getRawClass();\n    }\n    \n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append('[').append(getClass().getName());\n        sb.append(\"; base-type:\").append(_baseType);\n        sb.append(\"; id-resolver: \").append(_idResolver);\n    \t    sb.append(']');\n    \t    return sb.toString();\n    }\n    \n    \n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n        JsonDeserializer<Object> deser = _deserializers.get(typeId);\n        if (deser == null) {\n            \n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                \n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                }\n            } else {\n                \n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n                    \n                    type = _baseType.narrowBy(type.getRawClass());\n                }\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            }\n            _deserializers.put(typeId, deser);\n        }\n        return deser;\n    }\n\n    protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException {\n        \n        if (_defaultImpl == null) {\n            if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) {\n                return NullifyingDeserializer.instance;\n            }\n            return null;\n        }\n        Class<?> raw = _defaultImpl.getRawClass();\n        if (ClassUtil.isBogusClass(raw)) {\n            return NullifyingDeserializer.instance;\n        }\n        \n        synchronized (_defaultImpl) {\n            if (_defaultImplDeserializer == null) {\n                _defaultImplDeserializer = ctxt.findContextualValueDeserializer(\n                        _defaultImpl, _property);\n            }\n            return _defaultImplDeserializer;\n        }\n    }\n\n    \n    @Deprecated\n    protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        return _deserializeWithNativeTypeId(jp, ctxt, jp.getTypeId());\n    }\n\n    \n    protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt, Object typeId) throws IOException {\n        JsonDeserializer<Object> deser;\n        if (typeId == null) {\n            \n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                throw ctxt.mappingException(\"No (native) type id found when one was expected for polymorphic type handling\"); } } else { String typeIdStr = (typeId instanceof String) ? (String) typeId : String.valueOf(typeId); deser = _findDeserializer(ctxt, typeIdStr); } return deser.deserialize(jp, ctxt); } protected JsonDeserializer<Object> _handleUnknownTypeId(DeserializationContext ctxt, String typeId, TypeIdResolver idResolver, JavaType baseType) throws IOException { String extraDesc; if (idResolver instanceof TypeIdResolverBase) { extraDesc = ((TypeIdResolverBase) idResolver).getDescForKnownTypeIds(); if (extraDesc == null) {\n                extraDesc = \"known type ids are not statically known\";\n            } else {\n                extraDesc = \"known type ids = \" + extraDesc;\n            }\n        } else {\n            extraDesc = null;\n        }\n        throw ctxt.unknownTypeException(_baseType, typeId, extraDesc);\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.BeanProperty;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonDeserializer;\nimport com.fasterxml.jackson.databind.deser.std.NullifyingDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\npublic abstract class TypeDeserializerBase extends TypeDeserializer implements java.io.Serializable { private static final long serialVersionUID = 1; protected final TypeIdResolver _idResolver; protected final JavaType _baseType; protected final BeanProperty _property; protected final JavaType _defaultImpl; protected final String _typePropertyName; protected final boolean _typeIdVisible; protected final Map<String,JsonDeserializer<Object>> _deserializers; protected JsonDeserializer<Object> _defaultImplDeserializer; protected TypeDeserializerBase(JavaType baseType, TypeIdResolver idRes, String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl) {\n        _baseType = baseType;\n        _idResolver = idRes;\n        _typePropertyName = typePropertyName;\n        _typeIdVisible = typeIdVisible;\n        \n        _deserializers = new ConcurrentHashMap<String, JsonDeserializer<Object>>(16, 0.75f, 4);\n        if (defaultImpl == null) {\n            _defaultImpl = null;\n        } else {\n            \n            _defaultImpl = baseType.forcedNarrowBy(defaultImpl);\n        }\n        _property = null;\n    }\n\n    protected TypeDeserializerBase(TypeDeserializerBase src, BeanProperty property) {\n        _baseType = src._baseType;\n        _idResolver = src._idResolver;\n        _typePropertyName = src._typePropertyName;\n        _typeIdVisible = src._typeIdVisible;\n        _deserializers = src._deserializers;\n        _defaultImpl = src._defaultImpl;\n        _defaultImplDeserializer = src._defaultImplDeserializer;\n        _property = property;\n    }\n\n    @Override\n    public abstract TypeDeserializer forProperty(BeanProperty prop); @Override public abstract JsonTypeInfo.As getTypeInclusion(); public String baseTypeName() { return _baseType.getRawClass().getName(); }\n\n    @Override\n    public final String getPropertyName() { return _typePropertyName; }\n    \n    @Override    \n    public TypeIdResolver getTypeIdResolver() { return _idResolver; }\n\n    @Override    \n    public Class<?> getDefaultImpl() {\n        return (_defaultImpl == null) ? null : _defaultImpl.getRawClass();\n    }\n    \n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append('[').append(getClass().getName());\n        sb.append(\"; base-type:\").append(_baseType);\n        sb.append(\"; id-resolver: \").append(_idResolver);\n    \t    sb.append(']');\n    \t    return sb.toString();\n    }\n    \n    \n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n        JsonDeserializer<Object> deser = _deserializers.get(typeId);\n        if (deser == null) {\n            \n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                \n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                }\n            } else {\n                \n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n                    \n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            }\n            _deserializers.put(typeId, deser);\n        }\n        return deser;\n    }\n\n    protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException {\n        \n        if (_defaultImpl == null) {\n            if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) {\n                return NullifyingDeserializer.instance;\n            }\n            return null;\n        }\n        Class<?> raw = _defaultImpl.getRawClass();\n        if (ClassUtil.isBogusClass(raw)) {\n            return NullifyingDeserializer.instance;\n        }\n        \n        synchronized (_defaultImpl) {\n            if (_defaultImplDeserializer == null) {\n                _defaultImplDeserializer = ctxt.findContextualValueDeserializer(\n                        _defaultImpl, _property);\n            }\n            return _defaultImplDeserializer;\n        }\n    }\n\n    \n    @Deprecated\n    protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        return _deserializeWithNativeTypeId(jp, ctxt, jp.getTypeId());\n    }\n\n    \n    protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt, Object typeId) throws IOException {\n        JsonDeserializer<Object> deser;\n        if (typeId == null) {\n            \n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                throw ctxt.mappingException(\"No (native) type id found when one was expected for polymorphic type handling\"); } } else { String typeIdStr = (typeId instanceof String) ? (String) typeId : String.valueOf(typeId); deser = _findDeserializer(ctxt, typeIdStr); } return deser.deserialize(jp, ctxt); } protected JsonDeserializer<Object> _handleUnknownTypeId(DeserializationContext ctxt, String typeId, TypeIdResolver idResolver, JavaType baseType) throws IOException { String extraDesc; if (idResolver instanceof TypeIdResolverBase) { extraDesc = ((TypeIdResolverBase) idResolver).getDescForKnownTypeIds(); if (extraDesc == null) {\n                extraDesc = \"known type ids are not statically known\";\n            } else {\n                extraDesc = \"known type ids = \" + extraDesc;\n            }\n        } else {\n            extraDesc = null;\n        }\n        throw ctxt.unknownTypeException(_baseType, typeId, extraDesc);\n    }\n}\n",
      "buggy_signatures": [
        "protected TypeDeserializerBase(TypeDeserializerBase src, BeanProperty property)",
        "public abstract TypeDeserializer forProperty(BeanProperty prop); @Override public abstract JsonTypeInfo.As getTypeInclusion(); public String baseTypeName()",
        "public final String getPropertyName()",
        "public TypeIdResolver getTypeIdResolver()",
        "public Class<?> getDefaultImpl()",
        "public String toString()",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException",
        "protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException",
        "synchronized (_defaultImpl)",
        "protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt, Object typeId) throws IOException"
      ],
      "fixed_signatures": [
        "protected TypeDeserializerBase(TypeDeserializerBase src, BeanProperty property)",
        "public abstract TypeDeserializer forProperty(BeanProperty prop); @Override public abstract JsonTypeInfo.As getTypeInclusion(); public String baseTypeName()",
        "public final String getPropertyName()",
        "public TypeIdResolver getTypeIdResolver()",
        "public Class<?> getDefaultImpl()",
        "public String toString()",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException",
        "protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException",
        "synchronized (_defaultImpl)",
        "protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt, Object typeId) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n  JsonDeserializer<Object> deser = _deserializers.get(typeId);\n  if (deser == null) {\n  \n  JavaType type = _idResolver.typeFromId(ctxt, typeId);\n  if (type == null) {\n  \n  deser = _findDefaultImplDeserializer(ctxt);\n  if (deser == null) {\n  deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n  }\n  } else {\n  \n  if ((_baseType != null)\n  && _baseType.getClass() == type.getClass()) {\n  \n  type = _baseType.narrowBy(type.getRawClass());\n  }\n  deser = ctxt.findContextualValueDeserializer(type, _property);\n  }\n  _deserializers.put(typeId, deser);\n  }\n  return deser;\n  }",
          "fixed_method": "  protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n  JsonDeserializer<Object> deser = _deserializers.get(typeId);\n  if (deser == null) {\n  \n  JavaType type = _idResolver.typeFromId(ctxt, typeId);\n  if (type == null) {\n  \n  deser = _findDefaultImplDeserializer(ctxt);\n  if (deser == null) {\n  deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n  }\n  } else {\n  \n  if ((_baseType != null)\n  && _baseType.getClass() == type.getClass()) {\n  \n  type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n  }\n  deser = ctxt.findContextualValueDeserializer(type, _property);\n  }\n  _deserializers.put(typeId, deser);\n  }\n  return deser;\n  }",
          "diff": [
            "@@ -174,7 +174,7 @@",
            "                      *   important for some reason?\n",
            "                      *   Disabling the check will break 2 Enum-related tests.\n",
            "                      */\n",
            "-                    type = _baseType.narrowBy(type.getRawClass());\n",
            "+                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n",
            "                 }\n",
            "                 deser = ctxt.findContextualValueDeserializer(type, _property);\n",
            "             }\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.module;\n\nimport java.lang.reflect.Modifier;\nimport java.util.*;\n\n\nimport com.fasterxml.jackson.databind.AbstractTypeResolver;\nimport com.fasterxml.jackson.databind.DeserializationConfig;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.type.ClassKey;\n\n\npublic class SimpleAbstractTypeResolver extends AbstractTypeResolver implements java.io.Serializable { private static final long serialVersionUID = 8635483102371490919L; protected final HashMap<ClassKey,Class<?>> _mappings = new HashMap<ClassKey,Class<?>>(); public <T> SimpleAbstractTypeResolver addMapping(Class<T> superType, Class<? extends T> subType) {\n        \n        if (superType == subType) {\n            throw new IllegalArgumentException(\"Can not add mapping from class to itself\");\n        }\n        if (!superType.isAssignableFrom(subType)) {\n            throw new IllegalArgumentException(\"Can not add mapping from class \"+superType.getName()\n                    +\" to \"+subType.getName()+\", as latter is not a subtype of former\");\n        }\n        if (!Modifier.isAbstract(superType.getModifiers())) {\n            throw new IllegalArgumentException(\"Can not add mapping from class \"+superType.getName()\n                    +\" since it is not abstract\"); } _mappings.put(new ClassKey(superType), subType); return this; } @Override public JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n        \n        Class<?> src = type.getRawClass();\n        Class<?> dst = _mappings.get(new ClassKey(src));\n        if (dst == null) {\n            return null;\n        }\n        \n        return type.narrowBy(dst);\n    }\n\n    \n    @Override\n    public JavaType resolveAbstractType(DeserializationConfig config, JavaType type) {\n        \n        return null;\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.module;\n\nimport java.lang.reflect.Modifier;\nimport java.util.*;\n\n\nimport com.fasterxml.jackson.databind.AbstractTypeResolver;\nimport com.fasterxml.jackson.databind.DeserializationConfig;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.type.ClassKey;\n\n\npublic class SimpleAbstractTypeResolver extends AbstractTypeResolver implements java.io.Serializable { private static final long serialVersionUID = 8635483102371490919L; protected final HashMap<ClassKey,Class<?>> _mappings = new HashMap<ClassKey,Class<?>>(); public <T> SimpleAbstractTypeResolver addMapping(Class<T> superType, Class<? extends T> subType) {\n        \n        if (superType == subType) {\n            throw new IllegalArgumentException(\"Can not add mapping from class to itself\");\n        }\n        if (!superType.isAssignableFrom(subType)) {\n            throw new IllegalArgumentException(\"Can not add mapping from class \"+superType.getName()\n                    +\" to \"+subType.getName()+\", as latter is not a subtype of former\");\n        }\n        if (!Modifier.isAbstract(superType.getModifiers())) {\n            throw new IllegalArgumentException(\"Can not add mapping from class \"+superType.getName()\n                    +\" since it is not abstract\"); } _mappings.put(new ClassKey(superType), subType); return this; } @Override public JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n        \n        Class<?> src = type.getRawClass();\n        Class<?> dst = _mappings.get(new ClassKey(src));\n        if (dst == null) {\n            return null;\n        }\n        \n        return config.getTypeFactory().constructSpecializedType(type, dst);\n    }\n\n    \n    @Override\n    public JavaType resolveAbstractType(DeserializationConfig config, JavaType type) {\n        \n        return null;\n    }\n}\n",
      "buggy_signatures": [
        "abstract\"); } _mappings.put(new ClassKey(superType), subType); return this; } @Override public JavaType findTypeMapping(DeserializationConfig config, JavaType type)",
        "public JavaType resolveAbstractType(DeserializationConfig config, JavaType type)"
      ],
      "fixed_signatures": [
        "abstract\"); } _mappings.put(new ClassKey(superType), subType); return this; } @Override public JavaType findTypeMapping(DeserializationConfig config, JavaType type)",
        "public JavaType resolveAbstractType(DeserializationConfig config, JavaType type)"
      ],
      "methods": [
        {
          "buggy_method": "  public JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n  \n  Class<?> src = type.getRawClass();\n  Class<?> dst = _mappings.get(new ClassKey(src));\n  if (dst == null) {\n  return null;\n  }\n  \n  return type.narrowBy(dst);\n  }",
          "fixed_method": "  public JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n  \n  Class<?> src = type.getRawClass();\n  Class<?> dst = _mappings.get(new ClassKey(src));\n  if (dst == null) {\n  return null;\n  }\n  \n  return config.getTypeFactory().constructSpecializedType(type, dst);\n  }",
          "diff": [
            "@@ -77,7 +77,7 @@",
            "             return null;\n",
            "         }\n",
            "         // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n",
            "-        return type.narrowBy(dst);\n",
            "+        return config.getTypeFactory().constructSpecializedType(type, dst);\n",
            "     }\n",
            " \n",
            "     \n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
