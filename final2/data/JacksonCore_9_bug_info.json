{
  "bug_id": "9",
  "failed_tests": {
    "com.fasterxml.jackson.core.json.TestJsonParser": [
      {
        "methodName": "testGetValueAsTextBytes",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<a> but was:<null>",
        "fail_line": "        _testGetValueAsText(f, true, false);",
        "test_source": "  public void testGetValueAsTextBytes() throws Exception {\n  JsonFactory f = new JsonFactory();\n  _testGetValueAsText(f, true, false);\n  _testGetValueAsText(f, true, true);\n  }",
        "stack": [
          "TestJsonParser._testGetValueAsText line 546, TestJsonParser.testGetValueAsTextBytes line 518"
        ]
      },
      {
        "methodName": "testGetValueAsTextChars",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<a> but was:<null>",
        "fail_line": "        _testGetValueAsText(f, false, false);",
        "test_source": "  public void testGetValueAsTextChars() throws Exception {\n  JsonFactory f = new JsonFactory();\n  _testGetValueAsText(f, false, false);\n  _testGetValueAsText(f, false, true);\n  }",
        "stack": [
          "TestJsonParser._testGetValueAsText line 546, TestJsonParser.testGetValueAsTextChars line 525"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/core/base/ParserMinimalBase.java",
      "buggy_full_code": "package com.fasterxml.jackson.core.base;\n\nimport java.io.IOException;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.JsonParser.Feature;\nimport com.fasterxml.jackson.core.io.NumberInput;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*; public abstract class ParserMinimalBase extends JsonParser { protected final static int INT_TAB = '\\t'; protected final static int INT_LF = '\\n'; protected final static int INT_CR = '\\r'; protected final static int INT_SPACE = 0x0020; protected final static int INT_LBRACKET = '['; protected final static int INT_RBRACKET = ']'; protected final static int INT_LCURLY = '{'; protected final static int INT_RCURLY = '}'; protected final static int INT_QUOTE = '\"'; protected final static int INT_BACKSLASH = '\\\\'; protected final static int INT_SLASH = '/'; protected final static int INT_COLON = ':'; protected final static int INT_COMMA = ','; protected final static int INT_HASH = '#'; protected final static int INT_PERIOD = '.'; protected final static int INT_e = 'e'; protected final static int INT_E = 'E'; protected JsonToken _currToken; protected JsonToken _lastClearedToken; protected ParserMinimalBase() { }\n    protected ParserMinimalBase(int features) { super(features); }\n\n    \n    \n\n    \n\n    \n\n    \n    \n    \n    \n\n    \n\n    @Override public abstract JsonToken nextToken() throws IOException; @Override public JsonToken getCurrentToken() { return _currToken; }\n\n    @Override public final int getCurrentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n\n    @Override public boolean hasCurrentToken() { return _currToken != null; }\n    @Override public boolean hasTokenId(int id) {\n        final JsonToken t = _currToken;\n        if (t == null) {\n            return (JsonTokenId.ID_NO_TOKEN == id);\n        }\n        return t.id() == id;\n    }\n\n    @Override public final boolean hasToken(JsonToken t) {\n        return (_currToken == t);\n    }\n    \n    @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n    @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n    \n    @Override\n    public JsonToken nextValue() throws IOException {\n        \n        JsonToken t = nextToken();\n        if (t == JsonToken.FIELD_NAME) {\n            t = nextToken();\n        }\n        return t;\n    }\n\n    @Override\n    public JsonParser skipChildren() throws IOException {\n        if (_currToken != JsonToken.START_OBJECT\n            && _currToken != JsonToken.START_ARRAY) {\n            return this;\n        }\n        int open = 1;\n\n        \n        while (true) {\n            JsonToken t = nextToken();\n            if (t == null) {\n                _handleEOF();\n                \n                return this;\n            }\n            if (t.isStructStart()) {\n                ++open;\n            } else if (t.isStructEnd()) {\n                if (--open == 0) {\n                    return this;\n                }\n            }\n        }\n    }\n\n    \n    protected abstract void _handleEOF() throws JsonParseException; @Override public abstract String getCurrentName() throws IOException; @Override public abstract void close() throws IOException; @Override public abstract boolean isClosed(); @Override public abstract JsonStreamContext getParsingContext(); @Override public void clearCurrentToken() {\n        if (_currToken != null) {\n            _lastClearedToken = _currToken;\n            _currToken = null;\n        }\n    }\n\n    @Override public JsonToken getLastClearedToken() { return _lastClearedToken; }\n\n    @Override public abstract void overrideCurrentName(String name); @Override public abstract String getText() throws IOException; @Override public abstract char[] getTextCharacters() throws IOException; @Override public abstract boolean hasTextCharacters(); @Override public abstract int getTextLength() throws IOException; @Override public abstract int getTextOffset() throws IOException; @Override public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException; @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException {\n        JsonToken t = _currToken;\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText().trim();\n                if (\"true\".equals(str)) {\n                    return true;\n                }\n                if (\"false\".equals(str)) {\n                    return false;\n                }\n                if (_hasTextualNull(str)) {\n                    return false;\n                }\n                break;\n            case ID_NUMBER_INT:\n                return getIntValue() != 0;\n            case ID_TRUE:\n                return true;\n            case ID_FALSE:\n            case ID_NULL:\n                return false;\n            case ID_EMBEDDED_OBJECT:\n                Object value = this.getEmbeddedObject();\n                if (value instanceof Boolean) {\n                    return (Boolean) value;\n                }\n                break;\n            default:\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public int getValueAsInt() throws IOException {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return getIntValue();\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return getIntValue();\n        }\n        return getValueAsInt(0);\n    }\n\n    @Override\n    public int getValueAsInt(int defaultValue) throws IOException {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return getIntValue();\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return getIntValue();\n        }\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText();\n                if (_hasTextualNull(str)) {\n                    return 0;\n                }\n                return NumberInput.parseAsInt(str, defaultValue);\n            case ID_TRUE:\n                return 1;\n            case ID_FALSE:\n                return 0;\n            case ID_NULL:\n                return 0;\n            case ID_EMBEDDED_OBJECT:\n                Object value = this.getEmbeddedObject();\n                if (value instanceof Number) {\n                    return ((Number) value).intValue();\n                }\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public long getValueAsLong() throws IOException {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return getLongValue();\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return getLongValue();\n        }\n        return getValueAsLong(0L);\n    }\n    \n    @Override\n    public long getValueAsLong(long defaultValue) throws IOException {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return getLongValue();\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return getLongValue();\n        }\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText();\n                if (_hasTextualNull(str)) {\n                    return 0L;\n                }\n                return NumberInput.parseAsLong(str, defaultValue);\n            case ID_TRUE:\n                return 1L;\n            case ID_FALSE:\n            case ID_NULL:\n                return 0L;\n            case ID_EMBEDDED_OBJECT:\n                Object value = this.getEmbeddedObject();\n                if (value instanceof Number) {\n                    return ((Number) value).longValue();\n                }\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public double getValueAsDouble(double defaultValue) throws IOException {\n        JsonToken t = _currToken;\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText();\n                if (_hasTextualNull(str)) {\n                    return 0L;\n                }\n                return NumberInput.parseAsDouble(str, defaultValue);\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return getDoubleValue();\n            case ID_TRUE:\n                return 1.0;\n            case ID_FALSE:\n            case ID_NULL:\n                return 0.0;\n            case ID_EMBEDDED_OBJECT:\n                Object value = this.getEmbeddedObject();\n                if (value instanceof Number) {\n                    return ((Number) value).doubleValue();\n                }\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public String getValueAsString() throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            return getText();\n        }\n        return getValueAsString(null);\n    }\n    \n    @Override\n    public String getValueAsString(String defaultValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            return getText();\n        }\n        if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) {\n            return defaultValue;\n        }\n        return getText();\n    }\n    \n    \n\n    \n    protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException {\n        \n        try {\n            b64variant.decode(str, builder);\n        } catch (IllegalArgumentException e) {\n            _reportError(e.getMessage());\n        }\n    }\n\n    \n    @Deprecated\n    protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException {\n        String base;\n        if (ch <= INT_SPACE) {\n            base = \"Illegal white space character (code 0x\"+Integer.toHexString(ch)+\") as character #\"+(bindex+1)+\" of 4-char base64 unit: can only used between units\";\n        } else if (b64variant.usesPaddingChar(ch)) {\n            base = \"Unexpected padding character ('\"+b64variant.getPaddingChar()+\"') as character #\"+(bindex+1)+\" of 4-char base64 unit: padding only legal as 3rd or 4th character\";\n        } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) {\n            \n            base = \"Illegal character (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n        } else {\n            base = \"Illegal character '\"+ch+\"' (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n        }\n        if (msg != null) {\n            base = base + \": \" + msg;\n        }\n        throw _constructError(base);\n    }\n\n    \n    @Deprecated\n    protected void _reportBase64EOF() throws JsonParseException {\n        throw _constructError(\"Unexpected end-of-String in base64 content\");\n    }\n\n    \n    \n    \n    protected boolean _hasTextualNull(String value) { return \"null\".equals(value); }\n    \n    \n    \n    protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException {\n        if (ch < 0) { \n            _reportInvalidEOF();\n        }\n        String msg = \"Unexpected character (\"+_getCharDesc(ch)+\")\";\n        if (comment != null) {\n            msg += \": \"+comment;\n        }\n        _reportError(msg);\n    }\n\n    protected void _reportInvalidEOF() throws JsonParseException {\n        _reportInvalidEOF(\" in \"+_currToken);\n    }\n\n    protected void _reportInvalidEOF(String msg) throws JsonParseException {\n        _reportError(\"Unexpected end-of-input\"+msg);\n    }\n\n    protected void _reportInvalidEOFInValue() throws JsonParseException {\n        _reportInvalidEOF(\" in a value\");\n    }\n\n    protected void _reportMissingRootWS(int ch) throws JsonParseException {\n        _reportUnexpectedChar(ch, \"Expected space separating root-level values\");\n    }\n    \n    protected void _throwInvalidSpace(int i) throws JsonParseException {\n        char c = (char) i;\n        String msg = \"Illegal character (\"+_getCharDesc(c)+\"): only regular white space (\\\\r, \\\\n, \\\\t) is allowed between tokens\";\n        _reportError(msg);\n    }\n\n    \n    protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException {\n        \n        if (!isEnabled(Feature.ALLOW_UNQUOTED_CONTROL_CHARS) || i > INT_SPACE) {\n            char c = (char) i;\n            String msg = \"Illegal unquoted character (\"+_getCharDesc(c)+\"): has to be escaped using backslash to be included in \"+ctxtDesc;\n            _reportError(msg);\n        }\n    }\n\n    protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException {\n        \n        if (isEnabled(Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER)) {\n            return ch;\n        }\n        \n        if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return ch;\n        }\n        _reportError(\"Unrecognized character escape \"+_getCharDesc(ch));\n        return ch;\n    }\n    \n    \n\n    protected final static String _getCharDesc(int ch) {\n        char c = (char) ch;\n        if (Character.isISOControl(c)) {\n            return \"(CTRL-CHAR, code \"+ch+\")\";\n        }\n        if (ch > 255) {\n            return \"'\"+c+\"' (code \"+ch+\" / 0x\"+Integer.toHexString(ch)+\")\";\n        }\n        return \"'\"+c+\"' (code \"+ch+\")\";\n    }\n\n    protected final void _reportError(String msg) throws JsonParseException {\n        throw _constructError(msg);\n    }\n\n    protected final void _wrapError(String msg, Throwable t) throws JsonParseException {\n        throw _constructError(msg, t);\n    }\n\n    protected final void _throwInternal() {\n        VersionUtil.throwInternal();\n    }\n\n    protected final JsonParseException _constructError(String msg, Throwable t) {\n        return new JsonParseException(msg, getCurrentLocation(), t);\n    }\n\n    protected static byte[] _asciiBytes(String str) {\n        byte[] b = new byte[str.length()];\n        for (int i = 0, len = str.length(); i < len; ++i) {\n            b[i] = (byte) str.charAt(i);\n        }\n        return b;\n    }\n    \n    protected static String _ascii(byte[] b) {\n        try {\n            return new String(b, \"US-ASCII\");\n        } catch (IOException e) { \n            throw new RuntimeException(e);\n        }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.core.base;\n\nimport java.io.IOException;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.JsonParser.Feature;\nimport com.fasterxml.jackson.core.io.NumberInput;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*; public abstract class ParserMinimalBase extends JsonParser { protected final static int INT_TAB = '\\t'; protected final static int INT_LF = '\\n'; protected final static int INT_CR = '\\r'; protected final static int INT_SPACE = 0x0020; protected final static int INT_LBRACKET = '['; protected final static int INT_RBRACKET = ']'; protected final static int INT_LCURLY = '{'; protected final static int INT_RCURLY = '}'; protected final static int INT_QUOTE = '\"'; protected final static int INT_BACKSLASH = '\\\\'; protected final static int INT_SLASH = '/'; protected final static int INT_COLON = ':'; protected final static int INT_COMMA = ','; protected final static int INT_HASH = '#'; protected final static int INT_PERIOD = '.'; protected final static int INT_e = 'e'; protected final static int INT_E = 'E'; protected JsonToken _currToken; protected JsonToken _lastClearedToken; protected ParserMinimalBase() { }\n    protected ParserMinimalBase(int features) { super(features); }\n\n    \n    \n\n    \n\n    \n\n    \n    \n    \n    \n\n    \n\n    @Override public abstract JsonToken nextToken() throws IOException; @Override public JsonToken getCurrentToken() { return _currToken; }\n\n    @Override public final int getCurrentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n\n    @Override public boolean hasCurrentToken() { return _currToken != null; }\n    @Override public boolean hasTokenId(int id) {\n        final JsonToken t = _currToken;\n        if (t == null) {\n            return (JsonTokenId.ID_NO_TOKEN == id);\n        }\n        return t.id() == id;\n    }\n\n    @Override public final boolean hasToken(JsonToken t) {\n        return (_currToken == t);\n    }\n    \n    @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n    @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n    \n    @Override\n    public JsonToken nextValue() throws IOException {\n        \n        JsonToken t = nextToken();\n        if (t == JsonToken.FIELD_NAME) {\n            t = nextToken();\n        }\n        return t;\n    }\n\n    @Override\n    public JsonParser skipChildren() throws IOException {\n        if (_currToken != JsonToken.START_OBJECT\n            && _currToken != JsonToken.START_ARRAY) {\n            return this;\n        }\n        int open = 1;\n\n        \n        while (true) {\n            JsonToken t = nextToken();\n            if (t == null) {\n                _handleEOF();\n                \n                return this;\n            }\n            if (t.isStructStart()) {\n                ++open;\n            } else if (t.isStructEnd()) {\n                if (--open == 0) {\n                    return this;\n                }\n            }\n        }\n    }\n\n    \n    protected abstract void _handleEOF() throws JsonParseException; @Override public abstract String getCurrentName() throws IOException; @Override public abstract void close() throws IOException; @Override public abstract boolean isClosed(); @Override public abstract JsonStreamContext getParsingContext(); @Override public void clearCurrentToken() {\n        if (_currToken != null) {\n            _lastClearedToken = _currToken;\n            _currToken = null;\n        }\n    }\n\n    @Override public JsonToken getLastClearedToken() { return _lastClearedToken; }\n\n    @Override public abstract void overrideCurrentName(String name); @Override public abstract String getText() throws IOException; @Override public abstract char[] getTextCharacters() throws IOException; @Override public abstract boolean hasTextCharacters(); @Override public abstract int getTextLength() throws IOException; @Override public abstract int getTextOffset() throws IOException; @Override public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException; @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException {\n        JsonToken t = _currToken;\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText().trim();\n                if (\"true\".equals(str)) {\n                    return true;\n                }\n                if (\"false\".equals(str)) {\n                    return false;\n                }\n                if (_hasTextualNull(str)) {\n                    return false;\n                }\n                break;\n            case ID_NUMBER_INT:\n                return getIntValue() != 0;\n            case ID_TRUE:\n                return true;\n            case ID_FALSE:\n            case ID_NULL:\n                return false;\n            case ID_EMBEDDED_OBJECT:\n                Object value = this.getEmbeddedObject();\n                if (value instanceof Boolean) {\n                    return (Boolean) value;\n                }\n                break;\n            default:\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public int getValueAsInt() throws IOException {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return getIntValue();\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return getIntValue();\n        }\n        return getValueAsInt(0);\n    }\n\n    @Override\n    public int getValueAsInt(int defaultValue) throws IOException {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return getIntValue();\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return getIntValue();\n        }\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText();\n                if (_hasTextualNull(str)) {\n                    return 0;\n                }\n                return NumberInput.parseAsInt(str, defaultValue);\n            case ID_TRUE:\n                return 1;\n            case ID_FALSE:\n                return 0;\n            case ID_NULL:\n                return 0;\n            case ID_EMBEDDED_OBJECT:\n                Object value = this.getEmbeddedObject();\n                if (value instanceof Number) {\n                    return ((Number) value).intValue();\n                }\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public long getValueAsLong() throws IOException {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return getLongValue();\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return getLongValue();\n        }\n        return getValueAsLong(0L);\n    }\n    \n    @Override\n    public long getValueAsLong(long defaultValue) throws IOException {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return getLongValue();\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return getLongValue();\n        }\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText();\n                if (_hasTextualNull(str)) {\n                    return 0L;\n                }\n                return NumberInput.parseAsLong(str, defaultValue);\n            case ID_TRUE:\n                return 1L;\n            case ID_FALSE:\n            case ID_NULL:\n                return 0L;\n            case ID_EMBEDDED_OBJECT:\n                Object value = this.getEmbeddedObject();\n                if (value instanceof Number) {\n                    return ((Number) value).longValue();\n                }\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public double getValueAsDouble(double defaultValue) throws IOException {\n        JsonToken t = _currToken;\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText();\n                if (_hasTextualNull(str)) {\n                    return 0L;\n                }\n                return NumberInput.parseAsDouble(str, defaultValue);\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return getDoubleValue();\n            case ID_TRUE:\n                return 1.0;\n            case ID_FALSE:\n            case ID_NULL:\n                return 0.0;\n            case ID_EMBEDDED_OBJECT:\n                Object value = this.getEmbeddedObject();\n                if (value instanceof Number) {\n                    return ((Number) value).doubleValue();\n                }\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public String getValueAsString() throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            return getText();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return getValueAsString(null);\n    }\n    \n    @Override\n    public String getValueAsString(String defaultValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            return getText();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) {\n            return defaultValue;\n        }\n        return getText();\n    }\n    \n    \n\n    \n    protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException {\n        \n        try {\n            b64variant.decode(str, builder);\n        } catch (IllegalArgumentException e) {\n            _reportError(e.getMessage());\n        }\n    }\n\n    \n    @Deprecated\n    protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException {\n        String base;\n        if (ch <= INT_SPACE) {\n            base = \"Illegal white space character (code 0x\"+Integer.toHexString(ch)+\") as character #\"+(bindex+1)+\" of 4-char base64 unit: can only used between units\";\n        } else if (b64variant.usesPaddingChar(ch)) {\n            base = \"Unexpected padding character ('\"+b64variant.getPaddingChar()+\"') as character #\"+(bindex+1)+\" of 4-char base64 unit: padding only legal as 3rd or 4th character\";\n        } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) {\n            \n            base = \"Illegal character (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n        } else {\n            base = \"Illegal character '\"+ch+\"' (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n        }\n        if (msg != null) {\n            base = base + \": \" + msg;\n        }\n        throw _constructError(base);\n    }\n\n    \n    @Deprecated\n    protected void _reportBase64EOF() throws JsonParseException {\n        throw _constructError(\"Unexpected end-of-String in base64 content\");\n    }\n\n    \n    \n    \n    protected boolean _hasTextualNull(String value) { return \"null\".equals(value); }\n    \n    \n    \n    protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException {\n        if (ch < 0) { \n            _reportInvalidEOF();\n        }\n        String msg = \"Unexpected character (\"+_getCharDesc(ch)+\")\";\n        if (comment != null) {\n            msg += \": \"+comment;\n        }\n        _reportError(msg);\n    }\n\n    protected void _reportInvalidEOF() throws JsonParseException {\n        _reportInvalidEOF(\" in \"+_currToken);\n    }\n\n    protected void _reportInvalidEOF(String msg) throws JsonParseException {\n        _reportError(\"Unexpected end-of-input\"+msg);\n    }\n\n    protected void _reportInvalidEOFInValue() throws JsonParseException {\n        _reportInvalidEOF(\" in a value\");\n    }\n\n    protected void _reportMissingRootWS(int ch) throws JsonParseException {\n        _reportUnexpectedChar(ch, \"Expected space separating root-level values\");\n    }\n    \n    protected void _throwInvalidSpace(int i) throws JsonParseException {\n        char c = (char) i;\n        String msg = \"Illegal character (\"+_getCharDesc(c)+\"): only regular white space (\\\\r, \\\\n, \\\\t) is allowed between tokens\";\n        _reportError(msg);\n    }\n\n    \n    protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException {\n        \n        if (!isEnabled(Feature.ALLOW_UNQUOTED_CONTROL_CHARS) || i > INT_SPACE) {\n            char c = (char) i;\n            String msg = \"Illegal unquoted character (\"+_getCharDesc(c)+\"): has to be escaped using backslash to be included in \"+ctxtDesc;\n            _reportError(msg);\n        }\n    }\n\n    protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException {\n        \n        if (isEnabled(Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER)) {\n            return ch;\n        }\n        \n        if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return ch;\n        }\n        _reportError(\"Unrecognized character escape \"+_getCharDesc(ch));\n        return ch;\n    }\n    \n    \n\n    protected final static String _getCharDesc(int ch) {\n        char c = (char) ch;\n        if (Character.isISOControl(c)) {\n            return \"(CTRL-CHAR, code \"+ch+\")\";\n        }\n        if (ch > 255) {\n            return \"'\"+c+\"' (code \"+ch+\" / 0x\"+Integer.toHexString(ch)+\")\";\n        }\n        return \"'\"+c+\"' (code \"+ch+\")\";\n    }\n\n    protected final void _reportError(String msg) throws JsonParseException {\n        throw _constructError(msg);\n    }\n\n    protected final void _wrapError(String msg, Throwable t) throws JsonParseException {\n        throw _constructError(msg, t);\n    }\n\n    protected final void _throwInternal() {\n        VersionUtil.throwInternal();\n    }\n\n    protected final JsonParseException _constructError(String msg, Throwable t) {\n        return new JsonParseException(msg, getCurrentLocation(), t);\n    }\n\n    protected static byte[] _asciiBytes(String str) {\n        byte[] b = new byte[str.length()];\n        for (int i = 0, len = str.length(); i < len; ++i) {\n            b[i] = (byte) str.charAt(i);\n        }\n        return b;\n    }\n    \n    protected static String _ascii(byte[] b) {\n        try {\n            return new String(b, \"US-ASCII\");\n        } catch (IOException e) { \n            throw new RuntimeException(e);\n        }\n    }\n}\n",
      "buggy_signatures": [
        "protected ParserMinimalBase(int features)",
        "public abstract JsonToken nextToken() throws IOException; @Override public JsonToken getCurrentToken()",
        "public final int getCurrentTokenId()",
        "public boolean hasCurrentToken()",
        "public boolean hasTokenId(int id)",
        "public final boolean hasToken(JsonToken t)",
        "public boolean isExpectedStartArrayToken()",
        "public boolean isExpectedStartObjectToken()",
        "public JsonToken nextValue() throws IOException",
        "public JsonParser skipChildren() throws IOException",
        "protected abstract void _handleEOF() throws JsonParseException; @Override public abstract String getCurrentName() throws IOException; @Override public abstract void close() throws IOException; @Override public abstract boolean isClosed(); @Override public abstract JsonStreamContext getParsingContext(); @Override public void clearCurrentToken()",
        "public JsonToken getLastClearedToken()",
        "public abstract void overrideCurrentName(String name); @Override public abstract String getText() throws IOException; @Override public abstract char[] getTextCharacters() throws IOException; @Override public abstract boolean hasTextCharacters(); @Override public abstract int getTextLength() throws IOException; @Override public abstract int getTextOffset() throws IOException; @Override public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException; @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException",
        "public int getValueAsInt() throws IOException",
        "public int getValueAsInt(int defaultValue) throws IOException",
        "public long getValueAsLong() throws IOException",
        "public long getValueAsLong(long defaultValue) throws IOException",
        "public double getValueAsDouble(double defaultValue) throws IOException",
        "public String getValueAsString() throws IOException",
        "public String getValueAsString(String defaultValue) throws IOException",
        "protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException",
        "protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException",
        "protected void _reportBase64EOF() throws JsonParseException",
        "protected boolean _hasTextualNull(String value)",
        "protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException",
        "protected void _reportInvalidEOF() throws JsonParseException",
        "protected void _reportInvalidEOF(String msg) throws JsonParseException",
        "protected void _reportInvalidEOFInValue() throws JsonParseException",
        "protected void _reportMissingRootWS(int ch) throws JsonParseException",
        "protected void _throwInvalidSpace(int i) throws JsonParseException",
        "protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException",
        "protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException",
        "protected final static String _getCharDesc(int ch)",
        "protected final void _reportError(String msg) throws JsonParseException",
        "protected final void _wrapError(String msg, Throwable t) throws JsonParseException",
        "protected final void _throwInternal()",
        "protected final JsonParseException _constructError(String msg, Throwable t)",
        "protected static byte[] _asciiBytes(String str)",
        "protected static String _ascii(byte[] b)"
      ],
      "fixed_signatures": [
        "protected ParserMinimalBase(int features)",
        "public abstract JsonToken nextToken() throws IOException; @Override public JsonToken getCurrentToken()",
        "public final int getCurrentTokenId()",
        "public boolean hasCurrentToken()",
        "public boolean hasTokenId(int id)",
        "public final boolean hasToken(JsonToken t)",
        "public boolean isExpectedStartArrayToken()",
        "public boolean isExpectedStartObjectToken()",
        "public JsonToken nextValue() throws IOException",
        "public JsonParser skipChildren() throws IOException",
        "protected abstract void _handleEOF() throws JsonParseException; @Override public abstract String getCurrentName() throws IOException; @Override public abstract void close() throws IOException; @Override public abstract boolean isClosed(); @Override public abstract JsonStreamContext getParsingContext(); @Override public void clearCurrentToken()",
        "public JsonToken getLastClearedToken()",
        "public abstract void overrideCurrentName(String name); @Override public abstract String getText() throws IOException; @Override public abstract char[] getTextCharacters() throws IOException; @Override public abstract boolean hasTextCharacters(); @Override public abstract int getTextLength() throws IOException; @Override public abstract int getTextOffset() throws IOException; @Override public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException; @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException",
        "public int getValueAsInt() throws IOException",
        "public int getValueAsInt(int defaultValue) throws IOException",
        "public long getValueAsLong() throws IOException",
        "public long getValueAsLong(long defaultValue) throws IOException",
        "public double getValueAsDouble(double defaultValue) throws IOException",
        "public String getValueAsString() throws IOException",
        "public String getValueAsString(String defaultValue) throws IOException",
        "protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException",
        "protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException",
        "protected void _reportBase64EOF() throws JsonParseException",
        "protected boolean _hasTextualNull(String value)",
        "protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException",
        "protected void _reportInvalidEOF() throws JsonParseException",
        "protected void _reportInvalidEOF(String msg) throws JsonParseException",
        "protected void _reportInvalidEOFInValue() throws JsonParseException",
        "protected void _reportMissingRootWS(int ch) throws JsonParseException",
        "protected void _throwInvalidSpace(int i) throws JsonParseException",
        "protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException",
        "protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException",
        "protected final static String _getCharDesc(int ch)",
        "protected final void _reportError(String msg) throws JsonParseException",
        "protected final void _wrapError(String msg, Throwable t) throws JsonParseException",
        "protected final void _throwInternal()",
        "protected final JsonParseException _constructError(String msg, Throwable t)",
        "protected static byte[] _asciiBytes(String str)",
        "protected static String _ascii(byte[] b)"
      ],
      "methods": [
        {
          "buggy_method": "  public String getValueAsString() throws IOException {\n  if (_currToken == JsonToken.VALUE_STRING) {\n  return getText();\n  }\n  return getValueAsString(null);\n  }",
          "fixed_method": "  public String getValueAsString() throws IOException {\n  if (_currToken == JsonToken.VALUE_STRING) {\n  return getText();\n  }\n  if (_currToken == JsonToken.FIELD_NAME) {\n  return getCurrentName();\n  }\n  return getValueAsString(null);\n  }",
          "diff": [
            "@@ -389,6 +389,9 @@",
            "         if (_currToken == JsonToken.VALUE_STRING) {\n",
            "             return getText();\n",
            "         }\n",
            "+        if (_currToken == JsonToken.FIELD_NAME) {\n",
            "+            return getCurrentName();\n",
            "+        }\n",
            "         return getValueAsString(null);\n",
            "     }\n",
            "     \n"
          ],
          "changed_lines": 3
        },
        {
          "buggy_method": "  public String getValueAsString(String defaultValue) throws IOException {\n  if (_currToken == JsonToken.VALUE_STRING) {\n  return getText();\n  }\n  if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) {\n  return defaultValue;\n  }\n  return getText();\n  }",
          "fixed_method": "  public String getValueAsString(String defaultValue) throws IOException {\n  if (_currToken == JsonToken.VALUE_STRING) {\n  return getText();\n  }\n  if (_currToken == JsonToken.FIELD_NAME) {\n  return getCurrentName();\n  }\n  if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) {\n  return defaultValue;\n  }\n  return getText();\n  }",
          "diff": [
            "@@ -396,6 +399,9 @@",
            "     public String getValueAsString(String defaultValue) throws IOException {\n",
            "         if (_currToken == JsonToken.VALUE_STRING) {\n",
            "             return getText();\n",
            "+        }\n",
            "+        if (_currToken == JsonToken.FIELD_NAME) {\n",
            "+            return getCurrentName();\n",
            "         }\n",
            "         if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) {\n",
            "             return defaultValue;\n"
          ],
          "changed_lines": 3
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
      "buggy_full_code": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*; public class ReaderBasedJsonParser extends ParserBase { protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); protected Reader _reader; protected char[] _inputBuffer; protected boolean _bufferRecyclable; protected ObjectCodec _objectCodec; final protected CharsToNameCanonicalizer _symbols; final protected int _hashSeed; protected boolean _tokenIncomplete = false; public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st, char[] inputBuffer, int start, int end, boolean bufferRecyclable) {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    \n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st) {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    \n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n    \n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        \n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Override\n    protected boolean loadMore() throws IOException {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            \n            _closeInput();\n            \n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    protected char getNextChar(String eofMsg) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) { _reportInvalidEOF(eofMsg); }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        \n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    \n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        \n        _symbols.release();\n        \n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n    \n    \n    \n    \n    @Override\n    public final String getText() throws IOException {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); \n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    \n    \n    \n    @Override\n    public final String getValueAsString() throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); \n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    \n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); \n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            \n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException {\n        if (_currToken != null) { \n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); \n                }\n                \n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException {\n        if (_currToken != null) { \n            switch (_currToken.id()) {\n                \n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); \n                }\n                \n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException {\n        \n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); \n                }\n                \n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        \n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            \n            _tokenIncomplete = false;\n        } else { \n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n    \n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException {\n        \n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        \n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            \n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { \n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { \n                    continue;\n                }\n            }\n\n            \n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            \n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            \n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    \n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    \n\n    \n    @Override\n    public final JsonToken nextToken() throws IOException {\n        _numTypesValid = NR_UNKNOWN;\n\n        \n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        if (_tokenIncomplete) {\n            _skipString(); \n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { \n            \n            close();\n            return (_currToken = null);\n        }\n\n        \n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        \n        _binaryValue = null;\n\n        \n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        \n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n\n        \n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n           \n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n\n        \n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            \n            \n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            \n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName() {\n        _nameCopied = false; \n        JsonToken t = _nextToken;\n        _nextToken = null;\n        \n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    \n\n    \n    @Override\n    public final String nextTextValue() throws IOException {\n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        \n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    \n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        \n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    \n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException {\n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        \n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    \n    @Override\n    public final Boolean nextBooleanValue() throws IOException {\n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    \n\n    \n    protected final JsonToken _parsePosNumber(int ch) throws IOException {\n        \n        int ptr = _inputPtr;\n        int startPtr = ptr-1; \n        final int inputLen = _inputEnd;\n\n        \n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n            \n        \n        \n        int intLen = 1; \n        \n        \n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        \n        --ptr; \n        _inputPtr = ptr;\n        \n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen) throws IOException {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        \n        if (ch == '.') { \n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            \n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { \n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            \n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { \n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            \n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; \n        _inputPtr = ptr;\n        \n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        \n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; \n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        \n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        \n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; \n        \n        \n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    \n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        \n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        \n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        \n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                \n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        \n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        \n        if (c == '.') { \n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            \n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            \n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            \n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                \n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            \n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        \n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        \n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    \n    private final char _verifyNoLeadingZeroes() throws IOException {\n        \n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            \n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        \n        return _verifyNLZ2();\n    }\n        \n    private char _verifyNLZ2() throws IOException {\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        \n        ++_inputPtr; \n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { \n                    return '0';\n                }\n                ++_inputPtr; \n                if (ch != '0') { \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    \n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { _reportInvalidEOFInValue(); }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    \n    private final void _verifyRootSpace(int ch) throws IOException {\n        \n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n    \n    \n\n    protected final String _parseName() throws IOException {\n        \n        \n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; \n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        \n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    \n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            \n            outBuf[outPtr++] = c;\n\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    \n    protected String _handleOddName(int i) throws IOException {\n        \n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        \n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        \n        boolean firstOk;\n\n        if (i < maxCode) { \n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; \n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; \n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException {\n        \n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; \n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    \n    protected JsonToken _handleOddValue(int i) throws IOException {\n        \n        switch (i) {\n        case '\\'':\n            \n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': \n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        \n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        \n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n    \n    protected JsonToken _handleApos() throws IOException {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    \n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            \n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n    \n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { \n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i <= maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            \n            outBuf[outPtr++] = c;\n\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n  \n    @Override\n    protected final void _finishString() throws IOException {\n        \n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        \n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        \n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    \n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } \n            }\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            \n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    \n    protected final void _skipString() throws IOException {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    \n                    _inputPtr = inPtr;\n                    c = _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    \n    \n    \n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n    \n    private final int _skipColon() throws IOException {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { \n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { \n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;                    \n                    return i;\n                }\n            }\n            return _skipColon2(true); \n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    if (i < INT_SPACE) {\n                        _throwInvalidSpace(i);\n                    }\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n \n    \n    private final int _skipComma(int i) throws IOException {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException {\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n    \n    private final int _skipWSOrEnd() throws IOException {\n        \n        \n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n        \n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { \n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n    \n    private void _skipComment() throws IOException {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        \n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException {\n        \n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { \n                    if ((_inputPtr >= _inputEnd) && !loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private boolean _skipYAMLComment() throws IOException {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n    \n    private void _skipLine() throws IOException {\n        \n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            \n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            \n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': \n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        \n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n    \n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { \n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        \n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { \n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        \n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { \n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        \n        _matchToken(\"null\", 1);\n    }\n\n    \n    protected final void _matchToken(String matchStr, int i) throws IOException {\n        final int len = matchStr.length();\n\n        do {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidToken(matchStr.substring(0, i));\n                }\n            }\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n\n        \n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c < '0' || c == ']' || c == '}') { \n            return;\n        }\n        \n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n        return;\n    }\n\n    \n\n    \n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        \n        while (true) {\n            \n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { \n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { \n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            \n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            \n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    \n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                \n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    \n                    \n                    \n                    \n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                \n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    \n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n    \n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException {\n        StringBuilder sb = new StringBuilder(matchedPart);\n        \n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n        }\n        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*; public class ReaderBasedJsonParser extends ParserBase { protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); protected Reader _reader; protected char[] _inputBuffer; protected boolean _bufferRecyclable; protected ObjectCodec _objectCodec; final protected CharsToNameCanonicalizer _symbols; final protected int _hashSeed; protected boolean _tokenIncomplete = false; public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st, char[] inputBuffer, int start, int end, boolean bufferRecyclable) {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    \n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st) {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    \n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n    \n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        \n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Override\n    protected boolean loadMore() throws IOException {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            \n            _closeInput();\n            \n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    protected char getNextChar(String eofMsg) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) { _reportInvalidEOF(eofMsg); }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        \n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    \n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        \n        _symbols.release();\n        \n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n    \n    \n    \n    \n    @Override\n    public final String getText() throws IOException {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); \n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    \n    \n    \n    @Override\n    public final String getValueAsString() throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); \n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    \n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); \n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            \n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException {\n        if (_currToken != null) { \n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); \n                }\n                \n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException {\n        if (_currToken != null) { \n            switch (_currToken.id()) {\n                \n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); \n                }\n                \n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException {\n        \n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); \n                }\n                \n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        \n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            \n            _tokenIncomplete = false;\n        } else { \n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n    \n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException {\n        \n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        \n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            \n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { \n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { \n                    continue;\n                }\n            }\n\n            \n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            \n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            \n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    \n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    \n\n    \n    @Override\n    public final JsonToken nextToken() throws IOException {\n        _numTypesValid = NR_UNKNOWN;\n\n        \n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        if (_tokenIncomplete) {\n            _skipString(); \n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { \n            \n            close();\n            return (_currToken = null);\n        }\n\n        \n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        \n        _binaryValue = null;\n\n        \n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        \n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n\n        \n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n           \n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n\n        \n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            \n            \n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            \n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName() {\n        _nameCopied = false; \n        JsonToken t = _nextToken;\n        _nextToken = null;\n        \n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    \n\n    \n    @Override\n    public final String nextTextValue() throws IOException {\n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        \n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    \n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        \n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    \n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException {\n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        \n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    \n    @Override\n    public final Boolean nextBooleanValue() throws IOException {\n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    \n\n    \n    protected final JsonToken _parsePosNumber(int ch) throws IOException {\n        \n        int ptr = _inputPtr;\n        int startPtr = ptr-1; \n        final int inputLen = _inputEnd;\n\n        \n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n            \n        \n        \n        int intLen = 1; \n        \n        \n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        \n        --ptr; \n        _inputPtr = ptr;\n        \n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen) throws IOException {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        \n        if (ch == '.') { \n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            \n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { \n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            \n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { \n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            \n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; \n        _inputPtr = ptr;\n        \n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        \n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; \n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        \n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        \n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; \n        \n        \n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    \n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        \n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        \n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        \n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                \n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        \n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        \n        if (c == '.') { \n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            \n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            \n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            \n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                \n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            \n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        \n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        \n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    \n    private final char _verifyNoLeadingZeroes() throws IOException {\n        \n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            \n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        \n        return _verifyNLZ2();\n    }\n        \n    private char _verifyNLZ2() throws IOException {\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        \n        ++_inputPtr; \n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { \n                    return '0';\n                }\n                ++_inputPtr; \n                if (ch != '0') { \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    \n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { _reportInvalidEOFInValue(); }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    \n    private final void _verifyRootSpace(int ch) throws IOException {\n        \n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n    \n    \n\n    protected final String _parseName() throws IOException {\n        \n        \n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; \n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        \n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    \n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            \n            outBuf[outPtr++] = c;\n\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    \n    protected String _handleOddName(int i) throws IOException {\n        \n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        \n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        \n        boolean firstOk;\n\n        if (i < maxCode) { \n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; \n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; \n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException {\n        \n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; \n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    \n    protected JsonToken _handleOddValue(int i) throws IOException {\n        \n        switch (i) {\n        case '\\'':\n            \n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': \n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        \n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        \n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n    \n    protected JsonToken _handleApos() throws IOException {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    \n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            \n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n    \n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { \n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i <= maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            \n            outBuf[outPtr++] = c;\n\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n  \n    @Override\n    protected final void _finishString() throws IOException {\n        \n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        \n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        \n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    \n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } \n            }\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            \n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    \n    protected final void _skipString() throws IOException {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    \n                    _inputPtr = inPtr;\n                    c = _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    \n    \n    \n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n    \n    private final int _skipColon() throws IOException {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { \n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { \n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;                    \n                    return i;\n                }\n            }\n            return _skipColon2(true); \n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    if (i < INT_SPACE) {\n                        _throwInvalidSpace(i);\n                    }\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n \n    \n    private final int _skipComma(int i) throws IOException {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException {\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n    \n    private final int _skipWSOrEnd() throws IOException {\n        \n        \n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n        \n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { \n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n    \n    private void _skipComment() throws IOException {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        \n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException {\n        \n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { \n                    if ((_inputPtr >= _inputEnd) && !loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private boolean _skipYAMLComment() throws IOException {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n    \n    private void _skipLine() throws IOException {\n        \n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            \n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            \n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': \n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        \n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n    \n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { \n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        \n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { \n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        \n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { \n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        \n        _matchToken(\"null\", 1);\n    }\n\n    \n    protected final void _matchToken(String matchStr, int i) throws IOException {\n        final int len = matchStr.length();\n\n        do {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidToken(matchStr.substring(0, i));\n                }\n            }\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n\n        \n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c < '0' || c == ']' || c == '}') { \n            return;\n        }\n        \n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n        return;\n    }\n\n    \n\n    \n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        \n        while (true) {\n            \n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { \n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { \n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            \n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            \n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    \n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                \n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    \n                    \n                    \n                    \n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                \n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    \n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n    \n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException {\n        StringBuilder sb = new StringBuilder(matchedPart);\n        \n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n        }\n        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n    }\n}\n",
      "buggy_signatures": [
        "public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st)",
        "public ObjectCodec getCodec()",
        "public void setCodec(ObjectCodec c)",
        "public int releaseBuffered(Writer w) throws IOException",
        "public Object getInputSource()",
        "protected boolean loadMore() throws IOException",
        "protected char getNextChar(String eofMsg) throws IOException",
        "protected void _closeInput() throws IOException",
        "protected void _releaseBuffers() throws IOException",
        "public final String getText() throws IOException",
        "public final String getValueAsString() throws IOException",
        "public final String getValueAsString(String defValue) throws IOException",
        "protected final String _getText2(JsonToken t)",
        "public final char[] getTextCharacters() throws IOException",
        "public final int getTextLength() throws IOException",
        "public final int getTextOffset() throws IOException",
        "public byte[] getBinaryValue(Base64Variant b64variant) throws IOException",
        "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException",
        "protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException",
        "public final JsonToken nextToken() throws IOException",
        "private final JsonToken _nextAfterName()",
        "public final String nextTextValue() throws IOException",
        "public final int nextIntValue(int defaultValue) throws IOException",
        "public final long nextLongValue(long defaultValue) throws IOException",
        "public final Boolean nextBooleanValue() throws IOException",
        "protected final JsonToken _parsePosNumber(int ch) throws IOException",
        "private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen) throws IOException",
        "protected final JsonToken _parseNegNumber() throws IOException",
        "private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException",
        "private final char _verifyNoLeadingZeroes() throws IOException",
        "private char _verifyNLZ2() throws IOException",
        "protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException",
        "private final void _verifyRootSpace(int ch) throws IOException",
        "protected final String _parseName() throws IOException",
        "private String _parseName2(int startPtr, int hash, int endChar) throws IOException",
        "protected String _handleOddName(int i) throws IOException",
        "protected String _parseAposName() throws IOException",
        "protected JsonToken _handleOddValue(int i) throws IOException",
        "protected JsonToken _handleApos() throws IOException",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException",
        "protected final void _finishString() throws IOException",
        "protected void _finishString2() throws IOException",
        "protected final void _skipString() throws IOException",
        "protected final void _skipCR() throws IOException",
        "private final int _skipColon() throws IOException",
        "private final int _skipColon2(boolean gotColon) throws IOException",
        "private final int _skipComma(int i) throws IOException",
        "private final int _skipAfterComma2() throws IOException",
        "private final int _skipWSOrEnd() throws IOException",
        "private int _skipWSOrEnd2() throws IOException",
        "private void _skipComment() throws IOException",
        "private void _skipCComment() throws IOException",
        "private boolean _skipYAMLComment() throws IOException",
        "private void _skipLine() throws IOException",
        "protected char _decodeEscaped() throws IOException",
        "private final void _matchTrue() throws IOException",
        "private final void _matchFalse() throws IOException",
        "private final void _matchNull() throws IOException",
        "protected final void _matchToken(String matchStr, int i) throws IOException",
        "protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException",
        "protected void _reportInvalidToken(String matchedPart) throws IOException",
        "protected void _reportInvalidToken(String matchedPart, String msg) throws IOException"
      ],
      "fixed_signatures": [
        "public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st)",
        "public ObjectCodec getCodec()",
        "public void setCodec(ObjectCodec c)",
        "public int releaseBuffered(Writer w) throws IOException",
        "public Object getInputSource()",
        "protected boolean loadMore() throws IOException",
        "protected char getNextChar(String eofMsg) throws IOException",
        "protected void _closeInput() throws IOException",
        "protected void _releaseBuffers() throws IOException",
        "public final String getText() throws IOException",
        "public final String getValueAsString() throws IOException",
        "public final String getValueAsString(String defValue) throws IOException",
        "protected final String _getText2(JsonToken t)",
        "public final char[] getTextCharacters() throws IOException",
        "public final int getTextLength() throws IOException",
        "public final int getTextOffset() throws IOException",
        "public byte[] getBinaryValue(Base64Variant b64variant) throws IOException",
        "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException",
        "protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException",
        "public final JsonToken nextToken() throws IOException",
        "private final JsonToken _nextAfterName()",
        "public final String nextTextValue() throws IOException",
        "public final int nextIntValue(int defaultValue) throws IOException",
        "public final long nextLongValue(long defaultValue) throws IOException",
        "public final Boolean nextBooleanValue() throws IOException",
        "protected final JsonToken _parsePosNumber(int ch) throws IOException",
        "private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen) throws IOException",
        "protected final JsonToken _parseNegNumber() throws IOException",
        "private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException",
        "private final char _verifyNoLeadingZeroes() throws IOException",
        "private char _verifyNLZ2() throws IOException",
        "protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException",
        "private final void _verifyRootSpace(int ch) throws IOException",
        "protected final String _parseName() throws IOException",
        "private String _parseName2(int startPtr, int hash, int endChar) throws IOException",
        "protected String _handleOddName(int i) throws IOException",
        "protected String _parseAposName() throws IOException",
        "protected JsonToken _handleOddValue(int i) throws IOException",
        "protected JsonToken _handleApos() throws IOException",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException",
        "protected final void _finishString() throws IOException",
        "protected void _finishString2() throws IOException",
        "protected final void _skipString() throws IOException",
        "protected final void _skipCR() throws IOException",
        "private final int _skipColon() throws IOException",
        "private final int _skipColon2(boolean gotColon) throws IOException",
        "private final int _skipComma(int i) throws IOException",
        "private final int _skipAfterComma2() throws IOException",
        "private final int _skipWSOrEnd() throws IOException",
        "private int _skipWSOrEnd2() throws IOException",
        "private void _skipComment() throws IOException",
        "private void _skipCComment() throws IOException",
        "private boolean _skipYAMLComment() throws IOException",
        "private void _skipLine() throws IOException",
        "protected char _decodeEscaped() throws IOException",
        "private final void _matchTrue() throws IOException",
        "private final void _matchFalse() throws IOException",
        "private final void _matchNull() throws IOException",
        "protected final void _matchToken(String matchStr, int i) throws IOException",
        "protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException",
        "protected void _reportInvalidToken(String matchedPart) throws IOException",
        "protected void _reportInvalidToken(String matchedPart, String msg) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  public final String getValueAsString() throws IOException {\n  if (_currToken == JsonToken.VALUE_STRING) {\n  if (_tokenIncomplete) {\n  _tokenIncomplete = false;\n  _finishString(); \n  }\n  return _textBuffer.contentsAsString();\n  }\n  return super.getValueAsString(null);\n  }",
          "fixed_method": "  public final String getValueAsString() throws IOException {\n  if (_currToken == JsonToken.VALUE_STRING) {\n  if (_tokenIncomplete) {\n  _tokenIncomplete = false;\n  _finishString(); \n  }\n  return _textBuffer.contentsAsString();\n  }\n  if (_currToken == JsonToken.FIELD_NAME) {\n  return getCurrentName();\n  }\n  return super.getValueAsString(null);\n  }",
          "diff": [
            "@@ -250,6 +250,9 @@",
            "             }\n",
            "             return _textBuffer.contentsAsString();\n",
            "         }\n",
            "+        if (_currToken == JsonToken.FIELD_NAME) {\n",
            "+            return getCurrentName();\n",
            "+        }\n",
            "         return super.getValueAsString(null);\n",
            "     }\n",
            "     \n"
          ],
          "changed_lines": 3
        },
        {
          "buggy_method": "  public final String getValueAsString(String defValue) throws IOException {\n  if (_currToken == JsonToken.VALUE_STRING) {\n  if (_tokenIncomplete) {\n  _tokenIncomplete = false;\n  _finishString(); \n  }\n  return _textBuffer.contentsAsString();\n  }\n  return super.getValueAsString(defValue);\n  }",
          "fixed_method": "  public final String getValueAsString(String defValue) throws IOException {\n  if (_currToken == JsonToken.VALUE_STRING) {\n  if (_tokenIncomplete) {\n  _tokenIncomplete = false;\n  _finishString(); \n  }\n  return _textBuffer.contentsAsString();\n  }\n  if (_currToken == JsonToken.FIELD_NAME) {\n  return getCurrentName();\n  }\n  return super.getValueAsString(defValue);\n  }",
          "diff": [
            "@@ -262,6 +265,9 @@",
            "                 _finishString(); // only strings can be incomplete\n",
            "             }\n",
            "             return _textBuffer.contentsAsString();\n",
            "+        }\n",
            "+        if (_currToken == JsonToken.FIELD_NAME) {\n",
            "+            return getCurrentName();\n",
            "         }\n",
            "         return super.getValueAsString(defValue);\n",
            "     }\n"
          ],
          "changed_lines": 3
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java",
      "buggy_full_code": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.util.Arrays;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*; public class UTF8StreamJsonParser extends ParserBase { final static byte BYTE_LF = (byte) '\\n'; private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8(); protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); protected ObjectCodec _objectCodec; final protected ByteQuadsCanonicalizer _symbols; protected int[] _quadBuffer = new int[16]; protected boolean _tokenIncomplete = false; private int _quad1; protected InputStream _inputStream; protected byte[] _inputBuffer; protected boolean _bufferRecyclable; public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, ByteQuadsCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable) {\n        super(ctxt, features);\n        _inputStream = in;\n        _objectCodec = codec;\n        _symbols = sym;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _currInputRowStart = start;\n        \n        _currInputProcessed = -start;\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n    \n    \n\n    @Override\n    public int releaseBuffered(OutputStream out) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n            return 0;\n        }\n        \n        int origPtr = _inputPtr;\n        out.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override\n    public Object getInputSource() {\n        return _inputStream;\n    }\n    \n    \n\n    @Override\n    protected final boolean loadMore() throws IOException {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n        \n        if (_inputStream != null) {\n            int space = _inputBuffer.length;\n            if (space == 0) { \n                return false;\n            }\n            \n            int count = _inputStream.read(_inputBuffer, 0, space);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            \n            _closeInput();\n            \n            if (count == 0) {\n                throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\");\n            }\n        }\n        return false;\n    }\n\n    \n    protected final boolean _loadToHaveAtLeast(int minAvailable) throws IOException {\n        \n        if (_inputStream == null) {\n            return false;\n        }\n        \n        int amount = _inputEnd - _inputPtr;\n        if (amount > 0 && _inputPtr > 0) {\n            _currInputProcessed += _inputPtr;\n            _currInputRowStart -= _inputPtr;\n            System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount);\n            _inputEnd = amount;\n        } else {\n            _inputEnd = 0;\n        }\n        _inputPtr = 0;\n        while (_inputEnd < minAvailable) {\n            int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);\n            if (count < 1) {\n                \n                _closeInput();\n                \n                if (count == 0) {\n                    throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\");\n                }\n                return false;\n            }\n            _inputEnd += count;\n        }\n        return true;\n    }\n    \n    @Override\n    protected void _closeInput() throws IOException {\n        \n        if (_inputStream != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _inputStream.close();\n            }\n            _inputStream = null;\n        }\n    }\n\n    \n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        \n        _symbols.release();\n        if (_bufferRecyclable) {\n            byte[] buf = _inputBuffer;\n            if (buf != null) {\n                \n                _inputBuffer = ByteArrayBuilder.NO_BYTES;\n                _ioContext.releaseReadIOBuffer(buf);\n            }\n        }\n    }\n\n    \n\n    @Override\n    public String getText() throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); \n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(_currToken);\n    }\n\n    \n    \n    \n    @Override\n    public String getValueAsString() throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); \n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    \n    @Override\n    public String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); \n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    \n    @Override\n    public int getValueAsInt() throws IOException {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            \n            if ((_numTypesValid & NR_INT) == 0) {\n                if (_numTypesValid == NR_UNKNOWN) {\n                    return _parseIntValue();\n                }\n                if ((_numTypesValid & NR_INT) == 0) {\n                    convertNumberToInt();\n                }\n            }\n            return _numberInt;\n        }\n        return super.getValueAsInt(0);\n    }\n\n    \n    @Override\n    public int getValueAsInt(int defValue) throws IOException {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            \n            if ((_numTypesValid & NR_INT) == 0) {\n                if (_numTypesValid == NR_UNKNOWN) {\n                    return _parseIntValue();\n                }\n                if ((_numTypesValid & NR_INT) == 0) {\n                    convertNumberToInt();\n                }\n            }\n            return _numberInt;\n        }\n        return super.getValueAsInt(defValue);\n    }\n    \n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            \n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n        \treturn t.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters() throws IOException {\n        if (_currToken != null) { \n            switch (_currToken.id()) {\n                \n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); \n                }\n                \n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public int getTextLength() throws IOException {\n        if (_currToken != null) { \n            switch (_currToken.id()) {\n                \n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); \n                }\n                \n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public int getTextOffset() throws IOException {\n        \n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); \n                }\n                \n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n    \n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        \n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            \n            _tokenIncomplete = false;\n        } else { \n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException {\n        \n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        \n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            \n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { \n                if (ch == INT_QUOTE) {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { \n                    continue;\n                }\n            }\n\n            \n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            \n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            \n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    \n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    \n    @Override\n    public JsonLocation getTokenLocation() {\n        return new JsonLocation(_ioContext.getSourceReference(),\n                getTokenCharacterOffset(), -1L, \n                getTokenLineNr(),\n                getTokenColumnNr());\n    }\n\n    \n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; \n        return new JsonLocation(_ioContext.getSourceReference(),\n                _currInputProcessed + _inputPtr, -1L, \n                _currInputRow, col);\n    }\n    \n    \n\n    \n    @Override\n    public JsonToken nextToken() throws IOException {\n        _numTypesValid = NR_UNKNOWN;\n        \n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        if (_tokenIncomplete) {\n            _skipString(); \n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { \n            \n            close();\n            return (_currToken = null);\n        }\n\n        \n        \n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        \n        _binaryValue = null;\n\n        \n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        \n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        \n        if (!_parsingContext.inObject()) {\n            return _nextTokenNotInObject(i);\n        }\n        \n        String n = _parseName(i);\n        _parsingContext.setCurrentName(n);\n        _currToken = JsonToken.FIELD_NAME;\n\n        i = _skipColon();\n\n        \n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return _currToken;\n        }        \n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n\n            \n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return _currToken;\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            \n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        }\n        return (_currToken = _handleUnexpectedValue(i));\n    }\n    \n    private final JsonToken _nextAfterName() {\n        _nameCopied = false; \n        JsonToken t = _nextToken;\n        _nextToken = null;\n        \n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n    \n    \n\n    @Override\n    public boolean nextFieldName(SerializableString str) throws IOException {\n        \n        \n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { \n            close();\n            _currToken = null;\n            return false;\n        }\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        \n        _binaryValue = null;\n\n        \n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return false;\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return false;\n        }\n\n        \n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return false;\n        }\n        \n        \n        if (i == INT_QUOTE) {\n            \n            byte[] nameBytes = str.asQuotedUTF8();\n            final int len = nameBytes.length;\n            \n            \n            if ((_inputPtr + len + 4) < _inputEnd) { \n                \n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == INT_QUOTE) {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { \n                            _parsingContext.setCurrentName(str.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameBytes[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, str);\n    }\n\n    @Override\n    public String nextFieldName() throws IOException {\n        \n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        _binaryValue = null;\n\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return null;\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return null;\n        }\n\n        \n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        final String nameStr = _parseName(i);\n        _parsingContext.setCurrentName(nameStr);\n        _currToken = JsonToken.FIELD_NAME;\n\n        i = _skipColon();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameStr;\n        }\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n\n            \n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return nameStr;\n    }\n\n    \n    private final int _skipColonFast(int ptr) throws IOException {\n        int i = _inputBuffer[ptr++];\n        if (i == INT_COLON) { \n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { \n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); \n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        if (i == INT_COLON) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(false);\n    }\n    \n    private final void _isNextTokenNameYes(int i) throws IOException {\n        _currToken = JsonToken.FIELD_NAME;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleUnexpectedValue(i);\n    }\n    \n    \n    private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException {\n        \n\n        String n = _parseName(i);\n        _parsingContext.setCurrentName(n);\n        final boolean match = n.equals(str.getValue());\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        \n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return match;\n        }\n        JsonToken t;\n\n        switch (i) {\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return match;\n    }\n\n    @Override\n    public String nextTextValue() throws IOException {\n        \n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    return _finishAndReturnString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        \n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    @Override\n    public int nextIntValue(int defaultValue) throws IOException {\n        \n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        \n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    @Override\n    public long nextLongValue(long defaultValue) throws IOException {\n        \n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        \n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    @Override\n    public Boolean nextBooleanValue() throws IOException {\n        \n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n\n        switch (nextToken().id()) {\n        case ID_TRUE:\n            return Boolean.TRUE;\n        case ID_FALSE:\n            return Boolean.FALSE;\n        default:\n            return null;\n        }\n    }\n    \n    \n\n    \n    protected JsonToken _parsePosNumber(int c) throws IOException {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        \n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        outBuf[0] = (char) c;\n        int intLen = 1;\n        int outPtr = 1;\n        \n        \n        int end = _inputPtr + outBuf.length - 1; \n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n        \n        while (true) {\n            if (_inputPtr >= end) { \n                return _parseNumber2(outBuf, outPtr, false, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloat(outBuf, outPtr, c, false, intLen);\n        }\n        --_inputPtr; \n        _textBuffer.setCurrentLength(outPtr);\n        \n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n        \n        return resetInt(false, intLen);\n    }\n    \n    protected JsonToken _parseNegNumber() throws IOException {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        \n        outBuf[outPtr++] = '-';\n        \n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        \n        if (c < INT_0 || c > INT_9) {\n            return _handleInvalidNumberStart(c, true);\n        }\n\n        \n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        \n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        \n        \n        int end = _inputPtr + outBuf.length - outPtr;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        \n        while (true) {\n            if (_inputPtr >= end) {\n                \n                return _parseNumber2(outBuf, outPtr, true, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloat(outBuf, outPtr, c, true, intLen);\n        }\n        \n        --_inputPtr; \n        _textBuffer.setCurrentLength(outPtr);\n        \n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n\n        \n        return resetInt(true, intLen);\n    }\n\n    \n    private final JsonToken _parseNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException {\n        \n        while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                _textBuffer.setCurrentLength(outPtr);\n                return resetInt(negative, intPartLength);\n            }\n            int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c > INT_9 || c < INT_0) {\n                if (c == INT_PERIOD || c == INT_e || c == INT_E) {\n                    return _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            ++intPartLength;\n        }\n        --_inputPtr; \n        _textBuffer.setCurrentLength(outPtr);\n        \n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n        }\n\n        \n        return resetInt(negative, intPartLength);\n        \n    }\n    \n    \n    private final int _verifyNoLeadingZeroes() throws IOException {\n        \n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return INT_0;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        \n        if (ch < INT_0 || ch > INT_9) {\n            return INT_0;\n        }\n        \n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        \n        ++_inputPtr; \n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr] & 0xFF;\n                if (ch < INT_0 || ch > INT_9) { \n                    return INT_0;\n                }\n                ++_inputPtr; \n                if (ch != INT_0) { \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n    \n    private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException {\n        int fractLen = 0;\n        boolean eof = false;\n\n        \n        if (c == INT_PERIOD) { \n            outBuf[outPtr++] = (char) c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n            }\n            \n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == INT_e || c == INT_E) { \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            \n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                \n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n            \n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        \n        if (!eof) {\n            --_inputPtr;\n            \n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        \n        return resetFloat(negative, integerPartLength, fractLen, expLen);\n    }\n\n    \n    private final void _verifyRootSpace(int ch) throws IOException {\n        \n        ++_inputPtr;\n        \n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    \n    \n    protected final String _parseName(int i) throws IOException {\n        if (i != INT_QUOTE) {\n            return _handleOddName(i);\n        }\n        \n        if ((_inputPtr + 13) > _inputEnd) { \n            return slowParseName();\n        }\n\n        \n        \n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumName(i);\n                        }\n                        if (i == INT_QUOTE) { \n                            return findName(q, 4);\n                        }\n                        return parseName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { \n                        return findName(q, 3);\n                    }\n                    return parseName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { \n                    return findName(q, 2);\n                }\n                return parseName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { \n                return findName(q, 1);\n            }\n            return parseName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { \n            return \"\";\n        }\n        return parseName(0, q, 0); \n    }\n\n    protected final String parseMediumName(int q2) throws IOException {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        \n        int i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                return findName(_quad1, q2, 1);\n            }\n            return parseName(_quad1, q2, i, 1); \n        }\n        q2 = (q2 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                return findName(_quad1, q2, 2);\n            }\n            return parseName(_quad1, q2, i, 2);\n        }\n        q2 = (q2 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                return findName(_quad1, q2, 3);\n            }\n            return parseName(_quad1, q2, i, 3);\n        }\n        q2 = (q2 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                return findName(_quad1, q2, 4);\n            }\n            return parseName(_quad1, q2, i, 4);\n        }\n        return parseMediumName2(i, q2);\n    }\n\n    \n    protected final String parseMediumName2(int q3, final int q2) throws IOException {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        \n        int i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                return findName(_quad1, q2, q3, 1);\n            }\n            return parseName(_quad1, q2, q3, i, 1);\n        }\n        q3 = (q3 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                return findName(_quad1, q2, q3, 2);\n            }\n            return parseName(_quad1, q2, q3, i, 2);\n        }\n        q3 = (q3 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                return findName(_quad1, q2, q3, 3);\n            }\n            return parseName(_quad1, q2, q3, i, 3);\n        }\n        q3 = (q3 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                return findName(_quad1, q2, q3, 4);\n            }\n            return parseName(_quad1, q2, q3, i, 4);\n        }\n        return parseLongName(i, q2, q3);\n    }\n    \n    protected final String parseLongName(int q, final int q2, int q3) throws IOException {\n        _quadBuffer[0] = _quad1;\n        _quadBuffer[1] = q2;\n        _quadBuffer[2] = q3;\n\n        \n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n        int qlen = 3;\n\n        while ((_inputPtr + 4) <= _inputEnd) {\n            int i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 2);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            \n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n\n        \n        return parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n    }\n\n    \n    protected String slowParseName() throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\\"' for name\");\n            }\n        }\n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (i == INT_QUOTE) { \n            return \"\";\n        }\n        return parseEscapedName(_quadBuffer, 0, 0, i, 0);\n    }\n\n    private final String parseName(int q1, int ch, int lastQuadBytes) throws IOException {\n        return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n    }\n\n    private final String parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException {\n        _quadBuffer[0] = q1;\n        return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n    }\n\n    private final String parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException {\n        _quadBuffer[0] = q1;\n        _quadBuffer[1] = q2;\n        return parseEscapedName(_quadBuffer, 2, q3, ch, lastQuadBytes);\n    }\n    \n    \n    protected final String parseEscapedName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException {\n        \n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (codes[ch] != 0) {\n                if (ch == INT_QUOTE) { \n                    break;\n                }\n                \n                if (ch != INT_BACKSLASH) {\n                    \n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    \n                    ch = _decodeEscaped();\n                }\n                \n                if (ch > 127) {\n                    \n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { \n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        \n                    } else { \n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        \n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    \n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            \n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = pad(currQuad, currQuadBytes);\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    \n    protected String _handleOddName(int ch) throws IOException {\n        \n        if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        \n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            char c = (char) _decodeCharForError(ch);\n            _reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n        }\n        \n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n        \n        if (codes[ch] != 0) {\n            _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n\n        \n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        while (true) {\n            \n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (codes[ch] != 0) {\n                break;\n            }\n            ++_inputPtr;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    \n    protected String _parseAposName() throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == '\\'') { \n            return \"\";\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        \n\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (ch == '\\'') {\n                break;\n            }\n            \n            if (ch != '\"' && codes[ch] != 0) {\n                if (ch != '\\\\') {\n                    \n                    \n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    \n                    ch = _decodeEscaped();\n                }\n                \n                if (ch > 127) {\n                    \n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { \n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        \n                    } else { \n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        \n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    \n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            \n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = pad(currQuad, currQuadBytes);\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    \n\n    private final String findName(int q1, int lastQuadBytes) throws JsonParseException {\n        q1 = pad(q1, lastQuadBytes);\n        \n        String name = _symbols.findName(q1);\n        if (name != null) {\n            return name;\n        }\n        \n        _quadBuffer[0] = q1;\n        return addName(_quadBuffer, 1, lastQuadBytes);\n    }\n\n    private final String findName(int q1, int q2, int lastQuadBytes) throws JsonParseException {\n        q2 = pad(q2, lastQuadBytes);\n        \n        String name = _symbols.findName(q1, q2);\n        if (name != null) {\n            return name;\n        }\n        \n        _quadBuffer[0] = q1;\n        _quadBuffer[1] = q2;\n        return addName(_quadBuffer, 2, lastQuadBytes);\n    }\n\n    private final String findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException {\n        q3 = pad(q3, lastQuadBytes);\n        String name = _symbols.findName(q1, q2, q3);\n        if (name != null) {\n            return name;\n        }\n        int[] quads = _quadBuffer;\n        quads[0] = q1;\n        quads[1] = q2;\n        quads[2] = pad(q3, lastQuadBytes);\n        return addName(quads, 3, lastQuadBytes);\n    }\n    \n    private final String findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException {\n        if (qlen >= quads.length) {\n            _quadBuffer = quads = growArrayBy(quads, quads.length);\n        }\n        quads[qlen++] = pad(lastQuad, lastQuadBytes);\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            return addName(quads, qlen, lastQuadBytes);\n        }\n        return name;\n    }\n\n    \n    private final String addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException {\n        \n        \n        int byteLen = (qlen << 2) - 4 + lastQuadBytes;\n\n        \n        int lastQuad;\n\n        if (lastQuadBytes < 4) {\n            lastQuad = quads[qlen-1];\n            \n            quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\n        } else {\n            lastQuad = 0;\n        }\n\n        \n        char[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\n        int cix = 0;\n\n        for (int ix = 0; ix < byteLen; ) {\n            int ch = quads[ix >> 2]; \n            int byteIx = (ix & 3);\n            ch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n            ++ix;\n\n            if (ch > 127) { \n                int needed;\n                if ((ch & 0xE0) == 0xC0) { \n                    ch &= 0x1F;\n                    needed = 1;\n                } else if ((ch & 0xF0) == 0xE0) { \n                    ch &= 0x0F;\n                    needed = 2;\n                } else if ((ch & 0xF8) == 0xF0) { \n                    ch &= 0x07;\n                    needed = 3;\n                } else { \n                    _reportInvalidInitial(ch);\n                    needed = ch = 1; \n                }\n                if ((ix + needed) > byteLen) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n                \n                \n                int ch2 = quads[ix >> 2]; \n                byteIx = (ix & 3);\n                ch2 = (ch2 >> ((3 - byteIx) << 3));\n                ++ix;\n                \n                if ((ch2 & 0xC0) != 0x080) {\n                    _reportInvalidOther(ch2);\n                }\n                ch = (ch << 6) | (ch2 & 0x3F);\n                if (needed > 1) {\n                    ch2 = quads[ix >> 2];\n                    byteIx = (ix & 3);\n                    ch2 = (ch2 >> ((3 - byteIx) << 3));\n                    ++ix;\n                    \n                    if ((ch2 & 0xC0) != 0x080) {\n                        _reportInvalidOther(ch2);\n                    }\n                    ch = (ch << 6) | (ch2 & 0x3F);\n                    if (needed > 2) { \n                        ch2 = quads[ix >> 2];\n                        byteIx = (ix & 3);\n                        ch2 = (ch2 >> ((3 - byteIx) << 3));\n                        ++ix;\n                        if ((ch2 & 0xC0) != 0x080) {\n                            _reportInvalidOther(ch2 & 0xFF);\n                        }\n                        ch = (ch << 6) | (ch2 & 0x3F);\n                    }\n                }\n                if (needed > 2) { \n                    ch -= 0x10000; \n                    if (cix >= cbuf.length) {\n                        cbuf = _textBuffer.expandCurrentSegment();\n                    }\n                    cbuf[cix++] = (char) (0xD800 + (ch >> 10));\n                    ch = 0xDC00 | (ch & 0x03FF);\n                }\n            }\n            if (cix >= cbuf.length) {\n                cbuf = _textBuffer.expandCurrentSegment();\n            }\n            cbuf[cix++] = (char) ch;\n        }\n\n        \n        String baseName = new String(cbuf, 0, cix);\n        \n        if (lastQuadBytes < 4) {\n            quads[qlen-1] = lastQuad;\n        }\n        return _symbols.addName(baseName, quads, qlen);\n    }\n\n    \n\n    @Override\n    protected void _finishString() throws IOException {\n        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }\n\n    \n    protected String _finishAndReturnString() throws IOException {\n        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    return _textBuffer.setCurrentAndReturn(outPtr);\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n        return _textBuffer.contentsAsString();\n    }\n    \n    private final void _finishString2(char[] outBuf, int outPtr) throws IOException {\n        int c;\n\n        \n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            \n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                if (ptr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n                _inputPtr = ptr;\n            }\n            \n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: \n                c = _decodeEscaped();\n                break;\n            case 2: \n                c = _decodeUtf8_2(c);\n                break;\n            case 3: \n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: \n                c = _decodeUtf8_4(c);\n                \n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                \n                break;\n            default:\n                if (c < INT_SPACE) {\n                    \n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    \n                    _reportInvalidChar(c);\n                }\n            }\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            \n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    \n    protected void _skipString() throws IOException {\n        _tokenIncomplete = false;\n\n        \n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            int c;\n\n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                int max = _inputEnd;\n                if (ptr >= max) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                    max = _inputEnd;\n                }\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                }\n                _inputPtr = ptr;\n            }\n            \n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n            \n            switch (codes[c]) {\n            case 1: \n                _decodeEscaped();\n                break;\n            case 2: \n                _skipUtf8_2(c);\n                break;\n            case 3: \n                _skipUtf8_3(c);\n                break;\n            case 4: \n                _skipUtf8_4(c);\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    \n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    \n                    _reportInvalidChar(c);\n                }\n            }\n        }\n    }\n\n    \n    protected JsonToken _handleUnexpectedValue(int c) throws IOException {\n        \n        switch (c) {\n        case ']':\n        case '}':\n            \n            \n            _reportUnexpectedChar(c, \"expected a value\");\n        case '\\'':\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': \n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n        }\n        \n        if (Character.isJavaIdentifierStart(c)) {\n            _reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\");\n        }\n        \n        _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException {\n        int c = 0;\n        \n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n\n        \n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            \n            ascii_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                int max = _inputEnd;\n                {\n                    int max2 = _inputPtr + (outBuf.length - outPtr);\n                    if (max2 < max) {\n                        max = max2;\n                    }\n                }\n                while (_inputPtr < max) {\n                    c = (int) inputBuffer[_inputPtr++] & 0xFF;\n                    if (c == '\\'' || codes[c] != 0) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n\n            \n            if (c == '\\'') {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: \n                if (c != '\\'') { \n                    c = _decodeEscaped();\n                }\n                break;\n            case 2: \n                c = _decodeUtf8_2(c);\n                break;\n            case 3: \n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: \n                c = _decodeUtf8_4(c);\n                \n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                \n                break;\n            default:\n                if (c < INT_SPACE) {\n                    _throwUnquotedSpace(c, \"string value\");\n                }\n                \n                _reportInvalidChar(c);\n            }\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            \n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        return JsonToken.VALUE_STRING;\n    }\n    \n    \n    protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException {\n        while (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            String match;\n            if (ch == 'N') {\n                match = neg ? \"-INF\" :\"+INF\";\n            } else if (ch == 'n') {\n                match = neg ? \"-Infinity\" :\"+Infinity\";\n            } else {\n                break;\n            }\n            _matchToken(match, 3);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    protected final void _matchToken(String matchStr, int i) throws IOException {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        if (ch >= '0' && ch != ']' && ch != '}') { \n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        \n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        if (ch >= '0' && ch != ']' && ch != '}') { \n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int ch) throws IOException {\n        \n        char c = (char) _decodeCharForError(ch);\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n    \n    \n\n    private final int _skipWS() throws IOException {\n        while (_inputPtr < _inputEnd) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWS2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWS2();\n    }\n\n    private final int _skipWS2() throws IOException {\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }        \n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n    \n    private final int _skipWSOrEnd() throws IOException {\n        \n        \n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n        \n        while (_inputPtr < _inputEnd) {\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private final int _skipWSOrEnd2() throws IOException {\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        \n        return _eofAsNextChar();\n    }\n\n    private final int _skipColon() throws IOException {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        \n        int i = _inputBuffer[_inputPtr];\n        if (i == INT_COLON) { \n            i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { \n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;                    \n                    return i;\n                }\n            }\n            return _skipColon2(true); \n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[++_inputPtr];\n        }\n        if (i == INT_COLON) {\n            i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n    \n    private final int _skipColon2(boolean gotColon) throws IOException {\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    if (i < INT_SPACE) {\n                        _throwInvalidSpace(i);\n                    }\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private final void _skipComment() throws IOException {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        \n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        int c = _inputBuffer[_inputPtr++] & 0xFF;\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private final void _skipCComment() throws IOException {\n        \n        final int[] codes = CharTypes.getInputCodeComment();\n\n        \n        main_loop:\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case '*':\n                    if (_inputPtr >= _inputEnd && !loadMore()) {\n                        break main_loop;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    break;\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                case INT_CR:\n                    _skipCR();\n                    break;\n                case 2: \n                    _skipUtf8_2(i);\n                    break;\n                case 3: \n                    _skipUtf8_3(i);\n                    break;\n                case 4: \n                    _skipUtf8_4(i);\n                    break;\n                default: \n                    \n                    _reportInvalidChar(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private final boolean _skipYAMLComment() throws IOException {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    \n    private final void _skipLine() throws IOException {\n        \n        final int[] codes = CharTypes.getInputCodeComment();\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    return;\n                case INT_CR:\n                    _skipCR();\n                    return;\n                case '*': \n                    break;\n                case 2: \n                    _skipUtf8_2(i);\n                    break;\n                case 3: \n                    _skipUtf8_3(i);\n                    break;\n                case 4: \n                    _skipUtf8_4(i);\n                    break;\n                default: \n                    if (code < 0) {\n                        \n                        _reportInvalidChar(i);\n                    }\n                }\n            }\n        }\n    }\n    \n    @Override\n    protected char _decodeEscaped() throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        int c = (int) _inputBuffer[_inputPtr++];\n\n        switch (c) {\n            \n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            \n        case '\"':\n        case '/':\n        case '\\\\':\n            return (char) c;\n\n        case 'u': \n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c));\n        }\n\n        \n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    protected int _decodeCharForError(int firstByte) throws IOException {\n        int c = firstByte & 0xFF;\n        if (c > 0x7F) { \n            int needed;\n            \n            \n            if ((c & 0xE0) == 0xC0) { \n                c &= 0x1F;\n                needed = 1;\n            } else if ((c & 0xF0) == 0xE0) { \n                c &= 0x0F;\n                needed = 2;\n            } else if ((c & 0xF8) == 0xF0) {\n                \n                c &= 0x07;\n                needed = 3;\n            } else {\n                _reportInvalidInitial(c & 0xFF);\n                needed = 1; \n            }\n\n            int d = nextByte();\n            if ((d & 0xC0) != 0x080) {\n                _reportInvalidOther(d & 0xFF);\n            }\n            c = (c << 6) | (d & 0x3F);\n            \n            if (needed > 1) { \n                d = nextByte(); \n                if ((d & 0xC0) != 0x080) {\n                    _reportInvalidOther(d & 0xFF);\n                }\n                c = (c << 6) | (d & 0x3F);\n                if (needed > 2) { \n                    d = nextByte();\n                    if ((d & 0xC0) != 0x080) {\n                        _reportInvalidOther(d & 0xFF);\n                    }\n                    c = (c << 6) | (d & 0x3F);\n                }\n            }\n        }\n        return c;\n    }\n\n    \n\n    private final int _decodeUtf8_2(int c) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        return ((c & 0x1F) << 6) | (d & 0x3F);\n    }\n\n    private final int _decodeUtf8_3(int c1) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    private final int _decodeUtf8_3fast(int c1) throws IOException {\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    \n    private final int _decodeUtf8_4(int c) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = ((c & 0x07) << 6) | (d & 0x3F);\n\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n\n        \n        return ((c << 6) | (d & 0x3F)) - 0x10000;\n    }\n\n    private final void _skipUtf8_2(int c) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    \n    private final void _skipUtf8_3(int c) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        \n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    private final void _skipUtf8_4(int c) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n    }\n\n    \n\n    \n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == BYTE_LF) {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n        private int nextByte() throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        return _inputBuffer[_inputPtr++] & 0xFF;\n    }\n\n    \n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n         _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n     }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException {\n         StringBuilder sb = new StringBuilder(matchedPart);\n\n         \n         while (true) {\n             if (_inputPtr >= _inputEnd && !loadMore()) {\n                 break;\n             }\n             int i = (int) _inputBuffer[_inputPtr++];\n             char c = (char) _decodeCharForError(i);\n             if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n             }\n             sb.append(c);\n         }\n         _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n     }\n        \n    protected void _reportInvalidChar(int c) throws JsonParseException {\n        \n        if (c < INT_SPACE) {\n            _throwInvalidSpace(c);\n        }\n        _reportInvalidInitial(c);\n    }\n\n    protected void _reportInvalidInitial(int mask) throws JsonParseException {\n        _reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask) throws JsonParseException {\n        _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException {\n        _inputPtr = ptr;\n        _reportInvalidOther(mask);\n    }\n\n    public static int[] growArrayBy(int[] arr, int more) {\n        if (arr == null) {\n            return new int[more];\n        }\n        return Arrays.copyOf(arr, arr.length + more);\n    }\n\n    \n\n    \n    @SuppressWarnings(\"resource\")\n    protected final byte[] _decodeBase64(Base64Variant b64variant) throws IOException {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        \n        while (true) {\n            \n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { \n                if (ch == INT_QUOTE) {\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { \n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            \n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            \n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    \n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    \n\n    \n    private final static int pad(int q, int bytes) {\n        return (bytes == 4) ? q : (q | (-1 << (bytes << 3)));\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.util.Arrays;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*; public class UTF8StreamJsonParser extends ParserBase { final static byte BYTE_LF = (byte) '\\n'; private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8(); protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); protected ObjectCodec _objectCodec; final protected ByteQuadsCanonicalizer _symbols; protected int[] _quadBuffer = new int[16]; protected boolean _tokenIncomplete = false; private int _quad1; protected InputStream _inputStream; protected byte[] _inputBuffer; protected boolean _bufferRecyclable; public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, ByteQuadsCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable) {\n        super(ctxt, features);\n        _inputStream = in;\n        _objectCodec = codec;\n        _symbols = sym;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _currInputRowStart = start;\n        \n        _currInputProcessed = -start;\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n    \n    \n\n    @Override\n    public int releaseBuffered(OutputStream out) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n            return 0;\n        }\n        \n        int origPtr = _inputPtr;\n        out.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override\n    public Object getInputSource() {\n        return _inputStream;\n    }\n    \n    \n\n    @Override\n    protected final boolean loadMore() throws IOException {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n        \n        if (_inputStream != null) {\n            int space = _inputBuffer.length;\n            if (space == 0) { \n                return false;\n            }\n            \n            int count = _inputStream.read(_inputBuffer, 0, space);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            \n            _closeInput();\n            \n            if (count == 0) {\n                throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\");\n            }\n        }\n        return false;\n    }\n\n    \n    protected final boolean _loadToHaveAtLeast(int minAvailable) throws IOException {\n        \n        if (_inputStream == null) {\n            return false;\n        }\n        \n        int amount = _inputEnd - _inputPtr;\n        if (amount > 0 && _inputPtr > 0) {\n            _currInputProcessed += _inputPtr;\n            _currInputRowStart -= _inputPtr;\n            System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount);\n            _inputEnd = amount;\n        } else {\n            _inputEnd = 0;\n        }\n        _inputPtr = 0;\n        while (_inputEnd < minAvailable) {\n            int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);\n            if (count < 1) {\n                \n                _closeInput();\n                \n                if (count == 0) {\n                    throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\");\n                }\n                return false;\n            }\n            _inputEnd += count;\n        }\n        return true;\n    }\n    \n    @Override\n    protected void _closeInput() throws IOException {\n        \n        if (_inputStream != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _inputStream.close();\n            }\n            _inputStream = null;\n        }\n    }\n\n    \n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        \n        _symbols.release();\n        if (_bufferRecyclable) {\n            byte[] buf = _inputBuffer;\n            if (buf != null) {\n                \n                _inputBuffer = ByteArrayBuilder.NO_BYTES;\n                _ioContext.releaseReadIOBuffer(buf);\n            }\n        }\n    }\n\n    \n\n    @Override\n    public String getText() throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); \n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(_currToken);\n    }\n\n    \n    \n    \n    @Override\n    public String getValueAsString() throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); \n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    \n    @Override\n    public String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); \n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    \n    @Override\n    public int getValueAsInt() throws IOException {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            \n            if ((_numTypesValid & NR_INT) == 0) {\n                if (_numTypesValid == NR_UNKNOWN) {\n                    return _parseIntValue();\n                }\n                if ((_numTypesValid & NR_INT) == 0) {\n                    convertNumberToInt();\n                }\n            }\n            return _numberInt;\n        }\n        return super.getValueAsInt(0);\n    }\n\n    \n    @Override\n    public int getValueAsInt(int defValue) throws IOException {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            \n            if ((_numTypesValid & NR_INT) == 0) {\n                if (_numTypesValid == NR_UNKNOWN) {\n                    return _parseIntValue();\n                }\n                if ((_numTypesValid & NR_INT) == 0) {\n                    convertNumberToInt();\n                }\n            }\n            return _numberInt;\n        }\n        return super.getValueAsInt(defValue);\n    }\n    \n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            \n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n        \treturn t.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters() throws IOException {\n        if (_currToken != null) { \n            switch (_currToken.id()) {\n                \n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); \n                }\n                \n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public int getTextLength() throws IOException {\n        if (_currToken != null) { \n            switch (_currToken.id()) {\n                \n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); \n                }\n                \n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public int getTextOffset() throws IOException {\n        \n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); \n                }\n                \n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n    \n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        \n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            \n            _tokenIncomplete = false;\n        } else { \n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException {\n        \n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        \n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            \n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { \n                if (ch == INT_QUOTE) {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { \n                    continue;\n                }\n            }\n\n            \n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            \n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            \n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    \n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    \n    @Override\n    public JsonLocation getTokenLocation() {\n        return new JsonLocation(_ioContext.getSourceReference(),\n                getTokenCharacterOffset(), -1L, \n                getTokenLineNr(),\n                getTokenColumnNr());\n    }\n\n    \n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; \n        return new JsonLocation(_ioContext.getSourceReference(),\n                _currInputProcessed + _inputPtr, -1L, \n                _currInputRow, col);\n    }\n    \n    \n\n    \n    @Override\n    public JsonToken nextToken() throws IOException {\n        _numTypesValid = NR_UNKNOWN;\n        \n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        if (_tokenIncomplete) {\n            _skipString(); \n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { \n            \n            close();\n            return (_currToken = null);\n        }\n\n        \n        \n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        \n        _binaryValue = null;\n\n        \n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        \n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        \n        if (!_parsingContext.inObject()) {\n            return _nextTokenNotInObject(i);\n        }\n        \n        String n = _parseName(i);\n        _parsingContext.setCurrentName(n);\n        _currToken = JsonToken.FIELD_NAME;\n\n        i = _skipColon();\n\n        \n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return _currToken;\n        }        \n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n\n            \n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return _currToken;\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            \n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        }\n        return (_currToken = _handleUnexpectedValue(i));\n    }\n    \n    private final JsonToken _nextAfterName() {\n        _nameCopied = false; \n        JsonToken t = _nextToken;\n        _nextToken = null;\n        \n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n    \n    \n\n    @Override\n    public boolean nextFieldName(SerializableString str) throws IOException {\n        \n        \n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { \n            close();\n            _currToken = null;\n            return false;\n        }\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        \n        _binaryValue = null;\n\n        \n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return false;\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return false;\n        }\n\n        \n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return false;\n        }\n        \n        \n        if (i == INT_QUOTE) {\n            \n            byte[] nameBytes = str.asQuotedUTF8();\n            final int len = nameBytes.length;\n            \n            \n            if ((_inputPtr + len + 4) < _inputEnd) { \n                \n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == INT_QUOTE) {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { \n                            _parsingContext.setCurrentName(str.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameBytes[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, str);\n    }\n\n    @Override\n    public String nextFieldName() throws IOException {\n        \n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        _binaryValue = null;\n\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return null;\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return null;\n        }\n\n        \n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        final String nameStr = _parseName(i);\n        _parsingContext.setCurrentName(nameStr);\n        _currToken = JsonToken.FIELD_NAME;\n\n        i = _skipColon();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameStr;\n        }\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n\n            \n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return nameStr;\n    }\n\n    \n    private final int _skipColonFast(int ptr) throws IOException {\n        int i = _inputBuffer[ptr++];\n        if (i == INT_COLON) { \n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { \n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); \n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        if (i == INT_COLON) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(false);\n    }\n    \n    private final void _isNextTokenNameYes(int i) throws IOException {\n        _currToken = JsonToken.FIELD_NAME;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleUnexpectedValue(i);\n    }\n    \n    \n    private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException {\n        \n\n        String n = _parseName(i);\n        _parsingContext.setCurrentName(n);\n        final boolean match = n.equals(str.getValue());\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        \n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return match;\n        }\n        JsonToken t;\n\n        switch (i) {\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return match;\n    }\n\n    @Override\n    public String nextTextValue() throws IOException {\n        \n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    return _finishAndReturnString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        \n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    @Override\n    public int nextIntValue(int defaultValue) throws IOException {\n        \n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        \n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    @Override\n    public long nextLongValue(long defaultValue) throws IOException {\n        \n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        \n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    @Override\n    public Boolean nextBooleanValue() throws IOException {\n        \n        if (_currToken == JsonToken.FIELD_NAME) { \n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n\n        switch (nextToken().id()) {\n        case ID_TRUE:\n            return Boolean.TRUE;\n        case ID_FALSE:\n            return Boolean.FALSE;\n        default:\n            return null;\n        }\n    }\n    \n    \n\n    \n    protected JsonToken _parsePosNumber(int c) throws IOException {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        \n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        outBuf[0] = (char) c;\n        int intLen = 1;\n        int outPtr = 1;\n        \n        \n        int end = _inputPtr + outBuf.length - 1; \n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n        \n        while (true) {\n            if (_inputPtr >= end) { \n                return _parseNumber2(outBuf, outPtr, false, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloat(outBuf, outPtr, c, false, intLen);\n        }\n        --_inputPtr; \n        _textBuffer.setCurrentLength(outPtr);\n        \n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n        \n        return resetInt(false, intLen);\n    }\n    \n    protected JsonToken _parseNegNumber() throws IOException {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        \n        outBuf[outPtr++] = '-';\n        \n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        \n        if (c < INT_0 || c > INT_9) {\n            return _handleInvalidNumberStart(c, true);\n        }\n\n        \n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        \n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        \n        \n        int end = _inputPtr + outBuf.length - outPtr;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        \n        while (true) {\n            if (_inputPtr >= end) {\n                \n                return _parseNumber2(outBuf, outPtr, true, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloat(outBuf, outPtr, c, true, intLen);\n        }\n        \n        --_inputPtr; \n        _textBuffer.setCurrentLength(outPtr);\n        \n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n\n        \n        return resetInt(true, intLen);\n    }\n\n    \n    private final JsonToken _parseNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException {\n        \n        while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                _textBuffer.setCurrentLength(outPtr);\n                return resetInt(negative, intPartLength);\n            }\n            int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c > INT_9 || c < INT_0) {\n                if (c == INT_PERIOD || c == INT_e || c == INT_E) {\n                    return _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            ++intPartLength;\n        }\n        --_inputPtr; \n        _textBuffer.setCurrentLength(outPtr);\n        \n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n        }\n\n        \n        return resetInt(negative, intPartLength);\n        \n    }\n    \n    \n    private final int _verifyNoLeadingZeroes() throws IOException {\n        \n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return INT_0;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        \n        if (ch < INT_0 || ch > INT_9) {\n            return INT_0;\n        }\n        \n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        \n        ++_inputPtr; \n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr] & 0xFF;\n                if (ch < INT_0 || ch > INT_9) { \n                    return INT_0;\n                }\n                ++_inputPtr; \n                if (ch != INT_0) { \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n    \n    private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException {\n        int fractLen = 0;\n        boolean eof = false;\n\n        \n        if (c == INT_PERIOD) { \n            outBuf[outPtr++] = (char) c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n            }\n            \n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == INT_e || c == INT_E) { \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            \n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                \n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n            \n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        \n        if (!eof) {\n            --_inputPtr;\n            \n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        \n        return resetFloat(negative, integerPartLength, fractLen, expLen);\n    }\n\n    \n    private final void _verifyRootSpace(int ch) throws IOException {\n        \n        ++_inputPtr;\n        \n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    \n    \n    protected final String _parseName(int i) throws IOException {\n        if (i != INT_QUOTE) {\n            return _handleOddName(i);\n        }\n        \n        if ((_inputPtr + 13) > _inputEnd) { \n            return slowParseName();\n        }\n\n        \n        \n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumName(i);\n                        }\n                        if (i == INT_QUOTE) { \n                            return findName(q, 4);\n                        }\n                        return parseName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { \n                        return findName(q, 3);\n                    }\n                    return parseName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { \n                    return findName(q, 2);\n                }\n                return parseName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { \n                return findName(q, 1);\n            }\n            return parseName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { \n            return \"\";\n        }\n        return parseName(0, q, 0); \n    }\n\n    protected final String parseMediumName(int q2) throws IOException {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        \n        int i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                return findName(_quad1, q2, 1);\n            }\n            return parseName(_quad1, q2, i, 1); \n        }\n        q2 = (q2 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                return findName(_quad1, q2, 2);\n            }\n            return parseName(_quad1, q2, i, 2);\n        }\n        q2 = (q2 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                return findName(_quad1, q2, 3);\n            }\n            return parseName(_quad1, q2, i, 3);\n        }\n        q2 = (q2 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                return findName(_quad1, q2, 4);\n            }\n            return parseName(_quad1, q2, i, 4);\n        }\n        return parseMediumName2(i, q2);\n    }\n\n    \n    protected final String parseMediumName2(int q3, final int q2) throws IOException {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        \n        int i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                return findName(_quad1, q2, q3, 1);\n            }\n            return parseName(_quad1, q2, q3, i, 1);\n        }\n        q3 = (q3 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                return findName(_quad1, q2, q3, 2);\n            }\n            return parseName(_quad1, q2, q3, i, 2);\n        }\n        q3 = (q3 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                return findName(_quad1, q2, q3, 3);\n            }\n            return parseName(_quad1, q2, q3, i, 3);\n        }\n        q3 = (q3 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { \n                return findName(_quad1, q2, q3, 4);\n            }\n            return parseName(_quad1, q2, q3, i, 4);\n        }\n        return parseLongName(i, q2, q3);\n    }\n    \n    protected final String parseLongName(int q, final int q2, int q3) throws IOException {\n        _quadBuffer[0] = _quad1;\n        _quadBuffer[1] = q2;\n        _quadBuffer[2] = q3;\n\n        \n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n        int qlen = 3;\n\n        while ((_inputPtr + 4) <= _inputEnd) {\n            int i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 2);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            \n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n\n        \n        return parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n    }\n\n    \n    protected String slowParseName() throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\\"' for name\");\n            }\n        }\n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (i == INT_QUOTE) { \n            return \"\";\n        }\n        return parseEscapedName(_quadBuffer, 0, 0, i, 0);\n    }\n\n    private final String parseName(int q1, int ch, int lastQuadBytes) throws IOException {\n        return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n    }\n\n    private final String parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException {\n        _quadBuffer[0] = q1;\n        return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n    }\n\n    private final String parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException {\n        _quadBuffer[0] = q1;\n        _quadBuffer[1] = q2;\n        return parseEscapedName(_quadBuffer, 2, q3, ch, lastQuadBytes);\n    }\n    \n    \n    protected final String parseEscapedName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException {\n        \n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (codes[ch] != 0) {\n                if (ch == INT_QUOTE) { \n                    break;\n                }\n                \n                if (ch != INT_BACKSLASH) {\n                    \n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    \n                    ch = _decodeEscaped();\n                }\n                \n                if (ch > 127) {\n                    \n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { \n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        \n                    } else { \n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        \n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    \n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            \n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = pad(currQuad, currQuadBytes);\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    \n    protected String _handleOddName(int ch) throws IOException {\n        \n        if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        \n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            char c = (char) _decodeCharForError(ch);\n            _reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n        }\n        \n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n        \n        if (codes[ch] != 0) {\n            _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n\n        \n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        while (true) {\n            \n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (codes[ch] != 0) {\n                break;\n            }\n            ++_inputPtr;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    \n    protected String _parseAposName() throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == '\\'') { \n            return \"\";\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        \n\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (ch == '\\'') {\n                break;\n            }\n            \n            if (ch != '\"' && codes[ch] != 0) {\n                if (ch != '\\\\') {\n                    \n                    \n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    \n                    ch = _decodeEscaped();\n                }\n                \n                if (ch > 127) {\n                    \n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { \n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        \n                    } else { \n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        \n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    \n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            \n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = pad(currQuad, currQuadBytes);\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    \n\n    private final String findName(int q1, int lastQuadBytes) throws JsonParseException {\n        q1 = pad(q1, lastQuadBytes);\n        \n        String name = _symbols.findName(q1);\n        if (name != null) {\n            return name;\n        }\n        \n        _quadBuffer[0] = q1;\n        return addName(_quadBuffer, 1, lastQuadBytes);\n    }\n\n    private final String findName(int q1, int q2, int lastQuadBytes) throws JsonParseException {\n        q2 = pad(q2, lastQuadBytes);\n        \n        String name = _symbols.findName(q1, q2);\n        if (name != null) {\n            return name;\n        }\n        \n        _quadBuffer[0] = q1;\n        _quadBuffer[1] = q2;\n        return addName(_quadBuffer, 2, lastQuadBytes);\n    }\n\n    private final String findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException {\n        q3 = pad(q3, lastQuadBytes);\n        String name = _symbols.findName(q1, q2, q3);\n        if (name != null) {\n            return name;\n        }\n        int[] quads = _quadBuffer;\n        quads[0] = q1;\n        quads[1] = q2;\n        quads[2] = pad(q3, lastQuadBytes);\n        return addName(quads, 3, lastQuadBytes);\n    }\n    \n    private final String findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException {\n        if (qlen >= quads.length) {\n            _quadBuffer = quads = growArrayBy(quads, quads.length);\n        }\n        quads[qlen++] = pad(lastQuad, lastQuadBytes);\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            return addName(quads, qlen, lastQuadBytes);\n        }\n        return name;\n    }\n\n    \n    private final String addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException {\n        \n        \n        int byteLen = (qlen << 2) - 4 + lastQuadBytes;\n\n        \n        int lastQuad;\n\n        if (lastQuadBytes < 4) {\n            lastQuad = quads[qlen-1];\n            \n            quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\n        } else {\n            lastQuad = 0;\n        }\n\n        \n        char[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\n        int cix = 0;\n\n        for (int ix = 0; ix < byteLen; ) {\n            int ch = quads[ix >> 2]; \n            int byteIx = (ix & 3);\n            ch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n            ++ix;\n\n            if (ch > 127) { \n                int needed;\n                if ((ch & 0xE0) == 0xC0) { \n                    ch &= 0x1F;\n                    needed = 1;\n                } else if ((ch & 0xF0) == 0xE0) { \n                    ch &= 0x0F;\n                    needed = 2;\n                } else if ((ch & 0xF8) == 0xF0) { \n                    ch &= 0x07;\n                    needed = 3;\n                } else { \n                    _reportInvalidInitial(ch);\n                    needed = ch = 1; \n                }\n                if ((ix + needed) > byteLen) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n                \n                \n                int ch2 = quads[ix >> 2]; \n                byteIx = (ix & 3);\n                ch2 = (ch2 >> ((3 - byteIx) << 3));\n                ++ix;\n                \n                if ((ch2 & 0xC0) != 0x080) {\n                    _reportInvalidOther(ch2);\n                }\n                ch = (ch << 6) | (ch2 & 0x3F);\n                if (needed > 1) {\n                    ch2 = quads[ix >> 2];\n                    byteIx = (ix & 3);\n                    ch2 = (ch2 >> ((3 - byteIx) << 3));\n                    ++ix;\n                    \n                    if ((ch2 & 0xC0) != 0x080) {\n                        _reportInvalidOther(ch2);\n                    }\n                    ch = (ch << 6) | (ch2 & 0x3F);\n                    if (needed > 2) { \n                        ch2 = quads[ix >> 2];\n                        byteIx = (ix & 3);\n                        ch2 = (ch2 >> ((3 - byteIx) << 3));\n                        ++ix;\n                        if ((ch2 & 0xC0) != 0x080) {\n                            _reportInvalidOther(ch2 & 0xFF);\n                        }\n                        ch = (ch << 6) | (ch2 & 0x3F);\n                    }\n                }\n                if (needed > 2) { \n                    ch -= 0x10000; \n                    if (cix >= cbuf.length) {\n                        cbuf = _textBuffer.expandCurrentSegment();\n                    }\n                    cbuf[cix++] = (char) (0xD800 + (ch >> 10));\n                    ch = 0xDC00 | (ch & 0x03FF);\n                }\n            }\n            if (cix >= cbuf.length) {\n                cbuf = _textBuffer.expandCurrentSegment();\n            }\n            cbuf[cix++] = (char) ch;\n        }\n\n        \n        String baseName = new String(cbuf, 0, cix);\n        \n        if (lastQuadBytes < 4) {\n            quads[qlen-1] = lastQuad;\n        }\n        return _symbols.addName(baseName, quads, qlen);\n    }\n\n    \n\n    @Override\n    protected void _finishString() throws IOException {\n        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }\n\n    \n    protected String _finishAndReturnString() throws IOException {\n        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    return _textBuffer.setCurrentAndReturn(outPtr);\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n        return _textBuffer.contentsAsString();\n    }\n    \n    private final void _finishString2(char[] outBuf, int outPtr) throws IOException {\n        int c;\n\n        \n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            \n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                if (ptr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n                _inputPtr = ptr;\n            }\n            \n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: \n                c = _decodeEscaped();\n                break;\n            case 2: \n                c = _decodeUtf8_2(c);\n                break;\n            case 3: \n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: \n                c = _decodeUtf8_4(c);\n                \n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                \n                break;\n            default:\n                if (c < INT_SPACE) {\n                    \n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    \n                    _reportInvalidChar(c);\n                }\n            }\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            \n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    \n    protected void _skipString() throws IOException {\n        _tokenIncomplete = false;\n\n        \n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            int c;\n\n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                int max = _inputEnd;\n                if (ptr >= max) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                    max = _inputEnd;\n                }\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                }\n                _inputPtr = ptr;\n            }\n            \n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n            \n            switch (codes[c]) {\n            case 1: \n                _decodeEscaped();\n                break;\n            case 2: \n                _skipUtf8_2(c);\n                break;\n            case 3: \n                _skipUtf8_3(c);\n                break;\n            case 4: \n                _skipUtf8_4(c);\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    \n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    \n                    _reportInvalidChar(c);\n                }\n            }\n        }\n    }\n\n    \n    protected JsonToken _handleUnexpectedValue(int c) throws IOException {\n        \n        switch (c) {\n        case ']':\n        case '}':\n            \n            \n            _reportUnexpectedChar(c, \"expected a value\");\n        case '\\'':\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': \n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n        }\n        \n        if (Character.isJavaIdentifierStart(c)) {\n            _reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\");\n        }\n        \n        _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException {\n        int c = 0;\n        \n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n\n        \n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            \n            ascii_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                int max = _inputEnd;\n                {\n                    int max2 = _inputPtr + (outBuf.length - outPtr);\n                    if (max2 < max) {\n                        max = max2;\n                    }\n                }\n                while (_inputPtr < max) {\n                    c = (int) inputBuffer[_inputPtr++] & 0xFF;\n                    if (c == '\\'' || codes[c] != 0) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n\n            \n            if (c == '\\'') {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: \n                if (c != '\\'') { \n                    c = _decodeEscaped();\n                }\n                break;\n            case 2: \n                c = _decodeUtf8_2(c);\n                break;\n            case 3: \n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: \n                c = _decodeUtf8_4(c);\n                \n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                \n                break;\n            default:\n                if (c < INT_SPACE) {\n                    _throwUnquotedSpace(c, \"string value\");\n                }\n                \n                _reportInvalidChar(c);\n            }\n            \n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            \n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        return JsonToken.VALUE_STRING;\n    }\n    \n    \n    protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException {\n        while (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            String match;\n            if (ch == 'N') {\n                match = neg ? \"-INF\" :\"+INF\";\n            } else if (ch == 'n') {\n                match = neg ? \"-Infinity\" :\"+Infinity\";\n            } else {\n                break;\n            }\n            _matchToken(match, 3);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    protected final void _matchToken(String matchStr, int i) throws IOException {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        if (ch >= '0' && ch != ']' && ch != '}') { \n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        \n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        if (ch >= '0' && ch != ']' && ch != '}') { \n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int ch) throws IOException {\n        \n        char c = (char) _decodeCharForError(ch);\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n    \n    \n\n    private final int _skipWS() throws IOException {\n        while (_inputPtr < _inputEnd) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWS2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWS2();\n    }\n\n    private final int _skipWS2() throws IOException {\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }        \n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n    \n    private final int _skipWSOrEnd() throws IOException {\n        \n        \n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n        \n        while (_inputPtr < _inputEnd) {\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private final int _skipWSOrEnd2() throws IOException {\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        \n        return _eofAsNextChar();\n    }\n\n    private final int _skipColon() throws IOException {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        \n        int i = _inputBuffer[_inputPtr];\n        if (i == INT_COLON) { \n            i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { \n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;                    \n                    return i;\n                }\n            }\n            return _skipColon2(true); \n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[++_inputPtr];\n        }\n        if (i == INT_COLON) {\n            i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n    \n    private final int _skipColon2(boolean gotColon) throws IOException {\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    if (i < INT_SPACE) {\n                        _throwInvalidSpace(i);\n                    }\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private final void _skipComment() throws IOException {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        \n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        int c = _inputBuffer[_inputPtr++] & 0xFF;\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private final void _skipCComment() throws IOException {\n        \n        final int[] codes = CharTypes.getInputCodeComment();\n\n        \n        main_loop:\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case '*':\n                    if (_inputPtr >= _inputEnd && !loadMore()) {\n                        break main_loop;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    break;\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                case INT_CR:\n                    _skipCR();\n                    break;\n                case 2: \n                    _skipUtf8_2(i);\n                    break;\n                case 3: \n                    _skipUtf8_3(i);\n                    break;\n                case 4: \n                    _skipUtf8_4(i);\n                    break;\n                default: \n                    \n                    _reportInvalidChar(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private final boolean _skipYAMLComment() throws IOException {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    \n    private final void _skipLine() throws IOException {\n        \n        final int[] codes = CharTypes.getInputCodeComment();\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    return;\n                case INT_CR:\n                    _skipCR();\n                    return;\n                case '*': \n                    break;\n                case 2: \n                    _skipUtf8_2(i);\n                    break;\n                case 3: \n                    _skipUtf8_3(i);\n                    break;\n                case 4: \n                    _skipUtf8_4(i);\n                    break;\n                default: \n                    if (code < 0) {\n                        \n                        _reportInvalidChar(i);\n                    }\n                }\n            }\n        }\n    }\n    \n    @Override\n    protected char _decodeEscaped() throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        int c = (int) _inputBuffer[_inputPtr++];\n\n        switch (c) {\n            \n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            \n        case '\"':\n        case '/':\n        case '\\\\':\n            return (char) c;\n\n        case 'u': \n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c));\n        }\n\n        \n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    protected int _decodeCharForError(int firstByte) throws IOException {\n        int c = firstByte & 0xFF;\n        if (c > 0x7F) { \n            int needed;\n            \n            \n            if ((c & 0xE0) == 0xC0) { \n                c &= 0x1F;\n                needed = 1;\n            } else if ((c & 0xF0) == 0xE0) { \n                c &= 0x0F;\n                needed = 2;\n            } else if ((c & 0xF8) == 0xF0) {\n                \n                c &= 0x07;\n                needed = 3;\n            } else {\n                _reportInvalidInitial(c & 0xFF);\n                needed = 1; \n            }\n\n            int d = nextByte();\n            if ((d & 0xC0) != 0x080) {\n                _reportInvalidOther(d & 0xFF);\n            }\n            c = (c << 6) | (d & 0x3F);\n            \n            if (needed > 1) { \n                d = nextByte(); \n                if ((d & 0xC0) != 0x080) {\n                    _reportInvalidOther(d & 0xFF);\n                }\n                c = (c << 6) | (d & 0x3F);\n                if (needed > 2) { \n                    d = nextByte();\n                    if ((d & 0xC0) != 0x080) {\n                        _reportInvalidOther(d & 0xFF);\n                    }\n                    c = (c << 6) | (d & 0x3F);\n                }\n            }\n        }\n        return c;\n    }\n\n    \n\n    private final int _decodeUtf8_2(int c) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        return ((c & 0x1F) << 6) | (d & 0x3F);\n    }\n\n    private final int _decodeUtf8_3(int c1) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    private final int _decodeUtf8_3fast(int c1) throws IOException {\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    \n    private final int _decodeUtf8_4(int c) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = ((c & 0x07) << 6) | (d & 0x3F);\n\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n\n        \n        return ((c << 6) | (d & 0x3F)) - 0x10000;\n    }\n\n    private final void _skipUtf8_2(int c) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    \n    private final void _skipUtf8_3(int c) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        \n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    private final void _skipUtf8_4(int c) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n    }\n\n    \n\n    \n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == BYTE_LF) {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n        private int nextByte() throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        return _inputBuffer[_inputPtr++] & 0xFF;\n    }\n\n    \n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n         _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n     }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException {\n         StringBuilder sb = new StringBuilder(matchedPart);\n\n         \n         while (true) {\n             if (_inputPtr >= _inputEnd && !loadMore()) {\n                 break;\n             }\n             int i = (int) _inputBuffer[_inputPtr++];\n             char c = (char) _decodeCharForError(i);\n             if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n             }\n             sb.append(c);\n         }\n         _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n     }\n        \n    protected void _reportInvalidChar(int c) throws JsonParseException {\n        \n        if (c < INT_SPACE) {\n            _throwInvalidSpace(c);\n        }\n        _reportInvalidInitial(c);\n    }\n\n    protected void _reportInvalidInitial(int mask) throws JsonParseException {\n        _reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask) throws JsonParseException {\n        _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException {\n        _inputPtr = ptr;\n        _reportInvalidOther(mask);\n    }\n\n    public static int[] growArrayBy(int[] arr, int more) {\n        if (arr == null) {\n            return new int[more];\n        }\n        return Arrays.copyOf(arr, arr.length + more);\n    }\n\n    \n\n    \n    @SuppressWarnings(\"resource\")\n    protected final byte[] _decodeBase64(Base64Variant b64variant) throws IOException {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        \n        while (true) {\n            \n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { \n                if (ch == INT_QUOTE) {\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { \n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            \n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            \n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    \n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    \n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n            }\n            \n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    \n\n    \n    private final static int pad(int q, int bytes) {\n        return (bytes == 4) ? q : (q | (-1 << (bytes << 3)));\n    }\n}\n",
      "buggy_signatures": [
        "public ObjectCodec getCodec()",
        "public void setCodec(ObjectCodec c)",
        "public int releaseBuffered(OutputStream out) throws IOException",
        "public Object getInputSource()",
        "protected final boolean loadMore() throws IOException",
        "protected final boolean _loadToHaveAtLeast(int minAvailable) throws IOException",
        "protected void _closeInput() throws IOException",
        "protected void _releaseBuffers() throws IOException",
        "public String getText() throws IOException",
        "public String getValueAsString() throws IOException",
        "public String getValueAsString(String defValue) throws IOException",
        "public int getValueAsInt() throws IOException",
        "public int getValueAsInt(int defValue) throws IOException",
        "protected final String _getText2(JsonToken t)",
        "public char[] getTextCharacters() throws IOException",
        "public int getTextLength() throws IOException",
        "public int getTextOffset() throws IOException",
        "public byte[] getBinaryValue(Base64Variant b64variant) throws IOException",
        "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException",
        "protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException",
        "public JsonLocation getTokenLocation()",
        "public JsonLocation getCurrentLocation()",
        "public JsonToken nextToken() throws IOException",
        "private final JsonToken _nextTokenNotInObject(int i) throws IOException",
        "private final JsonToken _nextAfterName()",
        "public boolean nextFieldName(SerializableString str) throws IOException",
        "public String nextFieldName() throws IOException",
        "private final int _skipColonFast(int ptr) throws IOException",
        "private final void _isNextTokenNameYes(int i) throws IOException",
        "private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException",
        "public String nextTextValue() throws IOException",
        "public int nextIntValue(int defaultValue) throws IOException",
        "public long nextLongValue(long defaultValue) throws IOException",
        "public Boolean nextBooleanValue() throws IOException",
        "protected JsonToken _parsePosNumber(int c) throws IOException",
        "protected JsonToken _parseNegNumber() throws IOException",
        "private final JsonToken _parseNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException",
        "private final int _verifyNoLeadingZeroes() throws IOException",
        "private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException",
        "private final void _verifyRootSpace(int ch) throws IOException",
        "protected final String _parseName(int i) throws IOException",
        "protected final String parseMediumName(int q2) throws IOException",
        "protected final String parseMediumName2(int q3, final int q2) throws IOException",
        "protected final String parseLongName(int q, final int q2, int q3) throws IOException",
        "protected String slowParseName() throws IOException",
        "private final String parseName(int q1, int ch, int lastQuadBytes) throws IOException",
        "private final String parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException",
        "private final String parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException",
        "protected final String parseEscapedName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException",
        "protected String _handleOddName(int ch) throws IOException",
        "protected String _parseAposName() throws IOException",
        "private final String findName(int q1, int lastQuadBytes) throws JsonParseException",
        "private final String findName(int q1, int q2, int lastQuadBytes) throws JsonParseException",
        "private final String findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException",
        "private final String findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException",
        "private final String addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException",
        "protected void _finishString() throws IOException",
        "protected String _finishAndReturnString() throws IOException",
        "private final void _finishString2(char[] outBuf, int outPtr) throws IOException",
        "protected void _skipString() throws IOException",
        "protected JsonToken _handleUnexpectedValue(int c) throws IOException",
        "protected JsonToken _handleApos() throws IOException",
        "protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException",
        "protected final void _matchToken(String matchStr, int i) throws IOException",
        "private final void _matchToken2(String matchStr, int i) throws IOException",
        "private final void _checkMatchEnd(String matchStr, int i, int ch) throws IOException",
        "private final int _skipWS() throws IOException",
        "private final int _skipWS2() throws IOException",
        "private final int _skipWSOrEnd() throws IOException",
        "private final int _skipWSOrEnd2() throws IOException",
        "private final int _skipColon() throws IOException",
        "private final int _skipColon2(boolean gotColon) throws IOException",
        "private final void _skipComment() throws IOException",
        "private final void _skipCComment() throws IOException",
        "private final boolean _skipYAMLComment() throws IOException",
        "private final void _skipLine() throws IOException",
        "protected char _decodeEscaped() throws IOException",
        "protected int _decodeCharForError(int firstByte) throws IOException",
        "private final int _decodeUtf8_2(int c) throws IOException",
        "private final int _decodeUtf8_3(int c1) throws IOException",
        "private final int _decodeUtf8_3fast(int c1) throws IOException",
        "private final int _decodeUtf8_4(int c) throws IOException",
        "private final void _skipUtf8_2(int c) throws IOException",
        "private final void _skipUtf8_3(int c) throws IOException",
        "private final void _skipUtf8_4(int c) throws IOException",
        "protected final void _skipCR() throws IOException",
        "private int nextByte() throws IOException",
        "protected void _reportInvalidToken(String matchedPart) throws IOException",
        "protected void _reportInvalidToken(String matchedPart, String msg) throws IOException",
        "protected void _reportInvalidChar(int c) throws JsonParseException",
        "protected void _reportInvalidInitial(int mask) throws JsonParseException",
        "protected void _reportInvalidOther(int mask) throws JsonParseException",
        "protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException",
        "public static int[] growArrayBy(int[] arr, int more)",
        "protected final byte[] _decodeBase64(Base64Variant b64variant) throws IOException",
        "private final static int pad(int q, int bytes)"
      ],
      "fixed_signatures": [
        "public ObjectCodec getCodec()",
        "public void setCodec(ObjectCodec c)",
        "public int releaseBuffered(OutputStream out) throws IOException",
        "public Object getInputSource()",
        "protected final boolean loadMore() throws IOException",
        "protected final boolean _loadToHaveAtLeast(int minAvailable) throws IOException",
        "protected void _closeInput() throws IOException",
        "protected void _releaseBuffers() throws IOException",
        "public String getText() throws IOException",
        "public String getValueAsString() throws IOException",
        "public String getValueAsString(String defValue) throws IOException",
        "public int getValueAsInt() throws IOException",
        "public int getValueAsInt(int defValue) throws IOException",
        "protected final String _getText2(JsonToken t)",
        "public char[] getTextCharacters() throws IOException",
        "public int getTextLength() throws IOException",
        "public int getTextOffset() throws IOException",
        "public byte[] getBinaryValue(Base64Variant b64variant) throws IOException",
        "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException",
        "protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException",
        "public JsonLocation getTokenLocation()",
        "public JsonLocation getCurrentLocation()",
        "public JsonToken nextToken() throws IOException",
        "private final JsonToken _nextTokenNotInObject(int i) throws IOException",
        "private final JsonToken _nextAfterName()",
        "public boolean nextFieldName(SerializableString str) throws IOException",
        "public String nextFieldName() throws IOException",
        "private final int _skipColonFast(int ptr) throws IOException",
        "private final void _isNextTokenNameYes(int i) throws IOException",
        "private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException",
        "public String nextTextValue() throws IOException",
        "public int nextIntValue(int defaultValue) throws IOException",
        "public long nextLongValue(long defaultValue) throws IOException",
        "public Boolean nextBooleanValue() throws IOException",
        "protected JsonToken _parsePosNumber(int c) throws IOException",
        "protected JsonToken _parseNegNumber() throws IOException",
        "private final JsonToken _parseNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException",
        "private final int _verifyNoLeadingZeroes() throws IOException",
        "private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException",
        "private final void _verifyRootSpace(int ch) throws IOException",
        "protected final String _parseName(int i) throws IOException",
        "protected final String parseMediumName(int q2) throws IOException",
        "protected final String parseMediumName2(int q3, final int q2) throws IOException",
        "protected final String parseLongName(int q, final int q2, int q3) throws IOException",
        "protected String slowParseName() throws IOException",
        "private final String parseName(int q1, int ch, int lastQuadBytes) throws IOException",
        "private final String parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException",
        "private final String parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException",
        "protected final String parseEscapedName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException",
        "protected String _handleOddName(int ch) throws IOException",
        "protected String _parseAposName() throws IOException",
        "private final String findName(int q1, int lastQuadBytes) throws JsonParseException",
        "private final String findName(int q1, int q2, int lastQuadBytes) throws JsonParseException",
        "private final String findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException",
        "private final String findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException",
        "private final String addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException",
        "protected void _finishString() throws IOException",
        "protected String _finishAndReturnString() throws IOException",
        "private final void _finishString2(char[] outBuf, int outPtr) throws IOException",
        "protected void _skipString() throws IOException",
        "protected JsonToken _handleUnexpectedValue(int c) throws IOException",
        "protected JsonToken _handleApos() throws IOException",
        "protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException",
        "protected final void _matchToken(String matchStr, int i) throws IOException",
        "private final void _matchToken2(String matchStr, int i) throws IOException",
        "private final void _checkMatchEnd(String matchStr, int i, int ch) throws IOException",
        "private final int _skipWS() throws IOException",
        "private final int _skipWS2() throws IOException",
        "private final int _skipWSOrEnd() throws IOException",
        "private final int _skipWSOrEnd2() throws IOException",
        "private final int _skipColon() throws IOException",
        "private final int _skipColon2(boolean gotColon) throws IOException",
        "private final void _skipComment() throws IOException",
        "private final void _skipCComment() throws IOException",
        "private final boolean _skipYAMLComment() throws IOException",
        "private final void _skipLine() throws IOException",
        "protected char _decodeEscaped() throws IOException",
        "protected int _decodeCharForError(int firstByte) throws IOException",
        "private final int _decodeUtf8_2(int c) throws IOException",
        "private final int _decodeUtf8_3(int c1) throws IOException",
        "private final int _decodeUtf8_3fast(int c1) throws IOException",
        "private final int _decodeUtf8_4(int c) throws IOException",
        "private final void _skipUtf8_2(int c) throws IOException",
        "private final void _skipUtf8_3(int c) throws IOException",
        "private final void _skipUtf8_4(int c) throws IOException",
        "protected final void _skipCR() throws IOException",
        "private int nextByte() throws IOException",
        "protected void _reportInvalidToken(String matchedPart) throws IOException",
        "protected void _reportInvalidToken(String matchedPart, String msg) throws IOException",
        "protected void _reportInvalidChar(int c) throws JsonParseException",
        "protected void _reportInvalidInitial(int mask) throws JsonParseException",
        "protected void _reportInvalidOther(int mask) throws JsonParseException",
        "protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException",
        "public static int[] growArrayBy(int[] arr, int more)",
        "protected final byte[] _decodeBase64(Base64Variant b64variant) throws IOException",
        "private final static int pad(int q, int bytes)"
      ],
      "methods": [
        {
          "buggy_method": "  public String getValueAsString() throws IOException {\n  if (_currToken == JsonToken.VALUE_STRING) {\n  if (_tokenIncomplete) {\n  _tokenIncomplete = false;\n  return _finishAndReturnString(); \n  }\n  return _textBuffer.contentsAsString();\n  }\n  return super.getValueAsString(null);\n  }",
          "fixed_method": "  public String getValueAsString() throws IOException {\n  if (_currToken == JsonToken.VALUE_STRING) {\n  if (_tokenIncomplete) {\n  _tokenIncomplete = false;\n  return _finishAndReturnString(); \n  }\n  return _textBuffer.contentsAsString();\n  }\n  if (_currToken == JsonToken.FIELD_NAME) {\n  return getCurrentName();\n  }\n  return super.getValueAsString(null);\n  }",
          "diff": [
            "@@ -302,6 +302,9 @@",
            "             }\n",
            "             return _textBuffer.contentsAsString();\n",
            "         }\n",
            "+        if (_currToken == JsonToken.FIELD_NAME) {\n",
            "+            return getCurrentName();\n",
            "+        }\n",
            "         return super.getValueAsString(null);\n",
            "     }\n",
            "     \n"
          ],
          "changed_lines": 3
        },
        {
          "buggy_method": "  public String getValueAsString(String defValue) throws IOException {\n  if (_currToken == JsonToken.VALUE_STRING) {\n  if (_tokenIncomplete) {\n  _tokenIncomplete = false;\n  return _finishAndReturnString(); \n  }\n  return _textBuffer.contentsAsString();\n  }\n  return super.getValueAsString(defValue);\n  }",
          "fixed_method": "  public String getValueAsString(String defValue) throws IOException {\n  if (_currToken == JsonToken.VALUE_STRING) {\n  if (_tokenIncomplete) {\n  _tokenIncomplete = false;\n  return _finishAndReturnString(); \n  }\n  return _textBuffer.contentsAsString();\n  }\n  if (_currToken == JsonToken.FIELD_NAME) {\n  return getCurrentName();\n  }\n  return super.getValueAsString(defValue);\n  }",
          "diff": [
            "@@ -315,6 +318,9 @@",
            "                 return _finishAndReturnString(); // only strings can be incomplete\n",
            "             }\n",
            "             return _textBuffer.contentsAsString();\n",
            "+        }\n",
            "+        if (_currToken == JsonToken.FIELD_NAME) {\n",
            "+            return getCurrentName();\n",
            "         }\n",
            "         return super.getValueAsString(defValue);\n",
            "     }\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
