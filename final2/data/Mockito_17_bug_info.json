{
  "bug_id": "17",
  "failed_tests": {
    "org.mockitousage.basicapi.MocksSerializationTest": [
      {
        "methodName": "shouldBeSerializeAndHaveExtraInterfaces",
        "error": "java.io.NotSerializableException",
        "message": "org.mockitousage.IMethods$$EnhancerByMockitoWithCGLIB$$d42a8079",
        "fail_line": "        serializeAndBack((List) mock);",
        "test_source": "  public void shouldBeSerializeAndHaveExtraInterfaces() throws Exception {\n  //when\n  IMethods mock = mock(IMethods.class, withSettings().serializable().extraInterfaces(List.class));\n  IMethods mockTwo = mock(IMethods.class, withSettings().extraInterfaces(List.class).serializable());\n\n  //then\n  serializeAndBack((List) mock);\n  serializeAndBack((List) mockTwo);\n  }",
        "stack": [
          "TestBase.serializeMock line 160, TestBase.serializeAndBack line 146, MocksSerializationTest.shouldBeSerializeAndHaveExtraInterfaces line 312"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/mockito/internal/creation/MockSettingsImpl.java",
      "buggy_full_code": "\npackage org.mockito.internal.creation;\n\nimport org.mockito.MockSettings;\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.internal.util.MockName;\nimport org.mockito.stubbing.Answer;\n\npublic class MockSettingsImpl implements MockSettings { private static final long serialVersionUID = 4475297236197939568L; private Class<?>[] extraInterfaces; private String name; private Object spiedInstance; private Answer<Object> defaultAnswer; private MockName mockName; public MockSettings serializable() {\n        return this.extraInterfaces(java.io.Serializable.class);\n    }\n\n    public MockSettings extraInterfaces(Class<?>... extraInterfaces) {\n        if (extraInterfaces == null || extraInterfaces.length == 0) {\n            new Reporter().extraInterfacesRequiresAtLeastOneInterface();\n        }\n            \n        for (Class<?> i : extraInterfaces) {\n            if (i == null) {\n                new Reporter().extraInterfacesDoesNotAcceptNullParameters();\n            } else if (!i.isInterface()) {\n                new Reporter().extraInterfacesAcceptsOnlyInterfaces(i);\n            }\n        }\n        this.extraInterfaces = extraInterfaces;\n        return this;\n    }\n\n    public MockName getMockName() {\n        return mockName;\n    }\n\n    public Class<?>[] getExtraInterfaces() {\n        return extraInterfaces;\n    }\n\n    public Object getSpiedInstance() {\n        return spiedInstance;\n    }\n\n    public MockSettings name(String name) {\n        this.name = name;\n        return this;\n    }\n\n    public MockSettings spiedInstance(Object spiedInstance) {\n        this.spiedInstance = spiedInstance;\n        return this;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public MockSettings defaultAnswer(Answer defaultAnswer) {\n        this.defaultAnswer = defaultAnswer;\n        return this;\n    }\n\n    public Answer<Object> getDefaultAnswer() {\n        return defaultAnswer;\n    }\n\n    public boolean isSerializable() {\n        return extraInterfaces != null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);\n    }\n\n    public void initiateMockName(Class classToMock) {\n        mockName = new MockName(name, classToMock);\n    }\n}",
      "fixed_full_code": "\npackage org.mockito.internal.creation;\n\nimport org.mockito.MockSettings;\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.internal.util.MockName;\nimport org.mockito.stubbing.Answer;\n\npublic class MockSettingsImpl implements MockSettings { private static final long serialVersionUID = 4475297236197939568L; private Class<?>[] extraInterfaces; private String name; private Object spiedInstance; private Answer<Object> defaultAnswer; private MockName mockName; private boolean serializable; public MockSettings serializable() {\n        this.serializable = true;\n        return this;\n    }\n\n    public MockSettings extraInterfaces(Class<?>... extraInterfaces) {\n        if (extraInterfaces == null || extraInterfaces.length == 0) {\n            new Reporter().extraInterfacesRequiresAtLeastOneInterface();\n        }\n            \n        for (Class<?> i : extraInterfaces) {\n            if (i == null) {\n                new Reporter().extraInterfacesDoesNotAcceptNullParameters();\n            } else if (!i.isInterface()) {\n                new Reporter().extraInterfacesAcceptsOnlyInterfaces(i);\n            }\n        }\n        this.extraInterfaces = extraInterfaces;\n        return this;\n    }\n\n    public MockName getMockName() {\n        return mockName;\n    }\n\n    public Class<?>[] getExtraInterfaces() {\n        return extraInterfaces;\n    }\n\n    public Object getSpiedInstance() {\n        return spiedInstance;\n    }\n\n    public MockSettings name(String name) {\n        this.name = name;\n        return this;\n    }\n\n    public MockSettings spiedInstance(Object spiedInstance) {\n        this.spiedInstance = spiedInstance;\n        return this;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public MockSettings defaultAnswer(Answer defaultAnswer) {\n        this.defaultAnswer = defaultAnswer;\n        return this;\n    }\n\n    public Answer<Object> getDefaultAnswer() {\n        return defaultAnswer;\n    }\n\n    public boolean isSerializable() {\n        return serializable;\n    }\n\n    public void initiateMockName(Class classToMock) {\n        mockName = new MockName(name, classToMock);\n    }\n}",
      "buggy_signatures": [
        "public MockSettings extraInterfaces(Class<?>... extraInterfaces)",
        "public MockName getMockName()",
        "public Class<?>[] getExtraInterfaces()",
        "public Object getSpiedInstance()",
        "public MockSettings name(String name)",
        "public MockSettings spiedInstance(Object spiedInstance)",
        "public MockSettings defaultAnswer(Answer defaultAnswer)",
        "public Answer<Object> getDefaultAnswer()",
        "public boolean isSerializable()",
        "public void initiateMockName(Class classToMock)"
      ],
      "fixed_signatures": [
        "public MockSettings extraInterfaces(Class<?>... extraInterfaces)",
        "public MockName getMockName()",
        "public Class<?>[] getExtraInterfaces()",
        "public Object getSpiedInstance()",
        "public MockSettings name(String name)",
        "public MockSettings spiedInstance(Object spiedInstance)",
        "public MockSettings defaultAnswer(Answer defaultAnswer)",
        "public Answer<Object> getDefaultAnswer()",
        "public boolean isSerializable()",
        "public void initiateMockName(Class classToMock)"
      ],
      "methods": [
        {
          "buggy_method": "  public MockSettings extraInterfaces(Class<?>... extraInterfaces) {\n  if (extraInterfaces == null || extraInterfaces.length == 0) {\n  new Reporter().extraInterfacesRequiresAtLeastOneInterface();\n  }\n  \n  for (Class<?> i : extraInterfaces) {\n  if (i == null) {\n  new Reporter().extraInterfacesDoesNotAcceptNullParameters();\n  } else if (!i.isInterface()) {\n  new Reporter().extraInterfacesAcceptsOnlyInterfaces(i);\n  }\n  }\n  this.extraInterfaces = extraInterfaces;\n  return this;\n  }",
          "fixed_method": "  public MockSettings serializable() {\n  this.serializable = true;\n  return this;\n  }",
          "diff": [
            "@@ -17,9 +17,11 @@",
            "     private Object spiedInstance;\n",
            "     private Answer<Object> defaultAnswer;\n",
            "     private MockName mockName;\n",
            "+    private boolean serializable;\n",
            " \n",
            "     public MockSettings serializable() {\n",
            "-        return this.extraInterfaces(java.io.Serializable.class);\n",
            "+        this.serializable = true;\n",
            "+        return this;\n",
            "     }\n",
            " \n",
            "     public MockSettings extraInterfaces(Class<?>... extraInterfaces) {\n"
          ],
          "changed_lines": 4
        },
        {
          "buggy_method": "  public void initiateMockName(Class classToMock) {\n  mockName = new MockName(name, classToMock);\n  }",
          "fixed_method": "  public void initiateMockName(Class classToMock) {\n  mockName = new MockName(name, classToMock);\n  }",
          "diff": [
            "@@ -71,7 +73,7 @@",
            "     }\n",
            " \n",
            "     public boolean isSerializable() {\n",
            "-        return extraInterfaces != null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);\n",
            "+        return serializable;\n",
            "     }\n",
            " \n",
            "     public void initiateMockName(Class classToMock) {\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "org/mockito/internal/util/MockUtil.java",
      "buggy_full_code": "\npackage org.mockito.internal.util;\n\nimport static org.mockito.Mockito.RETURNS_DEFAULTS; import static org.mockito.Mockito.withSettings; import org.mockito.cglib.proxy.*; import org.mockito.exceptions.misusing.NotAMockException; import org.mockito.internal.MockHandler; import org.mockito.internal.MockHandlerInterface; import org.mockito.internal.creation.MethodInterceptorFilter; import org.mockito.internal.creation.MockSettingsImpl; import org.mockito.internal.creation.jmock.ClassImposterizer; import org.mockito.internal.util.reflection.LenientCopyTool; @SuppressWarnings(\"unchecked\") public class MockUtil {\n    \n    private final CreationValidator creationValidator; public MockUtil(CreationValidator creationValidator) {\n        this.creationValidator = creationValidator;\n    }\n    \n    public MockUtil() {\n        this(new CreationValidator());\n    }\n\n    public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings) {\n        creationValidator.validateType(classToMock);\n        creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\n        creationValidator.validateMockedType(classToMock, settings.getSpiedInstance());\n\n        settings.initiateMockName(classToMock);\n\n        MockHandler<T> mockHandler = new MockHandler<T>(settings);\n        MethodInterceptorFilter filter = new MethodInterceptorFilter(mockHandler, settings);\n        Class<?>[] interfaces = settings.getExtraInterfaces();\n\n        Class<?>[] ancillaryTypes;\n            ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\n\n        Object spiedInstance = settings.getSpiedInstance();\n        \n        T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);\n        \n        if (spiedInstance != null) {\n            new LenientCopyTool().copyToMock(spiedInstance, mock);\n        }\n        \n        return mock;\n    }\n\n    public <T> void resetMock(T mock) {\n        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, \n                        (MockSettingsImpl) withSettings().defaultAnswer(RETURNS_DEFAULTS));\n        ((Factory) mock).setCallback(0, newFilter);\n    }\n\n    public <T> MockHandlerInterface<T> getMockHandler(T mock) {\n        if (mock == null) {\n            throw new NotAMockException(\"Argument should be a mock, but is null!\");\n        }\n\n        if (isMockitoMock(mock)) {\n            return (MockHandlerInterface) getInterceptor(mock).getHandler();\n        } else {\n            throw new NotAMockException(\"Argument should be a mock, but is: \" + mock.getClass());\n        }\n    }\n\n    private <T> boolean isMockitoMock(T mock) {\n        return Enhancer.isEnhanced(mock.getClass()) && getInterceptor(mock) != null;\n    }\n\n    public boolean isMock(Object mock) {\n        return mock != null && isMockitoMock(mock);\n    }\n\n    private <T> MethodInterceptorFilter getInterceptor(T mock) {\n        Factory factory = (Factory) mock;\n        Callback callback = factory.getCallback(0);\n        if (callback instanceof MethodInterceptorFilter) {\n            return (MethodInterceptorFilter) callback;\n        }\n        return null;\n    }\n\n    public MockName getMockName(Object mock) {\n        return getMockHandler(mock).getMockSettings().getMockName();\n    }\n}",
      "fixed_full_code": "\npackage org.mockito.internal.util;\n\nimport static org.mockito.Mockito.RETURNS_DEFAULTS; import static org.mockito.Mockito.withSettings; import org.mockito.cglib.proxy.*; import org.mockito.exceptions.misusing.NotAMockException; import org.mockito.internal.MockHandler; import org.mockito.internal.MockHandlerInterface; import org.mockito.internal.creation.MethodInterceptorFilter; import org.mockito.internal.creation.MockSettingsImpl; import org.mockito.internal.creation.jmock.ClassImposterizer; import org.mockito.internal.util.reflection.LenientCopyTool; import java.io.Serializable; @SuppressWarnings(\"unchecked\") public class MockUtil {\n    \n    private final CreationValidator creationValidator; public MockUtil(CreationValidator creationValidator) {\n        this.creationValidator = creationValidator;\n    }\n    \n    public MockUtil() {\n        this(new CreationValidator());\n    }\n\n    public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings) {\n        creationValidator.validateType(classToMock);\n        creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\n        creationValidator.validateMockedType(classToMock, settings.getSpiedInstance());\n\n        settings.initiateMockName(classToMock);\n\n        MockHandler<T> mockHandler = new MockHandler<T>(settings);\n        MethodInterceptorFilter filter = new MethodInterceptorFilter(mockHandler, settings);\n        Class<?>[] interfaces = settings.getExtraInterfaces();\n\n        Class<?>[] ancillaryTypes;\n        if (settings.isSerializable()) {\n            ancillaryTypes = interfaces == null ? new Class<?>[] {Serializable.class} : new ArrayUtils().concat(interfaces, Serializable.class);\n        } else {\n            ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\n        }\n\n        Object spiedInstance = settings.getSpiedInstance();\n        \n        T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);\n        \n        if (spiedInstance != null) {\n            new LenientCopyTool().copyToMock(spiedInstance, mock);\n        }\n        \n        return mock;\n    }\n\n    public <T> void resetMock(T mock) {\n        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, \n                        (MockSettingsImpl) withSettings().defaultAnswer(RETURNS_DEFAULTS));\n        ((Factory) mock).setCallback(0, newFilter);\n    }\n\n    public <T> MockHandlerInterface<T> getMockHandler(T mock) {\n        if (mock == null) {\n            throw new NotAMockException(\"Argument should be a mock, but is null!\");\n        }\n\n        if (isMockitoMock(mock)) {\n            return (MockHandlerInterface) getInterceptor(mock).getHandler();\n        } else {\n            throw new NotAMockException(\"Argument should be a mock, but is: \" + mock.getClass());\n        }\n    }\n\n    private <T> boolean isMockitoMock(T mock) {\n        return Enhancer.isEnhanced(mock.getClass()) && getInterceptor(mock) != null;\n    }\n\n    public boolean isMock(Object mock) {\n        return mock != null && isMockitoMock(mock);\n    }\n\n    private <T> MethodInterceptorFilter getInterceptor(T mock) {\n        Factory factory = (Factory) mock;\n        Callback callback = factory.getCallback(0);\n        if (callback instanceof MethodInterceptorFilter) {\n            return (MethodInterceptorFilter) callback;\n        }\n        return null;\n    }\n\n    public MockName getMockName(Object mock) {\n        return getMockHandler(mock).getMockSettings().getMockName();\n    }\n}",
      "buggy_signatures": [
        "static org.mockito.Mockito.RETURNS_DEFAULTS; import static org.mockito.Mockito.withSettings; import org.mockito.cglib.proxy.*; import org.mockito.exceptions.misusing.NotAMockException; import org.mockito.internal.MockHandler; import org.mockito.internal.MockHandlerInterface; import org.mockito.internal.creation.MethodInterceptorFilter; import org.mockito.internal.creation.MockSettingsImpl; import org.mockito.internal.creation.jmock.ClassImposterizer; import org.mockito.internal.util.reflection.LenientCopyTool; @SuppressWarnings(\"unchecked\") public class MockUtil",
        "private final CreationValidator creationValidator; public MockUtil(CreationValidator creationValidator)",
        "public MockUtil()",
        "public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings)",
        "public <T> void resetMock(T mock)",
        "public <T> MockHandlerInterface<T> getMockHandler(T mock)",
        "private <T> boolean isMockitoMock(T mock)",
        "public boolean isMock(Object mock)",
        "private <T> MethodInterceptorFilter getInterceptor(T mock)",
        "public MockName getMockName(Object mock)"
      ],
      "fixed_signatures": [
        "static org.mockito.Mockito.RETURNS_DEFAULTS; import static org.mockito.Mockito.withSettings; import org.mockito.cglib.proxy.*; import org.mockito.exceptions.misusing.NotAMockException; import org.mockito.internal.MockHandler; import org.mockito.internal.MockHandlerInterface; import org.mockito.internal.creation.MethodInterceptorFilter; import org.mockito.internal.creation.MockSettingsImpl; import org.mockito.internal.creation.jmock.ClassImposterizer; import org.mockito.internal.util.reflection.LenientCopyTool; import java.io.Serializable; @SuppressWarnings(\"unchecked\") public class MockUtil",
        "private final CreationValidator creationValidator; public MockUtil(CreationValidator creationValidator)",
        "public MockUtil()",
        "public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings)",
        "public <T> void resetMock(T mock)",
        "public <T> MockHandlerInterface<T> getMockHandler(T mock)",
        "private <T> boolean isMockitoMock(T mock)",
        "public boolean isMock(Object mock)",
        "private <T> MethodInterceptorFilter getInterceptor(T mock)",
        "public MockName getMockName(Object mock)"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -16,6 +16,7 @@",
            " import org.mockito.internal.creation.jmock.ClassImposterizer;\n",
            " import org.mockito.internal.util.reflection.LenientCopyTool;\n",
            " \n",
            "+import java.io.Serializable;\n",
            " \n",
            " @SuppressWarnings(\"unchecked\")\n",
            " public class MockUtil {\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings) {\n  creationValidator.validateType(classToMock);\n  creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\n  creationValidator.validateMockedType(classToMock, settings.getSpiedInstance());\n\n  settings.initiateMockName(classToMock);\n\n  MockHandler<T> mockHandler = new MockHandler<T>(settings);\n  MethodInterceptorFilter filter = new MethodInterceptorFilter(mockHandler, settings);\n  Class<?>[] interfaces = settings.getExtraInterfaces();\n\n  Class<?>[] ancillaryTypes;\n  ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\n\n  Object spiedInstance = settings.getSpiedInstance();\n  \n  T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);\n  \n  if (spiedInstance != null) {\n  new LenientCopyTool().copyToMock(spiedInstance, mock);\n  }\n  \n  return mock;\n  }",
          "fixed_method": "  public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings) {\n  creationValidator.validateType(classToMock);\n  creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\n  creationValidator.validateMockedType(classToMock, settings.getSpiedInstance());\n\n  settings.initiateMockName(classToMock);\n\n  MockHandler<T> mockHandler = new MockHandler<T>(settings);\n  MethodInterceptorFilter filter = new MethodInterceptorFilter(mockHandler, settings);\n  Class<?>[] interfaces = settings.getExtraInterfaces();\n\n  Class<?>[] ancillaryTypes;\n  if (settings.isSerializable()) {\n  ancillaryTypes = interfaces == null ? new Class<?>[] {Serializable.class} : new ArrayUtils().concat(interfaces, Serializable.class);\n  } else {\n  ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\n  }\n\n  Object spiedInstance = settings.getSpiedInstance();\n  \n  T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);\n  \n  if (spiedInstance != null) {\n  new LenientCopyTool().copyToMock(spiedInstance, mock);\n  }\n  \n  return mock;\n  }",
          "diff": [
            "@@ -42,7 +43,11 @@",
            "         Class<?>[] interfaces = settings.getExtraInterfaces();\n",
            " \n",
            "         Class<?>[] ancillaryTypes;\n",
            "+        if (settings.isSerializable()) {\n",
            "+            ancillaryTypes = interfaces == null ? new Class<?>[] {Serializable.class} : new ArrayUtils().concat(interfaces, Serializable.class);\n",
            "+        } else {\n",
            "             ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\n",
            "+        }\n",
            " \n",
            "         Object spiedInstance = settings.getSpiedInstance();\n",
            "         \n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
