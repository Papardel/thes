{
  "bug_id": "18",
  "failed_tests": {
    "com.fasterxml.jackson.core.json.TestJsonGeneratorFeatures": [
      {
        "methodName": "testTooBigBigDecimal",
        "error": "junit.framework.AssertionFailedError",
        "message": "Should not have written without exception: 1E+10000",
        "fail_line": "                        fail(\"Should not have written without exception: \"+input);",
        "test_source": "  public void testTooBigBigDecimal() throws Exception {\n  JsonFactory f = new JsonFactory();\n  f.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n\n  // 24-Aug-2016, tatu: Initial check limits scale to [-9999,+9999]\n  BigDecimal BIG = new BigDecimal(\"1E+9999\");\n  BigDecimal TOO_BIG = new BigDecimal(\"1E+10000\");\n  BigDecimal SMALL = new BigDecimal(\"1E-9999\");\n  BigDecimal TOO_SMALL = new BigDecimal(\"1E-10000\");\n\n  for (boolean useBytes : new boolean[] { false, true } ) {\n  for (boolean asString : new boolean[] { false, true } ) {\n  JsonGenerator g;\n  \n  if (useBytes) {\n  g = f.createGenerator(new ByteArrayOutputStream());\n  } else {\n  g = f.createGenerator(new StringWriter());\n  }\n  if (asString) {\n  g.enable(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS);\n  }\n\n  // first, ok cases:\n  g.writeStartArray();\n  g.writeNumber(BIG);\n  g.writeNumber(SMALL);\n  g.writeEndArray();\n  g.close();\n\n  // then invalid\n  for (BigDecimal input : new BigDecimal[] { TOO_BIG, TOO_SMALL }) {\n  if (useBytes) {\n  g = f.createGenerator(new ByteArrayOutputStream());\n  } else {\n  g = f.createGenerator(new StringWriter());\n  }\n  if (asString) {\n  g.enable(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS);\n  }\n  try {\n  g.writeNumber(input);\n  fail(\"Should not have written without exception: \"+input);\n  } catch (JsonGenerationException e) {\n  verifyException(e, \"Attempt to write plain `java.math.BigDecimal`\");\n  verifyException(e, \"illegal scale\");\n  }\n  g.close();\n  }\n  }\n  }\n  }",
        "stack": [
          "TestJsonGeneratorFeatures.testTooBigBigDecimal line 154"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/core/base/GeneratorBase.java",
      "buggy_full_code": "package com.fasterxml.jackson.core.base;\n\nimport java.io.*;\nimport java.math.BigDecimal;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.json.DupDetector;\nimport com.fasterxml.jackson.core.json.JsonWriteContext;\nimport com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\n\npublic abstract class GeneratorBase extends JsonGenerator { public final static int SURR1_FIRST = 0xD800; public final static int SURR1_LAST = 0xDBFF; public final static int SURR2_FIRST = 0xDC00; public final static int SURR2_LAST = 0xDFFF; protected final static int DERIVED_FEATURES_MASK = Feature.WRITE_NUMBERS_AS_STRINGS.getMask() | Feature.ESCAPE_NON_ASCII.getMask() | Feature.STRICT_DUPLICATE_DETECTION.getMask() ; protected final static String WRITE_BINARY = \"write a binary value\"; protected final static String WRITE_BOOLEAN = \"write a boolean value\"; protected final static String WRITE_NULL = \"write a null\"; protected final static String WRITE_NUMBER = \"write a number\"; protected final static String WRITE_RAW = \"write a raw (unencoded) value\"; protected final static String WRITE_STRING = \"write a string\"; protected ObjectCodec _objectCodec; protected int _features; protected boolean _cfgNumbersAsStrings; protected JsonWriteContext _writeContext; protected boolean _closed; protected GeneratorBase(int features, ObjectCodec codec) {\n        super();\n        _features = features;\n        _objectCodec = codec;\n        DupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features)\n                ? DupDetector.rootDetector(this) : null;\n        _writeContext = JsonWriteContext.createRootContext(dups);\n        _cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(features);\n    }\n\n    \n    protected GeneratorBase(int features, ObjectCodec codec, JsonWriteContext ctxt) {\n        super();\n        _features = features;\n        _objectCodec = codec;\n        _writeContext = ctxt;\n        _cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(features);\n    }\n\n    \n    @Override public Version version() { return VersionUtil.versionFor(getClass()); }\n\n    @Override\n    public Object getCurrentValue() {\n        return _writeContext.getCurrentValue();\n    }\n\n    @Override\n    public void setCurrentValue(Object v) {\n        _writeContext.setCurrentValue(v);\n    }\n\n    \n\n\n    @Override public final boolean isEnabled(Feature f) { return (_features & f.getMask()) != 0; }\n    @Override public int getFeatureMask() { return _features; }\n\n    \n\n    @Override\n    public JsonGenerator enable(Feature f) {\n        final int mask = f.getMask();\n        _features |= mask;\n        if ((mask & DERIVED_FEATURES_MASK) != 0) {\n            \n            if (f == Feature.WRITE_NUMBERS_AS_STRINGS) {\n                _cfgNumbersAsStrings = true;\n            } else if (f == Feature.ESCAPE_NON_ASCII) {\n                setHighestNonEscapedChar(127);\n            } else if (f == Feature.STRICT_DUPLICATE_DETECTION) {\n                if (_writeContext.getDupDetector() == null) { \n                    _writeContext = _writeContext.withDupDetector(DupDetector.rootDetector(this));\n                }\n            }\n        }\n        return this;\n    }\n\n    @Override\n    public JsonGenerator disable(Feature f) {\n        final int mask = f.getMask();\n        _features &= ~mask;\n        if ((mask & DERIVED_FEATURES_MASK) != 0) {\n            if (f == Feature.WRITE_NUMBERS_AS_STRINGS) {\n                _cfgNumbersAsStrings = false;\n            } else if (f == Feature.ESCAPE_NON_ASCII) {\n                setHighestNonEscapedChar(0);\n            } else if (f == Feature.STRICT_DUPLICATE_DETECTION) {\n                _writeContext = _writeContext.withDupDetector(null);\n            }\n        }\n        return this;\n    }\n\n    @Override\n    @Deprecated\n    public JsonGenerator setFeatureMask(int newMask) {\n        int changed = newMask ^ _features;\n        _features = newMask;\n        if (changed != 0) {\n            _checkStdFeatureChanges(newMask, changed);\n        }\n        return this;\n    }\n\n    @Override \n    public JsonGenerator overrideStdFeatures(int values, int mask) {\n        int oldState = _features;\n        int newState = (oldState & ~mask) | (values & mask);\n        int changed = oldState ^ newState;\n        if (changed != 0) {\n            _features = newState;\n            _checkStdFeatureChanges(newState, changed);\n        }\n        return this;\n    }\n\n    \n    protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures) {\n        if ((changedFeatures & DERIVED_FEATURES_MASK) == 0) {\n            return;\n        }\n        _cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(newFeatureFlags);\n        if (Feature.ESCAPE_NON_ASCII.enabledIn(changedFeatures)) {\n            if (Feature.ESCAPE_NON_ASCII.enabledIn(newFeatureFlags)) {\n                setHighestNonEscapedChar(127);\n            } else {\n                setHighestNonEscapedChar(0);\n            }\n        }\n        if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(changedFeatures)) {\n            if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(newFeatureFlags)) { \n                if (_writeContext.getDupDetector() == null) { \n                    _writeContext = _writeContext.withDupDetector(DupDetector.rootDetector(this));\n                }\n            } else { \n                _writeContext = _writeContext.withDupDetector(null);\n            }\n        }\n    }\n\n    @Override public JsonGenerator useDefaultPrettyPrinter() {\n        \n        if (getPrettyPrinter() != null) {\n            return this;\n        }\n        return setPrettyPrinter(_constructDefaultPrettyPrinter());\n    }\n    \n    @Override public JsonGenerator setCodec(ObjectCodec oc) {\n        _objectCodec = oc;\n        return this;\n    }\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n\n    \n\n    \n    @Override public JsonWriteContext getOutputContext() { return _writeContext; }\n\n    \n\n    \n    \n    \n    \n\n    \n\n    @Override public void writeFieldName(SerializableString name) throws IOException {\n        writeFieldName(name.getValue());\n    }\n    \n    \n\n    \n\n    \n\n    \n\n    @Override\n    public void writeString(SerializableString text) throws IOException {\n        writeString(text.getValue());\n    }\n\n    @Override public void writeRawValue(String text) throws IOException {\n        _verifyValueWrite(\"write raw value\");\n        writeRaw(text);\n    }\n\n    @Override public void writeRawValue(String text, int offset, int len) throws IOException {\n        _verifyValueWrite(\"write raw value\");\n        writeRaw(text, offset, len);\n    }\n\n    @Override public void writeRawValue(char[] text, int offset, int len) throws IOException {\n        _verifyValueWrite(\"write raw value\");\n        writeRaw(text, offset, len);\n    }\n\n    @Override public void writeRawValue(SerializableString text) throws IOException {\n        _verifyValueWrite(\"write raw value\");\n        writeRaw(text);\n    }\n\n    @Override\n    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException {\n        \n        _reportUnsupportedOperation();\n        return 0;\n    }\n\n    \n\n    \n\n     \n\n    \n\n    @Override\n    public void writeObject(Object value) throws IOException {\n        if (value == null) {\n            \n            writeNull();\n        } else {\n            \n            if (_objectCodec != null) {\n                _objectCodec.writeValue(this, value);\n                return;\n            }\n            _writeSimpleObject(value);\n        }\n    }\n\n    @Override\n    public void writeTree(TreeNode rootNode) throws IOException {\n        \n        if (rootNode == null) {\n            writeNull();\n        } else {\n            if (_objectCodec == null) {\n                throw new IllegalStateException(\"No ObjectCodec defined\");\n            }\n            _objectCodec.writeValue(this, rootNode);\n        }\n    }\n\n    \n\n    @Override public abstract void flush() throws IOException; @Override public void close() throws IOException { _closed = true; }\n    @Override public boolean isClosed() { return _closed; }\n\n    \n\n    \n    protected abstract void _releaseBuffers(); protected abstract void _verifyValueWrite(String typeMsg) throws IOException; protected PrettyPrinter _constructDefaultPrettyPrinter() {\n        return new DefaultPrettyPrinter();\n    }\n\n    \n    protected String _asString(BigDecimal value) throws IOException {\n            \n        return value.toString();\n    }\n\n    \n\n    \n    protected final int _decodeSurrogate(int surr1, int surr2) throws IOException {\n        \n        if (surr2 < SURR2_FIRST || surr2 > SURR2_LAST) {\n            String msg = \"Incomplete surrogate pair: first char 0x\"+Integer.toHexString(surr1)+\", second 0x\"+Integer.toHexString(surr2);\n            _reportError(msg);\n        }\n        int c = 0x10000 + ((surr1 - SURR1_FIRST) << 10) + (surr2 - SURR2_FIRST);\n        return c;\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.core.base;\n\nimport java.io.*;\nimport java.math.BigDecimal;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.json.DupDetector;\nimport com.fasterxml.jackson.core.json.JsonWriteContext;\nimport com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\n\npublic abstract class GeneratorBase extends JsonGenerator { public final static int SURR1_FIRST = 0xD800; public final static int SURR1_LAST = 0xDBFF; public final static int SURR2_FIRST = 0xDC00; public final static int SURR2_LAST = 0xDFFF; protected final static int DERIVED_FEATURES_MASK = Feature.WRITE_NUMBERS_AS_STRINGS.getMask() | Feature.ESCAPE_NON_ASCII.getMask() | Feature.STRICT_DUPLICATE_DETECTION.getMask() ; protected final static String WRITE_BINARY = \"write a binary value\"; protected final static String WRITE_BOOLEAN = \"write a boolean value\"; protected final static String WRITE_NULL = \"write a null\"; protected final static String WRITE_NUMBER = \"write a number\"; protected final static String WRITE_RAW = \"write a raw (unencoded) value\"; protected final static String WRITE_STRING = \"write a string\"; protected final static int MAX_BIG_DECIMAL_SCALE = 9999; protected ObjectCodec _objectCodec; protected int _features; protected boolean _cfgNumbersAsStrings; protected JsonWriteContext _writeContext; protected boolean _closed; protected GeneratorBase(int features, ObjectCodec codec) {\n        super();\n        _features = features;\n        _objectCodec = codec;\n        DupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features)\n                ? DupDetector.rootDetector(this) : null;\n        _writeContext = JsonWriteContext.createRootContext(dups);\n        _cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(features);\n    }\n\n    \n    protected GeneratorBase(int features, ObjectCodec codec, JsonWriteContext ctxt) {\n        super();\n        _features = features;\n        _objectCodec = codec;\n        _writeContext = ctxt;\n        _cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(features);\n    }\n\n    \n    @Override public Version version() { return VersionUtil.versionFor(getClass()); }\n\n    @Override\n    public Object getCurrentValue() {\n        return _writeContext.getCurrentValue();\n    }\n\n    @Override\n    public void setCurrentValue(Object v) {\n        _writeContext.setCurrentValue(v);\n    }\n\n    \n\n\n    @Override public final boolean isEnabled(Feature f) { return (_features & f.getMask()) != 0; }\n    @Override public int getFeatureMask() { return _features; }\n\n    \n\n    @Override\n    public JsonGenerator enable(Feature f) {\n        final int mask = f.getMask();\n        _features |= mask;\n        if ((mask & DERIVED_FEATURES_MASK) != 0) {\n            \n            if (f == Feature.WRITE_NUMBERS_AS_STRINGS) {\n                _cfgNumbersAsStrings = true;\n            } else if (f == Feature.ESCAPE_NON_ASCII) {\n                setHighestNonEscapedChar(127);\n            } else if (f == Feature.STRICT_DUPLICATE_DETECTION) {\n                if (_writeContext.getDupDetector() == null) { \n                    _writeContext = _writeContext.withDupDetector(DupDetector.rootDetector(this));\n                }\n            }\n        }\n        return this;\n    }\n\n    @Override\n    public JsonGenerator disable(Feature f) {\n        final int mask = f.getMask();\n        _features &= ~mask;\n        if ((mask & DERIVED_FEATURES_MASK) != 0) {\n            if (f == Feature.WRITE_NUMBERS_AS_STRINGS) {\n                _cfgNumbersAsStrings = false;\n            } else if (f == Feature.ESCAPE_NON_ASCII) {\n                setHighestNonEscapedChar(0);\n            } else if (f == Feature.STRICT_DUPLICATE_DETECTION) {\n                _writeContext = _writeContext.withDupDetector(null);\n            }\n        }\n        return this;\n    }\n\n    @Override\n    @Deprecated\n    public JsonGenerator setFeatureMask(int newMask) {\n        int changed = newMask ^ _features;\n        _features = newMask;\n        if (changed != 0) {\n            _checkStdFeatureChanges(newMask, changed);\n        }\n        return this;\n    }\n\n    @Override \n    public JsonGenerator overrideStdFeatures(int values, int mask) {\n        int oldState = _features;\n        int newState = (oldState & ~mask) | (values & mask);\n        int changed = oldState ^ newState;\n        if (changed != 0) {\n            _features = newState;\n            _checkStdFeatureChanges(newState, changed);\n        }\n        return this;\n    }\n\n    \n    protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures) {\n        if ((changedFeatures & DERIVED_FEATURES_MASK) == 0) {\n            return;\n        }\n        _cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(newFeatureFlags);\n        if (Feature.ESCAPE_NON_ASCII.enabledIn(changedFeatures)) {\n            if (Feature.ESCAPE_NON_ASCII.enabledIn(newFeatureFlags)) {\n                setHighestNonEscapedChar(127);\n            } else {\n                setHighestNonEscapedChar(0);\n            }\n        }\n        if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(changedFeatures)) {\n            if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(newFeatureFlags)) { \n                if (_writeContext.getDupDetector() == null) { \n                    _writeContext = _writeContext.withDupDetector(DupDetector.rootDetector(this));\n                }\n            } else { \n                _writeContext = _writeContext.withDupDetector(null);\n            }\n        }\n    }\n\n    @Override public JsonGenerator useDefaultPrettyPrinter() {\n        \n        if (getPrettyPrinter() != null) {\n            return this;\n        }\n        return setPrettyPrinter(_constructDefaultPrettyPrinter());\n    }\n    \n    @Override public JsonGenerator setCodec(ObjectCodec oc) {\n        _objectCodec = oc;\n        return this;\n    }\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n\n    \n\n    \n    @Override public JsonWriteContext getOutputContext() { return _writeContext; }\n\n    \n\n    \n    \n    \n    \n\n    \n\n    @Override public void writeFieldName(SerializableString name) throws IOException {\n        writeFieldName(name.getValue());\n    }\n    \n    \n\n    \n\n    \n\n    \n\n    @Override\n    public void writeString(SerializableString text) throws IOException {\n        writeString(text.getValue());\n    }\n\n    @Override public void writeRawValue(String text) throws IOException {\n        _verifyValueWrite(\"write raw value\");\n        writeRaw(text);\n    }\n\n    @Override public void writeRawValue(String text, int offset, int len) throws IOException {\n        _verifyValueWrite(\"write raw value\");\n        writeRaw(text, offset, len);\n    }\n\n    @Override public void writeRawValue(char[] text, int offset, int len) throws IOException {\n        _verifyValueWrite(\"write raw value\");\n        writeRaw(text, offset, len);\n    }\n\n    @Override public void writeRawValue(SerializableString text) throws IOException {\n        _verifyValueWrite(\"write raw value\");\n        writeRaw(text);\n    }\n\n    @Override\n    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException {\n        \n        _reportUnsupportedOperation();\n        return 0;\n    }\n\n    \n\n    \n\n     \n\n    \n\n    @Override\n    public void writeObject(Object value) throws IOException {\n        if (value == null) {\n            \n            writeNull();\n        } else {\n            \n            if (_objectCodec != null) {\n                _objectCodec.writeValue(this, value);\n                return;\n            }\n            _writeSimpleObject(value);\n        }\n    }\n\n    @Override\n    public void writeTree(TreeNode rootNode) throws IOException {\n        \n        if (rootNode == null) {\n            writeNull();\n        } else {\n            if (_objectCodec == null) {\n                throw new IllegalStateException(\"No ObjectCodec defined\");\n            }\n            _objectCodec.writeValue(this, rootNode);\n        }\n    }\n\n    \n\n    @Override public abstract void flush() throws IOException; @Override public void close() throws IOException { _closed = true; }\n    @Override public boolean isClosed() { return _closed; }\n\n    \n\n    \n    protected abstract void _releaseBuffers(); protected abstract void _verifyValueWrite(String typeMsg) throws IOException; protected PrettyPrinter _constructDefaultPrettyPrinter() {\n        return new DefaultPrettyPrinter();\n    }\n\n    \n    protected String _asString(BigDecimal value) throws IOException {\n        if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {\n            \n            int scale = value.scale();\n            if ((scale < -MAX_BIG_DECIMAL_SCALE) || (scale > MAX_BIG_DECIMAL_SCALE)) {\n                _reportError(String.format(\n\"Attempt to write plain `java.math.BigDecimal` (see JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN) with illegal scale (%d): needs to be between [-%d, %d]\",\nscale, MAX_BIG_DECIMAL_SCALE, MAX_BIG_DECIMAL_SCALE));\n            }\n            return value.toPlainString();\n        }\n        return value.toString();\n    }\n\n    \n\n    \n    protected final int _decodeSurrogate(int surr1, int surr2) throws IOException {\n        \n        if (surr2 < SURR2_FIRST || surr2 > SURR2_LAST) {\n            String msg = \"Incomplete surrogate pair: first char 0x\"+Integer.toHexString(surr1)+\", second 0x\"+Integer.toHexString(surr2);\n            _reportError(msg);\n        }\n        int c = 0x10000 + ((surr1 - SURR1_FIRST) << 10) + (surr2 - SURR2_FIRST);\n        return c;\n    }\n}\n",
      "buggy_signatures": [
        "protected GeneratorBase(int features, ObjectCodec codec, JsonWriteContext ctxt)",
        "public Version version()",
        "public Object getCurrentValue()",
        "public void setCurrentValue(Object v)",
        "public final boolean isEnabled(Feature f)",
        "public int getFeatureMask()",
        "public JsonGenerator enable(Feature f)",
        "public JsonGenerator disable(Feature f)",
        "public JsonGenerator setFeatureMask(int newMask)",
        "public JsonGenerator overrideStdFeatures(int values, int mask)",
        "protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures)",
        "public JsonGenerator useDefaultPrettyPrinter()",
        "public JsonGenerator setCodec(ObjectCodec oc)",
        "public ObjectCodec getCodec()",
        "public JsonWriteContext getOutputContext()",
        "public void writeFieldName(SerializableString name) throws IOException",
        "public void writeString(SerializableString text) throws IOException",
        "public void writeRawValue(String text) throws IOException",
        "public void writeRawValue(String text, int offset, int len) throws IOException",
        "public void writeRawValue(char[] text, int offset, int len) throws IOException",
        "public void writeRawValue(SerializableString text) throws IOException",
        "public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException",
        "public void writeObject(Object value) throws IOException",
        "public void writeTree(TreeNode rootNode) throws IOException",
        "public abstract void flush() throws IOException; @Override public void close() throws IOException",
        "public boolean isClosed()",
        "protected abstract void _releaseBuffers(); protected abstract void _verifyValueWrite(String typeMsg) throws IOException; protected PrettyPrinter _constructDefaultPrettyPrinter()",
        "protected String _asString(BigDecimal value) throws IOException",
        "protected final int _decodeSurrogate(int surr1, int surr2) throws IOException"
      ],
      "fixed_signatures": [
        "protected GeneratorBase(int features, ObjectCodec codec, JsonWriteContext ctxt)",
        "public Version version()",
        "public Object getCurrentValue()",
        "public void setCurrentValue(Object v)",
        "public final boolean isEnabled(Feature f)",
        "public int getFeatureMask()",
        "public JsonGenerator enable(Feature f)",
        "public JsonGenerator disable(Feature f)",
        "public JsonGenerator setFeatureMask(int newMask)",
        "public JsonGenerator overrideStdFeatures(int values, int mask)",
        "protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures)",
        "public JsonGenerator useDefaultPrettyPrinter()",
        "public JsonGenerator setCodec(ObjectCodec oc)",
        "public ObjectCodec getCodec()",
        "public JsonWriteContext getOutputContext()",
        "public void writeFieldName(SerializableString name) throws IOException",
        "public void writeString(SerializableString text) throws IOException",
        "public void writeRawValue(String text) throws IOException",
        "public void writeRawValue(String text, int offset, int len) throws IOException",
        "public void writeRawValue(char[] text, int offset, int len) throws IOException",
        "public void writeRawValue(SerializableString text) throws IOException",
        "public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException",
        "public void writeObject(Object value) throws IOException",
        "public void writeTree(TreeNode rootNode) throws IOException",
        "public abstract void flush() throws IOException; @Override public void close() throws IOException",
        "public boolean isClosed()",
        "protected abstract void _releaseBuffers(); protected abstract void _verifyValueWrite(String typeMsg) throws IOException; protected PrettyPrinter _constructDefaultPrettyPrinter()",
        "protected String _asString(BigDecimal value) throws IOException",
        "protected final int _decodeSurrogate(int surr1, int surr2) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  protected final static String WRITE_RAW = \"write a raw (unencoded) value\"; protected final static String WRITE_STRING = \"write a string\"; /** * This value is the limit of scale allowed for serializing {@link BigDecimal}",
          "fixed_method": "  protected final static String WRITE_RAW = \"write a raw (unencoded) value\"; protected final static String WRITE_STRING = \"write a string\"; /** * This value is the limit of scale allowed for serializing {@link BigDecimal}",
          "diff": [
            "@@ -50,6 +50,7 @@",
            "      * \n",
            "      * @since 2.7.7\n",
            "      */\n",
            "+    protected final static int MAX_BIG_DECIMAL_SCALE = 9999;\n",
            "     \n",
            "     /*\n",
            "     /**********************************************************\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  protected String _asString(BigDecimal value) throws IOException {\n  \n  return value.toString();\n  }",
          "fixed_method": "  protected String _asString(BigDecimal value) throws IOException {\n  if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {\n  \n  int scale = value.scale();\n  if ((scale < -MAX_BIG_DECIMAL_SCALE) || (scale > MAX_BIG_DECIMAL_SCALE)) {\n  _reportError(String.format(\n\"Attempt to write plain `java.math.BigDecimal` (see JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN) with illegal scale (%d): needs to be between [-%d, %d]\",\nscale, MAX_BIG_DECIMAL_SCALE, MAX_BIG_DECIMAL_SCALE));\n  }\n  return value.toPlainString();\n  }\n  return value.toString();\n  }",
          "diff": [
            "@@ -431,7 +432,16 @@",
            "      * @since 2.7.7\n",
            "      */\n",
            "     protected String _asString(BigDecimal value) throws IOException {\n",
            "+        if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {\n",
            "             // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector\n",
            "+            int scale = value.scale();\n",
            "+            if ((scale < -MAX_BIG_DECIMAL_SCALE) || (scale > MAX_BIG_DECIMAL_SCALE)) {\n",
            "+                _reportError(String.format(\n",
            "+\"Attempt to write plain `java.math.BigDecimal` (see JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN) with illegal scale (%d): needs to be between [-%d, %d]\",\n",
            "+scale, MAX_BIG_DECIMAL_SCALE, MAX_BIG_DECIMAL_SCALE));\n",
            "+            }\n",
            "+            return value.toPlainString();\n",
            "+        }\n",
            "         return value.toString();\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 9
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
      "buggy_full_code": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.*;\n\npublic class UTF8JsonGenerator extends JsonGeneratorImpl { private final static byte BYTE_u = (byte) 'u'; private final static byte BYTE_0 = (byte) '0'; private final static byte BYTE_LBRACKET = (byte) '['; private final static byte BYTE_RBRACKET = (byte) ']'; private final static byte BYTE_LCURLY = (byte) ' {';\n    private final static byte BYTE_RCURLY = (byte) '}'; private final static byte BYTE_BACKSLASH = (byte) '\\\\'; private final static byte BYTE_COMMA = (byte) ','; private final static byte BYTE_COLON = (byte) ':'; private final static byte BYTE_QUOTE = (byte) '\"'; private final static int MAX_BYTES_TO_BUFFER = 512; private final static byte[] HEX_CHARS = CharTypes.copyHexBytes(); private final static byte[] NULL_BYTES = { 'n', 'u', 'l', 'l' };\n    private final static byte[] TRUE_BYTES = { 't', 'r', 'u', 'e' }; private final static byte[] FALSE_BYTES = { 'f', 'a', 'l', 's', 'e' }; final protected OutputStream _outputStream; protected byte[] _outputBuffer; protected int _outputTail; protected final int _outputEnd; protected final int _outputMaxContiguous; protected char[] _charBuffer; protected final int _charBufferLength; protected byte[] _entityBuffer; protected boolean _bufferRecyclable; public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out) {\n        super(ctxt, features, codec);\n        _outputStream = out;\n        _bufferRecyclable = true;\n        _outputBuffer = ctxt.allocWriteEncodingBuffer();\n        _outputEnd = _outputBuffer.length;\n\n        \n        _outputMaxContiguous = _outputEnd >> 3;\n        _charBuffer = ctxt.allocConcatBuffer();\n        _charBufferLength = _charBuffer.length;\n\n        \n        if (isEnabled(Feature.ESCAPE_NON_ASCII)) {\n            setHighestNonEscapedChar(127);\n        }\n    }\n    \n    public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable) {\n        \n        super(ctxt, features, codec);\n        _outputStream = out;\n        _bufferRecyclable = bufferRecyclable;\n        _outputTail = outputOffset;\n        _outputBuffer = outputBuffer;\n        _outputEnd = _outputBuffer.length;\n        \n        _outputMaxContiguous = (_outputEnd >> 3);\n        _charBuffer = ctxt.allocConcatBuffer();\n        _charBufferLength = _charBuffer.length;\n    }\n\n    \n    \n    @Override\n    public Object getOutputTarget() {\n        return _outputStream;\n    }\n\n    @Override\n    public int getOutputBuffered() {\n        \n        return _outputTail;\n    }\n\n    \n\n    @Override\n    public void writeFieldName(String name) throws IOException {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name);\n            return;\n        }\n        final int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { \n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_COMMA;\n        }\n        \n        if (_cfgUnqNames) {\n            _writeStringSegments(name, false);\n            return;\n        }\n        final int len = name.length();\n        \n        if (len > _charBufferLength) { \n            _writeStringSegments(name, true);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        \n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { \n                _flushBuffer();\n            }\n            _writeStringSegment(name, 0, len);\n        } else {\n            _writeStringSegments(name, 0, len);\n        }\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeFieldName(SerializableString name) throws IOException {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name);\n            return;\n        }\n        final int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_COMMA;\n        }\n        if (_cfgUnqNames) {\n            _writeUnq(name);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        int len = name.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) { \n            _writeBytes(name.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }    \n\n    private final void _writeUnq(SerializableString name) throws IOException {\n        int len = name.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) {\n            _writeBytes(name.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n    }\n    \n    \n\n    @Override\n    public final void writeStartArray() throws IOException {\n        _verifyValueWrite(\"start an array\");\n        _writeContext = _writeContext.createChildArrayContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartArray(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_LBRACKET;\n        }\n    }\n\n    @Override\n    public final void writeEndArray() throws IOException {\n        if (!_writeContext.inArray()) {\n            _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_RBRACKET;\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    @Override\n    public final void writeStartObject() throws IOException {\n        _verifyValueWrite(\"start an object\");\n        _writeContext = _writeContext.createChildObjectContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartObject(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_LCURLY;\n        }\n    }\n\n    @Override\n    public final void writeEndObject() throws IOException {\n        if (!_writeContext.inObject()) {\n            _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_RCURLY;\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    \n    protected final void _writePPFieldName(String name) throws IOException {\n        int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if ((status == JsonWriteContext.STATUS_OK_AFTER_COMMA)) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n        if (_cfgUnqNames) {\n            _writeStringSegments(name, false);\n            return;\n        }\n        final int len = name.length();\n        if (len > _charBufferLength) {\n            _writeStringSegments(name, true);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        name.getChars(0, len, _charBuffer, 0);\n        \n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { \n                _flushBuffer();\n            }\n            _writeStringSegment(_charBuffer, 0, len);\n        } else {\n            _writeStringSegments(_charBuffer, 0, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    protected final void _writePPFieldName(SerializableString name) throws IOException {\n        final int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n\n        final boolean addQuotes = !_cfgUnqNames; \n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n        _writeBytes(name.asQuotedUTF8());\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n    }\n    \n    \n\n    @Override\n    public void writeString(String text) throws IOException {\n        _verifyValueWrite(WRITE_STRING);\n        if (text == null) {\n            _writeNull();\n            return;\n        }\n        \n        final int len = text.length();\n        if (len > _outputMaxContiguous) { \n            _writeStringSegments(text, true);\n            return;\n        }\n        if ((_outputTail + len) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeStringSegment(text, 0, len); \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        \n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { \n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n        } else {\n            _writeStringSegments(text, offset, len);\n        }\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public final void writeString(SerializableString text) throws IOException {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        int len = text.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) {\n            _writeBytes(text.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeBytes(text, offset, length);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int len) throws IOException {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        \n        if (len <= _outputMaxContiguous) {\n            _writeUTF8Segment(text, offset, len);\n        } else {\n            _writeUTF8Segments(text, offset, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    \n\n    @Override\n    public void writeRaw(String text) throws IOException {\n        final int len = text.length();\n        final char[] buf = _charBuffer;\n        if (len <= buf.length) {\n            text.getChars(0, len, buf, 0);\n            writeRaw(buf, 0, len);\n        } else {\n            writeRaw(text, 0, len);\n        }\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException {\n        final char[] buf = _charBuffer;\n\n        \n        if (len <= buf.length) {\n            text.getChars(offset, offset+len, buf, 0);\n            writeRaw(buf, 0, len);\n            return;\n        }\n\n        \n        \n        \n        final int maxChunk = (_outputEnd >> 2) + (_outputEnd >> 4); \n        final int maxBytes = maxChunk * 3;\n\n        while (len > 0) {\n            int len2 = Math.min(maxChunk, len);\n            text.getChars(offset, offset+len2, buf, 0);\n            if ((_outputTail + maxBytes) > _outputEnd) {\n                _flushBuffer();\n            }\n            \n            \n            if (len > 0) {\n                char ch = buf[len2-1];\n                if ((ch >= SURR1_FIRST) && (ch <= SURR1_LAST)) {\n                    --len2;\n                }\n            }\n            _writeRawSegment(buf, 0, len2);\n            offset += len2;\n            len -= len2;\n        }\n    }\n\n    @Override\n    public void writeRaw(SerializableString text) throws IOException {\n        byte[] raw = text.asUnquotedUTF8();\n        if (raw.length > 0) {\n            _writeBytes(raw);\n        }\n    }\n\n    \n    @Override\n    public void writeRawValue(SerializableString text) throws IOException {\n        _verifyValueWrite(WRITE_RAW);\n        byte[] raw = text.asUnquotedUTF8();\n        if (raw.length > 0) {\n            _writeBytes(raw);\n        }\n    }\n\n    \n    @Override\n    public final void writeRaw(char[] cbuf, int offset, int len) throws IOException {\n        \n        {\n            int len3 = len+len+len;\n            if ((_outputTail + len3) > _outputEnd) {\n                \n                if (_outputEnd < len3) { \n                    _writeSegmentedRaw(cbuf, offset, len);\n                    return;\n                }\n                \n                _flushBuffer();\n            }\n        }\n        len += offset; \n\n        \n        main_loop:\n        while (offset < len) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch > 0x7F) {\n                    break inner_loop;\n                }\n                _outputBuffer[_outputTail++] = (byte) ch;\n                if (++offset >= len) {\n                    break main_loop;\n                }\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { \n                _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, len);\n            }\n        }\n    }\n\n    @Override\n    public void writeRaw(char ch) throws IOException {\n        if ((_outputTail + 3) >= _outputEnd) {\n            _flushBuffer();\n        }\n        final byte[] bbuf = _outputBuffer;\n        if (ch <= 0x7F) {\n            bbuf[_outputTail++] = (byte) ch;\n        } else  if (ch < 0x800) { \n            bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n            bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n        } else {\n             _outputRawMultiByteChar(ch, null, 0, 0);\n        }\n    }\n\n    \n    private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException {\n        final int end = _outputEnd;\n        final byte[] bbuf = _outputBuffer;\n        final int inputEnd = offset + len;\n        \n        main_loop:\n        while (offset < inputEnd) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch >= 0x80) {\n                    break inner_loop;\n                }\n                \n                if (_outputTail >= end) {\n                    _flushBuffer();\n                }\n                bbuf[_outputTail++] = (byte) ch;\n                if (++offset >= inputEnd) {\n                    break main_loop;\n                }\n            }\n            if ((_outputTail + 3) >= _outputEnd) {\n                _flushBuffer();\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { \n                bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, inputEnd);\n            }\n        }\n    }\n\n    \n    private void _writeRawSegment(char[] cbuf, int offset, int end) throws IOException {\n        main_loop:\n        while (offset < end) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch > 0x7F) {\n                    break inner_loop;\n                }\n                _outputBuffer[_outputTail++] = (byte) ch;\n                if (++offset >= end) {\n                    break main_loop;\n                }\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { \n                _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, end);\n            }\n        }\n    }\n\n    \n\n    @Override\n    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException {\n        _verifyValueWrite(WRITE_BINARY);\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeBinary(b64variant, data, offset, offset+len);\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException {\n        _verifyValueWrite(WRITE_BINARY);\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        byte[] encodingBuffer = _ioContext.allocBase64Buffer();\n        int bytes;\n        try {\n            if (dataLength < 0) { \n                bytes = _writeBinary(b64variant, data, encodingBuffer);\n            } else {\n                int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength);\n                if (missing > 0) {\n                    _reportError(\"Too few bytes available: missing \"+missing+\" bytes (out of \"+dataLength+\")\");\n                }\n                bytes = dataLength;\n            }\n        } finally {\n            _ioContext.releaseBase64Buffer(encodingBuffer);\n        }\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        return bytes;\n    }\n    \n    \n\n    @Override\n    public void writeNumber(short s) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        \n        if ((_outputTail + 6) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedShort(s);\n            return;\n        }\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n    }\n    \n    private final void _writeQuotedShort(short s) throws IOException {\n        if ((_outputTail + 8) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    } \n    \n    @Override\n    public void writeNumber(int i) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        \n        if ((_outputTail + 11) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedInt(i);\n            return;\n        }\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n    }\n\n    private final void _writeQuotedInt(int i) throws IOException {\n        if ((_outputTail + 13) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }    \n\n    @Override\n    public void writeNumber(long l) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedLong(l);\n            return;\n        }\n        if ((_outputTail + 21) >= _outputEnd) {\n            \n            _flushBuffer();\n        }\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n    }\n\n    private final void _writeQuotedLong(long l) throws IOException {\n        if ((_outputTail + 23) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeNumber(BigInteger value) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(value.toString());\n        } else {\n            writeRaw(value.toString());\n        }\n    }\n\n    \n    @Override\n    public void writeNumber(double d) throws IOException {\n        if (_cfgNumbersAsStrings ||\n            (((Double.isNaN(d) || Double.isInfinite(d))\n                && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {\n            writeString(String.valueOf(d));\n            return;\n        }\n        \n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException {\n        if (_cfgNumbersAsStrings ||\n            \n            (((Float.isNaN(f) || Float.isInfinite(f))\n                && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {\n            writeString(String.valueOf(f));\n            return;\n        }\n        \n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal value) throws IOException {\n        \n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else  if (_cfgNumbersAsStrings) {\n            String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString();\n            _writeQuotedRaw(raw);\n        } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {\n            writeRaw(value.toPlainString());\n        } else {\n            writeRaw(_asString(value));\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(encodedValue);            \n        } else {\n            writeRaw(encodedValue);\n        }\n    }\n\n    private final void _writeQuotedRaw(String value) throws IOException {\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        writeRaw(value);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeBoolean(boolean state) throws IOException {\n        _verifyValueWrite(WRITE_BOOLEAN);\n        if ((_outputTail + 5) >= _outputEnd) {\n            _flushBuffer();\n        }\n        byte[] keyword = state ? TRUE_BYTES : FALSE_BYTES;\n        int len = keyword.length;\n        System.arraycopy(keyword, 0, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    @Override\n    public void writeNull() throws IOException {\n        _verifyValueWrite(WRITE_NULL);\n        _writeNull();\n    }\n\n    \n\n    @Override\n    protected final void _verifyValueWrite(String typeMsg) throws IOException {\n        int status = _writeContext.writeValue();\n        if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n            _reportError(\"Can not \"+typeMsg+\", expecting field name\");\n        }\n        if (_cfgPrettyPrinter == null) {\n            byte b;\n            switch (status) {\n            case JsonWriteContext.STATUS_OK_AFTER_COMMA:\n                b = BYTE_COMMA;\n                break;\n            case JsonWriteContext.STATUS_OK_AFTER_COLON:\n                b = BYTE_COLON;\n                break;\n            case JsonWriteContext.STATUS_OK_AFTER_SPACE: \n                if (_rootValueSeparator != null) {\n                    byte[] raw = _rootValueSeparator.asUnquotedUTF8();\n                    if (raw.length > 0) {\n                        _writeBytes(raw);\n                    }\n                }\n                return;\n            case JsonWriteContext.STATUS_OK_AS_IS:\n            default:\n                return;\n            }\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail] = b;\n            ++_outputTail;\n            return;\n        }\n        \n        _verifyPrettyValueWrite(typeMsg, status);\n    }\n\n    protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException {\n        \n        switch (status) {\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA: \n            _cfgPrettyPrinter.writeArrayValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\n            _cfgPrettyPrinter.writeObjectFieldValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_SPACE:\n            _cfgPrettyPrinter.writeRootValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AS_IS:\n            \n            if (_writeContext.inArray()) {\n                _cfgPrettyPrinter.beforeArrayValues(this);\n            } else if (_writeContext.inObject()) {\n                _cfgPrettyPrinter.beforeObjectEntries(this);\n            }\n            break;\n        default:\n            _throwInternal();\n            break;\n        }\n    }\n\n    \n\n    @Override\n    public void flush() throws IOException {\n        _flushBuffer();\n        if (_outputStream != null) {\n            if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                _outputStream.flush();\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        super.close();\n\n        \n        \n        if ((_outputBuffer != null)\n            && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {\n            while (true) {\n                JsonStreamContext ctxt = getOutputContext();\n                if (ctxt.inArray()) {\n                    writeEndArray();\n                } else if (ctxt.inObject()) {\n                    writeEndObject();\n                } else {\n                    break;\n                }\n            }\n        }\n        _flushBuffer();\n        _outputTail = 0; \n\n        \n        if (_outputStream != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {\n                _outputStream.close();\n            } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                \n                _outputStream.flush();\n            }\n        }\n        \n        _releaseBuffers();\n    }\n\n    @Override\n    protected void _releaseBuffers() {\n        byte[] buf = _outputBuffer;\n        if (buf != null && _bufferRecyclable) {\n            _outputBuffer = null;\n            _ioContext.releaseWriteEncodingBuffer(buf);\n        }\n        char[] cbuf = _charBuffer;\n        if (cbuf != null) {\n            _charBuffer = null;\n            _ioContext.releaseConcatBuffer(cbuf);\n        }\n    }\n\n    \n\n    private final void _writeBytes(byte[] bytes) throws IOException {\n        final int len = bytes.length;\n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n            \n            if (len > MAX_BYTES_TO_BUFFER) {\n                _outputStream.write(bytes, 0, len);\n                return;\n            }\n        }\n        System.arraycopy(bytes, 0, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException {\n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n            \n            if (len > MAX_BYTES_TO_BUFFER) {\n                _outputStream.write(bytes, offset, len);\n                return;\n            }\n        }\n        System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    \n    \n    \n    private final void _writeStringSegments(String text, boolean addQuotes) throws IOException {\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;        \n        }\n\n        int left = text.length();\n        int offset = 0;\n\n        while (left > 0) {\n            int len = Math.min(_outputMaxContiguous, left);\n            if ((_outputTail + len) > _outputEnd) { \n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n            offset += len;\n            left -= len;\n        }\n\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n    }\n\n    \n    private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            if ((_outputTail + len) > _outputEnd) { \n                _flushBuffer();\n            }\n            _writeStringSegment(cbuf, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n\n    private final void _writeStringSegments(String text, int offset, int totalLen) throws IOException {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            if ((_outputTail + len) > _outputEnd) { \n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n\n    \n\n    \n    private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException {\n        \n        \n        \n        len += offset; \n\n        int outputPtr = _outputTail;\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n\n        while (offset < len) {\n            int ch = cbuf[offset];\n            \n            if (ch > 0x7F || escCodes[ch] != 0) {\n                break;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n            ++offset;\n        }\n        _outputTail = outputPtr;\n        if (offset < len) {\n            \n            if (_characterEscapes != null) {\n                _writeCustomStringSegment2(cbuf, offset, len);\n            \n            } else if (_maximumNonEscapedChar == 0) {\n                _writeStringSegment2(cbuf, offset, len);\n            } else {\n                _writeStringSegmentASCII2(cbuf, offset, len);\n            }\n\n        }\n    }\n\n    private final void _writeStringSegment(String text, int offset, int len) throws IOException {\n        \n        \n        len += offset; \n\n        int outputPtr = _outputTail;\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n\n        while (offset < len) {\n            int ch = text.charAt(offset);\n            \n            if (ch > 0x7F || escCodes[ch] != 0) {\n                break;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n            ++offset;\n        }\n        _outputTail = outputPtr;\n        if (offset < len) {\n            if (_characterEscapes != null) {\n                _writeCustomStringSegment2(text, offset, len);\n            } else if (_maximumNonEscapedChar == 0) {\n                _writeStringSegment2(text, offset, len);\n            } else {\n                _writeStringSegmentASCII2(text, offset, len);\n            }\n        }\n    }\n\n    \n    private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException {\n        \n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n\n        int outputPtr = _outputTail;\n\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { \n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     \n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                }\n                continue;\n            }\n            if (ch <= 0x7FF) { \n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeStringSegment2(final String text, int offset, final int end) throws IOException {\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n\n        int outputPtr = _outputTail;\n\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { \n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     \n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                }\n                continue;\n            }\n            if (ch <= 0x7FF) { \n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    \n\n    \n    private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException {\n        \n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n    \n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        final int maxUnescaped = _maximumNonEscapedChar;\n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { \n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     \n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { \n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            if (ch <= 0x7FF) { \n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeStringSegmentASCII2(final String text, int offset, final int end) throws IOException {\n        \n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n    \n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        final int maxUnescaped = _maximumNonEscapedChar;\n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { \n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     \n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { \n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            if (ch <= 0x7FF) { \n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    \n\n    \n    private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException {\n        \n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar;\n        final CharacterEscapes customEscapes = _characterEscapes; \n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { \n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) {\n                     SerializableString esc = customEscapes.getEscapeSequence(ch);\n                     if (esc == null) {\n                         _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\"\n                                 +Integer.toHexString(ch)+\", although was supposed to have one\");\n                     }\n                     outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                 } else {\n                     \n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { \n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            SerializableString esc = customEscapes.getEscapeSequence(ch);\n            if (esc != null) {\n                outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                continue;\n            }\n            if (ch <= 0x7FF) { \n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeCustomStringSegment2(final String text, int offset, final int end) throws IOException {\n        \n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar;\n        final CharacterEscapes customEscapes = _characterEscapes; \n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { \n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) {\n                     SerializableString esc = customEscapes.getEscapeSequence(ch);\n                     if (esc == null) {\n                         _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\"\n                                 +Integer.toHexString(ch)+\", although was supposed to have one\");\n                     }\n                     outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                 } else {\n                     \n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { \n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            SerializableString esc = customEscapes.getEscapeSequence(ch);\n            if (esc != null) {\n                outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                continue;\n            }\n            if (ch <= 0x7FF) { \n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException {\n        byte[] raw = esc.asUnquotedUTF8(); \n        int len = raw.length;\n        if (len > 6) { \n            return _handleLongCustomEscape(outputBuffer, outputPtr, _outputEnd, raw, remainingChars);\n        }\n        \n        System.arraycopy(raw, 0, outputBuffer, outputPtr, len);\n        return (outputPtr + len);\n    }\n    \n    private final int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException {\n        int len = raw.length;\n        if ((outputPtr + len) > outputEnd) {\n            _outputTail = outputPtr;\n            _flushBuffer();\n            outputPtr = _outputTail;\n            if (len > outputBuffer.length) { \n                _outputStream.write(raw, 0, len);\n                return outputPtr;\n            }\n            System.arraycopy(raw, 0, outputBuffer, outputPtr, len);\n            outputPtr += len;\n        }\n        \n        if ((outputPtr +  6 * remainingChars) > outputEnd) {\n            _flushBuffer();\n            return _outputTail;\n        }\n        return outputPtr;\n    }\n\n    \n    \n    \n    private final void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            _writeUTF8Segment(utf8, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n    \n    private final void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException {\n        \n        final int[] escCodes = _outputEscapes;\n\n        for (int ptr = offset, end = offset + len; ptr < end; ) {\n            \n            int ch = utf8[ptr++];\n            if ((ch >= 0) && escCodes[ch] != 0) {\n                _writeUTF8Segment2(utf8, offset, len);\n                return;\n            }\n        }\n        \n        \n        if ((_outputTail + len) > _outputEnd) { \n            _flushBuffer(); \n        }\n        System.arraycopy(utf8, offset, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    private final void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException {\n        int outputPtr = _outputTail;\n\n        \n        if ((outputPtr + (len * 6)) > _outputEnd) {\n            _flushBuffer();\n            outputPtr = _outputTail;\n        }\n        \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        len += offset; \n        \n        while (offset < len) {\n            byte b = utf8[offset++];\n            int ch = b;\n            if (ch < 0 || escCodes[ch] == 0) {\n                outputBuffer[outputPtr++] = b;\n                continue;\n            }\n            int escape = escCodes[ch];\n            if (escape > 0) { \n                outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                outputBuffer[outputPtr++] = (byte) escape;\n            } else {\n                \n                outputPtr = _writeGenericEscape(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    \n    \n    protected final void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException {\n        \n        int safeInputEnd = inputEnd - 3;\n        \n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        \n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            \n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                \n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        \n        int inputLeft = inputEnd - inputPtr; \n        if (inputLeft > 0) { \n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }\n\n    \n    protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        \n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { \n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { \n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        \n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { \n                if (_outputTail > safeOutputEnd) { \n                    _flushBuffer();\n                }\n                int b24 = ((int) readBuffer[inputPtr++]) << 16;\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }\n\n    \n    protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;\n        int bytesDone = 0;\n        \n        \n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        \n        while (true) {\n            if (inputPtr > lastFullOffset) { \n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length);\n                inputPtr = 0;\n                if (inputEnd < 3) { \n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            \n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesDone += 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        \n        if (inputPtr < inputEnd) { \n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 16;\n            int amount = 1;\n            if (inputPtr < inputEnd) {\n                b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                amount = 2;\n            }\n            bytesDone += amount;\n            _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n        }\n        return bytesDone;\n    }\n    \n    private final int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException {\n        \n        int i = 0;\n        while (inputPtr < inputEnd) {\n            readBuffer[i++]  = readBuffer[inputPtr++];\n        }\n        inputPtr = 0;\n        inputEnd = i;\n        maxRead = Math.min(maxRead, readBuffer.length);\n        \n        do {\n            int length = maxRead - inputEnd;\n            if (length == 0) {\n                break;\n            }\n            int count = in.read(readBuffer, inputEnd, length);            \n            if (count < 0) {\n                return inputEnd;\n            }\n            inputEnd += count;\n        } while (inputEnd < 3);\n        return inputEnd;\n    }\n    \n    \n    \n    \n    private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n        \n        if (ch >= SURR1_FIRST) {\n            if (ch <= SURR2_LAST) { \n                \n                if (inputOffset >= inputEnd || cbuf == null) { \n                    _reportError(String.format(\n\"Split surrogate on writeRaw() input (last character): first character 0x%4x\", ch));\n                }\n                _outputSurrogates(ch, cbuf[inputOffset]);\n                return inputOffset+1;\n            }\n        }\n        final byte[] bbuf = _outputBuffer;\n        bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n        return inputOffset;\n    }\n\n    protected final void _outputSurrogates(int surr1, int surr2) throws IOException {\n        int c = _decodeSurrogate(surr1, surr2);\n        if ((_outputTail + 4) > _outputEnd) {\n            _flushBuffer();\n        }\n        final byte[] bbuf = _outputBuffer;\n        bbuf[_outputTail++] = (byte) (0xf0 | (c >> 18));\n        bbuf[_outputTail++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (c & 0x3f));\n    }\n    \n    \n    private final int _outputMultiByteChar(int ch, int outputPtr) throws IOException {\n        byte[] bbuf = _outputBuffer;\n        if (ch >= SURR1_FIRST && ch <= SURR2_LAST) { \n            \n            \n            \n\n                bbuf[outputPtr++] = BYTE_BACKSLASH;\n                bbuf[outputPtr++] = BYTE_u;\n                \n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[ch & 0xF];\n\n        } else {\n            bbuf[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n            bbuf[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n            bbuf[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n        }\n        return outputPtr;\n    }\n\n    private final void _writeNull() throws IOException {\n        if ((_outputTail + 4) >= _outputEnd) {\n            _flushBuffer();\n        }\n        System.arraycopy(NULL_BYTES, 0, _outputBuffer, _outputTail, 4);\n        _outputTail += 4;\n    }\n        \n    \n    private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException {\n        final byte[] bbuf = _outputBuffer;\n        bbuf[outputPtr++] = BYTE_BACKSLASH;\n        bbuf[outputPtr++] = BYTE_u;\n        if (charToEscape > 0xFF) {\n            int hi = (charToEscape >> 8) & 0xFF;\n            bbuf[outputPtr++] = HEX_CHARS[hi >> 4];\n            bbuf[outputPtr++] = HEX_CHARS[hi & 0xF];\n            charToEscape &= 0xFF;\n        } else {\n            bbuf[outputPtr++] = BYTE_0;\n            bbuf[outputPtr++] = BYTE_0;\n        }\n        \n        bbuf[outputPtr++] = HEX_CHARS[charToEscape >> 4];\n        bbuf[outputPtr++] = HEX_CHARS[charToEscape & 0xF];\n        return outputPtr;\n    }\n\n    protected final void _flushBuffer() throws IOException {\n        int len = _outputTail;\n        if (len > 0) {\n            _outputTail = 0;\n            _outputStream.write(_outputBuffer, 0, len);\n        }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.*;\n\npublic class UTF8JsonGenerator extends JsonGeneratorImpl { private final static byte BYTE_u = (byte) 'u'; private final static byte BYTE_0 = (byte) '0'; private final static byte BYTE_LBRACKET = (byte) '['; private final static byte BYTE_RBRACKET = (byte) ']'; private final static byte BYTE_LCURLY = (byte) ' {';\n    private final static byte BYTE_RCURLY = (byte) '}'; private final static byte BYTE_BACKSLASH = (byte) '\\\\'; private final static byte BYTE_COMMA = (byte) ','; private final static byte BYTE_COLON = (byte) ':'; private final static byte BYTE_QUOTE = (byte) '\"'; private final static int MAX_BYTES_TO_BUFFER = 512; private final static byte[] HEX_CHARS = CharTypes.copyHexBytes(); private final static byte[] NULL_BYTES = { 'n', 'u', 'l', 'l' };\n    private final static byte[] TRUE_BYTES = { 't', 'r', 'u', 'e' }; private final static byte[] FALSE_BYTES = { 'f', 'a', 'l', 's', 'e' }; final protected OutputStream _outputStream; protected byte[] _outputBuffer; protected int _outputTail; protected final int _outputEnd; protected final int _outputMaxContiguous; protected char[] _charBuffer; protected final int _charBufferLength; protected byte[] _entityBuffer; protected boolean _bufferRecyclable; public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out) {\n        super(ctxt, features, codec);\n        _outputStream = out;\n        _bufferRecyclable = true;\n        _outputBuffer = ctxt.allocWriteEncodingBuffer();\n        _outputEnd = _outputBuffer.length;\n\n        \n        _outputMaxContiguous = _outputEnd >> 3;\n        _charBuffer = ctxt.allocConcatBuffer();\n        _charBufferLength = _charBuffer.length;\n\n        \n        if (isEnabled(Feature.ESCAPE_NON_ASCII)) {\n            setHighestNonEscapedChar(127);\n        }\n    }\n    \n    public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable) {\n        \n        super(ctxt, features, codec);\n        _outputStream = out;\n        _bufferRecyclable = bufferRecyclable;\n        _outputTail = outputOffset;\n        _outputBuffer = outputBuffer;\n        _outputEnd = _outputBuffer.length;\n        \n        _outputMaxContiguous = (_outputEnd >> 3);\n        _charBuffer = ctxt.allocConcatBuffer();\n        _charBufferLength = _charBuffer.length;\n    }\n\n    \n    \n    @Override\n    public Object getOutputTarget() {\n        return _outputStream;\n    }\n\n    @Override\n    public int getOutputBuffered() {\n        \n        return _outputTail;\n    }\n\n    \n\n    @Override\n    public void writeFieldName(String name) throws IOException {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name);\n            return;\n        }\n        final int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { \n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_COMMA;\n        }\n        \n        if (_cfgUnqNames) {\n            _writeStringSegments(name, false);\n            return;\n        }\n        final int len = name.length();\n        \n        if (len > _charBufferLength) { \n            _writeStringSegments(name, true);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        \n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { \n                _flushBuffer();\n            }\n            _writeStringSegment(name, 0, len);\n        } else {\n            _writeStringSegments(name, 0, len);\n        }\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeFieldName(SerializableString name) throws IOException {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name);\n            return;\n        }\n        final int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_COMMA;\n        }\n        if (_cfgUnqNames) {\n            _writeUnq(name);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        int len = name.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) { \n            _writeBytes(name.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }    \n\n    private final void _writeUnq(SerializableString name) throws IOException {\n        int len = name.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) {\n            _writeBytes(name.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n    }\n    \n    \n\n    @Override\n    public final void writeStartArray() throws IOException {\n        _verifyValueWrite(\"start an array\");\n        _writeContext = _writeContext.createChildArrayContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartArray(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_LBRACKET;\n        }\n    }\n\n    @Override\n    public final void writeEndArray() throws IOException {\n        if (!_writeContext.inArray()) {\n            _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_RBRACKET;\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    @Override\n    public final void writeStartObject() throws IOException {\n        _verifyValueWrite(\"start an object\");\n        _writeContext = _writeContext.createChildObjectContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartObject(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_LCURLY;\n        }\n    }\n\n    @Override\n    public final void writeEndObject() throws IOException {\n        if (!_writeContext.inObject()) {\n            _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_RCURLY;\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    \n    protected final void _writePPFieldName(String name) throws IOException {\n        int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if ((status == JsonWriteContext.STATUS_OK_AFTER_COMMA)) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n        if (_cfgUnqNames) {\n            _writeStringSegments(name, false);\n            return;\n        }\n        final int len = name.length();\n        if (len > _charBufferLength) {\n            _writeStringSegments(name, true);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        name.getChars(0, len, _charBuffer, 0);\n        \n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { \n                _flushBuffer();\n            }\n            _writeStringSegment(_charBuffer, 0, len);\n        } else {\n            _writeStringSegments(_charBuffer, 0, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    protected final void _writePPFieldName(SerializableString name) throws IOException {\n        final int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n\n        final boolean addQuotes = !_cfgUnqNames; \n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n        _writeBytes(name.asQuotedUTF8());\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n    }\n    \n    \n\n    @Override\n    public void writeString(String text) throws IOException {\n        _verifyValueWrite(WRITE_STRING);\n        if (text == null) {\n            _writeNull();\n            return;\n        }\n        \n        final int len = text.length();\n        if (len > _outputMaxContiguous) { \n            _writeStringSegments(text, true);\n            return;\n        }\n        if ((_outputTail + len) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeStringSegment(text, 0, len); \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        \n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { \n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n        } else {\n            _writeStringSegments(text, offset, len);\n        }\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public final void writeString(SerializableString text) throws IOException {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        int len = text.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) {\n            _writeBytes(text.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeBytes(text, offset, length);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int len) throws IOException {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        \n        if (len <= _outputMaxContiguous) {\n            _writeUTF8Segment(text, offset, len);\n        } else {\n            _writeUTF8Segments(text, offset, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    \n\n    @Override\n    public void writeRaw(String text) throws IOException {\n        final int len = text.length();\n        final char[] buf = _charBuffer;\n        if (len <= buf.length) {\n            text.getChars(0, len, buf, 0);\n            writeRaw(buf, 0, len);\n        } else {\n            writeRaw(text, 0, len);\n        }\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException {\n        final char[] buf = _charBuffer;\n\n        \n        if (len <= buf.length) {\n            text.getChars(offset, offset+len, buf, 0);\n            writeRaw(buf, 0, len);\n            return;\n        }\n\n        \n        \n        \n        final int maxChunk = (_outputEnd >> 2) + (_outputEnd >> 4); \n        final int maxBytes = maxChunk * 3;\n\n        while (len > 0) {\n            int len2 = Math.min(maxChunk, len);\n            text.getChars(offset, offset+len2, buf, 0);\n            if ((_outputTail + maxBytes) > _outputEnd) {\n                _flushBuffer();\n            }\n            \n            \n            if (len > 0) {\n                char ch = buf[len2-1];\n                if ((ch >= SURR1_FIRST) && (ch <= SURR1_LAST)) {\n                    --len2;\n                }\n            }\n            _writeRawSegment(buf, 0, len2);\n            offset += len2;\n            len -= len2;\n        }\n    }\n\n    @Override\n    public void writeRaw(SerializableString text) throws IOException {\n        byte[] raw = text.asUnquotedUTF8();\n        if (raw.length > 0) {\n            _writeBytes(raw);\n        }\n    }\n\n    \n    @Override\n    public void writeRawValue(SerializableString text) throws IOException {\n        _verifyValueWrite(WRITE_RAW);\n        byte[] raw = text.asUnquotedUTF8();\n        if (raw.length > 0) {\n            _writeBytes(raw);\n        }\n    }\n\n    \n    @Override\n    public final void writeRaw(char[] cbuf, int offset, int len) throws IOException {\n        \n        {\n            int len3 = len+len+len;\n            if ((_outputTail + len3) > _outputEnd) {\n                \n                if (_outputEnd < len3) { \n                    _writeSegmentedRaw(cbuf, offset, len);\n                    return;\n                }\n                \n                _flushBuffer();\n            }\n        }\n        len += offset; \n\n        \n        main_loop:\n        while (offset < len) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch > 0x7F) {\n                    break inner_loop;\n                }\n                _outputBuffer[_outputTail++] = (byte) ch;\n                if (++offset >= len) {\n                    break main_loop;\n                }\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { \n                _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, len);\n            }\n        }\n    }\n\n    @Override\n    public void writeRaw(char ch) throws IOException {\n        if ((_outputTail + 3) >= _outputEnd) {\n            _flushBuffer();\n        }\n        final byte[] bbuf = _outputBuffer;\n        if (ch <= 0x7F) {\n            bbuf[_outputTail++] = (byte) ch;\n        } else  if (ch < 0x800) { \n            bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n            bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n        } else {\n             _outputRawMultiByteChar(ch, null, 0, 0);\n        }\n    }\n\n    \n    private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException {\n        final int end = _outputEnd;\n        final byte[] bbuf = _outputBuffer;\n        final int inputEnd = offset + len;\n        \n        main_loop:\n        while (offset < inputEnd) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch >= 0x80) {\n                    break inner_loop;\n                }\n                \n                if (_outputTail >= end) {\n                    _flushBuffer();\n                }\n                bbuf[_outputTail++] = (byte) ch;\n                if (++offset >= inputEnd) {\n                    break main_loop;\n                }\n            }\n            if ((_outputTail + 3) >= _outputEnd) {\n                _flushBuffer();\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { \n                bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, inputEnd);\n            }\n        }\n    }\n\n    \n    private void _writeRawSegment(char[] cbuf, int offset, int end) throws IOException {\n        main_loop:\n        while (offset < end) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch > 0x7F) {\n                    break inner_loop;\n                }\n                _outputBuffer[_outputTail++] = (byte) ch;\n                if (++offset >= end) {\n                    break main_loop;\n                }\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { \n                _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, end);\n            }\n        }\n    }\n\n    \n\n    @Override\n    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException {\n        _verifyValueWrite(WRITE_BINARY);\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeBinary(b64variant, data, offset, offset+len);\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException {\n        _verifyValueWrite(WRITE_BINARY);\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        byte[] encodingBuffer = _ioContext.allocBase64Buffer();\n        int bytes;\n        try {\n            if (dataLength < 0) { \n                bytes = _writeBinary(b64variant, data, encodingBuffer);\n            } else {\n                int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength);\n                if (missing > 0) {\n                    _reportError(\"Too few bytes available: missing \"+missing+\" bytes (out of \"+dataLength+\")\");\n                }\n                bytes = dataLength;\n            }\n        } finally {\n            _ioContext.releaseBase64Buffer(encodingBuffer);\n        }\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        return bytes;\n    }\n    \n    \n\n    @Override\n    public void writeNumber(short s) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        \n        if ((_outputTail + 6) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedShort(s);\n            return;\n        }\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n    }\n    \n    private final void _writeQuotedShort(short s) throws IOException {\n        if ((_outputTail + 8) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    } \n    \n    @Override\n    public void writeNumber(int i) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        \n        if ((_outputTail + 11) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedInt(i);\n            return;\n        }\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n    }\n\n    private final void _writeQuotedInt(int i) throws IOException {\n        if ((_outputTail + 13) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }    \n\n    @Override\n    public void writeNumber(long l) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedLong(l);\n            return;\n        }\n        if ((_outputTail + 21) >= _outputEnd) {\n            \n            _flushBuffer();\n        }\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n    }\n\n    private final void _writeQuotedLong(long l) throws IOException {\n        if ((_outputTail + 23) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeNumber(BigInteger value) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(value.toString());\n        } else {\n            writeRaw(value.toString());\n        }\n    }\n\n    \n    @Override\n    public void writeNumber(double d) throws IOException {\n        if (_cfgNumbersAsStrings ||\n            (((Double.isNaN(d) || Double.isInfinite(d))\n                && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {\n            writeString(String.valueOf(d));\n            return;\n        }\n        \n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException {\n        if (_cfgNumbersAsStrings ||\n            \n            (((Float.isNaN(f) || Float.isInfinite(f))\n                && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {\n            writeString(String.valueOf(f));\n            return;\n        }\n        \n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal value) throws IOException {\n        \n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else  if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(_asString(value));\n        } else {\n            writeRaw(_asString(value));\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(encodedValue);            \n        } else {\n            writeRaw(encodedValue);\n        }\n    }\n\n    private final void _writeQuotedRaw(String value) throws IOException {\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        writeRaw(value);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeBoolean(boolean state) throws IOException {\n        _verifyValueWrite(WRITE_BOOLEAN);\n        if ((_outputTail + 5) >= _outputEnd) {\n            _flushBuffer();\n        }\n        byte[] keyword = state ? TRUE_BYTES : FALSE_BYTES;\n        int len = keyword.length;\n        System.arraycopy(keyword, 0, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    @Override\n    public void writeNull() throws IOException {\n        _verifyValueWrite(WRITE_NULL);\n        _writeNull();\n    }\n\n    \n\n    @Override\n    protected final void _verifyValueWrite(String typeMsg) throws IOException {\n        int status = _writeContext.writeValue();\n        if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n            _reportError(\"Can not \"+typeMsg+\", expecting field name\");\n        }\n        if (_cfgPrettyPrinter == null) {\n            byte b;\n            switch (status) {\n            case JsonWriteContext.STATUS_OK_AFTER_COMMA:\n                b = BYTE_COMMA;\n                break;\n            case JsonWriteContext.STATUS_OK_AFTER_COLON:\n                b = BYTE_COLON;\n                break;\n            case JsonWriteContext.STATUS_OK_AFTER_SPACE: \n                if (_rootValueSeparator != null) {\n                    byte[] raw = _rootValueSeparator.asUnquotedUTF8();\n                    if (raw.length > 0) {\n                        _writeBytes(raw);\n                    }\n                }\n                return;\n            case JsonWriteContext.STATUS_OK_AS_IS:\n            default:\n                return;\n            }\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail] = b;\n            ++_outputTail;\n            return;\n        }\n        \n        _verifyPrettyValueWrite(typeMsg, status);\n    }\n\n    protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException {\n        \n        switch (status) {\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA: \n            _cfgPrettyPrinter.writeArrayValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\n            _cfgPrettyPrinter.writeObjectFieldValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_SPACE:\n            _cfgPrettyPrinter.writeRootValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AS_IS:\n            \n            if (_writeContext.inArray()) {\n                _cfgPrettyPrinter.beforeArrayValues(this);\n            } else if (_writeContext.inObject()) {\n                _cfgPrettyPrinter.beforeObjectEntries(this);\n            }\n            break;\n        default:\n            _throwInternal();\n            break;\n        }\n    }\n\n    \n\n    @Override\n    public void flush() throws IOException {\n        _flushBuffer();\n        if (_outputStream != null) {\n            if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                _outputStream.flush();\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        super.close();\n\n        \n        \n        if ((_outputBuffer != null)\n            && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {\n            while (true) {\n                JsonStreamContext ctxt = getOutputContext();\n                if (ctxt.inArray()) {\n                    writeEndArray();\n                } else if (ctxt.inObject()) {\n                    writeEndObject();\n                } else {\n                    break;\n                }\n            }\n        }\n        _flushBuffer();\n        _outputTail = 0; \n\n        \n        if (_outputStream != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {\n                _outputStream.close();\n            } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                \n                _outputStream.flush();\n            }\n        }\n        \n        _releaseBuffers();\n    }\n\n    @Override\n    protected void _releaseBuffers() {\n        byte[] buf = _outputBuffer;\n        if (buf != null && _bufferRecyclable) {\n            _outputBuffer = null;\n            _ioContext.releaseWriteEncodingBuffer(buf);\n        }\n        char[] cbuf = _charBuffer;\n        if (cbuf != null) {\n            _charBuffer = null;\n            _ioContext.releaseConcatBuffer(cbuf);\n        }\n    }\n\n    \n\n    private final void _writeBytes(byte[] bytes) throws IOException {\n        final int len = bytes.length;\n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n            \n            if (len > MAX_BYTES_TO_BUFFER) {\n                _outputStream.write(bytes, 0, len);\n                return;\n            }\n        }\n        System.arraycopy(bytes, 0, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException {\n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n            \n            if (len > MAX_BYTES_TO_BUFFER) {\n                _outputStream.write(bytes, offset, len);\n                return;\n            }\n        }\n        System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    \n    \n    \n    private final void _writeStringSegments(String text, boolean addQuotes) throws IOException {\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;        \n        }\n\n        int left = text.length();\n        int offset = 0;\n\n        while (left > 0) {\n            int len = Math.min(_outputMaxContiguous, left);\n            if ((_outputTail + len) > _outputEnd) { \n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n            offset += len;\n            left -= len;\n        }\n\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n    }\n\n    \n    private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            if ((_outputTail + len) > _outputEnd) { \n                _flushBuffer();\n            }\n            _writeStringSegment(cbuf, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n\n    private final void _writeStringSegments(String text, int offset, int totalLen) throws IOException {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            if ((_outputTail + len) > _outputEnd) { \n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n\n    \n\n    \n    private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException {\n        \n        \n        \n        len += offset; \n\n        int outputPtr = _outputTail;\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n\n        while (offset < len) {\n            int ch = cbuf[offset];\n            \n            if (ch > 0x7F || escCodes[ch] != 0) {\n                break;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n            ++offset;\n        }\n        _outputTail = outputPtr;\n        if (offset < len) {\n            \n            if (_characterEscapes != null) {\n                _writeCustomStringSegment2(cbuf, offset, len);\n            \n            } else if (_maximumNonEscapedChar == 0) {\n                _writeStringSegment2(cbuf, offset, len);\n            } else {\n                _writeStringSegmentASCII2(cbuf, offset, len);\n            }\n\n        }\n    }\n\n    private final void _writeStringSegment(String text, int offset, int len) throws IOException {\n        \n        \n        len += offset; \n\n        int outputPtr = _outputTail;\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n\n        while (offset < len) {\n            int ch = text.charAt(offset);\n            \n            if (ch > 0x7F || escCodes[ch] != 0) {\n                break;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n            ++offset;\n        }\n        _outputTail = outputPtr;\n        if (offset < len) {\n            if (_characterEscapes != null) {\n                _writeCustomStringSegment2(text, offset, len);\n            } else if (_maximumNonEscapedChar == 0) {\n                _writeStringSegment2(text, offset, len);\n            } else {\n                _writeStringSegmentASCII2(text, offset, len);\n            }\n        }\n    }\n\n    \n    private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException {\n        \n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n\n        int outputPtr = _outputTail;\n\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { \n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     \n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                }\n                continue;\n            }\n            if (ch <= 0x7FF) { \n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeStringSegment2(final String text, int offset, final int end) throws IOException {\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n\n        int outputPtr = _outputTail;\n\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { \n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     \n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                }\n                continue;\n            }\n            if (ch <= 0x7FF) { \n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    \n\n    \n    private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException {\n        \n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n    \n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        final int maxUnescaped = _maximumNonEscapedChar;\n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { \n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     \n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { \n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            if (ch <= 0x7FF) { \n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeStringSegmentASCII2(final String text, int offset, final int end) throws IOException {\n        \n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n    \n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        final int maxUnescaped = _maximumNonEscapedChar;\n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { \n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     \n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { \n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            if (ch <= 0x7FF) { \n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    \n\n    \n    private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException {\n        \n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar;\n        final CharacterEscapes customEscapes = _characterEscapes; \n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { \n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) {\n                     SerializableString esc = customEscapes.getEscapeSequence(ch);\n                     if (esc == null) {\n                         _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\"\n                                 +Integer.toHexString(ch)+\", although was supposed to have one\");\n                     }\n                     outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                 } else {\n                     \n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { \n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            SerializableString esc = customEscapes.getEscapeSequence(ch);\n            if (esc != null) {\n                outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                continue;\n            }\n            if (ch <= 0x7FF) { \n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeCustomStringSegment2(final String text, int offset, final int end) throws IOException {\n        \n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar;\n        final CharacterEscapes customEscapes = _characterEscapes; \n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { \n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) {\n                     SerializableString esc = customEscapes.getEscapeSequence(ch);\n                     if (esc == null) {\n                         _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\"\n                                 +Integer.toHexString(ch)+\", although was supposed to have one\");\n                     }\n                     outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                 } else {\n                     \n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { \n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            SerializableString esc = customEscapes.getEscapeSequence(ch);\n            if (esc != null) {\n                outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                continue;\n            }\n            if (ch <= 0x7FF) { \n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException {\n        byte[] raw = esc.asUnquotedUTF8(); \n        int len = raw.length;\n        if (len > 6) { \n            return _handleLongCustomEscape(outputBuffer, outputPtr, _outputEnd, raw, remainingChars);\n        }\n        \n        System.arraycopy(raw, 0, outputBuffer, outputPtr, len);\n        return (outputPtr + len);\n    }\n    \n    private final int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException {\n        int len = raw.length;\n        if ((outputPtr + len) > outputEnd) {\n            _outputTail = outputPtr;\n            _flushBuffer();\n            outputPtr = _outputTail;\n            if (len > outputBuffer.length) { \n                _outputStream.write(raw, 0, len);\n                return outputPtr;\n            }\n            System.arraycopy(raw, 0, outputBuffer, outputPtr, len);\n            outputPtr += len;\n        }\n        \n        if ((outputPtr +  6 * remainingChars) > outputEnd) {\n            _flushBuffer();\n            return _outputTail;\n        }\n        return outputPtr;\n    }\n\n    \n    \n    \n    private final void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            _writeUTF8Segment(utf8, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n    \n    private final void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException {\n        \n        final int[] escCodes = _outputEscapes;\n\n        for (int ptr = offset, end = offset + len; ptr < end; ) {\n            \n            int ch = utf8[ptr++];\n            if ((ch >= 0) && escCodes[ch] != 0) {\n                _writeUTF8Segment2(utf8, offset, len);\n                return;\n            }\n        }\n        \n        \n        if ((_outputTail + len) > _outputEnd) { \n            _flushBuffer(); \n        }\n        System.arraycopy(utf8, offset, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    private final void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException {\n        int outputPtr = _outputTail;\n\n        \n        if ((outputPtr + (len * 6)) > _outputEnd) {\n            _flushBuffer();\n            outputPtr = _outputTail;\n        }\n        \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        len += offset; \n        \n        while (offset < len) {\n            byte b = utf8[offset++];\n            int ch = b;\n            if (ch < 0 || escCodes[ch] == 0) {\n                outputBuffer[outputPtr++] = b;\n                continue;\n            }\n            int escape = escCodes[ch];\n            if (escape > 0) { \n                outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                outputBuffer[outputPtr++] = (byte) escape;\n            } else {\n                \n                outputPtr = _writeGenericEscape(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    \n    \n    protected final void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException {\n        \n        int safeInputEnd = inputEnd - 3;\n        \n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        \n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            \n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                \n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        \n        int inputLeft = inputEnd - inputPtr; \n        if (inputLeft > 0) { \n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }\n\n    \n    protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        \n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { \n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { \n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        \n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { \n                if (_outputTail > safeOutputEnd) { \n                    _flushBuffer();\n                }\n                int b24 = ((int) readBuffer[inputPtr++]) << 16;\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }\n\n    \n    protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;\n        int bytesDone = 0;\n        \n        \n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        \n        while (true) {\n            if (inputPtr > lastFullOffset) { \n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length);\n                inputPtr = 0;\n                if (inputEnd < 3) { \n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            \n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesDone += 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        \n        if (inputPtr < inputEnd) { \n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 16;\n            int amount = 1;\n            if (inputPtr < inputEnd) {\n                b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                amount = 2;\n            }\n            bytesDone += amount;\n            _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n        }\n        return bytesDone;\n    }\n    \n    private final int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException {\n        \n        int i = 0;\n        while (inputPtr < inputEnd) {\n            readBuffer[i++]  = readBuffer[inputPtr++];\n        }\n        inputPtr = 0;\n        inputEnd = i;\n        maxRead = Math.min(maxRead, readBuffer.length);\n        \n        do {\n            int length = maxRead - inputEnd;\n            if (length == 0) {\n                break;\n            }\n            int count = in.read(readBuffer, inputEnd, length);            \n            if (count < 0) {\n                return inputEnd;\n            }\n            inputEnd += count;\n        } while (inputEnd < 3);\n        return inputEnd;\n    }\n    \n    \n    \n    \n    private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n        \n        if (ch >= SURR1_FIRST) {\n            if (ch <= SURR2_LAST) { \n                \n                if (inputOffset >= inputEnd || cbuf == null) { \n                    _reportError(String.format(\n\"Split surrogate on writeRaw() input (last character): first character 0x%4x\", ch));\n                }\n                _outputSurrogates(ch, cbuf[inputOffset]);\n                return inputOffset+1;\n            }\n        }\n        final byte[] bbuf = _outputBuffer;\n        bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n        return inputOffset;\n    }\n\n    protected final void _outputSurrogates(int surr1, int surr2) throws IOException {\n        int c = _decodeSurrogate(surr1, surr2);\n        if ((_outputTail + 4) > _outputEnd) {\n            _flushBuffer();\n        }\n        final byte[] bbuf = _outputBuffer;\n        bbuf[_outputTail++] = (byte) (0xf0 | (c >> 18));\n        bbuf[_outputTail++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (c & 0x3f));\n    }\n    \n    \n    private final int _outputMultiByteChar(int ch, int outputPtr) throws IOException {\n        byte[] bbuf = _outputBuffer;\n        if (ch >= SURR1_FIRST && ch <= SURR2_LAST) { \n            \n            \n            \n\n                bbuf[outputPtr++] = BYTE_BACKSLASH;\n                bbuf[outputPtr++] = BYTE_u;\n                \n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[ch & 0xF];\n\n        } else {\n            bbuf[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n            bbuf[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n            bbuf[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n        }\n        return outputPtr;\n    }\n\n    private final void _writeNull() throws IOException {\n        if ((_outputTail + 4) >= _outputEnd) {\n            _flushBuffer();\n        }\n        System.arraycopy(NULL_BYTES, 0, _outputBuffer, _outputTail, 4);\n        _outputTail += 4;\n    }\n        \n    \n    private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException {\n        final byte[] bbuf = _outputBuffer;\n        bbuf[outputPtr++] = BYTE_BACKSLASH;\n        bbuf[outputPtr++] = BYTE_u;\n        if (charToEscape > 0xFF) {\n            int hi = (charToEscape >> 8) & 0xFF;\n            bbuf[outputPtr++] = HEX_CHARS[hi >> 4];\n            bbuf[outputPtr++] = HEX_CHARS[hi & 0xF];\n            charToEscape &= 0xFF;\n        } else {\n            bbuf[outputPtr++] = BYTE_0;\n            bbuf[outputPtr++] = BYTE_0;\n        }\n        \n        bbuf[outputPtr++] = HEX_CHARS[charToEscape >> 4];\n        bbuf[outputPtr++] = HEX_CHARS[charToEscape & 0xF];\n        return outputPtr;\n    }\n\n    protected final void _flushBuffer() throws IOException {\n        int len = _outputTail;\n        if (len > 0) {\n            _outputTail = 0;\n            _outputStream.write(_outputBuffer, 0, len);\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable)",
        "public Object getOutputTarget()",
        "public int getOutputBuffered()",
        "public void writeFieldName(String name) throws IOException",
        "public void writeFieldName(SerializableString name) throws IOException",
        "private final void _writeUnq(SerializableString name) throws IOException",
        "public final void writeStartArray() throws IOException",
        "public final void writeEndArray() throws IOException",
        "public final void writeStartObject() throws IOException",
        "public final void writeEndObject() throws IOException",
        "protected final void _writePPFieldName(String name) throws IOException",
        "protected final void _writePPFieldName(SerializableString name) throws IOException",
        "public void writeString(String text) throws IOException",
        "public void writeString(char[] text, int offset, int len) throws IOException",
        "public final void writeString(SerializableString text) throws IOException",
        "public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException",
        "public void writeUTF8String(byte[] text, int offset, int len) throws IOException",
        "public void writeRaw(String text) throws IOException",
        "public void writeRaw(String text, int offset, int len) throws IOException",
        "public void writeRaw(SerializableString text) throws IOException",
        "public void writeRawValue(SerializableString text) throws IOException",
        "public final void writeRaw(char[] cbuf, int offset, int len) throws IOException",
        "public void writeRaw(char ch) throws IOException",
        "private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException",
        "private void _writeRawSegment(char[] cbuf, int offset, int end) throws IOException",
        "public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException",
        "public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException",
        "public void writeNumber(short s) throws IOException",
        "private final void _writeQuotedShort(short s) throws IOException",
        "public void writeNumber(int i) throws IOException",
        "private final void _writeQuotedInt(int i) throws IOException",
        "public void writeNumber(long l) throws IOException",
        "private final void _writeQuotedLong(long l) throws IOException",
        "public void writeNumber(BigInteger value) throws IOException",
        "public void writeNumber(double d) throws IOException",
        "public void writeNumber(float f) throws IOException",
        "public void writeNumber(BigDecimal value) throws IOException",
        "public void writeNumber(String encodedValue) throws IOException",
        "private final void _writeQuotedRaw(String value) throws IOException",
        "public void writeBoolean(boolean state) throws IOException",
        "public void writeNull() throws IOException",
        "protected final void _verifyValueWrite(String typeMsg) throws IOException",
        "protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException",
        "public void flush() throws IOException",
        "public void close() throws IOException",
        "protected void _releaseBuffers()",
        "private final void _writeBytes(byte[] bytes) throws IOException",
        "private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException",
        "private final void _writeStringSegments(String text, boolean addQuotes) throws IOException",
        "private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException",
        "private final void _writeStringSegments(String text, int offset, int totalLen) throws IOException",
        "private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException",
        "private final void _writeStringSegment(String text, int offset, int len) throws IOException",
        "private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException",
        "private final void _writeStringSegment2(final String text, int offset, final int end) throws IOException",
        "private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException",
        "private final void _writeStringSegmentASCII2(final String text, int offset, final int end) throws IOException",
        "private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException",
        "private final void _writeCustomStringSegment2(final String text, int offset, final int end) throws IOException",
        "private final int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException",
        "private final int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException",
        "private final void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException",
        "private final void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException",
        "private final void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException",
        "protected final void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException",
        "protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException",
        "protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException",
        "private final int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException",
        "private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException",
        "protected final void _outputSurrogates(int surr1, int surr2) throws IOException",
        "private final int _outputMultiByteChar(int ch, int outputPtr) throws IOException",
        "private final void _writeNull() throws IOException",
        "private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException",
        "protected final void _flushBuffer() throws IOException"
      ],
      "fixed_signatures": [
        "public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable)",
        "public Object getOutputTarget()",
        "public int getOutputBuffered()",
        "public void writeFieldName(String name) throws IOException",
        "public void writeFieldName(SerializableString name) throws IOException",
        "private final void _writeUnq(SerializableString name) throws IOException",
        "public final void writeStartArray() throws IOException",
        "public final void writeEndArray() throws IOException",
        "public final void writeStartObject() throws IOException",
        "public final void writeEndObject() throws IOException",
        "protected final void _writePPFieldName(String name) throws IOException",
        "protected final void _writePPFieldName(SerializableString name) throws IOException",
        "public void writeString(String text) throws IOException",
        "public void writeString(char[] text, int offset, int len) throws IOException",
        "public final void writeString(SerializableString text) throws IOException",
        "public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException",
        "public void writeUTF8String(byte[] text, int offset, int len) throws IOException",
        "public void writeRaw(String text) throws IOException",
        "public void writeRaw(String text, int offset, int len) throws IOException",
        "public void writeRaw(SerializableString text) throws IOException",
        "public void writeRawValue(SerializableString text) throws IOException",
        "public final void writeRaw(char[] cbuf, int offset, int len) throws IOException",
        "public void writeRaw(char ch) throws IOException",
        "private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException",
        "private void _writeRawSegment(char[] cbuf, int offset, int end) throws IOException",
        "public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException",
        "public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException",
        "public void writeNumber(short s) throws IOException",
        "private final void _writeQuotedShort(short s) throws IOException",
        "public void writeNumber(int i) throws IOException",
        "private final void _writeQuotedInt(int i) throws IOException",
        "public void writeNumber(long l) throws IOException",
        "private final void _writeQuotedLong(long l) throws IOException",
        "public void writeNumber(BigInteger value) throws IOException",
        "public void writeNumber(double d) throws IOException",
        "public void writeNumber(float f) throws IOException",
        "public void writeNumber(BigDecimal value) throws IOException",
        "public void writeNumber(String encodedValue) throws IOException",
        "private final void _writeQuotedRaw(String value) throws IOException",
        "public void writeBoolean(boolean state) throws IOException",
        "public void writeNull() throws IOException",
        "protected final void _verifyValueWrite(String typeMsg) throws IOException",
        "protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException",
        "public void flush() throws IOException",
        "public void close() throws IOException",
        "protected void _releaseBuffers()",
        "private final void _writeBytes(byte[] bytes) throws IOException",
        "private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException",
        "private final void _writeStringSegments(String text, boolean addQuotes) throws IOException",
        "private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException",
        "private final void _writeStringSegments(String text, int offset, int totalLen) throws IOException",
        "private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException",
        "private final void _writeStringSegment(String text, int offset, int len) throws IOException",
        "private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException",
        "private final void _writeStringSegment2(final String text, int offset, final int end) throws IOException",
        "private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException",
        "private final void _writeStringSegmentASCII2(final String text, int offset, final int end) throws IOException",
        "private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException",
        "private final void _writeCustomStringSegment2(final String text, int offset, final int end) throws IOException",
        "private final int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException",
        "private final int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException",
        "private final void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException",
        "private final void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException",
        "private final void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException",
        "protected final void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException",
        "protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException",
        "protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException",
        "private final int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException",
        "private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException",
        "protected final void _outputSurrogates(int surr1, int surr2) throws IOException",
        "private final int _outputMultiByteChar(int ch, int outputPtr) throws IOException",
        "private final void _writeNull() throws IOException",
        "private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException",
        "protected final void _flushBuffer() throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  public void writeNumber(BigDecimal value) throws IOException {\n  \n  _verifyValueWrite(WRITE_NUMBER);\n  if (value == null) {\n  _writeNull();\n  } else  if (_cfgNumbersAsStrings) {\n  String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString();\n  _writeQuotedRaw(raw);\n  } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {\n  writeRaw(value.toPlainString());\n  } else {\n  writeRaw(_asString(value));\n  }\n  }",
          "fixed_method": "  public void writeNumber(BigDecimal value) throws IOException {\n  \n  _verifyValueWrite(WRITE_NUMBER);\n  if (value == null) {\n  _writeNull();\n  } else  if (_cfgNumbersAsStrings) {\n  _writeQuotedRaw(_asString(value));\n  } else {\n  writeRaw(_asString(value));\n  }\n  }",
          "diff": [
            "@@ -907,10 +907,7 @@",
            "         if (value == null) {\n",
            "             _writeNull();\n",
            "         } else  if (_cfgNumbersAsStrings) {\n",
            "-            String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString();\n",
            "-            _writeQuotedRaw(raw);\n",
            "-        } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {\n",
            "-            writeRaw(value.toPlainString());\n",
            "+            _writeQuotedRaw(_asString(value));\n",
            "         } else {\n",
            "             writeRaw(_asString(value));\n",
            "         }\n"
          ],
          "changed_lines": 5
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java",
      "buggy_full_code": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.*;\n\n\npublic final class WriterBasedJsonGenerator extends JsonGeneratorImpl { final protected static int SHORT_WRITE = 32; final protected static char[] HEX_CHARS = CharTypes.copyHexChars(); final protected Writer _writer; protected char[] _outputBuffer; protected int _outputHead; protected int _outputTail; protected int _outputEnd; protected char[] _entityBuffer; protected SerializableString _currentEscape; public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w) {\n        super(ctxt, features, codec);\n        _writer = w;\n        _outputBuffer = ctxt.allocConcatBuffer();\n        _outputEnd = _outputBuffer.length;\n    }\n    \n    \n    \n    @Override\n    public Object getOutputTarget() {\n        return _writer;\n    }\n\n    @Override\n    public int getOutputBuffered() {\n        \n        int len = _outputTail - _outputHead;\n        return Math.max(0, len);\n    }\n\n    \n\n    @Override\n    public void writeFieldName(String name) throws IOException {\n        int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA));\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException {\n        \n        int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA));\n    }\n\n    protected void _writeFieldName(String name, boolean commaBefore) throws IOException {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name, commaBefore);\n            return;\n        }\n        \n        if ((_outputTail + 1) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (commaBefore) {\n            _outputBuffer[_outputTail++] = ',';\n        }\n        \n        if (_cfgUnqNames) {\n            _writeString(name);\n            return;\n        }\n        \n        _outputBuffer[_outputTail++] = '\"';\n        \n        _writeString(name);\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n    }\n    \n    protected void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name, commaBefore);\n            return;\n        }\n        \n        if ((_outputTail + 1) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (commaBefore) {\n            _outputBuffer[_outputTail++] = ',';\n        }\n        \n        final char[] quoted = name.asQuotedChars();\n        if (_cfgUnqNames) {\n            writeRaw(quoted, 0, quoted.length);\n            return;\n        }\n        \n        _outputBuffer[_outputTail++] = '\"';\n        \n        final int qlen = quoted.length;\n        if ((_outputTail + qlen + 1) >= _outputEnd) {\n            writeRaw(quoted, 0, qlen);\n            \n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '\"';\n        } else {\n            System.arraycopy(quoted, 0, _outputBuffer, _outputTail, qlen);\n            _outputTail += qlen;\n            _outputBuffer[_outputTail++] = '\"';\n        }\n    }\n    \n    \n\n    @Override\n    public void writeStartArray() throws IOException, JsonGenerationException {\n        _verifyValueWrite(\"start an array\");\n        _writeContext = _writeContext.createChildArrayContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartArray(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '[';\n        }\n    }\n\n    @Override\n    public void writeEndArray() throws IOException, JsonGenerationException {\n        if (!_writeContext.inArray()) {\n            _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = ']';\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    @Override\n    public void writeStartObject() throws IOException, JsonGenerationException {\n        _verifyValueWrite(\"start an object\");\n        _writeContext = _writeContext.createChildObjectContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartObject(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '{';\n        }\n    }\n\n    @Override\n    public void writeEndObject() throws IOException, JsonGenerationException {\n        if (!_writeContext.inObject()) {\n            _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '}';\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    \n    protected void _writePPFieldName(String name, boolean commaBefore) throws IOException {\n        if (commaBefore) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n\n        if (_cfgUnqNames) {\n            _writeString(name);\n        } else { \n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '\"';\n            _writeString(name);\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '\"';\n        }\n    }\n\n    protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException {\n        if (commaBefore) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n    \n        final char[] quoted = name.asQuotedChars();\n        if (_cfgUnqNames) {\n            writeRaw(quoted, 0, quoted.length);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '\"';\n            writeRaw(quoted, 0, quoted.length);\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '\"';\n        }\n    }\n\n    \n\n    @Override\n    public void writeString(String text) throws IOException {\n        _verifyValueWrite(WRITE_STRING);\n        if (text == null) {\n            _writeNull();\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        _writeString(text);\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        _writeString(text, offset, len);\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n    }\n\n    @Override\n    public void writeString(SerializableString sstr) throws IOException {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        \n        char[] text = sstr.asQuotedChars();\n        final int len = text.length;\n        \n        if (len < SHORT_WRITE) {\n            int room = _outputEnd - _outputTail;\n            if (len > room) {\n                _flushBuffer();\n            }\n            System.arraycopy(text, 0, _outputBuffer, _outputTail, len);\n            _outputTail += len;\n        } else {\n            \n            _flushBuffer();\n            _writer.write(text, 0, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n    }\n\n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException {\n        \n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int length) throws IOException {\n        \n        _reportUnsupportedOperation();\n    }\n    \n    \n\n    @Override\n    public void writeRaw(String text) throws IOException {\n        \n        int len = text.length();\n        int room = _outputEnd - _outputTail;\n\n        if (room == 0) {\n            _flushBuffer();\n            room = _outputEnd - _outputTail;\n        }\n        \n        if (room >= len) {\n            text.getChars(0, len, _outputBuffer, _outputTail);\n            _outputTail += len;\n        } else {\n            writeRawLong(text);\n        }\n    }\n\n    @Override\n    public void writeRaw(String text, int start, int len) throws IOException {\n        \n        int room = _outputEnd - _outputTail;\n\n        if (room < len) {\n            _flushBuffer();\n            room = _outputEnd - _outputTail;\n        }\n        \n        if (room >= len) {\n            text.getChars(start, start+len, _outputBuffer, _outputTail);\n            _outputTail += len;\n        } else {            \t\n            writeRawLong(text.substring(start, start+len));\n        }\n    }\n\n    \n    @Override\n    public void writeRaw(SerializableString text) throws IOException {\n        writeRaw(text.getValue());\n    }\n\n    @Override\n    public void writeRaw(char[] text, int offset, int len) throws IOException {\n        \n        if (len < SHORT_WRITE) {\n            int room = _outputEnd - _outputTail;\n            if (len > room) {\n                _flushBuffer();\n            }\n            System.arraycopy(text, offset, _outputBuffer, _outputTail, len);\n            _outputTail += len;\n            return;\n        }\n        \n        _flushBuffer();\n        _writer.write(text, offset, len);\n    }\n\n    @Override\n    public void writeRaw(char c) throws IOException {\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = c;\n    }\n\n    private void writeRawLong(String text) throws IOException {\n        int room = _outputEnd - _outputTail;\n        \n        text.getChars(0, room, _outputBuffer, _outputTail);\n        _outputTail += room;\n        _flushBuffer();\n        int offset = room;\n        int len = text.length() - room;\n\n        while (len > _outputEnd) {\n            int amount = _outputEnd;\n            text.getChars(offset, offset+amount, _outputBuffer, 0);\n            _outputHead = 0;\n            _outputTail = amount;\n            _flushBuffer();\n            offset += amount;\n            len -= amount;\n        }\n        \n        text.getChars(offset, offset+len, _outputBuffer, 0);\n        _outputHead = 0;\n        _outputTail = len;\n    }\n\n    \n\n    @Override\n    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException {\n        _verifyValueWrite(WRITE_BINARY);\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        _writeBinary(b64variant, data, offset, offset+len);\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n    }\n\n    @Override\n    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException {\n        _verifyValueWrite(WRITE_BINARY);\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        byte[] encodingBuffer = _ioContext.allocBase64Buffer();\n        int bytes;\n        try {\n            if (dataLength < 0) { \n                bytes = _writeBinary(b64variant, data, encodingBuffer);\n            } else {\n                int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength);\n                if (missing > 0) {\n                    _reportError(\"Too few bytes available: missing \"+missing+\" bytes (out of \"+dataLength+\")\");\n                }\n                bytes = dataLength;\n            }\n        } finally {\n            _ioContext.releaseBase64Buffer(encodingBuffer);\n        }\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        return bytes;\n    }\n    \n    \n\n    @Override\n    public void writeNumber(short s) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedShort(s);\n            return;\n        }\n        \n        if ((_outputTail + 6) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n    }\n\n    private void _writeQuotedShort(short s) throws IOException {\n        if ((_outputTail + 8) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = '\"';\n    }    \n\n    @Override\n    public void writeNumber(int i) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedInt(i);\n            return;\n        }\n        \n        if ((_outputTail + 11) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n    }\n\n    private void _writeQuotedInt(int i) throws IOException {\n        if ((_outputTail + 13) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = '\"';\n    }    \n\n    @Override\n    public void writeNumber(long l) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedLong(l);\n            return;\n        }\n        if ((_outputTail + 21) >= _outputEnd) {\n            \n            _flushBuffer();\n        }\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n    }\n\n    private void _writeQuotedLong(long l) throws IOException {\n        if ((_outputTail + 23) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = '\"';\n    }\n\n    \n\n    @Override\n    public void writeNumber(BigInteger value) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(value.toString());\n        } else {\n            writeRaw(value.toString());\n        }\n    }\n\n    \n    @Override\n    public void writeNumber(double d) throws IOException {\n        if (_cfgNumbersAsStrings ||\n            \n                (isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS) && ((Double.isNaN(d) || Double.isInfinite(d))))) {\n            writeString(String.valueOf(d));\n            return;\n        }\n        \n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException {\n        if (_cfgNumbersAsStrings ||\n            \n                (isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS) && ((Float.isNaN(f) || Float.isInfinite(f))))) {\n            writeString(String.valueOf(f));\n            return;\n        }\n        \n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal value) throws IOException {\n        \n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else  if (_cfgNumbersAsStrings) {\n            String raw = isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN) ? value.toPlainString() : value.toString();\n            _writeQuotedRaw(raw);\n        } else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n            writeRaw(value.toPlainString());\n        } else {\n            writeRaw(_asString(value));\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(encodedValue);\n        } else {\n            writeRaw(encodedValue);\n        }\n    }\n\n    private void _writeQuotedRaw(String value) throws IOException {\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        writeRaw(value);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n    }\n    \n    @Override\n    public void writeBoolean(boolean state) throws IOException {\n        _verifyValueWrite(WRITE_BOOLEAN);\n        if ((_outputTail + 5) >= _outputEnd) {\n            _flushBuffer();\n        }\n        int ptr = _outputTail;\n        char[] buf = _outputBuffer;\n        if (state) {\n            buf[ptr] = 't';\n            buf[++ptr] = 'r';\n            buf[++ptr] = 'u';\n            buf[++ptr] = 'e';\n        } else {\n            buf[ptr] = 'f';\n            buf[++ptr] = 'a';\n            buf[++ptr] = 'l';\n            buf[++ptr] = 's';\n            buf[++ptr] = 'e';\n        }\n        _outputTail = ptr+1;\n    }\n\n    @Override\n    public void writeNull() throws IOException {\n        _verifyValueWrite(WRITE_NULL);\n        _writeNull();\n    }\n\n    \n\n    @Override\n    protected void _verifyValueWrite(String typeMsg) throws IOException {\n        if (_cfgPrettyPrinter != null) {\n            \n            _verifyPrettyValueWrite(typeMsg);\n            return;\n        }\n        char c;\n        final int status = _writeContext.writeValue();\n        if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n            _reportError(\"Can not \"+typeMsg+\", expecting field name\");\n        }\n        switch (status) {\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\n            c = ',';\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\n            c = ':';\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_SPACE: \n            if (_rootValueSeparator != null) {\n                writeRaw(_rootValueSeparator.getValue());\n            }\n            return;\n        case JsonWriteContext.STATUS_OK_AS_IS:\n        default:\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail] = c;\n        ++_outputTail;\n    }\n\n    protected void _verifyPrettyValueWrite(String typeMsg) throws IOException {\n        final int status = _writeContext.writeValue();\n        if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n            _reportError(\"Can not \"+typeMsg+\", expecting field name\");\n        }\n\n        \n        switch (status) {\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA: \n            _cfgPrettyPrinter.writeArrayValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\n            _cfgPrettyPrinter.writeObjectFieldValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_SPACE:\n            _cfgPrettyPrinter.writeRootValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AS_IS:\n            \n            if (_writeContext.inArray()) {\n                _cfgPrettyPrinter.beforeArrayValues(this);\n            } else if (_writeContext.inObject()) {\n                _cfgPrettyPrinter.beforeObjectEntries(this);\n            }\n            break;\n        default:\n            _throwInternal();\n            break;\n        }\n    }\n\n    \n\n    @Override\n    public void flush() throws IOException {\n        _flushBuffer();\n        if (_writer != null) {\n            if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                _writer.flush();\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        super.close();\n\n        \n        \n        if (_outputBuffer != null\n            && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {\n            while (true) {\n                JsonStreamContext ctxt = getOutputContext();\n                if (ctxt.inArray()) {\n                    writeEndArray();\n                } else if (ctxt.inObject()) {\n                    writeEndObject();\n                } else {\n                    break;\n                }\n            }\n        }\n        _flushBuffer();\n        _outputHead = 0;\n        _outputTail = 0;\n\n        \n        if (_writer != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {\n                _writer.close();\n            } else  if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                \n                _writer.flush();\n            }\n        }\n        \n        _releaseBuffers();\n    }\n\n    @Override\n    protected void _releaseBuffers() {\n        char[] buf = _outputBuffer;\n        if (buf != null) {\n            _outputBuffer = null;\n            _ioContext.releaseConcatBuffer(buf);\n        }\n    }\n\n    \n\n    private void _writeString(String text) throws IOException {\n        \n        final int len = text.length();\n        if (len > _outputEnd) { \n            _writeLongString(text);\n            return;\n        }\n\n        \n        \n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n        }\n        text.getChars(0, len, _outputBuffer, _outputTail);\n\n        if (_characterEscapes != null) {\n            _writeStringCustom(len);\n        } else if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(len, _maximumNonEscapedChar);\n        } else {\n            _writeString2(len);\n        }\n    }\n\n    private void _writeString2(final int len) throws IOException {\n        \n        final int end = _outputTail + len;\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\n\n        output_loop:\n        while (_outputTail < end) {\n            \n            escape_loop:\n            while (true) {\n                char c = _outputBuffer[_outputTail];\n                if (c < escLen && escCodes[c] != 0) {\n                    break escape_loop;\n                }\n                if (++_outputTail >= end) {\n                    break output_loop;\n                }\n            }\n\n            \n            \n            int flushLen = (_outputTail - _outputHead);\n            if (flushLen > 0) {\n                _writer.write(_outputBuffer, _outputHead, flushLen);\n            }\n            \n            char c = _outputBuffer[_outputTail++];\n            _prependOrWriteCharacterEscape(c, escCodes[c]);\n        }\n    }\n\n    \n    private void _writeLongString(String text) throws IOException {\n        \n        _flushBuffer();\n\n        \n        final int textLen = text.length();\n        int offset = 0;\n        do {\n            int max = _outputEnd;\n            int segmentLen = ((offset + max) > textLen)\n                ? (textLen - offset) : max;\n            text.getChars(offset, offset+segmentLen, _outputBuffer, 0);\n            if (_characterEscapes != null) {\n                _writeSegmentCustom(segmentLen);\n            } else if (_maximumNonEscapedChar != 0) {\n                _writeSegmentASCII(segmentLen, _maximumNonEscapedChar);\n            } else {\n                _writeSegment(segmentLen);\n            }\n            offset += segmentLen;\n        } while (offset < textLen);\n    }\n\n    \n    private void _writeSegment(int end) throws IOException {\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\n    \n        int ptr = 0;\n        int start = ptr;\n\n        output_loop:\n        while (ptr < end) {\n            \n            char c;\n            while (true) {\n                c = _outputBuffer[ptr];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++ptr >= end) {\n                    break;\n                }\n            }\n\n            \n            \n            int flushLen = (ptr - start);\n            if (flushLen > 0) {\n                _writer.write(_outputBuffer, start, flushLen);\n                if (ptr >= end) {\n                    break output_loop;\n                }\n            }\n            ++ptr;\n            \n            start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCodes[c]);\n        }\n    }\n    \n    \n    private void _writeString(char[] text, int offset, int len) throws IOException {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        \n        len += offset; \n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\n        while (offset < len) {\n            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            \n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                \n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { \n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            \n            if (offset >= len) { \n                break;\n            }\n            \n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }\n\n    \n\n    \n    private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException {\n        \n        int end = _outputTail + len;\n        final int[] escCodes = _outputEscapes;\n        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n        int escCode = 0;\n        \n        output_loop:\n        while (_outputTail < end) {\n            char c;\n            \n            escape_loop:\n            while (true) {\n                c = _outputBuffer[_outputTail];\n                if (c < escLimit) {\n                    escCode = escCodes[c];\n                    if (escCode != 0) {\n                        break escape_loop;\n                    }\n                } else if (c > maxNonEscaped) {\n                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n                    break escape_loop;\n                }\n                if (++_outputTail >= end) {\n                    break output_loop;\n                }\n            }\n            int flushLen = (_outputTail - _outputHead);\n            if (flushLen > 0) {\n                _writer.write(_outputBuffer, _outputHead, flushLen);\n            }\n            ++_outputTail;\n            _prependOrWriteCharacterEscape(c, escCode);\n        }\n    }\n\n    private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException {\n        final int[] escCodes = _outputEscapes;\n        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n    \n        int ptr = 0;\n        int escCode = 0;\n        int start = ptr;\n    \n        output_loop:\n        while (ptr < end) {\n            \n            char c;\n            while (true) {\n                c = _outputBuffer[ptr];\n                if (c < escLimit) {\n                    escCode = escCodes[c];\n                    if (escCode != 0) {\n                        break;\n                    }\n                } else if (c > maxNonEscaped) {\n                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n                    break;\n                }\n                if (++ptr >= end) {\n                    break;\n                }\n            }\n            int flushLen = (ptr - start);\n            if (flushLen > 0) {\n                _writer.write(_outputBuffer, start, flushLen);\n                if (ptr >= end) {\n                    break output_loop;\n                }\n            }\n            ++ptr;\n            start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCode);\n        }\n    }\n\n    private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException {\n        len += offset; \n        final int[] escCodes = _outputEscapes;\n        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n\n        int escCode = 0;\n        \n        while (offset < len) {\n            int start = offset;\n            char c;\n            \n            while (true) {\n                c = text[offset];\n                if (c < escLimit) {\n                    escCode = escCodes[c];\n                    if (escCode != 0) {\n                        break;\n                    }\n                } else if (c > maxNonEscaped) {\n                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            \n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                \n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { \n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            \n            if (offset >= len) { \n                break;\n            }\n            \n            ++offset;\n            _appendCharacterEscape(c, escCode);\n        }\n    }\n\n    \n\n    \n    private void _writeStringCustom(final int len) throws IOException, JsonGenerationException {\n        \n        int end = _outputTail + len;\n        final int[] escCodes = _outputEscapes;\n        final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar;\n        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n        int escCode = 0;\n        final CharacterEscapes customEscapes = _characterEscapes;\n\n        output_loop:\n        while (_outputTail < end) {\n            char c;\n            \n            escape_loop:\n            while (true) {\n                c = _outputBuffer[_outputTail];\n                if (c < escLimit) {\n                    escCode = escCodes[c];\n                    if (escCode != 0) {\n                        break escape_loop;\n                    }\n                } else if (c > maxNonEscaped) {\n                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n                    break escape_loop;\n                } else {\n                    if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) {\n                        escCode = CharacterEscapes.ESCAPE_CUSTOM;\n                        break escape_loop;\n                    }\n                }\n                if (++_outputTail >= end) {\n                    break output_loop;\n                }\n            }\n            int flushLen = (_outputTail - _outputHead);\n            if (flushLen > 0) {\n                _writer.write(_outputBuffer, _outputHead, flushLen);\n            }\n            ++_outputTail;\n            _prependOrWriteCharacterEscape(c, escCode);\n        }\n    }\n\n    private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException {\n        final int[] escCodes = _outputEscapes;\n        final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar;\n        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n        final CharacterEscapes customEscapes = _characterEscapes;\n    \n        int ptr = 0;\n        int escCode = 0;\n        int start = ptr;\n    \n        output_loop:\n        while (ptr < end) {\n            \n            char c;\n            while (true) {\n                c = _outputBuffer[ptr];\n                if (c < escLimit) {\n                    escCode = escCodes[c];\n                    if (escCode != 0) {\n                        break;\n                    }\n                } else if (c > maxNonEscaped) {\n                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n                    break;\n                } else {\n                    if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) {\n                        escCode = CharacterEscapes.ESCAPE_CUSTOM;\n                        break;\n                    }\n                }\n                if (++ptr >= end) {\n                    break;\n                }\n            }\n            int flushLen = (ptr - start);\n            if (flushLen > 0) {\n                _writer.write(_outputBuffer, start, flushLen);\n                if (ptr >= end) {\n                    break output_loop;\n                }\n            }\n            ++ptr;\n            start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCode);\n        }\n    }\n\n    private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n        len += offset; \n        final int[] escCodes = _outputEscapes;\n        final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar;\n        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n        final CharacterEscapes customEscapes = _characterEscapes;\n\n        int escCode = 0;\n        \n        while (offset < len) {\n            int start = offset;\n            char c;\n            \n            while (true) {\n                c = text[offset];\n                if (c < escLimit) {\n                    escCode = escCodes[c];\n                    if (escCode != 0) {\n                        break;\n                    }\n                } else if (c > maxNonEscaped) {\n                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n                    break;\n                } else {\n                    if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) {\n                        escCode = CharacterEscapes.ESCAPE_CUSTOM;\n                        break;\n                    }\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n    \n            \n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                \n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { \n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            \n            if (offset >= len) { \n                break;\n            }\n            \n            ++offset;\n            _appendCharacterEscape(c, escCode);\n        }\n    }\n    \n    \n    \n    protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException {\n        \n        int safeInputEnd = inputEnd - 3;\n        \n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        \n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            \n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                \n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        \n        int inputLeft = inputEnd - inputPtr; \n        if (inputLeft > 0) { \n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }\n\n    \n    protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        \n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { \n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { \n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        \n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { \n                if (_outputTail > safeOutputEnd) { \n                    _flushBuffer();\n                }\n                int b24 = ((int) readBuffer[inputPtr++]) << 16;\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }\n    \n    \n    protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;\n        int bytesDone = 0;\n        \n        \n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        \n        while (true) {\n            if (inputPtr > lastFullOffset) { \n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length);\n                inputPtr = 0;\n                if (inputEnd < 3) { \n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            \n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesDone += 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        \n        if (inputPtr < inputEnd) { \n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 16;\n            int amount = 1;\n            if (inputPtr < inputEnd) {\n                b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                amount = 2;\n            }\n            bytesDone += amount;\n            _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n        }\n        return bytesDone;\n    }\n    \n    private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException {\n        \n        int i = 0;\n        while (inputPtr < inputEnd) {\n            readBuffer[i++]  = readBuffer[inputPtr++];\n        }\n        inputPtr = 0;\n        inputEnd = i;\n        maxRead = Math.min(maxRead, readBuffer.length);\n        \n        do {\n            int length = maxRead - inputEnd;\n            if (length == 0) {\n                break;\n            }\n            int count = in.read(readBuffer, inputEnd, length);            \n            if (count < 0) {\n                return inputEnd;\n            }\n            inputEnd += count;\n        } while (inputEnd < 3);\n        return inputEnd;\n    }\n    \n    \n    \n    private final void _writeNull() throws IOException {\n        if ((_outputTail + 4) >= _outputEnd) {\n            _flushBuffer();\n        }\n        int ptr = _outputTail;\n        char[] buf = _outputBuffer;\n        buf[ptr] = 'n';\n        buf[++ptr] = 'u';\n        buf[++ptr] = 'l';\n        buf[++ptr] = 'l';\n        _outputTail = ptr+1;\n    }\n        \n    \n\n    \n    private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException {\n        if (escCode >= 0) { \n            if (_outputTail >= 2) { \n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            \n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { \n            if (_outputTail >= 6) { \n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                \n                if (ch > 0xFF) { \n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\n                    buf[++ptr] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            \n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { \n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { \n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { \n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        \n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }\n\n    \n    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException {\n        if (escCode >= 0) { \n            if (ptr > 1 && ptr < end) { \n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { \n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { \n            if (ptr > 5 && ptr < end) { \n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                \n                if (ch > 0xFF) { \n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                \n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { \n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { \n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { \n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { \n            _writer.write(escape);\n        }\n        return ptr;\n    }\n\n    \n    private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException {\n        if (escCode >= 0) { \n            if ((_outputTail + 2) > _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '\\\\';\n            _outputBuffer[_outputTail++] = (char) escCode;\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { \n            if ((_outputTail + 5) >= _outputEnd) {\n                _flushBuffer();\n            }\n            int ptr = _outputTail;\n            char[] buf = _outputBuffer;\n            buf[ptr++] = '\\\\';\n            buf[ptr++] = 'u';\n            \n            if (ch > 0xFF) { \n                int hi = (ch >> 8) & 0xFF;\n                buf[ptr++] = HEX_CHARS[hi >> 4];\n                buf[ptr++] = HEX_CHARS[hi & 0xF];\n                ch &= 0xFF;\n            } else {\n                buf[ptr++] = '0';\n                buf[ptr++] = '0';\n            }\n            buf[ptr++] = HEX_CHARS[ch >> 4];\n            buf[ptr++] = HEX_CHARS[ch & 0xF];\n            _outputTail = ptr;\n            return;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n            if (len > _outputEnd) { \n                _writer.write(escape);\n                return;\n            }\n        }\n        escape.getChars(0, len, _outputBuffer, _outputTail);\n        _outputTail += len;\n    }\n    \n    private char[] _allocateEntityBuffer() {\n        char[] buf = new char[14];\n        \n        buf[0] = '\\\\';\n        \n        buf[2] = '\\\\';\n        buf[3] = 'u';\n        buf[4] = '0';\n        buf[5] = '0';\n        \n        buf[8] = '\\\\';\n        buf[9] = 'u';\n        _entityBuffer = buf;\n        return buf;\n    }\n    \n    protected void _flushBuffer() throws IOException {\n        int len = _outputTail - _outputHead;\n        if (len > 0) {\n            int offset = _outputHead;\n            _outputTail = _outputHead = 0;\n            _writer.write(_outputBuffer, offset, len);\n        }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.*;\n\n\npublic final class WriterBasedJsonGenerator extends JsonGeneratorImpl { final protected static int SHORT_WRITE = 32; final protected static char[] HEX_CHARS = CharTypes.copyHexChars(); final protected Writer _writer; protected char[] _outputBuffer; protected int _outputHead; protected int _outputTail; protected int _outputEnd; protected char[] _entityBuffer; protected SerializableString _currentEscape; public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w) {\n        super(ctxt, features, codec);\n        _writer = w;\n        _outputBuffer = ctxt.allocConcatBuffer();\n        _outputEnd = _outputBuffer.length;\n    }\n    \n    \n    \n    @Override\n    public Object getOutputTarget() {\n        return _writer;\n    }\n\n    @Override\n    public int getOutputBuffered() {\n        \n        int len = _outputTail - _outputHead;\n        return Math.max(0, len);\n    }\n\n    \n\n    @Override\n    public void writeFieldName(String name) throws IOException {\n        int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA));\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException {\n        \n        int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA));\n    }\n\n    protected void _writeFieldName(String name, boolean commaBefore) throws IOException {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name, commaBefore);\n            return;\n        }\n        \n        if ((_outputTail + 1) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (commaBefore) {\n            _outputBuffer[_outputTail++] = ',';\n        }\n        \n        if (_cfgUnqNames) {\n            _writeString(name);\n            return;\n        }\n        \n        _outputBuffer[_outputTail++] = '\"';\n        \n        _writeString(name);\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n    }\n    \n    protected void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name, commaBefore);\n            return;\n        }\n        \n        if ((_outputTail + 1) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (commaBefore) {\n            _outputBuffer[_outputTail++] = ',';\n        }\n        \n        final char[] quoted = name.asQuotedChars();\n        if (_cfgUnqNames) {\n            writeRaw(quoted, 0, quoted.length);\n            return;\n        }\n        \n        _outputBuffer[_outputTail++] = '\"';\n        \n        final int qlen = quoted.length;\n        if ((_outputTail + qlen + 1) >= _outputEnd) {\n            writeRaw(quoted, 0, qlen);\n            \n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '\"';\n        } else {\n            System.arraycopy(quoted, 0, _outputBuffer, _outputTail, qlen);\n            _outputTail += qlen;\n            _outputBuffer[_outputTail++] = '\"';\n        }\n    }\n    \n    \n\n    @Override\n    public void writeStartArray() throws IOException, JsonGenerationException {\n        _verifyValueWrite(\"start an array\");\n        _writeContext = _writeContext.createChildArrayContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartArray(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '[';\n        }\n    }\n\n    @Override\n    public void writeEndArray() throws IOException, JsonGenerationException {\n        if (!_writeContext.inArray()) {\n            _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = ']';\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    @Override\n    public void writeStartObject() throws IOException, JsonGenerationException {\n        _verifyValueWrite(\"start an object\");\n        _writeContext = _writeContext.createChildObjectContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartObject(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '{';\n        }\n    }\n\n    @Override\n    public void writeEndObject() throws IOException, JsonGenerationException {\n        if (!_writeContext.inObject()) {\n            _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '}';\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    \n    protected void _writePPFieldName(String name, boolean commaBefore) throws IOException {\n        if (commaBefore) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n\n        if (_cfgUnqNames) {\n            _writeString(name);\n        } else { \n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '\"';\n            _writeString(name);\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '\"';\n        }\n    }\n\n    protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException {\n        if (commaBefore) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n    \n        final char[] quoted = name.asQuotedChars();\n        if (_cfgUnqNames) {\n            writeRaw(quoted, 0, quoted.length);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '\"';\n            writeRaw(quoted, 0, quoted.length);\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '\"';\n        }\n    }\n\n    \n\n    @Override\n    public void writeString(String text) throws IOException {\n        _verifyValueWrite(WRITE_STRING);\n        if (text == null) {\n            _writeNull();\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        _writeString(text);\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        _writeString(text, offset, len);\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n    }\n\n    @Override\n    public void writeString(SerializableString sstr) throws IOException {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        \n        char[] text = sstr.asQuotedChars();\n        final int len = text.length;\n        \n        if (len < SHORT_WRITE) {\n            int room = _outputEnd - _outputTail;\n            if (len > room) {\n                _flushBuffer();\n            }\n            System.arraycopy(text, 0, _outputBuffer, _outputTail, len);\n            _outputTail += len;\n        } else {\n            \n            _flushBuffer();\n            _writer.write(text, 0, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n    }\n\n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException {\n        \n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int length) throws IOException {\n        \n        _reportUnsupportedOperation();\n    }\n    \n    \n\n    @Override\n    public void writeRaw(String text) throws IOException {\n        \n        int len = text.length();\n        int room = _outputEnd - _outputTail;\n\n        if (room == 0) {\n            _flushBuffer();\n            room = _outputEnd - _outputTail;\n        }\n        \n        if (room >= len) {\n            text.getChars(0, len, _outputBuffer, _outputTail);\n            _outputTail += len;\n        } else {\n            writeRawLong(text);\n        }\n    }\n\n    @Override\n    public void writeRaw(String text, int start, int len) throws IOException {\n        \n        int room = _outputEnd - _outputTail;\n\n        if (room < len) {\n            _flushBuffer();\n            room = _outputEnd - _outputTail;\n        }\n        \n        if (room >= len) {\n            text.getChars(start, start+len, _outputBuffer, _outputTail);\n            _outputTail += len;\n        } else {            \t\n            writeRawLong(text.substring(start, start+len));\n        }\n    }\n\n    \n    @Override\n    public void writeRaw(SerializableString text) throws IOException {\n        writeRaw(text.getValue());\n    }\n\n    @Override\n    public void writeRaw(char[] text, int offset, int len) throws IOException {\n        \n        if (len < SHORT_WRITE) {\n            int room = _outputEnd - _outputTail;\n            if (len > room) {\n                _flushBuffer();\n            }\n            System.arraycopy(text, offset, _outputBuffer, _outputTail, len);\n            _outputTail += len;\n            return;\n        }\n        \n        _flushBuffer();\n        _writer.write(text, offset, len);\n    }\n\n    @Override\n    public void writeRaw(char c) throws IOException {\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = c;\n    }\n\n    private void writeRawLong(String text) throws IOException {\n        int room = _outputEnd - _outputTail;\n        \n        text.getChars(0, room, _outputBuffer, _outputTail);\n        _outputTail += room;\n        _flushBuffer();\n        int offset = room;\n        int len = text.length() - room;\n\n        while (len > _outputEnd) {\n            int amount = _outputEnd;\n            text.getChars(offset, offset+amount, _outputBuffer, 0);\n            _outputHead = 0;\n            _outputTail = amount;\n            _flushBuffer();\n            offset += amount;\n            len -= amount;\n        }\n        \n        text.getChars(offset, offset+len, _outputBuffer, 0);\n        _outputHead = 0;\n        _outputTail = len;\n    }\n\n    \n\n    @Override\n    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException {\n        _verifyValueWrite(WRITE_BINARY);\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        _writeBinary(b64variant, data, offset, offset+len);\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n    }\n\n    @Override\n    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException {\n        _verifyValueWrite(WRITE_BINARY);\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        byte[] encodingBuffer = _ioContext.allocBase64Buffer();\n        int bytes;\n        try {\n            if (dataLength < 0) { \n                bytes = _writeBinary(b64variant, data, encodingBuffer);\n            } else {\n                int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength);\n                if (missing > 0) {\n                    _reportError(\"Too few bytes available: missing \"+missing+\" bytes (out of \"+dataLength+\")\");\n                }\n                bytes = dataLength;\n            }\n        } finally {\n            _ioContext.releaseBase64Buffer(encodingBuffer);\n        }\n        \n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        return bytes;\n    }\n    \n    \n\n    @Override\n    public void writeNumber(short s) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedShort(s);\n            return;\n        }\n        \n        if ((_outputTail + 6) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n    }\n\n    private void _writeQuotedShort(short s) throws IOException {\n        if ((_outputTail + 8) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = '\"';\n    }    \n\n    @Override\n    public void writeNumber(int i) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedInt(i);\n            return;\n        }\n        \n        if ((_outputTail + 11) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n    }\n\n    private void _writeQuotedInt(int i) throws IOException {\n        if ((_outputTail + 13) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = '\"';\n    }    \n\n    @Override\n    public void writeNumber(long l) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedLong(l);\n            return;\n        }\n        if ((_outputTail + 21) >= _outputEnd) {\n            \n            _flushBuffer();\n        }\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n    }\n\n    private void _writeQuotedLong(long l) throws IOException {\n        if ((_outputTail + 23) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = '\"';\n    }\n\n    \n\n    @Override\n    public void writeNumber(BigInteger value) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(value.toString());\n        } else {\n            writeRaw(value.toString());\n        }\n    }\n\n    \n    @Override\n    public void writeNumber(double d) throws IOException {\n        if (_cfgNumbersAsStrings ||\n            \n                (isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS) && ((Double.isNaN(d) || Double.isInfinite(d))))) {\n            writeString(String.valueOf(d));\n            return;\n        }\n        \n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException {\n        if (_cfgNumbersAsStrings ||\n            \n                (isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS) && ((Float.isNaN(f) || Float.isInfinite(f))))) {\n            writeString(String.valueOf(f));\n            return;\n        }\n        \n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal value) throws IOException {\n        \n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else  if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(_asString(value));\n        } else {\n            writeRaw(_asString(value));\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(encodedValue);\n        } else {\n            writeRaw(encodedValue);\n        }\n    }\n\n    private void _writeQuotedRaw(String value) throws IOException {\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        writeRaw(value);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n    }\n    \n    @Override\n    public void writeBoolean(boolean state) throws IOException {\n        _verifyValueWrite(WRITE_BOOLEAN);\n        if ((_outputTail + 5) >= _outputEnd) {\n            _flushBuffer();\n        }\n        int ptr = _outputTail;\n        char[] buf = _outputBuffer;\n        if (state) {\n            buf[ptr] = 't';\n            buf[++ptr] = 'r';\n            buf[++ptr] = 'u';\n            buf[++ptr] = 'e';\n        } else {\n            buf[ptr] = 'f';\n            buf[++ptr] = 'a';\n            buf[++ptr] = 'l';\n            buf[++ptr] = 's';\n            buf[++ptr] = 'e';\n        }\n        _outputTail = ptr+1;\n    }\n\n    @Override\n    public void writeNull() throws IOException {\n        _verifyValueWrite(WRITE_NULL);\n        _writeNull();\n    }\n\n    \n\n    @Override\n    protected void _verifyValueWrite(String typeMsg) throws IOException {\n        if (_cfgPrettyPrinter != null) {\n            \n            _verifyPrettyValueWrite(typeMsg);\n            return;\n        }\n        char c;\n        final int status = _writeContext.writeValue();\n        if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n            _reportError(\"Can not \"+typeMsg+\", expecting field name\");\n        }\n        switch (status) {\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\n            c = ',';\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\n            c = ':';\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_SPACE: \n            if (_rootValueSeparator != null) {\n                writeRaw(_rootValueSeparator.getValue());\n            }\n            return;\n        case JsonWriteContext.STATUS_OK_AS_IS:\n        default:\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail] = c;\n        ++_outputTail;\n    }\n\n    protected void _verifyPrettyValueWrite(String typeMsg) throws IOException {\n        final int status = _writeContext.writeValue();\n        if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n            _reportError(\"Can not \"+typeMsg+\", expecting field name\");\n        }\n\n        \n        switch (status) {\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA: \n            _cfgPrettyPrinter.writeArrayValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\n            _cfgPrettyPrinter.writeObjectFieldValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_SPACE:\n            _cfgPrettyPrinter.writeRootValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AS_IS:\n            \n            if (_writeContext.inArray()) {\n                _cfgPrettyPrinter.beforeArrayValues(this);\n            } else if (_writeContext.inObject()) {\n                _cfgPrettyPrinter.beforeObjectEntries(this);\n            }\n            break;\n        default:\n            _throwInternal();\n            break;\n        }\n    }\n\n    \n\n    @Override\n    public void flush() throws IOException {\n        _flushBuffer();\n        if (_writer != null) {\n            if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                _writer.flush();\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        super.close();\n\n        \n        \n        if (_outputBuffer != null\n            && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {\n            while (true) {\n                JsonStreamContext ctxt = getOutputContext();\n                if (ctxt.inArray()) {\n                    writeEndArray();\n                } else if (ctxt.inObject()) {\n                    writeEndObject();\n                } else {\n                    break;\n                }\n            }\n        }\n        _flushBuffer();\n        _outputHead = 0;\n        _outputTail = 0;\n\n        \n        if (_writer != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {\n                _writer.close();\n            } else  if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                \n                _writer.flush();\n            }\n        }\n        \n        _releaseBuffers();\n    }\n\n    @Override\n    protected void _releaseBuffers() {\n        char[] buf = _outputBuffer;\n        if (buf != null) {\n            _outputBuffer = null;\n            _ioContext.releaseConcatBuffer(buf);\n        }\n    }\n\n    \n\n    private void _writeString(String text) throws IOException {\n        \n        final int len = text.length();\n        if (len > _outputEnd) { \n            _writeLongString(text);\n            return;\n        }\n\n        \n        \n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n        }\n        text.getChars(0, len, _outputBuffer, _outputTail);\n\n        if (_characterEscapes != null) {\n            _writeStringCustom(len);\n        } else if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(len, _maximumNonEscapedChar);\n        } else {\n            _writeString2(len);\n        }\n    }\n\n    private void _writeString2(final int len) throws IOException {\n        \n        final int end = _outputTail + len;\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\n\n        output_loop:\n        while (_outputTail < end) {\n            \n            escape_loop:\n            while (true) {\n                char c = _outputBuffer[_outputTail];\n                if (c < escLen && escCodes[c] != 0) {\n                    break escape_loop;\n                }\n                if (++_outputTail >= end) {\n                    break output_loop;\n                }\n            }\n\n            \n            \n            int flushLen = (_outputTail - _outputHead);\n            if (flushLen > 0) {\n                _writer.write(_outputBuffer, _outputHead, flushLen);\n            }\n            \n            char c = _outputBuffer[_outputTail++];\n            _prependOrWriteCharacterEscape(c, escCodes[c]);\n        }\n    }\n\n    \n    private void _writeLongString(String text) throws IOException {\n        \n        _flushBuffer();\n\n        \n        final int textLen = text.length();\n        int offset = 0;\n        do {\n            int max = _outputEnd;\n            int segmentLen = ((offset + max) > textLen)\n                ? (textLen - offset) : max;\n            text.getChars(offset, offset+segmentLen, _outputBuffer, 0);\n            if (_characterEscapes != null) {\n                _writeSegmentCustom(segmentLen);\n            } else if (_maximumNonEscapedChar != 0) {\n                _writeSegmentASCII(segmentLen, _maximumNonEscapedChar);\n            } else {\n                _writeSegment(segmentLen);\n            }\n            offset += segmentLen;\n        } while (offset < textLen);\n    }\n\n    \n    private void _writeSegment(int end) throws IOException {\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\n    \n        int ptr = 0;\n        int start = ptr;\n\n        output_loop:\n        while (ptr < end) {\n            \n            char c;\n            while (true) {\n                c = _outputBuffer[ptr];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++ptr >= end) {\n                    break;\n                }\n            }\n\n            \n            \n            int flushLen = (ptr - start);\n            if (flushLen > 0) {\n                _writer.write(_outputBuffer, start, flushLen);\n                if (ptr >= end) {\n                    break output_loop;\n                }\n            }\n            ++ptr;\n            \n            start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCodes[c]);\n        }\n    }\n    \n    \n    private void _writeString(char[] text, int offset, int len) throws IOException {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        \n        len += offset; \n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\n        while (offset < len) {\n            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            \n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                \n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { \n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            \n            if (offset >= len) { \n                break;\n            }\n            \n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }\n\n    \n\n    \n    private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException {\n        \n        int end = _outputTail + len;\n        final int[] escCodes = _outputEscapes;\n        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n        int escCode = 0;\n        \n        output_loop:\n        while (_outputTail < end) {\n            char c;\n            \n            escape_loop:\n            while (true) {\n                c = _outputBuffer[_outputTail];\n                if (c < escLimit) {\n                    escCode = escCodes[c];\n                    if (escCode != 0) {\n                        break escape_loop;\n                    }\n                } else if (c > maxNonEscaped) {\n                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n                    break escape_loop;\n                }\n                if (++_outputTail >= end) {\n                    break output_loop;\n                }\n            }\n            int flushLen = (_outputTail - _outputHead);\n            if (flushLen > 0) {\n                _writer.write(_outputBuffer, _outputHead, flushLen);\n            }\n            ++_outputTail;\n            _prependOrWriteCharacterEscape(c, escCode);\n        }\n    }\n\n    private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException {\n        final int[] escCodes = _outputEscapes;\n        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n    \n        int ptr = 0;\n        int escCode = 0;\n        int start = ptr;\n    \n        output_loop:\n        while (ptr < end) {\n            \n            char c;\n            while (true) {\n                c = _outputBuffer[ptr];\n                if (c < escLimit) {\n                    escCode = escCodes[c];\n                    if (escCode != 0) {\n                        break;\n                    }\n                } else if (c > maxNonEscaped) {\n                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n                    break;\n                }\n                if (++ptr >= end) {\n                    break;\n                }\n            }\n            int flushLen = (ptr - start);\n            if (flushLen > 0) {\n                _writer.write(_outputBuffer, start, flushLen);\n                if (ptr >= end) {\n                    break output_loop;\n                }\n            }\n            ++ptr;\n            start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCode);\n        }\n    }\n\n    private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException {\n        len += offset; \n        final int[] escCodes = _outputEscapes;\n        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n\n        int escCode = 0;\n        \n        while (offset < len) {\n            int start = offset;\n            char c;\n            \n            while (true) {\n                c = text[offset];\n                if (c < escLimit) {\n                    escCode = escCodes[c];\n                    if (escCode != 0) {\n                        break;\n                    }\n                } else if (c > maxNonEscaped) {\n                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            \n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                \n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { \n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            \n            if (offset >= len) { \n                break;\n            }\n            \n            ++offset;\n            _appendCharacterEscape(c, escCode);\n        }\n    }\n\n    \n\n    \n    private void _writeStringCustom(final int len) throws IOException, JsonGenerationException {\n        \n        int end = _outputTail + len;\n        final int[] escCodes = _outputEscapes;\n        final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar;\n        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n        int escCode = 0;\n        final CharacterEscapes customEscapes = _characterEscapes;\n\n        output_loop:\n        while (_outputTail < end) {\n            char c;\n            \n            escape_loop:\n            while (true) {\n                c = _outputBuffer[_outputTail];\n                if (c < escLimit) {\n                    escCode = escCodes[c];\n                    if (escCode != 0) {\n                        break escape_loop;\n                    }\n                } else if (c > maxNonEscaped) {\n                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n                    break escape_loop;\n                } else {\n                    if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) {\n                        escCode = CharacterEscapes.ESCAPE_CUSTOM;\n                        break escape_loop;\n                    }\n                }\n                if (++_outputTail >= end) {\n                    break output_loop;\n                }\n            }\n            int flushLen = (_outputTail - _outputHead);\n            if (flushLen > 0) {\n                _writer.write(_outputBuffer, _outputHead, flushLen);\n            }\n            ++_outputTail;\n            _prependOrWriteCharacterEscape(c, escCode);\n        }\n    }\n\n    private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException {\n        final int[] escCodes = _outputEscapes;\n        final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar;\n        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n        final CharacterEscapes customEscapes = _characterEscapes;\n    \n        int ptr = 0;\n        int escCode = 0;\n        int start = ptr;\n    \n        output_loop:\n        while (ptr < end) {\n            \n            char c;\n            while (true) {\n                c = _outputBuffer[ptr];\n                if (c < escLimit) {\n                    escCode = escCodes[c];\n                    if (escCode != 0) {\n                        break;\n                    }\n                } else if (c > maxNonEscaped) {\n                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n                    break;\n                } else {\n                    if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) {\n                        escCode = CharacterEscapes.ESCAPE_CUSTOM;\n                        break;\n                    }\n                }\n                if (++ptr >= end) {\n                    break;\n                }\n            }\n            int flushLen = (ptr - start);\n            if (flushLen > 0) {\n                _writer.write(_outputBuffer, start, flushLen);\n                if (ptr >= end) {\n                    break output_loop;\n                }\n            }\n            ++ptr;\n            start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCode);\n        }\n    }\n\n    private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n        len += offset; \n        final int[] escCodes = _outputEscapes;\n        final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar;\n        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n        final CharacterEscapes customEscapes = _characterEscapes;\n\n        int escCode = 0;\n        \n        while (offset < len) {\n            int start = offset;\n            char c;\n            \n            while (true) {\n                c = text[offset];\n                if (c < escLimit) {\n                    escCode = escCodes[c];\n                    if (escCode != 0) {\n                        break;\n                    }\n                } else if (c > maxNonEscaped) {\n                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n                    break;\n                } else {\n                    if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) {\n                        escCode = CharacterEscapes.ESCAPE_CUSTOM;\n                        break;\n                    }\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n    \n            \n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                \n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { \n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            \n            if (offset >= len) { \n                break;\n            }\n            \n            ++offset;\n            _appendCharacterEscape(c, escCode);\n        }\n    }\n    \n    \n    \n    protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException {\n        \n        int safeInputEnd = inputEnd - 3;\n        \n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        \n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            \n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                \n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        \n        int inputLeft = inputEnd - inputPtr; \n        if (inputLeft > 0) { \n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }\n\n    \n    protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        \n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { \n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { \n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        \n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { \n                if (_outputTail > safeOutputEnd) { \n                    _flushBuffer();\n                }\n                int b24 = ((int) readBuffer[inputPtr++]) << 16;\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }\n    \n    \n    protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;\n        int bytesDone = 0;\n        \n        \n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        \n        while (true) {\n            if (inputPtr > lastFullOffset) { \n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length);\n                inputPtr = 0;\n                if (inputEnd < 3) { \n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            \n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesDone += 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        \n        if (inputPtr < inputEnd) { \n            if (_outputTail > safeOutputEnd) { \n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 16;\n            int amount = 1;\n            if (inputPtr < inputEnd) {\n                b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                amount = 2;\n            }\n            bytesDone += amount;\n            _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n        }\n        return bytesDone;\n    }\n    \n    private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException {\n        \n        int i = 0;\n        while (inputPtr < inputEnd) {\n            readBuffer[i++]  = readBuffer[inputPtr++];\n        }\n        inputPtr = 0;\n        inputEnd = i;\n        maxRead = Math.min(maxRead, readBuffer.length);\n        \n        do {\n            int length = maxRead - inputEnd;\n            if (length == 0) {\n                break;\n            }\n            int count = in.read(readBuffer, inputEnd, length);            \n            if (count < 0) {\n                return inputEnd;\n            }\n            inputEnd += count;\n        } while (inputEnd < 3);\n        return inputEnd;\n    }\n    \n    \n    \n    private final void _writeNull() throws IOException {\n        if ((_outputTail + 4) >= _outputEnd) {\n            _flushBuffer();\n        }\n        int ptr = _outputTail;\n        char[] buf = _outputBuffer;\n        buf[ptr] = 'n';\n        buf[++ptr] = 'u';\n        buf[++ptr] = 'l';\n        buf[++ptr] = 'l';\n        _outputTail = ptr+1;\n    }\n        \n    \n\n    \n    private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException {\n        if (escCode >= 0) { \n            if (_outputTail >= 2) { \n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            \n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { \n            if (_outputTail >= 6) { \n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                \n                if (ch > 0xFF) { \n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\n                    buf[++ptr] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            \n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { \n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { \n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { \n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        \n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }\n\n    \n    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException {\n        if (escCode >= 0) { \n            if (ptr > 1 && ptr < end) { \n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { \n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { \n            if (ptr > 5 && ptr < end) { \n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                \n                if (ch > 0xFF) { \n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                \n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { \n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { \n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { \n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { \n            _writer.write(escape);\n        }\n        return ptr;\n    }\n\n    \n    private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException {\n        if (escCode >= 0) { \n            if ((_outputTail + 2) > _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '\\\\';\n            _outputBuffer[_outputTail++] = (char) escCode;\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { \n            if ((_outputTail + 5) >= _outputEnd) {\n                _flushBuffer();\n            }\n            int ptr = _outputTail;\n            char[] buf = _outputBuffer;\n            buf[ptr++] = '\\\\';\n            buf[ptr++] = 'u';\n            \n            if (ch > 0xFF) { \n                int hi = (ch >> 8) & 0xFF;\n                buf[ptr++] = HEX_CHARS[hi >> 4];\n                buf[ptr++] = HEX_CHARS[hi & 0xF];\n                ch &= 0xFF;\n            } else {\n                buf[ptr++] = '0';\n                buf[ptr++] = '0';\n            }\n            buf[ptr++] = HEX_CHARS[ch >> 4];\n            buf[ptr++] = HEX_CHARS[ch & 0xF];\n            _outputTail = ptr;\n            return;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n            if (len > _outputEnd) { \n                _writer.write(escape);\n                return;\n            }\n        }\n        escape.getChars(0, len, _outputBuffer, _outputTail);\n        _outputTail += len;\n    }\n    \n    private char[] _allocateEntityBuffer() {\n        char[] buf = new char[14];\n        \n        buf[0] = '\\\\';\n        \n        buf[2] = '\\\\';\n        buf[3] = 'u';\n        buf[4] = '0';\n        buf[5] = '0';\n        \n        buf[8] = '\\\\';\n        buf[9] = 'u';\n        _entityBuffer = buf;\n        return buf;\n    }\n    \n    protected void _flushBuffer() throws IOException {\n        int len = _outputTail - _outputHead;\n        if (len > 0) {\n            int offset = _outputHead;\n            _outputTail = _outputHead = 0;\n            _writer.write(_outputBuffer, offset, len);\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public Object getOutputTarget()",
        "public int getOutputBuffered()",
        "public void writeFieldName(String name) throws IOException",
        "public void writeFieldName(SerializableString name) throws IOException",
        "protected void _writeFieldName(String name, boolean commaBefore) throws IOException",
        "protected void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException",
        "public void writeStartArray() throws IOException, JsonGenerationException",
        "public void writeEndArray() throws IOException, JsonGenerationException",
        "public void writeStartObject() throws IOException, JsonGenerationException",
        "public void writeEndObject() throws IOException, JsonGenerationException",
        "protected void _writePPFieldName(String name, boolean commaBefore) throws IOException",
        "protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException",
        "public void writeString(String text) throws IOException",
        "public void writeString(char[] text, int offset, int len) throws IOException",
        "public void writeString(SerializableString sstr) throws IOException",
        "public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException",
        "public void writeUTF8String(byte[] text, int offset, int length) throws IOException",
        "public void writeRaw(String text) throws IOException",
        "public void writeRaw(String text, int start, int len) throws IOException",
        "public void writeRaw(SerializableString text) throws IOException",
        "public void writeRaw(char[] text, int offset, int len) throws IOException",
        "public void writeRaw(char c) throws IOException",
        "private void writeRawLong(String text) throws IOException",
        "public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException",
        "public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException",
        "public void writeNumber(short s) throws IOException",
        "private void _writeQuotedShort(short s) throws IOException",
        "public void writeNumber(int i) throws IOException",
        "private void _writeQuotedInt(int i) throws IOException",
        "public void writeNumber(long l) throws IOException",
        "private void _writeQuotedLong(long l) throws IOException",
        "public void writeNumber(BigInteger value) throws IOException",
        "public void writeNumber(double d) throws IOException",
        "public void writeNumber(float f) throws IOException",
        "public void writeNumber(BigDecimal value) throws IOException",
        "public void writeNumber(String encodedValue) throws IOException",
        "private void _writeQuotedRaw(String value) throws IOException",
        "public void writeBoolean(boolean state) throws IOException",
        "public void writeNull() throws IOException",
        "protected void _verifyValueWrite(String typeMsg) throws IOException",
        "protected void _verifyPrettyValueWrite(String typeMsg) throws IOException",
        "public void flush() throws IOException",
        "public void close() throws IOException",
        "protected void _releaseBuffers()",
        "private void _writeString(String text) throws IOException",
        "private void _writeString2(final int len) throws IOException",
        "private void _writeLongString(String text) throws IOException",
        "private void _writeSegment(int end) throws IOException",
        "private void _writeString(char[] text, int offset, int len) throws IOException",
        "private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException",
        "private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException",
        "private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException",
        "private void _writeStringCustom(final int len) throws IOException, JsonGenerationException",
        "private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException",
        "private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException",
        "protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException",
        "protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException",
        "protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException",
        "private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException",
        "private final void _writeNull() throws IOException",
        "private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException",
        "private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException",
        "private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException",
        "private char[] _allocateEntityBuffer()",
        "protected void _flushBuffer() throws IOException"
      ],
      "fixed_signatures": [
        "public Object getOutputTarget()",
        "public int getOutputBuffered()",
        "public void writeFieldName(String name) throws IOException",
        "public void writeFieldName(SerializableString name) throws IOException",
        "protected void _writeFieldName(String name, boolean commaBefore) throws IOException",
        "protected void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException",
        "public void writeStartArray() throws IOException, JsonGenerationException",
        "public void writeEndArray() throws IOException, JsonGenerationException",
        "public void writeStartObject() throws IOException, JsonGenerationException",
        "public void writeEndObject() throws IOException, JsonGenerationException",
        "protected void _writePPFieldName(String name, boolean commaBefore) throws IOException",
        "protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException",
        "public void writeString(String text) throws IOException",
        "public void writeString(char[] text, int offset, int len) throws IOException",
        "public void writeString(SerializableString sstr) throws IOException",
        "public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException",
        "public void writeUTF8String(byte[] text, int offset, int length) throws IOException",
        "public void writeRaw(String text) throws IOException",
        "public void writeRaw(String text, int start, int len) throws IOException",
        "public void writeRaw(SerializableString text) throws IOException",
        "public void writeRaw(char[] text, int offset, int len) throws IOException",
        "public void writeRaw(char c) throws IOException",
        "private void writeRawLong(String text) throws IOException",
        "public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException",
        "public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException",
        "public void writeNumber(short s) throws IOException",
        "private void _writeQuotedShort(short s) throws IOException",
        "public void writeNumber(int i) throws IOException",
        "private void _writeQuotedInt(int i) throws IOException",
        "public void writeNumber(long l) throws IOException",
        "private void _writeQuotedLong(long l) throws IOException",
        "public void writeNumber(BigInteger value) throws IOException",
        "public void writeNumber(double d) throws IOException",
        "public void writeNumber(float f) throws IOException",
        "public void writeNumber(BigDecimal value) throws IOException",
        "public void writeNumber(String encodedValue) throws IOException",
        "private void _writeQuotedRaw(String value) throws IOException",
        "public void writeBoolean(boolean state) throws IOException",
        "public void writeNull() throws IOException",
        "protected void _verifyValueWrite(String typeMsg) throws IOException",
        "protected void _verifyPrettyValueWrite(String typeMsg) throws IOException",
        "public void flush() throws IOException",
        "public void close() throws IOException",
        "protected void _releaseBuffers()",
        "private void _writeString(String text) throws IOException",
        "private void _writeString2(final int len) throws IOException",
        "private void _writeLongString(String text) throws IOException",
        "private void _writeSegment(int end) throws IOException",
        "private void _writeString(char[] text, int offset, int len) throws IOException",
        "private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException",
        "private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException",
        "private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException",
        "private void _writeStringCustom(final int len) throws IOException, JsonGenerationException",
        "private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException",
        "private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException",
        "protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException",
        "protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException",
        "protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException",
        "private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException",
        "private final void _writeNull() throws IOException",
        "private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException",
        "private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException",
        "private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException",
        "private char[] _allocateEntityBuffer()",
        "protected void _flushBuffer() throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  public void writeNumber(BigDecimal value) throws IOException {\n  \n  _verifyValueWrite(WRITE_NUMBER);\n  if (value == null) {\n  _writeNull();\n  } else  if (_cfgNumbersAsStrings) {\n  String raw = isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN) ? value.toPlainString() : value.toString();\n  _writeQuotedRaw(raw);\n  } else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n  writeRaw(value.toPlainString());\n  } else {\n  writeRaw(_asString(value));\n  }\n  }",
          "fixed_method": "  public void writeNumber(BigDecimal value) throws IOException {\n  \n  _verifyValueWrite(WRITE_NUMBER);\n  if (value == null) {\n  _writeNull();\n  } else  if (_cfgNumbersAsStrings) {\n  _writeQuotedRaw(_asString(value));\n  } else {\n  writeRaw(_asString(value));\n  }\n  }",
          "diff": [
            "@@ -684,10 +684,7 @@",
            "         if (value == null) {\n",
            "             _writeNull();\n",
            "         } else  if (_cfgNumbersAsStrings) {\n",
            "-            String raw = isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN) ? value.toPlainString() : value.toString();\n",
            "-            _writeQuotedRaw(raw);\n",
            "-        } else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n",
            "-            writeRaw(value.toPlainString());\n",
            "+            _writeQuotedRaw(_asString(value));\n",
            "         } else {\n",
            "             writeRaw(_asString(value));\n",
            "         }\n"
          ],
          "changed_lines": 5
        }
      ]
    }
  ]
}
