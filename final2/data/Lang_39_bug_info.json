{
  "bug_id": "39",
  "failed_tests": {
    "org.apache.commons.lang3.StringUtilsTest": [
      {
        "methodName": "testReplace_StringStringArrayStringArray",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "        assertEquals(StringUtils.replaceEach(\"aba\", new String[]{\"a\", \"b\"}, new String[]{\"c\", null}),\"cbc\");",
        "test_source": "  public void testReplace_StringStringArrayStringArray() {\n\n  \n  //JAVADOC TESTS START\n  assertNull(StringUtils.replaceEach(null, new String[]{\"a\"}, new String[]{\"b\"}));\n  assertEquals(StringUtils.replaceEach(\"\", new String[]{\"a\"}, new String[]{\"b\"}),\"\");\n  assertEquals(StringUtils.replaceEach(\"aba\", null, null),\"aba\");\n  assertEquals(StringUtils.replaceEach(\"aba\", new String[0], null),\"aba\");\n  assertEquals(StringUtils.replaceEach(\"aba\", null, new String[0]),\"aba\");\n  assertEquals(StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null),\"aba\");\n\n  assertEquals(StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}),\"b\");\n  assertEquals(StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}),\"aba\");\n  assertEquals(StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}),\"wcte\");\n  assertEquals(StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}),\"dcte\");\n  //JAVADOC TESTS END\n\n  assertEquals(\"bcc\", StringUtils.replaceEach(\"abc\", new String[]{\"a\", \"b\"}, new String[]{\"b\", \"c\"}));\n  assertEquals(\"q651.506bera\", StringUtils.replaceEach(\"d216.102oren\",\n  new String[]{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \n  \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"A\", \"B\", \"C\", \"D\", \n  \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \n  \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"},\n  new String[]{\"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"a\", \n  \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"N\", \"O\", \"P\", \"Q\", \n  \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \n  \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"5\", \"6\", \"7\", \"8\", \"9\", \"1\", \"2\", \"3\", \"4\"}));\n\n  // Test null safety inside arrays - LANG-552\n  assertEquals(StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{null}),\"aba\");\n  assertEquals(StringUtils.replaceEach(\"aba\", new String[]{\"a\", \"b\"}, new String[]{\"c\", null}),\"cbc\");\n  }",
        "stack": [
          "StringUtils.replaceEach line 3676, StringUtils.replaceEach line 3502, StringUtilsTest.testReplace_StringStringArrayStringArray line 1039"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/lang3/StringUtils.java",
      "buggy_full_code": "\npackage org.apache.commons.lang3;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\n\n\n\npublic class StringUtils { public static final String EMPTY = \"\"; public static final int INDEX_NOT_FOUND = -1; private static final int PAD_LIMIT = 8192; public StringUtils() {\n        super();\n    }\n\n    \n    \n    \n    public static boolean isEmpty(CharSequence str) {\n        return str == null || str.length() == 0;\n    }\n\n    \n    public static boolean isNotEmpty(CharSequence str) {\n        return !StringUtils.isEmpty(str);\n    }\n\n    \n    public static boolean isBlank(CharSequence str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return true;\n        }\n        for (int i = 0; i < strLen; i++) {\n            if ((Character.isWhitespace(str.charAt(i)) == false)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isNotBlank(CharSequence str) {\n        return !StringUtils.isBlank(str);\n    }\n\n    \n    \n    \n    public static String trim(String str) {\n        return str == null ? null : str.trim();\n    }\n\n    \n    public static String trimToNull(String str) {\n        String ts = trim(str);\n        return isEmpty(ts) ? null : ts;\n    }\n\n    \n    public static String trimToEmpty(String str) {\n        return str == null ? EMPTY : str.trim();\n    }\n\n    \n    \n    \n    public static String strip(String str) {\n        return strip(str, null);\n    }\n\n    \n    public static String stripToNull(String str) {\n        if (str == null) {\n            return null;\n        }\n        str = strip(str, null);\n        return str.length() == 0 ? null : str;\n    }\n\n    \n    public static String stripToEmpty(String str) {\n        return str == null ? EMPTY : strip(str, null);\n    }\n\n    \n    public static String strip(String str, String stripChars) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        str = stripStart(str, stripChars);\n        return stripEnd(str, stripChars);\n    }\n\n    \n    public static String stripStart(String str, String stripChars) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        int start = 0;\n        if (stripChars == null) {\n            while ((start != strLen) && Character.isWhitespace(str.charAt(start))) {\n                start++;\n            }\n        } else if (stripChars.length() == 0) {\n            return str;\n        } else {\n            while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != -1)) {\n                start++;\n            }\n        }\n        return str.substring(start);\n    }\n\n    \n    public static String stripEnd(String str, String stripChars) {\n        int end;\n        if (str == null || (end = str.length()) == 0) {\n            return str;\n        }\n\n        if (stripChars == null) {\n            while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) {\n                end--;\n            }\n        } else if (stripChars.length() == 0) {\n            return str;\n        } else {\n            while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != -1)) {\n                end--;\n            }\n        }\n        return str.substring(0, end);\n    }\n\n    \n    \n    \n    public static String[] stripAll(String[] strs) {\n        return stripAll(strs, null);\n    }\n\n    \n    public static String[] stripAll(String[] strs, String stripChars) {\n        int strsLen;\n        if (strs == null || (strsLen = strs.length) == 0) {\n            return strs;\n        }\n        String[] newArr = new String[strsLen];\n        for (int i = 0; i < strsLen; i++) {\n            newArr[i] = strip(strs[i], stripChars);\n        }\n        return newArr;\n    }\n\n    \n    public static String stripAccents(String input) {\n        if(input == null) {\n            return null;\n        }\n        if(SystemUtils.isJavaVersionAtLeast(1.6f)) {\n\n            \n\n            \n            try {\n                \n                Class normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false);\n\n                \n                Class normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false);\n\n                \n                java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass );\n\n                \n                java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\");\n\n                \n                String decomposed = (String) method.invoke( null, input, nfd.get(null) );\n                \n\n                java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\");\n                return accentPattern.matcher(decomposed).replaceAll(\"\");\n            } catch(ClassNotFoundException cnfe) {\n                throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe);\n            } catch(NoSuchMethodException nsme) {\n                throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme);\n            } catch(NoSuchFieldException nsfe) {\n                throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe);\n            } catch(IllegalAccessException iae) {\n                throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae);\n            } catch(IllegalArgumentException iae) {\n                throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae);\n            } catch(java.lang.reflect.InvocationTargetException ite) {\n                throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite);\n            } catch(SecurityException se) {\n                throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\");\n        }\n    }\n\n    \n    \n    \n    public static boolean equals(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equals(str2);\n    }\n\n    \n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n\n    \n    \n    \n    public static int indexOf(String str, char searchChar) {\n        if (isEmpty(str)) {\n            return -1;\n        }\n        return str.indexOf(searchChar);\n    }\n\n    \n    public static int indexOf(String str, char searchChar, int startPos) {\n        if (isEmpty(str)) {\n            return -1;\n        }\n        return str.indexOf(searchChar, startPos);\n    }\n\n    \n    public static int indexOf(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return -1;\n        }\n        return str.indexOf(searchStr);\n    }\n\n    \n    public static int ordinalIndexOf(String str, String searchStr, int ordinal) {\n        if (str == null || searchStr == null || ordinal <= 0) {\n            return INDEX_NOT_FOUND;\n        }\n        if (searchStr.length() == 0) {\n            return 0;\n        }\n        int found = 0;\n        int index = INDEX_NOT_FOUND;\n        do {\n            index = str.indexOf(searchStr, index + 1);\n            if (index < 0) {\n                return index;\n            }\n            found++;\n        } while (found < ordinal);\n        return index;\n    }\n\n    \n    public static int indexOf(String str, String searchStr, int startPos) {\n        if (str == null || searchStr == null) {\n            return -1;\n        }\n        \n        if (searchStr.length() == 0 && startPos >= str.length()) {\n            return str.length();\n        }\n        return str.indexOf(searchStr, startPos);\n    }\n\n    \n    \n    \n    public static int lastIndexOf(String str, char searchChar) {\n        if (isEmpty(str)) {\n            return -1;\n        }\n        return str.lastIndexOf(searchChar);\n    }\n\n    \n    public static int lastIndexOf(String str, char searchChar, int startPos) {\n        if (isEmpty(str)) {\n            return -1;\n        }\n        return str.lastIndexOf(searchChar, startPos);\n    }\n\n    \n    public static int lastIndexOf(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return -1;\n        }\n        return str.lastIndexOf(searchStr);\n    }\n\n    \n    public static int lastIndexOf(String str, String searchStr, int startPos) {\n        if (str == null || searchStr == null) {\n            return -1;\n        }\n        return str.lastIndexOf(searchStr, startPos);\n    }\n\n    \n    \n    \n    public static boolean contains(String str, char searchChar) {\n        if (isEmpty(str)) {\n            return false;\n        }\n        return str.indexOf(searchChar) >= 0;\n    }\n\n    \n    public static boolean contains(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return false;\n        }\n        return str.indexOf(searchStr) >= 0;\n    }\n\n    \n    public static boolean containsIgnoreCase(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return false;\n        }\n        int len = searchStr.length();\n        int max = str.length() - len;\n        for (int i = 0; i <= max; i++) {\n            if (str.regionMatches(true, i, searchStr, 0, len)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    \n    \n    public static int indexOfAny(String str, char[] searchChars) {\n        if (isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {\n            return -1;\n        }\n        for (int i = 0; i < str.length(); i++) {\n            char ch = str.charAt(i);\n            for (int j = 0; j < searchChars.length; j++) {\n                if (searchChars[j] == ch) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    \n    public static int indexOfAny(String str, String searchChars) {\n        if (isEmpty(str) || isEmpty(searchChars)) {\n            return -1;\n        }\n        return indexOfAny(str, searchChars.toCharArray());\n    }\n\n    \n    \n    \n    public static boolean containsAny(String str, char[] searchChars) {\n        if (str == null || str.length() == 0 || searchChars == null || searchChars.length == 0) {\n            return false;\n        }\n        for (int i = 0; i < str.length(); i++) {\n            char ch = str.charAt(i);\n            for (int j = 0; j < searchChars.length; j++) {\n                if (searchChars[j] == ch) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    \n    public static boolean containsAny(String str, String searchChars) {\n        if (searchChars == null) {\n            return false;\n        }\n        return containsAny(str, searchChars.toCharArray());\n    }\n\n    \n    \n    \n    public static int indexOfAnyBut(String str, char[] searchChars) {\n        if (isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {\n            return -1;\n        }\n        outer : for (int i = 0; i < str.length(); i++) {\n            char ch = str.charAt(i);\n            for (int j = 0; j < searchChars.length; j++) {\n                if (searchChars[j] == ch) {\n                    continue outer;\n                }\n            }\n            return i;\n        }\n        return -1;\n    }\n\n    \n    public static int indexOfAnyBut(String str, String searchChars) {\n        if (isEmpty(str) || isEmpty(searchChars)) {\n            return -1;\n        }\n        for (int i = 0; i < str.length(); i++) {\n            if (searchChars.indexOf(str.charAt(i)) < 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    \n    \n    \n    public static boolean containsOnly(String str, char[] valid) {\n        \n        if ((valid == null) || (str == null)) {\n            return false;\n        }\n        if (str.length() == 0) {\n            return true;\n        }\n        if (valid.length == 0) {\n            return false;\n        }\n        return indexOfAnyBut(str, valid) == -1;\n    }\n\n    \n    public static boolean containsOnly(String str, String validChars) {\n        if (str == null || validChars == null) {\n            return false;\n        }\n        return containsOnly(str, validChars.toCharArray());\n    }\n\n    \n    \n    \n    public static boolean containsNone(String str, char[] invalidChars) {\n        if (str == null || invalidChars == null) {\n            return true;\n        }\n        int strSize = str.length();\n        int validSize = invalidChars.length;\n        for (int i = 0; i < strSize; i++) {\n            char ch = str.charAt(i);\n            for (int j = 0; j < validSize; j++) {\n                if (invalidChars[j] == ch) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean containsNone(String str, String invalidChars) {\n        if (str == null || invalidChars == null) {\n            return true;\n        }\n        return containsNone(str, invalidChars.toCharArray());\n    }\n\n    \n    \n    \n    public static int indexOfAny(String str, String[] searchStrs) {\n        if ((str == null) || (searchStrs == null)) {\n            return -1;\n        }\n        int sz = searchStrs.length;\n\n        \n        int ret = Integer.MAX_VALUE;\n\n        int tmp = 0;\n        for (int i = 0; i < sz; i++) {\n            String search = searchStrs[i];\n            if (search == null) {\n                continue;\n            }\n            tmp = str.indexOf(search);\n            if (tmp == -1) {\n                continue;\n            }\n\n            if (tmp < ret) {\n                ret = tmp;\n            }\n        }\n\n        return (ret == Integer.MAX_VALUE) ? -1 : ret;\n    }\n\n    \n    public static int lastIndexOfAny(String str, String[] searchStrs) {\n        if ((str == null) || (searchStrs == null)) {\n            return -1;\n        }\n        int sz = searchStrs.length;\n        int ret = -1;\n        int tmp = 0;\n        for (int i = 0; i < sz; i++) {\n            String search = searchStrs[i];\n            if (search == null) {\n                continue;\n            }\n            tmp = str.lastIndexOf(search);\n            if (tmp > ret) {\n                ret = tmp;\n            }\n        }\n        return ret;\n    }\n\n    \n    \n    \n    public static String substring(String str, int start) {\n        if (str == null) {\n            return null;\n        }\n\n        \n        if (start < 0) {\n            start = str.length() + start; \n        }\n\n        if (start < 0) {\n            start = 0;\n        }\n        if (start > str.length()) {\n            return EMPTY;\n        }\n\n        return str.substring(start);\n    }\n\n    \n    public static String substring(String str, int start, int end) {\n        if (str == null) {\n            return null;\n        }\n\n        \n        if (end < 0) {\n            end = str.length() + end; \n        }\n        if (start < 0) {\n            start = str.length() + start; \n        }\n\n        \n        if (end > str.length()) {\n            end = str.length();\n        }\n\n        \n        if (start > end) {\n            return EMPTY;\n        }\n\n        if (start < 0) {\n            start = 0;\n        }\n        if (end < 0) {\n            end = 0;\n        }\n\n        return str.substring(start, end);\n    }\n\n    \n    \n    \n    public static String left(String str, int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0) {\n            return EMPTY;\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(0, len);\n    }\n\n    \n    public static String right(String str, int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0) {\n            return EMPTY;\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(str.length() - len);\n    }\n\n    \n    public static String mid(String str, int pos, int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0 || pos > str.length()) {\n            return EMPTY;\n        }\n        if (pos < 0) {\n            pos = 0;\n        }\n        if (str.length() <= (pos + len)) {\n            return str.substring(pos);\n        }\n        return str.substring(pos, pos + len);\n    }\n\n    \n    \n    \n    public static String substringBefore(String str, String separator) {\n        if (isEmpty(str) || separator == null) {\n            return str;\n        }\n        if (separator.length() == 0) {\n            return EMPTY;\n        }\n        int pos = str.indexOf(separator);\n        if (pos == -1) {\n            return str;\n        }\n        return str.substring(0, pos);\n    }\n\n    \n    public static String substringAfter(String str, String separator) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        if (separator == null) {\n            return EMPTY;\n        }\n        int pos = str.indexOf(separator);\n        if (pos == -1) {\n            return EMPTY;\n        }\n        return str.substring(pos + separator.length());\n    }\n\n    \n    public static String substringBeforeLast(String str, String separator) {\n        if (isEmpty(str) || isEmpty(separator)) {\n            return str;\n        }\n        int pos = str.lastIndexOf(separator);\n        if (pos == -1) {\n            return str;\n        }\n        return str.substring(0, pos);\n    }\n\n    \n    public static String substringAfterLast(String str, String separator) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        if (isEmpty(separator)) {\n            return EMPTY;\n        }\n        int pos = str.lastIndexOf(separator);\n        if (pos == -1 || pos == (str.length() - separator.length())) {\n            return EMPTY;\n        }\n        return str.substring(pos + separator.length());\n    }\n\n    \n    \n    \n    public static String substringBetween(String str, String tag) {\n        return substringBetween(str, tag, tag);\n    }\n\n    \n    public static String substringBetween(String str, String open, String close) {\n        if (str == null || open == null || close == null) {\n            return null;\n        }\n        int start = str.indexOf(open);\n        if (start != -1) {\n            int end = str.indexOf(close, start + open.length());\n            if (end != -1) {\n                return str.substring(start + open.length(), end);\n            }\n        }\n        return null;\n    }\n\n    \n    public static String[] substringsBetween(String str, String open, String close) {\n        if (str == null || isEmpty(open) || isEmpty(close)) {\n            return null;\n        }\n        int strLen = str.length();\n        if (strLen == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        int closeLen = close.length();\n        int openLen = open.length();\n        List<String> list = new ArrayList<String>();\n        int pos = 0;\n        while (pos < (strLen - closeLen)) {\n            int start = str.indexOf(open, pos);\n            if (start < 0) {\n                break;\n            }\n            start += openLen;\n            int end = str.indexOf(close, start);\n            if (end < 0) {\n                break;\n            }\n            list.add(str.substring(start, end));\n            pos = end + closeLen;\n        }\n        if (list.isEmpty()) {\n            return null;\n        } \n        return list.toArray(new String [list.size()]);\n    }\n\n    \n    \n\n    \n    \n    \n    public static String[] split(String str) {\n        return split(str, null, -1);\n    }\n\n    \n    public static String[] split(String str, char separatorChar) {\n        return splitWorker(str, separatorChar, false);\n    }\n\n    \n    public static String[] split(String str, String separatorChars) {\n        return splitWorker(str, separatorChars, -1, false);\n    }\n\n    \n    public static String[] split(String str, String separatorChars, int max) {\n        return splitWorker(str, separatorChars, max, false);\n    }\n\n    \n    public static String[] splitByWholeSeparator(String str, String separator) {\n        return splitByWholeSeparatorWorker( str, separator, -1, false ) ;\n    }\n\n    \n    public static String[] splitByWholeSeparator( String str, String separator, int max ) {\n        return splitByWholeSeparatorWorker(str, separator, max, false);\n    }\n\n    \n    public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) {\n        return splitByWholeSeparatorWorker(str, separator, -1, true);\n    }\n\n    \n    public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) {\n        return splitByWholeSeparatorWorker(str, separator, max, true);\n    }\n\n    \n    private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\n        if ((separator == null) || (EMPTY.equals(separator))) {\n            \n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        int separatorLength = separator.length();\n\n        ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        \n                        \n                        substrings.add(str.substring(beg, end));\n\n                        \n                        \n                        \n                        beg = end + separatorLength;\n                    }\n                } else {\n                    \n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                \n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }\n\n    \n    \n    public static String[] splitPreserveAllTokens(String str) {\n        return splitWorker(str, null, -1, true);\n    }\n\n    \n    public static String[] splitPreserveAllTokens(String str, char separatorChar) {\n        return splitWorker(str, separatorChar, true);\n    }\n\n    \n    private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) {\n        \n\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        List<String> list = new ArrayList<String>();\n        int i = 0, start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        while (i < len) {\n            if (str.charAt(i) == separatorChar) {\n                if (match || preserveAllTokens) {\n                    list.add(str.substring(start, i));\n                    match = false;\n                    lastMatch = true;\n                }\n                start = ++i;\n                continue;\n            }\n            lastMatch = false;\n            match = true;\n            i++;\n        }\n        if (match || (preserveAllTokens && lastMatch)) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[list.size()]);\n    }\n\n    \n    public static String[] splitPreserveAllTokens(String str, String separatorChars) {\n        return splitWorker(str, separatorChars, -1, true);\n    }\n\n    \n    public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {\n        return splitWorker(str, separatorChars, max, true);\n    }\n\n    \n    private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {\n        \n        \n        \n\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        List<String> list = new ArrayList<String>();\n        int sizePlus1 = 1;\n        int i = 0, start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        if (separatorChars == null) {\n            \n            while (i < len) {\n                if (Character.isWhitespace(str.charAt(i))) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else if (separatorChars.length() == 1) {\n            \n            char sep = separatorChars.charAt(0);\n            while (i < len) {\n                if (str.charAt(i) == sep) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else {\n            \n            while (i < len) {\n                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        }\n        if (match || (preserveAllTokens && lastMatch)) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[list.size()]);\n    }\n\n    \n    public static String[] splitByCharacterType(String str) {\n        return splitByCharacterType(str, false);\n    }\n\n    \n    public static String[] splitByCharacterTypeCamelCase(String str) {\n        return splitByCharacterType(str, true);\n    }\n\n    \n    private static String[] splitByCharacterType(String str, boolean camelCase) {\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        char[] c = str.toCharArray();\n        List<String> list = new ArrayList<String>();\n        int tokenStart = 0;\n        int currentType = Character.getType(c[tokenStart]);\n        for (int pos = tokenStart + 1; pos < c.length; pos++) {\n            int type = Character.getType(c[pos]);\n            if (type == currentType) {\n                continue;\n            }\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                int newTokenStart = pos - 1;\n                if (newTokenStart != tokenStart) {\n                    list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                    tokenStart = newTokenStart;\n                }\n            } else {\n                list.add(new String(c, tokenStart, pos - tokenStart));\n                tokenStart = pos;\n            }\n            currentType = type;\n        }\n        list.add(new String(c, tokenStart, c.length - tokenStart));\n        return list.toArray(new String[list.size()]);\n    }\n\n    \n    \n    \n    public static String join(Object[] array) {\n        return join(array, null);\n    }\n\n    \n    public static String join(Object[] array, char separator) {\n        if (array == null) {\n            return null;\n        }\n\n        return join(array, separator, 0, array.length);\n    }\n\n    \n    public static String join(Object[] array, char separator, int startIndex, int endIndex) {\n        if (array == null) {\n            return null;\n        }\n        int bufSize = (endIndex - startIndex);\n        if (bufSize <= 0) {\n            return EMPTY;\n        }\n\n        bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n        StringBuilder buf = new StringBuilder(bufSize);\n\n        for (int i = startIndex; i < endIndex; i++) {\n            if (i > startIndex) {\n                buf.append(separator);\n            }\n            if (array[i] != null) {\n                buf.append(array[i]);\n            }\n        }\n        return buf.toString();\n    }\n\n\n    \n    public static String join(Object[] array, String separator) {\n        if (array == null) {\n            return null;\n        }\n        return join(array, separator, 0, array.length);\n    }\n\n    \n    public static String join(Object[] array, String separator, int startIndex, int endIndex) {\n        if (array == null) {\n            return null;\n        }\n        if (separator == null) {\n            separator = EMPTY;\n        }\n\n        \n        \n        int bufSize = (endIndex - startIndex);\n        if (bufSize <= 0) {\n            return EMPTY;\n        }\n\n        bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length())\n                        + separator.length());\n\n        StringBuilder buf = new StringBuilder(bufSize);\n\n        for (int i = startIndex; i < endIndex; i++) {\n            if (i > startIndex) {\n                buf.append(separator);\n            }\n            if (array[i] != null) {\n                buf.append(array[i]);\n            }\n        }\n        return buf.toString();\n    }\n\n    \n    public static String join(Iterator<?> iterator, char separator) {\n\n        \n        if (iterator == null) {\n            return null;\n        }\n        if (!iterator.hasNext()) {\n            return EMPTY;\n        }\n        Object first = iterator.next();\n        if (!iterator.hasNext()) {\n            return ObjectUtils.toString(first);\n        }\n\n        \n        StringBuilder buf = new StringBuilder(256); \n        if (first != null) {\n            buf.append(first);\n        }\n\n        while (iterator.hasNext()) {\n            buf.append(separator);\n            Object obj = iterator.next();\n            if (obj != null) {\n                buf.append(obj);\n            }\n        }\n\n        return buf.toString();\n    }\n\n    \n    public static String join(Iterator<?> iterator, String separator) {\n\n        \n        if (iterator == null) {\n            return null;\n        }\n        if (!iterator.hasNext()) {\n            return EMPTY;\n        }\n        Object first = iterator.next();\n        if (!iterator.hasNext()) {\n            return ObjectUtils.toString(first);\n        }\n\n        \n        StringBuilder buf = new StringBuilder(256); \n        if (first != null) {\n            buf.append(first);\n        }\n\n        while (iterator.hasNext()) {\n            if (separator != null) {\n                buf.append(separator);\n            }\n            Object obj = iterator.next();\n            if (obj != null) {\n                buf.append(obj);\n            }\n        }\n        return buf.toString();\n    }\n\n    \n    public static String join(Iterable<?> iterable, char separator) {\n        if (iterable == null) {\n            return null;\n        }\n        return join(iterable.iterator(), separator);\n    }\n\n    \n    public static String join(Iterable<?> iterable, String separator) {\n        if (iterable == null) {\n            return null;\n        }\n        return join(iterable.iterator(), separator);\n    }\n\n    \n    \n    \n    public static String deleteWhitespace(String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        int sz = str.length();\n        char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }\n\n    \n    \n    \n    public static String removeStart(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (str.startsWith(remove)){\n            return str.substring(remove.length());\n        }\n        return str;\n    }\n\n    \n    public static String removeStartIgnoreCase(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (startsWithIgnoreCase(str, remove)) {\n            return str.substring(remove.length());\n        }\n        return str;\n    }\n\n    \n    public static String removeEnd(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (str.endsWith(remove)) {\n            return str.substring(0, str.length() - remove.length());\n        }\n        return str;\n    }\n\n    \n    public static String removeEndIgnoreCase(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (endsWithIgnoreCase(str, remove)) {\n            return str.substring(0, str.length() - remove.length());\n        }\n        return str;\n    }\n\n    \n    public static String remove(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        return replace(str, remove, EMPTY, -1);\n    }\n\n    \n    public static String remove(String str, char remove) {\n        if (isEmpty(str) || str.indexOf(remove) == -1) {\n            return str;\n        }\n        char[] chars = str.toCharArray();\n        int pos = 0;\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] != remove) {\n                chars[pos++] = chars[i];\n            }\n        }\n        return new String(chars, 0, pos);\n    }\n\n    \n    \n    \n    public static String replaceOnce(String text, String searchString, String replacement) {\n        return replace(text, searchString, replacement, 1);\n    }\n\n    \n    public static String replace(String text, String searchString, String replacement) {\n        return replace(text, searchString, replacement, -1);\n    }\n\n    \n    public static String replace(String text, String searchString, String replacement, int max) {\n        if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {\n            return text;\n        }\n        int start = 0;\n        int end = text.indexOf(searchString, start);\n        if (end == -1) {\n            return text;\n        }\n        int replLength = searchString.length();\n        int increase = replacement.length() - replLength;\n        increase = (increase < 0 ? 0 : increase);\n        increase *= (max < 0 ? 16 : (max > 64 ? 64 : max));\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n        while (end != -1) {\n            buf.append(text.substring(start, end)).append(replacement);\n            start = end + replLength;\n            if (--max == 0) {\n                break;\n            }\n            end = text.indexOf(searchString, start);\n        }\n        buf.append(text.substring(start));\n        return buf.toString();\n    }\n\n    \n    public static String replaceEach(String text, String[] searchList, String[] replacementList) {\n        return replaceEach(text, searchList, replacementList, false, 0);\n    }\n\n    \n    public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {\n        \n        \n        int timeToLive = searchList == null ? 0 : searchList.length;\n        return replaceEach(text, searchList, replacementList, true, timeToLive);\n    }\n\n    \n    private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n\n        \n        \n\n        if (text == null || text.length() == 0 || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        \n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        \n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        \n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        \n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        \n        \n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            \n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        \n\n        \n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n\n        \n        int increase = 0;\n\n        \n        for (int i = 0; i < searchList.length; i++) {\n            int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater; \n            }\n        }\n        \n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n            \n            \n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].length() == 0 || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                \n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n            \n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n\n    \n    \n    \n    public static String replaceChars(String str, char searchChar, char replaceChar) {\n        if (str == null) {\n            return null;\n        }\n        return str.replace(searchChar, replaceChar);\n    }\n\n    \n    public static String replaceChars(String str, String searchChars, String replaceChars) {\n        if (isEmpty(str) || isEmpty(searchChars)) {\n            return str;\n        }\n        if (replaceChars == null) {\n            replaceChars = EMPTY;\n        }\n        boolean modified = false;\n        int replaceCharsLength = replaceChars.length();\n        int strLength = str.length();\n        StringBuilder buf = new StringBuilder(strLength);\n        for (int i = 0; i < strLength; i++) {\n            char ch = str.charAt(i);\n            int index = searchChars.indexOf(ch);\n            if (index >= 0) {\n                modified = true;\n                if (index < replaceCharsLength) {\n                    buf.append(replaceChars.charAt(index));\n                }\n            } else {\n                buf.append(ch);\n            }\n        }\n        if (modified) {\n            return buf.toString();\n        }\n        return str;\n    }\n\n    \n    \n    \n    public static String overlay(String str, String overlay, int start, int end) {\n        if (str == null) {\n            return null;\n        }\n        if (overlay == null) {\n            overlay = EMPTY;\n        }\n        int len = str.length();\n        if (start < 0) {\n            start = 0;\n        }\n        if (start > len) {\n            start = len;\n        }\n        if (end < 0) {\n            end = 0;\n        }\n        if (end > len) {\n            end = len;\n        }\n        if (start > end) {\n            int temp = start;\n            start = end;\n            end = temp;\n        }\n        return new StringBuilder(len + start - end + overlay.length() + 1)\n            .append(str.substring(0, start))\n            .append(overlay)\n            .append(str.substring(end))\n            .toString();\n    }\n\n    \n    \n    \n    public static String chomp(String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n\n        if (str.length() == 1) {\n            char ch = str.charAt(0);\n            if (ch == CharUtils.CR || ch == CharUtils.LF) {\n                return EMPTY;\n            }\n            return str;\n        }\n\n        int lastIdx = str.length() - 1;\n        char last = str.charAt(lastIdx);\n\n        if (last == CharUtils.LF) {\n            if (str.charAt(lastIdx - 1) == CharUtils.CR) {\n                lastIdx--;\n            }\n        } else if (last != CharUtils.CR) {\n            lastIdx++;\n        }\n        return str.substring(0, lastIdx);\n    }\n\n    \n    public static String chomp(String str, String separator) {\n        if (isEmpty(str) || separator == null) {\n            return str;\n        }\n        if (str.endsWith(separator)) {\n            return str.substring(0, str.length() - separator.length());\n        }\n        return str;\n    }\n\n    \n    \n    \n    public static String chop(String str) {\n        if (str == null) {\n            return null;\n        }\n        int strLen = str.length();\n        if (strLen < 2) {\n            return EMPTY;\n        }\n        int lastIdx = strLen - 1;\n        String ret = str.substring(0, lastIdx);\n        char last = str.charAt(lastIdx);\n        if (last == CharUtils.LF) {\n            if (ret.charAt(lastIdx - 1) == CharUtils.CR) {\n                return ret.substring(0, lastIdx - 1);\n            }\n        }\n        return ret;\n    }\n\n    \n    \n\n    \n    \n    \n    public static String repeat(String str, int repeat) {\n        \n\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return padding(repeat, str.charAt(0));\n        }\n\n        int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                char ch = str.charAt(0);\n                char[] output1 = new char[outputLength];\n                for (int i = repeat - 1; i >= 0; i--) {\n                    output1[i] = ch;\n                }\n                return new String(output1);\n            case 2 :\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }\n\n    \n    public static String repeat(String str, String separator, int repeat) {\n        if(str == null || separator == null) {\n            return repeat(str, repeat);\n        } else {\n            \n            String result = repeat(str + separator, repeat);\n            return removeEnd(result, separator);\n        }\n    }\n\n    \n    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        final char[] buf = new char[repeat];\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = padChar;\n        }\n        return new String(buf);\n    }\n\n    \n    public static String rightPad(String str, int size) {\n        return rightPad(str, size, ' ');\n    }\n\n    \n    public static String rightPad(String str, int size, char padChar) {\n        if (str == null) {\n            return null;\n        }\n        int pads = size - str.length();\n        if (pads <= 0) {\n            return str; \n        }\n        if (pads > PAD_LIMIT) {\n            return rightPad(str, size, String.valueOf(padChar));\n        }\n        return str.concat(padding(pads, padChar));\n    }\n\n    \n    public static String rightPad(String str, int size, String padStr) {\n        if (str == null) {\n            return null;\n        }\n        if (isEmpty(padStr)) {\n            padStr = \" \";\n        }\n        int padLen = padStr.length();\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str; \n        }\n        if (padLen == 1 && pads <= PAD_LIMIT) {\n            return rightPad(str, size, padStr.charAt(0));\n        }\n\n        if (pads == padLen) {\n            return str.concat(padStr);\n        } else if (pads < padLen) {\n            return str.concat(padStr.substring(0, pads));\n        } else {\n            char[] padding = new char[pads];\n            char[] padChars = padStr.toCharArray();\n            for (int i = 0; i < pads; i++) {\n                padding[i] = padChars[i % padLen];\n            }\n            return str.concat(new String(padding));\n        }\n    }\n\n    \n    public static String leftPad(String str, int size) {\n        return leftPad(str, size, ' ');\n    }\n\n    \n    public static String leftPad(String str, int size, char padChar) {\n        if (str == null) {\n            return null;\n        }\n        int pads = size - str.length();\n        if (pads <= 0) {\n            return str; \n        }\n        if (pads > PAD_LIMIT) {\n            return leftPad(str, size, String.valueOf(padChar));\n        }\n        return padding(pads, padChar).concat(str);\n    }\n\n    \n    public static String leftPad(String str, int size, String padStr) {\n        if (str == null) {\n            return null;\n        }\n        if (isEmpty(padStr)) {\n            padStr = \" \";\n        }\n        int padLen = padStr.length();\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str; \n        }\n        if (padLen == 1 && pads <= PAD_LIMIT) {\n            return leftPad(str, size, padStr.charAt(0));\n        }\n\n        if (pads == padLen) {\n            return padStr.concat(str);\n        } else if (pads < padLen) {\n            return padStr.substring(0, pads).concat(str);\n        } else {\n            char[] padding = new char[pads];\n            char[] padChars = padStr.toCharArray();\n            for (int i = 0; i < pads; i++) {\n                padding[i] = padChars[i % padLen];\n            }\n            return new String(padding).concat(str);\n        }\n    }\n\n    \n    public static int length(String str) {\n        return str == null ? 0 : str.length();\n    }\n    \n    \n    \n    \n    public static String center(String str, int size) {\n        return center(str, size, ' ');\n    }\n\n    \n    public static String center(String str, int size, char padChar) {\n        if (str == null || size <= 0) {\n            return str;\n        }\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str;\n        }\n        str = leftPad(str, strLen + pads / 2, padChar);\n        str = rightPad(str, size, padChar);\n        return str;\n    }\n\n    \n    public static String center(String str, int size, String padStr) {\n        if (str == null || size <= 0) {\n            return str;\n        }\n        if (isEmpty(padStr)) {\n            padStr = \" \";\n        }\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str;\n        }\n        str = leftPad(str, strLen + pads / 2, padStr);\n        str = rightPad(str, size, padStr);\n        return str;\n    }\n\n    \n    \n    \n    public static String upperCase(String str) {\n        if (str == null) {\n            return null;\n        }\n        return str.toUpperCase();\n    }\n\n    \n    public static String upperCase(String str, Locale locale) {\n        if (str == null) {\n            return null;\n        }\n        return str.toUpperCase(locale);\n    }\n\n    \n    public static String lowerCase(String str) {\n        if (str == null) {\n            return null;\n        }\n        return str.toLowerCase();\n    }\n\n    \n    public static String lowerCase(String str, Locale locale) {\n        if (str == null) {\n            return null;\n        }\n        return str.toLowerCase(locale);\n    }\n\n    \n    public static String capitalize(String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        return new StringBuilder(strLen)\n            .append(Character.toTitleCase(str.charAt(0)))\n            .append(str.substring(1))\n            .toString();\n    }\n\n    \n    public static String uncapitalize(String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        return new StringBuilder(strLen)\n            .append(Character.toLowerCase(str.charAt(0)))\n            .append(str.substring(1))\n            .toString();\n    }\n\n    \n    public static String swapCase(String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        StringBuilder buffer = new StringBuilder(strLen);\n\n        char ch = 0;\n        for (int i = 0; i < strLen; i++) {\n            ch = str.charAt(i);\n            if (Character.isUpperCase(ch)) {\n                ch = Character.toLowerCase(ch);\n            } else if (Character.isTitleCase(ch)) {\n                ch = Character.toLowerCase(ch);\n            } else if (Character.isLowerCase(ch)) {\n                ch = Character.toUpperCase(ch);\n            }\n            buffer.append(ch);\n        }\n        return buffer.toString();\n    }\n\n    \n    \n    \n    public static int countMatches(String str, String sub) {\n        if (isEmpty(str) || isEmpty(sub)) {\n            return 0;\n        }\n        int count = 0;\n        int idx = 0;\n        while ((idx = str.indexOf(sub, idx)) != -1) {\n            count++;\n            idx += sub.length();\n        }\n        return count;\n    }\n\n    \n    \n    \n    public static boolean isAlpha(String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isLetter(str.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAlphaSpace(String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isLetter(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAlphanumeric(String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isLetterOrDigit(str.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAlphanumericSpace(String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isLetterOrDigit(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAsciiPrintable(String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (CharUtils.isAsciiPrintable(str.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isNumeric(String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isDigit(str.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isNumericSpace(String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isDigit(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isWhitespace(String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isWhitespace(str.charAt(i)) == false)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAllLowerCase(String str) {\n        if (str == null || isEmpty(str)) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isLowerCase(str.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAllUpperCase(String str) {\n        if (str == null || isEmpty(str)) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isUpperCase(str.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    \n    \n    public static String defaultString(String str) {\n        return str == null ? EMPTY : str;\n    }\n\n    \n    public static String defaultString(String str, String defaultStr) {\n        return str == null ? defaultStr : str;\n    }\n\n    \n    public static String defaultIfEmpty(String str, String defaultStr) {\n        return StringUtils.isEmpty(str) ? defaultStr : str;\n    }\n\n    \n    \n    \n    public static String reverse(String str) {\n        if (str == null) {\n            return null;\n        }\n        return new StringBuilder(str).reverse().toString();\n    }\n\n    \n    public static String reverseDelimited(String str, char separatorChar) {\n        if (str == null) {\n            return null;\n        }\n        \n        \n        String[] strs = split(str, separatorChar);\n        ArrayUtils.reverse(strs);\n        return join(strs, separatorChar);\n    }\n\n    \n    \n    \n    public static String abbreviate(String str, int maxWidth) {\n        return abbreviate(str, 0, maxWidth);\n    }\n\n    \n    public static String abbreviate(String str, int offset, int maxWidth) {\n        if (str == null) {\n            return null;\n        }\n        if (maxWidth < 4) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n        }\n        if (str.length() <= maxWidth) {\n            return str;\n        }\n        if (offset > str.length()) {\n            offset = str.length();\n        }\n        if ((str.length() - offset) < (maxWidth - 3)) {\n            offset = str.length() - (maxWidth - 3);\n        }\n        if (offset <= 4) {\n            return str.substring(0, maxWidth - 3) + \"...\";\n        }\n        if (maxWidth < 7) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n        }\n        if ((offset + (maxWidth - 3)) < str.length()) {\n            return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n        }\n        return \"...\" + str.substring(str.length() - (maxWidth - 3));\n    }\n\n    \n    \n    \n    public static String difference(String str1, String str2) {\n        if (str1 == null) {\n            return str2;\n        }\n        if (str2 == null) {\n            return str1;\n        }\n        int at = indexOfDifference(str1, str2);\n        if (at == -1) {\n            return EMPTY;\n        }\n        return str2.substring(at);\n    }\n\n    \n    public static int indexOfDifference(String str1, String str2) {\n        if (str1 == str2) {\n            return -1;\n        }\n        if (str1 == null || str2 == null) {\n            return 0;\n        }\n        int i;\n        for (i = 0; i < str1.length() && i < str2.length(); ++i) {\n            if (str1.charAt(i) != str2.charAt(i)) {\n                break;\n            }\n        }\n        if (i < str2.length() || i < str1.length()) {\n            return i;\n        }\n        return -1;\n    }\n\n    \n    public static int indexOfDifference(String[] strs) {\n        if (strs == null || strs.length <= 1) {\n            return -1;\n        }\n        boolean anyStringNull = false;\n        boolean allStringsNull = true;\n        int arrayLen = strs.length;\n        int shortestStrLen = Integer.MAX_VALUE;\n        int longestStrLen = 0;\n\n        \n        \n        \n        for (int i = 0; i < arrayLen; i++) {\n            if (strs[i] == null) {\n                anyStringNull = true;\n                shortestStrLen = 0;\n            } else {\n                allStringsNull = false;\n                shortestStrLen = Math.min(strs[i].length(), shortestStrLen);\n                longestStrLen = Math.max(strs[i].length(), longestStrLen);\n            }\n        }\n\n        \n        if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) {\n            return -1;\n        }\n\n        \n        if (shortestStrLen == 0) {\n            return 0;\n        }\n\n        \n        int firstDiff = -1;\n        for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {\n            char comparisonChar = strs[0].charAt(stringPos);\n            for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {\n                if (strs[arrayPos].charAt(stringPos) != comparisonChar) {\n                    firstDiff = stringPos;\n                    break;\n                }\n            }\n            if (firstDiff != -1) {\n                break;\n            }\n        }\n\n        if (firstDiff == -1 && shortestStrLen != longestStrLen) {\n            \n            \n            \n            return shortestStrLen;\n        }\n        return firstDiff;\n    }\n    \n    \n    public static String getCommonPrefix(String[] strs) {\n        if (strs == null || strs.length == 0) {\n            return EMPTY;\n        }\n        int smallestIndexOfDiff = indexOfDifference(strs);\n        if (smallestIndexOfDiff == -1) {\n            \n            if (strs[0] == null) {\n                return EMPTY;\n            }\n            return strs[0];\n        } else if (smallestIndexOfDiff == 0) {\n            \n            return EMPTY;\n        } else {\n            \n            return strs[0].substring(0, smallestIndexOfDiff);\n        }\n    }  \n    \n    \n    \n    \n    public static int getLevenshteinDistance(String s, String t) {\n        if (s == null || t == null) {\n            throw new IllegalArgumentException(\"Strings must not be null\");\n        }\n\n        \n\n        int n = s.length(); \n        int m = t.length(); \n\n        if (n == 0) {\n            return m;\n        } else if (m == 0) {\n            return n;\n        }\n\n        if (n > m) {\n            \n            String tmp = s;\n            s = t;\n            t = tmp;\n            n = m;\n            m = t.length();\n        }\n\n        int p[] = new int[n+1]; \n        int d[] = new int[n+1]; \n        int _d[]; \n\n        \n        int i; \n        int j; \n\n        char t_j; \n\n        int cost; \n\n        for (i = 0; i<=n; i++) {\n            p[i] = i;\n        }\n\n        for (j = 1; j<=m; j++) {\n            t_j = t.charAt(j-1);\n            d[0] = j;\n\n            for (i=1; i<=n; i++) {\n                cost = s.charAt(i-1)==t_j ? 0 : 1;\n                \n                d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]+cost);\n            }\n\n            \n            _d = p;\n            p = d;\n            d = _d;\n        }\n\n        \n        \n        return p[n];\n    }\n\n    \n\n\n    \n    \n\n    \n    public static boolean startsWith(String str, String prefix) {\n        return startsWith(str, prefix, false);\n    }\n\n    \n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        return startsWith(str, prefix, true);\n    }\n\n    \n    private static boolean startsWith(String str, String prefix, boolean ignoreCase) {\n        if (str == null || prefix == null) {\n            return (str == null && prefix == null);\n        }\n        if (prefix.length() > str.length()) {\n            return false;\n        }\n        return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());\n    }\n    \n    \n    public static boolean startsWithAny(String string, String[] searchStrings) {\n        if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {\n            return false;\n        }\n        for (int i = 0; i < searchStrings.length; i++) {\n            String searchString = searchStrings[i];\n            if (StringUtils.startsWith(string, searchString)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    \n\n    \n    public static boolean endsWith(String str, String suffix) {\n        return endsWith(str, suffix, false);\n    }\n\n    \n    public static boolean endsWithIgnoreCase(String str, String suffix) {\n        return endsWith(str, suffix, true);\n    }\n\n    \n    private static boolean endsWith(String str, String suffix, boolean ignoreCase) {\n        if (str == null || suffix == null) {\n            return (str == null && suffix == null);\n        }\n        if (suffix.length() > str.length()) {\n            return false;\n        }\n        int strOffset = str.length() - suffix.length();\n        return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.lang3;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\n\n\n\npublic class StringUtils { public static final String EMPTY = \"\"; public static final int INDEX_NOT_FOUND = -1; private static final int PAD_LIMIT = 8192; public StringUtils() {\n        super();\n    }\n\n    \n    \n    \n    public static boolean isEmpty(CharSequence str) {\n        return str == null || str.length() == 0;\n    }\n\n    \n    public static boolean isNotEmpty(CharSequence str) {\n        return !StringUtils.isEmpty(str);\n    }\n\n    \n    public static boolean isBlank(CharSequence str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return true;\n        }\n        for (int i = 0; i < strLen; i++) {\n            if ((Character.isWhitespace(str.charAt(i)) == false)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isNotBlank(CharSequence str) {\n        return !StringUtils.isBlank(str);\n    }\n\n    \n    \n    \n    public static String trim(String str) {\n        return str == null ? null : str.trim();\n    }\n\n    \n    public static String trimToNull(String str) {\n        String ts = trim(str);\n        return isEmpty(ts) ? null : ts;\n    }\n\n    \n    public static String trimToEmpty(String str) {\n        return str == null ? EMPTY : str.trim();\n    }\n\n    \n    \n    \n    public static String strip(String str) {\n        return strip(str, null);\n    }\n\n    \n    public static String stripToNull(String str) {\n        if (str == null) {\n            return null;\n        }\n        str = strip(str, null);\n        return str.length() == 0 ? null : str;\n    }\n\n    \n    public static String stripToEmpty(String str) {\n        return str == null ? EMPTY : strip(str, null);\n    }\n\n    \n    public static String strip(String str, String stripChars) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        str = stripStart(str, stripChars);\n        return stripEnd(str, stripChars);\n    }\n\n    \n    public static String stripStart(String str, String stripChars) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        int start = 0;\n        if (stripChars == null) {\n            while ((start != strLen) && Character.isWhitespace(str.charAt(start))) {\n                start++;\n            }\n        } else if (stripChars.length() == 0) {\n            return str;\n        } else {\n            while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != -1)) {\n                start++;\n            }\n        }\n        return str.substring(start);\n    }\n\n    \n    public static String stripEnd(String str, String stripChars) {\n        int end;\n        if (str == null || (end = str.length()) == 0) {\n            return str;\n        }\n\n        if (stripChars == null) {\n            while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) {\n                end--;\n            }\n        } else if (stripChars.length() == 0) {\n            return str;\n        } else {\n            while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != -1)) {\n                end--;\n            }\n        }\n        return str.substring(0, end);\n    }\n\n    \n    \n    \n    public static String[] stripAll(String[] strs) {\n        return stripAll(strs, null);\n    }\n\n    \n    public static String[] stripAll(String[] strs, String stripChars) {\n        int strsLen;\n        if (strs == null || (strsLen = strs.length) == 0) {\n            return strs;\n        }\n        String[] newArr = new String[strsLen];\n        for (int i = 0; i < strsLen; i++) {\n            newArr[i] = strip(strs[i], stripChars);\n        }\n        return newArr;\n    }\n\n    \n    public static String stripAccents(String input) {\n        if(input == null) {\n            return null;\n        }\n        if(SystemUtils.isJavaVersionAtLeast(1.6f)) {\n\n            \n\n            \n            try {\n                \n                Class normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false);\n\n                \n                Class normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false);\n\n                \n                java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass );\n\n                \n                java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\");\n\n                \n                String decomposed = (String) method.invoke( null, input, nfd.get(null) );\n                \n\n                java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\");\n                return accentPattern.matcher(decomposed).replaceAll(\"\");\n            } catch(ClassNotFoundException cnfe) {\n                throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe);\n            } catch(NoSuchMethodException nsme) {\n                throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme);\n            } catch(NoSuchFieldException nsfe) {\n                throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe);\n            } catch(IllegalAccessException iae) {\n                throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae);\n            } catch(IllegalArgumentException iae) {\n                throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae);\n            } catch(java.lang.reflect.InvocationTargetException ite) {\n                throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite);\n            } catch(SecurityException se) {\n                throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\");\n        }\n    }\n\n    \n    \n    \n    public static boolean equals(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equals(str2);\n    }\n\n    \n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n\n    \n    \n    \n    public static int indexOf(String str, char searchChar) {\n        if (isEmpty(str)) {\n            return -1;\n        }\n        return str.indexOf(searchChar);\n    }\n\n    \n    public static int indexOf(String str, char searchChar, int startPos) {\n        if (isEmpty(str)) {\n            return -1;\n        }\n        return str.indexOf(searchChar, startPos);\n    }\n\n    \n    public static int indexOf(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return -1;\n        }\n        return str.indexOf(searchStr);\n    }\n\n    \n    public static int ordinalIndexOf(String str, String searchStr, int ordinal) {\n        if (str == null || searchStr == null || ordinal <= 0) {\n            return INDEX_NOT_FOUND;\n        }\n        if (searchStr.length() == 0) {\n            return 0;\n        }\n        int found = 0;\n        int index = INDEX_NOT_FOUND;\n        do {\n            index = str.indexOf(searchStr, index + 1);\n            if (index < 0) {\n                return index;\n            }\n            found++;\n        } while (found < ordinal);\n        return index;\n    }\n\n    \n    public static int indexOf(String str, String searchStr, int startPos) {\n        if (str == null || searchStr == null) {\n            return -1;\n        }\n        \n        if (searchStr.length() == 0 && startPos >= str.length()) {\n            return str.length();\n        }\n        return str.indexOf(searchStr, startPos);\n    }\n\n    \n    \n    \n    public static int lastIndexOf(String str, char searchChar) {\n        if (isEmpty(str)) {\n            return -1;\n        }\n        return str.lastIndexOf(searchChar);\n    }\n\n    \n    public static int lastIndexOf(String str, char searchChar, int startPos) {\n        if (isEmpty(str)) {\n            return -1;\n        }\n        return str.lastIndexOf(searchChar, startPos);\n    }\n\n    \n    public static int lastIndexOf(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return -1;\n        }\n        return str.lastIndexOf(searchStr);\n    }\n\n    \n    public static int lastIndexOf(String str, String searchStr, int startPos) {\n        if (str == null || searchStr == null) {\n            return -1;\n        }\n        return str.lastIndexOf(searchStr, startPos);\n    }\n\n    \n    \n    \n    public static boolean contains(String str, char searchChar) {\n        if (isEmpty(str)) {\n            return false;\n        }\n        return str.indexOf(searchChar) >= 0;\n    }\n\n    \n    public static boolean contains(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return false;\n        }\n        return str.indexOf(searchStr) >= 0;\n    }\n\n    \n    public static boolean containsIgnoreCase(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return false;\n        }\n        int len = searchStr.length();\n        int max = str.length() - len;\n        for (int i = 0; i <= max; i++) {\n            if (str.regionMatches(true, i, searchStr, 0, len)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    \n    \n    public static int indexOfAny(String str, char[] searchChars) {\n        if (isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {\n            return -1;\n        }\n        for (int i = 0; i < str.length(); i++) {\n            char ch = str.charAt(i);\n            for (int j = 0; j < searchChars.length; j++) {\n                if (searchChars[j] == ch) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    \n    public static int indexOfAny(String str, String searchChars) {\n        if (isEmpty(str) || isEmpty(searchChars)) {\n            return -1;\n        }\n        return indexOfAny(str, searchChars.toCharArray());\n    }\n\n    \n    \n    \n    public static boolean containsAny(String str, char[] searchChars) {\n        if (str == null || str.length() == 0 || searchChars == null || searchChars.length == 0) {\n            return false;\n        }\n        for (int i = 0; i < str.length(); i++) {\n            char ch = str.charAt(i);\n            for (int j = 0; j < searchChars.length; j++) {\n                if (searchChars[j] == ch) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    \n    public static boolean containsAny(String str, String searchChars) {\n        if (searchChars == null) {\n            return false;\n        }\n        return containsAny(str, searchChars.toCharArray());\n    }\n\n    \n    \n    \n    public static int indexOfAnyBut(String str, char[] searchChars) {\n        if (isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {\n            return -1;\n        }\n        outer : for (int i = 0; i < str.length(); i++) {\n            char ch = str.charAt(i);\n            for (int j = 0; j < searchChars.length; j++) {\n                if (searchChars[j] == ch) {\n                    continue outer;\n                }\n            }\n            return i;\n        }\n        return -1;\n    }\n\n    \n    public static int indexOfAnyBut(String str, String searchChars) {\n        if (isEmpty(str) || isEmpty(searchChars)) {\n            return -1;\n        }\n        for (int i = 0; i < str.length(); i++) {\n            if (searchChars.indexOf(str.charAt(i)) < 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    \n    \n    \n    public static boolean containsOnly(String str, char[] valid) {\n        \n        if ((valid == null) || (str == null)) {\n            return false;\n        }\n        if (str.length() == 0) {\n            return true;\n        }\n        if (valid.length == 0) {\n            return false;\n        }\n        return indexOfAnyBut(str, valid) == -1;\n    }\n\n    \n    public static boolean containsOnly(String str, String validChars) {\n        if (str == null || validChars == null) {\n            return false;\n        }\n        return containsOnly(str, validChars.toCharArray());\n    }\n\n    \n    \n    \n    public static boolean containsNone(String str, char[] invalidChars) {\n        if (str == null || invalidChars == null) {\n            return true;\n        }\n        int strSize = str.length();\n        int validSize = invalidChars.length;\n        for (int i = 0; i < strSize; i++) {\n            char ch = str.charAt(i);\n            for (int j = 0; j < validSize; j++) {\n                if (invalidChars[j] == ch) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean containsNone(String str, String invalidChars) {\n        if (str == null || invalidChars == null) {\n            return true;\n        }\n        return containsNone(str, invalidChars.toCharArray());\n    }\n\n    \n    \n    \n    public static int indexOfAny(String str, String[] searchStrs) {\n        if ((str == null) || (searchStrs == null)) {\n            return -1;\n        }\n        int sz = searchStrs.length;\n\n        \n        int ret = Integer.MAX_VALUE;\n\n        int tmp = 0;\n        for (int i = 0; i < sz; i++) {\n            String search = searchStrs[i];\n            if (search == null) {\n                continue;\n            }\n            tmp = str.indexOf(search);\n            if (tmp == -1) {\n                continue;\n            }\n\n            if (tmp < ret) {\n                ret = tmp;\n            }\n        }\n\n        return (ret == Integer.MAX_VALUE) ? -1 : ret;\n    }\n\n    \n    public static int lastIndexOfAny(String str, String[] searchStrs) {\n        if ((str == null) || (searchStrs == null)) {\n            return -1;\n        }\n        int sz = searchStrs.length;\n        int ret = -1;\n        int tmp = 0;\n        for (int i = 0; i < sz; i++) {\n            String search = searchStrs[i];\n            if (search == null) {\n                continue;\n            }\n            tmp = str.lastIndexOf(search);\n            if (tmp > ret) {\n                ret = tmp;\n            }\n        }\n        return ret;\n    }\n\n    \n    \n    \n    public static String substring(String str, int start) {\n        if (str == null) {\n            return null;\n        }\n\n        \n        if (start < 0) {\n            start = str.length() + start; \n        }\n\n        if (start < 0) {\n            start = 0;\n        }\n        if (start > str.length()) {\n            return EMPTY;\n        }\n\n        return str.substring(start);\n    }\n\n    \n    public static String substring(String str, int start, int end) {\n        if (str == null) {\n            return null;\n        }\n\n        \n        if (end < 0) {\n            end = str.length() + end; \n        }\n        if (start < 0) {\n            start = str.length() + start; \n        }\n\n        \n        if (end > str.length()) {\n            end = str.length();\n        }\n\n        \n        if (start > end) {\n            return EMPTY;\n        }\n\n        if (start < 0) {\n            start = 0;\n        }\n        if (end < 0) {\n            end = 0;\n        }\n\n        return str.substring(start, end);\n    }\n\n    \n    \n    \n    public static String left(String str, int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0) {\n            return EMPTY;\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(0, len);\n    }\n\n    \n    public static String right(String str, int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0) {\n            return EMPTY;\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(str.length() - len);\n    }\n\n    \n    public static String mid(String str, int pos, int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0 || pos > str.length()) {\n            return EMPTY;\n        }\n        if (pos < 0) {\n            pos = 0;\n        }\n        if (str.length() <= (pos + len)) {\n            return str.substring(pos);\n        }\n        return str.substring(pos, pos + len);\n    }\n\n    \n    \n    \n    public static String substringBefore(String str, String separator) {\n        if (isEmpty(str) || separator == null) {\n            return str;\n        }\n        if (separator.length() == 0) {\n            return EMPTY;\n        }\n        int pos = str.indexOf(separator);\n        if (pos == -1) {\n            return str;\n        }\n        return str.substring(0, pos);\n    }\n\n    \n    public static String substringAfter(String str, String separator) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        if (separator == null) {\n            return EMPTY;\n        }\n        int pos = str.indexOf(separator);\n        if (pos == -1) {\n            return EMPTY;\n        }\n        return str.substring(pos + separator.length());\n    }\n\n    \n    public static String substringBeforeLast(String str, String separator) {\n        if (isEmpty(str) || isEmpty(separator)) {\n            return str;\n        }\n        int pos = str.lastIndexOf(separator);\n        if (pos == -1) {\n            return str;\n        }\n        return str.substring(0, pos);\n    }\n\n    \n    public static String substringAfterLast(String str, String separator) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        if (isEmpty(separator)) {\n            return EMPTY;\n        }\n        int pos = str.lastIndexOf(separator);\n        if (pos == -1 || pos == (str.length() - separator.length())) {\n            return EMPTY;\n        }\n        return str.substring(pos + separator.length());\n    }\n\n    \n    \n    \n    public static String substringBetween(String str, String tag) {\n        return substringBetween(str, tag, tag);\n    }\n\n    \n    public static String substringBetween(String str, String open, String close) {\n        if (str == null || open == null || close == null) {\n            return null;\n        }\n        int start = str.indexOf(open);\n        if (start != -1) {\n            int end = str.indexOf(close, start + open.length());\n            if (end != -1) {\n                return str.substring(start + open.length(), end);\n            }\n        }\n        return null;\n    }\n\n    \n    public static String[] substringsBetween(String str, String open, String close) {\n        if (str == null || isEmpty(open) || isEmpty(close)) {\n            return null;\n        }\n        int strLen = str.length();\n        if (strLen == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        int closeLen = close.length();\n        int openLen = open.length();\n        List<String> list = new ArrayList<String>();\n        int pos = 0;\n        while (pos < (strLen - closeLen)) {\n            int start = str.indexOf(open, pos);\n            if (start < 0) {\n                break;\n            }\n            start += openLen;\n            int end = str.indexOf(close, start);\n            if (end < 0) {\n                break;\n            }\n            list.add(str.substring(start, end));\n            pos = end + closeLen;\n        }\n        if (list.isEmpty()) {\n            return null;\n        } \n        return list.toArray(new String [list.size()]);\n    }\n\n    \n    \n\n    \n    \n    \n    public static String[] split(String str) {\n        return split(str, null, -1);\n    }\n\n    \n    public static String[] split(String str, char separatorChar) {\n        return splitWorker(str, separatorChar, false);\n    }\n\n    \n    public static String[] split(String str, String separatorChars) {\n        return splitWorker(str, separatorChars, -1, false);\n    }\n\n    \n    public static String[] split(String str, String separatorChars, int max) {\n        return splitWorker(str, separatorChars, max, false);\n    }\n\n    \n    public static String[] splitByWholeSeparator(String str, String separator) {\n        return splitByWholeSeparatorWorker( str, separator, -1, false ) ;\n    }\n\n    \n    public static String[] splitByWholeSeparator( String str, String separator, int max ) {\n        return splitByWholeSeparatorWorker(str, separator, max, false);\n    }\n\n    \n    public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) {\n        return splitByWholeSeparatorWorker(str, separator, -1, true);\n    }\n\n    \n    public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) {\n        return splitByWholeSeparatorWorker(str, separator, max, true);\n    }\n\n    \n    private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\n        if ((separator == null) || (EMPTY.equals(separator))) {\n            \n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        int separatorLength = separator.length();\n\n        ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        \n                        \n                        substrings.add(str.substring(beg, end));\n\n                        \n                        \n                        \n                        beg = end + separatorLength;\n                    }\n                } else {\n                    \n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                \n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }\n\n    \n    \n    public static String[] splitPreserveAllTokens(String str) {\n        return splitWorker(str, null, -1, true);\n    }\n\n    \n    public static String[] splitPreserveAllTokens(String str, char separatorChar) {\n        return splitWorker(str, separatorChar, true);\n    }\n\n    \n    private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) {\n        \n\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        List<String> list = new ArrayList<String>();\n        int i = 0, start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        while (i < len) {\n            if (str.charAt(i) == separatorChar) {\n                if (match || preserveAllTokens) {\n                    list.add(str.substring(start, i));\n                    match = false;\n                    lastMatch = true;\n                }\n                start = ++i;\n                continue;\n            }\n            lastMatch = false;\n            match = true;\n            i++;\n        }\n        if (match || (preserveAllTokens && lastMatch)) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[list.size()]);\n    }\n\n    \n    public static String[] splitPreserveAllTokens(String str, String separatorChars) {\n        return splitWorker(str, separatorChars, -1, true);\n    }\n\n    \n    public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {\n        return splitWorker(str, separatorChars, max, true);\n    }\n\n    \n    private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {\n        \n        \n        \n\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        List<String> list = new ArrayList<String>();\n        int sizePlus1 = 1;\n        int i = 0, start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        if (separatorChars == null) {\n            \n            while (i < len) {\n                if (Character.isWhitespace(str.charAt(i))) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else if (separatorChars.length() == 1) {\n            \n            char sep = separatorChars.charAt(0);\n            while (i < len) {\n                if (str.charAt(i) == sep) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else {\n            \n            while (i < len) {\n                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        }\n        if (match || (preserveAllTokens && lastMatch)) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[list.size()]);\n    }\n\n    \n    public static String[] splitByCharacterType(String str) {\n        return splitByCharacterType(str, false);\n    }\n\n    \n    public static String[] splitByCharacterTypeCamelCase(String str) {\n        return splitByCharacterType(str, true);\n    }\n\n    \n    private static String[] splitByCharacterType(String str, boolean camelCase) {\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        char[] c = str.toCharArray();\n        List<String> list = new ArrayList<String>();\n        int tokenStart = 0;\n        int currentType = Character.getType(c[tokenStart]);\n        for (int pos = tokenStart + 1; pos < c.length; pos++) {\n            int type = Character.getType(c[pos]);\n            if (type == currentType) {\n                continue;\n            }\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                int newTokenStart = pos - 1;\n                if (newTokenStart != tokenStart) {\n                    list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                    tokenStart = newTokenStart;\n                }\n            } else {\n                list.add(new String(c, tokenStart, pos - tokenStart));\n                tokenStart = pos;\n            }\n            currentType = type;\n        }\n        list.add(new String(c, tokenStart, c.length - tokenStart));\n        return list.toArray(new String[list.size()]);\n    }\n\n    \n    \n    \n    public static String join(Object[] array) {\n        return join(array, null);\n    }\n\n    \n    public static String join(Object[] array, char separator) {\n        if (array == null) {\n            return null;\n        }\n\n        return join(array, separator, 0, array.length);\n    }\n\n    \n    public static String join(Object[] array, char separator, int startIndex, int endIndex) {\n        if (array == null) {\n            return null;\n        }\n        int bufSize = (endIndex - startIndex);\n        if (bufSize <= 0) {\n            return EMPTY;\n        }\n\n        bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n        StringBuilder buf = new StringBuilder(bufSize);\n\n        for (int i = startIndex; i < endIndex; i++) {\n            if (i > startIndex) {\n                buf.append(separator);\n            }\n            if (array[i] != null) {\n                buf.append(array[i]);\n            }\n        }\n        return buf.toString();\n    }\n\n\n    \n    public static String join(Object[] array, String separator) {\n        if (array == null) {\n            return null;\n        }\n        return join(array, separator, 0, array.length);\n    }\n\n    \n    public static String join(Object[] array, String separator, int startIndex, int endIndex) {\n        if (array == null) {\n            return null;\n        }\n        if (separator == null) {\n            separator = EMPTY;\n        }\n\n        \n        \n        int bufSize = (endIndex - startIndex);\n        if (bufSize <= 0) {\n            return EMPTY;\n        }\n\n        bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length())\n                        + separator.length());\n\n        StringBuilder buf = new StringBuilder(bufSize);\n\n        for (int i = startIndex; i < endIndex; i++) {\n            if (i > startIndex) {\n                buf.append(separator);\n            }\n            if (array[i] != null) {\n                buf.append(array[i]);\n            }\n        }\n        return buf.toString();\n    }\n\n    \n    public static String join(Iterator<?> iterator, char separator) {\n\n        \n        if (iterator == null) {\n            return null;\n        }\n        if (!iterator.hasNext()) {\n            return EMPTY;\n        }\n        Object first = iterator.next();\n        if (!iterator.hasNext()) {\n            return ObjectUtils.toString(first);\n        }\n\n        \n        StringBuilder buf = new StringBuilder(256); \n        if (first != null) {\n            buf.append(first);\n        }\n\n        while (iterator.hasNext()) {\n            buf.append(separator);\n            Object obj = iterator.next();\n            if (obj != null) {\n                buf.append(obj);\n            }\n        }\n\n        return buf.toString();\n    }\n\n    \n    public static String join(Iterator<?> iterator, String separator) {\n\n        \n        if (iterator == null) {\n            return null;\n        }\n        if (!iterator.hasNext()) {\n            return EMPTY;\n        }\n        Object first = iterator.next();\n        if (!iterator.hasNext()) {\n            return ObjectUtils.toString(first);\n        }\n\n        \n        StringBuilder buf = new StringBuilder(256); \n        if (first != null) {\n            buf.append(first);\n        }\n\n        while (iterator.hasNext()) {\n            if (separator != null) {\n                buf.append(separator);\n            }\n            Object obj = iterator.next();\n            if (obj != null) {\n                buf.append(obj);\n            }\n        }\n        return buf.toString();\n    }\n\n    \n    public static String join(Iterable<?> iterable, char separator) {\n        if (iterable == null) {\n            return null;\n        }\n        return join(iterable.iterator(), separator);\n    }\n\n    \n    public static String join(Iterable<?> iterable, String separator) {\n        if (iterable == null) {\n            return null;\n        }\n        return join(iterable.iterator(), separator);\n    }\n\n    \n    \n    \n    public static String deleteWhitespace(String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        int sz = str.length();\n        char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }\n\n    \n    \n    \n    public static String removeStart(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (str.startsWith(remove)){\n            return str.substring(remove.length());\n        }\n        return str;\n    }\n\n    \n    public static String removeStartIgnoreCase(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (startsWithIgnoreCase(str, remove)) {\n            return str.substring(remove.length());\n        }\n        return str;\n    }\n\n    \n    public static String removeEnd(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (str.endsWith(remove)) {\n            return str.substring(0, str.length() - remove.length());\n        }\n        return str;\n    }\n\n    \n    public static String removeEndIgnoreCase(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (endsWithIgnoreCase(str, remove)) {\n            return str.substring(0, str.length() - remove.length());\n        }\n        return str;\n    }\n\n    \n    public static String remove(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        return replace(str, remove, EMPTY, -1);\n    }\n\n    \n    public static String remove(String str, char remove) {\n        if (isEmpty(str) || str.indexOf(remove) == -1) {\n            return str;\n        }\n        char[] chars = str.toCharArray();\n        int pos = 0;\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] != remove) {\n                chars[pos++] = chars[i];\n            }\n        }\n        return new String(chars, 0, pos);\n    }\n\n    \n    \n    \n    public static String replaceOnce(String text, String searchString, String replacement) {\n        return replace(text, searchString, replacement, 1);\n    }\n\n    \n    public static String replace(String text, String searchString, String replacement) {\n        return replace(text, searchString, replacement, -1);\n    }\n\n    \n    public static String replace(String text, String searchString, String replacement, int max) {\n        if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {\n            return text;\n        }\n        int start = 0;\n        int end = text.indexOf(searchString, start);\n        if (end == -1) {\n            return text;\n        }\n        int replLength = searchString.length();\n        int increase = replacement.length() - replLength;\n        increase = (increase < 0 ? 0 : increase);\n        increase *= (max < 0 ? 16 : (max > 64 ? 64 : max));\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n        while (end != -1) {\n            buf.append(text.substring(start, end)).append(replacement);\n            start = end + replLength;\n            if (--max == 0) {\n                break;\n            }\n            end = text.indexOf(searchString, start);\n        }\n        buf.append(text.substring(start));\n        return buf.toString();\n    }\n\n    \n    public static String replaceEach(String text, String[] searchList, String[] replacementList) {\n        return replaceEach(text, searchList, replacementList, false, 0);\n    }\n\n    \n    public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {\n        \n        \n        int timeToLive = searchList == null ? 0 : searchList.length;\n        return replaceEach(text, searchList, replacementList, true, timeToLive);\n    }\n\n    \n    private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n\n        \n        \n\n        if (text == null || text.length() == 0 || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        \n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        \n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        \n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        \n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        \n        \n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            \n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        \n\n        \n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n\n        \n        int increase = 0;\n\n        \n        for (int i = 0; i < searchList.length; i++) {\n            if (searchList[i] == null || replacementList[i] == null) {\n                continue;\n            }\n            int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater; \n            }\n        }\n        \n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n            \n            \n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].length() == 0 || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                \n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n            \n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n\n    \n    \n    \n    public static String replaceChars(String str, char searchChar, char replaceChar) {\n        if (str == null) {\n            return null;\n        }\n        return str.replace(searchChar, replaceChar);\n    }\n\n    \n    public static String replaceChars(String str, String searchChars, String replaceChars) {\n        if (isEmpty(str) || isEmpty(searchChars)) {\n            return str;\n        }\n        if (replaceChars == null) {\n            replaceChars = EMPTY;\n        }\n        boolean modified = false;\n        int replaceCharsLength = replaceChars.length();\n        int strLength = str.length();\n        StringBuilder buf = new StringBuilder(strLength);\n        for (int i = 0; i < strLength; i++) {\n            char ch = str.charAt(i);\n            int index = searchChars.indexOf(ch);\n            if (index >= 0) {\n                modified = true;\n                if (index < replaceCharsLength) {\n                    buf.append(replaceChars.charAt(index));\n                }\n            } else {\n                buf.append(ch);\n            }\n        }\n        if (modified) {\n            return buf.toString();\n        }\n        return str;\n    }\n\n    \n    \n    \n    public static String overlay(String str, String overlay, int start, int end) {\n        if (str == null) {\n            return null;\n        }\n        if (overlay == null) {\n            overlay = EMPTY;\n        }\n        int len = str.length();\n        if (start < 0) {\n            start = 0;\n        }\n        if (start > len) {\n            start = len;\n        }\n        if (end < 0) {\n            end = 0;\n        }\n        if (end > len) {\n            end = len;\n        }\n        if (start > end) {\n            int temp = start;\n            start = end;\n            end = temp;\n        }\n        return new StringBuilder(len + start - end + overlay.length() + 1)\n            .append(str.substring(0, start))\n            .append(overlay)\n            .append(str.substring(end))\n            .toString();\n    }\n\n    \n    \n    \n    public static String chomp(String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n\n        if (str.length() == 1) {\n            char ch = str.charAt(0);\n            if (ch == CharUtils.CR || ch == CharUtils.LF) {\n                return EMPTY;\n            }\n            return str;\n        }\n\n        int lastIdx = str.length() - 1;\n        char last = str.charAt(lastIdx);\n\n        if (last == CharUtils.LF) {\n            if (str.charAt(lastIdx - 1) == CharUtils.CR) {\n                lastIdx--;\n            }\n        } else if (last != CharUtils.CR) {\n            lastIdx++;\n        }\n        return str.substring(0, lastIdx);\n    }\n\n    \n    public static String chomp(String str, String separator) {\n        if (isEmpty(str) || separator == null) {\n            return str;\n        }\n        if (str.endsWith(separator)) {\n            return str.substring(0, str.length() - separator.length());\n        }\n        return str;\n    }\n\n    \n    \n    \n    public static String chop(String str) {\n        if (str == null) {\n            return null;\n        }\n        int strLen = str.length();\n        if (strLen < 2) {\n            return EMPTY;\n        }\n        int lastIdx = strLen - 1;\n        String ret = str.substring(0, lastIdx);\n        char last = str.charAt(lastIdx);\n        if (last == CharUtils.LF) {\n            if (ret.charAt(lastIdx - 1) == CharUtils.CR) {\n                return ret.substring(0, lastIdx - 1);\n            }\n        }\n        return ret;\n    }\n\n    \n    \n\n    \n    \n    \n    public static String repeat(String str, int repeat) {\n        \n\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return padding(repeat, str.charAt(0));\n        }\n\n        int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                char ch = str.charAt(0);\n                char[] output1 = new char[outputLength];\n                for (int i = repeat - 1; i >= 0; i--) {\n                    output1[i] = ch;\n                }\n                return new String(output1);\n            case 2 :\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }\n\n    \n    public static String repeat(String str, String separator, int repeat) {\n        if(str == null || separator == null) {\n            return repeat(str, repeat);\n        } else {\n            \n            String result = repeat(str + separator, repeat);\n            return removeEnd(result, separator);\n        }\n    }\n\n    \n    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        final char[] buf = new char[repeat];\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = padChar;\n        }\n        return new String(buf);\n    }\n\n    \n    public static String rightPad(String str, int size) {\n        return rightPad(str, size, ' ');\n    }\n\n    \n    public static String rightPad(String str, int size, char padChar) {\n        if (str == null) {\n            return null;\n        }\n        int pads = size - str.length();\n        if (pads <= 0) {\n            return str; \n        }\n        if (pads > PAD_LIMIT) {\n            return rightPad(str, size, String.valueOf(padChar));\n        }\n        return str.concat(padding(pads, padChar));\n    }\n\n    \n    public static String rightPad(String str, int size, String padStr) {\n        if (str == null) {\n            return null;\n        }\n        if (isEmpty(padStr)) {\n            padStr = \" \";\n        }\n        int padLen = padStr.length();\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str; \n        }\n        if (padLen == 1 && pads <= PAD_LIMIT) {\n            return rightPad(str, size, padStr.charAt(0));\n        }\n\n        if (pads == padLen) {\n            return str.concat(padStr);\n        } else if (pads < padLen) {\n            return str.concat(padStr.substring(0, pads));\n        } else {\n            char[] padding = new char[pads];\n            char[] padChars = padStr.toCharArray();\n            for (int i = 0; i < pads; i++) {\n                padding[i] = padChars[i % padLen];\n            }\n            return str.concat(new String(padding));\n        }\n    }\n\n    \n    public static String leftPad(String str, int size) {\n        return leftPad(str, size, ' ');\n    }\n\n    \n    public static String leftPad(String str, int size, char padChar) {\n        if (str == null) {\n            return null;\n        }\n        int pads = size - str.length();\n        if (pads <= 0) {\n            return str; \n        }\n        if (pads > PAD_LIMIT) {\n            return leftPad(str, size, String.valueOf(padChar));\n        }\n        return padding(pads, padChar).concat(str);\n    }\n\n    \n    public static String leftPad(String str, int size, String padStr) {\n        if (str == null) {\n            return null;\n        }\n        if (isEmpty(padStr)) {\n            padStr = \" \";\n        }\n        int padLen = padStr.length();\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str; \n        }\n        if (padLen == 1 && pads <= PAD_LIMIT) {\n            return leftPad(str, size, padStr.charAt(0));\n        }\n\n        if (pads == padLen) {\n            return padStr.concat(str);\n        } else if (pads < padLen) {\n            return padStr.substring(0, pads).concat(str);\n        } else {\n            char[] padding = new char[pads];\n            char[] padChars = padStr.toCharArray();\n            for (int i = 0; i < pads; i++) {\n                padding[i] = padChars[i % padLen];\n            }\n            return new String(padding).concat(str);\n        }\n    }\n\n    \n    public static int length(String str) {\n        return str == null ? 0 : str.length();\n    }\n    \n    \n    \n    \n    public static String center(String str, int size) {\n        return center(str, size, ' ');\n    }\n\n    \n    public static String center(String str, int size, char padChar) {\n        if (str == null || size <= 0) {\n            return str;\n        }\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str;\n        }\n        str = leftPad(str, strLen + pads / 2, padChar);\n        str = rightPad(str, size, padChar);\n        return str;\n    }\n\n    \n    public static String center(String str, int size, String padStr) {\n        if (str == null || size <= 0) {\n            return str;\n        }\n        if (isEmpty(padStr)) {\n            padStr = \" \";\n        }\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str;\n        }\n        str = leftPad(str, strLen + pads / 2, padStr);\n        str = rightPad(str, size, padStr);\n        return str;\n    }\n\n    \n    \n    \n    public static String upperCase(String str) {\n        if (str == null) {\n            return null;\n        }\n        return str.toUpperCase();\n    }\n\n    \n    public static String upperCase(String str, Locale locale) {\n        if (str == null) {\n            return null;\n        }\n        return str.toUpperCase(locale);\n    }\n\n    \n    public static String lowerCase(String str) {\n        if (str == null) {\n            return null;\n        }\n        return str.toLowerCase();\n    }\n\n    \n    public static String lowerCase(String str, Locale locale) {\n        if (str == null) {\n            return null;\n        }\n        return str.toLowerCase(locale);\n    }\n\n    \n    public static String capitalize(String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        return new StringBuilder(strLen)\n            .append(Character.toTitleCase(str.charAt(0)))\n            .append(str.substring(1))\n            .toString();\n    }\n\n    \n    public static String uncapitalize(String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        return new StringBuilder(strLen)\n            .append(Character.toLowerCase(str.charAt(0)))\n            .append(str.substring(1))\n            .toString();\n    }\n\n    \n    public static String swapCase(String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        StringBuilder buffer = new StringBuilder(strLen);\n\n        char ch = 0;\n        for (int i = 0; i < strLen; i++) {\n            ch = str.charAt(i);\n            if (Character.isUpperCase(ch)) {\n                ch = Character.toLowerCase(ch);\n            } else if (Character.isTitleCase(ch)) {\n                ch = Character.toLowerCase(ch);\n            } else if (Character.isLowerCase(ch)) {\n                ch = Character.toUpperCase(ch);\n            }\n            buffer.append(ch);\n        }\n        return buffer.toString();\n    }\n\n    \n    \n    \n    public static int countMatches(String str, String sub) {\n        if (isEmpty(str) || isEmpty(sub)) {\n            return 0;\n        }\n        int count = 0;\n        int idx = 0;\n        while ((idx = str.indexOf(sub, idx)) != -1) {\n            count++;\n            idx += sub.length();\n        }\n        return count;\n    }\n\n    \n    \n    \n    public static boolean isAlpha(String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isLetter(str.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAlphaSpace(String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isLetter(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAlphanumeric(String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isLetterOrDigit(str.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAlphanumericSpace(String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isLetterOrDigit(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAsciiPrintable(String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (CharUtils.isAsciiPrintable(str.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isNumeric(String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isDigit(str.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isNumericSpace(String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isDigit(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isWhitespace(String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isWhitespace(str.charAt(i)) == false)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAllLowerCase(String str) {\n        if (str == null || isEmpty(str)) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isLowerCase(str.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isAllUpperCase(String str) {\n        if (str == null || isEmpty(str)) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isUpperCase(str.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    \n    \n    public static String defaultString(String str) {\n        return str == null ? EMPTY : str;\n    }\n\n    \n    public static String defaultString(String str, String defaultStr) {\n        return str == null ? defaultStr : str;\n    }\n\n    \n    public static String defaultIfEmpty(String str, String defaultStr) {\n        return StringUtils.isEmpty(str) ? defaultStr : str;\n    }\n\n    \n    \n    \n    public static String reverse(String str) {\n        if (str == null) {\n            return null;\n        }\n        return new StringBuilder(str).reverse().toString();\n    }\n\n    \n    public static String reverseDelimited(String str, char separatorChar) {\n        if (str == null) {\n            return null;\n        }\n        \n        \n        String[] strs = split(str, separatorChar);\n        ArrayUtils.reverse(strs);\n        return join(strs, separatorChar);\n    }\n\n    \n    \n    \n    public static String abbreviate(String str, int maxWidth) {\n        return abbreviate(str, 0, maxWidth);\n    }\n\n    \n    public static String abbreviate(String str, int offset, int maxWidth) {\n        if (str == null) {\n            return null;\n        }\n        if (maxWidth < 4) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n        }\n        if (str.length() <= maxWidth) {\n            return str;\n        }\n        if (offset > str.length()) {\n            offset = str.length();\n        }\n        if ((str.length() - offset) < (maxWidth - 3)) {\n            offset = str.length() - (maxWidth - 3);\n        }\n        if (offset <= 4) {\n            return str.substring(0, maxWidth - 3) + \"...\";\n        }\n        if (maxWidth < 7) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n        }\n        if ((offset + (maxWidth - 3)) < str.length()) {\n            return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n        }\n        return \"...\" + str.substring(str.length() - (maxWidth - 3));\n    }\n\n    \n    \n    \n    public static String difference(String str1, String str2) {\n        if (str1 == null) {\n            return str2;\n        }\n        if (str2 == null) {\n            return str1;\n        }\n        int at = indexOfDifference(str1, str2);\n        if (at == -1) {\n            return EMPTY;\n        }\n        return str2.substring(at);\n    }\n\n    \n    public static int indexOfDifference(String str1, String str2) {\n        if (str1 == str2) {\n            return -1;\n        }\n        if (str1 == null || str2 == null) {\n            return 0;\n        }\n        int i;\n        for (i = 0; i < str1.length() && i < str2.length(); ++i) {\n            if (str1.charAt(i) != str2.charAt(i)) {\n                break;\n            }\n        }\n        if (i < str2.length() || i < str1.length()) {\n            return i;\n        }\n        return -1;\n    }\n\n    \n    public static int indexOfDifference(String[] strs) {\n        if (strs == null || strs.length <= 1) {\n            return -1;\n        }\n        boolean anyStringNull = false;\n        boolean allStringsNull = true;\n        int arrayLen = strs.length;\n        int shortestStrLen = Integer.MAX_VALUE;\n        int longestStrLen = 0;\n\n        \n        \n        \n        for (int i = 0; i < arrayLen; i++) {\n            if (strs[i] == null) {\n                anyStringNull = true;\n                shortestStrLen = 0;\n            } else {\n                allStringsNull = false;\n                shortestStrLen = Math.min(strs[i].length(), shortestStrLen);\n                longestStrLen = Math.max(strs[i].length(), longestStrLen);\n            }\n        }\n\n        \n        if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) {\n            return -1;\n        }\n\n        \n        if (shortestStrLen == 0) {\n            return 0;\n        }\n\n        \n        int firstDiff = -1;\n        for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {\n            char comparisonChar = strs[0].charAt(stringPos);\n            for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {\n                if (strs[arrayPos].charAt(stringPos) != comparisonChar) {\n                    firstDiff = stringPos;\n                    break;\n                }\n            }\n            if (firstDiff != -1) {\n                break;\n            }\n        }\n\n        if (firstDiff == -1 && shortestStrLen != longestStrLen) {\n            \n            \n            \n            return shortestStrLen;\n        }\n        return firstDiff;\n    }\n    \n    \n    public static String getCommonPrefix(String[] strs) {\n        if (strs == null || strs.length == 0) {\n            return EMPTY;\n        }\n        int smallestIndexOfDiff = indexOfDifference(strs);\n        if (smallestIndexOfDiff == -1) {\n            \n            if (strs[0] == null) {\n                return EMPTY;\n            }\n            return strs[0];\n        } else if (smallestIndexOfDiff == 0) {\n            \n            return EMPTY;\n        } else {\n            \n            return strs[0].substring(0, smallestIndexOfDiff);\n        }\n    }  \n    \n    \n    \n    \n    public static int getLevenshteinDistance(String s, String t) {\n        if (s == null || t == null) {\n            throw new IllegalArgumentException(\"Strings must not be null\");\n        }\n\n        \n\n        int n = s.length(); \n        int m = t.length(); \n\n        if (n == 0) {\n            return m;\n        } else if (m == 0) {\n            return n;\n        }\n\n        if (n > m) {\n            \n            String tmp = s;\n            s = t;\n            t = tmp;\n            n = m;\n            m = t.length();\n        }\n\n        int p[] = new int[n+1]; \n        int d[] = new int[n+1]; \n        int _d[]; \n\n        \n        int i; \n        int j; \n\n        char t_j; \n\n        int cost; \n\n        for (i = 0; i<=n; i++) {\n            p[i] = i;\n        }\n\n        for (j = 1; j<=m; j++) {\n            t_j = t.charAt(j-1);\n            d[0] = j;\n\n            for (i=1; i<=n; i++) {\n                cost = s.charAt(i-1)==t_j ? 0 : 1;\n                \n                d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]+cost);\n            }\n\n            \n            _d = p;\n            p = d;\n            d = _d;\n        }\n\n        \n        \n        return p[n];\n    }\n\n    \n\n\n    \n    \n\n    \n    public static boolean startsWith(String str, String prefix) {\n        return startsWith(str, prefix, false);\n    }\n\n    \n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        return startsWith(str, prefix, true);\n    }\n\n    \n    private static boolean startsWith(String str, String prefix, boolean ignoreCase) {\n        if (str == null || prefix == null) {\n            return (str == null && prefix == null);\n        }\n        if (prefix.length() > str.length()) {\n            return false;\n        }\n        return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());\n    }\n    \n    \n    public static boolean startsWithAny(String string, String[] searchStrings) {\n        if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {\n            return false;\n        }\n        for (int i = 0; i < searchStrings.length; i++) {\n            String searchString = searchStrings[i];\n            if (StringUtils.startsWith(string, searchString)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    \n\n    \n    public static boolean endsWith(String str, String suffix) {\n        return endsWith(str, suffix, false);\n    }\n\n    \n    public static boolean endsWithIgnoreCase(String str, String suffix) {\n        return endsWith(str, suffix, true);\n    }\n\n    \n    private static boolean endsWith(String str, String suffix, boolean ignoreCase) {\n        if (str == null || suffix == null) {\n            return (str == null && suffix == null);\n        }\n        if (suffix.length() > str.length()) {\n            return false;\n        }\n        int strOffset = str.length() - suffix.length();\n        return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());\n    }\n\n}\n",
      "buggy_signatures": [
        "public static boolean isEmpty(CharSequence str)",
        "public static boolean isNotEmpty(CharSequence str)",
        "public static boolean isBlank(CharSequence str)",
        "public static boolean isNotBlank(CharSequence str)",
        "public static String trim(String str)",
        "public static String trimToNull(String str)",
        "public static String trimToEmpty(String str)",
        "public static String strip(String str)",
        "public static String stripToNull(String str)",
        "public static String stripToEmpty(String str)",
        "public static String strip(String str, String stripChars)",
        "public static String stripStart(String str, String stripChars)",
        "public static String stripEnd(String str, String stripChars)",
        "public static String[] stripAll(String[] strs)",
        "public static String[] stripAll(String[] strs, String stripChars)",
        "public static String stripAccents(String input)",
        "public static boolean equals(String str1, String str2)",
        "public static boolean equalsIgnoreCase(String str1, String str2)",
        "public static int indexOf(String str, char searchChar)",
        "public static int indexOf(String str, char searchChar, int startPos)",
        "public static int indexOf(String str, String searchStr)",
        "public static int ordinalIndexOf(String str, String searchStr, int ordinal)",
        "public static int indexOf(String str, String searchStr, int startPos)",
        "public static int lastIndexOf(String str, char searchChar)",
        "public static int lastIndexOf(String str, char searchChar, int startPos)",
        "public static int lastIndexOf(String str, String searchStr)",
        "public static int lastIndexOf(String str, String searchStr, int startPos)",
        "public static boolean contains(String str, char searchChar)",
        "public static boolean contains(String str, String searchStr)",
        "public static boolean containsIgnoreCase(String str, String searchStr)",
        "public static int indexOfAny(String str, char[] searchChars)",
        "public static int indexOfAny(String str, String searchChars)",
        "public static boolean containsAny(String str, char[] searchChars)",
        "public static boolean containsAny(String str, String searchChars)",
        "public static int indexOfAnyBut(String str, char[] searchChars)",
        "public static int indexOfAnyBut(String str, String searchChars)",
        "public static boolean containsOnly(String str, char[] valid)",
        "public static boolean containsOnly(String str, String validChars)",
        "public static boolean containsNone(String str, char[] invalidChars)",
        "public static boolean containsNone(String str, String invalidChars)",
        "public static int indexOfAny(String str, String[] searchStrs)",
        "public static int lastIndexOfAny(String str, String[] searchStrs)",
        "public static String substring(String str, int start)",
        "public static String substring(String str, int start, int end)",
        "public static String left(String str, int len)",
        "public static String right(String str, int len)",
        "public static String mid(String str, int pos, int len)",
        "public static String substringBefore(String str, String separator)",
        "public static String substringAfter(String str, String separator)",
        "public static String substringBeforeLast(String str, String separator)",
        "public static String substringAfterLast(String str, String separator)",
        "public static String substringBetween(String str, String tag)",
        "public static String substringBetween(String str, String open, String close)",
        "public static String[] substringsBetween(String str, String open, String close)",
        "public static String[] split(String str)",
        "public static String[] split(String str, char separatorChar)",
        "public static String[] split(String str, String separatorChars)",
        "public static String[] split(String str, String separatorChars, int max)",
        "public static String[] splitByWholeSeparator(String str, String separator)",
        "public static String[] splitByWholeSeparator( String str, String separator, int max )",
        "public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator)",
        "public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max)",
        "private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens)",
        "public static String[] splitPreserveAllTokens(String str)",
        "public static String[] splitPreserveAllTokens(String str, char separatorChar)",
        "private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens)",
        "public static String[] splitPreserveAllTokens(String str, String separatorChars)",
        "public static String[] splitPreserveAllTokens(String str, String separatorChars, int max)",
        "private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens)",
        "public static String[] splitByCharacterType(String str)",
        "public static String[] splitByCharacterTypeCamelCase(String str)",
        "private static String[] splitByCharacterType(String str, boolean camelCase)",
        "public static String join(Object[] array)",
        "public static String join(Object[] array, char separator)",
        "public static String join(Object[] array, char separator, int startIndex, int endIndex)",
        "public static String join(Object[] array, String separator)",
        "public static String join(Object[] array, String separator, int startIndex, int endIndex)",
        "public static String join(Iterator<?> iterator, char separator)",
        "public static String join(Iterator<?> iterator, String separator)",
        "public static String join(Iterable<?> iterable, char separator)",
        "public static String join(Iterable<?> iterable, String separator)",
        "public static String deleteWhitespace(String str)",
        "public static String removeStart(String str, String remove)",
        "public static String removeStartIgnoreCase(String str, String remove)",
        "public static String removeEnd(String str, String remove)",
        "public static String removeEndIgnoreCase(String str, String remove)",
        "public static String remove(String str, String remove)",
        "public static String remove(String str, char remove)",
        "public static String replaceOnce(String text, String searchString, String replacement)",
        "public static String replace(String text, String searchString, String replacement)",
        "public static String replace(String text, String searchString, String replacement, int max)",
        "public static String replaceEach(String text, String[] searchList, String[] replacementList)",
        "public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList)",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive)",
        "public static String replaceChars(String str, char searchChar, char replaceChar)",
        "public static String replaceChars(String str, String searchChars, String replaceChars)",
        "public static String overlay(String str, String overlay, int start, int end)",
        "public static String chomp(String str)",
        "public static String chomp(String str, String separator)",
        "public static String chop(String str)",
        "public static String repeat(String str, int repeat)",
        "public static String repeat(String str, String separator, int repeat)",
        "private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException",
        "public static String rightPad(String str, int size)",
        "public static String rightPad(String str, int size, char padChar)",
        "public static String rightPad(String str, int size, String padStr)",
        "public static String leftPad(String str, int size)",
        "public static String leftPad(String str, int size, char padChar)",
        "public static String leftPad(String str, int size, String padStr)",
        "public static int length(String str)",
        "public static String center(String str, int size)",
        "public static String center(String str, int size, char padChar)",
        "public static String center(String str, int size, String padStr)",
        "public static String upperCase(String str)",
        "public static String upperCase(String str, Locale locale)",
        "public static String lowerCase(String str)",
        "public static String lowerCase(String str, Locale locale)",
        "public static String capitalize(String str)",
        "public static String uncapitalize(String str)",
        "public static String swapCase(String str)",
        "public static int countMatches(String str, String sub)",
        "public static boolean isAlpha(String str)",
        "public static boolean isAlphaSpace(String str)",
        "public static boolean isAlphanumeric(String str)",
        "public static boolean isAlphanumericSpace(String str)",
        "public static boolean isAsciiPrintable(String str)",
        "public static boolean isNumeric(String str)",
        "public static boolean isNumericSpace(String str)",
        "public static boolean isWhitespace(String str)",
        "public static boolean isAllLowerCase(String str)",
        "public static boolean isAllUpperCase(String str)",
        "public static String defaultString(String str)",
        "public static String defaultString(String str, String defaultStr)",
        "public static String defaultIfEmpty(String str, String defaultStr)",
        "public static String reverse(String str)",
        "public static String reverseDelimited(String str, char separatorChar)",
        "public static String abbreviate(String str, int maxWidth)",
        "public static String abbreviate(String str, int offset, int maxWidth)",
        "public static String difference(String str1, String str2)",
        "public static int indexOfDifference(String str1, String str2)",
        "public static int indexOfDifference(String[] strs)",
        "public static String getCommonPrefix(String[] strs)",
        "public static int getLevenshteinDistance(String s, String t)",
        "public static boolean startsWith(String str, String prefix)",
        "public static boolean startsWithIgnoreCase(String str, String prefix)",
        "private static boolean startsWith(String str, String prefix, boolean ignoreCase)",
        "public static boolean startsWithAny(String string, String[] searchStrings)",
        "public static boolean endsWith(String str, String suffix)",
        "public static boolean endsWithIgnoreCase(String str, String suffix)",
        "private static boolean endsWith(String str, String suffix, boolean ignoreCase)"
      ],
      "fixed_signatures": [
        "public static boolean isEmpty(CharSequence str)",
        "public static boolean isNotEmpty(CharSequence str)",
        "public static boolean isBlank(CharSequence str)",
        "public static boolean isNotBlank(CharSequence str)",
        "public static String trim(String str)",
        "public static String trimToNull(String str)",
        "public static String trimToEmpty(String str)",
        "public static String strip(String str)",
        "public static String stripToNull(String str)",
        "public static String stripToEmpty(String str)",
        "public static String strip(String str, String stripChars)",
        "public static String stripStart(String str, String stripChars)",
        "public static String stripEnd(String str, String stripChars)",
        "public static String[] stripAll(String[] strs)",
        "public static String[] stripAll(String[] strs, String stripChars)",
        "public static String stripAccents(String input)",
        "public static boolean equals(String str1, String str2)",
        "public static boolean equalsIgnoreCase(String str1, String str2)",
        "public static int indexOf(String str, char searchChar)",
        "public static int indexOf(String str, char searchChar, int startPos)",
        "public static int indexOf(String str, String searchStr)",
        "public static int ordinalIndexOf(String str, String searchStr, int ordinal)",
        "public static int indexOf(String str, String searchStr, int startPos)",
        "public static int lastIndexOf(String str, char searchChar)",
        "public static int lastIndexOf(String str, char searchChar, int startPos)",
        "public static int lastIndexOf(String str, String searchStr)",
        "public static int lastIndexOf(String str, String searchStr, int startPos)",
        "public static boolean contains(String str, char searchChar)",
        "public static boolean contains(String str, String searchStr)",
        "public static boolean containsIgnoreCase(String str, String searchStr)",
        "public static int indexOfAny(String str, char[] searchChars)",
        "public static int indexOfAny(String str, String searchChars)",
        "public static boolean containsAny(String str, char[] searchChars)",
        "public static boolean containsAny(String str, String searchChars)",
        "public static int indexOfAnyBut(String str, char[] searchChars)",
        "public static int indexOfAnyBut(String str, String searchChars)",
        "public static boolean containsOnly(String str, char[] valid)",
        "public static boolean containsOnly(String str, String validChars)",
        "public static boolean containsNone(String str, char[] invalidChars)",
        "public static boolean containsNone(String str, String invalidChars)",
        "public static int indexOfAny(String str, String[] searchStrs)",
        "public static int lastIndexOfAny(String str, String[] searchStrs)",
        "public static String substring(String str, int start)",
        "public static String substring(String str, int start, int end)",
        "public static String left(String str, int len)",
        "public static String right(String str, int len)",
        "public static String mid(String str, int pos, int len)",
        "public static String substringBefore(String str, String separator)",
        "public static String substringAfter(String str, String separator)",
        "public static String substringBeforeLast(String str, String separator)",
        "public static String substringAfterLast(String str, String separator)",
        "public static String substringBetween(String str, String tag)",
        "public static String substringBetween(String str, String open, String close)",
        "public static String[] substringsBetween(String str, String open, String close)",
        "public static String[] split(String str)",
        "public static String[] split(String str, char separatorChar)",
        "public static String[] split(String str, String separatorChars)",
        "public static String[] split(String str, String separatorChars, int max)",
        "public static String[] splitByWholeSeparator(String str, String separator)",
        "public static String[] splitByWholeSeparator( String str, String separator, int max )",
        "public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator)",
        "public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max)",
        "private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens)",
        "public static String[] splitPreserveAllTokens(String str)",
        "public static String[] splitPreserveAllTokens(String str, char separatorChar)",
        "private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens)",
        "public static String[] splitPreserveAllTokens(String str, String separatorChars)",
        "public static String[] splitPreserveAllTokens(String str, String separatorChars, int max)",
        "private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens)",
        "public static String[] splitByCharacterType(String str)",
        "public static String[] splitByCharacterTypeCamelCase(String str)",
        "private static String[] splitByCharacterType(String str, boolean camelCase)",
        "public static String join(Object[] array)",
        "public static String join(Object[] array, char separator)",
        "public static String join(Object[] array, char separator, int startIndex, int endIndex)",
        "public static String join(Object[] array, String separator)",
        "public static String join(Object[] array, String separator, int startIndex, int endIndex)",
        "public static String join(Iterator<?> iterator, char separator)",
        "public static String join(Iterator<?> iterator, String separator)",
        "public static String join(Iterable<?> iterable, char separator)",
        "public static String join(Iterable<?> iterable, String separator)",
        "public static String deleteWhitespace(String str)",
        "public static String removeStart(String str, String remove)",
        "public static String removeStartIgnoreCase(String str, String remove)",
        "public static String removeEnd(String str, String remove)",
        "public static String removeEndIgnoreCase(String str, String remove)",
        "public static String remove(String str, String remove)",
        "public static String remove(String str, char remove)",
        "public static String replaceOnce(String text, String searchString, String replacement)",
        "public static String replace(String text, String searchString, String replacement)",
        "public static String replace(String text, String searchString, String replacement, int max)",
        "public static String replaceEach(String text, String[] searchList, String[] replacementList)",
        "public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList)",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive)",
        "public static String replaceChars(String str, char searchChar, char replaceChar)",
        "public static String replaceChars(String str, String searchChars, String replaceChars)",
        "public static String overlay(String str, String overlay, int start, int end)",
        "public static String chomp(String str)",
        "public static String chomp(String str, String separator)",
        "public static String chop(String str)",
        "public static String repeat(String str, int repeat)",
        "public static String repeat(String str, String separator, int repeat)",
        "private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException",
        "public static String rightPad(String str, int size)",
        "public static String rightPad(String str, int size, char padChar)",
        "public static String rightPad(String str, int size, String padStr)",
        "public static String leftPad(String str, int size)",
        "public static String leftPad(String str, int size, char padChar)",
        "public static String leftPad(String str, int size, String padStr)",
        "public static int length(String str)",
        "public static String center(String str, int size)",
        "public static String center(String str, int size, char padChar)",
        "public static String center(String str, int size, String padStr)",
        "public static String upperCase(String str)",
        "public static String upperCase(String str, Locale locale)",
        "public static String lowerCase(String str)",
        "public static String lowerCase(String str, Locale locale)",
        "public static String capitalize(String str)",
        "public static String uncapitalize(String str)",
        "public static String swapCase(String str)",
        "public static int countMatches(String str, String sub)",
        "public static boolean isAlpha(String str)",
        "public static boolean isAlphaSpace(String str)",
        "public static boolean isAlphanumeric(String str)",
        "public static boolean isAlphanumericSpace(String str)",
        "public static boolean isAsciiPrintable(String str)",
        "public static boolean isNumeric(String str)",
        "public static boolean isNumericSpace(String str)",
        "public static boolean isWhitespace(String str)",
        "public static boolean isAllLowerCase(String str)",
        "public static boolean isAllUpperCase(String str)",
        "public static String defaultString(String str)",
        "public static String defaultString(String str, String defaultStr)",
        "public static String defaultIfEmpty(String str, String defaultStr)",
        "public static String reverse(String str)",
        "public static String reverseDelimited(String str, char separatorChar)",
        "public static String abbreviate(String str, int maxWidth)",
        "public static String abbreviate(String str, int offset, int maxWidth)",
        "public static String difference(String str1, String str2)",
        "public static int indexOfDifference(String str1, String str2)",
        "public static int indexOfDifference(String[] strs)",
        "public static String getCommonPrefix(String[] strs)",
        "public static int getLevenshteinDistance(String s, String t)",
        "public static boolean startsWith(String str, String prefix)",
        "public static boolean startsWithIgnoreCase(String str, String prefix)",
        "private static boolean startsWith(String str, String prefix, boolean ignoreCase)",
        "public static boolean startsWithAny(String string, String[] searchStrings)",
        "public static boolean endsWith(String str, String suffix)",
        "public static boolean endsWithIgnoreCase(String str, String suffix)",
        "private static boolean endsWith(String str, String suffix, boolean ignoreCase)"
      ],
      "methods": [
        {
          "buggy_method": "  private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n\n  \n  \n\n  if (text == null || text.length() == 0 || searchList == null || \n  searchList.length == 0 || replacementList == null || replacementList.length == 0) \n  {\n  return text;\n  }\n\n  \n  if (timeToLive < 0) {\n  throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n  }\n\n  int searchLength = searchList.length;\n  int replacementLength = replacementList.length;\n\n  \n  if (searchLength != replacementLength) {\n  throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n  + searchLength\n  + \" vs \"\n  + replacementLength);\n  }\n\n  \n  boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n  \n  int textIndex = -1;\n  int replaceIndex = -1;\n  int tempIndex = -1;\n\n  \n  \n  for (int i = 0; i < searchLength; i++) {\n  if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n  searchList[i].length() == 0 || replacementList[i] == null) \n  {\n  continue;\n  }\n  tempIndex = text.indexOf(searchList[i]);\n\n  \n  if (tempIndex == -1) {\n  noMoreMatchesForReplIndex[i] = true;\n  } else {\n  if (textIndex == -1 || tempIndex < textIndex) {\n  textIndex = tempIndex;\n  replaceIndex = i;\n  }\n  }\n  }\n  \n\n  \n  if (textIndex == -1) {\n  return text;\n  }\n\n  int start = 0;\n\n  \n  int increase = 0;\n\n  \n  for (int i = 0; i < searchList.length; i++) {\n  int greater = replacementList[i].length() - searchList[i].length();\n  if (greater > 0) {\n  increase += 3 * greater; \n  }\n  }\n  \n  increase = Math.min(increase, text.length() / 5);\n\n  StringBuilder buf = new StringBuilder(text.length() + increase);\n\n  while (textIndex != -1) {\n\n  for (int i = start; i < textIndex; i++) {\n  buf.append(text.charAt(i));\n  }\n  buf.append(replacementList[replaceIndex]);\n\n  start = textIndex + searchList[replaceIndex].length();\n\n  textIndex = -1;\n  replaceIndex = -1;\n  tempIndex = -1;\n  \n  \n  for (int i = 0; i < searchLength; i++) {\n  if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n  searchList[i].length() == 0 || replacementList[i] == null) \n  {\n  continue;\n  }\n  tempIndex = text.indexOf(searchList[i], start);\n\n  \n  if (tempIndex == -1) {\n  noMoreMatchesForReplIndex[i] = true;\n  } else {\n  if (textIndex == -1 || tempIndex < textIndex) {\n  textIndex = tempIndex;\n  replaceIndex = i;\n  }\n  }\n  }\n  \n\n  }\n  int textLength = text.length();\n  for (int i = start; i < textLength; i++) {\n  buf.append(text.charAt(i));\n  }\n  String result = buf.toString();\n  if (!repeat) {\n  return result;\n  }\n\n  return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n  }",
          "fixed_method": "  private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n\n  \n  \n\n  if (text == null || text.length() == 0 || searchList == null || \n  searchList.length == 0 || replacementList == null || replacementList.length == 0) \n  {\n  return text;\n  }\n\n  \n  if (timeToLive < 0) {\n  throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n  }\n\n  int searchLength = searchList.length;\n  int replacementLength = replacementList.length;\n\n  \n  if (searchLength != replacementLength) {\n  throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n  + searchLength\n  + \" vs \"\n  + replacementLength);\n  }\n\n  \n  boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n  \n  int textIndex = -1;\n  int replaceIndex = -1;\n  int tempIndex = -1;\n\n  \n  \n  for (int i = 0; i < searchLength; i++) {\n  if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n  searchList[i].length() == 0 || replacementList[i] == null) \n  {\n  continue;\n  }\n  tempIndex = text.indexOf(searchList[i]);\n\n  \n  if (tempIndex == -1) {\n  noMoreMatchesForReplIndex[i] = true;\n  } else {\n  if (textIndex == -1 || tempIndex < textIndex) {\n  textIndex = tempIndex;\n  replaceIndex = i;\n  }\n  }\n  }\n  \n\n  \n  if (textIndex == -1) {\n  return text;\n  }\n\n  int start = 0;\n\n  \n  int increase = 0;\n\n  \n  for (int i = 0; i < searchList.length; i++) {\n  if (searchList[i] == null || replacementList[i] == null) {\n  continue;\n  }\n  int greater = replacementList[i].length() - searchList[i].length();\n  if (greater > 0) {\n  increase += 3 * greater; \n  }\n  }\n  \n  increase = Math.min(increase, text.length() / 5);\n\n  StringBuilder buf = new StringBuilder(text.length() + increase);\n\n  while (textIndex != -1) {\n\n  for (int i = start; i < textIndex; i++) {\n  buf.append(text.charAt(i));\n  }\n  buf.append(replacementList[replaceIndex]);\n\n  start = textIndex + searchList[replaceIndex].length();\n\n  textIndex = -1;\n  replaceIndex = -1;\n  tempIndex = -1;\n  \n  \n  for (int i = 0; i < searchLength; i++) {\n  if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n  searchList[i].length() == 0 || replacementList[i] == null) \n  {\n  continue;\n  }\n  tempIndex = text.indexOf(searchList[i], start);\n\n  \n  if (tempIndex == -1) {\n  noMoreMatchesForReplIndex[i] = true;\n  } else {\n  if (textIndex == -1 || tempIndex < textIndex) {\n  textIndex = tempIndex;\n  replaceIndex = i;\n  }\n  }\n  }\n  \n\n  }\n  int textLength = text.length();\n  for (int i = start; i < textLength; i++) {\n  buf.append(text.charAt(i));\n  }\n  String result = buf.toString();\n  if (!repeat) {\n  return result;\n  }\n\n  return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n  }",
          "diff": [
            "@@ -3673,6 +3673,9 @@",
            " \n",
            "         // count the replacement text elements that are larger than their corresponding text being replaced\n",
            "         for (int i = 0; i < searchList.length; i++) {\n",
            "+            if (searchList[i] == null || replacementList[i] == null) {\n",
            "+                continue;\n",
            "+            }\n",
            "             int greater = replacementList[i].length() - searchList[i].length();\n",
            "             if (greater > 0) {\n",
            "                 increase += 3 * greater; // assume 3 matches\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
