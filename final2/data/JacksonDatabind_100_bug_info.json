{
  "bug_id": "100",
  "failed_tests": {
    "com.fasterxml.jackson.databind.node.TestConversions": [
      {
        "methodName": "testBase64Text",
        "error": "junit.framework.AssertionFailedError",
        "message": "Failed (variant MODIFIED-FOR-URL, data length 1): Cannot access contents of TextNode as binary due to broken Base64 encoding: Unexpected end-of-String in base64 content",
        "fail_line": "                    fail(\"Failed (variant \"+variant+\", data length \"+len+\"): \"+e.getMessage());",
        "test_source": "  public void testBase64Text() throws Exception {\n  // let's actually iterate over sets of encoding modes, lengths\n  \n  final int[] LENS = { 1, 2, 3, 4, 7, 9, 32, 33, 34, 35 };\n  final Base64Variant[] VARIANTS = {\n  Base64Variants.MIME,\n  Base64Variants.MIME_NO_LINEFEEDS,\n  Base64Variants.MODIFIED_FOR_URL,\n  Base64Variants.PEM\n  };\n\n  for (int len : LENS) {\n  byte[] input = new byte[len];\n  for (int i = 0; i < input.length; ++i) {\n  input[i] = (byte) i;\n  }\n  for (Base64Variant variant : VARIANTS) {\n  TextNode n = new TextNode(variant.encode(input));\n  byte[] data = null;\n  try {\n  data = n.getBinaryValue(variant);\n  } catch (Exception e) {\n  fail(\"Failed (variant \"+variant+\", data length \"+len+\"): \"+e.getMessage());\n  }\n  assertNotNull(data);\n  assertArrayEquals(data, input);\n\n  // 15-Aug-2018, tatu: [databind#2096] requires another test\n  JsonParser p = new TreeTraversingParser(n);\n  assertEquals(JsonToken.VALUE_STRING, p.nextToken());\n  try {\n  data = p.getBinaryValue(variant);\n  } catch (Exception e) {\n  fail(\"Failed (variant \"+variant+\", data length \"+len+\"): \"+e.getMessage());\n  }\n  assertNotNull(data);\n  assertArrayEquals(data, input);\n  p.close();\n  }\n  }\n  }",
        "stack": [
          "TestConversions.testBase64Text line 189"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/node/TreeTraversingParser.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.node;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserMinimalBase;\n\nimport com.fasterxml.jackson.databind.JsonNode;\n\n\npublic class TreeTraversingParser extends ParserMinimalBase { protected ObjectCodec _objectCodec; protected NodeCursor _nodeCursor; protected JsonToken _nextToken; protected boolean _startContainer; protected boolean _closed; public TreeTraversingParser(JsonNode n) { this(n, null); }\n\n    public TreeTraversingParser(JsonNode n, ObjectCodec codec) {\n        super(0);\n        _objectCodec = codec;\n        if (n.isArray()) {\n            _nextToken = JsonToken.START_ARRAY;\n            _nodeCursor = new NodeCursor.ArrayCursor(n, null);\n        } else if (n.isObject()) {\n            _nextToken = JsonToken.START_OBJECT;\n            _nodeCursor = new NodeCursor.ObjectCursor(n, null);\n        } else { \n            _nodeCursor = new NodeCursor.RootCursor(n, null);\n        }\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n    \n    \n\n    @Override\n    public void close() throws IOException {\n        if (!_closed) {\n            _closed = true;\n            _nodeCursor = null;\n            _currToken = null;\n        }\n    }\n\n    \n\n    @Override\n    public JsonToken nextToken() throws IOException, JsonParseException {\n        if (_nextToken != null) {\n            _currToken = _nextToken;\n            _nextToken = null;\n            return _currToken;\n        }\n        \n        if (_startContainer) {\n            _startContainer = false;\n            \n            if (!_nodeCursor.currentHasChildren()) {\n                _currToken = (_currToken == JsonToken.START_OBJECT) ?\n                    JsonToken.END_OBJECT : JsonToken.END_ARRAY;\n                return _currToken;\n            }\n            _nodeCursor = _nodeCursor.iterateChildren();\n            _currToken = _nodeCursor.nextToken();\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                _startContainer = true;\n            }\n            return _currToken;\n        }\n        \n        if (_nodeCursor == null) {\n            _closed = true; \n            return null;\n        }\n        \n        _currToken = _nodeCursor.nextToken();\n        if (_currToken != null) {\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                _startContainer = true;\n            }\n            return _currToken;\n        }\n        \n        _currToken = _nodeCursor.endToken();\n        _nodeCursor = _nodeCursor.getParent();\n        return _currToken;\n    }\n    \n    \n    \n\n    @Override\n    public JsonParser skipChildren() throws IOException, JsonParseException {\n        if (_currToken == JsonToken.START_OBJECT) {\n            _startContainer = false;\n            _currToken = JsonToken.END_OBJECT;\n        } else if (_currToken == JsonToken.START_ARRAY) {\n            _startContainer = false;\n            _currToken = JsonToken.END_ARRAY;\n        }\n        return this;\n    }\n\n    @Override\n    public boolean isClosed() {\n        return _closed;\n    }\n\n    \n\n    @Override\n    public String getCurrentName() {\n        return (_nodeCursor == null) ? null : _nodeCursor.getCurrentName();\n    }\n\n    @Override\n    public void overrideCurrentName(String name) {\n        if (_nodeCursor != null) {\n            _nodeCursor.overrideCurrentName(name);\n        }\n    }\n    \n    @Override\n    public JsonStreamContext getParsingContext() {\n        return _nodeCursor;\n    }\n\n    @Override\n    public JsonLocation getTokenLocation() {\n        return JsonLocation.NA;\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        return JsonLocation.NA;\n    }\n\n    \n\n    @Override\n    public String getText() {\n        if (_closed) {\n            return null;\n        }\n        \n        switch (_currToken) {\n        case FIELD_NAME:\n            return _nodeCursor.getCurrentName();\n        case VALUE_STRING:\n            return currentNode().textValue();\n        case VALUE_NUMBER_INT:\n        case VALUE_NUMBER_FLOAT:\n            return String.valueOf(currentNode().numberValue());\n        case VALUE_EMBEDDED_OBJECT:\n            JsonNode n = currentNode();\n            if (n != null && n.isBinary()) {\n                \n                return n.asText();\n            }\n        default:\n        \treturn (_currToken == null) ? null : _currToken.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters() throws IOException, JsonParseException {\n        return getText().toCharArray();\n    }\n\n    @Override\n    public int getTextLength() throws IOException, JsonParseException {\n        return getText().length();\n    }\n\n    @Override\n    public int getTextOffset() throws IOException, JsonParseException {\n        return 0;\n    }\n\n    @Override\n    public boolean hasTextCharacters() {\n        \n        return false;\n    }\n    \n    \n\n    \n\n    @Override\n    public NumberType getNumberType() throws IOException, JsonParseException {\n        JsonNode n = currentNumericNode();\n        return (n == null) ? null : n.numberType();\n    }\n\n    @Override\n    public BigInteger getBigIntegerValue() throws IOException, JsonParseException {\n        return currentNumericNode().bigIntegerValue();\n    }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException, JsonParseException {\n        return currentNumericNode().decimalValue();\n    }\n\n    @Override\n    public double getDoubleValue() throws IOException, JsonParseException {\n        return currentNumericNode().doubleValue();\n    }\n\n    @Override\n    public float getFloatValue() throws IOException, JsonParseException {\n        return (float) currentNumericNode().doubleValue();\n    }\n\n    @Override\n    public long getLongValue() throws IOException, JsonParseException {\n        return currentNumericNode().longValue();\n    }\n\n    @Override\n    public int getIntValue() throws IOException, JsonParseException {\n        return currentNumericNode().intValue();\n    }\n\n    @Override\n    public Number getNumberValue() throws IOException, JsonParseException {\n        return currentNumericNode().numberValue();\n    }\n\n    @Override\n    public Object getEmbeddedObject() {\n        if (!_closed) {\n            JsonNode n = currentNode();\n            if (n != null) {\n                if (n.isPojo()) {\n                    return ((POJONode) n).getPojo();\n                }\n                if (n.isBinary()) {\n                    return ((BinaryNode) n).binaryValue();\n                }\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public boolean isNaN() {\n        if (!_closed) {\n            JsonNode n = currentNode();\n            if (n instanceof NumericNode) {\n                return ((NumericNode) n).isNaN();\n            }\n        }\n        return false;\n    }\n\n    \n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException {\n        \n        JsonNode n = currentNode();\n        if (n != null) {\n            \n            \n            byte[] data = n.binaryValue();\n            if (data != null) {\n                return data;\n            }\n            if (n.isPojo()) {\n                Object ob = ((POJONode) n).getPojo();\n                if (ob instanceof byte[]) {\n                    return (byte[]) ob;\n                }\n            }\n        }\n        \n        return null;\n    }\n\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException {\n        byte[] data = getBinaryValue(b64variant);\n        if (data != null) {\n            out.write(data, 0, data.length);\n            return data.length;\n        }\n        return 0;\n    }\n\n    \n\n    protected JsonNode currentNode() {\n        if (_closed || _nodeCursor == null) {\n            return null;\n        }\n        return _nodeCursor.currentNode();\n    }\n\n    protected JsonNode currentNumericNode() throws JsonParseException {\n        JsonNode n = currentNode();\n        if (n == null || !n.isNumber()) {\n            JsonToken t = (n == null) ? null : n.asToken();\n            throw _constructError(\"Current token (\"+t+\") not numeric, cannot use numeric value accessors\");\n        }\n        return n;\n    }\n\n    @Override\n    protected void _handleEOF() throws JsonParseException {\n        _throwInternal(); \n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.node;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserMinimalBase;\n\nimport com.fasterxml.jackson.databind.JsonNode;\n\n\npublic class TreeTraversingParser extends ParserMinimalBase { protected ObjectCodec _objectCodec; protected NodeCursor _nodeCursor; protected JsonToken _nextToken; protected boolean _startContainer; protected boolean _closed; public TreeTraversingParser(JsonNode n) { this(n, null); }\n\n    public TreeTraversingParser(JsonNode n, ObjectCodec codec) {\n        super(0);\n        _objectCodec = codec;\n        if (n.isArray()) {\n            _nextToken = JsonToken.START_ARRAY;\n            _nodeCursor = new NodeCursor.ArrayCursor(n, null);\n        } else if (n.isObject()) {\n            _nextToken = JsonToken.START_OBJECT;\n            _nodeCursor = new NodeCursor.ObjectCursor(n, null);\n        } else { \n            _nodeCursor = new NodeCursor.RootCursor(n, null);\n        }\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n    \n    \n\n    @Override\n    public void close() throws IOException {\n        if (!_closed) {\n            _closed = true;\n            _nodeCursor = null;\n            _currToken = null;\n        }\n    }\n\n    \n\n    @Override\n    public JsonToken nextToken() throws IOException, JsonParseException {\n        if (_nextToken != null) {\n            _currToken = _nextToken;\n            _nextToken = null;\n            return _currToken;\n        }\n        \n        if (_startContainer) {\n            _startContainer = false;\n            \n            if (!_nodeCursor.currentHasChildren()) {\n                _currToken = (_currToken == JsonToken.START_OBJECT) ?\n                    JsonToken.END_OBJECT : JsonToken.END_ARRAY;\n                return _currToken;\n            }\n            _nodeCursor = _nodeCursor.iterateChildren();\n            _currToken = _nodeCursor.nextToken();\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                _startContainer = true;\n            }\n            return _currToken;\n        }\n        \n        if (_nodeCursor == null) {\n            _closed = true; \n            return null;\n        }\n        \n        _currToken = _nodeCursor.nextToken();\n        if (_currToken != null) {\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                _startContainer = true;\n            }\n            return _currToken;\n        }\n        \n        _currToken = _nodeCursor.endToken();\n        _nodeCursor = _nodeCursor.getParent();\n        return _currToken;\n    }\n    \n    \n    \n\n    @Override\n    public JsonParser skipChildren() throws IOException, JsonParseException {\n        if (_currToken == JsonToken.START_OBJECT) {\n            _startContainer = false;\n            _currToken = JsonToken.END_OBJECT;\n        } else if (_currToken == JsonToken.START_ARRAY) {\n            _startContainer = false;\n            _currToken = JsonToken.END_ARRAY;\n        }\n        return this;\n    }\n\n    @Override\n    public boolean isClosed() {\n        return _closed;\n    }\n\n    \n\n    @Override\n    public String getCurrentName() {\n        return (_nodeCursor == null) ? null : _nodeCursor.getCurrentName();\n    }\n\n    @Override\n    public void overrideCurrentName(String name) {\n        if (_nodeCursor != null) {\n            _nodeCursor.overrideCurrentName(name);\n        }\n    }\n    \n    @Override\n    public JsonStreamContext getParsingContext() {\n        return _nodeCursor;\n    }\n\n    @Override\n    public JsonLocation getTokenLocation() {\n        return JsonLocation.NA;\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        return JsonLocation.NA;\n    }\n\n    \n\n    @Override\n    public String getText() {\n        if (_closed) {\n            return null;\n        }\n        \n        switch (_currToken) {\n        case FIELD_NAME:\n            return _nodeCursor.getCurrentName();\n        case VALUE_STRING:\n            return currentNode().textValue();\n        case VALUE_NUMBER_INT:\n        case VALUE_NUMBER_FLOAT:\n            return String.valueOf(currentNode().numberValue());\n        case VALUE_EMBEDDED_OBJECT:\n            JsonNode n = currentNode();\n            if (n != null && n.isBinary()) {\n                \n                return n.asText();\n            }\n        default:\n        \treturn (_currToken == null) ? null : _currToken.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters() throws IOException, JsonParseException {\n        return getText().toCharArray();\n    }\n\n    @Override\n    public int getTextLength() throws IOException, JsonParseException {\n        return getText().length();\n    }\n\n    @Override\n    public int getTextOffset() throws IOException, JsonParseException {\n        return 0;\n    }\n\n    @Override\n    public boolean hasTextCharacters() {\n        \n        return false;\n    }\n    \n    \n\n    \n\n    @Override\n    public NumberType getNumberType() throws IOException, JsonParseException {\n        JsonNode n = currentNumericNode();\n        return (n == null) ? null : n.numberType();\n    }\n\n    @Override\n    public BigInteger getBigIntegerValue() throws IOException, JsonParseException {\n        return currentNumericNode().bigIntegerValue();\n    }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException, JsonParseException {\n        return currentNumericNode().decimalValue();\n    }\n\n    @Override\n    public double getDoubleValue() throws IOException, JsonParseException {\n        return currentNumericNode().doubleValue();\n    }\n\n    @Override\n    public float getFloatValue() throws IOException, JsonParseException {\n        return (float) currentNumericNode().doubleValue();\n    }\n\n    @Override\n    public long getLongValue() throws IOException, JsonParseException {\n        return currentNumericNode().longValue();\n    }\n\n    @Override\n    public int getIntValue() throws IOException, JsonParseException {\n        return currentNumericNode().intValue();\n    }\n\n    @Override\n    public Number getNumberValue() throws IOException, JsonParseException {\n        return currentNumericNode().numberValue();\n    }\n\n    @Override\n    public Object getEmbeddedObject() {\n        if (!_closed) {\n            JsonNode n = currentNode();\n            if (n != null) {\n                if (n.isPojo()) {\n                    return ((POJONode) n).getPojo();\n                }\n                if (n.isBinary()) {\n                    return ((BinaryNode) n).binaryValue();\n                }\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public boolean isNaN() {\n        if (!_closed) {\n            JsonNode n = currentNode();\n            if (n instanceof NumericNode) {\n                return ((NumericNode) n).isNaN();\n            }\n        }\n        return false;\n    }\n\n    \n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException {\n        \n        JsonNode n = currentNode();\n        if (n != null) {\n            \n            \n            if (n instanceof TextNode) {\n                return ((TextNode) n).getBinaryValue(b64variant);\n            }\n            return n.binaryValue();\n        }\n        \n        return null;\n    }\n\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException {\n        byte[] data = getBinaryValue(b64variant);\n        if (data != null) {\n            out.write(data, 0, data.length);\n            return data.length;\n        }\n        return 0;\n    }\n\n    \n\n    protected JsonNode currentNode() {\n        if (_closed || _nodeCursor == null) {\n            return null;\n        }\n        return _nodeCursor.currentNode();\n    }\n\n    protected JsonNode currentNumericNode() throws JsonParseException {\n        JsonNode n = currentNode();\n        if (n == null || !n.isNumber()) {\n            JsonToken t = (n == null) ? null : n.asToken();\n            throw _constructError(\"Current token (\"+t+\") not numeric, cannot use numeric value accessors\");\n        }\n        return n;\n    }\n\n    @Override\n    protected void _handleEOF() throws JsonParseException {\n        _throwInternal(); \n    }\n}\n",
      "buggy_signatures": [
        "public class TreeTraversingParser extends ParserMinimalBase { protected ObjectCodec _objectCodec; protected NodeCursor _nodeCursor; protected JsonToken _nextToken; protected boolean _startContainer; protected boolean _closed; public TreeTraversingParser(JsonNode n)",
        "public TreeTraversingParser(JsonNode n, ObjectCodec codec)",
        "public void setCodec(ObjectCodec c)",
        "public ObjectCodec getCodec()",
        "public Version version()",
        "public void close() throws IOException",
        "public JsonToken nextToken() throws IOException, JsonParseException",
        "public JsonParser skipChildren() throws IOException, JsonParseException",
        "public boolean isClosed()",
        "public String getCurrentName()",
        "public void overrideCurrentName(String name)",
        "public JsonStreamContext getParsingContext()",
        "public JsonLocation getTokenLocation()",
        "public JsonLocation getCurrentLocation()",
        "public String getText()",
        "public char[] getTextCharacters() throws IOException, JsonParseException",
        "public int getTextLength() throws IOException, JsonParseException",
        "public int getTextOffset() throws IOException, JsonParseException",
        "public boolean hasTextCharacters()",
        "public NumberType getNumberType() throws IOException, JsonParseException",
        "public BigInteger getBigIntegerValue() throws IOException, JsonParseException",
        "public BigDecimal getDecimalValue() throws IOException, JsonParseException",
        "public double getDoubleValue() throws IOException, JsonParseException",
        "public float getFloatValue() throws IOException, JsonParseException",
        "public long getLongValue() throws IOException, JsonParseException",
        "public int getIntValue() throws IOException, JsonParseException",
        "public Number getNumberValue() throws IOException, JsonParseException",
        "public Object getEmbeddedObject()",
        "public boolean isNaN()",
        "public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException",
        "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException",
        "protected JsonNode currentNode()",
        "protected JsonNode currentNumericNode() throws JsonParseException",
        "protected void _handleEOF() throws JsonParseException"
      ],
      "fixed_signatures": [
        "public class TreeTraversingParser extends ParserMinimalBase { protected ObjectCodec _objectCodec; protected NodeCursor _nodeCursor; protected JsonToken _nextToken; protected boolean _startContainer; protected boolean _closed; public TreeTraversingParser(JsonNode n)",
        "public TreeTraversingParser(JsonNode n, ObjectCodec codec)",
        "public void setCodec(ObjectCodec c)",
        "public ObjectCodec getCodec()",
        "public Version version()",
        "public void close() throws IOException",
        "public JsonToken nextToken() throws IOException, JsonParseException",
        "public JsonParser skipChildren() throws IOException, JsonParseException",
        "public boolean isClosed()",
        "public String getCurrentName()",
        "public void overrideCurrentName(String name)",
        "public JsonStreamContext getParsingContext()",
        "public JsonLocation getTokenLocation()",
        "public JsonLocation getCurrentLocation()",
        "public String getText()",
        "public char[] getTextCharacters() throws IOException, JsonParseException",
        "public int getTextLength() throws IOException, JsonParseException",
        "public int getTextOffset() throws IOException, JsonParseException",
        "public boolean hasTextCharacters()",
        "public NumberType getNumberType() throws IOException, JsonParseException",
        "public BigInteger getBigIntegerValue() throws IOException, JsonParseException",
        "public BigDecimal getDecimalValue() throws IOException, JsonParseException",
        "public double getDoubleValue() throws IOException, JsonParseException",
        "public float getFloatValue() throws IOException, JsonParseException",
        "public long getLongValue() throws IOException, JsonParseException",
        "public int getIntValue() throws IOException, JsonParseException",
        "public Number getNumberValue() throws IOException, JsonParseException",
        "public Object getEmbeddedObject()",
        "public boolean isNaN()",
        "public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException",
        "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException",
        "protected JsonNode currentNode()",
        "protected JsonNode currentNumericNode() throws JsonParseException",
        "protected void _handleEOF() throws JsonParseException"
      ],
      "methods": [
        {
          "buggy_method": "  public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException {\n  \n  JsonNode n = currentNode();\n  if (n != null) {\n  \n  \n  byte[] data = n.binaryValue();\n  if (data != null) {\n  return data;\n  }\n  if (n.isPojo()) {\n  Object ob = ((POJONode) n).getPojo();\n  if (ob instanceof byte[]) {\n  return (byte[]) ob;\n  }\n  }\n  }\n  \n  return null;\n  }",
          "fixed_method": "  public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException {\n  \n  JsonNode n = currentNode();\n  if (n != null) {\n  \n  \n  if (n instanceof TextNode) {\n  return ((TextNode) n).getBinaryValue(b64variant);\n  }\n  return n.binaryValue();\n  }\n  \n  return null;\n  }",
          "diff": [
            "@@ -360,16 +360,10 @@",
            "         if (n != null) {\n",
            "             // [databind#2096]: although `binaryValue()` works for real binary node\n",
            "             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n",
            "-            byte[] data = n.binaryValue();\n",
            "-            if (data != null) {\n",
            "-                return data;\n",
            "-            }\n",
            "-            if (n.isPojo()) {\n",
            "-                Object ob = ((POJONode) n).getPojo();\n",
            "-                if (ob instanceof byte[]) {\n",
            "-                    return (byte[]) ob;\n",
            "-                }\n",
            "-            }\n",
            "+            if (n instanceof TextNode) {\n",
            "+                return ((TextNode) n).getBinaryValue(b64variant);\n",
            "+            }\n",
            "+            return n.binaryValue();\n",
            "         }\n",
            "         // otherwise return null to mark we have no binary content\n",
            "         return null;\n"
          ],
          "changed_lines": 14
        }
      ]
    }
  ]
}
