{
  "bug_id": "51",
  "failed_tests": {
    "org.apache.commons.math.analysis.solvers.RegulaFalsiSolverTest": [
      {
        "methodName": "testIssue631",
        "error": "org.apache.commons.math.exception.TooManyEvaluationsException",
        "message": "illegal state: maximal count (3,624) exceeded: evaluations",
        "fail_line": "        final double root = solver.solve(3624, f, 1, 10);",
        "test_source": "  public void testIssue631() {\n  final UnivariateRealFunction f = new UnivariateRealFunction() {\n  @Override\n  public double value(double x) {\n  return Math.exp(x) - Math.pow(Math.PI, 3.0);\n  }\n  };\n\n  final UnivariateRealSolver solver = new RegulaFalsiSolver();\n  final double root = solver.solve(3624, f, 1, 10);\n  Assert.assertEquals(3.4341896575482003, root, 1e-15);\n\t}",
        "stack": [
          "BaseAbstractUnivariateRealSolver.incrementEvaluationCount line 296, BaseAbstractUnivariateRealSolver.computeObjectiveValue line 153, BaseSecantSolver.doSolve line 161, BaseAbstractUnivariateRealSolver.solve line 190, BaseSecantSolver.solve line 117, BaseSecantSolver.solve line 124, BaseAbstractUnivariateRealSolver.solve line 195, RegulaFalsiSolverTest.testIssue631 line 53"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/analysis/solvers/BaseSecantSolver.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.analysis.solvers;\n\nimport org.apache.commons.math.util.FastMath;\nimport org.apache.commons.math.analysis.UnivariateRealFunction;\nimport org.apache.commons.math.exception.MathInternalError;\n\n\npublic abstract class BaseSecantSolver extends AbstractUnivariateRealSolver implements BracketedUnivariateRealSolver<UnivariateRealFunction> { protected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6; private AllowedSolution allowed; private final Method method; protected BaseSecantSolver(final double absoluteAccuracy, final Method method) {\n        super(absoluteAccuracy);\n        this.allowed = AllowedSolution.ANY_SIDE;\n        this.method = method;\n    }\n\n    \n    protected BaseSecantSolver(final double relativeAccuracy, final double absoluteAccuracy, final Method method) {\n        super(relativeAccuracy, absoluteAccuracy);\n        this.allowed = AllowedSolution.ANY_SIDE;\n        this.method = method;\n    }\n\n    \n    protected BaseSecantSolver(final double relativeAccuracy, final double absoluteAccuracy, final double functionValueAccuracy, final Method method) {\n        super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);\n        this.allowed = AllowedSolution.ANY_SIDE;\n        this.method = method;\n    }\n\n    \n    public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final AllowedSolution allowedSolution) {\n        return solve(maxEval, f, min, max, min + 0.5 * (max - min), allowedSolution);\n    }\n\n    \n    public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {\n        this.allowed = allowedSolution;\n        return super.solve(maxEval, f, min, max, startValue);\n    }\n\n    \n    @Override\n    public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue) {\n        return solve(maxEval, f, min, max, startValue, AllowedSolution.ANY_SIDE);\n    }\n\n    \n    protected final double doSolve() {\n        \n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        \n        \n        \n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        \n        verifyBracketing(x0, x1);\n\n        \n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        \n        \n        boolean inverted = false;\n\n        \n        while (true) {\n            \n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            \n            \n            \n            if (fx == 0.0) {\n                return x;\n            }\n\n            \n            if (f1 * fx < 0) {\n                \n                \n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                        \n                        \n                default:\n                    \n                }\n            }\n            \n            x1 = x;\n            f1 = fx;\n\n            \n            \n            \n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            \n            \n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }\n\n    \n    protected enum Method {\n\n        \n        REGULA_FALSI,\n\n        \n        ILLINOIS,\n\n        \n        PEGASUS;\n\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.analysis.solvers;\n\nimport org.apache.commons.math.util.FastMath;\nimport org.apache.commons.math.analysis.UnivariateRealFunction;\nimport org.apache.commons.math.exception.MathInternalError;\n\n\npublic abstract class BaseSecantSolver extends AbstractUnivariateRealSolver implements BracketedUnivariateRealSolver<UnivariateRealFunction> { protected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6; private AllowedSolution allowed; private final Method method; protected BaseSecantSolver(final double absoluteAccuracy, final Method method) {\n        super(absoluteAccuracy);\n        this.allowed = AllowedSolution.ANY_SIDE;\n        this.method = method;\n    }\n\n    \n    protected BaseSecantSolver(final double relativeAccuracy, final double absoluteAccuracy, final Method method) {\n        super(relativeAccuracy, absoluteAccuracy);\n        this.allowed = AllowedSolution.ANY_SIDE;\n        this.method = method;\n    }\n\n    \n    protected BaseSecantSolver(final double relativeAccuracy, final double absoluteAccuracy, final double functionValueAccuracy, final Method method) {\n        super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);\n        this.allowed = AllowedSolution.ANY_SIDE;\n        this.method = method;\n    }\n\n    \n    public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final AllowedSolution allowedSolution) {\n        return solve(maxEval, f, min, max, min + 0.5 * (max - min), allowedSolution);\n    }\n\n    \n    public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {\n        this.allowed = allowedSolution;\n        return super.solve(maxEval, f, min, max, startValue);\n    }\n\n    \n    @Override\n    public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue) {\n        return solve(maxEval, f, min, max, startValue, AllowedSolution.ANY_SIDE);\n    }\n\n    \n    protected final double doSolve() {\n        \n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        \n        \n        \n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        \n        verifyBracketing(x0, x1);\n\n        \n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        \n        \n        boolean inverted = false;\n\n        \n        while (true) {\n            \n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            \n            \n            \n            if (fx == 0.0) {\n                return x;\n            }\n\n            \n            if (f1 * fx < 0) {\n                \n                \n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    if (x == x1) {\n                        final double delta = FastMath.max(rtol * FastMath.abs(x1),\n                                                          atol);\n                        \n                        \n                        x0 = 0.5 * (x0 + x1 - delta);\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    \n                    throw new MathInternalError();\n                }\n            }\n            \n            x1 = x;\n            f1 = fx;\n\n            \n            \n            \n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            \n            \n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }\n\n    \n    protected enum Method {\n\n        \n        REGULA_FALSI,\n\n        \n        ILLINOIS,\n\n        \n        PEGASUS;\n\n    }\n}\n",
      "buggy_signatures": [
        "protected BaseSecantSolver(final double relativeAccuracy, final double absoluteAccuracy, final Method method)",
        "protected BaseSecantSolver(final double relativeAccuracy, final double absoluteAccuracy, final double functionValueAccuracy, final Method method)",
        "public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final AllowedSolution allowedSolution)",
        "public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution)",
        "public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue)",
        "protected final double doSolve()"
      ],
      "fixed_signatures": [
        "protected BaseSecantSolver(final double relativeAccuracy, final double absoluteAccuracy, final Method method)",
        "protected BaseSecantSolver(final double relativeAccuracy, final double absoluteAccuracy, final double functionValueAccuracy, final Method method)",
        "public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final AllowedSolution allowedSolution)",
        "public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution)",
        "public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue)",
        "protected final double doSolve()"
      ],
      "methods": [
        {
          "buggy_method": "  protected final double doSolve() {\n  \n  double x0 = getMin();\n  double x1 = getMax();\n  double f0 = computeObjectiveValue(x0);\n  double f1 = computeObjectiveValue(x1);\n\n  \n  \n  \n  if (f0 == 0.0) {\n  return x0;\n  }\n  if (f1 == 0.0) {\n  return x1;\n  }\n\n  \n  verifyBracketing(x0, x1);\n\n  \n  final double ftol = getFunctionValueAccuracy();\n  final double atol = getAbsoluteAccuracy();\n  final double rtol = getRelativeAccuracy();\n\n  \n  \n  boolean inverted = false;\n\n  \n  while (true) {\n  \n  final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n  final double fx = computeObjectiveValue(x);\n\n  \n  \n  \n  if (fx == 0.0) {\n  return x;\n  }\n\n  \n  if (f1 * fx < 0) {\n  \n  \n  x0 = x1;\n  f0 = f1;\n  inverted = !inverted;\n  } else {\n  switch (method) {\n  case ILLINOIS:\n  f0 *= 0.5;\n  break;\n  case PEGASUS:\n  f0 *= f1 / (f1 + fx);\n  break;\n  \n  \n  default:\n  \n  }\n  }\n  \n  x1 = x;\n  f1 = fx;\n\n  \n  \n  \n  if (FastMath.abs(f1) <= ftol) {\n  switch (allowed) {\n  case ANY_SIDE:\n  return x1;\n  case LEFT_SIDE:\n  if (inverted) {\n  return x1;\n  }\n  break;\n  case RIGHT_SIDE:\n  if (!inverted) {\n  return x1;\n  }\n  break;\n  case BELOW_SIDE:\n  if (f1 <= 0) {\n  return x1;\n  }\n  break;\n  case ABOVE_SIDE:\n  if (f1 >= 0) {\n  return x1;\n  }\n  break;\n  default:\n  throw new MathInternalError();\n  }\n  }\n\n  \n  \n  if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n  atol)) {\n  switch (allowed) {\n  case ANY_SIDE:\n  return x1;\n  case LEFT_SIDE:\n  return inverted ? x1 : x0;\n  case RIGHT_SIDE:\n  return inverted ? x0 : x1;\n  case BELOW_SIDE:\n  return (f1 <= 0) ? x1 : x0;\n  case ABOVE_SIDE:\n  return (f1 >= 0) ? x1 : x0;\n  default:\n  throw new MathInternalError();\n  }\n  }\n  }\n  }",
          "fixed_method": "  protected final double doSolve() {\n  \n  double x0 = getMin();\n  double x1 = getMax();\n  double f0 = computeObjectiveValue(x0);\n  double f1 = computeObjectiveValue(x1);\n\n  \n  \n  \n  if (f0 == 0.0) {\n  return x0;\n  }\n  if (f1 == 0.0) {\n  return x1;\n  }\n\n  \n  verifyBracketing(x0, x1);\n\n  \n  final double ftol = getFunctionValueAccuracy();\n  final double atol = getAbsoluteAccuracy();\n  final double rtol = getRelativeAccuracy();\n\n  \n  \n  boolean inverted = false;\n\n  \n  while (true) {\n  \n  final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n  final double fx = computeObjectiveValue(x);\n\n  \n  \n  \n  if (fx == 0.0) {\n  return x;\n  }\n\n  \n  if (f1 * fx < 0) {\n  \n  \n  x0 = x1;\n  f0 = f1;\n  inverted = !inverted;\n  } else {\n  switch (method) {\n  case ILLINOIS:\n  f0 *= 0.5;\n  break;\n  case PEGASUS:\n  f0 *= f1 / (f1 + fx);\n  break;\n  case REGULA_FALSI:\n  if (x == x1) {\n  final double delta = FastMath.max(rtol * FastMath.abs(x1),\n  atol);\n  \n  \n  x0 = 0.5 * (x0 + x1 - delta);\n  f0 = computeObjectiveValue(x0);\n  }\n  break;\n  default:\n  \n  throw new MathInternalError();\n  }\n  }\n  \n  x1 = x;\n  f1 = fx;\n\n  \n  \n  \n  if (FastMath.abs(f1) <= ftol) {\n  switch (allowed) {\n  case ANY_SIDE:\n  return x1;\n  case LEFT_SIDE:\n  if (inverted) {\n  return x1;\n  }\n  break;\n  case RIGHT_SIDE:\n  if (!inverted) {\n  return x1;\n  }\n  break;\n  case BELOW_SIDE:\n  if (f1 <= 0) {\n  return x1;\n  }\n  break;\n  case ABOVE_SIDE:\n  if (f1 >= 0) {\n  return x1;\n  }\n  break;\n  default:\n  throw new MathInternalError();\n  }\n  }\n\n  \n  \n  if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n  atol)) {\n  switch (allowed) {\n  case ANY_SIDE:\n  return x1;\n  case LEFT_SIDE:\n  return inverted ? x1 : x0;\n  case RIGHT_SIDE:\n  return inverted ? x0 : x1;\n  case BELOW_SIDE:\n  return (f1 <= 0) ? x1 : x0;\n  case ABOVE_SIDE:\n  return (f1 >= 0) ? x1 : x0;\n  default:\n  throw new MathInternalError();\n  }\n  }\n  }\n  }",
          "diff": [
            "@@ -182,10 +182,19 @@",
            "                 case PEGASUS:\n",
            "                     f0 *= f1 / (f1 + fx);\n",
            "                     break;\n",
            "+                case REGULA_FALSI:\n",
            "+                    if (x == x1) {\n",
            "+                        final double delta = FastMath.max(rtol * FastMath.abs(x1),\n",
            "+                                                          atol);\n",
            "                         // Update formula cannot make any progress: Update the\n",
            "                         // search interval.\n",
            "+                        x0 = 0.5 * (x0 + x1 - delta);\n",
            "+                        f0 = computeObjectiveValue(x0);\n",
            "+                    }\n",
            "+                    break;\n",
            "                 default:\n",
            "                     // Should never happen.\n",
            "+                    throw new MathInternalError();\n",
            "                 }\n",
            "             }\n",
            "             // Update from [x0, x1] to [x0, x].\n"
          ],
          "changed_lines": 9
        }
      ]
    }
  ]
}
