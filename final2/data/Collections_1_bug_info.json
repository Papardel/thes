{
  "bug_id": "1",
  "failed_tests": {
    "org.apache.commons.collections.map.TestFlat3Map": [
      {
        "methodName": "testEntryIteratorSetValue2",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<10> but was:<NewValue>",
        "fail_line": "        assertEquals(TEN, map.get(ONE));",
        "test_source": "  public void testEntryIteratorSetValue2() throws Exception {\n  Flat3Map map = new Flat3Map();\n  map.put(ONE, TEN);\n  map.put(TWO, TWENTY);\n  map.put(THREE, THIRTY);\n  \n  Iterator it = map.entrySet().iterator();\n  it.next();\n  Map.Entry entry = (Map.Entry) it.next();\n  entry.setValue(\"NewValue\");\n  assertEquals(3, map.size());\n  assertEquals(true, map.containsKey(ONE));\n  assertEquals(true, map.containsKey(TWO));\n  assertEquals(true, map.containsKey(THREE));\n  assertEquals(TEN, map.get(ONE));\n  assertEquals(\"NewValue\", map.get(TWO));\n  assertEquals(THIRTY, map.get(THREE));\n  }",
        "stack": [
          "TestFlat3Map.testEntryIteratorSetValue2 line 247"
        ]
      },
      {
        "methodName": "testEntryIteratorSetValue3",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<10> but was:<NewValue>",
        "fail_line": "        assertEquals(TEN, map.get(ONE));",
        "test_source": "  public void testEntryIteratorSetValue3() throws Exception {\n  Flat3Map map = new Flat3Map();\n  map.put(ONE, TEN);\n  map.put(TWO, TWENTY);\n  map.put(THREE, THIRTY);\n  \n  Iterator it = map.entrySet().iterator();\n  it.next();\n  it.next();\n  Map.Entry entry = (Map.Entry) it.next();\n  entry.setValue(\"NewValue\");\n  assertEquals(3, map.size());\n  assertEquals(true, map.containsKey(ONE));\n  assertEquals(true, map.containsKey(TWO));\n  assertEquals(true, map.containsKey(THREE));\n  assertEquals(TEN, map.get(ONE));\n  assertEquals(TWENTY, map.get(TWO));\n  assertEquals(\"NewValue\", map.get(THREE));\n  }",
        "stack": [
          "TestFlat3Map.testEntryIteratorSetValue3 line 267"
        ]
      },
      {
        "methodName": "testMapIteratorSetValue2",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<10> but was:<NewValue>",
        "fail_line": "        assertEquals(TEN, map.get(ONE));",
        "test_source": "  public void testMapIteratorSetValue2() throws Exception {\n  Flat3Map map = new Flat3Map();\n  map.put(ONE, TEN);\n  map.put(TWO, TWENTY);\n  map.put(THREE, THIRTY);\n  \n  MapIterator it = map.mapIterator();\n  it.next();\n  it.next();\n  it.setValue(\"NewValue\");\n  assertEquals(3, map.size());\n  assertEquals(true, map.containsKey(ONE));\n  assertEquals(true, map.containsKey(TWO));\n  assertEquals(true, map.containsKey(THREE));\n  assertEquals(TEN, map.get(ONE));\n  assertEquals(\"NewValue\", map.get(TWO));\n  assertEquals(THIRTY, map.get(THREE));\n  }",
        "stack": [
          "TestFlat3Map.testMapIteratorSetValue2 line 305"
        ]
      },
      {
        "methodName": "testMapIteratorSetValue3",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<10> but was:<NewValue>",
        "fail_line": "        assertEquals(TEN, map.get(ONE));",
        "test_source": "  public void testMapIteratorSetValue3() throws Exception {\n  Flat3Map map = new Flat3Map();\n  map.put(ONE, TEN);\n  map.put(TWO, TWENTY);\n  map.put(THREE, THIRTY);\n  \n  MapIterator it = map.mapIterator();\n  it.next();\n  it.next();\n  it.next();\n  it.setValue(\"NewValue\");\n  assertEquals(3, map.size());\n  assertEquals(true, map.containsKey(ONE));\n  assertEquals(true, map.containsKey(TWO));\n  assertEquals(true, map.containsKey(THREE));\n  assertEquals(TEN, map.get(ONE));\n  assertEquals(TWENTY, map.get(TWO));\n  assertEquals(\"NewValue\", map.get(THREE));\n  }",
        "stack": [
          "TestFlat3Map.testMapIteratorSetValue3 line 325"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/collections/map/Flat3Map.java",
      "buggy_full_code": "\npackage org.apache.commons.collections.map;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.AbstractCollection;\nimport java.util.AbstractSet;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport org.apache.commons.collections.IterableMap;\nimport org.apache.commons.collections.MapIterator;\nimport org.apache.commons.collections.ResettableIterator;\nimport org.apache.commons.collections.iterators.EmptyIterator;\nimport org.apache.commons.collections.iterators.EmptyMapIterator;\n\n\npublic class Flat3Map implements IterableMap, Serializable, Cloneable { private static final long serialVersionUID = -6701087419741928296L; private transient int size; private transient int hash1; private transient int hash2; private transient int hash3; private transient Object key1; private transient Object key2; private transient Object key3; private transient Object value1; private transient Object value2; private transient Object value3; private transient AbstractHashedMap delegateMap; public Flat3Map() {\n        super();\n    }\n\n    \n    public Flat3Map(Map map) {\n        super();\n        putAll(map);\n    }\n\n    \n    \n    public Object get(Object key) {\n        if (delegateMap != null) {\n            return delegateMap.get(key);\n        }\n        if (key == null) {\n            switch (size) {\n                \n                case 3:\n                    if (key3 == null) return value3;\n                case 2:\n                    if (key2 == null) return value2;\n                case 1:\n                    if (key1 == null) return value1;\n            }\n        } else {\n            if (size > 0) {\n                int hashCode = key.hashCode();\n                switch (size) {\n                    \n                    case 3:\n                        if (hash3 == hashCode && key.equals(key3)) return value3;\n                    case 2:\n                        if (hash2 == hashCode && key.equals(key2)) return value2;\n                    case 1:\n                        if (hash1 == hashCode && key.equals(key1)) return value1;\n                }\n            }\n        }\n        return null;\n    }\n\n    \n    public int size() {\n        if (delegateMap != null) {\n            return delegateMap.size();\n        }\n        return size;\n    }\n\n    \n    public boolean isEmpty() {\n        return (size() == 0);\n    }\n\n    \n    \n    public boolean containsKey(Object key) {\n        if (delegateMap != null) {\n            return delegateMap.containsKey(key);\n        }\n        if (key == null) {\n            switch (size) {  \n                case 3:\n                    if (key3 == null) return true;\n                case 2:\n                    if (key2 == null) return true;\n                case 1:\n                    if (key1 == null) return true;\n            }\n        } else {\n            if (size > 0) {\n                int hashCode = key.hashCode();\n                switch (size) {  \n                    case 3:\n                        if (hash3 == hashCode && key.equals(key3)) return true;\n                    case 2:\n                        if (hash2 == hashCode && key.equals(key2)) return true;\n                    case 1:\n                        if (hash1 == hashCode && key.equals(key1)) return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    \n    public boolean containsValue(Object value) {\n        if (delegateMap != null) {\n            return delegateMap.containsValue(value);\n        }\n        if (value == null) {  \n            switch (size) {\n                case 3:\n                    if (value3 == null) return true;\n                case 2:\n                    if (value2 == null) return true;\n                case 1:\n                    if (value1 == null) return true;\n            }\n        } else {\n            switch (size) {  \n                case 3:\n                    if (value.equals(value3)) return true;\n                case 2:\n                    if (value.equals(value2)) return true;\n                case 1:\n                    if (value.equals(value1)) return true;\n            }\n        }\n        return false;\n    }\n\n    \n    \n    public Object put(Object key, Object value) {\n        if (delegateMap != null) {\n            return delegateMap.put(key, value);\n        }\n        \n        if (key == null) {\n            switch (size) {  \n                case 3:\n                    if (key3 == null) {\n                        Object old = value3;\n                        value3 = value;\n                        return old;\n                    }\n                case 2:\n                    if (key2 == null) {\n                        Object old = value2;\n                        value2 = value;\n                        return old;\n                    }\n                case 1:\n                    if (key1 == null) {\n                        Object old = value1;\n                        value1 = value;\n                        return old;\n                    }\n            }\n        } else {\n            if (size > 0) {\n                int hashCode = key.hashCode();\n                switch (size) {  \n                    case 3:\n                        if (hash3 == hashCode && key.equals(key3)) {\n                            Object old = value3;\n                            value3 = value;\n                            return old;\n                        }\n                    case 2:\n                        if (hash2 == hashCode && key.equals(key2)) {\n                            Object old = value2;\n                            value2 = value;\n                            return old;\n                        }\n                    case 1:\n                        if (hash1 == hashCode && key.equals(key1)) {\n                            Object old = value1;\n                            value1 = value;\n                            return old;\n                        }\n                }\n            }\n        }\n        \n        \n        switch (size) {\n            default:\n                convertToMap();\n                delegateMap.put(key, value);\n                return null;\n            case 2:\n                hash3 = (key == null ? 0 : key.hashCode());\n                key3 = key;\n                value3 = value;\n                break;\n            case 1:\n                hash2 = (key == null ? 0 : key.hashCode());\n                key2 = key;\n                value2 = value;\n                break;\n            case 0:\n                hash1 = (key == null ? 0 : key.hashCode());\n                key1 = key;\n                value1 = value;\n                break;\n        }\n        size++;\n        return null;\n    }\n\n    \n    public void putAll(Map map) {\n        int size = map.size();\n        if (size == 0) {\n            return;\n        }\n        if (delegateMap != null) {\n            delegateMap.putAll(map);\n            return;\n        }\n        if (size < 4) {\n            for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n                Map.Entry entry = (Map.Entry) it.next();\n                put(entry.getKey(), entry.getValue());\n            }\n        } else {\n            convertToMap();\n            delegateMap.putAll(map);\n        }\n    }\n\n    \n    private void convertToMap() {\n        delegateMap = createDelegateMap();\n        switch (size) {  \n            case 3:\n                delegateMap.put(key3, value3);\n            case 2:\n                delegateMap.put(key2, value2);\n            case 1:\n                delegateMap.put(key1, value1);\n        }\n        \n        size = 0;\n        hash1 = hash2 = hash3 = 0;\n        key1 = key2 = key3 = null;\n        value1 = value2 = value3 = null;\n    }\n\n    \n    protected AbstractHashedMap createDelegateMap() {\n        return new HashedMap();\n    }\n\n    \n    public Object remove(Object key) {\n        if (delegateMap != null) {\n            return delegateMap.remove(key);\n        }\n        if (size == 0) {\n            return null;\n        }\n        if (key == null) {\n            switch (size) {  \n                case 3:\n                    if (key3 == null) {\n                        Object old = value3;\n                        hash3 = 0;\n                        key3 = null;\n                        value3 = null;\n                        size = 2;\n                        return old;\n                    }\n                    if (key2 == null) {\n                        Object old = value3;\n                        hash2 = hash3;\n                        key2 = key3;\n                        value2 = value3;\n                        hash3 = 0;\n                        key3 = null;\n                        value3 = null;\n                        size = 2;\n                        return old;\n                    }\n                    if (key1 == null) {\n                        Object old = value3;\n                        hash1 = hash3;\n                        key1 = key3;\n                        value1 = value3;\n                        hash3 = 0;\n                        key3 = null;\n                        value3 = null;\n                        size = 2;\n                        return old;\n                    }\n                    return null;\n                case 2:\n                    if (key2 == null) {\n                        Object old = value2;\n                        hash2 = 0;\n                        key2 = null;\n                        value2 = null;\n                        size = 1;\n                        return old;\n                    }\n                    if (key1 == null) {\n                        Object old = value2;\n                        hash1 = hash2;\n                        key1 = key2;\n                        value1 = value2;\n                        hash2 = 0;\n                        key2 = null;\n                        value2 = null;\n                        size = 1;\n                        return old;\n                    }\n                    return null;\n                case 1:\n                    if (key1 == null) {\n                        Object old = value1;\n                        hash1 = 0;\n                        key1 = null;\n                        value1 = null;\n                        size = 0;\n                        return old;\n                    }\n            }\n        } else {\n            if (size > 0) {\n                int hashCode = key.hashCode();\n                switch (size) {  \n                    case 3:\n                        if (hash3 == hashCode && key.equals(key3)) {\n                            Object old = value3;\n                            hash3 = 0;\n                            key3 = null;\n                            value3 = null;\n                            size = 2;\n                            return old;\n                        }\n                        if (hash2 == hashCode && key.equals(key2)) {\n                            Object old = value3;\n                            hash2 = hash3;\n                            key2 = key3;\n                            value2 = value3;\n                            hash3 = 0;\n                            key3 = null;\n                            value3 = null;\n                            size = 2;\n                            return old;\n                        }\n                        if (hash1 == hashCode && key.equals(key1)) {\n                            Object old = value3;\n                            hash1 = hash3;\n                            key1 = key3;\n                            value1 = value3;\n                            hash3 = 0;\n                            key3 = null;\n                            value3 = null;\n                            size = 2;\n                            return old;\n                        }\n                        return null;\n                    case 2:\n                        if (hash2 == hashCode && key.equals(key2)) {\n                            Object old = value2;\n                            hash2 = 0;\n                            key2 = null;\n                            value2 = null;\n                            size = 1;\n                            return old;\n                        }\n                        if (hash1 == hashCode && key.equals(key1)) {\n                            Object old = value2;\n                            hash1 = hash2;\n                            key1 = key2;\n                            value1 = value2;\n                            hash2 = 0;\n                            key2 = null;\n                            value2 = null;\n                            size = 1;\n                            return old;\n                        }\n                        return null;\n                    case 1:\n                        if (hash1 == hashCode && key.equals(key1)) {\n                            Object old = value1;\n                            hash1 = 0;\n                            key1 = null;\n                            value1 = null;\n                            size = 0;\n                            return old;\n                        }\n                }\n            }\n        }\n        return null;\n    }\n\n    \n    public void clear() {\n        if (delegateMap != null) {\n            delegateMap.clear();  \n            delegateMap = null;  \n        } else {\n            size = 0;\n            hash1 = hash2 = hash3 = 0;\n            key1 = key2 = key3 = null;\n            value1 = value2 = value3 = null;\n        }\n    }\n\n    \n    \n    public MapIterator mapIterator() {\n        if (delegateMap != null) {\n            return delegateMap.mapIterator();\n        }\n        if (size == 0) {\n            return EmptyMapIterator.INSTANCE;\n        }\n        return new FlatMapIterator(this);\n    }\n\n    \n    static class FlatMapIterator implements MapIterator, ResettableIterator { private final Flat3Map parent; private int nextIndex = 0; private boolean canRemove = false; FlatMapIterator(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public boolean hasNext() {\n            return (nextIndex < parent.size);\n        }\n\n        public Object next() {\n            if (hasNext() == false) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n            }\n            canRemove = true;\n            nextIndex++;\n            return getKey();\n        }\n\n        public void remove() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            parent.remove(getKey());\n            nextIndex--;\n            canRemove = false;\n        }\n\n        public Object getKey() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            switch (nextIndex) {\n                case 3:\n                    return parent.key3;\n                case 2:\n                    return parent.key2;\n                case 1:\n                    return parent.key1;\n            }\n            throw new IllegalStateException(\"Invalid map index\");\n        }\n\n        public Object getValue() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            switch (nextIndex) {\n                case 3:\n                    return parent.value3;\n                case 2:\n                    return parent.value2;\n                case 1:\n                    return parent.value1;\n            }\n            throw new IllegalStateException(\"Invalid map index\");\n        }\n\n        public Object setValue(Object value) {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            Object old = getValue();\n            switch (nextIndex) {\n                case 3: \n                    parent.value3 = value;\n                case 2:\n                    parent.value2 = value;\n                case 1:\n                    parent.value1 = value;\n            }\n            return old;\n        }\n        \n        public void reset() {\n            nextIndex = 0;\n            canRemove = false;\n        }\n        \n        public String toString() {\n            if (canRemove) {\n                return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n            } else {\n                return \"Iterator[]\";\n            }\n        }\n    }\n    \n    \n    public Set entrySet() {\n        if (delegateMap != null) {\n            return delegateMap.entrySet();\n        }\n        return new EntrySet(this);\n    }\n    \n    \n    static class EntrySet extends AbstractSet { private final Flat3Map parent; EntrySet(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public int size() {\n            return parent.size();\n        }\n        \n        public void clear() {\n            parent.clear();\n        }\n        \n        public boolean remove(Object obj) {\n            if (obj instanceof Map.Entry == false) {\n                return false;\n            }\n            Map.Entry entry = (Map.Entry) obj;\n            Object key = entry.getKey();\n            boolean result = parent.containsKey(key);\n            parent.remove(key);\n            return result;\n        }\n\n        public Iterator iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.entrySet().iterator();\n            }\n            if (parent.size() == 0) {\n                return EmptyIterator.INSTANCE;\n            }\n            return new EntrySetIterator(parent);\n        }\n    }\n\n    \n    static class EntrySetIterator implements Iterator, Map.Entry { private final Flat3Map parent; private int nextIndex = 0; private boolean canRemove = false; EntrySetIterator(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public boolean hasNext() {\n            return (nextIndex < parent.size);\n        }\n\n        public Object next() {\n            if (hasNext() == false) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n            }\n            canRemove = true;\n            nextIndex++;\n            return this;\n        }\n\n        public void remove() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            parent.remove(getKey());\n            nextIndex--;\n            canRemove = false;\n        }\n\n        public Object getKey() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            switch (nextIndex) {\n                case 3:\n                    return parent.key3;\n                case 2:\n                    return parent.key2;\n                case 1:\n                    return parent.key1;\n            }\n            throw new IllegalStateException(\"Invalid map index\");\n        }\n\n        public Object getValue() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            switch (nextIndex) {\n                case 3:\n                    return parent.value3;\n                case 2:\n                    return parent.value2;\n                case 1:\n                    return parent.value1;\n            }\n            throw new IllegalStateException(\"Invalid map index\");\n        }\n\n        public Object setValue(Object value) {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            Object old = getValue();\n            switch (nextIndex) {\n                case 3: \n                    parent.value3 = value;\n                case 2:\n                    parent.value2 = value;\n                case 1:\n                    parent.value1 = value;\n            }\n            return old;\n        }\n        \n        public boolean equals(Object obj) {\n            if (canRemove == false) {\n                return false;\n            }\n            if (obj instanceof Map.Entry == false) {\n                return false;\n            }\n            Map.Entry other = (Map.Entry) obj;\n            Object key = getKey();\n            Object value = getValue();\n            return (key == null ? other.getKey() == null : key.equals(other.getKey())) &&\n                   (value == null ? other.getValue() == null : value.equals(other.getValue()));\n        }\n        \n        public int hashCode() {\n            if (canRemove == false) {\n                return 0;\n            }\n            Object key = getKey();\n            Object value = getValue();\n            return (key == null ? 0 : key.hashCode()) ^\n                   (value == null ? 0 : value.hashCode());\n        }\n        \n        public String toString() {\n            if (canRemove) {\n                return getKey() + \"=\" + getValue();\n            } else {\n                return \"\";\n            }\n        }\n    }\n    \n    \n    public Set keySet() {\n        if (delegateMap != null) {\n            return delegateMap.keySet();\n        }\n        return new KeySet(this);\n    }\n\n    \n    static class KeySet extends AbstractSet { private final Flat3Map parent; KeySet(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public int size() {\n            return parent.size();\n        }\n        \n        public void clear() {\n            parent.clear();\n        }\n        \n        public boolean contains(Object key) {\n            return parent.containsKey(key);\n        }\n\n        public boolean remove(Object key) {\n            boolean result = parent.containsKey(key);\n            parent.remove(key);\n            return result;\n        }\n\n        public Iterator iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.keySet().iterator();\n            }\n            if (parent.size() == 0) {\n                return EmptyIterator.INSTANCE;\n            }\n            return new KeySetIterator(parent);\n        }\n    }\n\n    \n    static class KeySetIterator extends EntrySetIterator { KeySetIterator(Flat3Map parent) {\n            super(parent);\n        }\n\n        public Object next() {\n            super.next();\n            return getKey();\n        }\n    }\n    \n    \n    public Collection values() {\n        if (delegateMap != null) {\n            return delegateMap.values();\n        }\n        return new Values(this);\n    }\n\n    \n    static class Values extends AbstractCollection { private final Flat3Map parent; Values(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public int size() {\n            return parent.size();\n        }\n        \n        public void clear() {\n            parent.clear();\n        }\n        \n        public boolean contains(Object value) {\n            return parent.containsValue(value);\n        }\n\n        public Iterator iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.values().iterator();\n            }\n            if (parent.size() == 0) {\n                return EmptyIterator.INSTANCE;\n            }\n            return new ValuesIterator(parent);\n        }\n    }\n\n    \n    static class ValuesIterator extends EntrySetIterator { ValuesIterator(Flat3Map parent) {\n            super(parent);\n        }\n\n        public Object next() {\n            super.next();\n            return getValue();\n        }\n    }\n\n    \n    \n    private void writeObject(ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeInt(size());\n        for (MapIterator it = mapIterator(); it.hasNext();) {\n            out.writeObject(it.next());  \n            out.writeObject(it.getValue());  \n        }\n    }\n\n    \n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        int count = in.readInt();\n        if (count > 3) {\n            delegateMap = createDelegateMap();\n        }\n        for (int i = count; i > 0; i--) {\n            put(in.readObject(), in.readObject());\n        }\n    }\n\n    \n    \n    public Object clone() {\n        try {\n            Flat3Map cloned = (Flat3Map) super.clone();\n            if (cloned.delegateMap != null) {\n                cloned.delegateMap = (HashedMap) cloned.delegateMap.clone();\n            }\n            return cloned;\n        } catch (CloneNotSupportedException ex) {\n            throw new InternalError();\n        }\n    }\n\n    \n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (delegateMap != null) {\n            return delegateMap.equals(obj);\n        }\n        if (obj instanceof Map == false) {\n            return false;\n        }\n        Map other = (Map) obj;\n        if (size != other.size()) {\n            return false;\n        }\n        if (size > 0) {\n            Object otherValue = null;\n            switch (size) {  \n                case 3:\n                    if (other.containsKey(key3) == false) {\n                        return false;\n                    }\n                    otherValue = other.get(key3);\n                    if (value3 == null ? otherValue != null : !value3.equals(otherValue)) {\n                        return false;\n                    }\n                case 2:\n                    if (other.containsKey(key2) == false) {\n                        return false;\n                    }\n                    otherValue = other.get(key2);\n                    if (value2 == null ? otherValue != null : !value2.equals(otherValue)) {\n                        return false;\n                    }\n                case 1:\n                    if (other.containsKey(key1) == false) {\n                        return false;\n                    }\n                    otherValue = other.get(key1);\n                    if (value1 == null ? otherValue != null : !value1.equals(otherValue)) {\n                        return false;\n                    }\n            }\n        }\n        return true;\n    }\n\n    \n    public int hashCode() {\n        if (delegateMap != null) {\n            return delegateMap.hashCode();\n        }\n        int total = 0;\n        switch (size) {  \n            case 3:\n                total += (hash3 ^ (value3 == null ? 0 : value3.hashCode()));\n            case 2:\n                total += (hash2 ^ (value2 == null ? 0 : value2.hashCode()));\n            case 1:\n                total += (hash1 ^ (value1 == null ? 0 : value1.hashCode()));\n        }\n        return total;\n    }\n\n    \n    public String toString() {\n        if (delegateMap != null) {\n            return delegateMap.toString();\n        }\n        if (size == 0) {\n            return \"{}\";\n        }\n        StringBuffer buf = new StringBuffer(128);\n        buf.append('{');\n        switch (size) {  \n            case 3:\n                buf.append((key3 == this ? \"(this Map)\" : key3));\n                buf.append('=');\n                buf.append((value3 == this ? \"(this Map)\" : value3));\n                buf.append(',');\n            case 2:\n                buf.append((key2 == this ? \"(this Map)\" : key2));\n                buf.append('=');\n                buf.append((value2 == this ? \"(this Map)\" : value2));\n                buf.append(',');\n            case 1:\n                buf.append((key1 == this ? \"(this Map)\" : key1));\n                buf.append('=');\n                buf.append((value1 == this ? \"(this Map)\" : value1));\n        }\n        buf.append('}');\n        return buf.toString();\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.collections.map;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.AbstractCollection;\nimport java.util.AbstractSet;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport org.apache.commons.collections.IterableMap;\nimport org.apache.commons.collections.MapIterator;\nimport org.apache.commons.collections.ResettableIterator;\nimport org.apache.commons.collections.iterators.EmptyIterator;\nimport org.apache.commons.collections.iterators.EmptyMapIterator;\n\n\npublic class Flat3Map implements IterableMap, Serializable, Cloneable { private static final long serialVersionUID = -6701087419741928296L; private transient int size; private transient int hash1; private transient int hash2; private transient int hash3; private transient Object key1; private transient Object key2; private transient Object key3; private transient Object value1; private transient Object value2; private transient Object value3; private transient AbstractHashedMap delegateMap; public Flat3Map() {\n        super();\n    }\n\n    \n    public Flat3Map(Map map) {\n        super();\n        putAll(map);\n    }\n\n    \n    \n    public Object get(Object key) {\n        if (delegateMap != null) {\n            return delegateMap.get(key);\n        }\n        if (key == null) {\n            switch (size) {\n                \n                case 3:\n                    if (key3 == null) return value3;\n                case 2:\n                    if (key2 == null) return value2;\n                case 1:\n                    if (key1 == null) return value1;\n            }\n        } else {\n            if (size > 0) {\n                int hashCode = key.hashCode();\n                switch (size) {\n                    \n                    case 3:\n                        if (hash3 == hashCode && key.equals(key3)) return value3;\n                    case 2:\n                        if (hash2 == hashCode && key.equals(key2)) return value2;\n                    case 1:\n                        if (hash1 == hashCode && key.equals(key1)) return value1;\n                }\n            }\n        }\n        return null;\n    }\n\n    \n    public int size() {\n        if (delegateMap != null) {\n            return delegateMap.size();\n        }\n        return size;\n    }\n\n    \n    public boolean isEmpty() {\n        return (size() == 0);\n    }\n\n    \n    \n    public boolean containsKey(Object key) {\n        if (delegateMap != null) {\n            return delegateMap.containsKey(key);\n        }\n        if (key == null) {\n            switch (size) {  \n                case 3:\n                    if (key3 == null) return true;\n                case 2:\n                    if (key2 == null) return true;\n                case 1:\n                    if (key1 == null) return true;\n            }\n        } else {\n            if (size > 0) {\n                int hashCode = key.hashCode();\n                switch (size) {  \n                    case 3:\n                        if (hash3 == hashCode && key.equals(key3)) return true;\n                    case 2:\n                        if (hash2 == hashCode && key.equals(key2)) return true;\n                    case 1:\n                        if (hash1 == hashCode && key.equals(key1)) return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    \n    public boolean containsValue(Object value) {\n        if (delegateMap != null) {\n            return delegateMap.containsValue(value);\n        }\n        if (value == null) {  \n            switch (size) {\n                case 3:\n                    if (value3 == null) return true;\n                case 2:\n                    if (value2 == null) return true;\n                case 1:\n                    if (value1 == null) return true;\n            }\n        } else {\n            switch (size) {  \n                case 3:\n                    if (value.equals(value3)) return true;\n                case 2:\n                    if (value.equals(value2)) return true;\n                case 1:\n                    if (value.equals(value1)) return true;\n            }\n        }\n        return false;\n    }\n\n    \n    \n    public Object put(Object key, Object value) {\n        if (delegateMap != null) {\n            return delegateMap.put(key, value);\n        }\n        \n        if (key == null) {\n            switch (size) {  \n                case 3:\n                    if (key3 == null) {\n                        Object old = value3;\n                        value3 = value;\n                        return old;\n                    }\n                case 2:\n                    if (key2 == null) {\n                        Object old = value2;\n                        value2 = value;\n                        return old;\n                    }\n                case 1:\n                    if (key1 == null) {\n                        Object old = value1;\n                        value1 = value;\n                        return old;\n                    }\n            }\n        } else {\n            if (size > 0) {\n                int hashCode = key.hashCode();\n                switch (size) {  \n                    case 3:\n                        if (hash3 == hashCode && key.equals(key3)) {\n                            Object old = value3;\n                            value3 = value;\n                            return old;\n                        }\n                    case 2:\n                        if (hash2 == hashCode && key.equals(key2)) {\n                            Object old = value2;\n                            value2 = value;\n                            return old;\n                        }\n                    case 1:\n                        if (hash1 == hashCode && key.equals(key1)) {\n                            Object old = value1;\n                            value1 = value;\n                            return old;\n                        }\n                }\n            }\n        }\n        \n        \n        switch (size) {\n            default:\n                convertToMap();\n                delegateMap.put(key, value);\n                return null;\n            case 2:\n                hash3 = (key == null ? 0 : key.hashCode());\n                key3 = key;\n                value3 = value;\n                break;\n            case 1:\n                hash2 = (key == null ? 0 : key.hashCode());\n                key2 = key;\n                value2 = value;\n                break;\n            case 0:\n                hash1 = (key == null ? 0 : key.hashCode());\n                key1 = key;\n                value1 = value;\n                break;\n        }\n        size++;\n        return null;\n    }\n\n    \n    public void putAll(Map map) {\n        int size = map.size();\n        if (size == 0) {\n            return;\n        }\n        if (delegateMap != null) {\n            delegateMap.putAll(map);\n            return;\n        }\n        if (size < 4) {\n            for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n                Map.Entry entry = (Map.Entry) it.next();\n                put(entry.getKey(), entry.getValue());\n            }\n        } else {\n            convertToMap();\n            delegateMap.putAll(map);\n        }\n    }\n\n    \n    private void convertToMap() {\n        delegateMap = createDelegateMap();\n        switch (size) {  \n            case 3:\n                delegateMap.put(key3, value3);\n            case 2:\n                delegateMap.put(key2, value2);\n            case 1:\n                delegateMap.put(key1, value1);\n        }\n        \n        size = 0;\n        hash1 = hash2 = hash3 = 0;\n        key1 = key2 = key3 = null;\n        value1 = value2 = value3 = null;\n    }\n\n    \n    protected AbstractHashedMap createDelegateMap() {\n        return new HashedMap();\n    }\n\n    \n    public Object remove(Object key) {\n        if (delegateMap != null) {\n            return delegateMap.remove(key);\n        }\n        if (size == 0) {\n            return null;\n        }\n        if (key == null) {\n            switch (size) {  \n                case 3:\n                    if (key3 == null) {\n                        Object old = value3;\n                        hash3 = 0;\n                        key3 = null;\n                        value3 = null;\n                        size = 2;\n                        return old;\n                    }\n                    if (key2 == null) {\n                        Object old = value3;\n                        hash2 = hash3;\n                        key2 = key3;\n                        value2 = value3;\n                        hash3 = 0;\n                        key3 = null;\n                        value3 = null;\n                        size = 2;\n                        return old;\n                    }\n                    if (key1 == null) {\n                        Object old = value3;\n                        hash1 = hash3;\n                        key1 = key3;\n                        value1 = value3;\n                        hash3 = 0;\n                        key3 = null;\n                        value3 = null;\n                        size = 2;\n                        return old;\n                    }\n                    return null;\n                case 2:\n                    if (key2 == null) {\n                        Object old = value2;\n                        hash2 = 0;\n                        key2 = null;\n                        value2 = null;\n                        size = 1;\n                        return old;\n                    }\n                    if (key1 == null) {\n                        Object old = value2;\n                        hash1 = hash2;\n                        key1 = key2;\n                        value1 = value2;\n                        hash2 = 0;\n                        key2 = null;\n                        value2 = null;\n                        size = 1;\n                        return old;\n                    }\n                    return null;\n                case 1:\n                    if (key1 == null) {\n                        Object old = value1;\n                        hash1 = 0;\n                        key1 = null;\n                        value1 = null;\n                        size = 0;\n                        return old;\n                    }\n            }\n        } else {\n            if (size > 0) {\n                int hashCode = key.hashCode();\n                switch (size) {  \n                    case 3:\n                        if (hash3 == hashCode && key.equals(key3)) {\n                            Object old = value3;\n                            hash3 = 0;\n                            key3 = null;\n                            value3 = null;\n                            size = 2;\n                            return old;\n                        }\n                        if (hash2 == hashCode && key.equals(key2)) {\n                            Object old = value3;\n                            hash2 = hash3;\n                            key2 = key3;\n                            value2 = value3;\n                            hash3 = 0;\n                            key3 = null;\n                            value3 = null;\n                            size = 2;\n                            return old;\n                        }\n                        if (hash1 == hashCode && key.equals(key1)) {\n                            Object old = value3;\n                            hash1 = hash3;\n                            key1 = key3;\n                            value1 = value3;\n                            hash3 = 0;\n                            key3 = null;\n                            value3 = null;\n                            size = 2;\n                            return old;\n                        }\n                        return null;\n                    case 2:\n                        if (hash2 == hashCode && key.equals(key2)) {\n                            Object old = value2;\n                            hash2 = 0;\n                            key2 = null;\n                            value2 = null;\n                            size = 1;\n                            return old;\n                        }\n                        if (hash1 == hashCode && key.equals(key1)) {\n                            Object old = value2;\n                            hash1 = hash2;\n                            key1 = key2;\n                            value1 = value2;\n                            hash2 = 0;\n                            key2 = null;\n                            value2 = null;\n                            size = 1;\n                            return old;\n                        }\n                        return null;\n                    case 1:\n                        if (hash1 == hashCode && key.equals(key1)) {\n                            Object old = value1;\n                            hash1 = 0;\n                            key1 = null;\n                            value1 = null;\n                            size = 0;\n                            return old;\n                        }\n                }\n            }\n        }\n        return null;\n    }\n\n    \n    public void clear() {\n        if (delegateMap != null) {\n            delegateMap.clear();  \n            delegateMap = null;  \n        } else {\n            size = 0;\n            hash1 = hash2 = hash3 = 0;\n            key1 = key2 = key3 = null;\n            value1 = value2 = value3 = null;\n        }\n    }\n\n    \n    \n    public MapIterator mapIterator() {\n        if (delegateMap != null) {\n            return delegateMap.mapIterator();\n        }\n        if (size == 0) {\n            return EmptyMapIterator.INSTANCE;\n        }\n        return new FlatMapIterator(this);\n    }\n\n    \n    static class FlatMapIterator implements MapIterator, ResettableIterator { private final Flat3Map parent; private int nextIndex = 0; private boolean canRemove = false; FlatMapIterator(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public boolean hasNext() {\n            return (nextIndex < parent.size);\n        }\n\n        public Object next() {\n            if (hasNext() == false) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n            }\n            canRemove = true;\n            nextIndex++;\n            return getKey();\n        }\n\n        public void remove() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            parent.remove(getKey());\n            nextIndex--;\n            canRemove = false;\n        }\n\n        public Object getKey() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            switch (nextIndex) {\n                case 3:\n                    return parent.key3;\n                case 2:\n                    return parent.key2;\n                case 1:\n                    return parent.key1;\n            }\n            throw new IllegalStateException(\"Invalid map index\");\n        }\n\n        public Object getValue() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            switch (nextIndex) {\n                case 3:\n                    return parent.value3;\n                case 2:\n                    return parent.value2;\n                case 1:\n                    return parent.value1;\n            }\n            throw new IllegalStateException(\"Invalid map index\");\n        }\n\n        public Object setValue(Object value) {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            Object old = getValue();\n            switch (nextIndex) {\n                case 3: \n                    parent.value3 = value;\n                    break;\n                case 2:\n                    parent.value2 = value;\n                    break;\n                case 1:\n                    parent.value1 = value;\n                    break;\n            }\n            return old;\n        }\n        \n        public void reset() {\n            nextIndex = 0;\n            canRemove = false;\n        }\n        \n        public String toString() {\n            if (canRemove) {\n                return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n            } else {\n                return \"Iterator[]\";\n            }\n        }\n    }\n    \n    \n    public Set entrySet() {\n        if (delegateMap != null) {\n            return delegateMap.entrySet();\n        }\n        return new EntrySet(this);\n    }\n    \n    \n    static class EntrySet extends AbstractSet { private final Flat3Map parent; EntrySet(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public int size() {\n            return parent.size();\n        }\n        \n        public void clear() {\n            parent.clear();\n        }\n        \n        public boolean remove(Object obj) {\n            if (obj instanceof Map.Entry == false) {\n                return false;\n            }\n            Map.Entry entry = (Map.Entry) obj;\n            Object key = entry.getKey();\n            boolean result = parent.containsKey(key);\n            parent.remove(key);\n            return result;\n        }\n\n        public Iterator iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.entrySet().iterator();\n            }\n            if (parent.size() == 0) {\n                return EmptyIterator.INSTANCE;\n            }\n            return new EntrySetIterator(parent);\n        }\n    }\n\n    \n    static class EntrySetIterator implements Iterator, Map.Entry { private final Flat3Map parent; private int nextIndex = 0; private boolean canRemove = false; EntrySetIterator(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public boolean hasNext() {\n            return (nextIndex < parent.size);\n        }\n\n        public Object next() {\n            if (hasNext() == false) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n            }\n            canRemove = true;\n            nextIndex++;\n            return this;\n        }\n\n        public void remove() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            parent.remove(getKey());\n            nextIndex--;\n            canRemove = false;\n        }\n\n        public Object getKey() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            switch (nextIndex) {\n                case 3:\n                    return parent.key3;\n                case 2:\n                    return parent.key2;\n                case 1:\n                    return parent.key1;\n            }\n            throw new IllegalStateException(\"Invalid map index\");\n        }\n\n        public Object getValue() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            switch (nextIndex) {\n                case 3:\n                    return parent.value3;\n                case 2:\n                    return parent.value2;\n                case 1:\n                    return parent.value1;\n            }\n            throw new IllegalStateException(\"Invalid map index\");\n        }\n\n        public Object setValue(Object value) {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            Object old = getValue();\n            switch (nextIndex) {\n                case 3: \n                    parent.value3 = value;\n                    break;\n                case 2:\n                    parent.value2 = value;\n                    break;\n                case 1:\n                    parent.value1 = value;\n                    break;\n            }\n            return old;\n        }\n        \n        public boolean equals(Object obj) {\n            if (canRemove == false) {\n                return false;\n            }\n            if (obj instanceof Map.Entry == false) {\n                return false;\n            }\n            Map.Entry other = (Map.Entry) obj;\n            Object key = getKey();\n            Object value = getValue();\n            return (key == null ? other.getKey() == null : key.equals(other.getKey())) &&\n                   (value == null ? other.getValue() == null : value.equals(other.getValue()));\n        }\n        \n        public int hashCode() {\n            if (canRemove == false) {\n                return 0;\n            }\n            Object key = getKey();\n            Object value = getValue();\n            return (key == null ? 0 : key.hashCode()) ^\n                   (value == null ? 0 : value.hashCode());\n        }\n        \n        public String toString() {\n            if (canRemove) {\n                return getKey() + \"=\" + getValue();\n            } else {\n                return \"\";\n            }\n        }\n    }\n    \n    \n    public Set keySet() {\n        if (delegateMap != null) {\n            return delegateMap.keySet();\n        }\n        return new KeySet(this);\n    }\n\n    \n    static class KeySet extends AbstractSet { private final Flat3Map parent; KeySet(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public int size() {\n            return parent.size();\n        }\n        \n        public void clear() {\n            parent.clear();\n        }\n        \n        public boolean contains(Object key) {\n            return parent.containsKey(key);\n        }\n\n        public boolean remove(Object key) {\n            boolean result = parent.containsKey(key);\n            parent.remove(key);\n            return result;\n        }\n\n        public Iterator iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.keySet().iterator();\n            }\n            if (parent.size() == 0) {\n                return EmptyIterator.INSTANCE;\n            }\n            return new KeySetIterator(parent);\n        }\n    }\n\n    \n    static class KeySetIterator extends EntrySetIterator { KeySetIterator(Flat3Map parent) {\n            super(parent);\n        }\n\n        public Object next() {\n            super.next();\n            return getKey();\n        }\n    }\n    \n    \n    public Collection values() {\n        if (delegateMap != null) {\n            return delegateMap.values();\n        }\n        return new Values(this);\n    }\n\n    \n    static class Values extends AbstractCollection { private final Flat3Map parent; Values(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public int size() {\n            return parent.size();\n        }\n        \n        public void clear() {\n            parent.clear();\n        }\n        \n        public boolean contains(Object value) {\n            return parent.containsValue(value);\n        }\n\n        public Iterator iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.values().iterator();\n            }\n            if (parent.size() == 0) {\n                return EmptyIterator.INSTANCE;\n            }\n            return new ValuesIterator(parent);\n        }\n    }\n\n    \n    static class ValuesIterator extends EntrySetIterator { ValuesIterator(Flat3Map parent) {\n            super(parent);\n        }\n\n        public Object next() {\n            super.next();\n            return getValue();\n        }\n    }\n\n    \n    \n    private void writeObject(ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeInt(size());\n        for (MapIterator it = mapIterator(); it.hasNext();) {\n            out.writeObject(it.next());  \n            out.writeObject(it.getValue());  \n        }\n    }\n\n    \n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        int count = in.readInt();\n        if (count > 3) {\n            delegateMap = createDelegateMap();\n        }\n        for (int i = count; i > 0; i--) {\n            put(in.readObject(), in.readObject());\n        }\n    }\n\n    \n    \n    public Object clone() {\n        try {\n            Flat3Map cloned = (Flat3Map) super.clone();\n            if (cloned.delegateMap != null) {\n                cloned.delegateMap = (HashedMap) cloned.delegateMap.clone();\n            }\n            return cloned;\n        } catch (CloneNotSupportedException ex) {\n            throw new InternalError();\n        }\n    }\n\n    \n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (delegateMap != null) {\n            return delegateMap.equals(obj);\n        }\n        if (obj instanceof Map == false) {\n            return false;\n        }\n        Map other = (Map) obj;\n        if (size != other.size()) {\n            return false;\n        }\n        if (size > 0) {\n            Object otherValue = null;\n            switch (size) {  \n                case 3:\n                    if (other.containsKey(key3) == false) {\n                        return false;\n                    }\n                    otherValue = other.get(key3);\n                    if (value3 == null ? otherValue != null : !value3.equals(otherValue)) {\n                        return false;\n                    }\n                case 2:\n                    if (other.containsKey(key2) == false) {\n                        return false;\n                    }\n                    otherValue = other.get(key2);\n                    if (value2 == null ? otherValue != null : !value2.equals(otherValue)) {\n                        return false;\n                    }\n                case 1:\n                    if (other.containsKey(key1) == false) {\n                        return false;\n                    }\n                    otherValue = other.get(key1);\n                    if (value1 == null ? otherValue != null : !value1.equals(otherValue)) {\n                        return false;\n                    }\n            }\n        }\n        return true;\n    }\n\n    \n    public int hashCode() {\n        if (delegateMap != null) {\n            return delegateMap.hashCode();\n        }\n        int total = 0;\n        switch (size) {  \n            case 3:\n                total += (hash3 ^ (value3 == null ? 0 : value3.hashCode()));\n            case 2:\n                total += (hash2 ^ (value2 == null ? 0 : value2.hashCode()));\n            case 1:\n                total += (hash1 ^ (value1 == null ? 0 : value1.hashCode()));\n        }\n        return total;\n    }\n\n    \n    public String toString() {\n        if (delegateMap != null) {\n            return delegateMap.toString();\n        }\n        if (size == 0) {\n            return \"{}\";\n        }\n        StringBuffer buf = new StringBuffer(128);\n        buf.append('{');\n        switch (size) {  \n            case 3:\n                buf.append((key3 == this ? \"(this Map)\" : key3));\n                buf.append('=');\n                buf.append((value3 == this ? \"(this Map)\" : value3));\n                buf.append(',');\n            case 2:\n                buf.append((key2 == this ? \"(this Map)\" : key2));\n                buf.append('=');\n                buf.append((value2 == this ? \"(this Map)\" : value2));\n                buf.append(',');\n            case 1:\n                buf.append((key1 == this ? \"(this Map)\" : key1));\n                buf.append('=');\n                buf.append((value1 == this ? \"(this Map)\" : value1));\n        }\n        buf.append('}');\n        return buf.toString();\n    }\n\n}\n",
      "buggy_signatures": [
        "public Flat3Map(Map map)",
        "public Object get(Object key)",
        "public int size()",
        "public boolean isEmpty()",
        "public boolean containsKey(Object key)",
        "public boolean containsValue(Object value)",
        "public Object put(Object key, Object value)",
        "public void putAll(Map map)",
        "private void convertToMap()",
        "protected AbstractHashedMap createDelegateMap()",
        "public Object remove(Object key)",
        "public void clear()",
        "public MapIterator mapIterator()",
        "public boolean hasNext()",
        "public Object next()",
        "public void remove()",
        "public Object getKey()",
        "public Object getValue()",
        "public Object setValue(Object value)",
        "public void reset()",
        "public String toString()",
        "public Set entrySet()",
        "static class EntrySet extends AbstractSet { private final Flat3Map parent; EntrySet(Flat3Map parent)",
        "public int size()",
        "public void clear()",
        "public boolean remove(Object obj)",
        "public Iterator iterator()",
        "public boolean hasNext()",
        "public Object next()",
        "public void remove()",
        "public Object getKey()",
        "public Object getValue()",
        "public Object setValue(Object value)",
        "public boolean equals(Object obj)",
        "public int hashCode()",
        "public String toString()",
        "public Set keySet()",
        "static class KeySet extends AbstractSet { private final Flat3Map parent; KeySet(Flat3Map parent)",
        "public int size()",
        "public void clear()",
        "public boolean contains(Object key)",
        "public boolean remove(Object key)",
        "public Iterator iterator()",
        "static class KeySetIterator extends EntrySetIterator { KeySetIterator(Flat3Map parent)",
        "public Object next()",
        "public Collection values()",
        "static class Values extends AbstractCollection { private final Flat3Map parent; Values(Flat3Map parent)",
        "public int size()",
        "public void clear()",
        "public boolean contains(Object value)",
        "public Iterator iterator()",
        "static class ValuesIterator extends EntrySetIterator { ValuesIterator(Flat3Map parent)",
        "public Object next()",
        "private void writeObject(ObjectOutputStream out) throws IOException",
        "private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException",
        "public Object clone()",
        "public boolean equals(Object obj)",
        "public int hashCode()",
        "public String toString()"
      ],
      "fixed_signatures": [
        "public Flat3Map(Map map)",
        "public Object get(Object key)",
        "public int size()",
        "public boolean isEmpty()",
        "public boolean containsKey(Object key)",
        "public boolean containsValue(Object value)",
        "public Object put(Object key, Object value)",
        "public void putAll(Map map)",
        "private void convertToMap()",
        "protected AbstractHashedMap createDelegateMap()",
        "public Object remove(Object key)",
        "public void clear()",
        "public MapIterator mapIterator()",
        "public boolean hasNext()",
        "public Object next()",
        "public void remove()",
        "public Object getKey()",
        "public Object getValue()",
        "public Object setValue(Object value)",
        "public void reset()",
        "public String toString()",
        "public Set entrySet()",
        "static class EntrySet extends AbstractSet { private final Flat3Map parent; EntrySet(Flat3Map parent)",
        "public int size()",
        "public void clear()",
        "public boolean remove(Object obj)",
        "public Iterator iterator()",
        "public boolean hasNext()",
        "public Object next()",
        "public void remove()",
        "public Object getKey()",
        "public Object getValue()",
        "public Object setValue(Object value)",
        "public boolean equals(Object obj)",
        "public int hashCode()",
        "public String toString()",
        "public Set keySet()",
        "static class KeySet extends AbstractSet { private final Flat3Map parent; KeySet(Flat3Map parent)",
        "public int size()",
        "public void clear()",
        "public boolean contains(Object key)",
        "public boolean remove(Object key)",
        "public Iterator iterator()",
        "static class KeySetIterator extends EntrySetIterator { KeySetIterator(Flat3Map parent)",
        "public Object next()",
        "public Collection values()",
        "static class Values extends AbstractCollection { private final Flat3Map parent; Values(Flat3Map parent)",
        "public int size()",
        "public void clear()",
        "public boolean contains(Object value)",
        "public Iterator iterator()",
        "static class ValuesIterator extends EntrySetIterator { ValuesIterator(Flat3Map parent)",
        "public Object next()",
        "private void writeObject(ObjectOutputStream out) throws IOException",
        "private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException",
        "public Object clone()",
        "public boolean equals(Object obj)",
        "public int hashCode()",
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "  public Object setValue(Object value) {\n  if (canRemove == false) {\n  throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n  }\n  Object old = getValue();\n  switch (nextIndex) {\n  case 3: \n  parent.value3 = value;\n  case 2:\n  parent.value2 = value;\n  case 1:\n  parent.value1 = value;\n  }\n  return old;\n  }",
          "fixed_method": "  public Object setValue(Object value) {\n  if (canRemove == false) {\n  throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n  }\n  Object old = getValue();\n  switch (nextIndex) {\n  case 3: \n  parent.value3 = value;\n  break;\n  case 2:\n  parent.value2 = value;\n  break;\n  case 1:\n  parent.value1 = value;\n  break;\n  }\n  return old;\n  }",
          "diff": [
            "@@ -651,10 +651,13 @@",
            "             switch (nextIndex) {\n",
            "                 case 3: \n",
            "                     parent.value3 = value;\n",
            "+                    break;\n",
            "                 case 2:\n",
            "                     parent.value2 = value;\n",
            "+                    break;\n",
            "                 case 1:\n",
            "                     parent.value1 = value;\n",
            "+                    break;\n",
            "             }\n",
            "             return old;\n",
            "         }\n",
            "@@ -803,10 +806,13 @@",
            "             switch (nextIndex) {\n",
            "                 case 3: \n",
            "                     parent.value3 = value;\n",
            "+                    break;\n",
            "                 case 2:\n",
            "                     parent.value2 = value;\n",
            "+                    break;\n",
            "                 case 1:\n",
            "                     parent.value1 = value;\n",
            "+                    break;\n",
            "             }\n",
            "             return old;\n",
            "         }\n"
          ],
          "changed_lines": 6
        }
      ]
    }
  ]
}
