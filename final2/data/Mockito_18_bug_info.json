{
  "bug_id": "18",
  "failed_tests": {
    "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValuesTest": [
      {
        "methodName": "should_return_empty_iterable",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "        assertFalse(((Iterable) values.returnValueFor(Iterable.class)).iterator().hasNext());",
        "test_source": "  public void should_return_empty_iterable() throws Exception {\n  assertFalse(((Iterable) values.returnValueFor(Iterable.class)).iterator().hasNext());\n  }",
        "stack": [
          "ReturnsEmptyValuesTest.should_return_empty_iterable line 57"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java",
      "buggy_full_code": "\n\npackage org.mockito.internal.stubbing.defaultanswers;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.SortedSet;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.internal.util.ObjectMethodsGuru;\nimport org.mockito.internal.util.Primitives;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.mock.MockName;\nimport org.mockito.stubbing.Answer;\n\n\npublic class ReturnsEmptyValues implements Answer<Object>, Serializable { private static final long serialVersionUID = 1998191268711234347L; ObjectMethodsGuru methodsGuru = new ObjectMethodsGuru(); MockUtil mockUtil = new MockUtil(); public Object answer(InvocationOnMock invocation) {\n        if (methodsGuru.isToString(invocation.getMethod())) {\n            Object mock = invocation.getMock();\n            MockName name = mockUtil.getMockName(mock);\n            if (name.isDefault()) {\n                return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n            } else {\n                return name.toString();\n            }\n        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n            \n            \n            \n            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;\n        }\n        \n        Class<?> returnType = invocation.getMethod().getReturnType();\n        return returnValueFor(returnType);\n    }\n    \n    Object returnValueFor(Class<?> type) {\n        if (Primitives.isPrimitiveOrWrapper(type)) {\n            return Primitives.defaultValueForPrimitiveOrWrapper(type);\n            \n            \n        } else if (type == Collection.class) {\n            return new LinkedList<Object>();\n        } else if (type == Set.class) {\n            return new HashSet<Object>();\n        } else if (type == HashSet.class) {\n            return new HashSet<Object>();\n        } else if (type == SortedSet.class) {\n            return new TreeSet<Object>();\n        } else if (type == TreeSet.class) {\n            return new TreeSet<Object>();\n        } else if (type == LinkedHashSet.class) {\n            return new LinkedHashSet<Object>();\n        } else if (type == List.class) {\n            return new LinkedList<Object>();\n        } else if (type == LinkedList.class) {\n            return new LinkedList<Object>();\n        } else if (type == ArrayList.class) {\n            return new ArrayList<Object>();\n        } else if (type == Map.class) {\n            return new HashMap<Object, Object>();\n        } else if (type == HashMap.class) {\n            return new HashMap<Object, Object>();\n        } else if (type == SortedMap.class) {\n            return new TreeMap<Object, Object>();\n        } else if (type == TreeMap.class) {\n            return new TreeMap<Object, Object>();\n        } else if (type == LinkedHashMap.class) {\n            return new LinkedHashMap<Object, Object>();\n        }\n        \n        return null;\n    }\n\n}\n",
      "fixed_full_code": "\n\npackage org.mockito.internal.stubbing.defaultanswers;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.SortedSet;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.internal.util.ObjectMethodsGuru;\nimport org.mockito.internal.util.Primitives;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.mock.MockName;\nimport org.mockito.stubbing.Answer;\n\n\npublic class ReturnsEmptyValues implements Answer<Object>, Serializable { private static final long serialVersionUID = 1998191268711234347L; ObjectMethodsGuru methodsGuru = new ObjectMethodsGuru(); MockUtil mockUtil = new MockUtil(); public Object answer(InvocationOnMock invocation) {\n        if (methodsGuru.isToString(invocation.getMethod())) {\n            Object mock = invocation.getMock();\n            MockName name = mockUtil.getMockName(mock);\n            if (name.isDefault()) {\n                return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n            } else {\n                return name.toString();\n            }\n        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n            \n            \n            \n            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;\n        }\n        \n        Class<?> returnType = invocation.getMethod().getReturnType();\n        return returnValueFor(returnType);\n    }\n    \n    Object returnValueFor(Class<?> type) {\n        if (Primitives.isPrimitiveOrWrapper(type)) {\n            return Primitives.defaultValueForPrimitiveOrWrapper(type);\n            \n            \n        } else if (type == Iterable.class) {\n            return new ArrayList<Object>(0);\n        } else if (type == Collection.class) {\n            return new LinkedList<Object>();\n        } else if (type == Set.class) {\n            return new HashSet<Object>();\n        } else if (type == HashSet.class) {\n            return new HashSet<Object>();\n        } else if (type == SortedSet.class) {\n            return new TreeSet<Object>();\n        } else if (type == TreeSet.class) {\n            return new TreeSet<Object>();\n        } else if (type == LinkedHashSet.class) {\n            return new LinkedHashSet<Object>();\n        } else if (type == List.class) {\n            return new LinkedList<Object>();\n        } else if (type == LinkedList.class) {\n            return new LinkedList<Object>();\n        } else if (type == ArrayList.class) {\n            return new ArrayList<Object>();\n        } else if (type == Map.class) {\n            return new HashMap<Object, Object>();\n        } else if (type == HashMap.class) {\n            return new HashMap<Object, Object>();\n        } else if (type == SortedMap.class) {\n            return new TreeMap<Object, Object>();\n        } else if (type == TreeMap.class) {\n            return new TreeMap<Object, Object>();\n        } else if (type == LinkedHashMap.class) {\n            return new LinkedHashMap<Object, Object>();\n        }\n        \n        return null;\n    }\n\n}\n",
      "buggy_signatures": [],
      "fixed_signatures": [],
      "methods": [
        {
          "buggy_method": "  public Object answer(InvocationOnMock invocation) {\n  if (methodsGuru.isToString(invocation.getMethod())) {\n  Object mock = invocation.getMock();\n  MockName name = mockUtil.getMockName(mock);\n  if (name.isDefault()) {\n  return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n  } else {\n  return name.toString();\n  }\n  } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n  \n  \n  \n  return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;\n  }\n  \n  Class<?> returnType = invocation.getMethod().getReturnType();\n  return returnValueFor(returnType);\n  }",
          "fixed_method": "  public Object answer(InvocationOnMock invocation) {\n  if (methodsGuru.isToString(invocation.getMethod())) {\n  Object mock = invocation.getMock();\n  MockName name = mockUtil.getMockName(mock);\n  if (name.isDefault()) {\n  return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n  } else {\n  return name.toString();\n  }\n  } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n  \n  \n  \n  return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;\n  }\n  \n  Class<?> returnType = invocation.getMethod().getReturnType();\n  return returnValueFor(returnType);\n  }",
          "diff": [
            "@@ -84,6 +84,8 @@",
            "             return Primitives.defaultValueForPrimitiveOrWrapper(type);\n",
            "             //new instances are used instead of Collections.emptyList(), etc.\n",
            "             //to avoid UnsupportedOperationException if code under test modifies returned collection\n",
            "+        } else if (type == Iterable.class) {\n",
            "+            return new ArrayList<Object>(0);\n",
            "         } else if (type == Collection.class) {\n",
            "             return new LinkedList<Object>();\n",
            "         } else if (type == Set.class) {\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
