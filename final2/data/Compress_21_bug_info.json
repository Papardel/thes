{
  "bug_id": "21",
  "failed_tests": {
    "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest": [
      {
        "methodName": "testSevenEmptyFiles",
        "error": "java.io.IOException",
        "message": "Unknown property 128",
        "fail_line": "        testCompress252(7, 0);",
        "test_source": "  public void testSevenEmptyFiles() throws Exception {\n  testCompress252(7, 0);\n  }",
        "stack": [
          "SevenZFile.readFilesInfo line 714, SevenZFile.readHeader line 241, SevenZFile.readHeaders line 197, SevenZFile.<init> line 94, SevenZFile.<init> line 116, SevenZOutputFileTest.verifyCompress252 line 226, SevenZOutputFileTest.testCompress252 line 221, SevenZOutputFileTest.testSevenEmptyFiles line 183"
        ]
      },
      {
        "methodName": "testEightFilesSomeNotEmpty",
        "error": "java.io.IOException",
        "message": "Badly terminated header",
        "fail_line": "        testCompress252(8, 2);",
        "test_source": "  public void testEightFilesSomeNotEmpty() throws Exception {\n  testCompress252(8, 2);\n  }",
        "stack": [
          "SevenZFile.readHeader line 246, SevenZFile.readHeaders line 197, SevenZFile.<init> line 94, SevenZFile.<init> line 116, SevenZOutputFileTest.verifyCompress252 line 226, SevenZOutputFileTest.testCompress252 line 221, SevenZOutputFileTest.testEightFilesSomeNotEmpty line 195"
        ]
      },
      {
        "methodName": "testSixEmptyFiles",
        "error": "java.io.IOException",
        "message": "Badly terminated header",
        "fail_line": "        testCompress252(6, 0);",
        "test_source": "  public void testSixEmptyFiles() throws Exception {\n  testCompress252(6, 0);\n  }",
        "stack": [
          "SevenZFile.readHeader line 246, SevenZFile.readHeaders line 197, SevenZFile.<init> line 94, SevenZFile.<init> line 116, SevenZOutputFileTest.verifyCompress252 line 226, SevenZOutputFileTest.testCompress252 line 221, SevenZOutputFileTest.testSixEmptyFiles line 175"
        ]
      },
      {
        "methodName": "testEightEmptyFiles",
        "error": "java.io.IOException",
        "message": "Unknown property 192",
        "fail_line": "        testCompress252(8, 0);",
        "test_source": "  public void testEightEmptyFiles() throws Exception {\n  testCompress252(8, 0);\n  }",
        "stack": [
          "SevenZFile.readFilesInfo line 714, SevenZFile.readHeader line 241, SevenZFile.readHeaders line 197, SevenZFile.<init> line 94, SevenZFile.<init> line 116, SevenZOutputFileTest.verifyCompress252 line 226, SevenZOutputFileTest.testCompress252 line 221, SevenZOutputFileTest.testEightEmptyFiles line 191"
        ]
      },
      {
        "methodName": "testNineEmptyFiles",
        "error": "java.lang.ArrayIndexOutOfBoundsException",
        "message": "Index 0 out of bounds for length 0",
        "fail_line": "        testCompress252(9, 0);",
        "test_source": "  public void testNineEmptyFiles() throws Exception {\n  testCompress252(9, 0);\n  }",
        "stack": [
          "SevenZFile.readFilesInfo line 728, SevenZFile.readHeader line 241, SevenZFile.readHeaders line 197, SevenZFile.<init> line 94, SevenZFile.<init> line 116, SevenZOutputFileTest.verifyCompress252 line 226, SevenZOutputFileTest.testCompress252 line 221, SevenZOutputFileTest.testNineEmptyFiles line 199"
        ]
      },
      {
        "methodName": "testSixFilesSomeNotEmpty",
        "error": "java.io.IOException",
        "message": "Badly terminated header",
        "fail_line": "        testCompress252(6, 2);",
        "test_source": "  public void testSixFilesSomeNotEmpty() throws Exception {\n  testCompress252(6, 2);\n  }",
        "stack": [
          "SevenZFile.readHeader line 246, SevenZFile.readHeaders line 197, SevenZFile.<init> line 94, SevenZFile.<init> line 116, SevenZOutputFileTest.verifyCompress252 line 226, SevenZOutputFileTest.testCompress252 line 221, SevenZOutputFileTest.testSixFilesSomeNotEmpty line 179"
        ]
      },
      {
        "methodName": "testNineFilesSomeNotEmpty",
        "error": "java.io.IOException",
        "message": "Unknown property 128",
        "fail_line": "        testCompress252(9, 2);",
        "test_source": "  public void testNineFilesSomeNotEmpty() throws Exception {\n  testCompress252(9, 2);\n  }",
        "stack": [
          "SevenZFile.readFilesInfo line 714, SevenZFile.readHeader line 241, SevenZFile.readHeaders line 197, SevenZFile.<init> line 94, SevenZFile.<init> line 116, SevenZOutputFileTest.verifyCompress252 line 226, SevenZOutputFileTest.testCompress252 line 221, SevenZOutputFileTest.testNineFilesSomeNotEmpty line 203"
        ]
      },
      {
        "methodName": "testSevenFilesSomeNotEmpty",
        "error": "java.io.IOException",
        "message": "Unknown property 128",
        "fail_line": "        testCompress252(7, 2);",
        "test_source": "  public void testSevenFilesSomeNotEmpty() throws Exception {\n  testCompress252(7, 2);\n  }",
        "stack": [
          "SevenZFile.readFilesInfo line 714, SevenZFile.readHeader line 241, SevenZFile.readHeaders line 197, SevenZFile.<init> line 94, SevenZFile.<init> line 116, SevenZOutputFileTest.verifyCompress252 line 226, SevenZOutputFileTest.testCompress252 line 221, SevenZOutputFileTest.testSevenFilesSomeNotEmpty line 187"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.sevenz;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.DataOutput;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.RandomAccessFile;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.zip.CRC32;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.utils.CountingOutputStream;\n\n\npublic class SevenZOutputFile { private final RandomAccessFile file; private final List<SevenZArchiveEntry> files = new ArrayList<SevenZArchiveEntry>(); private int numNonEmptyStreams = 0; private CRC32 crc32 = new CRC32(); private CRC32 compressedCrc32 = new CRC32(); private long fileBytesWritten = 0; private boolean finished = false; private CountingOutputStream currentOutputStream; private SevenZMethod contentCompression = SevenZMethod.LZMA2; public SevenZOutputFile(final File filename) throws IOException {\n        file = new RandomAccessFile(filename, \"rw\");\n        file.seek(SevenZFile.SIGNATURE_HEADER_SIZE);\n    }\n    \n    \n    public void setContentCompression(SevenZMethod method) {\n        this.contentCompression = method;\n    }\n\n    \n    public void close() throws IOException {\n        if (!finished) {\n            finish();\n        }\n        file.close();\n    }\n    \n    \n    public SevenZArchiveEntry createArchiveEntry(final File inputFile, final String entryName) throws IOException {\n        final SevenZArchiveEntry entry = new SevenZArchiveEntry();\n        entry.setDirectory(inputFile.isDirectory());\n        entry.setName(entryName);\n        entry.setLastModifiedDate(new Date(inputFile.lastModified()));\n        return entry;\n    }\n\n    \n    public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\n        final SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;\n        files.add(entry);\n    }\n    \n    \n    public void closeArchiveEntry() throws IOException {\n        if (currentOutputStream != null) {\n            currentOutputStream.flush();\n            currentOutputStream.close();\n        }\n\n        final SevenZArchiveEntry entry = files.get(files.size() - 1);\n        if (fileBytesWritten > 0) {\n            entry.setHasStream(true);\n            ++numNonEmptyStreams;\n            entry.setSize(currentOutputStream.getBytesWritten());\n            entry.setCompressedSize(fileBytesWritten);\n            entry.setCrcValue(crc32.getValue());\n            entry.setCompressedCrcValue(compressedCrc32.getValue());\n            entry.setHasCrc(true);\n        } else {\n            entry.setHasStream(false);\n            entry.setSize(0);\n            entry.setCompressedSize(0);\n            entry.setHasCrc(false);\n        }\n        currentOutputStream = null;\n        crc32.reset();\n        compressedCrc32.reset();\n        fileBytesWritten = 0;\n    }\n    \n    \n    public void write(final int b) throws IOException {\n        getCurrentOutputStream().write(b);\n    }\n    \n    \n    public void write(final byte[] b) throws IOException {\n        write(b, 0, b.length);\n    }\n    \n    \n    public void write(final byte[] b, final int off, final int len) throws IOException {\n        if (len > 0) {\n            getCurrentOutputStream().write(b, off, len);\n        }\n    }\n    \n    \n    public void finish() throws IOException {\n        if (finished) {\n            throw new IOException(\"This archive has already been finished\");\n        }\n        finished = true;\n        \n        final long headerPosition = file.getFilePointer();\n        \n        final ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();\n        final DataOutputStream header = new DataOutputStream(headerBaos);\n        \n        writeHeader(header);\n        header.flush();\n        final byte[] headerBytes = headerBaos.toByteArray();\n        file.write(headerBytes);\n        \n        final CRC32 crc32 = new CRC32();\n        \n        \n        file.seek(0);\n        file.write(SevenZFile.sevenZSignature);\n        \n        file.write(0);\n        file.write(2);\n        \n        \n        final ByteArrayOutputStream startHeaderBaos = new ByteArrayOutputStream();\n        final DataOutputStream startHeaderStream = new DataOutputStream(startHeaderBaos);\n        startHeaderStream.writeLong(Long.reverseBytes(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE));\n        startHeaderStream.writeLong(Long.reverseBytes(0xffffFFFFL & headerBytes.length));\n        crc32.reset();\n        crc32.update(headerBytes);\n        startHeaderStream.writeInt(Integer.reverseBytes((int)crc32.getValue()));\n        startHeaderStream.flush();\n        final byte[] startHeaderBytes = startHeaderBaos.toByteArray();\n        crc32.reset();\n        crc32.update(startHeaderBytes);\n        file.writeInt(Integer.reverseBytes((int) crc32.getValue()));\n        file.write(startHeaderBytes);\n    }\n    \n    \n    private OutputStream getCurrentOutputStream() throws IOException {\n        if (currentOutputStream == null) {\n            currentOutputStream = setupFileOutputStream();\n        }\n        return currentOutputStream;\n    }\n\n    private CountingOutputStream setupFileOutputStream() throws IOException {\n        OutputStream out = new OutputStreamWrapper();\n        return new CountingOutputStream(Coders\n                                        .addEncoder(out,\n                                                    contentCompression,\n                                                    null)) {\n            @Override\n            public void write(final int b) throws IOException {\n                super.write(b);\n                crc32.update(b);\n            }\n    \n            @Override\n            public void write(final byte[] b) throws IOException {\n                super.write(b);\n                crc32.update(b);\n            }\n    \n            @Override\n            public void write(final byte[] b, final int off, final int len) throws IOException {\n                super.write(b, off, len);\n                crc32.update(b, off, len);\n            }\n        };\n    }\n\n    private void writeHeader(final DataOutput header) throws IOException {\n        header.write(NID.kHeader);\n        \n        header.write(NID.kMainStreamsInfo);\n        writeStreamsInfo(header);\n        writeFilesInfo(header);\n        header.write(NID.kEnd);\n    }\n    \n    private void writeStreamsInfo(final DataOutput header) throws IOException {\n        if (numNonEmptyStreams > 0) {\n            writePackInfo(header);\n            writeUnpackInfo(header);\n        }\n        \n        writeSubStreamsInfo(header);\n        \n        header.write(NID.kEnd);\n    }\n    \n    private void writePackInfo(final DataOutput header) throws IOException {\n        header.write(NID.kPackInfo);\n        \n        writeUint64(header, 0);\n        writeUint64(header, 0xffffFFFFL & numNonEmptyStreams);\n        \n        header.write(NID.kSize);\n        for (final SevenZArchiveEntry entry : files) {\n            if (entry.hasStream()) {\n                writeUint64(header, entry.getCompressedSize());\n            }\n        }\n        \n        header.write(NID.kCRC);\n        header.write(1);\n        for (final SevenZArchiveEntry entry : files) {\n            if (entry.hasStream()) {\n                header.writeInt(Integer.reverseBytes((int) entry.getCompressedCrcValue()));\n            }\n        }\n        \n        header.write(NID.kEnd);\n    }\n    \n    private void writeUnpackInfo(final DataOutput header) throws IOException {\n        header.write(NID.kUnpackInfo);\n        \n        header.write(NID.kFolder);\n        writeUint64(header, numNonEmptyStreams);\n        header.write(0);\n        for (int i = 0; i < numNonEmptyStreams; i++) {\n            writeFolder(header);\n        }\n        \n        header.write(NID.kCodersUnpackSize);\n        for (final SevenZArchiveEntry entry : files) {\n            if (entry.hasStream()) {\n                writeUint64(header, entry.getSize());\n            }\n        }\n        \n        header.write(NID.kCRC);\n        header.write(1);\n        for (final SevenZArchiveEntry entry : files) {\n            if (entry.hasStream()) {\n                header.writeInt(Integer.reverseBytes((int) entry.getCrcValue()));\n            }\n        }\n        \n        header.write(NID.kEnd);\n    }\n    \n    private void writeFolder(final DataOutput header) throws IOException {\n        \n        writeUint64(header, 1);\n        byte[] id = contentCompression.getId();\n        byte[] properties = contentCompression.getProperties();\n\n        int codecFlags = id.length;\n        if (properties.length > 0) {\n            codecFlags |= 0x20;\n        }\n        header.write(codecFlags);\n        header.write(id);\n\n        if (properties.length > 0) {\n            header.write(properties.length);\n            header.write(properties);\n        }\n    }\n    \n    private void writeSubStreamsInfo(final DataOutput header) throws IOException {\n        header.write(NID.kSubStreamsInfo);\n\n\n\n\n\n\n\n\n\n        header.write(NID.kEnd);\n    }\n    \n    private void writeFilesInfo(final DataOutput header) throws IOException {\n        header.write(NID.kFilesInfo);\n        \n        writeUint64(header, files.size());\n\n        writeFileEmptyStreams(header);\n        writeFileEmptyFiles(header);\n        writeFileAntiItems(header);\n        writeFileNames(header);\n        writeFileCTimes(header);\n        writeFileATimes(header);\n        writeFileMTimes(header);\n        writeFileWindowsAttributes(header);\n        header.write(0);\n    }\n    \n    private void writeFileEmptyStreams(final DataOutput header) throws IOException {\n        boolean hasEmptyStreams = false;\n        for (final SevenZArchiveEntry entry : files) {\n            if (!entry.hasStream()) {\n                hasEmptyStreams = true;\n                break;\n            }\n        }\n        if (hasEmptyStreams) {\n            header.write(NID.kEmptyStream);\n            final BitSet emptyStreams = new BitSet(files.size());\n            for (int i = 0; i < files.size(); i++) {\n                emptyStreams.set(i, !files.get(i).hasStream());\n            }\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final DataOutputStream out = new DataOutputStream(baos);\n            writeBits(out, emptyStreams, files.size());\n            out.flush();\n            final byte[] contents = baos.toByteArray();\n            writeUint64(header, contents.length);\n            header.write(contents);\n        }\n    }\n    \n    private void writeFileEmptyFiles(final DataOutput header) throws IOException {\n        boolean hasEmptyFiles = false;\n        int emptyStreamCounter = 0;\n        final BitSet emptyFiles = new BitSet(0);\n        for (int i = 0; i < files.size(); i++) {\n            if (!files.get(i).hasStream()) {\n                boolean isDir = files.get(i).isDirectory();\n                emptyFiles.set(emptyStreamCounter++, !isDir);\n                hasEmptyFiles |= !isDir;\n            }\n        }\n        if (hasEmptyFiles) {\n            header.write(NID.kEmptyFile);\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final DataOutputStream out = new DataOutputStream(baos);\n            writeBits(out, emptyFiles, emptyStreamCounter);\n            out.flush();\n            final byte[] contents = baos.toByteArray();\n            writeUint64(header, contents.length);\n            header.write(contents);\n        }\n    }\n    \n    private void writeFileAntiItems(final DataOutput header) throws IOException {\n        boolean hasAntiItems = false;\n        final BitSet antiItems = new BitSet(0);\n        int antiItemCounter = 0;\n        for (int i = 0; i < files.size(); i++) {\n            if (!files.get(i).hasStream()) {\n                boolean isAnti = files.get(i).isAntiItem();\n                antiItems.set(antiItemCounter++, isAnti);\n                hasAntiItems |= isAnti;\n            }\n        }\n        if (hasAntiItems) {\n            header.write(NID.kAnti);\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final DataOutputStream out = new DataOutputStream(baos);\n            writeBits(out, antiItems, antiItemCounter);\n            out.flush();\n            final byte[] contents = baos.toByteArray();\n            writeUint64(header, contents.length);\n            header.write(contents);\n        }\n    }\n    \n    private void writeFileNames(final DataOutput header) throws IOException {\n        header.write(NID.kName);\n        \n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final DataOutputStream out = new DataOutputStream(baos);\n        out.write(0);\n        for (final SevenZArchiveEntry entry : files) {\n            out.write(entry.getName().getBytes(\"UTF-16LE\"));\n            out.writeShort(0);\n        }\n        out.flush();\n        final byte[] contents = baos.toByteArray();\n        writeUint64(header, contents.length);\n        header.write(contents);\n    }\n\n    private void writeFileCTimes(final DataOutput header) throws IOException {\n        int numCreationDates = 0;\n        for (final SevenZArchiveEntry entry : files) {\n            if (entry.getHasCreationDate()) {\n                ++numCreationDates;\n            }\n        }\n        if (numCreationDates > 0) {\n            header.write(NID.kCTime);\n\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final DataOutputStream out = new DataOutputStream(baos);\n            if (numCreationDates != files.size()) {\n                out.write(0);\n                final BitSet cTimes = new BitSet(files.size());\n                for (int i = 0; i < files.size(); i++) {\n                    cTimes.set(i, files.get(i).getHasCreationDate());\n                }\n                writeBits(out, cTimes, files.size());\n            } else {\n                out.write(1);\n            }\n            out.write(0);\n            for (final SevenZArchiveEntry entry : files) {\n                if (entry.getHasCreationDate()) {\n                    out.writeLong(Long.reverseBytes(\n                            SevenZArchiveEntry.javaTimeToNtfsTime(entry.getCreationDate())));\n                }\n            }\n            out.flush();\n            final byte[] contents = baos.toByteArray();\n            writeUint64(header, contents.length);\n            header.write(contents);\n        }\n    }\n\n    private void writeFileATimes(final DataOutput header) throws IOException {\n        int numAccessDates = 0;\n        for (final SevenZArchiveEntry entry : files) {\n            if (entry.getHasAccessDate()) {\n                ++numAccessDates;\n            }\n        }\n        if (numAccessDates > 0) {\n            header.write(NID.kATime);\n\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final DataOutputStream out = new DataOutputStream(baos);\n            if (numAccessDates != files.size()) {\n                out.write(0);\n                final BitSet aTimes = new BitSet(files.size());\n                for (int i = 0; i < files.size(); i++) {\n                    aTimes.set(i, files.get(i).getHasAccessDate());\n                }\n                writeBits(out, aTimes, files.size());\n            } else {\n                out.write(1);\n            }\n            out.write(0);\n            for (final SevenZArchiveEntry entry : files) {\n                if (entry.getHasAccessDate()) {\n                    out.writeLong(Long.reverseBytes(\n                            SevenZArchiveEntry.javaTimeToNtfsTime(entry.getAccessDate())));\n                }\n            }\n            out.flush();\n            final byte[] contents = baos.toByteArray();\n            writeUint64(header, contents.length);\n            header.write(contents);\n        }\n    }\n\n    private void writeFileMTimes(final DataOutput header) throws IOException {\n        int numLastModifiedDates = 0;\n        for (final SevenZArchiveEntry entry : files) {\n            if (entry.getHasLastModifiedDate()) {\n                ++numLastModifiedDates;\n            }\n        }\n        if (numLastModifiedDates > 0) {\n            header.write(NID.kMTime);\n\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final DataOutputStream out = new DataOutputStream(baos);\n            if (numLastModifiedDates != files.size()) {\n                out.write(0);\n                final BitSet mTimes = new BitSet(files.size());\n                for (int i = 0; i < files.size(); i++) {\n                    mTimes.set(i, files.get(i).getHasLastModifiedDate());\n                }\n                writeBits(out, mTimes, files.size());\n            } else {\n                out.write(1);\n            }\n            out.write(0);\n            for (final SevenZArchiveEntry entry : files) {\n                if (entry.getHasLastModifiedDate()) {\n                    out.writeLong(Long.reverseBytes(\n                            SevenZArchiveEntry.javaTimeToNtfsTime(entry.getLastModifiedDate())));\n                }\n            }\n            out.flush();\n            final byte[] contents = baos.toByteArray();\n            writeUint64(header, contents.length);\n            header.write(contents);\n        }\n    }\n\n    private void writeFileWindowsAttributes(final DataOutput header) throws IOException {\n        int numWindowsAttributes = 0;\n        for (final SevenZArchiveEntry entry : files) {\n            if (entry.getHasWindowsAttributes()) {\n                ++numWindowsAttributes;\n            }\n        }\n        if (numWindowsAttributes > 0) {\n            header.write(NID.kWinAttributes);\n\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final DataOutputStream out = new DataOutputStream(baos);\n            if (numWindowsAttributes != files.size()) {\n                out.write(0);\n                final BitSet attributes = new BitSet(files.size());\n                for (int i = 0; i < files.size(); i++) {\n                    attributes.set(i, files.get(i).getHasWindowsAttributes());\n                }\n                writeBits(out, attributes, files.size());\n            } else {\n                out.write(1);\n            }\n            out.write(0);\n            for (final SevenZArchiveEntry entry : files) {\n                if (entry.getHasWindowsAttributes()) {\n                    out.writeInt(Integer.reverseBytes(entry.getWindowsAttributes()));\n                }\n            }\n            out.flush();\n            final byte[] contents = baos.toByteArray();\n            writeUint64(header, contents.length);\n            header.write(contents);\n        }\n    }\n\n    private void writeUint64(final DataOutput header, long value) throws IOException {\n        int firstByte = 0;\n        int mask = 0x80;\n        int i;\n        for (i = 0; i < 8; i++) {\n            if (value < ((1L << ( 7  * (i + 1))))) {\n                firstByte |= (value >>> (8 * i));\n                break;\n            }\n            firstByte |= mask;\n            mask >>>= 1;\n        }\n        header.write(firstByte);\n        for (; i > 0; i--) {\n            header.write((int) (0xff & value));\n            value >>>= 8;\n        }\n    }\n\n    private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\n        int cache = 0;\n        int shift = 7;\n        for (int i = 0; i < length; i++) {\n            cache |= ((bits.get(i) ? 1 : 0) << shift);\n            --shift;\n            if (shift == 0) {\n                header.write(cache);\n                shift = 7;\n                cache = 0;\n            }\n        }\n        if (length > 0 && shift > 0) {\n            header.write(cache);\n        }\n    }\n\n    private class OutputStreamWrapper extends OutputStream { @Override public void write(final int b) throws IOException {\n            file.write(b);\n            compressedCrc32.update(b);\n            fileBytesWritten++;\n        }\n    \n        @Override\n        public void write(final byte[] b) throws IOException {\n            OutputStreamWrapper.this.write(b, 0, b.length);\n        }\n    \n        @Override\n        public void write(final byte[] b, final int off, final int len) throws IOException {\n            file.write(b, off, len);\n            compressedCrc32.update(b, off, len);\n            fileBytesWritten += len;\n        }\n\n        @Override\n        public void flush() throws IOException {\n            \n        }\n\n        @Override\n        public void close() throws IOException {\n            \n        }\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.sevenz;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.DataOutput;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.RandomAccessFile;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.zip.CRC32;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.utils.CountingOutputStream;\n\n\npublic class SevenZOutputFile { private final RandomAccessFile file; private final List<SevenZArchiveEntry> files = new ArrayList<SevenZArchiveEntry>(); private int numNonEmptyStreams = 0; private CRC32 crc32 = new CRC32(); private CRC32 compressedCrc32 = new CRC32(); private long fileBytesWritten = 0; private boolean finished = false; private CountingOutputStream currentOutputStream; private SevenZMethod contentCompression = SevenZMethod.LZMA2; public SevenZOutputFile(final File filename) throws IOException {\n        file = new RandomAccessFile(filename, \"rw\");\n        file.seek(SevenZFile.SIGNATURE_HEADER_SIZE);\n    }\n    \n    \n    public void setContentCompression(SevenZMethod method) {\n        this.contentCompression = method;\n    }\n\n    \n    public void close() throws IOException {\n        if (!finished) {\n            finish();\n        }\n        file.close();\n    }\n    \n    \n    public SevenZArchiveEntry createArchiveEntry(final File inputFile, final String entryName) throws IOException {\n        final SevenZArchiveEntry entry = new SevenZArchiveEntry();\n        entry.setDirectory(inputFile.isDirectory());\n        entry.setName(entryName);\n        entry.setLastModifiedDate(new Date(inputFile.lastModified()));\n        return entry;\n    }\n\n    \n    public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\n        final SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;\n        files.add(entry);\n    }\n    \n    \n    public void closeArchiveEntry() throws IOException {\n        if (currentOutputStream != null) {\n            currentOutputStream.flush();\n            currentOutputStream.close();\n        }\n\n        final SevenZArchiveEntry entry = files.get(files.size() - 1);\n        if (fileBytesWritten > 0) {\n            entry.setHasStream(true);\n            ++numNonEmptyStreams;\n            entry.setSize(currentOutputStream.getBytesWritten());\n            entry.setCompressedSize(fileBytesWritten);\n            entry.setCrcValue(crc32.getValue());\n            entry.setCompressedCrcValue(compressedCrc32.getValue());\n            entry.setHasCrc(true);\n        } else {\n            entry.setHasStream(false);\n            entry.setSize(0);\n            entry.setCompressedSize(0);\n            entry.setHasCrc(false);\n        }\n        currentOutputStream = null;\n        crc32.reset();\n        compressedCrc32.reset();\n        fileBytesWritten = 0;\n    }\n    \n    \n    public void write(final int b) throws IOException {\n        getCurrentOutputStream().write(b);\n    }\n    \n    \n    public void write(final byte[] b) throws IOException {\n        write(b, 0, b.length);\n    }\n    \n    \n    public void write(final byte[] b, final int off, final int len) throws IOException {\n        if (len > 0) {\n            getCurrentOutputStream().write(b, off, len);\n        }\n    }\n    \n    \n    public void finish() throws IOException {\n        if (finished) {\n            throw new IOException(\"This archive has already been finished\");\n        }\n        finished = true;\n        \n        final long headerPosition = file.getFilePointer();\n        \n        final ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();\n        final DataOutputStream header = new DataOutputStream(headerBaos);\n        \n        writeHeader(header);\n        header.flush();\n        final byte[] headerBytes = headerBaos.toByteArray();\n        file.write(headerBytes);\n        \n        final CRC32 crc32 = new CRC32();\n        \n        \n        file.seek(0);\n        file.write(SevenZFile.sevenZSignature);\n        \n        file.write(0);\n        file.write(2);\n        \n        \n        final ByteArrayOutputStream startHeaderBaos = new ByteArrayOutputStream();\n        final DataOutputStream startHeaderStream = new DataOutputStream(startHeaderBaos);\n        startHeaderStream.writeLong(Long.reverseBytes(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE));\n        startHeaderStream.writeLong(Long.reverseBytes(0xffffFFFFL & headerBytes.length));\n        crc32.reset();\n        crc32.update(headerBytes);\n        startHeaderStream.writeInt(Integer.reverseBytes((int)crc32.getValue()));\n        startHeaderStream.flush();\n        final byte[] startHeaderBytes = startHeaderBaos.toByteArray();\n        crc32.reset();\n        crc32.update(startHeaderBytes);\n        file.writeInt(Integer.reverseBytes((int) crc32.getValue()));\n        file.write(startHeaderBytes);\n    }\n    \n    \n    private OutputStream getCurrentOutputStream() throws IOException {\n        if (currentOutputStream == null) {\n            currentOutputStream = setupFileOutputStream();\n        }\n        return currentOutputStream;\n    }\n\n    private CountingOutputStream setupFileOutputStream() throws IOException {\n        OutputStream out = new OutputStreamWrapper();\n        return new CountingOutputStream(Coders\n                                        .addEncoder(out,\n                                                    contentCompression,\n                                                    null)) {\n            @Override\n            public void write(final int b) throws IOException {\n                super.write(b);\n                crc32.update(b);\n            }\n    \n            @Override\n            public void write(final byte[] b) throws IOException {\n                super.write(b);\n                crc32.update(b);\n            }\n    \n            @Override\n            public void write(final byte[] b, final int off, final int len) throws IOException {\n                super.write(b, off, len);\n                crc32.update(b, off, len);\n            }\n        };\n    }\n\n    private void writeHeader(final DataOutput header) throws IOException {\n        header.write(NID.kHeader);\n        \n        header.write(NID.kMainStreamsInfo);\n        writeStreamsInfo(header);\n        writeFilesInfo(header);\n        header.write(NID.kEnd);\n    }\n    \n    private void writeStreamsInfo(final DataOutput header) throws IOException {\n        if (numNonEmptyStreams > 0) {\n            writePackInfo(header);\n            writeUnpackInfo(header);\n        }\n        \n        writeSubStreamsInfo(header);\n        \n        header.write(NID.kEnd);\n    }\n    \n    private void writePackInfo(final DataOutput header) throws IOException {\n        header.write(NID.kPackInfo);\n        \n        writeUint64(header, 0);\n        writeUint64(header, 0xffffFFFFL & numNonEmptyStreams);\n        \n        header.write(NID.kSize);\n        for (final SevenZArchiveEntry entry : files) {\n            if (entry.hasStream()) {\n                writeUint64(header, entry.getCompressedSize());\n            }\n        }\n        \n        header.write(NID.kCRC);\n        header.write(1);\n        for (final SevenZArchiveEntry entry : files) {\n            if (entry.hasStream()) {\n                header.writeInt(Integer.reverseBytes((int) entry.getCompressedCrcValue()));\n            }\n        }\n        \n        header.write(NID.kEnd);\n    }\n    \n    private void writeUnpackInfo(final DataOutput header) throws IOException {\n        header.write(NID.kUnpackInfo);\n        \n        header.write(NID.kFolder);\n        writeUint64(header, numNonEmptyStreams);\n        header.write(0);\n        for (int i = 0; i < numNonEmptyStreams; i++) {\n            writeFolder(header);\n        }\n        \n        header.write(NID.kCodersUnpackSize);\n        for (final SevenZArchiveEntry entry : files) {\n            if (entry.hasStream()) {\n                writeUint64(header, entry.getSize());\n            }\n        }\n        \n        header.write(NID.kCRC);\n        header.write(1);\n        for (final SevenZArchiveEntry entry : files) {\n            if (entry.hasStream()) {\n                header.writeInt(Integer.reverseBytes((int) entry.getCrcValue()));\n            }\n        }\n        \n        header.write(NID.kEnd);\n    }\n    \n    private void writeFolder(final DataOutput header) throws IOException {\n        \n        writeUint64(header, 1);\n        byte[] id = contentCompression.getId();\n        byte[] properties = contentCompression.getProperties();\n\n        int codecFlags = id.length;\n        if (properties.length > 0) {\n            codecFlags |= 0x20;\n        }\n        header.write(codecFlags);\n        header.write(id);\n\n        if (properties.length > 0) {\n            header.write(properties.length);\n            header.write(properties);\n        }\n    }\n    \n    private void writeSubStreamsInfo(final DataOutput header) throws IOException {\n        header.write(NID.kSubStreamsInfo);\n\n\n\n\n\n\n\n\n\n        header.write(NID.kEnd);\n    }\n    \n    private void writeFilesInfo(final DataOutput header) throws IOException {\n        header.write(NID.kFilesInfo);\n        \n        writeUint64(header, files.size());\n\n        writeFileEmptyStreams(header);\n        writeFileEmptyFiles(header);\n        writeFileAntiItems(header);\n        writeFileNames(header);\n        writeFileCTimes(header);\n        writeFileATimes(header);\n        writeFileMTimes(header);\n        writeFileWindowsAttributes(header);\n        header.write(0);\n    }\n    \n    private void writeFileEmptyStreams(final DataOutput header) throws IOException {\n        boolean hasEmptyStreams = false;\n        for (final SevenZArchiveEntry entry : files) {\n            if (!entry.hasStream()) {\n                hasEmptyStreams = true;\n                break;\n            }\n        }\n        if (hasEmptyStreams) {\n            header.write(NID.kEmptyStream);\n            final BitSet emptyStreams = new BitSet(files.size());\n            for (int i = 0; i < files.size(); i++) {\n                emptyStreams.set(i, !files.get(i).hasStream());\n            }\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final DataOutputStream out = new DataOutputStream(baos);\n            writeBits(out, emptyStreams, files.size());\n            out.flush();\n            final byte[] contents = baos.toByteArray();\n            writeUint64(header, contents.length);\n            header.write(contents);\n        }\n    }\n    \n    private void writeFileEmptyFiles(final DataOutput header) throws IOException {\n        boolean hasEmptyFiles = false;\n        int emptyStreamCounter = 0;\n        final BitSet emptyFiles = new BitSet(0);\n        for (int i = 0; i < files.size(); i++) {\n            if (!files.get(i).hasStream()) {\n                boolean isDir = files.get(i).isDirectory();\n                emptyFiles.set(emptyStreamCounter++, !isDir);\n                hasEmptyFiles |= !isDir;\n            }\n        }\n        if (hasEmptyFiles) {\n            header.write(NID.kEmptyFile);\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final DataOutputStream out = new DataOutputStream(baos);\n            writeBits(out, emptyFiles, emptyStreamCounter);\n            out.flush();\n            final byte[] contents = baos.toByteArray();\n            writeUint64(header, contents.length);\n            header.write(contents);\n        }\n    }\n    \n    private void writeFileAntiItems(final DataOutput header) throws IOException {\n        boolean hasAntiItems = false;\n        final BitSet antiItems = new BitSet(0);\n        int antiItemCounter = 0;\n        for (int i = 0; i < files.size(); i++) {\n            if (!files.get(i).hasStream()) {\n                boolean isAnti = files.get(i).isAntiItem();\n                antiItems.set(antiItemCounter++, isAnti);\n                hasAntiItems |= isAnti;\n            }\n        }\n        if (hasAntiItems) {\n            header.write(NID.kAnti);\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final DataOutputStream out = new DataOutputStream(baos);\n            writeBits(out, antiItems, antiItemCounter);\n            out.flush();\n            final byte[] contents = baos.toByteArray();\n            writeUint64(header, contents.length);\n            header.write(contents);\n        }\n    }\n    \n    private void writeFileNames(final DataOutput header) throws IOException {\n        header.write(NID.kName);\n        \n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final DataOutputStream out = new DataOutputStream(baos);\n        out.write(0);\n        for (final SevenZArchiveEntry entry : files) {\n            out.write(entry.getName().getBytes(\"UTF-16LE\"));\n            out.writeShort(0);\n        }\n        out.flush();\n        final byte[] contents = baos.toByteArray();\n        writeUint64(header, contents.length);\n        header.write(contents);\n    }\n\n    private void writeFileCTimes(final DataOutput header) throws IOException {\n        int numCreationDates = 0;\n        for (final SevenZArchiveEntry entry : files) {\n            if (entry.getHasCreationDate()) {\n                ++numCreationDates;\n            }\n        }\n        if (numCreationDates > 0) {\n            header.write(NID.kCTime);\n\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final DataOutputStream out = new DataOutputStream(baos);\n            if (numCreationDates != files.size()) {\n                out.write(0);\n                final BitSet cTimes = new BitSet(files.size());\n                for (int i = 0; i < files.size(); i++) {\n                    cTimes.set(i, files.get(i).getHasCreationDate());\n                }\n                writeBits(out, cTimes, files.size());\n            } else {\n                out.write(1);\n            }\n            out.write(0);\n            for (final SevenZArchiveEntry entry : files) {\n                if (entry.getHasCreationDate()) {\n                    out.writeLong(Long.reverseBytes(\n                            SevenZArchiveEntry.javaTimeToNtfsTime(entry.getCreationDate())));\n                }\n            }\n            out.flush();\n            final byte[] contents = baos.toByteArray();\n            writeUint64(header, contents.length);\n            header.write(contents);\n        }\n    }\n\n    private void writeFileATimes(final DataOutput header) throws IOException {\n        int numAccessDates = 0;\n        for (final SevenZArchiveEntry entry : files) {\n            if (entry.getHasAccessDate()) {\n                ++numAccessDates;\n            }\n        }\n        if (numAccessDates > 0) {\n            header.write(NID.kATime);\n\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final DataOutputStream out = new DataOutputStream(baos);\n            if (numAccessDates != files.size()) {\n                out.write(0);\n                final BitSet aTimes = new BitSet(files.size());\n                for (int i = 0; i < files.size(); i++) {\n                    aTimes.set(i, files.get(i).getHasAccessDate());\n                }\n                writeBits(out, aTimes, files.size());\n            } else {\n                out.write(1);\n            }\n            out.write(0);\n            for (final SevenZArchiveEntry entry : files) {\n                if (entry.getHasAccessDate()) {\n                    out.writeLong(Long.reverseBytes(\n                            SevenZArchiveEntry.javaTimeToNtfsTime(entry.getAccessDate())));\n                }\n            }\n            out.flush();\n            final byte[] contents = baos.toByteArray();\n            writeUint64(header, contents.length);\n            header.write(contents);\n        }\n    }\n\n    private void writeFileMTimes(final DataOutput header) throws IOException {\n        int numLastModifiedDates = 0;\n        for (final SevenZArchiveEntry entry : files) {\n            if (entry.getHasLastModifiedDate()) {\n                ++numLastModifiedDates;\n            }\n        }\n        if (numLastModifiedDates > 0) {\n            header.write(NID.kMTime);\n\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final DataOutputStream out = new DataOutputStream(baos);\n            if (numLastModifiedDates != files.size()) {\n                out.write(0);\n                final BitSet mTimes = new BitSet(files.size());\n                for (int i = 0; i < files.size(); i++) {\n                    mTimes.set(i, files.get(i).getHasLastModifiedDate());\n                }\n                writeBits(out, mTimes, files.size());\n            } else {\n                out.write(1);\n            }\n            out.write(0);\n            for (final SevenZArchiveEntry entry : files) {\n                if (entry.getHasLastModifiedDate()) {\n                    out.writeLong(Long.reverseBytes(\n                            SevenZArchiveEntry.javaTimeToNtfsTime(entry.getLastModifiedDate())));\n                }\n            }\n            out.flush();\n            final byte[] contents = baos.toByteArray();\n            writeUint64(header, contents.length);\n            header.write(contents);\n        }\n    }\n\n    private void writeFileWindowsAttributes(final DataOutput header) throws IOException {\n        int numWindowsAttributes = 0;\n        for (final SevenZArchiveEntry entry : files) {\n            if (entry.getHasWindowsAttributes()) {\n                ++numWindowsAttributes;\n            }\n        }\n        if (numWindowsAttributes > 0) {\n            header.write(NID.kWinAttributes);\n\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final DataOutputStream out = new DataOutputStream(baos);\n            if (numWindowsAttributes != files.size()) {\n                out.write(0);\n                final BitSet attributes = new BitSet(files.size());\n                for (int i = 0; i < files.size(); i++) {\n                    attributes.set(i, files.get(i).getHasWindowsAttributes());\n                }\n                writeBits(out, attributes, files.size());\n            } else {\n                out.write(1);\n            }\n            out.write(0);\n            for (final SevenZArchiveEntry entry : files) {\n                if (entry.getHasWindowsAttributes()) {\n                    out.writeInt(Integer.reverseBytes(entry.getWindowsAttributes()));\n                }\n            }\n            out.flush();\n            final byte[] contents = baos.toByteArray();\n            writeUint64(header, contents.length);\n            header.write(contents);\n        }\n    }\n\n    private void writeUint64(final DataOutput header, long value) throws IOException {\n        int firstByte = 0;\n        int mask = 0x80;\n        int i;\n        for (i = 0; i < 8; i++) {\n            if (value < ((1L << ( 7  * (i + 1))))) {\n                firstByte |= (value >>> (8 * i));\n                break;\n            }\n            firstByte |= mask;\n            mask >>>= 1;\n        }\n        header.write(firstByte);\n        for (; i > 0; i--) {\n            header.write((int) (0xff & value));\n            value >>>= 8;\n        }\n    }\n\n    private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\n        int cache = 0;\n        int shift = 7;\n        for (int i = 0; i < length; i++) {\n            cache |= ((bits.get(i) ? 1 : 0) << shift);\n            if (--shift < 0) {\n                header.write(cache);\n                shift = 7;\n                cache = 0;\n            }\n        }\n        if (shift != 7) {\n            header.write(cache);\n        }\n    }\n\n    private class OutputStreamWrapper extends OutputStream { @Override public void write(final int b) throws IOException {\n            file.write(b);\n            compressedCrc32.update(b);\n            fileBytesWritten++;\n        }\n    \n        @Override\n        public void write(final byte[] b) throws IOException {\n            OutputStreamWrapper.this.write(b, 0, b.length);\n        }\n    \n        @Override\n        public void write(final byte[] b, final int off, final int len) throws IOException {\n            file.write(b, off, len);\n            compressedCrc32.update(b, off, len);\n            fileBytesWritten += len;\n        }\n\n        @Override\n        public void flush() throws IOException {\n            \n        }\n\n        @Override\n        public void close() throws IOException {\n            \n        }\n    }\n}\n",
      "buggy_signatures": [
        "public void setContentCompression(SevenZMethod method)",
        "public void close() throws IOException",
        "public SevenZArchiveEntry createArchiveEntry(final File inputFile, final String entryName) throws IOException",
        "public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException",
        "public void closeArchiveEntry() throws IOException",
        "public void write(final int b) throws IOException",
        "public void write(final byte[] b) throws IOException",
        "public void write(final byte[] b, final int off, final int len) throws IOException",
        "public void finish() throws IOException",
        "private OutputStream getCurrentOutputStream() throws IOException",
        "private CountingOutputStream setupFileOutputStream() throws IOException",
        "public void write(final int b) throws IOException",
        "public void write(final byte[] b) throws IOException",
        "public void write(final byte[] b, final int off, final int len) throws IOException",
        "private void writeHeader(final DataOutput header) throws IOException",
        "private void writeStreamsInfo(final DataOutput header) throws IOException",
        "private void writePackInfo(final DataOutput header) throws IOException",
        "private void writeUnpackInfo(final DataOutput header) throws IOException",
        "private void writeFolder(final DataOutput header) throws IOException",
        "private void writeSubStreamsInfo(final DataOutput header) throws IOException",
        "private void writeFilesInfo(final DataOutput header) throws IOException",
        "private void writeFileEmptyStreams(final DataOutput header) throws IOException",
        "private void writeFileEmptyFiles(final DataOutput header) throws IOException",
        "private void writeFileAntiItems(final DataOutput header) throws IOException",
        "private void writeFileNames(final DataOutput header) throws IOException",
        "private void writeFileCTimes(final DataOutput header) throws IOException",
        "private void writeFileATimes(final DataOutput header) throws IOException",
        "private void writeFileMTimes(final DataOutput header) throws IOException",
        "private void writeFileWindowsAttributes(final DataOutput header) throws IOException",
        "private void writeUint64(final DataOutput header, long value) throws IOException",
        "private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException",
        "private class OutputStreamWrapper extends OutputStream { @Override public void write(final int b) throws IOException",
        "public void write(final byte[] b) throws IOException",
        "public void write(final byte[] b, final int off, final int len) throws IOException",
        "public void flush() throws IOException",
        "public void close() throws IOException"
      ],
      "fixed_signatures": [
        "public void setContentCompression(SevenZMethod method)",
        "public void close() throws IOException",
        "public SevenZArchiveEntry createArchiveEntry(final File inputFile, final String entryName) throws IOException",
        "public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException",
        "public void closeArchiveEntry() throws IOException",
        "public void write(final int b) throws IOException",
        "public void write(final byte[] b) throws IOException",
        "public void write(final byte[] b, final int off, final int len) throws IOException",
        "public void finish() throws IOException",
        "private OutputStream getCurrentOutputStream() throws IOException",
        "private CountingOutputStream setupFileOutputStream() throws IOException",
        "public void write(final int b) throws IOException",
        "public void write(final byte[] b) throws IOException",
        "public void write(final byte[] b, final int off, final int len) throws IOException",
        "private void writeHeader(final DataOutput header) throws IOException",
        "private void writeStreamsInfo(final DataOutput header) throws IOException",
        "private void writePackInfo(final DataOutput header) throws IOException",
        "private void writeUnpackInfo(final DataOutput header) throws IOException",
        "private void writeFolder(final DataOutput header) throws IOException",
        "private void writeSubStreamsInfo(final DataOutput header) throws IOException",
        "private void writeFilesInfo(final DataOutput header) throws IOException",
        "private void writeFileEmptyStreams(final DataOutput header) throws IOException",
        "private void writeFileEmptyFiles(final DataOutput header) throws IOException",
        "private void writeFileAntiItems(final DataOutput header) throws IOException",
        "private void writeFileNames(final DataOutput header) throws IOException",
        "private void writeFileCTimes(final DataOutput header) throws IOException",
        "private void writeFileATimes(final DataOutput header) throws IOException",
        "private void writeFileMTimes(final DataOutput header) throws IOException",
        "private void writeFileWindowsAttributes(final DataOutput header) throws IOException",
        "private void writeUint64(final DataOutput header, long value) throws IOException",
        "private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException",
        "private class OutputStreamWrapper extends OutputStream { @Override public void write(final int b) throws IOException",
        "public void write(final byte[] b) throws IOException",
        "public void write(final byte[] b, final int off, final int len) throws IOException",
        "public void flush() throws IOException",
        "public void close() throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\n  int cache = 0;\n  int shift = 7;\n  for (int i = 0; i < length; i++) {\n  cache |= ((bits.get(i) ? 1 : 0) << shift);\n  --shift;\n  if (shift == 0) {\n  header.write(cache);\n  shift = 7;\n  cache = 0;\n  }\n  }\n  if (length > 0 && shift > 0) {\n  header.write(cache);\n  }\n  }",
          "fixed_method": "  private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\n  int cache = 0;\n  int shift = 7;\n  for (int i = 0; i < length; i++) {\n  cache |= ((bits.get(i) ? 1 : 0) << shift);\n  if (--shift < 0) {\n  header.write(cache);\n  shift = 7;\n  cache = 0;\n  }\n  }\n  if (shift != 7) {\n  header.write(cache);\n  }\n  }",
          "diff": [
            "@@ -636,14 +636,13 @@",
            "         int shift = 7;\n",
            "         for (int i = 0; i < length; i++) {\n",
            "             cache |= ((bits.get(i) ? 1 : 0) << shift);\n",
            "-            --shift;\n",
            "-            if (shift == 0) {\n",
            "+            if (--shift < 0) {\n",
            "                 header.write(cache);\n",
            "                 shift = 7;\n",
            "                 cache = 0;\n",
            "             }\n",
            "         }\n",
            "-        if (length > 0 && shift > 0) {\n",
            "+        if (shift != 7) {\n",
            "             header.write(cache);\n",
            "         }\n",
            "     }\n"
          ],
          "changed_lines": 5
        }
      ]
    }
  ]
}
