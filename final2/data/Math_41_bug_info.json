{
  "bug_id": "41",
  "failed_tests": {
    "org.apache.commons.math.stat.descriptive.moment.VarianceTest": [
      {
        "methodName": "testEvaluateArraySegmentWeighted",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<1.6644508338125354> but was:<0.31909161062727365>",
        "fail_line": "",
        "test_source": "",
        "stack": [
          "UnivariateStatisticAbstractTest.testEvaluateArraySegmentWeighted line 130"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/stat/descriptive/moment/Variance.java",
      "buggy_full_code": "\npackage org.apache.commons.math.stat.descriptive.moment;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math.exception.NullArgumentException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.stat.descriptive.WeightedEvaluation;\nimport org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\nimport org.apache.commons.math.util.MathUtils;\n\n\npublic class Variance extends AbstractStorelessUnivariateStatistic implements Serializable, WeightedEvaluation { private static final long serialVersionUID = -9111962718267217978L; protected SecondMoment moment = null; protected boolean incMoment = true; private boolean isBiasCorrected = true; public Variance() {\n        moment = new SecondMoment();\n    }\n\n    \n    public Variance(final SecondMoment m2) {\n        incMoment = false;\n        this.moment = m2;\n    }\n\n    \n    public Variance(boolean isBiasCorrected) {\n        moment = new SecondMoment();\n        this.isBiasCorrected = isBiasCorrected;\n    }\n\n    \n    public Variance(boolean isBiasCorrected, SecondMoment m2) {\n        incMoment = false;\n        this.moment = m2;\n        this.isBiasCorrected = isBiasCorrected;\n    }\n\n    \n    public Variance(Variance original) {\n        copy(original, this);\n    }\n\n    \n    @Override\n    public void increment(final double d) {\n        if (incMoment) {\n            moment.increment(d);\n        }\n    }\n\n    \n    @Override\n    public double getResult() {\n            if (moment.n == 0) {\n                return Double.NaN;\n            } else if (moment.n == 1) {\n                return 0d;\n            } else {\n                if (isBiasCorrected) {\n                    return moment.m2 / (moment.n - 1d);\n                } else {\n                    return moment.m2 / (moment.n);\n                }\n            }\n    }\n\n    \n    public long getN() {\n        return moment.getN();\n    }\n\n    \n    @Override\n    public void clear() {\n        if (incMoment) {\n            moment.clear();\n        }\n    }\n\n    \n    @Override\n    public double evaluate(final double[] values) {\n        if (values == null) {\n            throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n        }\n        return evaluate(values, 0, values.length);\n    }\n\n    \n    @Override\n    public double evaluate(final double[] values, final int begin, final int length) {\n\n        double var = Double.NaN;\n\n        if (test(values, begin, length)) {\n            clear();\n            if (length == 1) {\n                var = 0.0;\n            } else if (length > 1) {\n                Mean mean = new Mean();\n                double m = mean.evaluate(values, begin, length);\n                var = evaluate(values, m, begin, length);\n            }\n        }\n        return var;\n    }\n\n    \n    public double evaluate(final double[] values, final double[] weights, final int begin, final int length) {\n\n        double var = Double.NaN;\n\n        if (test(values, weights,begin, length)) {\n            clear();\n            if (length == 1) {\n                var = 0.0;\n            } else if (length > 1) {\n                Mean mean = new Mean();\n                double m = mean.evaluate(values, weights, begin, length);\n                var = evaluate(values, weights, m, begin, length);\n            }\n        }\n        return var;\n    }\n\n    \n    public double evaluate(final double[] values, final double[] weights) {\n        return evaluate(values, weights, 0, values.length);\n    }\n\n    \n    public double evaluate(final double[] values, final double mean, final int begin, final int length) {\n\n        double var = Double.NaN;\n\n        if (test(values, begin, length)) {\n            if (length == 1) {\n                var = 0.0;\n            } else if (length > 1) {\n                double accum = 0.0;\n                double dev = 0.0;\n                double accum2 = 0.0;\n                for (int i = begin; i < begin + length; i++) {\n                    dev = values[i] - mean;\n                    accum += dev * dev;\n                    accum2 += dev;\n                }\n                double len = length;\n                if (isBiasCorrected) {\n                    var = (accum - (accum2 * accum2 / len)) / (len - 1.0);\n                } else {\n                    var = (accum - (accum2 * accum2 / len)) / len;\n                }\n            }\n        }\n        return var;\n    }\n\n    \n    public double evaluate(final double[] values, final double mean) {\n        return evaluate(values, mean, 0, values.length);\n    }\n\n    \n    public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) {\n\n        double var = Double.NaN;\n\n        if (test(values, weights, begin, length)) {\n            if (length == 1) {\n                var = 0.0;\n            } else if (length > 1) {\n                double accum = 0.0;\n                double dev = 0.0;\n                double accum2 = 0.0;\n                for (int i = begin; i < begin + length; i++) {\n                    dev = values[i] - mean;\n                    accum += weights[i] * (dev * dev);\n                    accum2 += weights[i] * dev;\n                }\n\n                double sumWts = 0;\n                for (int i = 0; i < weights.length; i++) {\n                    sumWts += weights[i];\n                }\n\n                if (isBiasCorrected) {\n                    var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n                } else {\n                    var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n                }\n            }\n        }\n        return var;\n    }\n\n    \n    public double evaluate(final double[] values, final double[] weights, final double mean) {\n        return evaluate(values, weights, mean, 0, values.length);\n    }\n\n    \n    public boolean isBiasCorrected() {\n        return isBiasCorrected;\n    }\n\n    \n    public void setBiasCorrected(boolean biasCorrected) {\n        this.isBiasCorrected = biasCorrected;\n    }\n\n    \n    @Override\n    public Variance copy() {\n        Variance result = new Variance();\n        copy(this, result);\n        return result;\n    }\n\n    \n    public static void copy(Variance source, Variance dest) throws NullArgumentException {\n        MathUtils.checkNotNull(source);\n        MathUtils.checkNotNull(dest);\n        dest.setData(source.getDataRef());\n        dest.moment = source.moment.copy();\n        dest.isBiasCorrected = source.isBiasCorrected;\n        dest.incMoment = source.incMoment;\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.math.stat.descriptive.moment;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math.exception.NullArgumentException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.stat.descriptive.WeightedEvaluation;\nimport org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\nimport org.apache.commons.math.util.MathUtils;\n\n\npublic class Variance extends AbstractStorelessUnivariateStatistic implements Serializable, WeightedEvaluation { private static final long serialVersionUID = -9111962718267217978L; protected SecondMoment moment = null; protected boolean incMoment = true; private boolean isBiasCorrected = true; public Variance() {\n        moment = new SecondMoment();\n    }\n\n    \n    public Variance(final SecondMoment m2) {\n        incMoment = false;\n        this.moment = m2;\n    }\n\n    \n    public Variance(boolean isBiasCorrected) {\n        moment = new SecondMoment();\n        this.isBiasCorrected = isBiasCorrected;\n    }\n\n    \n    public Variance(boolean isBiasCorrected, SecondMoment m2) {\n        incMoment = false;\n        this.moment = m2;\n        this.isBiasCorrected = isBiasCorrected;\n    }\n\n    \n    public Variance(Variance original) {\n        copy(original, this);\n    }\n\n    \n    @Override\n    public void increment(final double d) {\n        if (incMoment) {\n            moment.increment(d);\n        }\n    }\n\n    \n    @Override\n    public double getResult() {\n            if (moment.n == 0) {\n                return Double.NaN;\n            } else if (moment.n == 1) {\n                return 0d;\n            } else {\n                if (isBiasCorrected) {\n                    return moment.m2 / (moment.n - 1d);\n                } else {\n                    return moment.m2 / (moment.n);\n                }\n            }\n    }\n\n    \n    public long getN() {\n        return moment.getN();\n    }\n\n    \n    @Override\n    public void clear() {\n        if (incMoment) {\n            moment.clear();\n        }\n    }\n\n    \n    @Override\n    public double evaluate(final double[] values) {\n        if (values == null) {\n            throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n        }\n        return evaluate(values, 0, values.length);\n    }\n\n    \n    @Override\n    public double evaluate(final double[] values, final int begin, final int length) {\n\n        double var = Double.NaN;\n\n        if (test(values, begin, length)) {\n            clear();\n            if (length == 1) {\n                var = 0.0;\n            } else if (length > 1) {\n                Mean mean = new Mean();\n                double m = mean.evaluate(values, begin, length);\n                var = evaluate(values, m, begin, length);\n            }\n        }\n        return var;\n    }\n\n    \n    public double evaluate(final double[] values, final double[] weights, final int begin, final int length) {\n\n        double var = Double.NaN;\n\n        if (test(values, weights,begin, length)) {\n            clear();\n            if (length == 1) {\n                var = 0.0;\n            } else if (length > 1) {\n                Mean mean = new Mean();\n                double m = mean.evaluate(values, weights, begin, length);\n                var = evaluate(values, weights, m, begin, length);\n            }\n        }\n        return var;\n    }\n\n    \n    public double evaluate(final double[] values, final double[] weights) {\n        return evaluate(values, weights, 0, values.length);\n    }\n\n    \n    public double evaluate(final double[] values, final double mean, final int begin, final int length) {\n\n        double var = Double.NaN;\n\n        if (test(values, begin, length)) {\n            if (length == 1) {\n                var = 0.0;\n            } else if (length > 1) {\n                double accum = 0.0;\n                double dev = 0.0;\n                double accum2 = 0.0;\n                for (int i = begin; i < begin + length; i++) {\n                    dev = values[i] - mean;\n                    accum += dev * dev;\n                    accum2 += dev;\n                }\n                double len = length;\n                if (isBiasCorrected) {\n                    var = (accum - (accum2 * accum2 / len)) / (len - 1.0);\n                } else {\n                    var = (accum - (accum2 * accum2 / len)) / len;\n                }\n            }\n        }\n        return var;\n    }\n\n    \n    public double evaluate(final double[] values, final double mean) {\n        return evaluate(values, mean, 0, values.length);\n    }\n\n    \n    public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) {\n\n        double var = Double.NaN;\n\n        if (test(values, weights, begin, length)) {\n            if (length == 1) {\n                var = 0.0;\n            } else if (length > 1) {\n                double accum = 0.0;\n                double dev = 0.0;\n                double accum2 = 0.0;\n                for (int i = begin; i < begin + length; i++) {\n                    dev = values[i] - mean;\n                    accum += weights[i] * (dev * dev);\n                    accum2 += weights[i] * dev;\n                }\n\n                double sumWts = 0;\n                for (int i = begin; i < begin + length; i++) {\n                    sumWts += weights[i];\n                }\n\n                if (isBiasCorrected) {\n                    var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n                } else {\n                    var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n                }\n            }\n        }\n        return var;\n    }\n\n    \n    public double evaluate(final double[] values, final double[] weights, final double mean) {\n        return evaluate(values, weights, mean, 0, values.length);\n    }\n\n    \n    public boolean isBiasCorrected() {\n        return isBiasCorrected;\n    }\n\n    \n    public void setBiasCorrected(boolean biasCorrected) {\n        this.isBiasCorrected = biasCorrected;\n    }\n\n    \n    @Override\n    public Variance copy() {\n        Variance result = new Variance();\n        copy(this, result);\n        return result;\n    }\n\n    \n    public static void copy(Variance source, Variance dest) throws NullArgumentException {\n        MathUtils.checkNotNull(source);\n        MathUtils.checkNotNull(dest);\n        dest.setData(source.getDataRef());\n        dest.moment = source.moment.copy();\n        dest.isBiasCorrected = source.isBiasCorrected;\n        dest.incMoment = source.incMoment;\n    }\n}\n",
      "buggy_signatures": [
        "public Variance(final SecondMoment m2)",
        "public Variance(boolean isBiasCorrected)",
        "public Variance(boolean isBiasCorrected, SecondMoment m2)",
        "public Variance(Variance original)",
        "public void increment(final double d)",
        "public double getResult()",
        "public long getN()",
        "public void clear()",
        "public double evaluate(final double[] values)",
        "public double evaluate(final double[] values, final int begin, final int length)",
        "public double evaluate(final double[] values, final double[] weights, final int begin, final int length)",
        "public double evaluate(final double[] values, final double[] weights)",
        "public double evaluate(final double[] values, final double mean, final int begin, final int length)",
        "public double evaluate(final double[] values, final double mean)",
        "public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length)",
        "public double evaluate(final double[] values, final double[] weights, final double mean)",
        "public boolean isBiasCorrected()",
        "public void setBiasCorrected(boolean biasCorrected)",
        "public Variance copy()",
        "public static void copy(Variance source, Variance dest) throws NullArgumentException"
      ],
      "fixed_signatures": [
        "public Variance(final SecondMoment m2)",
        "public Variance(boolean isBiasCorrected)",
        "public Variance(boolean isBiasCorrected, SecondMoment m2)",
        "public Variance(Variance original)",
        "public void increment(final double d)",
        "public double getResult()",
        "public long getN()",
        "public void clear()",
        "public double evaluate(final double[] values)",
        "public double evaluate(final double[] values, final int begin, final int length)",
        "public double evaluate(final double[] values, final double[] weights, final int begin, final int length)",
        "public double evaluate(final double[] values, final double[] weights)",
        "public double evaluate(final double[] values, final double mean, final int begin, final int length)",
        "public double evaluate(final double[] values, final double mean)",
        "public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length)",
        "public double evaluate(final double[] values, final double[] weights, final double mean)",
        "public boolean isBiasCorrected()",
        "public void setBiasCorrected(boolean biasCorrected)",
        "public Variance copy()",
        "public static void copy(Variance source, Variance dest) throws NullArgumentException"
      ],
      "methods": [
        {
          "buggy_method": "  public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) {\n\n  double var = Double.NaN;\n\n  if (test(values, weights, begin, length)) {\n  if (length == 1) {\n  var = 0.0;\n  } else if (length > 1) {\n  double accum = 0.0;\n  double dev = 0.0;\n  double accum2 = 0.0;\n  for (int i = begin; i < begin + length; i++) {\n  dev = values[i] - mean;\n  accum += weights[i] * (dev * dev);\n  accum2 += weights[i] * dev;\n  }\n\n  double sumWts = 0;\n  for (int i = 0; i < weights.length; i++) {\n  sumWts += weights[i];\n  }\n\n  if (isBiasCorrected) {\n  var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n  } else {\n  var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n  }\n  }\n  }\n  return var;\n  }",
          "fixed_method": "  public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) {\n\n  double var = Double.NaN;\n\n  if (test(values, weights, begin, length)) {\n  if (length == 1) {\n  var = 0.0;\n  } else if (length > 1) {\n  double accum = 0.0;\n  double dev = 0.0;\n  double accum2 = 0.0;\n  for (int i = begin; i < begin + length; i++) {\n  dev = values[i] - mean;\n  accum += weights[i] * (dev * dev);\n  accum2 += weights[i] * dev;\n  }\n\n  double sumWts = 0;\n  for (int i = begin; i < begin + length; i++) {\n  sumWts += weights[i];\n  }\n\n  if (isBiasCorrected) {\n  var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n  } else {\n  var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n  }\n  }\n  }\n  return var;\n  }",
          "diff": [
            "@@ -517,7 +517,7 @@",
            "                 }\n",
            " \n",
            "                 double sumWts = 0;\n",
            "-                for (int i = 0; i < weights.length; i++) {\n",
            "+                for (int i = begin; i < begin + length; i++) {\n",
            "                     sumWts += weights[i];\n",
            "                 }\n",
            " \n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
