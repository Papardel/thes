{
  "bug_id": "13",
  "failed_tests": {
    "org.apache.commons.csv.CSVPrinterTest": [
      {
        "methodName": "testMySqlNullOutput",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<\"NULL\"\t[NULL]",
        "fail_line": "        assertEquals(expected, writer.toString());",
        "test_source": "  public void testMySqlNullOutput() throws IOException {\n  Object[] s = new String[] { \"NULL\", null };\n  CSVFormat format = CSVFormat.MYSQL.withQuote('\"').withNullString(\"NULL\").withQuoteMode(QuoteMode.NON_NUMERIC);\n  StringWriter writer = new StringWriter();\n  CSVPrinter printer = new CSVPrinter(writer, format);\n  printer.printRecord(s);\n  printer.close();\n  String expected = \"\\\"NULL\\\"\\tNULL\\n\";\n  assertEquals(expected, writer.toString());\n  String[] record0 = toFirstRecordValues(expected, format);\n  assertArrayEquals(new Object[2], record0);\n\n  s = new String[] { \"\\\\N\", null };\n  format = CSVFormat.MYSQL.withNullString(\"\\\\N\");\n  writer = new StringWriter();\n  printer = new CSVPrinter(writer, format);\n  printer.printRecord(s);\n  printer.close();\n  expected = \"\\\\\\\\N\\t\\\\N\\n\";\n  assertEquals(expected, writer.toString());\n  record0 = toFirstRecordValues(expected, format);\n  assertArrayEquals(expectNulls(s, format), record0);\n\n  s = new String[] { \"\\\\N\", \"A\" };\n  format = CSVFormat.MYSQL.withNullString(\"\\\\N\");\n  writer = new StringWriter();\n  printer = new CSVPrinter(writer, format);\n  printer.printRecord(s);\n  printer.close();\n  expected = \"\\\\\\\\N\\tA\\n\";\n  assertEquals(expected, writer.toString());\n  record0 = toFirstRecordValues(expected, format);\n  assertArrayEquals(expectNulls(s, format), record0);\n\n  s = new String[] { \"\\n\", \"A\" };\n  format = CSVFormat.MYSQL.withNullString(\"\\\\N\");\n  writer = new StringWriter();\n  printer = new CSVPrinter(writer, format);\n  printer.printRecord(s);\n  printer.close();\n  expected = \"\\\\n\\tA\\n\";\n  assertEquals(expected, writer.toString());\n  record0 = toFirstRecordValues(expected, format);\n  assertArrayEquals(expectNulls(s, format), record0);\n\n  s = new String[] { \"\", null };\n  format = CSVFormat.MYSQL.withNullString(\"NULL\");\n  writer = new StringWriter();\n  printer = new CSVPrinter(writer, format);\n  printer.printRecord(s);\n  printer.close();\n  expected = \"\\tNULL\\n\";\n  assertEquals(expected, writer.toString());\n  record0 = toFirstRecordValues(expected, format);\n  assertArrayEquals(expectNulls(s, format), record0);\n\n  s = new String[] { \"\", null };\n  format = CSVFormat.MYSQL;\n  writer = new StringWriter();\n  printer = new CSVPrinter(writer, format);\n  printer.printRecord(s);\n  printer.close();\n  expected = \"\\t\\\\N\\n\";\n  assertEquals(expected, writer.toString());\n  record0 = toFirstRecordValues(expected, format);\n  assertArrayEquals(expectNulls(s, format), record0);\n\n  s = new String[] { \"\\\\N\", \"\", \"\\u000e,\\\\\\r\" };\n  format = CSVFormat.MYSQL;\n  writer = new StringWriter();\n  printer = new CSVPrinter(writer, format);\n  printer.printRecord(s);\n  printer.close();\n  expected = \"\\\\\\\\N\\t\\t\\u000e,\\\\\\\\\\\\r\\n\";\n  assertEquals(expected, writer.toString());\n  record0 = toFirstRecordValues(expected, format);\n  assertArrayEquals(expectNulls(s, format), record0);\n\n  s = new String[] { \"NULL\", \"\\\\\\r\" };\n  format = CSVFormat.MYSQL;\n  writer = new StringWriter();\n  printer = new CSVPrinter(writer, format);\n  printer.printRecord(s);\n  printer.close();\n  expected = \"NULL\\t\\\\\\\\\\\\r\\n\";\n  assertEquals(expected, writer.toString());\n  record0 = toFirstRecordValues(expected, format);\n  assertArrayEquals(expectNulls(s, format), record0);\n\n  s = new String[] { \"\\\\\\r\" };\n  format = CSVFormat.MYSQL;\n  writer = new StringWriter();\n  printer = new CSVPrinter(writer, format);\n  printer.printRecord(s);\n  printer.close();\n  expected = \"\\\\\\\\\\\\r\\n\";\n  assertEquals(expected, writer.toString());\n  record0 = toFirstRecordValues(expected, format);\n  assertArrayEquals(expectNulls(s, format), record0);\n  }",
        "stack": [
          "CSVPrinterTest.testMySqlNullOutput line 331"
        ]
      },
      {
        "methodName": "testMySqlNullStringDefault",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<\\N> but was:<null>",
        "fail_line": "        assertEquals(\"\\\\N\", CSVFormat.MYSQL.getNullString());",
        "test_source": "  public void testMySqlNullStringDefault() throws IOException {\n  assertEquals(\"\\\\N\", CSVFormat.MYSQL.getNullString());\n  }",
        "stack": [
          "CSVPrinterTest.testMySqlNullStringDefault line 319"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/csv/CSVFormat.java",
      "buggy_full_code": "\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH; import static org.apache.commons.csv.Constants.COMMA; import static org.apache.commons.csv.Constants.CR; import static org.apache.commons.csv.Constants.CRLF; import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR; import static org.apache.commons.csv.Constants.LF; import static org.apache.commons.csv.Constants.TAB; import java.io.IOException; import java.io.Reader; import java.io.Serializable; import java.io.StringWriter; import java.sql.ResultSet; import java.sql.ResultSetMetaData; import java.sql.SQLException; import java.util.Arrays; import java.util.HashSet; import java.util.Set; public final class CSVFormat implements Serializable { public static enum Predefined { Default(CSVFormat.DEFAULT), Excel(CSVFormat.EXCEL), MySQL(CSVFormat.MYSQL), RFC4180(CSVFormat.RFC4180), TDF(CSVFormat.TDF); private final CSVFormat format; private Predefined(final CSVFormat format) {\n            this.format = format;\n        }\n        \n        \n        public CSVFormat getFormat() {\n            return format;\n        }\n    };\n    \n    private static final long serialVersionUID = 1L; private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase; public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF); private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    \n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    \n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false, false);\n    }\n\n    \n    public static CSVFormat valueOf(final String format) {\n        return CSVFormat.Predefined.valueOf(format).getFormat();\n    }\n\n    \n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        validate();\n    }\n\n    private String[] toStringArray(final Object[] values) {\n        if (values == null) {\n            return null;\n        }\n        final String[] strings = new String[values.length];\n        for (int i = 0; i < values.length; i++) {\n            final Object value = values[i];\n            strings[i] = value == null ? null : value.toString();\n        }\n        return strings;\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (quoteMode != other.quoteMode) {\n            return false;\n        }\n        if (quoteCharacter == null) {\n            if (other.quoteCharacter != null) {\n                return false;\n            }\n        } else if (!quoteCharacter.equals(other.quoteCharacter)) {\n            return false;\n        }\n        if (commentMarker == null) {\n            if (other.commentMarker != null) {\n                return false;\n            }\n        } else if (!commentMarker.equals(other.commentMarker)) {\n            return false;\n        }\n        if (escapeCharacter == null) {\n            if (other.escapeCharacter != null) {\n                return false;\n            }\n        } else if (!escapeCharacter.equals(other.escapeCharacter)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        return true;\n    }\n\n    \n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try {\n            new CSVPrinter(out, this).printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            \n            throw new IllegalStateException(e);\n        }\n    }\n\n    \n    public Character getCommentMarker() {\n        return commentMarker;\n    }\n\n    \n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    \n    public Character getEscapeCharacter() {\n        return escapeCharacter;\n    }\n\n    \n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    \n    public String[] getHeaderComments() {\n        return headerComments != null ? headerComments.clone() : null;\n    }\n\n    \n    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }\n\n    \n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    \n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    \n    public boolean getIgnoreHeaderCase() {\n        return ignoreHeaderCase;\n    }\n\n    \n    public String getNullString() {\n        return nullString;\n    }\n\n    \n    public Character getQuoteCharacter() {\n        return quoteCharacter;\n    }\n\n    \n    public QuoteMode getQuoteMode() {\n        return quoteMode;\n    }\n\n    \n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    \n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());\n        result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());\n        result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());\n        result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreHeaderCase ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        return result;\n    }\n\n    \n    public boolean isCommentMarkerSet() {\n        return commentMarker != null;\n    }\n\n    \n    public boolean isEscapeCharacterSet() {\n        return escapeCharacter != null;\n    }\n\n    \n    public boolean isNullStringSet() {\n        return nullString != null;\n    }\n\n    \n    public boolean isQuoteCharacterSet() {\n        return quoteCharacter != null;\n    }\n\n    \n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    \n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if (recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        if (getIgnoreHeaderCase()) {\n            sb.append(\" IgnoreHeaderCase:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (headerComments != null) {\n            sb.append(' ');\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\n        }\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    \n    private void validate() throws IllegalArgumentException {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        \n        if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n            throw new IllegalArgumentException(\"The quoteChar character and the delimiter cannot be the same ('\" +\n                    quoteCharacter + \"')\");\n        }\n\n        if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n            throw new IllegalArgumentException(\"The escape character and the delimiter cannot be the same ('\" +\n                    escapeCharacter + \"')\");\n        }\n\n        if (commentMarker != null && delimiter == commentMarker.charValue()) {\n            throw new IllegalArgumentException(\"The comment start character and the delimiter cannot be the same ('\" +\n                    commentMarker + \"')\");\n        }\n\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start character and the quoteChar cannot be the same ('\" +\n                    commentMarker + \"')\");\n        }\n\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start and the escape character cannot be the same ('\" +\n                    commentMarker + \"')\");\n        }\n\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n        }\n        \n        \n        if (header != null) {\n            final Set<String> dupCheck = new HashSet<String>();\n            for (final String hdr : header) {\n                if (!dupCheck.add(hdr)) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate entry: '\" + hdr + \"' in \" +\n                            Arrays.toString(header));\n                }\n            }\n        }\n    }\n\n    \n    public CSVFormat withCommentMarker(final char commentMarker) {\n        return withCommentMarker(Character.valueOf(commentMarker));\n    }\n\n    \n    public CSVFormat withCommentMarker(final Character commentMarker) {\n        if (isLineBreak(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    \n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\n        return withHeader(resultSet != null ? resultSet.getMetaData() : null);\n    }\n\n    \n    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException {\n        String[] labels = null;\n        if (metaData != null) {\n            final int columnCount = metaData.getColumnCount();\n            labels = new String[columnCount];\n            for (int i = 0; i < columnCount; i++) {\n                labels[i] = metaData.getColumnLabel(i + 1);\n            }\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, labels,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withHeaderComments(final Object... headerComments) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withAllowMissingColumnNames() {\n        return this.withAllowMissingColumnNames(true);\n    }\n\n    \n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withIgnoreEmptyLines() {\n        return this.withIgnoreEmptyLines(true);\n    }\n\n    \n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withIgnoreSurroundingSpaces() {\n        return this.withIgnoreSurroundingSpaces(true);\n    }\n\n    \n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withIgnoreHeaderCase() {\n        return this.withIgnoreHeaderCase(true);\n    }\n\n    \n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withQuote(final char quoteChar) {\n        return withQuote(Character.valueOf(quoteChar));\n    }\n\n    \n    public CSVFormat withQuote(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    \n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withSkipHeaderRecord() {\n        return this.withSkipHeaderRecord(true);\n    }\n\n    \n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH; import static org.apache.commons.csv.Constants.COMMA; import static org.apache.commons.csv.Constants.CR; import static org.apache.commons.csv.Constants.CRLF; import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR; import static org.apache.commons.csv.Constants.LF; import static org.apache.commons.csv.Constants.TAB; import java.io.IOException; import java.io.Reader; import java.io.Serializable; import java.io.StringWriter; import java.sql.ResultSet; import java.sql.ResultSetMetaData; import java.sql.SQLException; import java.util.Arrays; import java.util.HashSet; import java.util.Set; public final class CSVFormat implements Serializable { public static enum Predefined { Default(CSVFormat.DEFAULT), Excel(CSVFormat.EXCEL), MySQL(CSVFormat.MYSQL), RFC4180(CSVFormat.RFC4180), TDF(CSVFormat.TDF); private final CSVFormat format; private Predefined(final CSVFormat format) {\n            this.format = format;\n        }\n        \n        \n        public CSVFormat getFormat() {\n            return format;\n        }\n    };\n    \n    private static final long serialVersionUID = 1L; private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase; public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(\"\\\\N\"); private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    \n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    \n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false, false);\n    }\n\n    \n    public static CSVFormat valueOf(final String format) {\n        return CSVFormat.Predefined.valueOf(format).getFormat();\n    }\n\n    \n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        validate();\n    }\n\n    private String[] toStringArray(final Object[] values) {\n        if (values == null) {\n            return null;\n        }\n        final String[] strings = new String[values.length];\n        for (int i = 0; i < values.length; i++) {\n            final Object value = values[i];\n            strings[i] = value == null ? null : value.toString();\n        }\n        return strings;\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (quoteMode != other.quoteMode) {\n            return false;\n        }\n        if (quoteCharacter == null) {\n            if (other.quoteCharacter != null) {\n                return false;\n            }\n        } else if (!quoteCharacter.equals(other.quoteCharacter)) {\n            return false;\n        }\n        if (commentMarker == null) {\n            if (other.commentMarker != null) {\n                return false;\n            }\n        } else if (!commentMarker.equals(other.commentMarker)) {\n            return false;\n        }\n        if (escapeCharacter == null) {\n            if (other.escapeCharacter != null) {\n                return false;\n            }\n        } else if (!escapeCharacter.equals(other.escapeCharacter)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        return true;\n    }\n\n    \n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try {\n            new CSVPrinter(out, this).printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            \n            throw new IllegalStateException(e);\n        }\n    }\n\n    \n    public Character getCommentMarker() {\n        return commentMarker;\n    }\n\n    \n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    \n    public Character getEscapeCharacter() {\n        return escapeCharacter;\n    }\n\n    \n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    \n    public String[] getHeaderComments() {\n        return headerComments != null ? headerComments.clone() : null;\n    }\n\n    \n    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }\n\n    \n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    \n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    \n    public boolean getIgnoreHeaderCase() {\n        return ignoreHeaderCase;\n    }\n\n    \n    public String getNullString() {\n        return nullString;\n    }\n\n    \n    public Character getQuoteCharacter() {\n        return quoteCharacter;\n    }\n\n    \n    public QuoteMode getQuoteMode() {\n        return quoteMode;\n    }\n\n    \n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    \n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());\n        result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());\n        result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());\n        result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreHeaderCase ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        return result;\n    }\n\n    \n    public boolean isCommentMarkerSet() {\n        return commentMarker != null;\n    }\n\n    \n    public boolean isEscapeCharacterSet() {\n        return escapeCharacter != null;\n    }\n\n    \n    public boolean isNullStringSet() {\n        return nullString != null;\n    }\n\n    \n    public boolean isQuoteCharacterSet() {\n        return quoteCharacter != null;\n    }\n\n    \n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    \n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if (recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        if (getIgnoreHeaderCase()) {\n            sb.append(\" IgnoreHeaderCase:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (headerComments != null) {\n            sb.append(' ');\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\n        }\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    \n    private void validate() throws IllegalArgumentException {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        \n        if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n            throw new IllegalArgumentException(\"The quoteChar character and the delimiter cannot be the same ('\" +\n                    quoteCharacter + \"')\");\n        }\n\n        if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n            throw new IllegalArgumentException(\"The escape character and the delimiter cannot be the same ('\" +\n                    escapeCharacter + \"')\");\n        }\n\n        if (commentMarker != null && delimiter == commentMarker.charValue()) {\n            throw new IllegalArgumentException(\"The comment start character and the delimiter cannot be the same ('\" +\n                    commentMarker + \"')\");\n        }\n\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start character and the quoteChar cannot be the same ('\" +\n                    commentMarker + \"')\");\n        }\n\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start and the escape character cannot be the same ('\" +\n                    commentMarker + \"')\");\n        }\n\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n        }\n        \n        \n        if (header != null) {\n            final Set<String> dupCheck = new HashSet<String>();\n            for (final String hdr : header) {\n                if (!dupCheck.add(hdr)) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate entry: '\" + hdr + \"' in \" +\n                            Arrays.toString(header));\n                }\n            }\n        }\n    }\n\n    \n    public CSVFormat withCommentMarker(final char commentMarker) {\n        return withCommentMarker(Character.valueOf(commentMarker));\n    }\n\n    \n    public CSVFormat withCommentMarker(final Character commentMarker) {\n        if (isLineBreak(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    \n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\n        return withHeader(resultSet != null ? resultSet.getMetaData() : null);\n    }\n\n    \n    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException {\n        String[] labels = null;\n        if (metaData != null) {\n            final int columnCount = metaData.getColumnCount();\n            labels = new String[columnCount];\n            for (int i = 0; i < columnCount; i++) {\n                labels[i] = metaData.getColumnLabel(i + 1);\n            }\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, labels,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withHeaderComments(final Object... headerComments) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withAllowMissingColumnNames() {\n        return this.withAllowMissingColumnNames(true);\n    }\n\n    \n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withIgnoreEmptyLines() {\n        return this.withIgnoreEmptyLines(true);\n    }\n\n    \n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withIgnoreSurroundingSpaces() {\n        return this.withIgnoreSurroundingSpaces(true);\n    }\n\n    \n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withIgnoreHeaderCase() {\n        return this.withIgnoreHeaderCase(true);\n    }\n\n    \n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withQuote(final char quoteChar) {\n        return withQuote(Character.valueOf(quoteChar));\n    }\n\n    \n    public CSVFormat withQuote(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    \n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    \n    public CSVFormat withSkipHeaderRecord() {\n        return this.withSkipHeaderRecord(true);\n    }\n\n    \n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n}\n",
      "buggy_signatures": [
        "static org.apache.commons.csv.Constants.BACKSLASH; import static org.apache.commons.csv.Constants.COMMA; import static org.apache.commons.csv.Constants.CR; import static org.apache.commons.csv.Constants.CRLF; import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR; import static org.apache.commons.csv.Constants.LF; import static org.apache.commons.csv.Constants.TAB; import java.io.IOException; import java.io.Reader; import java.io.Serializable; import java.io.StringWriter; import java.sql.ResultSet; import java.sql.ResultSetMetaData; import java.sql.SQLException; import java.util.Arrays; import java.util.HashSet; import java.util.Set; public final class CSVFormat implements Serializable { public static enum Predefined { Default(CSVFormat.DEFAULT), Excel(CSVFormat.EXCEL), MySQL(CSVFormat.MYSQL), RFC4180(CSVFormat.RFC4180), TDF(CSVFormat.TDF); private final CSVFormat format; private Predefined(final CSVFormat format)",
        "public CSVFormat getFormat()",
        "private static boolean isLineBreak(final Character c)",
        "public static CSVFormat newFormat(final char delimiter)",
        "public static CSVFormat valueOf(final String format)",
        "private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase)",
        "private String[] toStringArray(final Object[] values)",
        "public boolean equals(final Object obj)",
        "public String format(final Object... values)",
        "public Character getCommentMarker()",
        "public char getDelimiter()",
        "public Character getEscapeCharacter()",
        "public String[] getHeader()",
        "public String[] getHeaderComments()",
        "public boolean getAllowMissingColumnNames()",
        "public boolean getIgnoreEmptyLines()",
        "public boolean getIgnoreSurroundingSpaces()",
        "public boolean getIgnoreHeaderCase()",
        "public String getNullString()",
        "public Character getQuoteCharacter()",
        "public QuoteMode getQuoteMode()",
        "public String getRecordSeparator()",
        "public boolean getSkipHeaderRecord()",
        "public int hashCode()",
        "public boolean isCommentMarkerSet()",
        "public boolean isEscapeCharacterSet()",
        "public boolean isNullStringSet()",
        "public boolean isQuoteCharacterSet()",
        "public CSVParser parse(final Reader in) throws IOException",
        "public CSVPrinter print(final Appendable out) throws IOException",
        "public String toString()",
        "private void validate() throws IllegalArgumentException",
        "public CSVFormat withCommentMarker(final char commentMarker)",
        "public CSVFormat withCommentMarker(final Character commentMarker)",
        "public CSVFormat withDelimiter(final char delimiter)",
        "public CSVFormat withEscape(final char escape)",
        "public CSVFormat withEscape(final Character escape)",
        "public CSVFormat withHeader(final String... header)",
        "public CSVFormat withHeader(final ResultSet resultSet) throws SQLException",
        "public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException",
        "public CSVFormat withHeaderComments(final Object... headerComments)",
        "public CSVFormat withAllowMissingColumnNames()",
        "public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames)",
        "public CSVFormat withIgnoreEmptyLines()",
        "public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines)",
        "public CSVFormat withIgnoreSurroundingSpaces()",
        "public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces)",
        "public CSVFormat withIgnoreHeaderCase()",
        "public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase)",
        "public CSVFormat withNullString(final String nullString)",
        "public CSVFormat withQuote(final char quoteChar)",
        "public CSVFormat withQuote(final Character quoteChar)",
        "public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy)",
        "public CSVFormat withRecordSeparator(final char recordSeparator)",
        "public CSVFormat withRecordSeparator(final String recordSeparator)",
        "public CSVFormat withSkipHeaderRecord()",
        "public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord)"
      ],
      "fixed_signatures": [
        "static org.apache.commons.csv.Constants.BACKSLASH; import static org.apache.commons.csv.Constants.COMMA; import static org.apache.commons.csv.Constants.CR; import static org.apache.commons.csv.Constants.CRLF; import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR; import static org.apache.commons.csv.Constants.LF; import static org.apache.commons.csv.Constants.TAB; import java.io.IOException; import java.io.Reader; import java.io.Serializable; import java.io.StringWriter; import java.sql.ResultSet; import java.sql.ResultSetMetaData; import java.sql.SQLException; import java.util.Arrays; import java.util.HashSet; import java.util.Set; public final class CSVFormat implements Serializable { public static enum Predefined { Default(CSVFormat.DEFAULT), Excel(CSVFormat.EXCEL), MySQL(CSVFormat.MYSQL), RFC4180(CSVFormat.RFC4180), TDF(CSVFormat.TDF); private final CSVFormat format; private Predefined(final CSVFormat format)",
        "public CSVFormat getFormat()",
        "private static boolean isLineBreak(final Character c)",
        "public static CSVFormat newFormat(final char delimiter)",
        "public static CSVFormat valueOf(final String format)",
        "private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase)",
        "private String[] toStringArray(final Object[] values)",
        "public boolean equals(final Object obj)",
        "public String format(final Object... values)",
        "public Character getCommentMarker()",
        "public char getDelimiter()",
        "public Character getEscapeCharacter()",
        "public String[] getHeader()",
        "public String[] getHeaderComments()",
        "public boolean getAllowMissingColumnNames()",
        "public boolean getIgnoreEmptyLines()",
        "public boolean getIgnoreSurroundingSpaces()",
        "public boolean getIgnoreHeaderCase()",
        "public String getNullString()",
        "public Character getQuoteCharacter()",
        "public QuoteMode getQuoteMode()",
        "public String getRecordSeparator()",
        "public boolean getSkipHeaderRecord()",
        "public int hashCode()",
        "public boolean isCommentMarkerSet()",
        "public boolean isEscapeCharacterSet()",
        "public boolean isNullStringSet()",
        "public boolean isQuoteCharacterSet()",
        "public CSVParser parse(final Reader in) throws IOException",
        "public CSVPrinter print(final Appendable out) throws IOException",
        "public String toString()",
        "private void validate() throws IllegalArgumentException",
        "public CSVFormat withCommentMarker(final char commentMarker)",
        "public CSVFormat withCommentMarker(final Character commentMarker)",
        "public CSVFormat withDelimiter(final char delimiter)",
        "public CSVFormat withEscape(final char escape)",
        "public CSVFormat withEscape(final Character escape)",
        "public CSVFormat withHeader(final String... header)",
        "public CSVFormat withHeader(final ResultSet resultSet) throws SQLException",
        "public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException",
        "public CSVFormat withHeaderComments(final Object... headerComments)",
        "public CSVFormat withAllowMissingColumnNames()",
        "public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames)",
        "public CSVFormat withIgnoreEmptyLines()",
        "public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines)",
        "public CSVFormat withIgnoreSurroundingSpaces()",
        "public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces)",
        "public CSVFormat withIgnoreHeaderCase()",
        "public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase)",
        "public CSVFormat withNullString(final String nullString)",
        "public CSVFormat withQuote(final char quoteChar)",
        "public CSVFormat withQuote(final Character quoteChar)",
        "public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy)",
        "public CSVFormat withRecordSeparator(final char recordSeparator)",
        "public CSVFormat withRecordSeparator(final String recordSeparator)",
        "public CSVFormat withSkipHeaderRecord()",
        "public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord)"
      ],
      "methods": [
        {
          "buggy_method": "  public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF); private static boolean isLineBreak(final char c) {\n  return c == LF || c == CR;\n  }",
          "fixed_method": "  public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(\"\\\\N\"); private static boolean isLineBreak(final char c) {\n  return c == LF || c == CR;\n  }",
          "diff": [
            "@@ -316,7 +316,7 @@",
            "      *      http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a>\n",
            "      */\n",
            "     public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false)\n",
            "-            .withQuote(null).withRecordSeparator(LF);\n",
            "+            .withQuote(null).withRecordSeparator(LF).withNullString(\"\\\\N\");\n",
            " \n",
            "     /**\n",
            "      * Returns true if the given character is a line break character.\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "org/apache/commons/csv/CSVPrinter.java",
      "buggy_full_code": "\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.COMMENT; import static org.apache.commons.csv.Constants.CR; import static org.apache.commons.csv.Constants.LF; import static org.apache.commons.csv.Constants.SP; import java.io.Closeable; import java.io.Flushable; import java.io.IOException; import java.sql.ResultSet; import java.sql.SQLException; public final class CSVPrinter implements Flushable, Closeable { private final Appendable out; private final CSVFormat format; private boolean newRecord = true; public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {\n        Assertions.notNull(out, \"out\");\n        Assertions.notNull(format, \"format\");\n\n        this.out = out;\n        this.format = format;\n        \n        \n        if (format.getHeaderComments() != null) {\n            for (final String line : format.getHeaderComments()) {\n                if (line != null) {\n                    this.printComment(line);\n                }\n            }\n        }\n        if (format.getHeader() != null && !format.getSkipHeaderRecord()) {\n            this.printRecord((Object[]) format.getHeader());\n        }\n    }\n\n    \n    \n    \n\n    @Override\n    public void close() throws IOException {\n        if (out instanceof Closeable) {\n            ((Closeable) out).close();\n        }\n    }\n\n    \n    @Override\n    public void flush() throws IOException {\n        if (out instanceof Flushable) {\n            ((Flushable) out).flush();\n        }\n    }\n\n    \n    public Appendable getOut() {\n        return this.out;\n    }\n\n    \n    public void print(final Object value) throws IOException {\n        \n        String strValue;\n        if (value == null) {\n            final String nullString = format.getNullString();\n            strValue = nullString == null ? Constants.EMPTY : nullString;\n        } else {\n            strValue = value.toString();\n        }\n        this.print(value, strValue, 0, strValue.length());\n    }\n\n    private void print(final Object object, final CharSequence value, final int offset, final int len) throws IOException {\n        if (!newRecord) {\n            out.append(format.getDelimiter());\n        }\n        if (format.isQuoteCharacterSet()) {\n            \n            printAndQuote(object, value, offset, len);\n        } else if (format.isEscapeCharacterSet()) {\n            printAndEscape(value, offset, len);\n        } else {\n            out.append(value, offset, offset + len);\n        }\n        newRecord = false;\n    }\n\n    \n    private void printAndEscape(final CharSequence value, final int offset, final int len) throws IOException {\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delim = format.getDelimiter();\n        final char escape = format.getEscapeCharacter().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                \n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; \n            }\n\n            pos++;\n        }\n\n        \n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n\n    \n    \n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = format.getDelimiter();\n        final char quoteChar = format.getQuoteCharacter().charValue();\n\n        QuoteMode quoteModePolicy = format.getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            \n            printAndEscape(value, offset, len);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                \n                \n                \n                \n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                \n                if (newRecord && (c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || (c > 'z'))) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n                    \n                    \n                    \n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        \n                        \n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                \n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        if (!quote) {\n            \n            out.append(value, start, end);\n            return;\n        }\n\n        \n        out.append(quoteChar);\n\n        \n        \n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                \n\n                \n                out.append(value, start, pos + 1);\n                \n                \n                start = pos;\n            }\n            pos++;\n        }\n\n        \n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    \n    public void printComment(final String comment) throws IOException {\n        if (!format.isCommentMarkerSet()) {\n            return;\n        }\n        if (!newRecord) {\n            println();\n        }\n        out.append(format.getCommentMarker().charValue());\n        out.append(SP);\n        for (int i = 0; i < comment.length(); i++) {\n            final char c = comment.charAt(i);\n            switch (c) {\n            case CR:\n                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {\n                    i++;\n                }\n                \n            case LF:\n                println();\n                out.append(format.getCommentMarker().charValue());\n                out.append(SP);\n                break;\n            default:\n                out.append(c);\n                break;\n            }\n        }\n        println();\n    }\n\n    \n    public void println() throws IOException {\n        final String recordSeparator = format.getRecordSeparator();\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n        newRecord = true;\n    }\n\n    \n    public void printRecord(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n            print(value);\n        }\n        println();\n    }\n\n    \n    public void printRecord(final Object... values) throws IOException {\n        for (final Object value : values) {\n            print(value);\n        }\n        println();\n    }\n\n    \n    public void printRecords(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n            if (value instanceof Object[]) {\n                this.printRecord((Object[]) value);\n            } else if (value instanceof Iterable) {\n                this.printRecord((Iterable<?>) value);\n            } else {\n                this.printRecord(value);\n            }\n        }\n    }\n\n    \n    public void printRecords(final Object... values) throws IOException {\n        for (final Object value : values) {\n            if (value instanceof Object[]) {\n                this.printRecord((Object[]) value);\n            } else if (value instanceof Iterable) {\n                this.printRecord((Iterable<?>) value);\n            } else {\n                this.printRecord(value);\n            }\n        }\n    }\n\n    \n    public void printRecords(final ResultSet resultSet) throws SQLException, IOException {\n        final int columnCount = resultSet.getMetaData().getColumnCount();\n        while (resultSet.next()) {\n            for (int i = 1; i <= columnCount; i++) {\n                print(resultSet.getObject(i));\n            }\n            println();\n        }\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.COMMENT; import static org.apache.commons.csv.Constants.CR; import static org.apache.commons.csv.Constants.LF; import static org.apache.commons.csv.Constants.SP; import java.io.Closeable; import java.io.Flushable; import java.io.IOException; import java.sql.ResultSet; import java.sql.SQLException; public final class CSVPrinter implements Flushable, Closeable { private final Appendable out; private final CSVFormat format; private boolean newRecord = true; public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {\n        Assertions.notNull(out, \"out\");\n        Assertions.notNull(format, \"format\");\n\n        this.out = out;\n        this.format = format;\n        \n        \n        if (format.getHeaderComments() != null) {\n            for (final String line : format.getHeaderComments()) {\n                if (line != null) {\n                    this.printComment(line);\n                }\n            }\n        }\n        if (format.getHeader() != null && !format.getSkipHeaderRecord()) {\n            this.printRecord((Object[]) format.getHeader());\n        }\n    }\n\n    \n    \n    \n\n    @Override\n    public void close() throws IOException {\n        if (out instanceof Closeable) {\n            ((Closeable) out).close();\n        }\n    }\n\n    \n    @Override\n    public void flush() throws IOException {\n        if (out instanceof Flushable) {\n            ((Flushable) out).flush();\n        }\n    }\n\n    \n    public Appendable getOut() {\n        return this.out;\n    }\n\n    \n    public void print(final Object value) throws IOException {\n        \n        String strValue;\n        if (value == null) {\n            final String nullString = format.getNullString();\n            strValue = nullString == null ? Constants.EMPTY : nullString;\n        } else {\n            strValue = value.toString();\n        }\n        this.print(value, strValue, 0, strValue.length());\n    }\n\n    private void print(final Object object, final CharSequence value, final int offset, final int len) throws IOException {\n        if (!newRecord) {\n            out.append(format.getDelimiter());\n        }\n        if (object == null) {\n            out.append(value);\n        } else if (format.isQuoteCharacterSet()) {\n            \n            printAndQuote(object, value, offset, len);\n        } else if (format.isEscapeCharacterSet()) {\n            printAndEscape(value, offset, len);\n        } else {\n            out.append(value, offset, offset + len);\n        }\n        newRecord = false;\n    }\n\n    \n    private void printAndEscape(final CharSequence value, final int offset, final int len) throws IOException {\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delim = format.getDelimiter();\n        final char escape = format.getEscapeCharacter().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                \n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; \n            }\n\n            pos++;\n        }\n\n        \n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n\n    \n    \n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = format.getDelimiter();\n        final char quoteChar = format.getQuoteCharacter().charValue();\n\n        QuoteMode quoteModePolicy = format.getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            \n            printAndEscape(value, offset, len);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                \n                \n                \n                \n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                \n                if (newRecord && (c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || (c > 'z'))) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n                    \n                    \n                    \n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        \n                        \n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                \n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        if (!quote) {\n            \n            out.append(value, start, end);\n            return;\n        }\n\n        \n        out.append(quoteChar);\n\n        \n        \n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                \n\n                \n                out.append(value, start, pos + 1);\n                \n                \n                start = pos;\n            }\n            pos++;\n        }\n\n        \n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    \n    public void printComment(final String comment) throws IOException {\n        if (!format.isCommentMarkerSet()) {\n            return;\n        }\n        if (!newRecord) {\n            println();\n        }\n        out.append(format.getCommentMarker().charValue());\n        out.append(SP);\n        for (int i = 0; i < comment.length(); i++) {\n            final char c = comment.charAt(i);\n            switch (c) {\n            case CR:\n                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {\n                    i++;\n                }\n                \n            case LF:\n                println();\n                out.append(format.getCommentMarker().charValue());\n                out.append(SP);\n                break;\n            default:\n                out.append(c);\n                break;\n            }\n        }\n        println();\n    }\n\n    \n    public void println() throws IOException {\n        final String recordSeparator = format.getRecordSeparator();\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n        newRecord = true;\n    }\n\n    \n    public void printRecord(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n            print(value);\n        }\n        println();\n    }\n\n    \n    public void printRecord(final Object... values) throws IOException {\n        for (final Object value : values) {\n            print(value);\n        }\n        println();\n    }\n\n    \n    public void printRecords(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n            if (value instanceof Object[]) {\n                this.printRecord((Object[]) value);\n            } else if (value instanceof Iterable) {\n                this.printRecord((Iterable<?>) value);\n            } else {\n                this.printRecord(value);\n            }\n        }\n    }\n\n    \n    public void printRecords(final Object... values) throws IOException {\n        for (final Object value : values) {\n            if (value instanceof Object[]) {\n                this.printRecord((Object[]) value);\n            } else if (value instanceof Iterable) {\n                this.printRecord((Iterable<?>) value);\n            } else {\n                this.printRecord(value);\n            }\n        }\n    }\n\n    \n    public void printRecords(final ResultSet resultSet) throws SQLException, IOException {\n        final int columnCount = resultSet.getMetaData().getColumnCount();\n        while (resultSet.next()) {\n            for (int i = 1; i <= columnCount; i++) {\n                print(resultSet.getObject(i));\n            }\n            println();\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public void close() throws IOException",
        "public void flush() throws IOException",
        "public Appendable getOut()",
        "public void print(final Object value) throws IOException",
        "private void print(final Object object, final CharSequence value, final int offset, final int len) throws IOException",
        "private void printAndEscape(final CharSequence value, final int offset, final int len) throws IOException",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len) throws IOException",
        "public void printComment(final String comment) throws IOException",
        "public void println() throws IOException",
        "public void printRecord(final Iterable<?> values) throws IOException",
        "public void printRecord(final Object... values) throws IOException",
        "public void printRecords(final Iterable<?> values) throws IOException",
        "public void printRecords(final Object... values) throws IOException",
        "public void printRecords(final ResultSet resultSet) throws SQLException, IOException"
      ],
      "fixed_signatures": [
        "public void close() throws IOException",
        "public void flush() throws IOException",
        "public Appendable getOut()",
        "public void print(final Object value) throws IOException",
        "private void print(final Object object, final CharSequence value, final int offset, final int len) throws IOException",
        "private void printAndEscape(final CharSequence value, final int offset, final int len) throws IOException",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len) throws IOException",
        "public void printComment(final String comment) throws IOException",
        "public void println() throws IOException",
        "public void printRecord(final Iterable<?> values) throws IOException",
        "public void printRecord(final Object... values) throws IOException",
        "public void printRecords(final Iterable<?> values) throws IOException",
        "public void printRecords(final Object... values) throws IOException",
        "public void printRecords(final ResultSet resultSet) throws SQLException, IOException"
      ],
      "methods": [
        {
          "buggy_method": "  private void print(final Object object, final CharSequence value, final int offset, final int len) throws IOException {\n  if (!newRecord) {\n  out.append(format.getDelimiter());\n  }\n  if (format.isQuoteCharacterSet()) {\n  \n  printAndQuote(object, value, offset, len);\n  } else if (format.isEscapeCharacterSet()) {\n  printAndEscape(value, offset, len);\n  } else {\n  out.append(value, offset, offset + len);\n  }\n  newRecord = false;\n  }",
          "fixed_method": "  private void print(final Object object, final CharSequence value, final int offset, final int len) throws IOException {\n  if (!newRecord) {\n  out.append(format.getDelimiter());\n  }\n  if (object == null) {\n  out.append(value);\n  } else if (format.isQuoteCharacterSet()) {\n  \n  printAndQuote(object, value, offset, len);\n  } else if (format.isEscapeCharacterSet()) {\n  printAndEscape(value, offset, len);\n  } else {\n  out.append(value, offset, offset + len);\n  }\n  newRecord = false;\n  }",
          "diff": [
            "@@ -136,7 +136,9 @@",
            "         if (!newRecord) {\n",
            "             out.append(format.getDelimiter());\n",
            "         }\n",
            "-        if (format.isQuoteCharacterSet()) {\n",
            "+        if (object == null) {\n",
            "+            out.append(value);\n",
            "+        } else if (format.isQuoteCharacterSet()) {\n",
            "             // the original object is needed so can check for Number\n",
            "             printAndQuote(object, value, offset, len);\n",
            "         } else if (format.isEscapeCharacterSet()) {\n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
