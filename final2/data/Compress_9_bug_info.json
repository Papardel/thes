{
  "bug_id": "9",
  "failed_tests": {
    "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest": [
      {
        "methodName": "testCount",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<10240> but was:<76>",
        "fail_line": "        assertEquals(f.length(), tarOut.getBytesWritten());",
        "test_source": "  public void testCount() throws Exception {\n  File f = File.createTempFile(\"commons-compress-tarcount\", \".tar\");\n  f.deleteOnExit();\n  FileOutputStream fos = new FileOutputStream(f);\n\n  ArchiveOutputStream tarOut = new ArchiveStreamFactory()\n  .createArchiveOutputStream(ArchiveStreamFactory.TAR, fos);\n\n  File file1 = getFile(\"test1.xml\");\n  TarArchiveEntry sEntry = new TarArchiveEntry(file1);\n  tarOut.putArchiveEntry(sEntry);\n\n  FileInputStream in = new FileInputStream(file1);\n  byte[] buf = new byte[8192];\n\n  int read = 0;\n  while ((read = in.read(buf)) > 0) {\n  tarOut.write(buf, 0, read);\n  }\n\n  in.close();\n  tarOut.closeArchiveEntry();\n  tarOut.close();\n\n  assertEquals(f.length(), tarOut.getBytesWritten());\n  }",
        "stack": [
          "TarArchiveOutputStreamTest.testCount line 55"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.tar;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveOutputStream;\nimport org.apache.commons.compress.utils.ArchiveUtils;\nimport org.apache.commons.compress.utils.CountingOutputStream;\n\n\npublic class TarArchiveOutputStream extends ArchiveOutputStream { public static final int LONGFILE_ERROR = 0; public static final int LONGFILE_TRUNCATE = 1; public static final int LONGFILE_GNU = 2; private long currSize; private String currName; private long currBytes; private final byte[] recordBuf; private int assemLen; private final byte[] assemBuf; protected final TarBuffer buffer; private int longFileMode = LONGFILE_ERROR; private boolean closed = false; private boolean haveUnclosedEntry = false; private boolean finished = false; private final OutputStream out; public TarArchiveOutputStream(OutputStream os) {\n        this(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize) {\n        this(os, blockSize, TarBuffer.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) {\n        out = new CountingOutputStream(os);\n\n        this.buffer = new TarBuffer(out, blockSize, recordSize);\n        this.assemLen = 0;\n        this.assemBuf = new byte[recordSize];\n        this.recordBuf = new byte[recordSize];\n    }\n\n    \n    public void setLongFileMode(int longFileMode) {\n        this.longFileMode = longFileMode;\n    }\n\n\n\n\n    \n    @Override\n    public void finish() throws IOException {\n        if (finished) {\n            throw new IOException(\"This archive has already been finished\");\n        }\n        \n        if(haveUnclosedEntry) {\n            throw new IOException(\"This archives contains unclosed entries.\");\n        }\n        writeEOFRecord();\n        writeEOFRecord();\n        buffer.flushBlock();\n        finished = true;\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        if(!finished) {\n            finish();\n        }\n        \n        if (!closed) {\n            buffer.close();\n            out.close();\n            closed = true;\n        }\n    }\n\n    \n    public int getRecordSize() {\n        return buffer.getRecordSize();\n    }\n\n    \n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_GNU) {\n                \n                \n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                final byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName());\n                longLinkEntry.setSize(nameBytes.length + 1); \n                putArchiveEntry(longLinkEntry);\n                write(nameBytes);\n                write(0); \n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entry.getName()\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        entry.writeEntryHeader(recordBuf);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entry.getName();\n        haveUnclosedEntry = true;\n    }\n\n    \n    @Override\n    public void closeArchiveEntry() throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        if (!haveUnclosedEntry){\n            throw new IOException(\"No current entry to close\");\n        }\n        if (assemLen > 0) {\n            for (int i = assemLen; i < assemBuf.length; ++i) {\n                assemBuf[i] = 0;\n            }\n\n            buffer.writeRecord(assemBuf);\n\n            currBytes += assemLen;\n            assemLen = 0;\n        }\n\n        if (currBytes < currSize) {\n            throw new IOException(\"entry '\" + currName + \"' closed at '\"\n                                  + currBytes\n                                  + \"' before the '\" + currSize\n                                  + \"' bytes specified in the header were written\");\n        }\n        haveUnclosedEntry = false;\n    }\n\n    \n    @Override\n    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n        if ((currBytes + numToWrite) > currSize) {\n            throw new IOException(\"request to write '\" + numToWrite\n                                  + \"' bytes exceeds size in header of '\"\n                                  + currSize + \"' bytes for entry '\"\n                                  + currName + \"'\");\n\n            \n            \n            \n            \n            \n            \n            \n        }\n\n        if (assemLen > 0) {\n            if ((assemLen + numToWrite) >= recordBuf.length) {\n                int aLen = recordBuf.length - assemLen;\n\n                System.arraycopy(assemBuf, 0, recordBuf, 0,\n                                 assemLen);\n                System.arraycopy(wBuf, wOffset, recordBuf,\n                                 assemLen, aLen);\n                buffer.writeRecord(recordBuf);\n\n                currBytes += recordBuf.length;\n                wOffset += aLen;\n                numToWrite -= aLen;\n                assemLen = 0;\n            } else {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                wOffset += numToWrite;\n                assemLen += numToWrite;\n                numToWrite = 0;\n            }\n        }\n\n        \n        \n        \n        \n        \n        while (numToWrite > 0) {\n            if (numToWrite < recordBuf.length) {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                assemLen += numToWrite;\n\n                break;\n            }\n\n            buffer.writeRecord(wBuf, wOffset);\n\n            int num = recordBuf.length;\n\n            currBytes += num;\n            numToWrite -= num;\n            wOffset += num;\n        }\n        count(numToWrite);\n    }\n\n    \n    private void writeEOFRecord() throws IOException {\n        for (int i = 0; i < recordBuf.length; ++i) {\n            recordBuf[i] = 0;\n        }\n\n        buffer.writeRecord(recordBuf);\n    }\n\n    @Override\n    public void flush() throws IOException {\n        out.flush();\n    }\n\n    \n    @Override\n    public ArchiveEntry createArchiveEntry(File inputFile, String entryName) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        return new TarArchiveEntry(inputFile, entryName);\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.tar;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveOutputStream;\nimport org.apache.commons.compress.utils.ArchiveUtils;\nimport org.apache.commons.compress.utils.CountingOutputStream;\n\n\npublic class TarArchiveOutputStream extends ArchiveOutputStream { public static final int LONGFILE_ERROR = 0; public static final int LONGFILE_TRUNCATE = 1; public static final int LONGFILE_GNU = 2; private long currSize; private String currName; private long currBytes; private final byte[] recordBuf; private int assemLen; private final byte[] assemBuf; protected final TarBuffer buffer; private int longFileMode = LONGFILE_ERROR; private boolean closed = false; private boolean haveUnclosedEntry = false; private boolean finished = false; private final OutputStream out; public TarArchiveOutputStream(OutputStream os) {\n        this(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize) {\n        this(os, blockSize, TarBuffer.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) {\n        out = new CountingOutputStream(os);\n\n        this.buffer = new TarBuffer(out, blockSize, recordSize);\n        this.assemLen = 0;\n        this.assemBuf = new byte[recordSize];\n        this.recordBuf = new byte[recordSize];\n    }\n\n    \n    public void setLongFileMode(int longFileMode) {\n        this.longFileMode = longFileMode;\n    }\n\n\n    @Deprecated\n    @Override\n    public int getCount() {\n        return (int) getBytesWritten();\n    }\n\n    @Override\n    public long getBytesWritten() {\n        return ((CountingOutputStream) out).getBytesWritten();\n    }\n\n    \n    @Override\n    public void finish() throws IOException {\n        if (finished) {\n            throw new IOException(\"This archive has already been finished\");\n        }\n        \n        if(haveUnclosedEntry) {\n            throw new IOException(\"This archives contains unclosed entries.\");\n        }\n        writeEOFRecord();\n        writeEOFRecord();\n        buffer.flushBlock();\n        finished = true;\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        if(!finished) {\n            finish();\n        }\n        \n        if (!closed) {\n            buffer.close();\n            out.close();\n            closed = true;\n        }\n    }\n\n    \n    public int getRecordSize() {\n        return buffer.getRecordSize();\n    }\n\n    \n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_GNU) {\n                \n                \n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                final byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName());\n                longLinkEntry.setSize(nameBytes.length + 1); \n                putArchiveEntry(longLinkEntry);\n                write(nameBytes);\n                write(0); \n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entry.getName()\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        entry.writeEntryHeader(recordBuf);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entry.getName();\n        haveUnclosedEntry = true;\n    }\n\n    \n    @Override\n    public void closeArchiveEntry() throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        if (!haveUnclosedEntry){\n            throw new IOException(\"No current entry to close\");\n        }\n        if (assemLen > 0) {\n            for (int i = assemLen; i < assemBuf.length; ++i) {\n                assemBuf[i] = 0;\n            }\n\n            buffer.writeRecord(assemBuf);\n\n            currBytes += assemLen;\n            assemLen = 0;\n        }\n\n        if (currBytes < currSize) {\n            throw new IOException(\"entry '\" + currName + \"' closed at '\"\n                                  + currBytes\n                                  + \"' before the '\" + currSize\n                                  + \"' bytes specified in the header were written\");\n        }\n        haveUnclosedEntry = false;\n    }\n\n    \n    @Override\n    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n        if ((currBytes + numToWrite) > currSize) {\n            throw new IOException(\"request to write '\" + numToWrite\n                                  + \"' bytes exceeds size in header of '\"\n                                  + currSize + \"' bytes for entry '\"\n                                  + currName + \"'\");\n\n            \n            \n            \n            \n            \n            \n            \n        }\n\n        if (assemLen > 0) {\n            if ((assemLen + numToWrite) >= recordBuf.length) {\n                int aLen = recordBuf.length - assemLen;\n\n                System.arraycopy(assemBuf, 0, recordBuf, 0,\n                                 assemLen);\n                System.arraycopy(wBuf, wOffset, recordBuf,\n                                 assemLen, aLen);\n                buffer.writeRecord(recordBuf);\n\n                currBytes += recordBuf.length;\n                wOffset += aLen;\n                numToWrite -= aLen;\n                assemLen = 0;\n            } else {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                wOffset += numToWrite;\n                assemLen += numToWrite;\n                numToWrite = 0;\n            }\n        }\n\n        \n        \n        \n        \n        \n        while (numToWrite > 0) {\n            if (numToWrite < recordBuf.length) {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                assemLen += numToWrite;\n\n                break;\n            }\n\n            buffer.writeRecord(wBuf, wOffset);\n\n            int num = recordBuf.length;\n\n            currBytes += num;\n            numToWrite -= num;\n            wOffset += num;\n        }\n    }\n\n    \n    private void writeEOFRecord() throws IOException {\n        for (int i = 0; i < recordBuf.length; ++i) {\n            recordBuf[i] = 0;\n        }\n\n        buffer.writeRecord(recordBuf);\n    }\n\n    @Override\n    public void flush() throws IOException {\n        out.flush();\n    }\n\n    \n    @Override\n    public ArchiveEntry createArchiveEntry(File inputFile, String entryName) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        return new TarArchiveEntry(inputFile, entryName);\n    }\n}\n",
      "buggy_signatures": [
        "public TarArchiveOutputStream(OutputStream os, int blockSize)",
        "public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize)",
        "public void setLongFileMode(int longFileMode)",
        "public void finish() throws IOException",
        "public void close() throws IOException",
        "public int getRecordSize()",
        "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException",
        "public void closeArchiveEntry() throws IOException",
        "public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException",
        "private void writeEOFRecord() throws IOException",
        "public void flush() throws IOException",
        "public ArchiveEntry createArchiveEntry(File inputFile, String entryName) throws IOException"
      ],
      "fixed_signatures": [
        "public TarArchiveOutputStream(OutputStream os, int blockSize)",
        "public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize)",
        "public void setLongFileMode(int longFileMode)",
        "public int getCount()",
        "public long getBytesWritten()",
        "public void finish() throws IOException",
        "public void close() throws IOException",
        "public int getRecordSize()",
        "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException",
        "public void closeArchiveEntry() throws IOException",
        "public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException",
        "private void writeEOFRecord() throws IOException",
        "public void flush() throws IOException",
        "public ArchiveEntry createArchiveEntry(File inputFile, String entryName) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  public void setLongFileMode(int longFileMode) {\n  this.longFileMode = longFileMode;\n  }",
          "fixed_method": "  public int getCount() {\n  return (int) getBytesWritten();\n  }",
          "diff": [
            "@@ -105,7 +105,16 @@",
            "     }\n",
            " \n",
            " \n",
            "-\n",
            "+    @Deprecated\n",
            "+    @Override\n",
            "+    public int getCount() {\n",
            "+        return (int) getBytesWritten();\n",
            "+    }\n",
            "+\n",
            "+    @Override\n",
            "+    public long getBytesWritten() {\n",
            "+        return ((CountingOutputStream) out).getBytesWritten();\n",
            "+    }\n",
            " \n",
            "     /**\n",
            "      * Ends the TAR archive without closing the underlying OutputStream.\n"
          ],
          "changed_lines": 11
        },
        {
          "buggy_method": "  public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n  if ((currBytes + numToWrite) > currSize) {\n  throw new IOException(\"request to write '\" + numToWrite\n  + \"' bytes exceeds size in header of '\"\n  + currSize + \"' bytes for entry '\"\n  + currName + \"'\");\n\n  \n  \n  \n  \n  \n  \n  \n  }\n\n  if (assemLen > 0) {\n  if ((assemLen + numToWrite) >= recordBuf.length) {\n  int aLen = recordBuf.length - assemLen;\n\n  System.arraycopy(assemBuf, 0, recordBuf, 0,\n  assemLen);\n  System.arraycopy(wBuf, wOffset, recordBuf,\n  assemLen, aLen);\n  buffer.writeRecord(recordBuf);\n\n  currBytes += recordBuf.length;\n  wOffset += aLen;\n  numToWrite -= aLen;\n  assemLen = 0;\n  } else {\n  System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n  numToWrite);\n\n  wOffset += numToWrite;\n  assemLen += numToWrite;\n  numToWrite = 0;\n  }\n  }\n\n  \n  \n  \n  \n  \n  while (numToWrite > 0) {\n  if (numToWrite < recordBuf.length) {\n  System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n  numToWrite);\n\n  assemLen += numToWrite;\n\n  break;\n  }\n\n  buffer.writeRecord(wBuf, wOffset);\n\n  int num = recordBuf.length;\n\n  currBytes += num;\n  numToWrite -= num;\n  wOffset += num;\n  }\n  count(numToWrite);\n  }",
          "fixed_method": "  public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n  if ((currBytes + numToWrite) > currSize) {\n  throw new IOException(\"request to write '\" + numToWrite\n  + \"' bytes exceeds size in header of '\"\n  + currSize + \"' bytes for entry '\"\n  + currName + \"'\");\n\n  \n  \n  \n  \n  \n  \n  \n  }\n\n  if (assemLen > 0) {\n  if ((assemLen + numToWrite) >= recordBuf.length) {\n  int aLen = recordBuf.length - assemLen;\n\n  System.arraycopy(assemBuf, 0, recordBuf, 0,\n  assemLen);\n  System.arraycopy(wBuf, wOffset, recordBuf,\n  assemLen, aLen);\n  buffer.writeRecord(recordBuf);\n\n  currBytes += recordBuf.length;\n  wOffset += aLen;\n  numToWrite -= aLen;\n  assemLen = 0;\n  } else {\n  System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n  numToWrite);\n\n  wOffset += numToWrite;\n  assemLen += numToWrite;\n  numToWrite = 0;\n  }\n  }\n\n  \n  \n  \n  \n  \n  while (numToWrite > 0) {\n  if (numToWrite < recordBuf.length) {\n  System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n  numToWrite);\n\n  assemLen += numToWrite;\n\n  break;\n  }\n\n  buffer.writeRecord(wBuf, wOffset);\n\n  int num = recordBuf.length;\n\n  currBytes += num;\n  numToWrite -= num;\n  wOffset += num;\n  }\n  }",
          "diff": [
            "@@ -327,7 +336,6 @@",
            "             numToWrite -= num;\n",
            "             wOffset += num;\n",
            "         }\n",
            "-        count(numToWrite);\n",
            "     }\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 1
        }
      ]
    }
  ]
}
