{
  "bug_id": "101",
  "failed_tests": {
    "org.apache.commons.math.complex.ComplexFormatTest": [
      {
        "methodName": "testForgottenImaginaryCharacter",
        "error": "java.lang.StringIndexOutOfBoundsException",
        "message": "begin 5, end 6, length 5",
        "fail_line": "",
        "test_source": "",
        "stack": [
          "ComplexFormat.parse line 378, ComplexFormatAbstractTest.testForgottenImaginaryCharacter line 355"
        ]
      }
    ],
    "org.apache.commons.math.complex.FrenchComplexFormatTest": [
      {
        "methodName": "testForgottenImaginaryCharacter",
        "error": "java.lang.StringIndexOutOfBoundsException",
        "message": "begin 5, end 6, length 5",
        "fail_line": "",
        "test_source": "",
        "stack": [
          "ComplexFormat.parse line 378, ComplexFormatAbstractTest.testForgottenImaginaryCharacter line 355"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/complex/ComplexFormat.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.complex;\n\nimport java.io.Serializable;\nimport java.text.FieldPosition;\nimport java.text.Format;\nimport java.text.NumberFormat;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.util.Locale;\n\n\npublic class ComplexFormat extends Format implements Serializable { private static final long serialVersionUID = -6337346779577272306L; private static final String DEFAULT_IMAGINARY_CHARACTER = \"i\"; private String imaginaryCharacter; private NumberFormat imaginaryFormat; private NumberFormat realFormat; public ComplexFormat() {\n        this(DEFAULT_IMAGINARY_CHARACTER, getDefaultNumberFormat());\n    }\n\n    \n    public ComplexFormat(NumberFormat format) {\n        this(DEFAULT_IMAGINARY_CHARACTER, format);\n    }\n    \n    \n    public ComplexFormat(NumberFormat realFormat, NumberFormat imaginaryFormat) {\n        this(DEFAULT_IMAGINARY_CHARACTER, realFormat, imaginaryFormat);\n    }\n    \n    \n    public ComplexFormat(String imaginaryCharacter) {\n        this(imaginaryCharacter, getDefaultNumberFormat());\n    }\n    \n    \n    public ComplexFormat(String imaginaryCharacter, NumberFormat format) {\n        this(imaginaryCharacter, format, (NumberFormat)format.clone());\n    }\n    \n    \n    public ComplexFormat(String imaginaryCharacter, NumberFormat realFormat, NumberFormat imaginaryFormat) {\n        super();\n        setImaginaryCharacter(imaginaryCharacter);\n        setImaginaryFormat(imaginaryFormat);\n        setRealFormat(realFormat);\n    }\n\n    \n    public static String formatComplex( Complex c ) {\n        return getInstance().format( c );\n    }\n    \n    \n    public StringBuffer format(Complex complex, StringBuffer toAppendTo, FieldPosition pos) {\n        \n        pos.setBeginIndex(0);\n        pos.setEndIndex(0);\n\n        \n        double re = complex.getReal();\n        formatDouble(re, getRealFormat(), toAppendTo, pos);\n        \n        \n        double im = complex.getImaginary();\n        if (im < 0.0) {\n            toAppendTo.append(\" - \");\n            formatDouble(-im, getImaginaryFormat(), toAppendTo, pos);\n            toAppendTo.append(getImaginaryCharacter());\n        } else if (im > 0.0 || Double.isNaN(im)) {\n            toAppendTo.append(\" + \");\n            formatDouble(im, getImaginaryFormat(), toAppendTo, pos);\n            toAppendTo.append(getImaginaryCharacter());\n        }\n        \n        return toAppendTo;\n    }\n    \n    \n    public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n        \n        StringBuffer ret = null;\n        \n        if (obj instanceof Complex) {\n            ret = format( (Complex)obj, toAppendTo, pos);\n        } else if (obj instanceof Number) {\n            ret = format( new Complex(((Number)obj).doubleValue(), 0.0),\n                toAppendTo, pos);\n        } else { \n            throw new IllegalArgumentException(\n                \"Cannot format given Object as a Date\");\n        }\n        \n        return ret;\n    }\n\n    \n    private StringBuffer formatDouble(double value, NumberFormat format, StringBuffer toAppendTo, FieldPosition pos) {\n        if( Double.isNaN(value) || Double.isInfinite(value) ) {\n            toAppendTo.append('(');\n            toAppendTo.append(value);\n            toAppendTo.append(')');\n        } else {\n            format.format(value, toAppendTo, pos);\n        }\n        return toAppendTo;\n    }\n    \n    \n    public static Locale[] getAvailableLocales() {\n        return NumberFormat.getAvailableLocales();\n    }\n    \n    \n    private static NumberFormat getDefaultNumberFormat() {\n        return getDefaultNumberFormat(Locale.getDefault());\n    }\n    \n    \n    private static NumberFormat getDefaultNumberFormat(Locale locale) {\n        NumberFormat nf = NumberFormat.getInstance(locale);\n        nf.setMaximumFractionDigits(2);\n        return nf;\n    }\n    \n    \n    public String getImaginaryCharacter() {\n        return imaginaryCharacter;\n    }\n    \n    \n    public NumberFormat getImaginaryFormat() {\n        return imaginaryFormat;\n    }\n    \n    \n    public static ComplexFormat getInstance() {\n        return getInstance(Locale.getDefault());\n    }\n    \n    \n    public static ComplexFormat getInstance(Locale locale) {\n        NumberFormat f = getDefaultNumberFormat(locale);\n        return new ComplexFormat(f);\n    }\n    \n    \n    public NumberFormat getRealFormat() {\n        return realFormat;\n    }\n\n    \n    public Complex parse(String source) throws ParseException {\n        ParsePosition parsePosition = new ParsePosition(0);\n        Complex result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new ParseException(\"Unparseable complex number: \\\"\" + source +\n                \"\\\"\", parsePosition.getErrorIndex());\n        }\n        return result;\n    }\n    \n    \n    public Complex parse(String source, ParsePosition pos) {\n        int initialIndex = pos.getIndex();\n\n        \n        parseAndIgnoreWhitespace(source, pos);\n\n        \n        Number re = parseNumber(source, getRealFormat(), pos);\n        if (re == null) {\n            \n            \n            \n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        \n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        int sign = 0;\n        switch (c) {\n        case 0 :\n            \n            \n            return new Complex(re.doubleValue(), 0.0);\n        case '-' :\n            sign = -1;\n            break;\n        case '+' :\n            sign = 1;\n            break;\n        default :\n            \n            \n            \n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n\n        \n        parseAndIgnoreWhitespace(source, pos);\n\n        \n        Number im = parseNumber(source, getRealFormat(), pos);\n        if (im == null) {\n            \n            \n            \n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        \n        int n = getImaginaryCharacter().length();\n        startIndex = pos.getIndex();\n        int endIndex = startIndex + n;\n        if (\n            source.substring(startIndex, endIndex).compareTo(\n            getImaginaryCharacter()) != 0) {\n            \n            \n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        pos.setIndex(endIndex);\n\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    }\n     \n    \n    private void parseAndIgnoreWhitespace(String source, ParsePosition pos) {\n        parseNextCharacter(source, pos);\n        pos.setIndex(pos.getIndex() - 1);\n    }\n\n    \n    private char parseNextCharacter(String source, ParsePosition pos) {\n         int index = pos.getIndex();\n         int n = source.length();\n         char ret = 0;\n\n         if (index < n) {\n             char c;\n             do {\n                 c = source.charAt(index++);\n             } while (Character.isWhitespace(c) && index < n);\n             pos.setIndex(index);\n         \n             if (index < n) {\n                 ret = c;\n             }\n         }\n         \n         return ret;\n    }\n    \n    \n    private Number parseNumber(String source, double value, ParsePosition pos) {\n        Number ret = null;\n        \n        StringBuffer sb = new StringBuffer();\n        sb.append('(');\n        sb.append(value);\n        sb.append(')');\n        \n        int n = sb.length();\n        int startIndex = pos.getIndex();\n        int endIndex = startIndex + n;\n        if (endIndex < source.length()) {\n            if (source.substring(startIndex, endIndex).compareTo(sb.toString()) == 0) {\n                ret = new Double(value);\n                pos.setIndex(endIndex);\n            }\n        }\n        \n        return ret;\n    }\n    \n    \n    private Number parseNumber(String source, NumberFormat format, ParsePosition pos) {\n        int startIndex = pos.getIndex();\n        Number number = format.parse(source, pos);\n        int endIndex = pos.getIndex();\n        \n        \n        if (startIndex == endIndex) {\n            \n            double[] special = {Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY};\n            for (int i = 0; i < special.length; ++i) {\n                number = parseNumber(source, special[i], pos);\n                if (number != null) {\n                    break;\n                }\n            }\n        }\n        \n        return number;\n    }\n\n    \n    public Object parseObject(String source, ParsePosition pos) {\n        return parse(source, pos);\n    }\n    \n    public void setImaginaryCharacter(String imaginaryCharacter) {\n        if (imaginaryCharacter == null || imaginaryCharacter.length() == 0) {\n            throw new IllegalArgumentException(\n                \"imaginaryCharacter must be a non-empty string.\");\n        }\n        this.imaginaryCharacter = imaginaryCharacter;\n    }\n    \n    \n    public void setImaginaryFormat(NumberFormat imaginaryFormat) {\n        if (imaginaryFormat == null) {\n            throw new IllegalArgumentException(\n                \"imaginaryFormat can not be null.\");\n        }\n        this.imaginaryFormat = imaginaryFormat;\n    }\n    \n    \n    public void setRealFormat(NumberFormat realFormat) {\n        if (realFormat == null) {\n            throw new IllegalArgumentException(\n                \"realFormat can not be null.\");\n        }\n        this.realFormat = realFormat;\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.complex;\n\nimport java.io.Serializable;\nimport java.text.FieldPosition;\nimport java.text.Format;\nimport java.text.NumberFormat;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.util.Locale;\n\n\npublic class ComplexFormat extends Format implements Serializable { private static final long serialVersionUID = -6337346779577272306L; private static final String DEFAULT_IMAGINARY_CHARACTER = \"i\"; private String imaginaryCharacter; private NumberFormat imaginaryFormat; private NumberFormat realFormat; public ComplexFormat() {\n        this(DEFAULT_IMAGINARY_CHARACTER, getDefaultNumberFormat());\n    }\n\n    \n    public ComplexFormat(NumberFormat format) {\n        this(DEFAULT_IMAGINARY_CHARACTER, format);\n    }\n    \n    \n    public ComplexFormat(NumberFormat realFormat, NumberFormat imaginaryFormat) {\n        this(DEFAULT_IMAGINARY_CHARACTER, realFormat, imaginaryFormat);\n    }\n    \n    \n    public ComplexFormat(String imaginaryCharacter) {\n        this(imaginaryCharacter, getDefaultNumberFormat());\n    }\n    \n    \n    public ComplexFormat(String imaginaryCharacter, NumberFormat format) {\n        this(imaginaryCharacter, format, (NumberFormat)format.clone());\n    }\n    \n    \n    public ComplexFormat(String imaginaryCharacter, NumberFormat realFormat, NumberFormat imaginaryFormat) {\n        super();\n        setImaginaryCharacter(imaginaryCharacter);\n        setImaginaryFormat(imaginaryFormat);\n        setRealFormat(realFormat);\n    }\n\n    \n    public static String formatComplex( Complex c ) {\n        return getInstance().format( c );\n    }\n    \n    \n    public StringBuffer format(Complex complex, StringBuffer toAppendTo, FieldPosition pos) {\n        \n        pos.setBeginIndex(0);\n        pos.setEndIndex(0);\n\n        \n        double re = complex.getReal();\n        formatDouble(re, getRealFormat(), toAppendTo, pos);\n        \n        \n        double im = complex.getImaginary();\n        if (im < 0.0) {\n            toAppendTo.append(\" - \");\n            formatDouble(-im, getImaginaryFormat(), toAppendTo, pos);\n            toAppendTo.append(getImaginaryCharacter());\n        } else if (im > 0.0 || Double.isNaN(im)) {\n            toAppendTo.append(\" + \");\n            formatDouble(im, getImaginaryFormat(), toAppendTo, pos);\n            toAppendTo.append(getImaginaryCharacter());\n        }\n        \n        return toAppendTo;\n    }\n    \n    \n    public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n        \n        StringBuffer ret = null;\n        \n        if (obj instanceof Complex) {\n            ret = format( (Complex)obj, toAppendTo, pos);\n        } else if (obj instanceof Number) {\n            ret = format( new Complex(((Number)obj).doubleValue(), 0.0),\n                toAppendTo, pos);\n        } else { \n            throw new IllegalArgumentException(\n                \"Cannot format given Object as a Date\");\n        }\n        \n        return ret;\n    }\n\n    \n    private StringBuffer formatDouble(double value, NumberFormat format, StringBuffer toAppendTo, FieldPosition pos) {\n        if( Double.isNaN(value) || Double.isInfinite(value) ) {\n            toAppendTo.append('(');\n            toAppendTo.append(value);\n            toAppendTo.append(')');\n        } else {\n            format.format(value, toAppendTo, pos);\n        }\n        return toAppendTo;\n    }\n    \n    \n    public static Locale[] getAvailableLocales() {\n        return NumberFormat.getAvailableLocales();\n    }\n    \n    \n    private static NumberFormat getDefaultNumberFormat() {\n        return getDefaultNumberFormat(Locale.getDefault());\n    }\n    \n    \n    private static NumberFormat getDefaultNumberFormat(Locale locale) {\n        NumberFormat nf = NumberFormat.getInstance(locale);\n        nf.setMaximumFractionDigits(2);\n        return nf;\n    }\n    \n    \n    public String getImaginaryCharacter() {\n        return imaginaryCharacter;\n    }\n    \n    \n    public NumberFormat getImaginaryFormat() {\n        return imaginaryFormat;\n    }\n    \n    \n    public static ComplexFormat getInstance() {\n        return getInstance(Locale.getDefault());\n    }\n    \n    \n    public static ComplexFormat getInstance(Locale locale) {\n        NumberFormat f = getDefaultNumberFormat(locale);\n        return new ComplexFormat(f);\n    }\n    \n    \n    public NumberFormat getRealFormat() {\n        return realFormat;\n    }\n\n    \n    public Complex parse(String source) throws ParseException {\n        ParsePosition parsePosition = new ParsePosition(0);\n        Complex result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new ParseException(\"Unparseable complex number: \\\"\" + source +\n                \"\\\"\", parsePosition.getErrorIndex());\n        }\n        return result;\n    }\n    \n    \n    public Complex parse(String source, ParsePosition pos) {\n        int initialIndex = pos.getIndex();\n\n        \n        parseAndIgnoreWhitespace(source, pos);\n\n        \n        Number re = parseNumber(source, getRealFormat(), pos);\n        if (re == null) {\n            \n            \n            \n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        \n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        int sign = 0;\n        switch (c) {\n        case 0 :\n            \n            \n            return new Complex(re.doubleValue(), 0.0);\n        case '-' :\n            sign = -1;\n            break;\n        case '+' :\n            sign = 1;\n            break;\n        default :\n            \n            \n            \n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n\n        \n        parseAndIgnoreWhitespace(source, pos);\n\n        \n        Number im = parseNumber(source, getRealFormat(), pos);\n        if (im == null) {\n            \n            \n            \n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        \n        int n = getImaginaryCharacter().length();\n        startIndex = pos.getIndex();\n        int endIndex = startIndex + n;\n        if ((startIndex >= source.length()) ||\n            (endIndex > source.length()) ||\n            source.substring(startIndex, endIndex).compareTo(\n            getImaginaryCharacter()) != 0) {\n            \n            \n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        pos.setIndex(endIndex);\n\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    }\n     \n    \n    private void parseAndIgnoreWhitespace(String source, ParsePosition pos) {\n        parseNextCharacter(source, pos);\n        pos.setIndex(pos.getIndex() - 1);\n    }\n\n    \n    private char parseNextCharacter(String source, ParsePosition pos) {\n         int index = pos.getIndex();\n         int n = source.length();\n         char ret = 0;\n\n         if (index < n) {\n             char c;\n             do {\n                 c = source.charAt(index++);\n             } while (Character.isWhitespace(c) && index < n);\n             pos.setIndex(index);\n         \n             if (index < n) {\n                 ret = c;\n             }\n         }\n         \n         return ret;\n    }\n    \n    \n    private Number parseNumber(String source, double value, ParsePosition pos) {\n        Number ret = null;\n        \n        StringBuffer sb = new StringBuffer();\n        sb.append('(');\n        sb.append(value);\n        sb.append(')');\n        \n        int n = sb.length();\n        int startIndex = pos.getIndex();\n        int endIndex = startIndex + n;\n        if (endIndex < source.length()) {\n            if (source.substring(startIndex, endIndex).compareTo(sb.toString()) == 0) {\n                ret = new Double(value);\n                pos.setIndex(endIndex);\n            }\n        }\n        \n        return ret;\n    }\n    \n    \n    private Number parseNumber(String source, NumberFormat format, ParsePosition pos) {\n        int startIndex = pos.getIndex();\n        Number number = format.parse(source, pos);\n        int endIndex = pos.getIndex();\n        \n        \n        if (startIndex == endIndex) {\n            \n            double[] special = {Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY};\n            for (int i = 0; i < special.length; ++i) {\n                number = parseNumber(source, special[i], pos);\n                if (number != null) {\n                    break;\n                }\n            }\n        }\n        \n        return number;\n    }\n\n    \n    public Object parseObject(String source, ParsePosition pos) {\n        return parse(source, pos);\n    }\n    \n    public void setImaginaryCharacter(String imaginaryCharacter) {\n        if (imaginaryCharacter == null || imaginaryCharacter.length() == 0) {\n            throw new IllegalArgumentException(\n                \"imaginaryCharacter must be a non-empty string.\");\n        }\n        this.imaginaryCharacter = imaginaryCharacter;\n    }\n    \n    \n    public void setImaginaryFormat(NumberFormat imaginaryFormat) {\n        if (imaginaryFormat == null) {\n            throw new IllegalArgumentException(\n                \"imaginaryFormat can not be null.\");\n        }\n        this.imaginaryFormat = imaginaryFormat;\n    }\n    \n    \n    public void setRealFormat(NumberFormat realFormat) {\n        if (realFormat == null) {\n            throw new IllegalArgumentException(\n                \"realFormat can not be null.\");\n        }\n        this.realFormat = realFormat;\n    }\n}\n",
      "buggy_signatures": [
        "public ComplexFormat(NumberFormat format)",
        "public ComplexFormat(NumberFormat realFormat, NumberFormat imaginaryFormat)",
        "public ComplexFormat(String imaginaryCharacter)",
        "public ComplexFormat(String imaginaryCharacter, NumberFormat format)",
        "public ComplexFormat(String imaginaryCharacter, NumberFormat realFormat, NumberFormat imaginaryFormat)",
        "public static String formatComplex( Complex c )",
        "public StringBuffer format(Complex complex, StringBuffer toAppendTo, FieldPosition pos)",
        "public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos)",
        "private StringBuffer formatDouble(double value, NumberFormat format, StringBuffer toAppendTo, FieldPosition pos)",
        "public static Locale[] getAvailableLocales()",
        "private static NumberFormat getDefaultNumberFormat()",
        "private static NumberFormat getDefaultNumberFormat(Locale locale)",
        "public String getImaginaryCharacter()",
        "public NumberFormat getImaginaryFormat()",
        "public static ComplexFormat getInstance()",
        "public static ComplexFormat getInstance(Locale locale)",
        "public NumberFormat getRealFormat()",
        "public Complex parse(String source) throws ParseException",
        "public Complex parse(String source, ParsePosition pos)",
        "private void parseAndIgnoreWhitespace(String source, ParsePosition pos)",
        "private char parseNextCharacter(String source, ParsePosition pos)",
        "private Number parseNumber(String source, double value, ParsePosition pos)",
        "private Number parseNumber(String source, NumberFormat format, ParsePosition pos)",
        "public Object parseObject(String source, ParsePosition pos)",
        "public void setImaginaryCharacter(String imaginaryCharacter)",
        "public void setImaginaryFormat(NumberFormat imaginaryFormat)",
        "public void setRealFormat(NumberFormat realFormat)"
      ],
      "fixed_signatures": [
        "public ComplexFormat(NumberFormat format)",
        "public ComplexFormat(NumberFormat realFormat, NumberFormat imaginaryFormat)",
        "public ComplexFormat(String imaginaryCharacter)",
        "public ComplexFormat(String imaginaryCharacter, NumberFormat format)",
        "public ComplexFormat(String imaginaryCharacter, NumberFormat realFormat, NumberFormat imaginaryFormat)",
        "public static String formatComplex( Complex c )",
        "public StringBuffer format(Complex complex, StringBuffer toAppendTo, FieldPosition pos)",
        "public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos)",
        "private StringBuffer formatDouble(double value, NumberFormat format, StringBuffer toAppendTo, FieldPosition pos)",
        "public static Locale[] getAvailableLocales()",
        "private static NumberFormat getDefaultNumberFormat()",
        "private static NumberFormat getDefaultNumberFormat(Locale locale)",
        "public String getImaginaryCharacter()",
        "public NumberFormat getImaginaryFormat()",
        "public static ComplexFormat getInstance()",
        "public static ComplexFormat getInstance(Locale locale)",
        "public NumberFormat getRealFormat()",
        "public Complex parse(String source) throws ParseException",
        "public Complex parse(String source, ParsePosition pos)",
        "private void parseAndIgnoreWhitespace(String source, ParsePosition pos)",
        "private char parseNextCharacter(String source, ParsePosition pos)",
        "private Number parseNumber(String source, double value, ParsePosition pos)",
        "private Number parseNumber(String source, NumberFormat format, ParsePosition pos)",
        "public Object parseObject(String source, ParsePosition pos)",
        "public void setImaginaryCharacter(String imaginaryCharacter)",
        "public void setImaginaryFormat(NumberFormat imaginaryFormat)",
        "public void setRealFormat(NumberFormat realFormat)"
      ],
      "methods": [
        {
          "buggy_method": "  public Complex parse(String source, ParsePosition pos) {\n  int initialIndex = pos.getIndex();\n\n  \n  parseAndIgnoreWhitespace(source, pos);\n\n  \n  Number re = parseNumber(source, getRealFormat(), pos);\n  if (re == null) {\n  \n  \n  \n  pos.setIndex(initialIndex);\n  return null;\n  }\n\n  \n  int startIndex = pos.getIndex();\n  char c = parseNextCharacter(source, pos);\n  int sign = 0;\n  switch (c) {\n  case 0 :\n  \n  \n  return new Complex(re.doubleValue(), 0.0);\n  case '-' :\n  sign = -1;\n  break;\n  case '+' :\n  sign = 1;\n  break;\n  default :\n  \n  \n  \n  pos.setIndex(initialIndex);\n  pos.setErrorIndex(startIndex);\n  return null;\n  }\n\n  \n  parseAndIgnoreWhitespace(source, pos);\n\n  \n  Number im = parseNumber(source, getRealFormat(), pos);\n  if (im == null) {\n  \n  \n  \n  pos.setIndex(initialIndex);\n  return null;\n  }\n\n  \n  int n = getImaginaryCharacter().length();\n  startIndex = pos.getIndex();\n  int endIndex = startIndex + n;\n  if (\n  source.substring(startIndex, endIndex).compareTo(\n  getImaginaryCharacter()) != 0) {\n  \n  \n  pos.setIndex(initialIndex);\n  pos.setErrorIndex(startIndex);\n  return null;\n  }\n  pos.setIndex(endIndex);\n\n  return new Complex(re.doubleValue(), im.doubleValue() * sign);\n  }",
          "fixed_method": "  public Complex parse(String source, ParsePosition pos) {\n  int initialIndex = pos.getIndex();\n\n  \n  parseAndIgnoreWhitespace(source, pos);\n\n  \n  Number re = parseNumber(source, getRealFormat(), pos);\n  if (re == null) {\n  \n  \n  \n  pos.setIndex(initialIndex);\n  return null;\n  }\n\n  \n  int startIndex = pos.getIndex();\n  char c = parseNextCharacter(source, pos);\n  int sign = 0;\n  switch (c) {\n  case 0 :\n  \n  \n  return new Complex(re.doubleValue(), 0.0);\n  case '-' :\n  sign = -1;\n  break;\n  case '+' :\n  sign = 1;\n  break;\n  default :\n  \n  \n  \n  pos.setIndex(initialIndex);\n  pos.setErrorIndex(startIndex);\n  return null;\n  }\n\n  \n  parseAndIgnoreWhitespace(source, pos);\n\n  \n  Number im = parseNumber(source, getRealFormat(), pos);\n  if (im == null) {\n  \n  \n  \n  pos.setIndex(initialIndex);\n  return null;\n  }\n\n  \n  int n = getImaginaryCharacter().length();\n  startIndex = pos.getIndex();\n  int endIndex = startIndex + n;\n  if ((startIndex >= source.length()) ||\n  (endIndex > source.length()) ||\n  source.substring(startIndex, endIndex).compareTo(\n  getImaginaryCharacter()) != 0) {\n  \n  \n  pos.setIndex(initialIndex);\n  pos.setErrorIndex(startIndex);\n  return null;\n  }\n  pos.setIndex(endIndex);\n\n  return new Complex(re.doubleValue(), im.doubleValue() * sign);\n  }",
          "diff": [
            "@@ -374,7 +374,8 @@",
            "         int n = getImaginaryCharacter().length();\n",
            "         startIndex = pos.getIndex();\n",
            "         int endIndex = startIndex + n;\n",
            "-        if (\n",
            "+        if ((startIndex >= source.length()) ||\n",
            "+            (endIndex > source.length()) ||\n",
            "             source.substring(startIndex, endIndex).compareTo(\n",
            "             getImaginaryCharacter()) != 0) {\n",
            "             // set index back to initial, error index should be the start index\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
