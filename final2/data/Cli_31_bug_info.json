{
  "bug_id": "31",
  "failed_tests": {
    "org.apache.commons.cli.HelpFormatterTest": [
      {
        "methodName": "testDefaultArgName",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<usage: app -f <arg[ument]>",
        "fail_line": "        assertEquals(\"usage: app -f <argument>\" + EOL, out.toString());",
        "test_source": "  public void testDefaultArgName() {\n  Option option = OptionBuilder.hasArg().isRequired().create(\"f\");\n  \n  Options options = new Options();\n  options.addOption(option);\n  \n  StringWriter out = new StringWriter();\n\n  HelpFormatter formatter = new HelpFormatter();\n  formatter.setArgName(\"argument\");\n  formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n  assertEquals(\"usage: app -f <argument>\" + EOL, out.toString());\n  }",
        "stack": [
          "HelpFormatterTest.testDefaultArgName line 321"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/cli/HelpFormatter.java",
      "buggy_full_code": "\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n\npublic class HelpFormatter { public static final int DEFAULT_WIDTH = 74; public static final int DEFAULT_LEFT_PAD = 1; public static final int DEFAULT_DESC_PAD = 3; public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \"; public static final String DEFAULT_OPT_PREFIX = \"-\"; public static final String DEFAULT_LONG_OPT_PREFIX = \"--\"; public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \"; public static final String DEFAULT_ARG_NAME = \"arg\"; public int defaultWidth = DEFAULT_WIDTH; public int defaultLeftPad = DEFAULT_LEFT_PAD; public int defaultDescPad = DEFAULT_DESC_PAD; public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX; public String defaultNewLine = System.getProperty(\"line.separator\"); public String defaultOptPrefix = DEFAULT_OPT_PREFIX; public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX; private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR; public String defaultArgName = DEFAULT_ARG_NAME; protected Comparator optionComparator = new OptionComparator(); public void setWidth(int width) {\n        this.defaultWidth = width;\n    }\n\n    \n    public int getWidth() {\n        return defaultWidth;\n    }\n\n    \n    public void setLeftPadding(int padding) {\n        this.defaultLeftPad = padding;\n    }\n\n    \n    public int getLeftPadding() {\n        return defaultLeftPad;\n    }\n\n    \n    public void setDescPadding(int padding) {\n        this.defaultDescPad = padding;\n    }\n\n    \n    public int getDescPadding() {\n        return defaultDescPad;\n    }\n\n    \n    public void setSyntaxPrefix(String prefix) {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    \n    public String getSyntaxPrefix() {\n        return defaultSyntaxPrefix;\n    }\n\n    \n    public void setNewLine(String newline) {\n        this.defaultNewLine = newline;\n    }\n\n    \n    public String getNewLine() {\n        return defaultNewLine;\n    }\n\n    \n    public void setOptPrefix(String prefix) {\n        this.defaultOptPrefix = prefix;\n    }\n\n    \n    public String getOptPrefix() {\n        return defaultOptPrefix;\n    }\n\n    \n    public void setLongOptPrefix(String prefix) {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    \n    public String getLongOptPrefix() {\n        return defaultLongOptPrefix;\n    }\n\n    \n    public void setLongOptSeparator(String longOptSeparator) {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    \n    public String getLongOptSeparator() {\n        return longOptSeparator;\n    }\n\n    \n    public void setArgName(String name) {\n        this.defaultArgName = name;\n    }\n\n    \n    public String getArgName() {\n        return defaultArgName;\n    }\n\n    \n    public Comparator getOptionComparator() {\n        return optionComparator;\n    }\n\n    \n    public void setOptionComparator(Comparator comparator) {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    \n    public void printHelp(String cmdLineSyntax, Options options) {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    \n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage) {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    \n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer) {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    \n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage) {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    \n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer) {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    \n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage) {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    \n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, String header, Options options, int leftPad, int descPad, String footer) {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    \n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, String header, Options options, int leftPad, int descPad, String footer, boolean autoUsage) {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    \n    public void printUsage(PrintWriter pw, int width, String app, Options options) {\n        \n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        \n        final Collection processedGroups = new ArrayList();\n\n        \n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        \n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            \n            option = (Option) i.next();\n\n            \n            OptionGroup group = options.getOptionGroup(option);\n\n            \n            if (group != null)\n            {\n                \n                if (!processedGroups.contains(group))\n                {\n                    \n                    processedGroups.add(group);\n\n\n                    \n                    appendOptionGroup(buff, group);\n                }\n\n                \n                \n            }\n\n            \n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        \n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    \n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group) {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        \n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            \n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    \n    private void appendOption(final StringBuffer buff, final Option option, final boolean required) {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        \n        if (option.hasArg() && option.hasArgName())\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName()).append(\">\");\n        }\n        \n        \n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    \n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax) {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    \n    public void printOptions(PrintWriter pw, int width, Options options, int leftPad, int descPad) {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    \n    public void printWrapped(PrintWriter pw, int width, String text) {\n        printWrapped(pw, width, 0, text);\n    }\n\n    \n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text) {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    \n\n    \n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad) {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        \n        \n        \n        \n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    \n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    \n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            \n            nextLineTabStop = 1;\n        }\n\n        \n        \n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    \n    protected int findWrapPos(String text, int width, int startPos) {\n        int pos = -1;\n\n        \n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        \n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        \n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        \n        \n        pos = startPos + width;\n\n        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            ++pos;\n        }\n\n        return (pos == text.length()) ? (-1) : pos;\n    }\n\n    \n    protected String createPadding(int len) {\n        StringBuffer sb = new StringBuffer(len);\n\n        for (int i = 0; i < len; ++i)\n        {\n            sb.append(' ');\n        }\n\n        return sb.toString();\n    }\n\n    \n    protected String rtrim(String s) {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    \n    \n    \n    \n    private static class OptionComparator implements Comparator { public int compare(Object o1, Object o2) {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n\npublic class HelpFormatter { public static final int DEFAULT_WIDTH = 74; public static final int DEFAULT_LEFT_PAD = 1; public static final int DEFAULT_DESC_PAD = 3; public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \"; public static final String DEFAULT_OPT_PREFIX = \"-\"; public static final String DEFAULT_LONG_OPT_PREFIX = \"--\"; public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \"; public static final String DEFAULT_ARG_NAME = \"arg\"; public int defaultWidth = DEFAULT_WIDTH; public int defaultLeftPad = DEFAULT_LEFT_PAD; public int defaultDescPad = DEFAULT_DESC_PAD; public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX; public String defaultNewLine = System.getProperty(\"line.separator\"); public String defaultOptPrefix = DEFAULT_OPT_PREFIX; public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX; private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR; public String defaultArgName = DEFAULT_ARG_NAME; protected Comparator optionComparator = new OptionComparator(); public void setWidth(int width) {\n        this.defaultWidth = width;\n    }\n\n    \n    public int getWidth() {\n        return defaultWidth;\n    }\n\n    \n    public void setLeftPadding(int padding) {\n        this.defaultLeftPad = padding;\n    }\n\n    \n    public int getLeftPadding() {\n        return defaultLeftPad;\n    }\n\n    \n    public void setDescPadding(int padding) {\n        this.defaultDescPad = padding;\n    }\n\n    \n    public int getDescPadding() {\n        return defaultDescPad;\n    }\n\n    \n    public void setSyntaxPrefix(String prefix) {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    \n    public String getSyntaxPrefix() {\n        return defaultSyntaxPrefix;\n    }\n\n    \n    public void setNewLine(String newline) {\n        this.defaultNewLine = newline;\n    }\n\n    \n    public String getNewLine() {\n        return defaultNewLine;\n    }\n\n    \n    public void setOptPrefix(String prefix) {\n        this.defaultOptPrefix = prefix;\n    }\n\n    \n    public String getOptPrefix() {\n        return defaultOptPrefix;\n    }\n\n    \n    public void setLongOptPrefix(String prefix) {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    \n    public String getLongOptPrefix() {\n        return defaultLongOptPrefix;\n    }\n\n    \n    public void setLongOptSeparator(String longOptSeparator) {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    \n    public String getLongOptSeparator() {\n        return longOptSeparator;\n    }\n\n    \n    public void setArgName(String name) {\n        this.defaultArgName = name;\n    }\n\n    \n    public String getArgName() {\n        return defaultArgName;\n    }\n\n    \n    public Comparator getOptionComparator() {\n        return optionComparator;\n    }\n\n    \n    public void setOptionComparator(Comparator comparator) {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    \n    public void printHelp(String cmdLineSyntax, Options options) {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    \n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage) {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    \n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer) {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    \n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage) {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    \n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer) {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    \n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage) {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    \n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, String header, Options options, int leftPad, int descPad, String footer) {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    \n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, String header, Options options, int leftPad, int descPad, String footer, boolean autoUsage) {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    \n    public void printUsage(PrintWriter pw, int width, String app, Options options) {\n        \n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        \n        final Collection processedGroups = new ArrayList();\n\n        \n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        \n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            \n            option = (Option) i.next();\n\n            \n            OptionGroup group = options.getOptionGroup(option);\n\n            \n            if (group != null)\n            {\n                \n                if (!processedGroups.contains(group))\n                {\n                    \n                    processedGroups.add(group);\n\n\n                    \n                    appendOptionGroup(buff, group);\n                }\n\n                \n                \n            }\n\n            \n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        \n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    \n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group) {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        \n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            \n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    \n    private void appendOption(final StringBuffer buff, final Option option, final boolean required) {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        \n        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        \n        \n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    \n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax) {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    \n    public void printOptions(PrintWriter pw, int width, Options options, int leftPad, int descPad) {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    \n    public void printWrapped(PrintWriter pw, int width, String text) {\n        printWrapped(pw, width, 0, text);\n    }\n\n    \n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text) {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    \n\n    \n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad) {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        \n        \n        \n        \n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    \n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    \n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            \n            nextLineTabStop = 1;\n        }\n\n        \n        \n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    \n    protected int findWrapPos(String text, int width, int startPos) {\n        int pos = -1;\n\n        \n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        \n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        \n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        \n        \n        pos = startPos + width;\n\n        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            ++pos;\n        }\n\n        return (pos == text.length()) ? (-1) : pos;\n    }\n\n    \n    protected String createPadding(int len) {\n        StringBuffer sb = new StringBuffer(len);\n\n        for (int i = 0; i < len; ++i)\n        {\n            sb.append(' ');\n        }\n\n        return sb.toString();\n    }\n\n    \n    protected String rtrim(String s) {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    \n    \n    \n    \n    private static class OptionComparator implements Comparator { public int compare(Object o1, Object o2) {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}\n",
      "buggy_signatures": [
        "public int getWidth()",
        "public void setLeftPadding(int padding)",
        "public int getLeftPadding()",
        "public void setDescPadding(int padding)",
        "public int getDescPadding()",
        "public void setSyntaxPrefix(String prefix)",
        "public String getSyntaxPrefix()",
        "public void setNewLine(String newline)",
        "public String getNewLine()",
        "public void setOptPrefix(String prefix)",
        "public String getOptPrefix()",
        "public void setLongOptPrefix(String prefix)",
        "public String getLongOptPrefix()",
        "public void setLongOptSeparator(String longOptSeparator)",
        "public String getLongOptSeparator()",
        "public void setArgName(String name)",
        "public String getArgName()",
        "public Comparator getOptionComparator()",
        "public void setOptionComparator(Comparator comparator)",
        "public void printHelp(String cmdLineSyntax, Options options)",
        "public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)",
        "public void printHelp(String cmdLineSyntax, String header, Options options, String footer)",
        "public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)",
        "public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)",
        "public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)",
        "public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, String header, Options options, int leftPad, int descPad, String footer)",
        "public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, String header, Options options, int leftPad, int descPad, String footer, boolean autoUsage)",
        "public void printUsage(PrintWriter pw, int width, String app, Options options)",
        "private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)",
        "private void appendOption(final StringBuffer buff, final Option option, final boolean required)",
        "public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)",
        "public void printOptions(PrintWriter pw, int width, Options options, int leftPad, int descPad)",
        "public void printWrapped(PrintWriter pw, int width, String text)",
        "public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)",
        "protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text)",
        "protected int findWrapPos(String text, int width, int startPos)",
        "protected String createPadding(int len)",
        "protected String rtrim(String s)",
        "private static class OptionComparator implements Comparator { public int compare(Object o1, Object o2)"
      ],
      "fixed_signatures": [
        "public int getWidth()",
        "public void setLeftPadding(int padding)",
        "public int getLeftPadding()",
        "public void setDescPadding(int padding)",
        "public int getDescPadding()",
        "public void setSyntaxPrefix(String prefix)",
        "public String getSyntaxPrefix()",
        "public void setNewLine(String newline)",
        "public String getNewLine()",
        "public void setOptPrefix(String prefix)",
        "public String getOptPrefix()",
        "public void setLongOptPrefix(String prefix)",
        "public String getLongOptPrefix()",
        "public void setLongOptSeparator(String longOptSeparator)",
        "public String getLongOptSeparator()",
        "public void setArgName(String name)",
        "public String getArgName()",
        "public Comparator getOptionComparator()",
        "public void setOptionComparator(Comparator comparator)",
        "public void printHelp(String cmdLineSyntax, Options options)",
        "public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)",
        "public void printHelp(String cmdLineSyntax, String header, Options options, String footer)",
        "public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)",
        "public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)",
        "public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)",
        "public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, String header, Options options, int leftPad, int descPad, String footer)",
        "public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, String header, Options options, int leftPad, int descPad, String footer, boolean autoUsage)",
        "public void printUsage(PrintWriter pw, int width, String app, Options options)",
        "private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)",
        "private void appendOption(final StringBuffer buff, final Option option, final boolean required)",
        "public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)",
        "public void printOptions(PrintWriter pw, int width, Options options, int leftPad, int descPad)",
        "public void printWrapped(PrintWriter pw, int width, String text)",
        "public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)",
        "protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text)",
        "protected int findWrapPos(String text, int width, int startPos)",
        "protected String createPadding(int len)",
        "protected String rtrim(String s)",
        "private static class OptionComparator implements Comparator { public int compare(Object o1, Object o2)"
      ],
      "methods": [
        {
          "buggy_method": "  private void appendOption(final StringBuffer buff, final Option option, final boolean required) {\n  if (!required)\n  {\n  buff.append(\"[\");\n  }\n\n  if (option.getOpt() != null)\n  {\n  buff.append(\"-\").append(option.getOpt());\n  }\n  else\n  {\n  buff.append(\"--\").append(option.getLongOpt());\n  }\n  \n  \n  if (option.hasArg() && option.hasArgName())\n  {\n  buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n  buff.append(\"<\").append(option.getArgName()).append(\">\");\n  }\n  \n  \n  if (!required)\n  {\n  buff.append(\"]\");\n  }\n  }",
          "fixed_method": "  private void appendOption(final StringBuffer buff, final Option option, final boolean required) {\n  if (!required)\n  {\n  buff.append(\"[\");\n  }\n\n  if (option.getOpt() != null)\n  {\n  buff.append(\"-\").append(option.getOpt());\n  }\n  else\n  {\n  buff.append(\"--\").append(option.getLongOpt());\n  }\n  \n  \n  if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))\n  {\n  buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n  buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n  }\n  \n  \n  if (!required)\n  {\n  buff.append(\"]\");\n  }\n  }",
          "diff": [
            "@@ -650,10 +650,10 @@",
            "         }\n",
            "         \n",
            "         // if the Option has a value and a non blank argname\n",
            "-        if (option.hasArg() && option.hasArgName())\n",
            "+        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))\n",
            "         {\n",
            "             buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n",
            "-            buff.append(\"<\").append(option.getArgName()).append(\">\");\n",
            "+            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n",
            "         }\n",
            "         \n",
            "         // if the Option is not a required option\n"
          ],
          "changed_lines": 4
        }
      ]
    },
    {
      "name": "org/apache/commons/cli/Option.java",
      "buggy_full_code": "\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\n\npublic class Option implements Cloneable, Serializable { private static final long serialVersionUID = 1L; public static final int UNINITIALIZED = -1; public static final int UNLIMITED_VALUES = -2; private String opt; private String longOpt; private String argName = \"arg\"; private String description; private boolean required; private boolean optionalArg; private int numberOfArgs = UNINITIALIZED; private Object type; private List values = new ArrayList(); private char valuesep; public Option(String opt, String description) throws IllegalArgumentException {\n        this(opt, null, false, description);\n    }\n\n    \n    public Option(String opt, boolean hasArg, String description) throws IllegalArgumentException {\n        this(opt, null, hasArg, description);\n    }\n\n    \n    public Option(String opt, String longOpt, boolean hasArg, String description) throws IllegalArgumentException {\n        \n        OptionValidator.validateOption(opt);\n\n        this.opt = opt;\n        this.longOpt = longOpt;\n\n        \n        if (hasArg)\n        {\n            this.numberOfArgs = 1;\n        }\n\n        this.description = description;\n    }\n\n    \n    public int getId() {\n        return getKey().charAt(0);\n    }\n\n    \n    String getKey()\n    {\n        \n        if (opt == null)\n        {\n            return longOpt;\n        }\n\n        return opt;\n    }\n\n    \n    public String getOpt() {\n        return opt;\n    }\n\n    \n    public Object getType() {\n        return type;\n    }\n\n    \n    public void setType(Object type) {\n        this.type = type;\n    }\n\n    \n    public String getLongOpt() {\n        return longOpt;\n    }\n\n    \n    public void setLongOpt(String longOpt) {\n        this.longOpt = longOpt;\n    }\n\n    \n    public void setOptionalArg(boolean optionalArg) {\n        this.optionalArg = optionalArg;\n    }\n\n    \n    public boolean hasOptionalArg() {\n        return optionalArg;\n    }\n\n    \n    public boolean hasLongOpt() {\n        return longOpt != null;\n    }\n\n    \n    public boolean hasArg() {\n        return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n    }\n\n    \n    public String getDescription() {\n        return description;\n    }\n\n    \n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    \n    public boolean isRequired() {\n        return required;\n    }\n\n    \n    public void setRequired(boolean required) {\n        this.required = required;\n    }\n\n    \n    public void setArgName(String argName) {\n        this.argName = argName;\n    }\n\n    \n    public String getArgName() {\n        return argName;\n    }\n\n    \n    public boolean hasArgName() {\n        return argName != null && argName.length() > 0;\n    }\n\n    \n    public boolean hasArgs() {\n        return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES;\n    }\n\n    \n    public void setArgs(int num) {\n        this.numberOfArgs = num;\n    }\n\n    \n    public void setValueSeparator(char sep) {\n        this.valuesep = sep;\n    }\n\n    \n    public char getValueSeparator() {\n        return valuesep;\n    }\n\n    \n    public boolean hasValueSeparator() {\n        return valuesep > 0;\n    }\n\n    \n    public int getArgs() {\n        return numberOfArgs;\n    }\n\n    \n    void addValueForProcessing(String value)\n    {\n        switch (numberOfArgs)\n        {\n            case UNINITIALIZED:\n                throw new RuntimeException(\"NO_ARGS_ALLOWED\");\n\n            default:\n                processValue(value);\n        }\n    }\n\n    \n    private void processValue(String value) {\n        \n        if (hasValueSeparator())\n        {\n            \n            char sep = getValueSeparator();\n\n            \n            int index = value.indexOf(sep);\n\n            \n            while (index != -1)\n            {\n                \n                if (values.size() == (numberOfArgs - 1))\n                {\n                    break;\n                }\n\n                \n                add(value.substring(0, index));\n\n                \n                value = value.substring(index + 1);\n\n                \n                index = value.indexOf(sep);\n            }\n        }\n\n        \n        add(value);\n    }\n\n    \n    private void add(String value) {\n        if (!acceptsArg())\n        {\n            throw new RuntimeException(\"Cannot add value, list full.\");\n        }\n\n        \n        values.add(value);\n    }\n\n    \n    public String getValue() {\n        return hasNoValues() ? null : (String) values.get(0);\n    }\n\n    \n    public String getValue(int index) throws IndexOutOfBoundsException {\n        return hasNoValues() ? null : (String) values.get(index);\n    }\n\n    \n    public String getValue(String defaultValue) {\n        String value = getValue();\n\n        return (value != null) ? value : defaultValue;\n    }\n\n    \n    public String[] getValues() {\n        return hasNoValues() ? null : (String[]) values.toArray(new String[values.size()]);\n    }\n\n    \n    public List getValuesList() {\n        return values;\n    }\n\n    \n    public String toString() {\n        StringBuffer buf = new StringBuffer().append(\"[ option: \");\n\n        buf.append(opt);\n\n        if (longOpt != null)\n        {\n            buf.append(\" \").append(longOpt);\n        }\n\n        buf.append(\" \");\n\n        if (hasArgs())\n        {\n            buf.append(\"[ARG...]\");\n        }\n        else if (hasArg())\n        {\n            buf.append(\" [ARG]\");\n        }\n\n        buf.append(\" :: \").append(description);\n\n        if (type != null)\n        {\n            buf.append(\" :: \").append(type);\n        }\n\n        buf.append(\" ]\");\n\n        return buf.toString();\n    }\n\n    \n    private boolean hasNoValues() {\n        return values.isEmpty();\n    }\n\n    public boolean equals(Object o) {\n        if (this == o)\n        {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass())\n        {\n            return false;\n        }\n\n        Option option = (Option) o;\n\n\n        if (opt != null ? !opt.equals(option.opt) : option.opt != null)\n        {\n            return false;\n        }\n        if (longOpt != null ? !longOpt.equals(option.longOpt) : option.longOpt != null)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    public int hashCode() {\n        int result;\n        result = opt != null ? opt.hashCode() : 0;\n        result = 31 * result + (longOpt != null ? longOpt.hashCode() : 0);\n        return result;\n    }\n\n    \n    public Object clone() {\n        try\n        {\n            Option option = (Option) super.clone();\n            option.values = new ArrayList(values);\n            return option;\n        }\n        catch (CloneNotSupportedException cnse)\n        {\n            throw new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n        }\n    }\n\n    \n    void clearValues()\n    {\n        values.clear();\n    }\n\n    \n    public boolean addValue(String value) {\n        throw new UnsupportedOperationException(\"The addValue method is not intended for client use. \"\n                + \"Subclasses should use the addValueForProcessing method instead. \");\n    }\n\n    \n    boolean acceptsArg()\n    {\n        return (hasArg() || hasArgs() || hasOptionalArg()) && (numberOfArgs <= 0 || values.size() < numberOfArgs);\n    }\n\n    \n    boolean requiresArg()\n    {\n        if (optionalArg)\n        {\n            return false;\n        }\n        if (numberOfArgs == UNLIMITED_VALUES)\n        {\n            return values.size() < 1;\n        }\n        else\n        {\n            return acceptsArg();\n        }\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\n\npublic class Option implements Cloneable, Serializable { private static final long serialVersionUID = 1L; public static final int UNINITIALIZED = -1; public static final int UNLIMITED_VALUES = -2; private String opt; private String longOpt; private String argName; private String description; private boolean required; private boolean optionalArg; private int numberOfArgs = UNINITIALIZED; private Object type; private List values = new ArrayList(); private char valuesep; public Option(String opt, String description) throws IllegalArgumentException {\n        this(opt, null, false, description);\n    }\n\n    \n    public Option(String opt, boolean hasArg, String description) throws IllegalArgumentException {\n        this(opt, null, hasArg, description);\n    }\n\n    \n    public Option(String opt, String longOpt, boolean hasArg, String description) throws IllegalArgumentException {\n        \n        OptionValidator.validateOption(opt);\n\n        this.opt = opt;\n        this.longOpt = longOpt;\n\n        \n        if (hasArg)\n        {\n            this.numberOfArgs = 1;\n        }\n\n        this.description = description;\n    }\n\n    \n    public int getId() {\n        return getKey().charAt(0);\n    }\n\n    \n    String getKey()\n    {\n        \n        if (opt == null)\n        {\n            return longOpt;\n        }\n\n        return opt;\n    }\n\n    \n    public String getOpt() {\n        return opt;\n    }\n\n    \n    public Object getType() {\n        return type;\n    }\n\n    \n    public void setType(Object type) {\n        this.type = type;\n    }\n\n    \n    public String getLongOpt() {\n        return longOpt;\n    }\n\n    \n    public void setLongOpt(String longOpt) {\n        this.longOpt = longOpt;\n    }\n\n    \n    public void setOptionalArg(boolean optionalArg) {\n        this.optionalArg = optionalArg;\n    }\n\n    \n    public boolean hasOptionalArg() {\n        return optionalArg;\n    }\n\n    \n    public boolean hasLongOpt() {\n        return longOpt != null;\n    }\n\n    \n    public boolean hasArg() {\n        return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n    }\n\n    \n    public String getDescription() {\n        return description;\n    }\n\n    \n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    \n    public boolean isRequired() {\n        return required;\n    }\n\n    \n    public void setRequired(boolean required) {\n        this.required = required;\n    }\n\n    \n    public void setArgName(String argName) {\n        this.argName = argName;\n    }\n\n    \n    public String getArgName() {\n        return argName;\n    }\n\n    \n    public boolean hasArgName() {\n        return argName != null && argName.length() > 0;\n    }\n\n    \n    public boolean hasArgs() {\n        return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES;\n    }\n\n    \n    public void setArgs(int num) {\n        this.numberOfArgs = num;\n    }\n\n    \n    public void setValueSeparator(char sep) {\n        this.valuesep = sep;\n    }\n\n    \n    public char getValueSeparator() {\n        return valuesep;\n    }\n\n    \n    public boolean hasValueSeparator() {\n        return valuesep > 0;\n    }\n\n    \n    public int getArgs() {\n        return numberOfArgs;\n    }\n\n    \n    void addValueForProcessing(String value)\n    {\n        switch (numberOfArgs)\n        {\n            case UNINITIALIZED:\n                throw new RuntimeException(\"NO_ARGS_ALLOWED\");\n\n            default:\n                processValue(value);\n        }\n    }\n\n    \n    private void processValue(String value) {\n        \n        if (hasValueSeparator())\n        {\n            \n            char sep = getValueSeparator();\n\n            \n            int index = value.indexOf(sep);\n\n            \n            while (index != -1)\n            {\n                \n                if (values.size() == (numberOfArgs - 1))\n                {\n                    break;\n                }\n\n                \n                add(value.substring(0, index));\n\n                \n                value = value.substring(index + 1);\n\n                \n                index = value.indexOf(sep);\n            }\n        }\n\n        \n        add(value);\n    }\n\n    \n    private void add(String value) {\n        if (!acceptsArg())\n        {\n            throw new RuntimeException(\"Cannot add value, list full.\");\n        }\n\n        \n        values.add(value);\n    }\n\n    \n    public String getValue() {\n        return hasNoValues() ? null : (String) values.get(0);\n    }\n\n    \n    public String getValue(int index) throws IndexOutOfBoundsException {\n        return hasNoValues() ? null : (String) values.get(index);\n    }\n\n    \n    public String getValue(String defaultValue) {\n        String value = getValue();\n\n        return (value != null) ? value : defaultValue;\n    }\n\n    \n    public String[] getValues() {\n        return hasNoValues() ? null : (String[]) values.toArray(new String[values.size()]);\n    }\n\n    \n    public List getValuesList() {\n        return values;\n    }\n\n    \n    public String toString() {\n        StringBuffer buf = new StringBuffer().append(\"[ option: \");\n\n        buf.append(opt);\n\n        if (longOpt != null)\n        {\n            buf.append(\" \").append(longOpt);\n        }\n\n        buf.append(\" \");\n\n        if (hasArgs())\n        {\n            buf.append(\"[ARG...]\");\n        }\n        else if (hasArg())\n        {\n            buf.append(\" [ARG]\");\n        }\n\n        buf.append(\" :: \").append(description);\n\n        if (type != null)\n        {\n            buf.append(\" :: \").append(type);\n        }\n\n        buf.append(\" ]\");\n\n        return buf.toString();\n    }\n\n    \n    private boolean hasNoValues() {\n        return values.isEmpty();\n    }\n\n    public boolean equals(Object o) {\n        if (this == o)\n        {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass())\n        {\n            return false;\n        }\n\n        Option option = (Option) o;\n\n\n        if (opt != null ? !opt.equals(option.opt) : option.opt != null)\n        {\n            return false;\n        }\n        if (longOpt != null ? !longOpt.equals(option.longOpt) : option.longOpt != null)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    public int hashCode() {\n        int result;\n        result = opt != null ? opt.hashCode() : 0;\n        result = 31 * result + (longOpt != null ? longOpt.hashCode() : 0);\n        return result;\n    }\n\n    \n    public Object clone() {\n        try\n        {\n            Option option = (Option) super.clone();\n            option.values = new ArrayList(values);\n            return option;\n        }\n        catch (CloneNotSupportedException cnse)\n        {\n            throw new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n        }\n    }\n\n    \n    void clearValues()\n    {\n        values.clear();\n    }\n\n    \n    public boolean addValue(String value) {\n        throw new UnsupportedOperationException(\"The addValue method is not intended for client use. \"\n                + \"Subclasses should use the addValueForProcessing method instead. \");\n    }\n\n    \n    boolean acceptsArg()\n    {\n        return (hasArg() || hasArgs() || hasOptionalArg()) && (numberOfArgs <= 0 || values.size() < numberOfArgs);\n    }\n\n    \n    boolean requiresArg()\n    {\n        if (optionalArg)\n        {\n            return false;\n        }\n        if (numberOfArgs == UNLIMITED_VALUES)\n        {\n            return values.size() < 1;\n        }\n        else\n        {\n            return acceptsArg();\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public Option(String opt, boolean hasArg, String description) throws IllegalArgumentException",
        "public Option(String opt, String longOpt, boolean hasArg, String description) throws IllegalArgumentException",
        "public int getId()",
        "public String getOpt()",
        "public Object getType()",
        "public void setType(Object type)",
        "public String getLongOpt()",
        "public void setLongOpt(String longOpt)",
        "public void setOptionalArg(boolean optionalArg)",
        "public boolean hasOptionalArg()",
        "public boolean hasLongOpt()",
        "public boolean hasArg()",
        "public String getDescription()",
        "public void setDescription(String description)",
        "public boolean isRequired()",
        "public void setRequired(boolean required)",
        "public void setArgName(String argName)",
        "public String getArgName()",
        "public boolean hasArgName()",
        "public boolean hasArgs()",
        "public void setArgs(int num)",
        "public void setValueSeparator(char sep)",
        "public char getValueSeparator()",
        "public boolean hasValueSeparator()",
        "public int getArgs()",
        "private void processValue(String value)",
        "private void add(String value)",
        "public String getValue()",
        "public String getValue(int index) throws IndexOutOfBoundsException",
        "public String getValue(String defaultValue)",
        "public String[] getValues()",
        "public List getValuesList()",
        "public String toString()",
        "private boolean hasNoValues()",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "public Object clone()",
        "public boolean addValue(String value)"
      ],
      "fixed_signatures": [
        "public Option(String opt, boolean hasArg, String description) throws IllegalArgumentException",
        "public Option(String opt, String longOpt, boolean hasArg, String description) throws IllegalArgumentException",
        "public int getId()",
        "public String getOpt()",
        "public Object getType()",
        "public void setType(Object type)",
        "public String getLongOpt()",
        "public void setLongOpt(String longOpt)",
        "public void setOptionalArg(boolean optionalArg)",
        "public boolean hasOptionalArg()",
        "public boolean hasLongOpt()",
        "public boolean hasArg()",
        "public String getDescription()",
        "public void setDescription(String description)",
        "public boolean isRequired()",
        "public void setRequired(boolean required)",
        "public void setArgName(String argName)",
        "public String getArgName()",
        "public boolean hasArgName()",
        "public boolean hasArgs()",
        "public void setArgs(int num)",
        "public void setValueSeparator(char sep)",
        "public char getValueSeparator()",
        "public boolean hasValueSeparator()",
        "public int getArgs()",
        "private void processValue(String value)",
        "private void add(String value)",
        "public String getValue()",
        "public String getValue(int index) throws IndexOutOfBoundsException",
        "public String getValue(String defaultValue)",
        "public String[] getValues()",
        "public List getValuesList()",
        "public String toString()",
        "private boolean hasNoValues()",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "public Object clone()",
        "public boolean addValue(String value)"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -54,7 +54,7 @@",
            "     private String longOpt;\n",
            " \n",
            "     /** the name of the argument for this option */\n",
            "-    private String argName = \"arg\";\n",
            "+    private String argName;\n",
            " \n",
            "     /** description of the option */\n",
            "     private String description;\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "org/apache/commons/cli/OptionBuilder.java",
      "buggy_full_code": "\n\npackage org.apache.commons.cli;\n\n\npublic final class OptionBuilder { private static String longopt; private static String description; private static String argName; private static boolean required; private static int numberOfArgs = Option.UNINITIALIZED; private static Object type; private static boolean optionalArg; private static char valuesep; private static OptionBuilder instance = new OptionBuilder(); static {\n        \n        reset();\n    }\n\n    \n    private OptionBuilder() {\n        \n    }\n\n    \n    private static void reset() {\n        description = null;\n        argName = \"arg\";\n        longopt = null;\n        type = null;\n        required = false;\n        numberOfArgs = Option.UNINITIALIZED;\n        optionalArg = false;\n        valuesep = (char) 0;\n    }\n\n    \n    public static OptionBuilder withLongOpt(String newLongopt) {\n        OptionBuilder.longopt = newLongopt;\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder hasArg() {\n        OptionBuilder.numberOfArgs = 1;\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder hasArg(boolean hasArg) {\n        OptionBuilder.numberOfArgs = hasArg ? 1 : Option.UNINITIALIZED;\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder withArgName(String name) {\n        OptionBuilder.argName = name;\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder isRequired() {\n        OptionBuilder.required = true;\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder withValueSeparator(char sep) {\n        OptionBuilder.valuesep = sep;\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder withValueSeparator() {\n        OptionBuilder.valuesep = '=';\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder isRequired(boolean newRequired) {\n        OptionBuilder.required = newRequired;\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder hasArgs() {\n        OptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder hasArgs(int num) {\n        OptionBuilder.numberOfArgs = num;\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder hasOptionalArg() {\n        OptionBuilder.numberOfArgs = 1;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder hasOptionalArgs() {\n        OptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder hasOptionalArgs(int numArgs) {\n        OptionBuilder.numberOfArgs = numArgs;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder withType(Object newType) {\n        OptionBuilder.type = newType;\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder withDescription(String newDescription) {\n        OptionBuilder.description = newDescription;\n\n        return instance;\n    }\n\n    \n    public static Option create(char opt) throws IllegalArgumentException {\n        return create(String.valueOf(opt));\n    }\n\n    \n    public static Option create() throws IllegalArgumentException {\n        if (longopt == null)\n        {\n            OptionBuilder.reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }\n\n    \n    public static Option create(String opt) throws IllegalArgumentException {\n        Option option = null;\n        try\n        {\n            \n            option = new Option(opt, description);\n\n            \n            option.setLongOpt(longopt);\n            option.setRequired(required);\n            option.setOptionalArg(optionalArg);\n            option.setArgs(numberOfArgs);\n            option.setType(type);\n            option.setValueSeparator(valuesep);\n            option.setArgName(argName);\n        }\n        finally\n        {\n            \n            OptionBuilder.reset();\n        }\n\n        \n        return option;\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.cli;\n\n\npublic final class OptionBuilder { private static String longopt; private static String description; private static String argName; private static boolean required; private static int numberOfArgs = Option.UNINITIALIZED; private static Object type; private static boolean optionalArg; private static char valuesep; private static OptionBuilder instance = new OptionBuilder(); static {\n        \n        reset();\n    }\n\n    \n    private OptionBuilder() {\n        \n    }\n\n    \n    private static void reset() {\n        description = null;\n        argName = null;\n        longopt = null;\n        type = null;\n        required = false;\n        numberOfArgs = Option.UNINITIALIZED;\n        optionalArg = false;\n        valuesep = (char) 0;\n    }\n\n    \n    public static OptionBuilder withLongOpt(String newLongopt) {\n        OptionBuilder.longopt = newLongopt;\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder hasArg() {\n        OptionBuilder.numberOfArgs = 1;\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder hasArg(boolean hasArg) {\n        OptionBuilder.numberOfArgs = hasArg ? 1 : Option.UNINITIALIZED;\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder withArgName(String name) {\n        OptionBuilder.argName = name;\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder isRequired() {\n        OptionBuilder.required = true;\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder withValueSeparator(char sep) {\n        OptionBuilder.valuesep = sep;\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder withValueSeparator() {\n        OptionBuilder.valuesep = '=';\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder isRequired(boolean newRequired) {\n        OptionBuilder.required = newRequired;\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder hasArgs() {\n        OptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder hasArgs(int num) {\n        OptionBuilder.numberOfArgs = num;\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder hasOptionalArg() {\n        OptionBuilder.numberOfArgs = 1;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder hasOptionalArgs() {\n        OptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder hasOptionalArgs(int numArgs) {\n        OptionBuilder.numberOfArgs = numArgs;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder withType(Object newType) {\n        OptionBuilder.type = newType;\n\n        return instance;\n    }\n\n    \n    public static OptionBuilder withDescription(String newDescription) {\n        OptionBuilder.description = newDescription;\n\n        return instance;\n    }\n\n    \n    public static Option create(char opt) throws IllegalArgumentException {\n        return create(String.valueOf(opt));\n    }\n\n    \n    public static Option create() throws IllegalArgumentException {\n        if (longopt == null)\n        {\n            OptionBuilder.reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }\n\n    \n    public static Option create(String opt) throws IllegalArgumentException {\n        Option option = null;\n        try\n        {\n            \n            option = new Option(opt, description);\n\n            \n            option.setLongOpt(longopt);\n            option.setRequired(required);\n            option.setOptionalArg(optionalArg);\n            option.setArgs(numberOfArgs);\n            option.setType(type);\n            option.setValueSeparator(valuesep);\n            option.setArgName(argName);\n        }\n        finally\n        {\n            \n            OptionBuilder.reset();\n        }\n\n        \n        return option;\n    }\n}\n",
      "buggy_signatures": [
        "private OptionBuilder()",
        "private static void reset()",
        "public static OptionBuilder withLongOpt(String newLongopt)",
        "public static OptionBuilder hasArg()",
        "public static OptionBuilder hasArg(boolean hasArg)",
        "public static OptionBuilder withArgName(String name)",
        "public static OptionBuilder isRequired()",
        "public static OptionBuilder withValueSeparator(char sep)",
        "public static OptionBuilder withValueSeparator()",
        "public static OptionBuilder isRequired(boolean newRequired)",
        "public static OptionBuilder hasArgs()",
        "public static OptionBuilder hasArgs(int num)",
        "public static OptionBuilder hasOptionalArg()",
        "public static OptionBuilder hasOptionalArgs()",
        "public static OptionBuilder hasOptionalArgs(int numArgs)",
        "public static OptionBuilder withType(Object newType)",
        "public static OptionBuilder withDescription(String newDescription)",
        "public static Option create(char opt) throws IllegalArgumentException",
        "public static Option create() throws IllegalArgumentException",
        "public static Option create(String opt) throws IllegalArgumentException"
      ],
      "fixed_signatures": [
        "private OptionBuilder()",
        "private static void reset()",
        "public static OptionBuilder withLongOpt(String newLongopt)",
        "public static OptionBuilder hasArg()",
        "public static OptionBuilder hasArg(boolean hasArg)",
        "public static OptionBuilder withArgName(String name)",
        "public static OptionBuilder isRequired()",
        "public static OptionBuilder withValueSeparator(char sep)",
        "public static OptionBuilder withValueSeparator()",
        "public static OptionBuilder isRequired(boolean newRequired)",
        "public static OptionBuilder hasArgs()",
        "public static OptionBuilder hasArgs(int num)",
        "public static OptionBuilder hasOptionalArg()",
        "public static OptionBuilder hasOptionalArgs()",
        "public static OptionBuilder hasOptionalArgs(int numArgs)",
        "public static OptionBuilder withType(Object newType)",
        "public static OptionBuilder withDescription(String newDescription)",
        "public static Option create(char opt) throws IllegalArgumentException",
        "public static Option create() throws IllegalArgumentException",
        "public static Option create(String opt) throws IllegalArgumentException"
      ],
      "methods": [
        {
          "buggy_method": "  private static void reset() {\n  description = null;\n  argName = \"arg\";\n  longopt = null;\n  type = null;\n  required = false;\n  numberOfArgs = Option.UNINITIALIZED;\n  optionalArg = false;\n  valuesep = (char) 0;\n  }",
          "fixed_method": "  private static void reset() {\n  description = null;\n  argName = null;\n  longopt = null;\n  type = null;\n  required = false;\n  numberOfArgs = Option.UNINITIALIZED;\n  optionalArg = false;\n  valuesep = (char) 0;\n  }",
          "diff": [
            "@@ -77,7 +77,7 @@",
            "     private static void reset()\n",
            "     {\n",
            "         description = null;\n",
            "-        argName = \"arg\";\n",
            "+        argName = null;\n",
            "         longopt = null;\n",
            "         type = null;\n",
            "         required = false;\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
