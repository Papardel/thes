{
  "bug_id": "47",
  "failed_tests": {
    "com.fasterxml.jackson.databind.ser.TestJsonSerialize": [
      {
        "methodName": "testBrokenAnnotation",
        "error": "junit.framework.AssertionFailedError",
        "message": "Expected an exception with one of substrings ([types not related]): got one with message \"Failed to widen type [simple type, class java.lang.Long] with annotation (value java.lang.String), from 'getValue': Class java.lang.String not a super-type of [simple type, class java.lang.Long]\"",
        "fail_line": "            verifyException(e, \"types not related\");",
        "test_source": "  public void testBrokenAnnotation() throws Exception {\n  try {\n  serializeAsString(MAPPER, new BrokenClass());\n  } catch (Exception e) {\n  verifyException(e, \"types not related\");\n  }\n  }",
        "stack": [
          "BaseTest.verifyException line 368, TestJsonSerialize.testBrokenAnnotation line 152"
        ]
      }
    ],
    "com.fasterxml.jackson.databind.ser.TestJsonSerializeAs": [
      {
        "methodName": "testSpecializedAsIntermediate",
        "error": "com.fasterxml.jackson.databind.JsonMappingException",
        "message": "Failed to widen type [simple type, class com.fasterxml.jackson.databind.ser.TestJsonSerializeAs$Bean1178Base] with annotation (value com.fasterxml.jackson.databind.ser.TestJsonSerializeAs$Bean1178Abstract), from 'value': Class com.fasterxml.jackson.databind.ser.TestJsonSerializeAs$Bean1178Abstract not a super-type of [simple type, class com.fasterxml.jackson.databind.ser.TestJsonSerializeAs$Bean1178Base]",
        "fail_line": "                WRITER.writeValueAsString(new Bean1178Holder()));",
        "test_source": "  public void testSpecializedAsIntermediate() throws IOException {\n  assertEquals(aposToQuotes(\"{'value':{'a':1,'b':2}}\"),\n  WRITER.writeValueAsString(new Bean1178Holder()));\n  }",
        "stack": [
          "AnnotationIntrospector.refineSerializationType line 822, PropertyBuilder.findSerializationType line 194, PropertyBuilder.buildWriter line 73, BeanSerializerFactory._constructWriter line 805, BeanSerializerFactory.findBeanProperties line 610, BeanSerializerFactory.constructBeanSerializer line 388, BeanSerializerFactory.findBeanSerializer line 271, BeanSerializerFactory._createSerializer2 line 223, BeanSerializerFactory.createSerializer line 157, SerializerProvider._createUntypedSerializer line 1215, SerializerProvider._createAndCacheUntypedSerializer line 1167, SerializerProvider.findValueSerializer line 490, SerializerProvider.findTypedValueSerializer line 688, DefaultSerializerProvider.serializeValue line 107, ObjectWriter$Prefetch.serialize line 1428, ObjectWriter._configAndWriteValue line 1129, ObjectWriter.writeValueAsString line 1001, TestJsonSerializeAs.testSpecializedAsIntermediate line 119, TypeFactory.constructGeneralizedType line 482, AnnotationIntrospector.refineSerializationType line 819"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/AnnotationIntrospector.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind;\n\nimport java.lang.annotation.Annotation;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.core.Version;\nimport com.fasterxml.jackson.core.Versioned;\nimport com.fasterxml.jackson.databind.JsonDeserializer;\nimport com.fasterxml.jackson.databind.JsonSerializer;\nimport com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.deser.ValueInstantiator;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\nimport com.fasterxml.jackson.databind.type.MapLikeType;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.Converter;\nimport com.fasterxml.jackson.databind.util.NameTransformer;\n\n\n@SuppressWarnings(\"serial\")\npublic abstract class AnnotationIntrospector implements Versioned, java.io.Serializable { public static class ReferenceProperty { public enum Type { MANAGED_REFERENCE ,BACK_REFERENCE ; } private final Type _type; private final String _name; public ReferenceProperty(Type t, String n) {\n            _type = t;\n            _name = n;\n        }\n\n        public static ReferenceProperty managed(String name) { return new ReferenceProperty(Type.MANAGED_REFERENCE, name); }\n        public static ReferenceProperty back(String name) { return new ReferenceProperty(Type.BACK_REFERENCE, name); }\n        \n        public Type getType() { return _type; }\n        public String getName() { return _name; }\n\n        public boolean isManagedReference() { return _type == Type.MANAGED_REFERENCE; }\n        public boolean isBackReference() { return _type == Type.BACK_REFERENCE; }\n    }\n    \n    \n    \n    \n    public static AnnotationIntrospector nopInstance() {\n        return NopAnnotationIntrospector.instance;\n    }\n\n    public static AnnotationIntrospector pair(AnnotationIntrospector a1, AnnotationIntrospector a2) {\n        return new AnnotationIntrospectorPair(a1, a2);\n    }\n\n    \n\n    \n    public Collection<AnnotationIntrospector> allIntrospectors() {\n        return Collections.singletonList(this);\n    }\n    \n    \n    public Collection<AnnotationIntrospector> allIntrospectors(Collection<AnnotationIntrospector> result) {\n        result.add(this);\n        return result;\n    }\n    \n    \n\n    @Override\n    public abstract Version version(); public boolean isAnnotationBundle(Annotation ann) {\n        return false;\n    }\n\n    \n    \n    \n    public ObjectIdInfo findObjectIdInfo(Annotated ann) {\n        return null;\n    }\n\n    \n    public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n        return objectIdInfo;\n    }\n\n    \n\n    \n    public PropertyName findRootName(AnnotatedClass ac) {\n        return null;\n    }\n\n    \n    public String[] findPropertiesToIgnore(Annotated ac, boolean forSerialization) {\n        return null;\n    }\n\n    \n    @Deprecated\n    public String[] findPropertiesToIgnore(Annotated ac) {\n        \n        return findPropertiesToIgnore(ac, true);\n    }\n    \n    \n    public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) { return null; }\n\n    \n    public Boolean isIgnorableType(AnnotatedClass ac) { return null; }\n\n    \n    public Object findFilterId(Annotated ann) { return null; }\n\n    \n    public Object findNamingStrategy(AnnotatedClass ac) { return null; }\n\n    \n    public String findClassDescription(AnnotatedClass ac) { return null; }\n\n    \n\n    \n    public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) {\n        return checker;\n    }\n    \n    \n    \n    \n    public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config, AnnotatedClass ac, JavaType baseType) {\n        return null;\n    }\n\n    \n    public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType baseType) {\n        return null;\n    }\n\n        \n    public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType containerType) {\n        return null;\n    }\n\n    \n    public List<NamedType> findSubtypes(Annotated a) { return null; }\n\n    \n    public String findTypeName(AnnotatedClass ac) { return null; }\n\n    \n    public Boolean isTypeId(AnnotatedMember member) { return null; }\n\n    \n\n    \n    public ReferenceProperty findReferenceType(AnnotatedMember member) { return null; }\n\n    \n    public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member) { return null; }\n\n    \n    public boolean hasIgnoreMarker(AnnotatedMember m) { return false; }\n\n    \n    public Object findInjectableValueId(AnnotatedMember m) { return null; }\n\n    \n    public Boolean hasRequiredMarker(AnnotatedMember m) { return null; }\n    \n    \n    public Class<?>[] findViews(Annotated a) { return null; }\n\n    \n    public JsonFormat.Value findFormat(Annotated memberOrClass) { return null; }\n\n    \n    public PropertyName findWrapperName(Annotated ann) { return null; }\n\n    \n    public String findPropertyDefaultValue(Annotated ann) { return null; }\n\n    \n    public String findPropertyDescription(Annotated ann) { return null; }\n\n    \n    public Integer findPropertyIndex(Annotated ann) { return null; }\n\n    \n    public String findImplicitPropertyName(AnnotatedMember member) { return null; }\n\n    \n    public JsonProperty.Access findPropertyAccess(Annotated ann) { return null; }\n\n    \n    public AnnotatedMethod resolveSetterConflict(MapperConfig<?> config, AnnotatedMethod setter1, AnnotatedMethod setter2) {\n        return null;\n    }\n\n    \n\n    \n    public Object findSerializer(Annotated am) {\n        return null;\n    }\n\n    \n    public Object findKeySerializer(Annotated am) {\n        return null;\n    }\n\n    \n    public Object findContentSerializer(Annotated am) {\n        return null;\n    }\n\n    \n    public Object findNullSerializer(Annotated am) {\n        return null;\n    }\n\n    \n    public JsonSerialize.Typing findSerializationTyping(Annotated a) {\n        return null;\n    }\n\n    \n    public Object findSerializationConverter(Annotated a) {\n        return null;\n    }\n\n    \n    public Object findSerializationContentConverter(AnnotatedMember a) {\n        return null;\n    }\n\n    \n    @Deprecated \n    public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) {\n        return defValue;\n    }\n\n    \n    @Deprecated \n    public JsonInclude.Include findSerializationInclusionForContent(Annotated a, JsonInclude.Include defValue) {\n        return defValue;\n    }\n\n    \n    public JsonInclude.Value findPropertyInclusion(Annotated a) {\n        return JsonInclude.Value.empty();\n    }\n\n    \n\n    \n    @Deprecated \n    public Class<?> findSerializationType(Annotated a) {\n        return null;\n    }\n\n    \n    @Deprecated \n    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) {\n        return null;\n    }\n\n    \n    @Deprecated \n    public Class<?> findSerializationContentType(Annotated am, JavaType baseType) {\n        return null;\n    }\n\n    \n    public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n        JavaType type = baseType;\n        final TypeFactory tf = config.getTypeFactory();\n        \n        \n        \n        \n        \n        \n\n        \n        \n        Class<?> serClass = findSerializationType(a);\n        if (serClass != null) {\n            if (type.hasRawClass(serClass)) {\n                \n                \n                type = type.withStaticTyping();\n            } else {\n                try {\n                    \n                    \n                        type = tf.constructGeneralizedType(type, serClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null,\n                            String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\",\n                                    type, serClass.getName(), a.getName(), iae.getMessage()),\n                                    iae);\n                }\n            }\n        }\n        \n\n        \n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            Class<?> keyClass = findSerializationKeyType(a, keyType);\n            if (keyClass != null) {\n                if (keyType.hasRawClass(keyClass)) {\n                    keyType = keyType.withStaticTyping();\n                } else {\n                    Class<?> currRaw = keyType.getRawClass();\n                    try {\n                        \n                        \n                        \n                        if (keyClass.isAssignableFrom(currRaw)) { \n                            keyType = tf.constructGeneralizedType(keyType, keyClass);\n                        } else if (currRaw.isAssignableFrom(keyClass)) { \n                            keyType = tf.constructSpecializedType(keyType, keyClass);\n                        } else {\n                            throw new JsonMappingException(null,\n                                    String.format(\"Can not refine serialization key type %s into %s; types not related\",\n                                            keyType, keyClass.getName()));\n                        }\n                    } catch (IllegalArgumentException iae) {\n                        throw new JsonMappingException(null,\n                                String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                        type, keyClass.getName(), a.getName(), iae.getMessage()),\n                                        iae);\n                    }\n                }\n                type = ((MapLikeType) type).withKeyType(keyType);\n            }\n        }\n\n        JavaType contentType = type.getContentType();\n        if (contentType != null) { \n            \n           Class<?> contentClass = findSerializationContentType(a, contentType);\n           if (contentClass != null) {\n               if (contentType.hasRawClass(contentClass)) {\n                   contentType = contentType.withStaticTyping();\n               } else {\n                   \n                   \n                   \n                   Class<?> currRaw = contentType.getRawClass();\n                   try {\n                       if (contentClass.isAssignableFrom(currRaw)) { \n                           contentType = tf.constructGeneralizedType(contentType, contentClass);\n                       } else if (currRaw.isAssignableFrom(contentClass)) { \n                           contentType = tf.constructSpecializedType(contentType, contentClass);\n                       } else {\n                           throw new JsonMappingException(null,\n                                   String.format(\"Can not refine serialization content type %s into %s; types not related\",\n                                           contentType, contentClass.getName()));\n                       }\n                   } catch (IllegalArgumentException iae) { \n                       throw new JsonMappingException(null,\n                               String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                       type, contentClass.getName(), a.getName(), iae.getMessage()),\n                                       iae);\n                   }\n               }\n               type = type.withContentType(contentType);\n           }\n        }\n        return type;\n    }\n\n    \n\n    \n    public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n        return null;\n    }\n\n    \n    public Boolean findSerializationSortAlphabetically(Annotated ann) {\n        return null;\n    }\n\n    \n    public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac, List<BeanPropertyWriter> properties) { }\n    \n    \n\n    \n    public PropertyName findNameForSerialization(Annotated a) {\n        \n        return null;\n    }\n\n    \n    public boolean hasAsValueAnnotation(AnnotatedMethod am) {\n        return false;\n    }\n\n    \n    \n    public String findEnumValue(Enum<?> value) {\n        return value.name();\n    }\n\n    \n    public String[] findEnumValues(Class<?> enumType, Enum<?>[] enumValues, String[] names) {\n        for (int i = 0, len = enumValues.length; i < len; ++i) {\n            \n            \n            if (names[i] == null) {\n                names[i] = findEnumValue(enumValues[i]);\n            }\n        }\n        return names;\n    }\n\n    \n\n    \n    public Object findDeserializer(Annotated am) {\n        return null;\n    }\n\n    \n    public Object findKeyDeserializer(Annotated am) {\n        return null;\n    }\n\n    \n    public Object findContentDeserializer(Annotated am) {\n        return null;\n    }\n\n    \n    public Object findDeserializationConverter(Annotated a) {\n        return null;\n    }\n\n    \n    public Object findDeserializationContentConverter(AnnotatedMember a) {\n        return null;\n    }\n\n    \n\n    \n    public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n        JavaType type = baseType;\n        final TypeFactory tf = config.getTypeFactory();\n\n        \n        \n        \n        \n        \n\n        \n        \n        Class<?> valueClass = findDeserializationType(a, type);\n        if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n            try {\n                type = tf.constructSpecializedType(type, valueClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null,\n                        String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\",\n                                type, valueClass.getName(), a.getName(), iae.getMessage()),\n                                iae);\n            }\n        }\n        \n\n        \n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            Class<?> keyClass = findDeserializationKeyType(a, keyType);\n            if (keyClass != null) {\n                try {\n                    keyType = tf.constructSpecializedType(keyType, keyClass);\n                    type = ((MapLikeType) type).withKeyType(keyType);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null,\n                            String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                    type, keyClass.getName(), a.getName(), iae.getMessage()),\n                                    iae);\n                }\n            }\n        }\n        JavaType contentType = type.getContentType();\n        if (contentType != null) { \n            \n           Class<?> contentClass = findDeserializationContentType(a, contentType);\n           if (contentClass != null) {\n               try {\n                   contentType = tf.constructSpecializedType(contentType, contentClass);\n                   type = type.withContentType(contentType);\n               } catch (IllegalArgumentException iae) {\n                   throw new JsonMappingException(null,\n                           String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                   type, contentClass.getName(), a.getName(), iae.getMessage()),\n                                   iae);\n               }\n           }\n        }\n        return type;\n    }\n    \n    \n    @Deprecated\n    public Class<?> findDeserializationType(Annotated am, JavaType baseType) {\n        return null;\n    }\n    \n    \n    @Deprecated\n    public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) {\n        return null;\n    }\n\n    \n    @Deprecated\n    public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType) {\n        return null;\n    }\n\n    \n\n    \n    public Object findValueInstantiator(AnnotatedClass ac) {\n        return null;\n    }\n\n    \n    public Class<?> findPOJOBuilder(AnnotatedClass ac) {\n        return null;\n    }\n\n    \n    public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac) {\n        return null;\n    }\n    \n    \n\n    \n    public PropertyName findNameForDeserialization(Annotated a) {\n        \n        return null;\n    }\n    \n    \n    public boolean hasAnySetterAnnotation(AnnotatedMethod am) {\n        return false;\n    }\n\n    \n    public boolean hasAnyGetterAnnotation(AnnotatedMethod am) {\n        return false;\n    }\n    \n    \n    public boolean hasCreatorAnnotation(Annotated a) {\n        return false;\n    }\n\n    \n    public JsonCreator.Mode findCreatorBinding(Annotated a) {\n        return null;\n    }\n    \n    \n\n    \n    protected <A extends Annotation> A _findAnnotation(Annotated annotated, Class<A> annoClass) {\n        return annotated.getAnnotation(annoClass);\n    }\n\n    \n    protected boolean _hasAnnotation(Annotated annotated, Class<? extends Annotation> annoClass) {\n        return annotated.hasAnnotation(annoClass);\n    }\n\n    \n    protected boolean _hasOneOf(Annotated annotated, Class<? extends Annotation>[] annoClasses) {\n        return annotated.hasOneOf(annoClasses);\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind;\n\nimport java.lang.annotation.Annotation;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.core.Version;\nimport com.fasterxml.jackson.core.Versioned;\nimport com.fasterxml.jackson.databind.JsonDeserializer;\nimport com.fasterxml.jackson.databind.JsonSerializer;\nimport com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.deser.ValueInstantiator;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\nimport com.fasterxml.jackson.databind.type.MapLikeType;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.Converter;\nimport com.fasterxml.jackson.databind.util.NameTransformer;\n\n\n@SuppressWarnings(\"serial\")\npublic abstract class AnnotationIntrospector implements Versioned, java.io.Serializable { public static class ReferenceProperty { public enum Type { MANAGED_REFERENCE ,BACK_REFERENCE ; } private final Type _type; private final String _name; public ReferenceProperty(Type t, String n) {\n            _type = t;\n            _name = n;\n        }\n\n        public static ReferenceProperty managed(String name) { return new ReferenceProperty(Type.MANAGED_REFERENCE, name); }\n        public static ReferenceProperty back(String name) { return new ReferenceProperty(Type.BACK_REFERENCE, name); }\n        \n        public Type getType() { return _type; }\n        public String getName() { return _name; }\n\n        public boolean isManagedReference() { return _type == Type.MANAGED_REFERENCE; }\n        public boolean isBackReference() { return _type == Type.BACK_REFERENCE; }\n    }\n    \n    \n    \n    \n    public static AnnotationIntrospector nopInstance() {\n        return NopAnnotationIntrospector.instance;\n    }\n\n    public static AnnotationIntrospector pair(AnnotationIntrospector a1, AnnotationIntrospector a2) {\n        return new AnnotationIntrospectorPair(a1, a2);\n    }\n\n    \n\n    \n    public Collection<AnnotationIntrospector> allIntrospectors() {\n        return Collections.singletonList(this);\n    }\n    \n    \n    public Collection<AnnotationIntrospector> allIntrospectors(Collection<AnnotationIntrospector> result) {\n        result.add(this);\n        return result;\n    }\n    \n    \n\n    @Override\n    public abstract Version version(); public boolean isAnnotationBundle(Annotation ann) {\n        return false;\n    }\n\n    \n    \n    \n    public ObjectIdInfo findObjectIdInfo(Annotated ann) {\n        return null;\n    }\n\n    \n    public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n        return objectIdInfo;\n    }\n\n    \n\n    \n    public PropertyName findRootName(AnnotatedClass ac) {\n        return null;\n    }\n\n    \n    public String[] findPropertiesToIgnore(Annotated ac, boolean forSerialization) {\n        return null;\n    }\n\n    \n    @Deprecated\n    public String[] findPropertiesToIgnore(Annotated ac) {\n        \n        return findPropertiesToIgnore(ac, true);\n    }\n    \n    \n    public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) { return null; }\n\n    \n    public Boolean isIgnorableType(AnnotatedClass ac) { return null; }\n\n    \n    public Object findFilterId(Annotated ann) { return null; }\n\n    \n    public Object findNamingStrategy(AnnotatedClass ac) { return null; }\n\n    \n    public String findClassDescription(AnnotatedClass ac) { return null; }\n\n    \n\n    \n    public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) {\n        return checker;\n    }\n    \n    \n    \n    \n    public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config, AnnotatedClass ac, JavaType baseType) {\n        return null;\n    }\n\n    \n    public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType baseType) {\n        return null;\n    }\n\n        \n    public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType containerType) {\n        return null;\n    }\n\n    \n    public List<NamedType> findSubtypes(Annotated a) { return null; }\n\n    \n    public String findTypeName(AnnotatedClass ac) { return null; }\n\n    \n    public Boolean isTypeId(AnnotatedMember member) { return null; }\n\n    \n\n    \n    public ReferenceProperty findReferenceType(AnnotatedMember member) { return null; }\n\n    \n    public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member) { return null; }\n\n    \n    public boolean hasIgnoreMarker(AnnotatedMember m) { return false; }\n\n    \n    public Object findInjectableValueId(AnnotatedMember m) { return null; }\n\n    \n    public Boolean hasRequiredMarker(AnnotatedMember m) { return null; }\n    \n    \n    public Class<?>[] findViews(Annotated a) { return null; }\n\n    \n    public JsonFormat.Value findFormat(Annotated memberOrClass) { return null; }\n\n    \n    public PropertyName findWrapperName(Annotated ann) { return null; }\n\n    \n    public String findPropertyDefaultValue(Annotated ann) { return null; }\n\n    \n    public String findPropertyDescription(Annotated ann) { return null; }\n\n    \n    public Integer findPropertyIndex(Annotated ann) { return null; }\n\n    \n    public String findImplicitPropertyName(AnnotatedMember member) { return null; }\n\n    \n    public JsonProperty.Access findPropertyAccess(Annotated ann) { return null; }\n\n    \n    public AnnotatedMethod resolveSetterConflict(MapperConfig<?> config, AnnotatedMethod setter1, AnnotatedMethod setter2) {\n        return null;\n    }\n\n    \n\n    \n    public Object findSerializer(Annotated am) {\n        return null;\n    }\n\n    \n    public Object findKeySerializer(Annotated am) {\n        return null;\n    }\n\n    \n    public Object findContentSerializer(Annotated am) {\n        return null;\n    }\n\n    \n    public Object findNullSerializer(Annotated am) {\n        return null;\n    }\n\n    \n    public JsonSerialize.Typing findSerializationTyping(Annotated a) {\n        return null;\n    }\n\n    \n    public Object findSerializationConverter(Annotated a) {\n        return null;\n    }\n\n    \n    public Object findSerializationContentConverter(AnnotatedMember a) {\n        return null;\n    }\n\n    \n    @Deprecated \n    public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) {\n        return defValue;\n    }\n\n    \n    @Deprecated \n    public JsonInclude.Include findSerializationInclusionForContent(Annotated a, JsonInclude.Include defValue) {\n        return defValue;\n    }\n\n    \n    public JsonInclude.Value findPropertyInclusion(Annotated a) {\n        return JsonInclude.Value.empty();\n    }\n\n    \n\n    \n    @Deprecated \n    public Class<?> findSerializationType(Annotated a) {\n        return null;\n    }\n\n    \n    @Deprecated \n    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) {\n        return null;\n    }\n\n    \n    @Deprecated \n    public Class<?> findSerializationContentType(Annotated am, JavaType baseType) {\n        return null;\n    }\n\n    \n    public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n        JavaType type = baseType;\n        final TypeFactory tf = config.getTypeFactory();\n        \n        \n        \n        \n        \n        \n\n        \n        \n        Class<?> serClass = findSerializationType(a);\n        if (serClass != null) {\n            if (type.hasRawClass(serClass)) {\n                \n                \n                type = type.withStaticTyping();\n            } else {\n                Class<?> currRaw = type.getRawClass();\n                try {\n                    \n                    \n                    if (serClass.isAssignableFrom(currRaw)) { \n                        type = tf.constructGeneralizedType(type, serClass);\n                    } else if (currRaw.isAssignableFrom(serClass)) { \n                        type = tf.constructSpecializedType(type, serClass);\n                    } else {\n                        throw new JsonMappingException(null,\n                                String.format(\"Can not refine serialization type %s into %s; types not related\",\n                                        type, serClass.getName()));\n                    }\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null,\n                            String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\",\n                                    type, serClass.getName(), a.getName(), iae.getMessage()),\n                                    iae);\n                }\n            }\n        }\n        \n\n        \n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            Class<?> keyClass = findSerializationKeyType(a, keyType);\n            if (keyClass != null) {\n                if (keyType.hasRawClass(keyClass)) {\n                    keyType = keyType.withStaticTyping();\n                } else {\n                    Class<?> currRaw = keyType.getRawClass();\n                    try {\n                        \n                        \n                        \n                        if (keyClass.isAssignableFrom(currRaw)) { \n                            keyType = tf.constructGeneralizedType(keyType, keyClass);\n                        } else if (currRaw.isAssignableFrom(keyClass)) { \n                            keyType = tf.constructSpecializedType(keyType, keyClass);\n                        } else {\n                            throw new JsonMappingException(null,\n                                    String.format(\"Can not refine serialization key type %s into %s; types not related\",\n                                            keyType, keyClass.getName()));\n                        }\n                    } catch (IllegalArgumentException iae) {\n                        throw new JsonMappingException(null,\n                                String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                        type, keyClass.getName(), a.getName(), iae.getMessage()),\n                                        iae);\n                    }\n                }\n                type = ((MapLikeType) type).withKeyType(keyType);\n            }\n        }\n\n        JavaType contentType = type.getContentType();\n        if (contentType != null) { \n            \n           Class<?> contentClass = findSerializationContentType(a, contentType);\n           if (contentClass != null) {\n               if (contentType.hasRawClass(contentClass)) {\n                   contentType = contentType.withStaticTyping();\n               } else {\n                   \n                   \n                   \n                   Class<?> currRaw = contentType.getRawClass();\n                   try {\n                       if (contentClass.isAssignableFrom(currRaw)) { \n                           contentType = tf.constructGeneralizedType(contentType, contentClass);\n                       } else if (currRaw.isAssignableFrom(contentClass)) { \n                           contentType = tf.constructSpecializedType(contentType, contentClass);\n                       } else {\n                           throw new JsonMappingException(null,\n                                   String.format(\"Can not refine serialization content type %s into %s; types not related\",\n                                           contentType, contentClass.getName()));\n                       }\n                   } catch (IllegalArgumentException iae) { \n                       throw new JsonMappingException(null,\n                               String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                       type, contentClass.getName(), a.getName(), iae.getMessage()),\n                                       iae);\n                   }\n               }\n               type = type.withContentType(contentType);\n           }\n        }\n        return type;\n    }\n\n    \n\n    \n    public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n        return null;\n    }\n\n    \n    public Boolean findSerializationSortAlphabetically(Annotated ann) {\n        return null;\n    }\n\n    \n    public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac, List<BeanPropertyWriter> properties) { }\n    \n    \n\n    \n    public PropertyName findNameForSerialization(Annotated a) {\n        \n        return null;\n    }\n\n    \n    public boolean hasAsValueAnnotation(AnnotatedMethod am) {\n        return false;\n    }\n\n    \n    \n    public String findEnumValue(Enum<?> value) {\n        return value.name();\n    }\n\n    \n    public String[] findEnumValues(Class<?> enumType, Enum<?>[] enumValues, String[] names) {\n        for (int i = 0, len = enumValues.length; i < len; ++i) {\n            \n            \n            if (names[i] == null) {\n                names[i] = findEnumValue(enumValues[i]);\n            }\n        }\n        return names;\n    }\n\n    \n\n    \n    public Object findDeserializer(Annotated am) {\n        return null;\n    }\n\n    \n    public Object findKeyDeserializer(Annotated am) {\n        return null;\n    }\n\n    \n    public Object findContentDeserializer(Annotated am) {\n        return null;\n    }\n\n    \n    public Object findDeserializationConverter(Annotated a) {\n        return null;\n    }\n\n    \n    public Object findDeserializationContentConverter(AnnotatedMember a) {\n        return null;\n    }\n\n    \n\n    \n    public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n        JavaType type = baseType;\n        final TypeFactory tf = config.getTypeFactory();\n\n        \n        \n        \n        \n        \n\n        \n        \n        Class<?> valueClass = findDeserializationType(a, type);\n        if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n            try {\n                type = tf.constructSpecializedType(type, valueClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null,\n                        String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\",\n                                type, valueClass.getName(), a.getName(), iae.getMessage()),\n                                iae);\n            }\n        }\n        \n\n        \n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            Class<?> keyClass = findDeserializationKeyType(a, keyType);\n            if (keyClass != null) {\n                try {\n                    keyType = tf.constructSpecializedType(keyType, keyClass);\n                    type = ((MapLikeType) type).withKeyType(keyType);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null,\n                            String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                    type, keyClass.getName(), a.getName(), iae.getMessage()),\n                                    iae);\n                }\n            }\n        }\n        JavaType contentType = type.getContentType();\n        if (contentType != null) { \n            \n           Class<?> contentClass = findDeserializationContentType(a, contentType);\n           if (contentClass != null) {\n               try {\n                   contentType = tf.constructSpecializedType(contentType, contentClass);\n                   type = type.withContentType(contentType);\n               } catch (IllegalArgumentException iae) {\n                   throw new JsonMappingException(null,\n                           String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                   type, contentClass.getName(), a.getName(), iae.getMessage()),\n                                   iae);\n               }\n           }\n        }\n        return type;\n    }\n    \n    \n    @Deprecated\n    public Class<?> findDeserializationType(Annotated am, JavaType baseType) {\n        return null;\n    }\n    \n    \n    @Deprecated\n    public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) {\n        return null;\n    }\n\n    \n    @Deprecated\n    public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType) {\n        return null;\n    }\n\n    \n\n    \n    public Object findValueInstantiator(AnnotatedClass ac) {\n        return null;\n    }\n\n    \n    public Class<?> findPOJOBuilder(AnnotatedClass ac) {\n        return null;\n    }\n\n    \n    public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac) {\n        return null;\n    }\n    \n    \n\n    \n    public PropertyName findNameForDeserialization(Annotated a) {\n        \n        return null;\n    }\n    \n    \n    public boolean hasAnySetterAnnotation(AnnotatedMethod am) {\n        return false;\n    }\n\n    \n    public boolean hasAnyGetterAnnotation(AnnotatedMethod am) {\n        return false;\n    }\n    \n    \n    public boolean hasCreatorAnnotation(Annotated a) {\n        return false;\n    }\n\n    \n    public JsonCreator.Mode findCreatorBinding(Annotated a) {\n        return null;\n    }\n    \n    \n\n    \n    protected <A extends Annotation> A _findAnnotation(Annotated annotated, Class<A> annoClass) {\n        return annotated.getAnnotation(annoClass);\n    }\n\n    \n    protected boolean _hasAnnotation(Annotated annotated, Class<? extends Annotation> annoClass) {\n        return annotated.hasAnnotation(annoClass);\n    }\n\n    \n    protected boolean _hasOneOf(Annotated annotated, Class<? extends Annotation>[] annoClasses) {\n        return annotated.hasOneOf(annoClasses);\n    }\n}\n",
      "buggy_signatures": [
        "public abstract class AnnotationIntrospector implements Versioned, java.io.Serializable { public static class ReferenceProperty { public enum Type { MANAGED_REFERENCE ,BACK_REFERENCE ; } private final Type _type; private final String _name; public ReferenceProperty(Type t, String n)",
        "public static ReferenceProperty managed(String name)",
        "public static ReferenceProperty back(String name)",
        "public Type getType()",
        "public String getName()",
        "public boolean isManagedReference()",
        "public boolean isBackReference()",
        "public static AnnotationIntrospector nopInstance()",
        "public static AnnotationIntrospector pair(AnnotationIntrospector a1, AnnotationIntrospector a2)",
        "public Collection<AnnotationIntrospector> allIntrospectors()",
        "public Collection<AnnotationIntrospector> allIntrospectors(Collection<AnnotationIntrospector> result)",
        "public abstract Version version(); public boolean isAnnotationBundle(Annotation ann)",
        "public ObjectIdInfo findObjectIdInfo(Annotated ann)",
        "public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo)",
        "public PropertyName findRootName(AnnotatedClass ac)",
        "public String[] findPropertiesToIgnore(Annotated ac, boolean forSerialization)",
        "public String[] findPropertiesToIgnore(Annotated ac)",
        "public Boolean findIgnoreUnknownProperties(AnnotatedClass ac)",
        "public Boolean isIgnorableType(AnnotatedClass ac)",
        "public Object findFilterId(Annotated ann)",
        "public Object findNamingStrategy(AnnotatedClass ac)",
        "public String findClassDescription(AnnotatedClass ac)",
        "public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker)",
        "public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config, AnnotatedClass ac, JavaType baseType)",
        "public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType baseType)",
        "public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType containerType)",
        "public List<NamedType> findSubtypes(Annotated a)",
        "public String findTypeName(AnnotatedClass ac)",
        "public Boolean isTypeId(AnnotatedMember member)",
        "public ReferenceProperty findReferenceType(AnnotatedMember member)",
        "public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member)",
        "public boolean hasIgnoreMarker(AnnotatedMember m)",
        "public Object findInjectableValueId(AnnotatedMember m)",
        "public Boolean hasRequiredMarker(AnnotatedMember m)",
        "public Class<?>[] findViews(Annotated a)",
        "public JsonFormat.Value findFormat(Annotated memberOrClass)",
        "public PropertyName findWrapperName(Annotated ann)",
        "public String findPropertyDefaultValue(Annotated ann)",
        "public String findPropertyDescription(Annotated ann)",
        "public Integer findPropertyIndex(Annotated ann)",
        "public String findImplicitPropertyName(AnnotatedMember member)",
        "public JsonProperty.Access findPropertyAccess(Annotated ann)",
        "public AnnotatedMethod resolveSetterConflict(MapperConfig<?> config, AnnotatedMethod setter1, AnnotatedMethod setter2)",
        "public Object findSerializer(Annotated am)",
        "public Object findKeySerializer(Annotated am)",
        "public Object findContentSerializer(Annotated am)",
        "public Object findNullSerializer(Annotated am)",
        "public JsonSerialize.Typing findSerializationTyping(Annotated a)",
        "public Object findSerializationConverter(Annotated a)",
        "public Object findSerializationContentConverter(AnnotatedMember a)",
        "public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue)",
        "public JsonInclude.Include findSerializationInclusionForContent(Annotated a, JsonInclude.Include defValue)",
        "public JsonInclude.Value findPropertyInclusion(Annotated a)",
        "public Class<?> findSerializationType(Annotated a)",
        "public Class<?> findSerializationKeyType(Annotated am, JavaType baseType)",
        "public Class<?> findSerializationContentType(Annotated am, JavaType baseType)",
        "public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException",
        "public String[] findSerializationPropertyOrder(AnnotatedClass ac)",
        "public Boolean findSerializationSortAlphabetically(Annotated ann)",
        "public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac, List<BeanPropertyWriter> properties)",
        "public PropertyName findNameForSerialization(Annotated a)",
        "public boolean hasAsValueAnnotation(AnnotatedMethod am)",
        "public String findEnumValue(Enum<?> value)",
        "public String[] findEnumValues(Class<?> enumType, Enum<?>[] enumValues, String[] names)",
        "public Object findDeserializer(Annotated am)",
        "public Object findKeyDeserializer(Annotated am)",
        "public Object findContentDeserializer(Annotated am)",
        "public Object findDeserializationConverter(Annotated a)",
        "public Object findDeserializationContentConverter(AnnotatedMember a)",
        "public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException",
        "public Class<?> findDeserializationType(Annotated am, JavaType baseType)",
        "public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType)",
        "public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType)",
        "public Object findValueInstantiator(AnnotatedClass ac)",
        "public Class<?> findPOJOBuilder(AnnotatedClass ac)",
        "public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac)",
        "public PropertyName findNameForDeserialization(Annotated a)",
        "public boolean hasAnySetterAnnotation(AnnotatedMethod am)",
        "public boolean hasAnyGetterAnnotation(AnnotatedMethod am)",
        "public boolean hasCreatorAnnotation(Annotated a)",
        "public JsonCreator.Mode findCreatorBinding(Annotated a)",
        "protected <A extends Annotation> A _findAnnotation(Annotated annotated, Class<A> annoClass)",
        "protected boolean _hasAnnotation(Annotated annotated, Class<? extends Annotation> annoClass)",
        "protected boolean _hasOneOf(Annotated annotated, Class<? extends Annotation>[] annoClasses)"
      ],
      "fixed_signatures": [
        "public abstract class AnnotationIntrospector implements Versioned, java.io.Serializable { public static class ReferenceProperty { public enum Type { MANAGED_REFERENCE ,BACK_REFERENCE ; } private final Type _type; private final String _name; public ReferenceProperty(Type t, String n)",
        "public static ReferenceProperty managed(String name)",
        "public static ReferenceProperty back(String name)",
        "public Type getType()",
        "public String getName()",
        "public boolean isManagedReference()",
        "public boolean isBackReference()",
        "public static AnnotationIntrospector nopInstance()",
        "public static AnnotationIntrospector pair(AnnotationIntrospector a1, AnnotationIntrospector a2)",
        "public Collection<AnnotationIntrospector> allIntrospectors()",
        "public Collection<AnnotationIntrospector> allIntrospectors(Collection<AnnotationIntrospector> result)",
        "public abstract Version version(); public boolean isAnnotationBundle(Annotation ann)",
        "public ObjectIdInfo findObjectIdInfo(Annotated ann)",
        "public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo)",
        "public PropertyName findRootName(AnnotatedClass ac)",
        "public String[] findPropertiesToIgnore(Annotated ac, boolean forSerialization)",
        "public String[] findPropertiesToIgnore(Annotated ac)",
        "public Boolean findIgnoreUnknownProperties(AnnotatedClass ac)",
        "public Boolean isIgnorableType(AnnotatedClass ac)",
        "public Object findFilterId(Annotated ann)",
        "public Object findNamingStrategy(AnnotatedClass ac)",
        "public String findClassDescription(AnnotatedClass ac)",
        "public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker)",
        "public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config, AnnotatedClass ac, JavaType baseType)",
        "public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType baseType)",
        "public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType containerType)",
        "public List<NamedType> findSubtypes(Annotated a)",
        "public String findTypeName(AnnotatedClass ac)",
        "public Boolean isTypeId(AnnotatedMember member)",
        "public ReferenceProperty findReferenceType(AnnotatedMember member)",
        "public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member)",
        "public boolean hasIgnoreMarker(AnnotatedMember m)",
        "public Object findInjectableValueId(AnnotatedMember m)",
        "public Boolean hasRequiredMarker(AnnotatedMember m)",
        "public Class<?>[] findViews(Annotated a)",
        "public JsonFormat.Value findFormat(Annotated memberOrClass)",
        "public PropertyName findWrapperName(Annotated ann)",
        "public String findPropertyDefaultValue(Annotated ann)",
        "public String findPropertyDescription(Annotated ann)",
        "public Integer findPropertyIndex(Annotated ann)",
        "public String findImplicitPropertyName(AnnotatedMember member)",
        "public JsonProperty.Access findPropertyAccess(Annotated ann)",
        "public AnnotatedMethod resolveSetterConflict(MapperConfig<?> config, AnnotatedMethod setter1, AnnotatedMethod setter2)",
        "public Object findSerializer(Annotated am)",
        "public Object findKeySerializer(Annotated am)",
        "public Object findContentSerializer(Annotated am)",
        "public Object findNullSerializer(Annotated am)",
        "public JsonSerialize.Typing findSerializationTyping(Annotated a)",
        "public Object findSerializationConverter(Annotated a)",
        "public Object findSerializationContentConverter(AnnotatedMember a)",
        "public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue)",
        "public JsonInclude.Include findSerializationInclusionForContent(Annotated a, JsonInclude.Include defValue)",
        "public JsonInclude.Value findPropertyInclusion(Annotated a)",
        "public Class<?> findSerializationType(Annotated a)",
        "public Class<?> findSerializationKeyType(Annotated am, JavaType baseType)",
        "public Class<?> findSerializationContentType(Annotated am, JavaType baseType)",
        "public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException",
        "public String[] findSerializationPropertyOrder(AnnotatedClass ac)",
        "public Boolean findSerializationSortAlphabetically(Annotated ann)",
        "public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac, List<BeanPropertyWriter> properties)",
        "public PropertyName findNameForSerialization(Annotated a)",
        "public boolean hasAsValueAnnotation(AnnotatedMethod am)",
        "public String findEnumValue(Enum<?> value)",
        "public String[] findEnumValues(Class<?> enumType, Enum<?>[] enumValues, String[] names)",
        "public Object findDeserializer(Annotated am)",
        "public Object findKeyDeserializer(Annotated am)",
        "public Object findContentDeserializer(Annotated am)",
        "public Object findDeserializationConverter(Annotated a)",
        "public Object findDeserializationContentConverter(AnnotatedMember a)",
        "public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException",
        "public Class<?> findDeserializationType(Annotated am, JavaType baseType)",
        "public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType)",
        "public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType)",
        "public Object findValueInstantiator(AnnotatedClass ac)",
        "public Class<?> findPOJOBuilder(AnnotatedClass ac)",
        "public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac)",
        "public PropertyName findNameForDeserialization(Annotated a)",
        "public boolean hasAnySetterAnnotation(AnnotatedMethod am)",
        "public boolean hasAnyGetterAnnotation(AnnotatedMethod am)",
        "public boolean hasCreatorAnnotation(Annotated a)",
        "public JsonCreator.Mode findCreatorBinding(Annotated a)",
        "protected <A extends Annotation> A _findAnnotation(Annotated annotated, Class<A> annoClass)",
        "protected boolean _hasAnnotation(Annotated annotated, Class<? extends Annotation> annoClass)",
        "protected boolean _hasOneOf(Annotated annotated, Class<? extends Annotation>[] annoClasses)"
      ],
      "methods": [
        {
          "buggy_method": "  public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n  JavaType type = baseType;\n  final TypeFactory tf = config.getTypeFactory();\n  \n  \n  \n  \n  \n  \n\n  \n  \n  Class<?> serClass = findSerializationType(a);\n  if (serClass != null) {\n  if (type.hasRawClass(serClass)) {\n  \n  \n  type = type.withStaticTyping();\n  } else {\n  try {\n  \n  \n  type = tf.constructGeneralizedType(type, serClass);\n  } catch (IllegalArgumentException iae) {\n  throw new JsonMappingException(null,\n  String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\",\n  type, serClass.getName(), a.getName(), iae.getMessage()),\n  iae);\n  }\n  }\n  }\n  \n\n  \n  if (type.isMapLikeType()) {\n  JavaType keyType = type.getKeyType();\n  Class<?> keyClass = findSerializationKeyType(a, keyType);\n  if (keyClass != null) {\n  if (keyType.hasRawClass(keyClass)) {\n  keyType = keyType.withStaticTyping();\n  } else {\n  Class<?> currRaw = keyType.getRawClass();\n  try {\n  \n  \n  \n  if (keyClass.isAssignableFrom(currRaw)) { \n  keyType = tf.constructGeneralizedType(keyType, keyClass);\n  } else if (currRaw.isAssignableFrom(keyClass)) { \n  keyType = tf.constructSpecializedType(keyType, keyClass);\n  } else {\n  throw new JsonMappingException(null,\n  String.format(\"Can not refine serialization key type %s into %s; types not related\",\n  keyType, keyClass.getName()));\n  }\n  } catch (IllegalArgumentException iae) {\n  throw new JsonMappingException(null,\n  String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n  type, keyClass.getName(), a.getName(), iae.getMessage()),\n  iae);\n  }\n  }\n  type = ((MapLikeType) type).withKeyType(keyType);\n  }\n  }\n\n  JavaType contentType = type.getContentType();\n  if (contentType != null) { \n  \n  Class<?> contentClass = findSerializationContentType(a, contentType);\n  if (contentClass != null) {\n  if (contentType.hasRawClass(contentClass)) {\n  contentType = contentType.withStaticTyping();\n  } else {\n  \n  \n  \n  Class<?> currRaw = contentType.getRawClass();\n  try {\n  if (contentClass.isAssignableFrom(currRaw)) { \n  contentType = tf.constructGeneralizedType(contentType, contentClass);\n  } else if (currRaw.isAssignableFrom(contentClass)) { \n  contentType = tf.constructSpecializedType(contentType, contentClass);\n  } else {\n  throw new JsonMappingException(null,\n  String.format(\"Can not refine serialization content type %s into %s; types not related\",\n  contentType, contentClass.getName()));\n  }\n  } catch (IllegalArgumentException iae) { \n  throw new JsonMappingException(null,\n  String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n  type, contentClass.getName(), a.getName(), iae.getMessage()),\n  iae);\n  }\n  }\n  type = type.withContentType(contentType);\n  }\n  }\n  return type;\n  }",
          "fixed_method": "  public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n  JavaType type = baseType;\n  final TypeFactory tf = config.getTypeFactory();\n  \n  \n  \n  \n  \n  \n\n  \n  \n  Class<?> serClass = findSerializationType(a);\n  if (serClass != null) {\n  if (type.hasRawClass(serClass)) {\n  \n  \n  type = type.withStaticTyping();\n  } else {\n  Class<?> currRaw = type.getRawClass();\n  try {\n  \n  \n  if (serClass.isAssignableFrom(currRaw)) { \n  type = tf.constructGeneralizedType(type, serClass);\n  } else if (currRaw.isAssignableFrom(serClass)) { \n  type = tf.constructSpecializedType(type, serClass);\n  } else {\n  throw new JsonMappingException(null,\n  String.format(\"Can not refine serialization type %s into %s; types not related\",\n  type, serClass.getName()));\n  }\n  } catch (IllegalArgumentException iae) {\n  throw new JsonMappingException(null,\n  String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\",\n  type, serClass.getName(), a.getName(), iae.getMessage()),\n  iae);\n  }\n  }\n  }\n  \n\n  \n  if (type.isMapLikeType()) {\n  JavaType keyType = type.getKeyType();\n  Class<?> keyClass = findSerializationKeyType(a, keyType);\n  if (keyClass != null) {\n  if (keyType.hasRawClass(keyClass)) {\n  keyType = keyType.withStaticTyping();\n  } else {\n  Class<?> currRaw = keyType.getRawClass();\n  try {\n  \n  \n  \n  if (keyClass.isAssignableFrom(currRaw)) { \n  keyType = tf.constructGeneralizedType(keyType, keyClass);\n  } else if (currRaw.isAssignableFrom(keyClass)) { \n  keyType = tf.constructSpecializedType(keyType, keyClass);\n  } else {\n  throw new JsonMappingException(null,\n  String.format(\"Can not refine serialization key type %s into %s; types not related\",\n  keyType, keyClass.getName()));\n  }\n  } catch (IllegalArgumentException iae) {\n  throw new JsonMappingException(null,\n  String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n  type, keyClass.getName(), a.getName(), iae.getMessage()),\n  iae);\n  }\n  }\n  type = ((MapLikeType) type).withKeyType(keyType);\n  }\n  }\n\n  JavaType contentType = type.getContentType();\n  if (contentType != null) { \n  \n  Class<?> contentClass = findSerializationContentType(a, contentType);\n  if (contentClass != null) {\n  if (contentType.hasRawClass(contentClass)) {\n  contentType = contentType.withStaticTyping();\n  } else {\n  \n  \n  \n  Class<?> currRaw = contentType.getRawClass();\n  try {\n  if (contentClass.isAssignableFrom(currRaw)) { \n  contentType = tf.constructGeneralizedType(contentType, contentClass);\n  } else if (currRaw.isAssignableFrom(contentClass)) { \n  contentType = tf.constructSpecializedType(contentType, contentClass);\n  } else {\n  throw new JsonMappingException(null,\n  String.format(\"Can not refine serialization content type %s into %s; types not related\",\n  contentType, contentClass.getName()));\n  }\n  } catch (IllegalArgumentException iae) { \n  throw new JsonMappingException(null,\n  String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n  type, contentClass.getName(), a.getName(), iae.getMessage()),\n  iae);\n  }\n  }\n  type = type.withContentType(contentType);\n  }\n  }\n  return type;\n  }",
          "diff": [
            "@@ -813,10 +813,19 @@",
            "                 //    static typing this way\n",
            "                 type = type.withStaticTyping();\n",
            "             } else {\n",
            "+                Class<?> currRaw = type.getRawClass();\n",
            "                 try {\n",
            "                     // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n",
            "                     //   may be needed here too in future?\n",
            "+                    if (serClass.isAssignableFrom(currRaw)) { // common case\n",
            "                         type = tf.constructGeneralizedType(type, serClass);\n",
            "+                    } else if (currRaw.isAssignableFrom(serClass)) { // specialization, ok as well\n",
            "+                        type = tf.constructSpecializedType(type, serClass);\n",
            "+                    } else {\n",
            "+                        throw new JsonMappingException(null,\n",
            "+                                String.format(\"Can not refine serialization type %s into %s; types not related\",\n",
            "+                                        type, serClass.getName()));\n",
            "+                    }\n",
            "                 } catch (IllegalArgumentException iae) {\n",
            "                     throw new JsonMappingException(null,\n",
            "                             String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\",\n"
          ],
          "changed_lines": 9
        }
      ]
    }
  ]
}
