{
  "bug_id": "49",
  "failed_tests": {
    "org.apache.commons.math.linear.SparseRealVectorTest": [
      {
        "methodName": "testConcurrentModification",
        "error": "org.apache.commons.math.MathRuntimeException$6",
        "message": "map has been modified while iterating",
        "fail_line": "        w = u.ebeMultiply(v1);",
        "test_source": "  public void testConcurrentModification() {\n  final RealVector u = new OpenMapRealVector(3, 1e-6);\n  u.setEntry(0, 1);\n  u.setEntry(1, 0);\n  u.setEntry(2, 2);\n\n  final RealVector v1 = new OpenMapRealVector(3, 1e-6);\n  final double[] v2 = new double[3];\n  v1.setEntry(0, 0);\n  v2[0] = 0;\n  v1.setEntry(1, 3);\n  v2[1] = 3;\n  v1.setEntry(2, 0);\n  v2[2] = 0;\n\n  RealVector w;\n\n  w = u.ebeMultiply(v1);\n  w = u.ebeMultiply(v2);\n\n  w = u.ebeDivide(v1);\n  w = u.ebeDivide(v2);\n  }",
        "stack": [
          "MathRuntimeException.createConcurrentModificationException line 373, OpenIntToDoubleHashMap$Iterator.advance line 564, OpenMapRealVector.ebeMultiply line 372, OpenMapRealVector.ebeMultiply line 33, SparseRealVectorTest.testConcurrentModification line 1021"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/linear/OpenMapRealVector.java",
      "buggy_full_code": "\npackage org.apache.commons.math.linear;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math.exception.MathArithmeticException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.util.OpenIntToDoubleHashMap;\nimport org.apache.commons.math.util.OpenIntToDoubleHashMap.Iterator;\nimport org.apache.commons.math.util.FastMath;\n\n\npublic class OpenMapRealVector extends AbstractRealVector implements SparseRealVector, Serializable { public static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12; private static final long serialVersionUID = 8772222695580707260L; private final OpenIntToDoubleHashMap entries; private final int virtualSize; private final double epsilon; public OpenMapRealVector() {\n        this(0, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(int dimension) {\n        this(dimension, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(int dimension, double epsilon) {\n        virtualSize = dimension;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n    }\n\n    \n    protected OpenMapRealVector(OpenMapRealVector v, int resize) {\n        virtualSize = v.getDimension() + resize;\n        entries = new OpenIntToDoubleHashMap(v.entries);\n        epsilon = v.epsilon;\n    }\n\n    \n    public OpenMapRealVector(int dimension, int expectedSize) {\n        this(dimension, expectedSize, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(int dimension, int expectedSize, double epsilon) {\n        virtualSize = dimension;\n        entries = new OpenIntToDoubleHashMap(expectedSize, 0.0);\n        this.epsilon = epsilon;\n    }\n\n    \n    public OpenMapRealVector(double[] values) {\n        this(values, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(double[] values, double epsilon) {\n        virtualSize = values.length;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n        for (int key = 0; key < values.length; key++) {\n            double value = values[key];\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    \n    public OpenMapRealVector(Double[] values) {\n        this(values, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(Double[] values, double epsilon) {\n        virtualSize = values.length;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n        for (int key = 0; key < values.length; key++) {\n            double value = values[key].doubleValue();\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    \n    public OpenMapRealVector(OpenMapRealVector v) {\n        virtualSize = v.getDimension();\n        entries = new OpenIntToDoubleHashMap(v.getEntries());\n        epsilon = v.epsilon;\n    }\n\n    \n    public OpenMapRealVector(RealVector v) {\n        virtualSize = v.getDimension();\n        entries = new OpenIntToDoubleHashMap(0.0);\n        epsilon = DEFAULT_ZERO_TOLERANCE;\n        for (int key = 0; key < virtualSize; key++) {\n            double value = v.getEntry(key);\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    \n    private OpenIntToDoubleHashMap getEntries() {\n        return entries;\n    }\n\n    \n    protected boolean isDefaultValue(double value) {\n        return FastMath.abs(value) < epsilon;\n    }\n\n    \n    @Override\n        public RealVector add(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return add((OpenMapRealVector) v);\n        } else {\n            return super.add(v);\n        }\n    }\n\n    \n    public OpenMapRealVector add(OpenMapRealVector v) {\n        checkVectorDimensions(v.getDimension());\n        boolean copyThis = entries.size() > v.entries.size();\n        OpenMapRealVector res = copyThis ? this.copy() : v.copy();\n        Iterator iter = copyThis ? v.entries.iterator() : entries.iterator();\n        OpenIntToDoubleHashMap randomAccess = copyThis ? entries : v.entries;\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (randomAccess.containsKey(key)) {\n                res.setEntry(key, randomAccess.get(key) + iter.value());\n            } else {\n                res.setEntry(key, iter.value());\n            }\n        }\n        return res;\n    }\n\n    \n    public OpenMapRealVector append(OpenMapRealVector v) {\n        OpenMapRealVector res = new OpenMapRealVector(this, v.getDimension());\n        Iterator iter = v.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key() + virtualSize, iter.value());\n        }\n        return res;\n    }\n\n    \n    public OpenMapRealVector append(RealVector v) {\n        if (v instanceof OpenMapRealVector) {\n            return append((OpenMapRealVector) v);\n        }\n        return append(v.getData());\n    }\n\n    \n    public OpenMapRealVector append(double d) {\n        OpenMapRealVector res = new OpenMapRealVector(this, 1);\n        res.setEntry(virtualSize, d);\n        return res;\n    }\n\n    \n    public OpenMapRealVector append(double[] a) {\n        OpenMapRealVector res = new OpenMapRealVector(this, a.length);\n        for (int i = 0; i < a.length; i++) {\n            res.setEntry(i + virtualSize, a[i]);\n        }\n        return res;\n    }\n\n    \n    @Override\n    public OpenMapRealVector copy() {\n        return new OpenMapRealVector(this);\n    }\n\n    \n    public double dotProduct(OpenMapRealVector v) {\n        checkVectorDimensions(v.getDimension());\n        boolean thisIsSmaller  = entries.size() < v.entries.size();\n        Iterator iter = thisIsSmaller  ? entries.iterator() : v.entries.iterator();\n        OpenIntToDoubleHashMap larger = thisIsSmaller  ? v.entries : entries;\n        double d = 0;\n        while(iter.hasNext()) {\n            iter.advance();\n            d += iter.value() * larger.get(iter.key());\n        }\n        return d;\n    }\n\n    \n    @Override\n    public double dotProduct(RealVector v) {\n        if(v instanceof OpenMapRealVector) {\n            return dotProduct((OpenMapRealVector)v);\n        } else {\n            return super.dotProduct(v);\n        }\n    }\n\n    \n    public OpenMapRealVector ebeDivide(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n        }\n        return res;\n    }\n\n    \n    @Override\n    public OpenMapRealVector ebeDivide(double[] v) {\n        checkVectorDimensions(v.length);\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() / v[iter.key()]);\n        }\n        return res;\n    }\n\n    \n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        return res;\n    }\n\n    \n    @Override\n    public OpenMapRealVector ebeMultiply(double[] v) {\n        checkVectorDimensions(v.length);\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v[iter.key()]);\n        }\n        return res;\n    }\n\n    \n    public OpenMapRealVector getSubVector(int index, int n) {\n        checkIndex(index);\n        checkIndex(index + n - 1);\n        OpenMapRealVector res = new OpenMapRealVector(n);\n        int end = index + n;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (key >= index && key < end) {\n                res.setEntry(key - index, iter.value());\n            }\n        }\n        return res;\n    }\n\n    \n    @Override\n    public double[] getData() {\n        double[] res = new double[virtualSize];\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res[iter.key()] = iter.value();\n        }\n        return res;\n    }\n\n    \n    public int getDimension() {\n        return virtualSize;\n    }\n\n    \n    public double getDistance(OpenMapRealVector v) {\n        Iterator iter = entries.iterator();\n        double res = 0;\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            double delta;\n            delta = iter.value() - v.getEntry(key);\n            res += delta * delta;\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                final double value = iter.value();\n                res += value * value;\n            }\n        }\n        return FastMath.sqrt(res);\n    }\n\n    \n    @Override\n    public double getDistance(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getDistance((OpenMapRealVector) v);\n        }\n        return getDistance(v.getData());\n    }\n\n    \n    @Override\n    public double getDistance(double[] v) {\n        checkVectorDimensions(v.length);\n        double res = 0;\n        for (int i = 0; i < v.length; i++) {\n            double delta = entries.get(i) - v[i];\n            res += delta * delta;\n        }\n        return FastMath.sqrt(res);\n    }\n\n    \n    public double getEntry(int index) {\n        checkIndex(index);\n        return entries.get(index);\n    }\n\n    \n    public double getL1Distance(OpenMapRealVector v) {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double delta = FastMath.abs(iter.value() - v.getEntry(iter.key()));\n            max += delta;\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                double delta = FastMath.abs(iter.value());\n                max +=  FastMath.abs(delta);\n            }\n        }\n        return max;\n    }\n\n    \n    @Override\n    public double getL1Distance(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getL1Distance((OpenMapRealVector) v);\n        }\n        return getL1Distance(v.getData());\n    }\n\n    \n    @Override\n    public double getL1Distance(double[] v) {\n        checkVectorDimensions(v.length);\n        double max = 0;\n        for (int i = 0; i < v.length; i++) {\n            double delta = FastMath.abs(getEntry(i) - v[i]);\n            max += delta;\n        }\n        return max;\n    }\n\n    \n    private double getLInfDistance(OpenMapRealVector v) {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double delta = FastMath.abs(iter.value() - v.getEntry(iter.key()));\n            if (delta > max) {\n                max = delta;\n            }\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                if (iter.value() > max) {\n                    max = iter.value();\n                }\n            }\n        }\n        return max;\n    }\n\n    \n    @Override\n    public double getLInfDistance(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getLInfDistance((OpenMapRealVector) v);\n        }\n        return getLInfDistance(v.getData());\n    }\n\n    \n    @Override\n    public double getLInfDistance(double[] v) {\n        checkVectorDimensions(v.length);\n        double max = 0;\n        for (int i = 0; i < v.length; i++) {\n            double delta = FastMath.abs(getEntry(i) - v[i]);\n            if (delta > max) {\n                max = delta;\n            }\n        }\n        return max;\n    }\n\n    \n    public boolean isInfinite() {\n        boolean infiniteFound = false;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            final double value = iter.value();\n            if (Double.isNaN(value)) {\n                return false;\n            }\n            if (Double.isInfinite(value)) {\n                infiniteFound = true;\n            }\n        }\n        return infiniteFound;\n    }\n\n    \n    public boolean isNaN() {\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            if (Double.isNaN(iter.value())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    @Override\n    public OpenMapRealVector mapAdd(double d) {\n        return copy().mapAddToSelf(d);\n    }\n\n    \n    @Override\n    public OpenMapRealVector mapAddToSelf(double d) {\n        for (int i = 0; i < virtualSize; i++) {\n            setEntry(i, getEntry(i) + d);\n        }\n        return this;\n    }\n\n     \n    @Override\n    public RealMatrix outerProduct(double[] v) {\n        final int n = v.length;\n        RealMatrix res = new OpenMapRealMatrix(virtualSize, n);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int row = iter.key();\n            double value = iter.value();\n            for (int col = 0; col < n; col++) {\n                res.setEntry(row, col, value * v[col]);\n            }\n        }\n        return res;\n    }\n\n    \n    public RealVector projection(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        return v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n    }\n\n    \n    @Override\n    public OpenMapRealVector projection(double[] v) {\n        checkVectorDimensions(v.length);\n        return (OpenMapRealVector) projection(new OpenMapRealVector(v));\n    }\n\n    \n    public void setEntry(int index, double value) {\n        checkIndex(index);\n        if (!isDefaultValue(value)) {\n            entries.put(index, value);\n        } else if (entries.containsKey(index)) {\n            entries.remove(index);\n        }\n    }\n\n    \n    @Override\n    public void setSubVector(int index, RealVector v) {\n        checkIndex(index);\n        checkIndex(index + v.getDimension() - 1);\n        setSubVector(index, v.getData());\n    }\n\n    \n    @Override\n    public void setSubVector(int index, double[] v) {\n        checkIndex(index);\n        checkIndex(index + v.length - 1);\n        for (int i = 0; i < v.length; i++) {\n            setEntry(i + index, v[i]);\n        }\n    }\n\n    \n    @Override\n    public void set(double value) {\n        for (int i = 0; i < virtualSize; i++) {\n            setEntry(i, value);\n        }\n    }\n\n    \n    public OpenMapRealVector subtract(OpenMapRealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = copy();\n        Iterator iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (entries.containsKey(key)) {\n                res.setEntry(key, entries.get(key) - iter.value());\n            } else {\n                res.setEntry(key, -iter.value());\n            }\n        }\n        return res;\n    }\n\n    \n    @Override\n    public OpenMapRealVector subtract(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return subtract((OpenMapRealVector) v);\n        }\n        return subtract(v.getData());\n    }\n\n    \n    @Override\n    public OpenMapRealVector subtract(double[] v) {\n        checkVectorDimensions(v.length);\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        for (int i = 0; i < v.length; i++) {\n            if (entries.containsKey(i)) {\n                res.setEntry(i, entries.get(i) - v[i]);\n            } else {\n                res.setEntry(i, -v[i]);\n            }\n        }\n        return res;\n    }\n\n\n    \n    @Override\n    public OpenMapRealVector unitVector() {\n        OpenMapRealVector res = copy();\n        res.unitize();\n        return res;\n    }\n\n    \n    @Override\n    public void unitize() {\n        double norm = getNorm();\n        if (isDefaultValue(norm)) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            entries.put(iter.key(), iter.value() / norm);\n        }\n    }\n\n    \n    @Override\n    public double[] toArray() {\n        return getData();\n    }\n\n    \n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        long temp;\n        temp = Double.doubleToLongBits(epsilon);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        result = prime * result + virtualSize;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            temp = Double.doubleToLongBits(iter.value());\n            result = prime * result + (int) (temp ^ (temp >>32));\n        }\n        return result;\n    }\n\n    \n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof OpenMapRealVector)) {\n            return false;\n        }\n        OpenMapRealVector other = (OpenMapRealVector) obj;\n        if (virtualSize != other.virtualSize) {\n            return false;\n        }\n        if (Double.doubleToLongBits(epsilon) !=\n            Double.doubleToLongBits(other.epsilon)) {\n            return false;\n        }\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double test = other.getEntry(iter.key());\n            if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {\n                return false;\n            }\n        }\n        iter = other.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double test = iter.value();\n            if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public double getSparsity() {\n        return (double)entries.size()/(double)getDimension();\n    }\n\n    \n    @Override\n    public java.util.Iterator<Entry> sparseIterator() {\n        return new OpenMapSparseIterator();\n    }\n\n    \n    protected class OpenMapEntry extends Entry { private final Iterator iter; protected OpenMapEntry(Iterator iter) {\n            this.iter = iter;\n        }\n\n        \n        @Override\n        public double getValue() {\n            return iter.value();\n        }\n\n        \n        @Override\n        public void setValue(double value) {\n            entries.put(iter.key(), value);\n        }\n\n        \n        @Override\n        public int getIndex() {\n            return iter.key();\n        }\n\n    }\n\n    \n    protected class OpenMapSparseIterator implements java.util.Iterator<Entry> { private final Iterator iter; private final Entry current; protected OpenMapSparseIterator() {\n            iter = entries.iterator();\n            current = new OpenMapEntry(iter);\n        }\n\n        \n        public boolean hasNext() {\n            return iter.hasNext();\n        }\n\n        \n        public Entry next() {\n            iter.advance();\n            return current;\n        }\n\n        \n        public void remove() {\n            throw new UnsupportedOperationException(\"Not supported\");\n        }\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.math.linear;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math.exception.MathArithmeticException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.util.OpenIntToDoubleHashMap;\nimport org.apache.commons.math.util.OpenIntToDoubleHashMap.Iterator;\nimport org.apache.commons.math.util.FastMath;\n\n\npublic class OpenMapRealVector extends AbstractRealVector implements SparseRealVector, Serializable { public static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12; private static final long serialVersionUID = 8772222695580707260L; private final OpenIntToDoubleHashMap entries; private final int virtualSize; private final double epsilon; public OpenMapRealVector() {\n        this(0, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(int dimension) {\n        this(dimension, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(int dimension, double epsilon) {\n        virtualSize = dimension;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n    }\n\n    \n    protected OpenMapRealVector(OpenMapRealVector v, int resize) {\n        virtualSize = v.getDimension() + resize;\n        entries = new OpenIntToDoubleHashMap(v.entries);\n        epsilon = v.epsilon;\n    }\n\n    \n    public OpenMapRealVector(int dimension, int expectedSize) {\n        this(dimension, expectedSize, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(int dimension, int expectedSize, double epsilon) {\n        virtualSize = dimension;\n        entries = new OpenIntToDoubleHashMap(expectedSize, 0.0);\n        this.epsilon = epsilon;\n    }\n\n    \n    public OpenMapRealVector(double[] values) {\n        this(values, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(double[] values, double epsilon) {\n        virtualSize = values.length;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n        for (int key = 0; key < values.length; key++) {\n            double value = values[key];\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    \n    public OpenMapRealVector(Double[] values) {\n        this(values, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    \n    public OpenMapRealVector(Double[] values, double epsilon) {\n        virtualSize = values.length;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n        for (int key = 0; key < values.length; key++) {\n            double value = values[key].doubleValue();\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    \n    public OpenMapRealVector(OpenMapRealVector v) {\n        virtualSize = v.getDimension();\n        entries = new OpenIntToDoubleHashMap(v.getEntries());\n        epsilon = v.epsilon;\n    }\n\n    \n    public OpenMapRealVector(RealVector v) {\n        virtualSize = v.getDimension();\n        entries = new OpenIntToDoubleHashMap(0.0);\n        epsilon = DEFAULT_ZERO_TOLERANCE;\n        for (int key = 0; key < virtualSize; key++) {\n            double value = v.getEntry(key);\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    \n    private OpenIntToDoubleHashMap getEntries() {\n        return entries;\n    }\n\n    \n    protected boolean isDefaultValue(double value) {\n        return FastMath.abs(value) < epsilon;\n    }\n\n    \n    @Override\n        public RealVector add(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return add((OpenMapRealVector) v);\n        } else {\n            return super.add(v);\n        }\n    }\n\n    \n    public OpenMapRealVector add(OpenMapRealVector v) {\n        checkVectorDimensions(v.getDimension());\n        boolean copyThis = entries.size() > v.entries.size();\n        OpenMapRealVector res = copyThis ? this.copy() : v.copy();\n        Iterator iter = copyThis ? v.entries.iterator() : entries.iterator();\n        OpenIntToDoubleHashMap randomAccess = copyThis ? entries : v.entries;\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (randomAccess.containsKey(key)) {\n                res.setEntry(key, randomAccess.get(key) + iter.value());\n            } else {\n                res.setEntry(key, iter.value());\n            }\n        }\n        return res;\n    }\n\n    \n    public OpenMapRealVector append(OpenMapRealVector v) {\n        OpenMapRealVector res = new OpenMapRealVector(this, v.getDimension());\n        Iterator iter = v.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key() + virtualSize, iter.value());\n        }\n        return res;\n    }\n\n    \n    public OpenMapRealVector append(RealVector v) {\n        if (v instanceof OpenMapRealVector) {\n            return append((OpenMapRealVector) v);\n        }\n        return append(v.getData());\n    }\n\n    \n    public OpenMapRealVector append(double d) {\n        OpenMapRealVector res = new OpenMapRealVector(this, 1);\n        res.setEntry(virtualSize, d);\n        return res;\n    }\n\n    \n    public OpenMapRealVector append(double[] a) {\n        OpenMapRealVector res = new OpenMapRealVector(this, a.length);\n        for (int i = 0; i < a.length; i++) {\n            res.setEntry(i + virtualSize, a[i]);\n        }\n        return res;\n    }\n\n    \n    @Override\n    public OpenMapRealVector copy() {\n        return new OpenMapRealVector(this);\n    }\n\n    \n    public double dotProduct(OpenMapRealVector v) {\n        checkVectorDimensions(v.getDimension());\n        boolean thisIsSmaller  = entries.size() < v.entries.size();\n        Iterator iter = thisIsSmaller  ? entries.iterator() : v.entries.iterator();\n        OpenIntToDoubleHashMap larger = thisIsSmaller  ? v.entries : entries;\n        double d = 0;\n        while(iter.hasNext()) {\n            iter.advance();\n            d += iter.value() * larger.get(iter.key());\n        }\n        return d;\n    }\n\n    \n    @Override\n    public double dotProduct(RealVector v) {\n        if(v instanceof OpenMapRealVector) {\n            return dotProduct((OpenMapRealVector)v);\n        } else {\n            return super.dotProduct(v);\n        }\n    }\n\n    \n    public OpenMapRealVector ebeDivide(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n        }\n        return res;\n    }\n\n    \n    @Override\n    public OpenMapRealVector ebeDivide(double[] v) {\n        checkVectorDimensions(v.length);\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() / v[iter.key()]);\n        }\n        return res;\n    }\n\n    \n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        return res;\n    }\n\n    \n    @Override\n    public OpenMapRealVector ebeMultiply(double[] v) {\n        checkVectorDimensions(v.length);\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v[iter.key()]);\n        }\n        return res;\n    }\n\n    \n    public OpenMapRealVector getSubVector(int index, int n) {\n        checkIndex(index);\n        checkIndex(index + n - 1);\n        OpenMapRealVector res = new OpenMapRealVector(n);\n        int end = index + n;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (key >= index && key < end) {\n                res.setEntry(key - index, iter.value());\n            }\n        }\n        return res;\n    }\n\n    \n    @Override\n    public double[] getData() {\n        double[] res = new double[virtualSize];\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res[iter.key()] = iter.value();\n        }\n        return res;\n    }\n\n    \n    public int getDimension() {\n        return virtualSize;\n    }\n\n    \n    public double getDistance(OpenMapRealVector v) {\n        Iterator iter = entries.iterator();\n        double res = 0;\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            double delta;\n            delta = iter.value() - v.getEntry(key);\n            res += delta * delta;\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                final double value = iter.value();\n                res += value * value;\n            }\n        }\n        return FastMath.sqrt(res);\n    }\n\n    \n    @Override\n    public double getDistance(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getDistance((OpenMapRealVector) v);\n        }\n        return getDistance(v.getData());\n    }\n\n    \n    @Override\n    public double getDistance(double[] v) {\n        checkVectorDimensions(v.length);\n        double res = 0;\n        for (int i = 0; i < v.length; i++) {\n            double delta = entries.get(i) - v[i];\n            res += delta * delta;\n        }\n        return FastMath.sqrt(res);\n    }\n\n    \n    public double getEntry(int index) {\n        checkIndex(index);\n        return entries.get(index);\n    }\n\n    \n    public double getL1Distance(OpenMapRealVector v) {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double delta = FastMath.abs(iter.value() - v.getEntry(iter.key()));\n            max += delta;\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                double delta = FastMath.abs(iter.value());\n                max +=  FastMath.abs(delta);\n            }\n        }\n        return max;\n    }\n\n    \n    @Override\n    public double getL1Distance(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getL1Distance((OpenMapRealVector) v);\n        }\n        return getL1Distance(v.getData());\n    }\n\n    \n    @Override\n    public double getL1Distance(double[] v) {\n        checkVectorDimensions(v.length);\n        double max = 0;\n        for (int i = 0; i < v.length; i++) {\n            double delta = FastMath.abs(getEntry(i) - v[i]);\n            max += delta;\n        }\n        return max;\n    }\n\n    \n    private double getLInfDistance(OpenMapRealVector v) {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double delta = FastMath.abs(iter.value() - v.getEntry(iter.key()));\n            if (delta > max) {\n                max = delta;\n            }\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                if (iter.value() > max) {\n                    max = iter.value();\n                }\n            }\n        }\n        return max;\n    }\n\n    \n    @Override\n    public double getLInfDistance(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getLInfDistance((OpenMapRealVector) v);\n        }\n        return getLInfDistance(v.getData());\n    }\n\n    \n    @Override\n    public double getLInfDistance(double[] v) {\n        checkVectorDimensions(v.length);\n        double max = 0;\n        for (int i = 0; i < v.length; i++) {\n            double delta = FastMath.abs(getEntry(i) - v[i]);\n            if (delta > max) {\n                max = delta;\n            }\n        }\n        return max;\n    }\n\n    \n    public boolean isInfinite() {\n        boolean infiniteFound = false;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            final double value = iter.value();\n            if (Double.isNaN(value)) {\n                return false;\n            }\n            if (Double.isInfinite(value)) {\n                infiniteFound = true;\n            }\n        }\n        return infiniteFound;\n    }\n\n    \n    public boolean isNaN() {\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            if (Double.isNaN(iter.value())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    @Override\n    public OpenMapRealVector mapAdd(double d) {\n        return copy().mapAddToSelf(d);\n    }\n\n    \n    @Override\n    public OpenMapRealVector mapAddToSelf(double d) {\n        for (int i = 0; i < virtualSize; i++) {\n            setEntry(i, getEntry(i) + d);\n        }\n        return this;\n    }\n\n     \n    @Override\n    public RealMatrix outerProduct(double[] v) {\n        final int n = v.length;\n        RealMatrix res = new OpenMapRealMatrix(virtualSize, n);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int row = iter.key();\n            double value = iter.value();\n            for (int col = 0; col < n; col++) {\n                res.setEntry(row, col, value * v[col]);\n            }\n        }\n        return res;\n    }\n\n    \n    public RealVector projection(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        return v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n    }\n\n    \n    @Override\n    public OpenMapRealVector projection(double[] v) {\n        checkVectorDimensions(v.length);\n        return (OpenMapRealVector) projection(new OpenMapRealVector(v));\n    }\n\n    \n    public void setEntry(int index, double value) {\n        checkIndex(index);\n        if (!isDefaultValue(value)) {\n            entries.put(index, value);\n        } else if (entries.containsKey(index)) {\n            entries.remove(index);\n        }\n    }\n\n    \n    @Override\n    public void setSubVector(int index, RealVector v) {\n        checkIndex(index);\n        checkIndex(index + v.getDimension() - 1);\n        setSubVector(index, v.getData());\n    }\n\n    \n    @Override\n    public void setSubVector(int index, double[] v) {\n        checkIndex(index);\n        checkIndex(index + v.length - 1);\n        for (int i = 0; i < v.length; i++) {\n            setEntry(i + index, v[i]);\n        }\n    }\n\n    \n    @Override\n    public void set(double value) {\n        for (int i = 0; i < virtualSize; i++) {\n            setEntry(i, value);\n        }\n    }\n\n    \n    public OpenMapRealVector subtract(OpenMapRealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = copy();\n        Iterator iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (entries.containsKey(key)) {\n                res.setEntry(key, entries.get(key) - iter.value());\n            } else {\n                res.setEntry(key, -iter.value());\n            }\n        }\n        return res;\n    }\n\n    \n    @Override\n    public OpenMapRealVector subtract(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return subtract((OpenMapRealVector) v);\n        }\n        return subtract(v.getData());\n    }\n\n    \n    @Override\n    public OpenMapRealVector subtract(double[] v) {\n        checkVectorDimensions(v.length);\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        for (int i = 0; i < v.length; i++) {\n            if (entries.containsKey(i)) {\n                res.setEntry(i, entries.get(i) - v[i]);\n            } else {\n                res.setEntry(i, -v[i]);\n            }\n        }\n        return res;\n    }\n\n\n    \n    @Override\n    public OpenMapRealVector unitVector() {\n        OpenMapRealVector res = copy();\n        res.unitize();\n        return res;\n    }\n\n    \n    @Override\n    public void unitize() {\n        double norm = getNorm();\n        if (isDefaultValue(norm)) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            entries.put(iter.key(), iter.value() / norm);\n        }\n    }\n\n    \n    @Override\n    public double[] toArray() {\n        return getData();\n    }\n\n    \n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        long temp;\n        temp = Double.doubleToLongBits(epsilon);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        result = prime * result + virtualSize;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            temp = Double.doubleToLongBits(iter.value());\n            result = prime * result + (int) (temp ^ (temp >>32));\n        }\n        return result;\n    }\n\n    \n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof OpenMapRealVector)) {\n            return false;\n        }\n        OpenMapRealVector other = (OpenMapRealVector) obj;\n        if (virtualSize != other.virtualSize) {\n            return false;\n        }\n        if (Double.doubleToLongBits(epsilon) !=\n            Double.doubleToLongBits(other.epsilon)) {\n            return false;\n        }\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double test = other.getEntry(iter.key());\n            if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {\n                return false;\n            }\n        }\n        iter = other.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double test = iter.value();\n            if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public double getSparsity() {\n        return (double)entries.size()/(double)getDimension();\n    }\n\n    \n    @Override\n    public java.util.Iterator<Entry> sparseIterator() {\n        return new OpenMapSparseIterator();\n    }\n\n    \n    protected class OpenMapEntry extends Entry { private final Iterator iter; protected OpenMapEntry(Iterator iter) {\n            this.iter = iter;\n        }\n\n        \n        @Override\n        public double getValue() {\n            return iter.value();\n        }\n\n        \n        @Override\n        public void setValue(double value) {\n            entries.put(iter.key(), value);\n        }\n\n        \n        @Override\n        public int getIndex() {\n            return iter.key();\n        }\n\n    }\n\n    \n    protected class OpenMapSparseIterator implements java.util.Iterator<Entry> { private final Iterator iter; private final Entry current; protected OpenMapSparseIterator() {\n            iter = entries.iterator();\n            current = new OpenMapEntry(iter);\n        }\n\n        \n        public boolean hasNext() {\n            return iter.hasNext();\n        }\n\n        \n        public Entry next() {\n            iter.advance();\n            return current;\n        }\n\n        \n        public void remove() {\n            throw new UnsupportedOperationException(\"Not supported\");\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public OpenMapRealVector(int dimension)",
        "public OpenMapRealVector(int dimension, double epsilon)",
        "protected OpenMapRealVector(OpenMapRealVector v, int resize)",
        "public OpenMapRealVector(int dimension, int expectedSize)",
        "public OpenMapRealVector(int dimension, int expectedSize, double epsilon)",
        "public OpenMapRealVector(double[] values)",
        "public OpenMapRealVector(double[] values, double epsilon)",
        "public OpenMapRealVector(Double[] values)",
        "public OpenMapRealVector(Double[] values, double epsilon)",
        "public OpenMapRealVector(OpenMapRealVector v)",
        "public OpenMapRealVector(RealVector v)",
        "private OpenIntToDoubleHashMap getEntries()",
        "protected boolean isDefaultValue(double value)",
        "public RealVector add(RealVector v)",
        "public OpenMapRealVector add(OpenMapRealVector v)",
        "public OpenMapRealVector append(OpenMapRealVector v)",
        "public OpenMapRealVector append(RealVector v)",
        "public OpenMapRealVector append(double d)",
        "public OpenMapRealVector append(double[] a)",
        "public OpenMapRealVector copy()",
        "public double dotProduct(OpenMapRealVector v)",
        "public double dotProduct(RealVector v)",
        "public OpenMapRealVector ebeDivide(RealVector v)",
        "public OpenMapRealVector ebeDivide(double[] v)",
        "public OpenMapRealVector ebeMultiply(RealVector v)",
        "public OpenMapRealVector ebeMultiply(double[] v)",
        "public OpenMapRealVector getSubVector(int index, int n)",
        "public double[] getData()",
        "public int getDimension()",
        "public double getDistance(OpenMapRealVector v)",
        "public double getDistance(RealVector v)",
        "public double getDistance(double[] v)",
        "public double getEntry(int index)",
        "public double getL1Distance(OpenMapRealVector v)",
        "public double getL1Distance(RealVector v)",
        "public double getL1Distance(double[] v)",
        "private double getLInfDistance(OpenMapRealVector v)",
        "public double getLInfDistance(RealVector v)",
        "public double getLInfDistance(double[] v)",
        "public boolean isInfinite()",
        "public boolean isNaN()",
        "public OpenMapRealVector mapAdd(double d)",
        "public OpenMapRealVector mapAddToSelf(double d)",
        "public RealMatrix outerProduct(double[] v)",
        "public RealVector projection(RealVector v)",
        "public OpenMapRealVector projection(double[] v)",
        "public void setEntry(int index, double value)",
        "public void setSubVector(int index, RealVector v)",
        "public void setSubVector(int index, double[] v)",
        "public void set(double value)",
        "public OpenMapRealVector subtract(OpenMapRealVector v)",
        "public OpenMapRealVector subtract(RealVector v)",
        "public OpenMapRealVector subtract(double[] v)",
        "public OpenMapRealVector unitVector()",
        "public void unitize()",
        "public double[] toArray()",
        "public int hashCode()",
        "public boolean equals(Object obj)",
        "public double getSparsity()",
        "public java.util.Iterator<Entry> sparseIterator()",
        "protected class OpenMapEntry extends Entry { private final Iterator iter; protected OpenMapEntry(Iterator iter)",
        "public double getValue()",
        "public void setValue(double value)",
        "public int getIndex()",
        "protected class OpenMapSparseIterator implements java.util.Iterator<Entry> { private final Iterator iter; private final Entry current; protected OpenMapSparseIterator()",
        "public boolean hasNext()",
        "public Entry next()",
        "public void remove()"
      ],
      "fixed_signatures": [
        "public OpenMapRealVector(int dimension)",
        "public OpenMapRealVector(int dimension, double epsilon)",
        "protected OpenMapRealVector(OpenMapRealVector v, int resize)",
        "public OpenMapRealVector(int dimension, int expectedSize)",
        "public OpenMapRealVector(int dimension, int expectedSize, double epsilon)",
        "public OpenMapRealVector(double[] values)",
        "public OpenMapRealVector(double[] values, double epsilon)",
        "public OpenMapRealVector(Double[] values)",
        "public OpenMapRealVector(Double[] values, double epsilon)",
        "public OpenMapRealVector(OpenMapRealVector v)",
        "public OpenMapRealVector(RealVector v)",
        "private OpenIntToDoubleHashMap getEntries()",
        "protected boolean isDefaultValue(double value)",
        "public RealVector add(RealVector v)",
        "public OpenMapRealVector add(OpenMapRealVector v)",
        "public OpenMapRealVector append(OpenMapRealVector v)",
        "public OpenMapRealVector append(RealVector v)",
        "public OpenMapRealVector append(double d)",
        "public OpenMapRealVector append(double[] a)",
        "public OpenMapRealVector copy()",
        "public double dotProduct(OpenMapRealVector v)",
        "public double dotProduct(RealVector v)",
        "public OpenMapRealVector ebeDivide(RealVector v)",
        "public OpenMapRealVector ebeDivide(double[] v)",
        "public OpenMapRealVector ebeMultiply(RealVector v)",
        "public OpenMapRealVector ebeMultiply(double[] v)",
        "public OpenMapRealVector getSubVector(int index, int n)",
        "public double[] getData()",
        "public int getDimension()",
        "public double getDistance(OpenMapRealVector v)",
        "public double getDistance(RealVector v)",
        "public double getDistance(double[] v)",
        "public double getEntry(int index)",
        "public double getL1Distance(OpenMapRealVector v)",
        "public double getL1Distance(RealVector v)",
        "public double getL1Distance(double[] v)",
        "private double getLInfDistance(OpenMapRealVector v)",
        "public double getLInfDistance(RealVector v)",
        "public double getLInfDistance(double[] v)",
        "public boolean isInfinite()",
        "public boolean isNaN()",
        "public OpenMapRealVector mapAdd(double d)",
        "public OpenMapRealVector mapAddToSelf(double d)",
        "public RealMatrix outerProduct(double[] v)",
        "public RealVector projection(RealVector v)",
        "public OpenMapRealVector projection(double[] v)",
        "public void setEntry(int index, double value)",
        "public void setSubVector(int index, RealVector v)",
        "public void setSubVector(int index, double[] v)",
        "public void set(double value)",
        "public OpenMapRealVector subtract(OpenMapRealVector v)",
        "public OpenMapRealVector subtract(RealVector v)",
        "public OpenMapRealVector subtract(double[] v)",
        "public OpenMapRealVector unitVector()",
        "public void unitize()",
        "public double[] toArray()",
        "public int hashCode()",
        "public boolean equals(Object obj)",
        "public double getSparsity()",
        "public java.util.Iterator<Entry> sparseIterator()",
        "protected class OpenMapEntry extends Entry { private final Iterator iter; protected OpenMapEntry(Iterator iter)",
        "public double getValue()",
        "public void setValue(double value)",
        "public int getIndex()",
        "protected class OpenMapSparseIterator implements java.util.Iterator<Entry> { private final Iterator iter; private final Entry current; protected OpenMapSparseIterator()",
        "public boolean hasNext()",
        "public Entry next()",
        "public void remove()"
      ],
      "methods": [
        {
          "buggy_method": "  public OpenMapRealVector ebeDivide(RealVector v) {\n  checkVectorDimensions(v.getDimension());\n  OpenMapRealVector res = new OpenMapRealVector(this);\n  Iterator iter = res.entries.iterator();\n  while (iter.hasNext()) {\n  iter.advance();\n  res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n  }\n  return res;\n  }",
          "fixed_method": "  public OpenMapRealVector ebeDivide(RealVector v) {\n  checkVectorDimensions(v.getDimension());\n  OpenMapRealVector res = new OpenMapRealVector(this);\n  Iterator iter = entries.iterator();\n  while (iter.hasNext()) {\n  iter.advance();\n  res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n  }\n  return res;\n  }",
          "diff": [
            "@@ -342,7 +342,7 @@",
            "     public OpenMapRealVector ebeDivide(RealVector v) {\n",
            "         checkVectorDimensions(v.getDimension());\n",
            "         OpenMapRealVector res = new OpenMapRealVector(this);\n",
            "-        Iterator iter = res.entries.iterator();\n",
            "+        Iterator iter = entries.iterator();\n",
            "         while (iter.hasNext()) {\n",
            "             iter.advance();\n",
            "             res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  public OpenMapRealVector ebeDivide(double[] v) {\n  checkVectorDimensions(v.length);\n  OpenMapRealVector res = new OpenMapRealVector(this);\n  Iterator iter = res.entries.iterator();\n  while (iter.hasNext()) {\n  iter.advance();\n  res.setEntry(iter.key(), iter.value() / v[iter.key()]);\n  }\n  return res;\n  }",
          "fixed_method": "  public OpenMapRealVector ebeDivide(double[] v) {\n  checkVectorDimensions(v.length);\n  OpenMapRealVector res = new OpenMapRealVector(this);\n  Iterator iter = entries.iterator();\n  while (iter.hasNext()) {\n  iter.advance();\n  res.setEntry(iter.key(), iter.value() / v[iter.key()]);\n  }\n  return res;\n  }",
          "diff": [
            "@@ -355,7 +355,7 @@",
            "     public OpenMapRealVector ebeDivide(double[] v) {\n",
            "         checkVectorDimensions(v.length);\n",
            "         OpenMapRealVector res = new OpenMapRealVector(this);\n",
            "-        Iterator iter = res.entries.iterator();\n",
            "+        Iterator iter = entries.iterator();\n",
            "         while (iter.hasNext()) {\n",
            "             iter.advance();\n",
            "             res.setEntry(iter.key(), iter.value() / v[iter.key()]);\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  public OpenMapRealVector ebeMultiply(RealVector v) {\n  checkVectorDimensions(v.getDimension());\n  OpenMapRealVector res = new OpenMapRealVector(this);\n  Iterator iter = res.entries.iterator();\n  while (iter.hasNext()) {\n  iter.advance();\n  res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n  }\n  return res;\n  }",
          "fixed_method": "  public OpenMapRealVector ebeMultiply(RealVector v) {\n  checkVectorDimensions(v.getDimension());\n  OpenMapRealVector res = new OpenMapRealVector(this);\n  Iterator iter = entries.iterator();\n  while (iter.hasNext()) {\n  iter.advance();\n  res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n  }\n  return res;\n  }",
          "diff": [
            "@@ -367,7 +367,7 @@",
            "     public OpenMapRealVector ebeMultiply(RealVector v) {\n",
            "         checkVectorDimensions(v.getDimension());\n",
            "         OpenMapRealVector res = new OpenMapRealVector(this);\n",
            "-        Iterator iter = res.entries.iterator();\n",
            "+        Iterator iter = entries.iterator();\n",
            "         while (iter.hasNext()) {\n",
            "             iter.advance();\n",
            "             res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n"
          ],
          "changed_lines": 2
        },
        {
          "buggy_method": "  public OpenMapRealVector ebeMultiply(double[] v) {\n  checkVectorDimensions(v.length);\n  OpenMapRealVector res = new OpenMapRealVector(this);\n  Iterator iter = res.entries.iterator();\n  while (iter.hasNext()) {\n  iter.advance();\n  res.setEntry(iter.key(), iter.value() * v[iter.key()]);\n  }\n  return res;\n  }",
          "fixed_method": "  public OpenMapRealVector ebeMultiply(double[] v) {\n  checkVectorDimensions(v.length);\n  OpenMapRealVector res = new OpenMapRealVector(this);\n  Iterator iter = entries.iterator();\n  while (iter.hasNext()) {\n  iter.advance();\n  res.setEntry(iter.key(), iter.value() * v[iter.key()]);\n  }\n  return res;\n  }",
          "diff": [
            "@@ -380,7 +380,7 @@",
            "     public OpenMapRealVector ebeMultiply(double[] v) {\n",
            "         checkVectorDimensions(v.length);\n",
            "         OpenMapRealVector res = new OpenMapRealVector(this);\n",
            "-        Iterator iter = res.entries.iterator();\n",
            "+        Iterator iter = entries.iterator();\n",
            "         while (iter.hasNext()) {\n",
            "             iter.advance();\n",
            "             res.setEntry(iter.key(), iter.value() * v[iter.key()]);\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
