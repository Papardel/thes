{
  "bug_id": "32",
  "failed_tests": {
    "org.jsoup.nodes.ElementTest": [
      {
        "methodName": "testClonesClassnames",
        "error": "junit.framework.AssertionFailedError",
        "message": "",
        "fail_line": "        assertTrue(classes.contains(\"one\"));",
        "test_source": "",
        "stack": [
          "ElementTest.testClonesClassnames line 493"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/nodes/Element.java",
      "buggy_full_code": "package org.jsoup.nodes;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.parser.Tag;\nimport org.jsoup.select.Collector;\nimport org.jsoup.select.Elements;\nimport org.jsoup.select.Evaluator;\nimport org.jsoup.select.Selector;\n\nimport java.util.*;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\n\n\npublic class Element extends Node { private Tag tag; private Set<String> classNames; public Element(Tag tag, String baseUri, Attributes attributes) {\n        super(baseUri, attributes);\n        \n        Validate.notNull(tag);    \n        this.tag = tag;\n    }\n    \n    \n    public Element(Tag tag, String baseUri) {\n        this(tag, baseUri, new Attributes());\n    }\n\n    @Override\n    public String nodeName() {\n        return tag.getName();\n    }\n\n    \n    public String tagName() {\n        return tag.getName();\n    }\n\n    \n    public Element tagName(String tagName) {\n        Validate.notEmpty(tagName, \"Tag name must not be empty.\");\n        tag = Tag.valueOf(tagName);\n        return this;\n    }\n\n    \n    public Tag tag() {\n        return tag;\n    }\n    \n    \n    public boolean isBlock() {\n        return tag.isBlock();\n    }\n\n    \n    public String id() {\n        String id = attr(\"id\");\n        return id == null ? \"\" : id;\n    }\n\n    \n    public Element attr(String attributeKey, String attributeValue) {\n        super.attr(attributeKey, attributeValue);\n        return this;\n    }\n\n    \n    public Map<String, String> dataset() {\n        return attributes.dataset();\n    }\n\n    @Override\n    public final Element parent() {\n        return (Element) parentNode;\n    }\n\n    \n    public Elements parents() {\n        Elements parents = new Elements();\n        accumulateParents(this, parents);\n        return parents;\n    }\n\n    private static void accumulateParents(Element el, Elements parents) {\n        Element parent = el.parent();\n        if (parent != null && !parent.tagName().equals(\"#root\")) {\n            parents.add(parent);\n            accumulateParents(parent, parents);\n        }\n    }\n\n    \n    public Element child(int index) {\n        return children().get(index);\n    }\n\n    \n    public Elements children() {\n        \n        List<Element> elements = new ArrayList<Element>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                elements.add((Element) node);\n        }\n        return new Elements(elements);\n    }\n\n    \n    public List<TextNode> textNodes() {\n        List<TextNode> textNodes = new ArrayList<TextNode>();\n        for (Node node : childNodes) {\n            if (node instanceof TextNode)\n                textNodes.add((TextNode) node);\n        }\n        return Collections.unmodifiableList(textNodes);\n    }\n\n    \n    public List<DataNode> dataNodes() {\n        List<DataNode> dataNodes = new ArrayList<DataNode>();\n        for (Node node : childNodes) {\n            if (node instanceof DataNode)\n                dataNodes.add((DataNode) node);\n        }\n        return Collections.unmodifiableList(dataNodes);\n    }\n\n    \n    public Elements select(String cssQuery) {\n        return Selector.select(cssQuery, this);\n    }\n    \n    \n    public Element appendChild(Node child) {\n        Validate.notNull(child);\n        \n        addChildren(child);\n        return this;\n    }\n\n    \n    public Element prependChild(Node child) {\n        Validate.notNull(child);\n        \n        addChildren(0, child);\n        return this;\n    }\n\n\n    \n    public Element insertChildren(int index, Collection<? extends Node> children) {\n        Validate.notNull(children, \"Children collection to be inserted must not be null.\");\n        int currentSize = childNodeSize();\n        if (index < 0) index += currentSize +1; \n        Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n\n        ArrayList<Node> nodes = new ArrayList<Node>(children);\n        Node[] nodeArray = nodes.toArray(new Node[nodes.size()]);\n        addChildren(index, nodeArray);\n        return this;\n    }\n    \n    \n    public Element appendElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName), baseUri());\n        appendChild(child);\n        return child;\n    }\n    \n    \n    public Element prependElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName), baseUri());\n        prependChild(child);\n        return child;\n    }\n    \n    \n    public Element appendText(String text) {\n        TextNode node = new TextNode(text, baseUri());\n        appendChild(node);\n        return this;\n    }\n    \n    \n    public Element prependText(String text) {\n        TextNode node = new TextNode(text, baseUri());\n        prependChild(node);\n        return this;\n    }\n    \n    \n    public Element append(String html) {\n        Validate.notNull(html);\n\n        List<Node> nodes = Parser.parseFragment(html, this, baseUri());\n        addChildren(nodes.toArray(new Node[nodes.size()]));\n        return this;\n    }\n    \n    \n    public Element prepend(String html) {\n        Validate.notNull(html);\n        \n        List<Node> nodes = Parser.parseFragment(html, this, baseUri());\n        addChildren(0, nodes.toArray(new Node[nodes.size()]));\n        return this;\n    }\n\n    \n    @Override\n    public Element before(String html) {\n        return (Element) super.before(html);\n    }\n\n    \n    @Override\n    public Element before(Node node) {\n        return (Element) super.before(node);\n    }\n\n    \n    @Override\n    public Element after(String html) {\n        return (Element) super.after(html);\n    }\n\n    \n    @Override\n    public Element after(Node node) {\n        return (Element) super.after(node);\n    }\n\n    \n    public Element empty() {\n        childNodes.clear();\n        return this;\n    }\n\n    \n    @Override\n    public Element wrap(String html) {\n        return (Element) super.wrap(html);\n    }\n\n    \n    public Elements siblingElements() {\n        if (parentNode == null)\n            return new Elements(0);\n\n        List<Element> elements = parent().children();\n        Elements siblings = new Elements(elements.size() - 1);\n        for (Element el: elements)\n            if (el != this)\n                siblings.add(el);\n        return siblings;\n    }\n\n    \n    public Element nextElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().children();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }\n\n    \n    public Element previousElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().children();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }\n\n    \n    public Element firstElementSibling() {\n        \n        List<Element> siblings = parent().children();\n        return siblings.size() > 1 ? siblings.get(0) : null;\n    }\n    \n    \n    public Integer elementSiblingIndex() {\n       if (parent() == null) return 0;\n       return indexInList(this, parent().children()); \n    }\n\n    \n    public Element lastElementSibling() {\n        List<Element> siblings = parent().children();\n        return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;\n    }\n    \n    private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n        Validate.notNull(search);\n        Validate.notNull(elements);\n\n        for (int i = 0; i < elements.size(); i++) {\n            E element = elements.get(i);\n            if (element.equals(search))\n                return i;\n        }\n        return null;\n    }\n\n    \n\n    \n    public Elements getElementsByTag(String tagName) {\n        Validate.notEmpty(tagName);\n        tagName = tagName.toLowerCase().trim();\n\n        return Collector.collect(new Evaluator.Tag(tagName), this);\n    }\n\n    \n    public Element getElementById(String id) {\n        Validate.notEmpty(id);\n        \n        Elements elements = Collector.collect(new Evaluator.Id(id), this);\n        if (elements.size() > 0)\n            return elements.get(0);\n        else\n            return null;\n    }\n\n    \n    public Elements getElementsByClass(String className) {\n        Validate.notEmpty(className);\n\n        return Collector.collect(new Evaluator.Class(className), this);\n    }\n\n    \n    public Elements getElementsByAttribute(String key) {\n        Validate.notEmpty(key);\n        key = key.trim().toLowerCase();\n\n        return Collector.collect(new Evaluator.Attribute(key), this);\n    }\n\n    \n    public Elements getElementsByAttributeStarting(String keyPrefix) {\n        Validate.notEmpty(keyPrefix);\n        keyPrefix = keyPrefix.trim().toLowerCase();\n\n        return Collector.collect(new Evaluator.AttributeStarting(keyPrefix), this);\n    }\n\n    \n    public Elements getElementsByAttributeValue(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValue(key, value), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueNot(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) {\n        return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) {\n        return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueContaining(String key, String match) {\n        return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this);\n    }\n    \n    \n    public Elements getElementsByAttributeValueMatching(String key, Pattern pattern) {\n        return Collector.collect(new Evaluator.AttributeWithValueMatching(key, pattern), this);\n        \n    }\n    \n    \n    public Elements getElementsByAttributeValueMatching(String key, String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsByAttributeValueMatching(key, pattern);\n    }\n    \n    \n    public Elements getElementsByIndexLessThan(int index) {\n        return Collector.collect(new Evaluator.IndexLessThan(index), this);\n    }\n    \n    \n    public Elements getElementsByIndexGreaterThan(int index) {\n        return Collector.collect(new Evaluator.IndexGreaterThan(index), this);\n    }\n    \n    \n    public Elements getElementsByIndexEquals(int index) {\n        return Collector.collect(new Evaluator.IndexEquals(index), this);\n    }\n    \n    \n    public Elements getElementsContainingText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsText(searchText), this);\n    }\n    \n    \n    public Elements getElementsContainingOwnText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsOwnText(searchText), this);\n    }\n    \n    \n    public Elements getElementsMatchingText(Pattern pattern) {\n        return Collector.collect(new Evaluator.Matches(pattern), this);\n    }\n    \n    \n    public Elements getElementsMatchingText(String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsMatchingText(pattern);\n    }\n    \n    \n    public Elements getElementsMatchingOwnText(Pattern pattern) {\n        return Collector.collect(new Evaluator.MatchesOwn(pattern), this);\n    }\n    \n    \n    public Elements getElementsMatchingOwnText(String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsMatchingOwnText(pattern);\n    }\n    \n    \n    public Elements getAllElements() {\n        return Collector.collect(new Evaluator.AllElements(), this);\n    }\n\n    \n    public String text() {\n        StringBuilder sb = new StringBuilder();\n        text(sb);\n        return sb.toString().trim();\n    }\n\n    private void text(StringBuilder accum) {\n        appendWhitespaceIfBr(this, accum);\n        \n        for (Node child : childNodes) {\n            if (child instanceof TextNode) {\n                TextNode textNode = (TextNode) child;\n                appendNormalisedText(accum, textNode);\n            } else if (child instanceof Element) {\n                Element element = (Element) child;\n                if (accum.length() > 0 && element.isBlock() && !TextNode.lastCharIsWhitespace(accum))\n                    accum.append(\" \");\n                element.text(accum);\n            }\n        }\n    }\n\n    \n    public String ownText() {\n        StringBuilder sb = new StringBuilder();\n        ownText(sb);\n        return sb.toString().trim();\n    }\n\n    private void ownText(StringBuilder accum) {\n        for (Node child : childNodes) {\n            if (child instanceof TextNode) {\n                TextNode textNode = (TextNode) child;\n                appendNormalisedText(accum, textNode);\n            } else if (child instanceof Element) {\n                appendWhitespaceIfBr((Element) child, accum);\n            }\n        }\n    }\n\n    private void appendNormalisedText(StringBuilder accum, TextNode textNode) {\n        String text = textNode.getWholeText();\n\n        if (!preserveWhitespace()) {\n            text = TextNode.normaliseWhitespace(text);\n            if (TextNode.lastCharIsWhitespace(accum))\n                text = TextNode.stripLeadingWhitespace(text);\n        }\n        accum.append(text);\n    }\n\n    private static void appendWhitespaceIfBr(Element element, StringBuilder accum) {\n        if (element.tag.getName().equals(\"br\") && !TextNode.lastCharIsWhitespace(accum))\n            accum.append(\" \");\n    }\n\n    boolean preserveWhitespace() {\n        return tag.preserveWhitespace() || parent() != null && parent().preserveWhitespace();\n    }\n\n    \n    public Element text(String text) {\n        Validate.notNull(text);\n\n        empty();\n        TextNode textNode = new TextNode(text, baseUri);\n        appendChild(textNode);\n\n        return this;\n    }\n\n    \n    public boolean hasText() {\n        for (Node child: childNodes) {\n            if (child instanceof TextNode) {\n                TextNode textNode = (TextNode) child;\n                if (!textNode.isBlank())\n                    return true;\n            } else if (child instanceof Element) {\n                Element el = (Element) child;\n                if (el.hasText())\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    \n    public String data() {\n        StringBuilder sb = new StringBuilder();\n\n        for (Node childNode : childNodes) {\n            if (childNode instanceof DataNode) {\n                DataNode data = (DataNode) childNode;\n                sb.append(data.getWholeData());\n            } else if (childNode instanceof Element) {\n                Element element = (Element) childNode;\n                String elementData = element.data();\n                sb.append(elementData);\n            }\n        }\n        return sb.toString();\n    }   \n\n    \n    public String className() {\n        return attr(\"class\");\n    }\n\n    \n    public Set<String> classNames() {\n        if (classNames == null) {\n            String[] names = className().split(\"\\\\s+\");\n            classNames = new LinkedHashSet<String>(Arrays.asList(names));\n        }\n        return classNames;\n    }\n\n    \n    public Element classNames(Set<String> classNames) {\n        Validate.notNull(classNames);\n        attributes.put(\"class\", StringUtil.join(classNames, \" \"));\n        return this;\n    }\n\n    \n    public boolean hasClass(String className) {\n        Set<String> classNames = classNames();\n        for (String name : classNames) {\n            if (className.equalsIgnoreCase(name))\n                return true;\n        }\n        return false;\n    }\n\n    \n    public Element addClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        classes.add(className);\n        classNames(classes);\n\n        return this;\n    }\n\n    \n    public Element removeClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        classes.remove(className);\n        classNames(classes);\n\n        return this;\n    }\n\n    \n    public Element toggleClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        if (classes.contains(className))\n            classes.remove(className);\n        else\n            classes.add(className);\n        classNames(classes);\n\n        return this;\n    }\n    \n    \n    public String val() {\n        if (tagName().equals(\"textarea\"))\n            return text();\n        else\n            return attr(\"value\");\n    }\n    \n    \n    public Element val(String value) {\n        if (tagName().equals(\"textarea\"))\n            text(value);\n        else\n            attr(\"value\", value);\n        return this;\n    }\n\n    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n        if (accum.length() > 0 && out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock())))\n            indent(accum, depth, out);\n        accum\n                .append(\"<\")\n                .append(tagName());\n        attributes.html(accum, out);\n\n        if (childNodes.isEmpty() && tag.isSelfClosing())\n            accum.append(\" />\");\n        else\n            accum.append(\">\");\n    }\n\n    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {\n        if (!(childNodes.isEmpty() && tag.isSelfClosing())) {\n            if (out.prettyPrint() && !childNodes.isEmpty() && tag.formatAsBlock())\n                indent(accum, depth, out);\n            accum.append(\"</\").append(tagName()).append(\">\");\n        }\n    }\n\n    \n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        html(accum); \n        return accum.toString().trim();\n    }\n\n    private void html(StringBuilder accum) {\n        for (Node node : childNodes)\n            node.outerHtml(accum);\n    }\n    \n    \n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n    public String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        return this == o;\n    }\n\n    @Override\n    public int hashCode() {\n        \n        int result = super.hashCode();\n        result = 31 * result + (tag != null ? tag.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public Element clone() {\n        Element clone = (Element) super.clone();\n        clone.classNames();\n        return clone;\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.nodes;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.parser.Tag;\nimport org.jsoup.select.Collector;\nimport org.jsoup.select.Elements;\nimport org.jsoup.select.Evaluator;\nimport org.jsoup.select.Selector;\n\nimport java.util.*;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\n\n\npublic class Element extends Node { private Tag tag; private Set<String> classNames; public Element(Tag tag, String baseUri, Attributes attributes) {\n        super(baseUri, attributes);\n        \n        Validate.notNull(tag);    \n        this.tag = tag;\n    }\n    \n    \n    public Element(Tag tag, String baseUri) {\n        this(tag, baseUri, new Attributes());\n    }\n\n    @Override\n    public String nodeName() {\n        return tag.getName();\n    }\n\n    \n    public String tagName() {\n        return tag.getName();\n    }\n\n    \n    public Element tagName(String tagName) {\n        Validate.notEmpty(tagName, \"Tag name must not be empty.\");\n        tag = Tag.valueOf(tagName);\n        return this;\n    }\n\n    \n    public Tag tag() {\n        return tag;\n    }\n    \n    \n    public boolean isBlock() {\n        return tag.isBlock();\n    }\n\n    \n    public String id() {\n        String id = attr(\"id\");\n        return id == null ? \"\" : id;\n    }\n\n    \n    public Element attr(String attributeKey, String attributeValue) {\n        super.attr(attributeKey, attributeValue);\n        return this;\n    }\n\n    \n    public Map<String, String> dataset() {\n        return attributes.dataset();\n    }\n\n    @Override\n    public final Element parent() {\n        return (Element) parentNode;\n    }\n\n    \n    public Elements parents() {\n        Elements parents = new Elements();\n        accumulateParents(this, parents);\n        return parents;\n    }\n\n    private static void accumulateParents(Element el, Elements parents) {\n        Element parent = el.parent();\n        if (parent != null && !parent.tagName().equals(\"#root\")) {\n            parents.add(parent);\n            accumulateParents(parent, parents);\n        }\n    }\n\n    \n    public Element child(int index) {\n        return children().get(index);\n    }\n\n    \n    public Elements children() {\n        \n        List<Element> elements = new ArrayList<Element>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                elements.add((Element) node);\n        }\n        return new Elements(elements);\n    }\n\n    \n    public List<TextNode> textNodes() {\n        List<TextNode> textNodes = new ArrayList<TextNode>();\n        for (Node node : childNodes) {\n            if (node instanceof TextNode)\n                textNodes.add((TextNode) node);\n        }\n        return Collections.unmodifiableList(textNodes);\n    }\n\n    \n    public List<DataNode> dataNodes() {\n        List<DataNode> dataNodes = new ArrayList<DataNode>();\n        for (Node node : childNodes) {\n            if (node instanceof DataNode)\n                dataNodes.add((DataNode) node);\n        }\n        return Collections.unmodifiableList(dataNodes);\n    }\n\n    \n    public Elements select(String cssQuery) {\n        return Selector.select(cssQuery, this);\n    }\n    \n    \n    public Element appendChild(Node child) {\n        Validate.notNull(child);\n        \n        addChildren(child);\n        return this;\n    }\n\n    \n    public Element prependChild(Node child) {\n        Validate.notNull(child);\n        \n        addChildren(0, child);\n        return this;\n    }\n\n\n    \n    public Element insertChildren(int index, Collection<? extends Node> children) {\n        Validate.notNull(children, \"Children collection to be inserted must not be null.\");\n        int currentSize = childNodeSize();\n        if (index < 0) index += currentSize +1; \n        Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n\n        ArrayList<Node> nodes = new ArrayList<Node>(children);\n        Node[] nodeArray = nodes.toArray(new Node[nodes.size()]);\n        addChildren(index, nodeArray);\n        return this;\n    }\n    \n    \n    public Element appendElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName), baseUri());\n        appendChild(child);\n        return child;\n    }\n    \n    \n    public Element prependElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName), baseUri());\n        prependChild(child);\n        return child;\n    }\n    \n    \n    public Element appendText(String text) {\n        TextNode node = new TextNode(text, baseUri());\n        appendChild(node);\n        return this;\n    }\n    \n    \n    public Element prependText(String text) {\n        TextNode node = new TextNode(text, baseUri());\n        prependChild(node);\n        return this;\n    }\n    \n    \n    public Element append(String html) {\n        Validate.notNull(html);\n\n        List<Node> nodes = Parser.parseFragment(html, this, baseUri());\n        addChildren(nodes.toArray(new Node[nodes.size()]));\n        return this;\n    }\n    \n    \n    public Element prepend(String html) {\n        Validate.notNull(html);\n        \n        List<Node> nodes = Parser.parseFragment(html, this, baseUri());\n        addChildren(0, nodes.toArray(new Node[nodes.size()]));\n        return this;\n    }\n\n    \n    @Override\n    public Element before(String html) {\n        return (Element) super.before(html);\n    }\n\n    \n    @Override\n    public Element before(Node node) {\n        return (Element) super.before(node);\n    }\n\n    \n    @Override\n    public Element after(String html) {\n        return (Element) super.after(html);\n    }\n\n    \n    @Override\n    public Element after(Node node) {\n        return (Element) super.after(node);\n    }\n\n    \n    public Element empty() {\n        childNodes.clear();\n        return this;\n    }\n\n    \n    @Override\n    public Element wrap(String html) {\n        return (Element) super.wrap(html);\n    }\n\n    \n    public Elements siblingElements() {\n        if (parentNode == null)\n            return new Elements(0);\n\n        List<Element> elements = parent().children();\n        Elements siblings = new Elements(elements.size() - 1);\n        for (Element el: elements)\n            if (el != this)\n                siblings.add(el);\n        return siblings;\n    }\n\n    \n    public Element nextElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().children();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }\n\n    \n    public Element previousElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().children();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }\n\n    \n    public Element firstElementSibling() {\n        \n        List<Element> siblings = parent().children();\n        return siblings.size() > 1 ? siblings.get(0) : null;\n    }\n    \n    \n    public Integer elementSiblingIndex() {\n       if (parent() == null) return 0;\n       return indexInList(this, parent().children()); \n    }\n\n    \n    public Element lastElementSibling() {\n        List<Element> siblings = parent().children();\n        return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;\n    }\n    \n    private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n        Validate.notNull(search);\n        Validate.notNull(elements);\n\n        for (int i = 0; i < elements.size(); i++) {\n            E element = elements.get(i);\n            if (element.equals(search))\n                return i;\n        }\n        return null;\n    }\n\n    \n\n    \n    public Elements getElementsByTag(String tagName) {\n        Validate.notEmpty(tagName);\n        tagName = tagName.toLowerCase().trim();\n\n        return Collector.collect(new Evaluator.Tag(tagName), this);\n    }\n\n    \n    public Element getElementById(String id) {\n        Validate.notEmpty(id);\n        \n        Elements elements = Collector.collect(new Evaluator.Id(id), this);\n        if (elements.size() > 0)\n            return elements.get(0);\n        else\n            return null;\n    }\n\n    \n    public Elements getElementsByClass(String className) {\n        Validate.notEmpty(className);\n\n        return Collector.collect(new Evaluator.Class(className), this);\n    }\n\n    \n    public Elements getElementsByAttribute(String key) {\n        Validate.notEmpty(key);\n        key = key.trim().toLowerCase();\n\n        return Collector.collect(new Evaluator.Attribute(key), this);\n    }\n\n    \n    public Elements getElementsByAttributeStarting(String keyPrefix) {\n        Validate.notEmpty(keyPrefix);\n        keyPrefix = keyPrefix.trim().toLowerCase();\n\n        return Collector.collect(new Evaluator.AttributeStarting(keyPrefix), this);\n    }\n\n    \n    public Elements getElementsByAttributeValue(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValue(key, value), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueNot(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) {\n        return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) {\n        return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this);\n    }\n\n    \n    public Elements getElementsByAttributeValueContaining(String key, String match) {\n        return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this);\n    }\n    \n    \n    public Elements getElementsByAttributeValueMatching(String key, Pattern pattern) {\n        return Collector.collect(new Evaluator.AttributeWithValueMatching(key, pattern), this);\n        \n    }\n    \n    \n    public Elements getElementsByAttributeValueMatching(String key, String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsByAttributeValueMatching(key, pattern);\n    }\n    \n    \n    public Elements getElementsByIndexLessThan(int index) {\n        return Collector.collect(new Evaluator.IndexLessThan(index), this);\n    }\n    \n    \n    public Elements getElementsByIndexGreaterThan(int index) {\n        return Collector.collect(new Evaluator.IndexGreaterThan(index), this);\n    }\n    \n    \n    public Elements getElementsByIndexEquals(int index) {\n        return Collector.collect(new Evaluator.IndexEquals(index), this);\n    }\n    \n    \n    public Elements getElementsContainingText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsText(searchText), this);\n    }\n    \n    \n    public Elements getElementsContainingOwnText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsOwnText(searchText), this);\n    }\n    \n    \n    public Elements getElementsMatchingText(Pattern pattern) {\n        return Collector.collect(new Evaluator.Matches(pattern), this);\n    }\n    \n    \n    public Elements getElementsMatchingText(String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsMatchingText(pattern);\n    }\n    \n    \n    public Elements getElementsMatchingOwnText(Pattern pattern) {\n        return Collector.collect(new Evaluator.MatchesOwn(pattern), this);\n    }\n    \n    \n    public Elements getElementsMatchingOwnText(String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsMatchingOwnText(pattern);\n    }\n    \n    \n    public Elements getAllElements() {\n        return Collector.collect(new Evaluator.AllElements(), this);\n    }\n\n    \n    public String text() {\n        StringBuilder sb = new StringBuilder();\n        text(sb);\n        return sb.toString().trim();\n    }\n\n    private void text(StringBuilder accum) {\n        appendWhitespaceIfBr(this, accum);\n        \n        for (Node child : childNodes) {\n            if (child instanceof TextNode) {\n                TextNode textNode = (TextNode) child;\n                appendNormalisedText(accum, textNode);\n            } else if (child instanceof Element) {\n                Element element = (Element) child;\n                if (accum.length() > 0 && element.isBlock() && !TextNode.lastCharIsWhitespace(accum))\n                    accum.append(\" \");\n                element.text(accum);\n            }\n        }\n    }\n\n    \n    public String ownText() {\n        StringBuilder sb = new StringBuilder();\n        ownText(sb);\n        return sb.toString().trim();\n    }\n\n    private void ownText(StringBuilder accum) {\n        for (Node child : childNodes) {\n            if (child instanceof TextNode) {\n                TextNode textNode = (TextNode) child;\n                appendNormalisedText(accum, textNode);\n            } else if (child instanceof Element) {\n                appendWhitespaceIfBr((Element) child, accum);\n            }\n        }\n    }\n\n    private void appendNormalisedText(StringBuilder accum, TextNode textNode) {\n        String text = textNode.getWholeText();\n\n        if (!preserveWhitespace()) {\n            text = TextNode.normaliseWhitespace(text);\n            if (TextNode.lastCharIsWhitespace(accum))\n                text = TextNode.stripLeadingWhitespace(text);\n        }\n        accum.append(text);\n    }\n\n    private static void appendWhitespaceIfBr(Element element, StringBuilder accum) {\n        if (element.tag.getName().equals(\"br\") && !TextNode.lastCharIsWhitespace(accum))\n            accum.append(\" \");\n    }\n\n    boolean preserveWhitespace() {\n        return tag.preserveWhitespace() || parent() != null && parent().preserveWhitespace();\n    }\n\n    \n    public Element text(String text) {\n        Validate.notNull(text);\n\n        empty();\n        TextNode textNode = new TextNode(text, baseUri);\n        appendChild(textNode);\n\n        return this;\n    }\n\n    \n    public boolean hasText() {\n        for (Node child: childNodes) {\n            if (child instanceof TextNode) {\n                TextNode textNode = (TextNode) child;\n                if (!textNode.isBlank())\n                    return true;\n            } else if (child instanceof Element) {\n                Element el = (Element) child;\n                if (el.hasText())\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    \n    public String data() {\n        StringBuilder sb = new StringBuilder();\n\n        for (Node childNode : childNodes) {\n            if (childNode instanceof DataNode) {\n                DataNode data = (DataNode) childNode;\n                sb.append(data.getWholeData());\n            } else if (childNode instanceof Element) {\n                Element element = (Element) childNode;\n                String elementData = element.data();\n                sb.append(elementData);\n            }\n        }\n        return sb.toString();\n    }   \n\n    \n    public String className() {\n        return attr(\"class\");\n    }\n\n    \n    public Set<String> classNames() {\n        if (classNames == null) {\n            String[] names = className().split(\"\\\\s+\");\n            classNames = new LinkedHashSet<String>(Arrays.asList(names));\n        }\n        return classNames;\n    }\n\n    \n    public Element classNames(Set<String> classNames) {\n        Validate.notNull(classNames);\n        attributes.put(\"class\", StringUtil.join(classNames, \" \"));\n        return this;\n    }\n\n    \n    public boolean hasClass(String className) {\n        Set<String> classNames = classNames();\n        for (String name : classNames) {\n            if (className.equalsIgnoreCase(name))\n                return true;\n        }\n        return false;\n    }\n\n    \n    public Element addClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        classes.add(className);\n        classNames(classes);\n\n        return this;\n    }\n\n    \n    public Element removeClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        classes.remove(className);\n        classNames(classes);\n\n        return this;\n    }\n\n    \n    public Element toggleClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        if (classes.contains(className))\n            classes.remove(className);\n        else\n            classes.add(className);\n        classNames(classes);\n\n        return this;\n    }\n    \n    \n    public String val() {\n        if (tagName().equals(\"textarea\"))\n            return text();\n        else\n            return attr(\"value\");\n    }\n    \n    \n    public Element val(String value) {\n        if (tagName().equals(\"textarea\"))\n            text(value);\n        else\n            attr(\"value\", value);\n        return this;\n    }\n\n    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n        if (accum.length() > 0 && out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock())))\n            indent(accum, depth, out);\n        accum\n                .append(\"<\")\n                .append(tagName());\n        attributes.html(accum, out);\n\n        if (childNodes.isEmpty() && tag.isSelfClosing())\n            accum.append(\" />\");\n        else\n            accum.append(\">\");\n    }\n\n    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {\n        if (!(childNodes.isEmpty() && tag.isSelfClosing())) {\n            if (out.prettyPrint() && !childNodes.isEmpty() && tag.formatAsBlock())\n                indent(accum, depth, out);\n            accum.append(\"</\").append(tagName()).append(\">\");\n        }\n    }\n\n    \n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        html(accum); \n        return accum.toString().trim();\n    }\n\n    private void html(StringBuilder accum) {\n        for (Node node : childNodes)\n            node.outerHtml(accum);\n    }\n    \n    \n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n    public String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        return this == o;\n    }\n\n    @Override\n    public int hashCode() {\n        \n        int result = super.hashCode();\n        result = 31 * result + (tag != null ? tag.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public Element clone() {\n        Element clone = (Element) super.clone();\n        clone.classNames = null; \n        return clone;\n    }\n}\n",
      "buggy_signatures": [
        "public class Element extends Node { private Tag tag; private Set<String> classNames; public Element(Tag tag, String baseUri, Attributes attributes)",
        "public Element(Tag tag, String baseUri)",
        "public String nodeName()",
        "public String tagName()",
        "public Element tagName(String tagName)",
        "public Tag tag()",
        "public boolean isBlock()",
        "public String id()",
        "public Element attr(String attributeKey, String attributeValue)",
        "public Map<String, String> dataset()",
        "public final Element parent()",
        "public Elements parents()",
        "private static void accumulateParents(Element el, Elements parents)",
        "public Element child(int index)",
        "public Elements children()",
        "public List<TextNode> textNodes()",
        "public List<DataNode> dataNodes()",
        "public Elements select(String cssQuery)",
        "public Element appendChild(Node child)",
        "public Element prependChild(Node child)",
        "public Element insertChildren(int index, Collection<? extends Node> children)",
        "public Element appendElement(String tagName)",
        "public Element prependElement(String tagName)",
        "public Element appendText(String text)",
        "public Element prependText(String text)",
        "public Element append(String html)",
        "public Element prepend(String html)",
        "public Element before(String html)",
        "public Element before(Node node)",
        "public Element after(String html)",
        "public Element after(Node node)",
        "public Element empty()",
        "public Element wrap(String html)",
        "public Elements siblingElements()",
        "public Element nextElementSibling()",
        "public Element previousElementSibling()",
        "public Element firstElementSibling()",
        "public Integer elementSiblingIndex()",
        "public Element lastElementSibling()",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements)",
        "public Elements getElementsByTag(String tagName)",
        "public Element getElementById(String id)",
        "public Elements getElementsByClass(String className)",
        "public Elements getElementsByAttribute(String key)",
        "public Elements getElementsByAttributeStarting(String keyPrefix)",
        "public Elements getElementsByAttributeValue(String key, String value)",
        "public Elements getElementsByAttributeValueNot(String key, String value)",
        "public Elements getElementsByAttributeValueStarting(String key, String valuePrefix)",
        "public Elements getElementsByAttributeValueEnding(String key, String valueSuffix)",
        "public Elements getElementsByAttributeValueContaining(String key, String match)",
        "public Elements getElementsByAttributeValueMatching(String key, Pattern pattern)",
        "public Elements getElementsByAttributeValueMatching(String key, String regex)",
        "public Elements getElementsByIndexLessThan(int index)",
        "public Elements getElementsByIndexGreaterThan(int index)",
        "public Elements getElementsByIndexEquals(int index)",
        "public Elements getElementsContainingText(String searchText)",
        "public Elements getElementsContainingOwnText(String searchText)",
        "public Elements getElementsMatchingText(Pattern pattern)",
        "public Elements getElementsMatchingText(String regex)",
        "public Elements getElementsMatchingOwnText(Pattern pattern)",
        "public Elements getElementsMatchingOwnText(String regex)",
        "public Elements getAllElements()",
        "public String text()",
        "private void text(StringBuilder accum)",
        "public String ownText()",
        "private void ownText(StringBuilder accum)",
        "private void appendNormalisedText(StringBuilder accum, TextNode textNode)",
        "private static void appendWhitespaceIfBr(Element element, StringBuilder accum)",
        "public Element text(String text)",
        "public boolean hasText()",
        "public String data()",
        "public String className()",
        "public Set<String> classNames()",
        "public Element classNames(Set<String> classNames)",
        "public boolean hasClass(String className)",
        "public Element addClass(String className)",
        "public Element removeClass(String className)",
        "public Element toggleClass(String className)",
        "public String val()",
        "public Element val(String value)",
        "public String html()",
        "private void html(StringBuilder accum)",
        "public Element html(String html)",
        "public String toString()",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "public Element clone()"
      ],
      "fixed_signatures": [
        "public class Element extends Node { private Tag tag; private Set<String> classNames; public Element(Tag tag, String baseUri, Attributes attributes)",
        "public Element(Tag tag, String baseUri)",
        "public String nodeName()",
        "public String tagName()",
        "public Element tagName(String tagName)",
        "public Tag tag()",
        "public boolean isBlock()",
        "public String id()",
        "public Element attr(String attributeKey, String attributeValue)",
        "public Map<String, String> dataset()",
        "public final Element parent()",
        "public Elements parents()",
        "private static void accumulateParents(Element el, Elements parents)",
        "public Element child(int index)",
        "public Elements children()",
        "public List<TextNode> textNodes()",
        "public List<DataNode> dataNodes()",
        "public Elements select(String cssQuery)",
        "public Element appendChild(Node child)",
        "public Element prependChild(Node child)",
        "public Element insertChildren(int index, Collection<? extends Node> children)",
        "public Element appendElement(String tagName)",
        "public Element prependElement(String tagName)",
        "public Element appendText(String text)",
        "public Element prependText(String text)",
        "public Element append(String html)",
        "public Element prepend(String html)",
        "public Element before(String html)",
        "public Element before(Node node)",
        "public Element after(String html)",
        "public Element after(Node node)",
        "public Element empty()",
        "public Element wrap(String html)",
        "public Elements siblingElements()",
        "public Element nextElementSibling()",
        "public Element previousElementSibling()",
        "public Element firstElementSibling()",
        "public Integer elementSiblingIndex()",
        "public Element lastElementSibling()",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements)",
        "public Elements getElementsByTag(String tagName)",
        "public Element getElementById(String id)",
        "public Elements getElementsByClass(String className)",
        "public Elements getElementsByAttribute(String key)",
        "public Elements getElementsByAttributeStarting(String keyPrefix)",
        "public Elements getElementsByAttributeValue(String key, String value)",
        "public Elements getElementsByAttributeValueNot(String key, String value)",
        "public Elements getElementsByAttributeValueStarting(String key, String valuePrefix)",
        "public Elements getElementsByAttributeValueEnding(String key, String valueSuffix)",
        "public Elements getElementsByAttributeValueContaining(String key, String match)",
        "public Elements getElementsByAttributeValueMatching(String key, Pattern pattern)",
        "public Elements getElementsByAttributeValueMatching(String key, String regex)",
        "public Elements getElementsByIndexLessThan(int index)",
        "public Elements getElementsByIndexGreaterThan(int index)",
        "public Elements getElementsByIndexEquals(int index)",
        "public Elements getElementsContainingText(String searchText)",
        "public Elements getElementsContainingOwnText(String searchText)",
        "public Elements getElementsMatchingText(Pattern pattern)",
        "public Elements getElementsMatchingText(String regex)",
        "public Elements getElementsMatchingOwnText(Pattern pattern)",
        "public Elements getElementsMatchingOwnText(String regex)",
        "public Elements getAllElements()",
        "public String text()",
        "private void text(StringBuilder accum)",
        "public String ownText()",
        "private void ownText(StringBuilder accum)",
        "private void appendNormalisedText(StringBuilder accum, TextNode textNode)",
        "private static void appendWhitespaceIfBr(Element element, StringBuilder accum)",
        "public Element text(String text)",
        "public boolean hasText()",
        "public String data()",
        "public String className()",
        "public Set<String> classNames()",
        "public Element classNames(Set<String> classNames)",
        "public boolean hasClass(String className)",
        "public Element addClass(String className)",
        "public Element removeClass(String className)",
        "public Element toggleClass(String className)",
        "public String val()",
        "public Element val(String value)",
        "public String html()",
        "private void html(StringBuilder accum)",
        "public Element html(String html)",
        "public String toString()",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "public Element clone()"
      ],
      "methods": [
        {
          "buggy_method": "  public Element clone() {\n  Element clone = (Element) super.clone();\n  clone.classNames();\n  return clone;\n  }",
          "fixed_method": "  public Element clone() {\n  Element clone = (Element) super.clone();\n  clone.classNames = null; \n  return clone;\n  }",
          "diff": [
            "@@ -1135,7 +1135,7 @@",
            "     @Override\n",
            "     public Element clone() {\n",
            "         Element clone = (Element) super.clone();\n",
            "-        clone.classNames();\n",
            "+        clone.classNames = null; // derived on first hit, otherwise gets a pointer to source classnames\n",
            "         return clone;\n",
            "     }\n",
            " }\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
