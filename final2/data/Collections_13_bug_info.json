{
  "bug_id": "13",
  "failed_tests": {
    "org.apache.commons.collections.TestExtendedProperties": [
      {
        "methodName": "testCollections299",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "        ExtendedProperties extended = ExtendedProperties.convertProperties(properties);",
        "test_source": "  public void testCollections299() {\n  Properties defaults = new Properties();\n  defaults.put(\"objectTrue\", Boolean.TRUE);\n\n  Properties properties = new Properties(defaults);\n  properties.put(\"objectFalse\", Boolean.FALSE);\n\n  ExtendedProperties extended = ExtendedProperties.convertProperties(properties);\n\n  assertNull(extended.getString(\"objectTrue\"));\n  assertNull(extended.getString(\"objectFalse\"));\n\n  assertNull(extended.get(\"objectTrue\"));\n  assertNull(extended.get(\"objectFalse\"));\n  }",
        "stack": [
          "ExtendedProperties.addPropertyInternal line 749, ExtendedProperties.addProperty line 697, ExtendedProperties.setProperty line 763, ExtendedProperties.convertProperties line 1724, TestExtendedProperties.testCollections299 line 438"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/collections/ExtendedProperties.java",
      "buggy_full_code": "\npackage org.apache.commons.collections;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\n\npublic class ExtendedProperties extends Hashtable { private ExtendedProperties defaults; protected String file; protected String basePath; protected String fileSeparator = System.getProperty(\"file.separator\"); protected boolean isInitialized = false; private String includePropertyName = null; protected static String include = \"include\"; protected ArrayList keysAsListed = new ArrayList(); protected final static String START_TOKEN=\"$ {\";\n    protected final static String END_TOKEN=\"}\"; protected String interpolate(String base) {\n        \n        return (interpolateHelper(base, null));\n    }\n\n    \n    protected String interpolateHelper(String base, List priorVariables) {\n        \n        if (base == null) {\n            return null;\n        }\n\n        \n        \n        if (priorVariables == null) {\n            priorVariables = new ArrayList();\n            priorVariables.add(base);\n        }\n\n        int begin = -1;\n        int end = -1;\n        int prec = 0 - END_TOKEN.length();\n        String variable = null;\n        StringBuffer result = new StringBuffer();\n\n        \n        while (((begin = base.indexOf(START_TOKEN, prec + END_TOKEN.length())) > -1)\n            && ((end = base.indexOf(END_TOKEN, begin)) > -1)) {\n            result.append(base.substring(prec + END_TOKEN.length(), begin));\n            variable = base.substring(begin + START_TOKEN.length(), end);\n\n            \n            if (priorVariables.contains(variable)) {\n                String initialBase = priorVariables.remove(0).toString();\n                priorVariables.add(variable);\n                StringBuffer priorVariableSb = new StringBuffer();\n\n                \n                \n                for (Iterator it = priorVariables.iterator(); it.hasNext();) {\n                    priorVariableSb.append(it.next());\n                    if (it.hasNext()) {\n                        priorVariableSb.append(\"->\");\n                    }\n                }\n\n                throw new IllegalStateException(\n                    \"infinite loop in property interpolation of \" + initialBase + \": \" + priorVariableSb.toString());\n            }\n            \n            else {\n                priorVariables.add(variable);\n            }\n\n            \n            Object value = getProperty(variable);\n            if (value != null) {\n                result.append(interpolateHelper(value.toString(), priorVariables));\n\n                \n                \n                \n                \n                priorVariables.remove(priorVariables.size() - 1);\n            } else if (defaults != null && defaults.getString(variable, null) != null) {\n                result.append(defaults.getString(variable));\n            } else {\n                \n                result.append(START_TOKEN).append(variable).append(END_TOKEN);\n            }\n            prec = end;\n        }\n        result.append(base.substring(prec + END_TOKEN.length(), base.length()));\n\n        return result.toString();\n    }\n    \n    \n    private static String escape(String s) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = 0; i < buf.length(); i++) {\n            char c = buf.charAt(i);\n            if (c == ',' || c == '\\\\') {\n                buf.insert(i, '\\\\');\n                i++;\n            }\n        }\n        return buf.toString();\n    }\n    \n    \n    private static String unescape(String s) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = 0; i < buf.length() - 1; i++) {\n            char c1 = buf.charAt(i);\n            char c2 = buf.charAt(i + 1);\n            if (c1 == '\\\\' && c2 == '\\\\') {\n                buf.deleteCharAt(i);\n            }\n        }\n        return buf.toString();\n    }\n\n    \n    private static int countPreceding(String line, int index, char ch) {\n        int i;\n        for (i = index - 1; i >= 0; i--) {\n            if (line.charAt(i) != ch) {\n                break;\n            }\n        }\n        return index - 1 - i;\n    }\n\n    \n    private static boolean endsWithSlash(String line) {\n        if (!line.endsWith(\"\\\\\")) {\n            return false;\n        }\n        return (countPreceding(line, line.length() - 1, '\\\\') % 2 == 0);\n    }\n\n    \n    static class PropertiesReader extends LineNumberReader { public PropertiesReader(Reader reader) {\n            super(reader);\n        }\n\n        \n        public String readProperty() throws IOException {\n            StringBuffer buffer = new StringBuffer();\n            String line = readLine();\n            while (line != null) {\n                line = line.trim();\n                if ((line.length() != 0) && (line.charAt(0) != '#')) {\n                    if (endsWithSlash(line)) {\n                        line = line.substring(0, line.length() - 1);\n                        buffer.append(line);\n                    } else {\n                        buffer.append(line);\n                        return buffer.toString();  \n                    }\n                }\n                line = readLine();\n            }\n            return null;  \n        }\n    }\n\n    \n    static class PropertiesTokenizer extends StringTokenizer { static final String DELIMITER = \",\"; public PropertiesTokenizer(String string) {\n            super(string, DELIMITER);\n        }\n\n        \n        public boolean hasMoreTokens() {\n            return super.hasMoreTokens();\n        }\n\n        \n        public String nextToken() {\n            StringBuffer buffer = new StringBuffer();\n\n            while (hasMoreTokens()) {\n                String token = super.nextToken();\n                if (endsWithSlash(token)) {\n                    buffer.append(token.substring(0, token.length() - 1));\n                    buffer.append(DELIMITER);\n                } else {\n                    buffer.append(token);\n                    break;\n                }\n            }\n\n            return buffer.toString().trim();\n        }\n    }\n\n    \n    public ExtendedProperties() {\n        super();\n    }\n\n    \n    public ExtendedProperties(String file) throws IOException {\n        this(file, null);\n    }\n\n    \n    public ExtendedProperties(String file, String defaultFile) throws IOException {\n        this.file = file;\n\n        basePath = new File(file).getAbsolutePath();\n        basePath = basePath.substring(0, basePath.lastIndexOf(fileSeparator) + 1);\n\n        FileInputStream in = null;\n        try {\n            in = new FileInputStream(file);\n            this.load(in);\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException ex) {}\n        }\n\n        if (defaultFile != null) {\n            defaults = new ExtendedProperties(defaultFile);\n        }\n    }\n\n    \n    public boolean isInitialized() {\n        return isInitialized;\n    }\n\n    \n    public String getInclude() {\n        if (includePropertyName == null) {\n            return include;  \n        }\n        if (\"\".equals(includePropertyName)) {\n            return null;  \n        }\n        return includePropertyName;\n    }\n\n    \n    public void setInclude(String inc) {\n        if (inc == null) {\n            inc = \"\";  \n        }\n        includePropertyName = inc;\n    }\n\n    \n    public void load(InputStream input) throws IOException {\n        load(input, null);\n    }\n\n    \n    public synchronized void load(InputStream input, String enc) throws IOException {\n        PropertiesReader reader = null;\n        if (enc != null) {\n            try {\n                reader = new PropertiesReader(new InputStreamReader(input, enc));\n                \n            } catch (UnsupportedEncodingException ex) {\n                \n            }\n        }\n        \n        if (reader == null) {\n            try {\n                reader = new PropertiesReader(new InputStreamReader(input, \"8859_1\"));\n                \n            } catch (UnsupportedEncodingException ex) {\n                \n                \n                reader = new PropertiesReader(new InputStreamReader(input));\n            }\n        }\n\n        try {\n            String includeProperty = getInclude();\n            while (true) {\n                String line = reader.readProperty();\n                if (line == null) {\n                    return;  \n                }\n                int equalSign = line.indexOf('=');\n\n                if (equalSign > 0) {\n                    String key = line.substring(0, equalSign).trim();\n                    String value = line.substring(equalSign + 1).trim();\n\n                    \n\n                    if (includeProperty != null && key.equalsIgnoreCase(includeProperty)) {\n                        \n                        File file = null;\n\n                        if (value.startsWith(fileSeparator)) {\n                            \n                            file = new File(value);\n                            \n                        } else {\n                            \n                            \n                            \n                            if (value.startsWith(\".\" + fileSeparator)) {\n                                value = value.substring(2);\n                            }\n\n                            file = new File(basePath + value);\n                        }\n\n                        if (file != null && file.exists() && file.canRead()) {\n                            load(new FileInputStream(file));\n                        }\n                    } else {\n                        addProperty(key, value);\n                    }\n                }\n            }\n        } finally {\n            \n            isInitialized = true;\n        }\n    }\n\n    \n    public Object getProperty(String key) {\n        \n        Object obj = super.get(key);\n\n        if (obj == null) {\n            \n            \n            if (defaults != null) {\n                obj = defaults.get(key);\n            }\n        }\n\n        return obj;\n    }\n    \n    \n    public void addProperty(String key, Object value) {\n        if (value instanceof String) {\n            String str = (String) value;\n            if (str.indexOf(PropertiesTokenizer.DELIMITER) > 0) {\n                \n                PropertiesTokenizer tokenizer = new PropertiesTokenizer(str);\n                while (tokenizer.hasMoreTokens()) {\n                    String token = tokenizer.nextToken();\n                    addPropertyInternal(key, unescape(token));\n                }\n            } else {\n                \n                addPropertyInternal(key, unescape(str));\n            }\n        } else {\n            addPropertyInternal(key, value);\n        }\n\n        \n        isInitialized = true;\n    }\n\n    \n    private void addPropertyDirect(String key, Object value) {\n        \n        if (!containsKey(key)) {\n            keysAsListed.add(key);\n        }\n        super.put(key, value);\n    }\n\n    \n    private void addPropertyInternal(String key, Object value) {\n        Object current = this.get(key);\n\n        if (current instanceof String) {\n            \n            List values = new Vector(2);\n            values.add(current);\n            values.add(value);\n            super.put(key, values);\n            \n        } else if (current instanceof List) {\n            \n            ((List) current).add(value);\n            \n        } else {\n            \n            if (!containsKey(key)) {\n                keysAsListed.add(key);\n            }\n            super.put(key, value);\n        }\n    }\n\n    \n    public void setProperty(String key, Object value) {\n        clearProperty(key);\n        addProperty(key, value);\n    }\n    \n    \n    public synchronized void save(OutputStream output, String header) throws IOException {\n        if (output == null) {\n            return;\n        }\n        PrintWriter theWrtr = new PrintWriter(output);\n        if (header != null) {\n            theWrtr.println(header);\n        }\n        \n        Enumeration theKeys = keys();\n        while (theKeys.hasMoreElements()) {\n            String key = (String) theKeys.nextElement();\n            Object value = get(key);\n            if (value != null) {\n                if (value instanceof String) {\n                    StringBuffer currentOutput = new StringBuffer();\n                    currentOutput.append(key);\n                    currentOutput.append(\"=\");\n                    currentOutput.append(escape((String) value));\n                    theWrtr.println(currentOutput.toString());\n                    \n                } else if (value instanceof List) {\n                    List values = (List) value;\n                    for (Iterator it = values.iterator(); it.hasNext(); ) {\n                        String currentElement = (String) it.next();\n                        StringBuffer currentOutput = new StringBuffer();\n                        currentOutput.append(key);\n                        currentOutput.append(\"=\");\n                        currentOutput.append(escape(currentElement));\n                        theWrtr.println(currentOutput.toString());\n                    }\n                }\n            }\n            theWrtr.println();\n            theWrtr.flush();\n        }\n    }\n\n    \n    public void combine(ExtendedProperties props) {\n        for (Iterator it = props.getKeys(); it.hasNext();) {\n            String key = (String) it.next();\n            clearProperty(key);\n            addPropertyDirect(key, props.get(key));\n        }\n    }\n    \n    \n    public void clearProperty(String key) {\n        if (containsKey(key)) {\n            \n            \n            for (int i = 0; i < keysAsListed.size(); i++) {\n                if (( keysAsListed.get(i)).equals(key)) {\n                    keysAsListed.remove(i);\n                    break;\n                }\n            }\n            super.remove(key);\n        }\n    }\n\n    \n    public Iterator getKeys() {\n        return keysAsListed.iterator();\n    }\n\n    \n    public Iterator getKeys(String prefix) {\n        Iterator keys = getKeys();\n        ArrayList matchingKeys = new ArrayList();\n\n        while (keys.hasNext()) {\n            Object key = keys.next();\n\n            if (key instanceof String && ((String) key).startsWith(prefix)) {\n                matchingKeys.add(key);\n            }\n        }\n        return matchingKeys.iterator();\n    }\n\n    \n    public ExtendedProperties subset(String prefix) {\n        ExtendedProperties c = new ExtendedProperties();\n        Iterator keys = getKeys();\n        boolean validSubset = false;\n\n        while (keys.hasNext()) {\n            Object key = keys.next();\n\n            if (key instanceof String && ((String) key).startsWith(prefix)) {\n                if (!validSubset) {\n                    validSubset = true;\n                }\n\n                \n                String newKey = null;\n                if (((String) key).length() == prefix.length()) {\n                    newKey = prefix;\n                } else {\n                    newKey = ((String) key).substring(prefix.length() + 1);\n                }\n\n                \n                c.addPropertyDirect(newKey, get(key));\n            }\n        }\n\n        if (validSubset) {\n            return c;\n        } else {\n            return null;\n        }\n    }\n\n    \n    public void display() {\n        Iterator i = getKeys();\n\n        while (i.hasNext()) {\n            String key = (String) i.next();\n            Object value = get(key);\n            System.out.println(key + \" => \" + value);\n        }\n    }\n\n    \n    public String getString(String key) {\n        return getString(key, null);\n    }\n\n    \n    public String getString(String key, String defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof String) {\n            return interpolate((String) value);\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return interpolate(defaults.getString(key, defaultValue));\n            } else {\n                return interpolate(defaultValue);\n            }\n        } else if (value instanceof List) {\n            return interpolate((String) ((List) value).get(0));\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a String object\");\n        }\n    }\n\n    \n    public Properties getProperties(String key) {\n        return getProperties(key, new Properties());\n    }\n\n    \n    public Properties getProperties(String key, Properties defaults) {\n        \n        String[] tokens = getStringArray(key);\n\n        \n        Properties props = new Properties(defaults);\n        for (int i = 0; i < tokens.length; i++) {\n            String token = tokens[i];\n            int equalSign = token.indexOf('=');\n            if (equalSign > 0) {\n                String pkey = token.substring(0, equalSign).trim();\n                String pvalue = token.substring(equalSign + 1).trim();\n                props.put(pkey, pvalue);\n            } else {\n                throw new IllegalArgumentException('\\'' + token + \"' does not contain \" + \"an equals sign\");\n            }\n        }\n        return props;\n    }\n\n    \n    public String[] getStringArray(String key) {\n        Object value = get(key);\n\n        List values;\n        if (value instanceof String) {\n            values = new Vector(1);\n            values.add(value);\n            \n        } else if (value instanceof List) {\n            values = (List) value;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getStringArray(key);\n            } else {\n                return new String[0];\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a String/List object\");\n        }\n\n        String[] tokens = new String[values.size()];\n        for (int i = 0; i < tokens.length; i++) {\n            tokens[i] = (String) values.get(i);\n        }\n\n        return tokens;\n    }\n\n    \n    public Vector getVector(String key) {\n        return getVector(key, null);\n    }\n\n    \n    public Vector getVector(String key, Vector defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof List) {\n            return new Vector((List) value);\n            \n        } else if (value instanceof String) {\n            Vector values = new Vector(1);\n            values.add(value);\n            super.put(key, values);\n            return values;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getVector(key, defaultValue);\n            } else {\n                return ((defaultValue == null) ? new Vector() : defaultValue);\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Vector object\");\n        }\n    }\n\n    \n    public List getList(String key) {\n        return getList(key, null);\n    }\n\n    \n    public List getList(String key, List defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof List) {\n            return new ArrayList((List) value);\n            \n        } else if (value instanceof String) {\n            List values = new ArrayList(1);\n            values.add(value);\n            super.put(key, values);\n            return values;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getList(key, defaultValue);\n            } else {\n                return ((defaultValue == null) ? new ArrayList() : defaultValue);\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a List object\");\n        }\n    }\n\n    \n    public boolean getBoolean(String key) {\n        Boolean b = getBoolean(key, null);\n        if (b != null) {\n            return b.booleanValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    \n    public boolean getBoolean(String key, boolean defaultValue) {\n        return getBoolean(key, new Boolean(defaultValue)).booleanValue();\n    }\n\n    \n    public Boolean getBoolean(String key, Boolean defaultValue) {\n\n        Object value = get(key);\n\n        if (value instanceof Boolean) {\n            return (Boolean) value;\n            \n        } else if (value instanceof String) {\n            String s = testBoolean((String) value);\n            Boolean b = new Boolean(s);\n            super.put(key, b);\n            return b;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getBoolean(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Boolean object\");\n        }\n    }\n\n    \n    public String testBoolean(String value) {\n        String s = value.toLowerCase(Locale.ENGLISH);\n\n        if (s.equals(\"true\") || s.equals(\"on\") || s.equals(\"yes\")) {\n            return \"true\";\n        } else if (s.equals(\"false\") || s.equals(\"off\") || s.equals(\"no\")) {\n            return \"false\";\n        } else {\n            return null;\n        }\n    }\n\n    \n    public byte getByte(String key) {\n        Byte b = getByte(key, null);\n        if (b != null) {\n            return b.byteValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \" doesn't map to an existing object\");\n        }\n    }\n\n    \n    public byte getByte(String key, byte defaultValue) {\n        return getByte(key, new Byte(defaultValue)).byteValue();\n    }\n\n    \n    public Byte getByte(String key, Byte defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Byte) {\n            return (Byte) value;\n            \n        } else if (value instanceof String) {\n            Byte b = new Byte((String) value);\n            super.put(key, b);\n            return b;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getByte(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Byte object\");\n        }\n    }\n\n    \n    public short getShort(String key) {\n        Short s = getShort(key, null);\n        if (s != null) {\n            return s.shortValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    \n    public short getShort(String key, short defaultValue) {\n        return getShort(key, new Short(defaultValue)).shortValue();\n    }\n\n    \n    public Short getShort(String key, Short defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Short) {\n            return (Short) value;\n            \n        } else if (value instanceof String) {\n            Short s = new Short((String) value);\n            super.put(key, s);\n            return s;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getShort(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Short object\");\n        }\n    }\n\n    \n    public int getInt(String name) {\n        return getInteger(name);\n    }\n\n    \n    public int getInt(String name, int def) {\n        return getInteger(name, def);\n    }\n\n    \n    public int getInteger(String key) {\n        Integer i = getInteger(key, null);\n        if (i != null) {\n            return i.intValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    \n    public int getInteger(String key, int defaultValue) {\n        Integer i = getInteger(key, null);\n\n        if (i == null) {\n            return defaultValue;\n        }\n        return i.intValue();\n    }\n\n    \n    public Integer getInteger(String key, Integer defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Integer) {\n            return (Integer) value;\n            \n        } else if (value instanceof String) {\n            Integer i = new Integer((String) value);\n            super.put(key, i);\n            return i;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getInteger(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Integer object\");\n        }\n    }\n\n    \n    public long getLong(String key) {\n        Long l = getLong(key, null);\n        if (l != null) {\n            return l.longValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    \n    public long getLong(String key, long defaultValue) {\n        return getLong(key, new Long(defaultValue)).longValue();\n    }\n\n    \n    public Long getLong(String key, Long defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Long) {\n            return (Long) value;\n            \n        } else if (value instanceof String) {\n            Long l = new Long((String) value);\n            super.put(key, l);\n            return l;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getLong(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Long object\");\n        }\n    }\n\n    \n    public float getFloat(String key) {\n        Float f = getFloat(key, null);\n        if (f != null) {\n            return f.floatValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    \n    public float getFloat(String key, float defaultValue) {\n        return getFloat(key, new Float(defaultValue)).floatValue();\n    }\n\n    \n    public Float getFloat(String key, Float defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Float) {\n            return (Float) value;\n            \n        } else if (value instanceof String) {\n            Float f = new Float((String) value);\n            super.put(key, f);\n            return f;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getFloat(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Float object\");\n        }\n    }\n\n    \n    public double getDouble(String key) {\n        Double d = getDouble(key, null);\n        if (d != null) {\n            return d.doubleValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    \n    public double getDouble(String key, double defaultValue) {\n        return getDouble(key, new Double(defaultValue)).doubleValue();\n    }\n\n    \n    public Double getDouble(String key, Double defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Double) {\n            return (Double) value;\n            \n        } else if (value instanceof String) {\n            Double d = new Double((String) value);\n            super.put(key, d);\n            return d;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getDouble(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Double object\");\n        }\n    }\n\n    \n    public static ExtendedProperties convertProperties(Properties props) {\n        ExtendedProperties c = new ExtendedProperties();\n\n        for (Enumeration e = props.propertyNames(); e.hasMoreElements();) {\n            String s = (String) e.nextElement();\n            c.setProperty(s, props.getProperty(s));\n        }\n\n        return c;\n    }\n\n    \n    public Object put(Object key, Object value) {\n        String strKey = String.valueOf(key);\n        Object ret = getProperty(strKey);\n        addProperty(strKey, value);\n        return ret;\n    }\n\n    \n    public void putAll(Map map) {\n        if (map instanceof ExtendedProperties) {\n            for (Iterator it = ((ExtendedProperties) map).getKeys(); it.hasNext(); ) {\n                Object key = it.next();\n                put(key, map.get(key));\n            }\n        } else {\n            for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) {\n                Map.Entry entry = (Map.Entry) it.next();\n                put(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n\n    \n    public Object remove(Object key) {\n        String strKey = String.valueOf(key);\n        Object ret = getProperty(strKey);\n        clearProperty(strKey);\n        return ret;\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.collections;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\n\npublic class ExtendedProperties extends Hashtable { private ExtendedProperties defaults; protected String file; protected String basePath; protected String fileSeparator = System.getProperty(\"file.separator\"); protected boolean isInitialized = false; private String includePropertyName = null; protected static String include = \"include\"; protected ArrayList keysAsListed = new ArrayList(); protected final static String START_TOKEN=\"$ {\";\n    protected final static String END_TOKEN=\"}\"; protected String interpolate(String base) {\n        \n        return (interpolateHelper(base, null));\n    }\n\n    \n    protected String interpolateHelper(String base, List priorVariables) {\n        \n        if (base == null) {\n            return null;\n        }\n\n        \n        \n        if (priorVariables == null) {\n            priorVariables = new ArrayList();\n            priorVariables.add(base);\n        }\n\n        int begin = -1;\n        int end = -1;\n        int prec = 0 - END_TOKEN.length();\n        String variable = null;\n        StringBuffer result = new StringBuffer();\n\n        \n        while (((begin = base.indexOf(START_TOKEN, prec + END_TOKEN.length())) > -1)\n            && ((end = base.indexOf(END_TOKEN, begin)) > -1)) {\n            result.append(base.substring(prec + END_TOKEN.length(), begin));\n            variable = base.substring(begin + START_TOKEN.length(), end);\n\n            \n            if (priorVariables.contains(variable)) {\n                String initialBase = priorVariables.remove(0).toString();\n                priorVariables.add(variable);\n                StringBuffer priorVariableSb = new StringBuffer();\n\n                \n                \n                for (Iterator it = priorVariables.iterator(); it.hasNext();) {\n                    priorVariableSb.append(it.next());\n                    if (it.hasNext()) {\n                        priorVariableSb.append(\"->\");\n                    }\n                }\n\n                throw new IllegalStateException(\n                    \"infinite loop in property interpolation of \" + initialBase + \": \" + priorVariableSb.toString());\n            }\n            \n            else {\n                priorVariables.add(variable);\n            }\n\n            \n            Object value = getProperty(variable);\n            if (value != null) {\n                result.append(interpolateHelper(value.toString(), priorVariables));\n\n                \n                \n                \n                \n                priorVariables.remove(priorVariables.size() - 1);\n            } else if (defaults != null && defaults.getString(variable, null) != null) {\n                result.append(defaults.getString(variable));\n            } else {\n                \n                result.append(START_TOKEN).append(variable).append(END_TOKEN);\n            }\n            prec = end;\n        }\n        result.append(base.substring(prec + END_TOKEN.length(), base.length()));\n\n        return result.toString();\n    }\n    \n    \n    private static String escape(String s) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = 0; i < buf.length(); i++) {\n            char c = buf.charAt(i);\n            if (c == ',' || c == '\\\\') {\n                buf.insert(i, '\\\\');\n                i++;\n            }\n        }\n        return buf.toString();\n    }\n    \n    \n    private static String unescape(String s) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = 0; i < buf.length() - 1; i++) {\n            char c1 = buf.charAt(i);\n            char c2 = buf.charAt(i + 1);\n            if (c1 == '\\\\' && c2 == '\\\\') {\n                buf.deleteCharAt(i);\n            }\n        }\n        return buf.toString();\n    }\n\n    \n    private static int countPreceding(String line, int index, char ch) {\n        int i;\n        for (i = index - 1; i >= 0; i--) {\n            if (line.charAt(i) != ch) {\n                break;\n            }\n        }\n        return index - 1 - i;\n    }\n\n    \n    private static boolean endsWithSlash(String line) {\n        if (!line.endsWith(\"\\\\\")) {\n            return false;\n        }\n        return (countPreceding(line, line.length() - 1, '\\\\') % 2 == 0);\n    }\n\n    \n    static class PropertiesReader extends LineNumberReader { public PropertiesReader(Reader reader) {\n            super(reader);\n        }\n\n        \n        public String readProperty() throws IOException {\n            StringBuffer buffer = new StringBuffer();\n            String line = readLine();\n            while (line != null) {\n                line = line.trim();\n                if ((line.length() != 0) && (line.charAt(0) != '#')) {\n                    if (endsWithSlash(line)) {\n                        line = line.substring(0, line.length() - 1);\n                        buffer.append(line);\n                    } else {\n                        buffer.append(line);\n                        return buffer.toString();  \n                    }\n                }\n                line = readLine();\n            }\n            return null;  \n        }\n    }\n\n    \n    static class PropertiesTokenizer extends StringTokenizer { static final String DELIMITER = \",\"; public PropertiesTokenizer(String string) {\n            super(string, DELIMITER);\n        }\n\n        \n        public boolean hasMoreTokens() {\n            return super.hasMoreTokens();\n        }\n\n        \n        public String nextToken() {\n            StringBuffer buffer = new StringBuffer();\n\n            while (hasMoreTokens()) {\n                String token = super.nextToken();\n                if (endsWithSlash(token)) {\n                    buffer.append(token.substring(0, token.length() - 1));\n                    buffer.append(DELIMITER);\n                } else {\n                    buffer.append(token);\n                    break;\n                }\n            }\n\n            return buffer.toString().trim();\n        }\n    }\n\n    \n    public ExtendedProperties() {\n        super();\n    }\n\n    \n    public ExtendedProperties(String file) throws IOException {\n        this(file, null);\n    }\n\n    \n    public ExtendedProperties(String file, String defaultFile) throws IOException {\n        this.file = file;\n\n        basePath = new File(file).getAbsolutePath();\n        basePath = basePath.substring(0, basePath.lastIndexOf(fileSeparator) + 1);\n\n        FileInputStream in = null;\n        try {\n            in = new FileInputStream(file);\n            this.load(in);\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException ex) {}\n        }\n\n        if (defaultFile != null) {\n            defaults = new ExtendedProperties(defaultFile);\n        }\n    }\n\n    \n    public boolean isInitialized() {\n        return isInitialized;\n    }\n\n    \n    public String getInclude() {\n        if (includePropertyName == null) {\n            return include;  \n        }\n        if (\"\".equals(includePropertyName)) {\n            return null;  \n        }\n        return includePropertyName;\n    }\n\n    \n    public void setInclude(String inc) {\n        if (inc == null) {\n            inc = \"\";  \n        }\n        includePropertyName = inc;\n    }\n\n    \n    public void load(InputStream input) throws IOException {\n        load(input, null);\n    }\n\n    \n    public synchronized void load(InputStream input, String enc) throws IOException {\n        PropertiesReader reader = null;\n        if (enc != null) {\n            try {\n                reader = new PropertiesReader(new InputStreamReader(input, enc));\n                \n            } catch (UnsupportedEncodingException ex) {\n                \n            }\n        }\n        \n        if (reader == null) {\n            try {\n                reader = new PropertiesReader(new InputStreamReader(input, \"8859_1\"));\n                \n            } catch (UnsupportedEncodingException ex) {\n                \n                \n                reader = new PropertiesReader(new InputStreamReader(input));\n            }\n        }\n\n        try {\n            String includeProperty = getInclude();\n            while (true) {\n                String line = reader.readProperty();\n                if (line == null) {\n                    return;  \n                }\n                int equalSign = line.indexOf('=');\n\n                if (equalSign > 0) {\n                    String key = line.substring(0, equalSign).trim();\n                    String value = line.substring(equalSign + 1).trim();\n\n                    \n\n                    if (includeProperty != null && key.equalsIgnoreCase(includeProperty)) {\n                        \n                        File file = null;\n\n                        if (value.startsWith(fileSeparator)) {\n                            \n                            file = new File(value);\n                            \n                        } else {\n                            \n                            \n                            \n                            if (value.startsWith(\".\" + fileSeparator)) {\n                                value = value.substring(2);\n                            }\n\n                            file = new File(basePath + value);\n                        }\n\n                        if (file != null && file.exists() && file.canRead()) {\n                            load(new FileInputStream(file));\n                        }\n                    } else {\n                        addProperty(key, value);\n                    }\n                }\n            }\n        } finally {\n            \n            isInitialized = true;\n        }\n    }\n\n    \n    public Object getProperty(String key) {\n        \n        Object obj = super.get(key);\n\n        if (obj == null) {\n            \n            \n            if (defaults != null) {\n                obj = defaults.get(key);\n            }\n        }\n\n        return obj;\n    }\n    \n    \n    public void addProperty(String key, Object value) {\n        if (value instanceof String) {\n            String str = (String) value;\n            if (str.indexOf(PropertiesTokenizer.DELIMITER) > 0) {\n                \n                PropertiesTokenizer tokenizer = new PropertiesTokenizer(str);\n                while (tokenizer.hasMoreTokens()) {\n                    String token = tokenizer.nextToken();\n                    addPropertyInternal(key, unescape(token));\n                }\n            } else {\n                \n                addPropertyInternal(key, unescape(str));\n            }\n        } else {\n            addPropertyInternal(key, value);\n        }\n\n        \n        isInitialized = true;\n    }\n\n    \n    private void addPropertyDirect(String key, Object value) {\n        \n        if (!containsKey(key)) {\n            keysAsListed.add(key);\n        }\n        super.put(key, value);\n    }\n\n    \n    private void addPropertyInternal(String key, Object value) {\n        Object current = this.get(key);\n\n        if (current instanceof String) {\n            \n            List values = new Vector(2);\n            values.add(current);\n            values.add(value);\n            super.put(key, values);\n            \n        } else if (current instanceof List) {\n            \n            ((List) current).add(value);\n            \n        } else {\n            \n            if (!containsKey(key)) {\n                keysAsListed.add(key);\n            }\n            super.put(key, value);\n        }\n    }\n\n    \n    public void setProperty(String key, Object value) {\n        clearProperty(key);\n        addProperty(key, value);\n    }\n    \n    \n    public synchronized void save(OutputStream output, String header) throws IOException {\n        if (output == null) {\n            return;\n        }\n        PrintWriter theWrtr = new PrintWriter(output);\n        if (header != null) {\n            theWrtr.println(header);\n        }\n        \n        Enumeration theKeys = keys();\n        while (theKeys.hasMoreElements()) {\n            String key = (String) theKeys.nextElement();\n            Object value = get(key);\n            if (value != null) {\n                if (value instanceof String) {\n                    StringBuffer currentOutput = new StringBuffer();\n                    currentOutput.append(key);\n                    currentOutput.append(\"=\");\n                    currentOutput.append(escape((String) value));\n                    theWrtr.println(currentOutput.toString());\n                    \n                } else if (value instanceof List) {\n                    List values = (List) value;\n                    for (Iterator it = values.iterator(); it.hasNext(); ) {\n                        String currentElement = (String) it.next();\n                        StringBuffer currentOutput = new StringBuffer();\n                        currentOutput.append(key);\n                        currentOutput.append(\"=\");\n                        currentOutput.append(escape(currentElement));\n                        theWrtr.println(currentOutput.toString());\n                    }\n                }\n            }\n            theWrtr.println();\n            theWrtr.flush();\n        }\n    }\n\n    \n    public void combine(ExtendedProperties props) {\n        for (Iterator it = props.getKeys(); it.hasNext();) {\n            String key = (String) it.next();\n            clearProperty(key);\n            addPropertyDirect(key, props.get(key));\n        }\n    }\n    \n    \n    public void clearProperty(String key) {\n        if (containsKey(key)) {\n            \n            \n            for (int i = 0; i < keysAsListed.size(); i++) {\n                if (( keysAsListed.get(i)).equals(key)) {\n                    keysAsListed.remove(i);\n                    break;\n                }\n            }\n            super.remove(key);\n        }\n    }\n\n    \n    public Iterator getKeys() {\n        return keysAsListed.iterator();\n    }\n\n    \n    public Iterator getKeys(String prefix) {\n        Iterator keys = getKeys();\n        ArrayList matchingKeys = new ArrayList();\n\n        while (keys.hasNext()) {\n            Object key = keys.next();\n\n            if (key instanceof String && ((String) key).startsWith(prefix)) {\n                matchingKeys.add(key);\n            }\n        }\n        return matchingKeys.iterator();\n    }\n\n    \n    public ExtendedProperties subset(String prefix) {\n        ExtendedProperties c = new ExtendedProperties();\n        Iterator keys = getKeys();\n        boolean validSubset = false;\n\n        while (keys.hasNext()) {\n            Object key = keys.next();\n\n            if (key instanceof String && ((String) key).startsWith(prefix)) {\n                if (!validSubset) {\n                    validSubset = true;\n                }\n\n                \n                String newKey = null;\n                if (((String) key).length() == prefix.length()) {\n                    newKey = prefix;\n                } else {\n                    newKey = ((String) key).substring(prefix.length() + 1);\n                }\n\n                \n                c.addPropertyDirect(newKey, get(key));\n            }\n        }\n\n        if (validSubset) {\n            return c;\n        } else {\n            return null;\n        }\n    }\n\n    \n    public void display() {\n        Iterator i = getKeys();\n\n        while (i.hasNext()) {\n            String key = (String) i.next();\n            Object value = get(key);\n            System.out.println(key + \" => \" + value);\n        }\n    }\n\n    \n    public String getString(String key) {\n        return getString(key, null);\n    }\n\n    \n    public String getString(String key, String defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof String) {\n            return interpolate((String) value);\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return interpolate(defaults.getString(key, defaultValue));\n            } else {\n                return interpolate(defaultValue);\n            }\n        } else if (value instanceof List) {\n            return interpolate((String) ((List) value).get(0));\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a String object\");\n        }\n    }\n\n    \n    public Properties getProperties(String key) {\n        return getProperties(key, new Properties());\n    }\n\n    \n    public Properties getProperties(String key, Properties defaults) {\n        \n        String[] tokens = getStringArray(key);\n\n        \n        Properties props = new Properties(defaults);\n        for (int i = 0; i < tokens.length; i++) {\n            String token = tokens[i];\n            int equalSign = token.indexOf('=');\n            if (equalSign > 0) {\n                String pkey = token.substring(0, equalSign).trim();\n                String pvalue = token.substring(equalSign + 1).trim();\n                props.put(pkey, pvalue);\n            } else {\n                throw new IllegalArgumentException('\\'' + token + \"' does not contain \" + \"an equals sign\");\n            }\n        }\n        return props;\n    }\n\n    \n    public String[] getStringArray(String key) {\n        Object value = get(key);\n\n        List values;\n        if (value instanceof String) {\n            values = new Vector(1);\n            values.add(value);\n            \n        } else if (value instanceof List) {\n            values = (List) value;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getStringArray(key);\n            } else {\n                return new String[0];\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a String/List object\");\n        }\n\n        String[] tokens = new String[values.size()];\n        for (int i = 0; i < tokens.length; i++) {\n            tokens[i] = (String) values.get(i);\n        }\n\n        return tokens;\n    }\n\n    \n    public Vector getVector(String key) {\n        return getVector(key, null);\n    }\n\n    \n    public Vector getVector(String key, Vector defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof List) {\n            return new Vector((List) value);\n            \n        } else if (value instanceof String) {\n            Vector values = new Vector(1);\n            values.add(value);\n            super.put(key, values);\n            return values;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getVector(key, defaultValue);\n            } else {\n                return ((defaultValue == null) ? new Vector() : defaultValue);\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Vector object\");\n        }\n    }\n\n    \n    public List getList(String key) {\n        return getList(key, null);\n    }\n\n    \n    public List getList(String key, List defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof List) {\n            return new ArrayList((List) value);\n            \n        } else if (value instanceof String) {\n            List values = new ArrayList(1);\n            values.add(value);\n            super.put(key, values);\n            return values;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getList(key, defaultValue);\n            } else {\n                return ((defaultValue == null) ? new ArrayList() : defaultValue);\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a List object\");\n        }\n    }\n\n    \n    public boolean getBoolean(String key) {\n        Boolean b = getBoolean(key, null);\n        if (b != null) {\n            return b.booleanValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    \n    public boolean getBoolean(String key, boolean defaultValue) {\n        return getBoolean(key, new Boolean(defaultValue)).booleanValue();\n    }\n\n    \n    public Boolean getBoolean(String key, Boolean defaultValue) {\n\n        Object value = get(key);\n\n        if (value instanceof Boolean) {\n            return (Boolean) value;\n            \n        } else if (value instanceof String) {\n            String s = testBoolean((String) value);\n            Boolean b = new Boolean(s);\n            super.put(key, b);\n            return b;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getBoolean(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Boolean object\");\n        }\n    }\n\n    \n    public String testBoolean(String value) {\n        String s = value.toLowerCase(Locale.ENGLISH);\n\n        if (s.equals(\"true\") || s.equals(\"on\") || s.equals(\"yes\")) {\n            return \"true\";\n        } else if (s.equals(\"false\") || s.equals(\"off\") || s.equals(\"no\")) {\n            return \"false\";\n        } else {\n            return null;\n        }\n    }\n\n    \n    public byte getByte(String key) {\n        Byte b = getByte(key, null);\n        if (b != null) {\n            return b.byteValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \" doesn't map to an existing object\");\n        }\n    }\n\n    \n    public byte getByte(String key, byte defaultValue) {\n        return getByte(key, new Byte(defaultValue)).byteValue();\n    }\n\n    \n    public Byte getByte(String key, Byte defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Byte) {\n            return (Byte) value;\n            \n        } else if (value instanceof String) {\n            Byte b = new Byte((String) value);\n            super.put(key, b);\n            return b;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getByte(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Byte object\");\n        }\n    }\n\n    \n    public short getShort(String key) {\n        Short s = getShort(key, null);\n        if (s != null) {\n            return s.shortValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    \n    public short getShort(String key, short defaultValue) {\n        return getShort(key, new Short(defaultValue)).shortValue();\n    }\n\n    \n    public Short getShort(String key, Short defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Short) {\n            return (Short) value;\n            \n        } else if (value instanceof String) {\n            Short s = new Short((String) value);\n            super.put(key, s);\n            return s;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getShort(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Short object\");\n        }\n    }\n\n    \n    public int getInt(String name) {\n        return getInteger(name);\n    }\n\n    \n    public int getInt(String name, int def) {\n        return getInteger(name, def);\n    }\n\n    \n    public int getInteger(String key) {\n        Integer i = getInteger(key, null);\n        if (i != null) {\n            return i.intValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    \n    public int getInteger(String key, int defaultValue) {\n        Integer i = getInteger(key, null);\n\n        if (i == null) {\n            return defaultValue;\n        }\n        return i.intValue();\n    }\n\n    \n    public Integer getInteger(String key, Integer defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Integer) {\n            return (Integer) value;\n            \n        } else if (value instanceof String) {\n            Integer i = new Integer((String) value);\n            super.put(key, i);\n            return i;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getInteger(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Integer object\");\n        }\n    }\n\n    \n    public long getLong(String key) {\n        Long l = getLong(key, null);\n        if (l != null) {\n            return l.longValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    \n    public long getLong(String key, long defaultValue) {\n        return getLong(key, new Long(defaultValue)).longValue();\n    }\n\n    \n    public Long getLong(String key, Long defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Long) {\n            return (Long) value;\n            \n        } else if (value instanceof String) {\n            Long l = new Long((String) value);\n            super.put(key, l);\n            return l;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getLong(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Long object\");\n        }\n    }\n\n    \n    public float getFloat(String key) {\n        Float f = getFloat(key, null);\n        if (f != null) {\n            return f.floatValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    \n    public float getFloat(String key, float defaultValue) {\n        return getFloat(key, new Float(defaultValue)).floatValue();\n    }\n\n    \n    public Float getFloat(String key, Float defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Float) {\n            return (Float) value;\n            \n        } else if (value instanceof String) {\n            Float f = new Float((String) value);\n            super.put(key, f);\n            return f;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getFloat(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Float object\");\n        }\n    }\n\n    \n    public double getDouble(String key) {\n        Double d = getDouble(key, null);\n        if (d != null) {\n            return d.doubleValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    \n    public double getDouble(String key, double defaultValue) {\n        return getDouble(key, new Double(defaultValue)).doubleValue();\n    }\n\n    \n    public Double getDouble(String key, Double defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Double) {\n            return (Double) value;\n            \n        } else if (value instanceof String) {\n            Double d = new Double((String) value);\n            super.put(key, d);\n            return d;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getDouble(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Double object\");\n        }\n    }\n\n    \n    public static ExtendedProperties convertProperties(Properties props) {\n        ExtendedProperties c = new ExtendedProperties();\n\n        for (Enumeration e = props.propertyNames(); e.hasMoreElements();) {\n            String s = (String) e.nextElement();\n            String value = props.getProperty(s);\n            if(value != null) {\n                c.setProperty(s, value);\n            }\n        }\n\n        return c;\n    }\n\n    \n    public Object put(Object key, Object value) {\n        String strKey = String.valueOf(key);\n        Object ret = getProperty(strKey);\n        addProperty(strKey, value);\n        return ret;\n    }\n\n    \n    public void putAll(Map map) {\n        if (map instanceof ExtendedProperties) {\n            for (Iterator it = ((ExtendedProperties) map).getKeys(); it.hasNext(); ) {\n                Object key = it.next();\n                put(key, map.get(key));\n            }\n        } else {\n            for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) {\n                Map.Entry entry = (Map.Entry) it.next();\n                put(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n\n    \n    public Object remove(Object key) {\n        String strKey = String.valueOf(key);\n        Object ret = getProperty(strKey);\n        clearProperty(strKey);\n        return ret;\n    }\n\n}\n",
      "buggy_signatures": [
        "protected String interpolateHelper(String base, List priorVariables)",
        "private static String escape(String s)",
        "private static String unescape(String s)",
        "private static int countPreceding(String line, int index, char ch)",
        "private static boolean endsWithSlash(String line)",
        "static class PropertiesReader extends LineNumberReader { public PropertiesReader(Reader reader)",
        "public String readProperty() throws IOException",
        "public boolean hasMoreTokens()",
        "public String nextToken()",
        "public ExtendedProperties()",
        "public ExtendedProperties(String file) throws IOException",
        "public ExtendedProperties(String file, String defaultFile) throws IOException",
        "public boolean isInitialized()",
        "public String getInclude()",
        "public void setInclude(String inc)",
        "public void load(InputStream input) throws IOException",
        "public synchronized void load(InputStream input, String enc) throws IOException",
        "public Object getProperty(String key)",
        "public void addProperty(String key, Object value)",
        "private void addPropertyDirect(String key, Object value)",
        "private void addPropertyInternal(String key, Object value)",
        "public void setProperty(String key, Object value)",
        "public synchronized void save(OutputStream output, String header) throws IOException",
        "public void combine(ExtendedProperties props)",
        "public void clearProperty(String key)",
        "public Iterator getKeys()",
        "public Iterator getKeys(String prefix)",
        "public ExtendedProperties subset(String prefix)",
        "public void display()",
        "public String getString(String key)",
        "public String getString(String key, String defaultValue)",
        "public Properties getProperties(String key)",
        "public Properties getProperties(String key, Properties defaults)",
        "public String[] getStringArray(String key)",
        "public Vector getVector(String key)",
        "public Vector getVector(String key, Vector defaultValue)",
        "public List getList(String key)",
        "public List getList(String key, List defaultValue)",
        "public boolean getBoolean(String key)",
        "public boolean getBoolean(String key, boolean defaultValue)",
        "public Boolean getBoolean(String key, Boolean defaultValue)",
        "public String testBoolean(String value)",
        "public byte getByte(String key)",
        "public byte getByte(String key, byte defaultValue)",
        "public Byte getByte(String key, Byte defaultValue)",
        "public short getShort(String key)",
        "public short getShort(String key, short defaultValue)",
        "public Short getShort(String key, Short defaultValue)",
        "public int getInt(String name)",
        "public int getInt(String name, int def)",
        "public int getInteger(String key)",
        "public int getInteger(String key, int defaultValue)",
        "public Integer getInteger(String key, Integer defaultValue)",
        "public long getLong(String key)",
        "public long getLong(String key, long defaultValue)",
        "public Long getLong(String key, Long defaultValue)",
        "public float getFloat(String key)",
        "public float getFloat(String key, float defaultValue)",
        "public Float getFloat(String key, Float defaultValue)",
        "public double getDouble(String key)",
        "public double getDouble(String key, double defaultValue)",
        "public Double getDouble(String key, Double defaultValue)",
        "public static ExtendedProperties convertProperties(Properties props)",
        "public Object put(Object key, Object value)",
        "public void putAll(Map map)",
        "public Object remove(Object key)"
      ],
      "fixed_signatures": [
        "protected String interpolateHelper(String base, List priorVariables)",
        "private static String escape(String s)",
        "private static String unescape(String s)",
        "private static int countPreceding(String line, int index, char ch)",
        "private static boolean endsWithSlash(String line)",
        "static class PropertiesReader extends LineNumberReader { public PropertiesReader(Reader reader)",
        "public String readProperty() throws IOException",
        "public boolean hasMoreTokens()",
        "public String nextToken()",
        "public ExtendedProperties()",
        "public ExtendedProperties(String file) throws IOException",
        "public ExtendedProperties(String file, String defaultFile) throws IOException",
        "public boolean isInitialized()",
        "public String getInclude()",
        "public void setInclude(String inc)",
        "public void load(InputStream input) throws IOException",
        "public synchronized void load(InputStream input, String enc) throws IOException",
        "public Object getProperty(String key)",
        "public void addProperty(String key, Object value)",
        "private void addPropertyDirect(String key, Object value)",
        "private void addPropertyInternal(String key, Object value)",
        "public void setProperty(String key, Object value)",
        "public synchronized void save(OutputStream output, String header) throws IOException",
        "public void combine(ExtendedProperties props)",
        "public void clearProperty(String key)",
        "public Iterator getKeys()",
        "public Iterator getKeys(String prefix)",
        "public ExtendedProperties subset(String prefix)",
        "public void display()",
        "public String getString(String key)",
        "public String getString(String key, String defaultValue)",
        "public Properties getProperties(String key)",
        "public Properties getProperties(String key, Properties defaults)",
        "public String[] getStringArray(String key)",
        "public Vector getVector(String key)",
        "public Vector getVector(String key, Vector defaultValue)",
        "public List getList(String key)",
        "public List getList(String key, List defaultValue)",
        "public boolean getBoolean(String key)",
        "public boolean getBoolean(String key, boolean defaultValue)",
        "public Boolean getBoolean(String key, Boolean defaultValue)",
        "public String testBoolean(String value)",
        "public byte getByte(String key)",
        "public byte getByte(String key, byte defaultValue)",
        "public Byte getByte(String key, Byte defaultValue)",
        "public short getShort(String key)",
        "public short getShort(String key, short defaultValue)",
        "public Short getShort(String key, Short defaultValue)",
        "public int getInt(String name)",
        "public int getInt(String name, int def)",
        "public int getInteger(String key)",
        "public int getInteger(String key, int defaultValue)",
        "public Integer getInteger(String key, Integer defaultValue)",
        "public long getLong(String key)",
        "public long getLong(String key, long defaultValue)",
        "public Long getLong(String key, Long defaultValue)",
        "public float getFloat(String key)",
        "public float getFloat(String key, float defaultValue)",
        "public Float getFloat(String key, Float defaultValue)",
        "public double getDouble(String key)",
        "public double getDouble(String key, double defaultValue)",
        "public Double getDouble(String key, Double defaultValue)",
        "public static ExtendedProperties convertProperties(Properties props)",
        "public Object put(Object key, Object value)",
        "public void putAll(Map map)",
        "public Object remove(Object key)"
      ],
      "methods": [
        {
          "buggy_method": "  public static ExtendedProperties convertProperties(Properties props) {\n  ExtendedProperties c = new ExtendedProperties();\n\n  for (Enumeration e = props.propertyNames(); e.hasMoreElements();) {\n  String s = (String) e.nextElement();\n  c.setProperty(s, props.getProperty(s));\n  }\n\n  return c;\n  }",
          "fixed_method": "  public static ExtendedProperties convertProperties(Properties props) {\n  ExtendedProperties c = new ExtendedProperties();\n\n  for (Enumeration e = props.propertyNames(); e.hasMoreElements();) {\n  String s = (String) e.nextElement();\n  String value = props.getProperty(s);\n  if(value != null) {\n  c.setProperty(s, value);\n  }\n  }\n\n  return c;\n  }",
          "diff": [
            "@@ -1721,7 +1721,10 @@",
            " \n",
            "         for (Enumeration e = props.propertyNames(); e.hasMoreElements();) {\n",
            "             String s = (String) e.nextElement();\n",
            "-            c.setProperty(s, props.getProperty(s));\n",
            "+            String value = props.getProperty(s);\n",
            "+            if(value != null) {\n",
            "+                c.setProperty(s, value);\n",
            "+            }\n",
            "         }\n",
            " \n",
            "         return c;\n"
          ],
          "changed_lines": 5
        }
      ]
    }
  ]
}
