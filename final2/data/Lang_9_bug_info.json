{
  "bug_id": "9",
  "failed_tests": {
    "org.apache.commons.lang3.time.FastDateFormat_ParserTest": [
      {
        "methodName": "testLANG_832",
        "error": "junit.framework.AssertionFailedError",
        "message": "Parsed dates should be equal expected:<null> but was:<Fri Jan 02 21:00:00 PST 1970>",
        "fail_line": "",
        "test_source": "",
        "stack": [
          "FastDateParserTest.testSdfAndFdp line 387, FastDateParserTest.testLANG_832 line 342"
        ]
      }
    ],
    "org.apache.commons.lang3.time.FastDateParserTest": [
      {
        "methodName": "testLANG_832",
        "error": "junit.framework.AssertionFailedError",
        "message": "Expected FDF failure, but got Fri Jan 02 21:00:00 PST 1970 for ['d'd',d3] using d(\\p{IsNd}++)",
        "fail_line": "        testSdfAndFdp(\"'d'd'\",\"d3\", true); // should fail (unterminated quote)",
        "test_source": "  public void testLANG_832() throws Exception {\n  testSdfAndFdp(\"'d'd\" ,\"d3\", false); // OK\n  testSdfAndFdp(\"'d'd'\",\"d3\", true); // should fail (unterminated quote)\n  }",
        "stack": [
          "FastDateParserTest.testSdfAndFdp line 376, FastDateParserTest.testLANG_832 line 342"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/lang3/time/FastDateParser.java",
      "buggy_full_code": "\npackage org.apache.commons.lang3.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.text.DateFormatSymbols;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.SortedMap;\nimport java.util.TimeZone;\nimport java.util.TreeMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n\npublic class FastDateParser implements DateParser, Serializable { private static final long serialVersionUID = 1L; private static final ConcurrentMap<Locale,TimeZoneStrategy> tzsCache= new ConcurrentHashMap<Locale,TimeZoneStrategy>(3); static final Locale JAPANESE_IMPERIAL = new Locale(\"ja\",\"JP\",\"JP\"); private final String pattern; private final TimeZone timeZone; private final Locale locale; private transient Pattern parsePattern; private transient Strategy[] strategies; private transient int thisYear; private transient ConcurrentMap<Integer, KeyValue[]> nameValues; private transient String currentFormatField; private transient Strategy nextStrategy; protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }\n\n    \n    private void init() {\n        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n\n        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n\n        StringBuilder regex= new StringBuilder();\n        List<Strategy> collector = new ArrayList<Strategy>();\n\n        Matcher patternMatcher= formatPattern.matcher(pattern);\n        if(!patternMatcher.lookingAt()) {\n            throw new IllegalArgumentException(\"Invalid pattern\");\n        }\n\n        currentFormatField= patternMatcher.group();\n        Strategy currentStrategy= getStrategy(currentFormatField);\n        for(;;) {\n            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\n            if(!patternMatcher.lookingAt()) {\n                nextStrategy = null;\n                break;\n            }\n            String nextFormatField= patternMatcher.group();\n            nextStrategy = getStrategy(nextFormatField);\n            if(currentStrategy.addRegex(this, regex)) {\n                collector.add(currentStrategy);\n            }\n            currentFormatField= nextFormatField;\n            currentStrategy= nextStrategy;\n        }\n        if(currentStrategy.addRegex(this, regex)) {\n            collector.add(currentStrategy);\n        }\n        currentFormatField= null;\n        strategies= collector.toArray(new Strategy[collector.size()]);\n        parsePattern= Pattern.compile(regex.toString());\n    }\n\n    \n    \n    \n    @Override\n    public String getPattern() {\n        return pattern;\n    }\n\n    \n    @Override\n    public TimeZone getTimeZone() {\n        return timeZone;\n    }\n\n    \n    @Override\n    public Locale getLocale() {\n        return locale;\n    }\n\n    \n    Pattern getParsePattern() {\n        return parsePattern;\n    }\n\n    \n    \n    \n    @Override\n    public boolean equals(Object obj) {\n        if (! (obj instanceof FastDateParser) ) {\n            return false;\n        }\n        FastDateParser other = (FastDateParser) obj;\n        return pattern.equals(other.pattern)\n            && timeZone.equals(other.timeZone)\n            && locale.equals(other.locale);\n    }\n\n    \n    @Override\n    public int hashCode() {\n        return pattern.hashCode() + 13 * (timeZone.hashCode() + 13 * locale.hashCode());\n    }\n\n    \n    @Override\n    public String toString() {\n        return \"FastDateParser[\" + pattern + \",\" + locale + \",\" + timeZone.getID() + \"]\";\n    }\n\n    \n    \n    \n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        init();\n    }\n\n    \n    @Override\n    public Object parseObject(String source) throws ParseException {\n        return parse(source);\n    }\n\n    \n    @Override\n    public Date parse(String source) throws ParseException {\n        Date date= parse(source, new ParsePosition(0));\n        if(date==null) {\n            \n            if (locale.equals(JAPANESE_IMPERIAL)) {\n                throw new ParseException(\n                        \"(The \" +locale + \" locale does not support dates before 1868 AD)\\n\" +\n                                \"Unparseable date: \\\"\"+source+\"\\\" does not match \"+parsePattern.pattern(), 0);\n            }\n            throw new ParseException(\"Unparseable date: \\\"\"+source+\"\\\" does not match \"+parsePattern.pattern(), 0);\n        }\n        return date;\n    }\n\n    \n    @Override\n    public Object parseObject(String source, ParsePosition pos) {\n        return parse(source, pos);\n    }\n\n    \n    @Override\n    public Date parse(String source, ParsePosition pos) {\n        int offset= pos.getIndex();\n        Matcher matcher= parsePattern.matcher(source.substring(offset));\n        if(!matcher.lookingAt()) {\n            return null;\n        }\n        \n        Calendar cal= Calendar.getInstance(timeZone, locale);\n        cal.clear();\n\n        for(int i=0; i<strategies.length;) {\n            Strategy strategy= strategies[i++];\n            strategy.setCalendar(this, cal, matcher.group(i));\n        }\n        pos.setIndex(offset+matcher.end());\n        return cal.getTime();\n    }\n\n    \n    \n\n    \n    private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n        for(int i= 0; i<value.length(); ++i) {\n            char c= value.charAt(i);\n            switch(c) {\n            case '\\'':\n                if(unquote) {\n                    if(++i==value.length()) {\n                        return regex;\n                    }\n                    c= value.charAt(i);\n                }\n                break;\n            case '?':\n            case '[':\n            case ']':\n            case '(':\n            case ')':\n            case '{':\n            case '}':\n            case '\\\\':\n            case '|':\n            case '*':\n            case '+':\n            case '^':\n            case '$':\n            case '.':\n                regex.append('\\\\');\n            }\n            regex.append(c);\n        }\n        return regex;\n    }\n\n    \n    private static class KeyValue { public String key; public int value; public KeyValue(String key, int value) {\n            this.key= key;\n            this.value= value;\n        }\n    }\n\n    \n    private static final Comparator<KeyValue> IGNORE_CASE_COMPARATOR = new Comparator<KeyValue> () {\n        @Override\n        public int compare(KeyValue left, KeyValue right) {\n            return left.key.compareToIgnoreCase(right.key);\n        }\n    };\n\n    \n    KeyValue[] getDisplayNames(int field) {\n        Integer fieldInt = Integer.valueOf(field);\n        KeyValue[] fieldKeyValues= nameValues.get(fieldInt);\n        if(fieldKeyValues==null) {\n            DateFormatSymbols symbols= DateFormatSymbols.getInstance(locale);\n            switch(field) {\n            case Calendar.ERA:\n                \n                \n                \n                Calendar c = Calendar.getInstance(locale);\n                \n                String[] shortEras = toArray(c.getDisplayNames(Calendar.ERA, Calendar.SHORT, locale));\n                String[] longEras = toArray(c.getDisplayNames(Calendar.ERA, Calendar.LONG, locale));\n                fieldKeyValues= createKeyValues(longEras, shortEras);\n                break;\n            case Calendar.DAY_OF_WEEK:\n                fieldKeyValues= createKeyValues(symbols.getWeekdays(), symbols.getShortWeekdays());\n                break;\n            case Calendar.AM_PM:\n                fieldKeyValues= createKeyValues(symbols.getAmPmStrings(), null);\n                break;\n            case Calendar.MONTH:\n                fieldKeyValues= createKeyValues(symbols.getMonths(), symbols.getShortMonths());\n                break;\n            default:\n                throw new IllegalArgumentException(\"Invalid field value \"+field);\n            }\n            KeyValue[] prior = nameValues.putIfAbsent(fieldInt, fieldKeyValues);\n            if(prior!=null) {\n                fieldKeyValues= prior;\n            }\n        }\n        return fieldKeyValues;\n    }\n\n    private String[] toArray(Map<String, Integer> era) {\n        String[] eras = new String[era.size()]; \n        for(Map.Entry<String, Integer> me : era.entrySet()) {\n            int idx = me.getValue().intValue();\n            final String key = me.getKey();\n            if (key == null) {\n                throw new IllegalArgumentException();\n            }\n            eras[idx] = key;\n        }\n        return eras;\n    }\n\n    \n    private static KeyValue[] createKeyValues(String[] longValues, String[] shortValues) {\n        KeyValue[] fieldKeyValues= new KeyValue[count(longValues)+count(shortValues)];\n        copy(fieldKeyValues, copy(fieldKeyValues, 0, longValues), shortValues);\n        Arrays.sort(fieldKeyValues, IGNORE_CASE_COMPARATOR);\n        return fieldKeyValues;\n    }\n\n    \n    private static int count(String[] values) {\n        int count= 0;\n        if(values!=null) {\n            for(String value : values) {\n                if(value.length()>0) {\n                    ++count;\n                }\n            }\n        }\n        return count;\n    }\n\n    \n    private static int copy(KeyValue[] fieldKeyValues, int offset, String[] values) {\n        if(values!=null) {\n            for(int i= 0; i<values.length; ++i) {\n                String value= values[i];\n                if(value.length()>0) {\n                    fieldKeyValues[offset++]= new KeyValue(value, i);\n                }\n            }\n        }\n        return offset;\n    }\n\n    \n    int adjustYear(int twoDigitYear) {\n        int trial= twoDigitYear + thisYear - thisYear%100;\n        if(trial < thisYear+20) {\n            return trial;\n        }\n        return trial-100;\n    }\n\n    \n    boolean isNextNumber() {\n        return nextStrategy!=null && nextStrategy.isNumber();\n    }\n\n    \n    int getFieldWidth() {\n        return currentFormatField.length();\n    }\n\n    \n    private interface Strategy { boolean isNumber(); void setCalendar(FastDateParser parser, Calendar cal, String value); boolean addRegex(FastDateParser parser, StringBuilder regex); } private static final Pattern formatPattern= Pattern.compile( \"D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++\"); private Strategy getStrategy(String formatField) {\n        switch(formatField.charAt(0)) {\n        case '\\'':\n            if(formatField.length()>2) {\n                formatField= formatField.substring(1, formatField.length()-1);\n            }\n            \n        default:\n            return new CopyQuotedStrategy(formatField);\n        case 'D':\n            return DAY_OF_YEAR_STRATEGY;\n        case 'E':\n            return DAY_OF_WEEK_STRATEGY;\n        case 'F':\n            return DAY_OF_WEEK_IN_MONTH_STRATEGY;\n        case 'G':\n            return ERA_STRATEGY;\n        case 'H':\n            return MODULO_HOUR_OF_DAY_STRATEGY;\n        case 'K':\n            return HOUR_STRATEGY;\n        case 'M':\n            return formatField.length()>=3 ?TEXT_MONTH_STRATEGY :NUMBER_MONTH_STRATEGY;\n        case 'S':\n            return MILLISECOND_STRATEGY;\n        case 'W':\n            return WEEK_OF_MONTH_STRATEGY;\n        case 'Z':\n            break;\n        case 'a':\n            return AM_PM_STRATEGY;\n        case 'd':\n            return DAY_OF_MONTH_STRATEGY;\n        case 'h':\n            return MODULO_HOUR_STRATEGY;\n        case 'k':\n            return HOUR_OF_DAY_STRATEGY;\n        case 'm':\n            return MINUTE_STRATEGY;\n        case 's':\n            return SECOND_STRATEGY;\n        case 'w':\n            return WEEK_OF_YEAR_STRATEGY;\n        case 'y':\n            return formatField.length()>2 ?LITERAL_YEAR_STRATEGY :ABBREVIATED_YEAR_STRATEGY;\n        case 'z':\n            break;\n        }\n        TimeZoneStrategy tzs= tzsCache.get(locale);\n        if(tzs==null) {\n            tzs= new TimeZoneStrategy(locale);\n            TimeZoneStrategy inCache= tzsCache.putIfAbsent(locale, tzs);\n            if(inCache!=null) {\n                return inCache;\n            }\n        }\n        return tzs;\n    }\n\n    \n    private static class CopyQuotedStrategy implements Strategy { private final String formatField; CopyQuotedStrategy(String formatField) {\n            this.formatField= formatField;\n        }\n\n        \n        @Override\n        public boolean isNumber() {\n            char c= formatField.charAt(0);\n            if(c=='\\'') {\n                c= formatField.charAt(1);\n            }\n            return Character.isDigit(c);\n        }\n\n        \n        @Override\n        public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n            escapeRegex(regex, formatField, true);\n            return false;\n        }\n\n        \n        @Override\n        public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n        }\n    }\n\n    \n    private static class TextStrategy implements Strategy { private final int field; TextStrategy(int field) {\n            this.field= field;\n        }\n\n        \n        @Override\n        public boolean isNumber() {\n            return false;\n        }\n\n        \n        @Override\n        public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n            regex.append('(');\n            for(KeyValue textKeyValue : parser.getDisplayNames(field)) {\n                escapeRegex(regex, textKeyValue.key, false).append('|');\n            }\n            regex.setCharAt(regex.length()-1, ')');\n            return true;\n        }\n\n        \n        @Override\n        public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n            KeyValue[] textKeyValues= parser.getDisplayNames(field);\n            int idx= Arrays.binarySearch(textKeyValues, new KeyValue(value, -1), IGNORE_CASE_COMPARATOR);\n            if(idx<0) {\n                StringBuilder sb= new StringBuilder(value);\n                sb.append(\" not in (\");\n                for(KeyValue textKeyValue : textKeyValues) {\n                    sb.append(textKeyValue.key).append(' ');\n                }\n                sb.setCharAt(sb.length()-1, ')');\n                throw new IllegalArgumentException(sb.toString());\n            }\n            cal.set(field, textKeyValues[idx].value);\n        }\n    }\n\n    \n    private static class NumberStrategy implements Strategy { protected final int field; NumberStrategy(int field) {\n             this.field= field;\n        }\n\n        \n        @Override\n        public boolean isNumber() {\n            return true;\n        }\n\n        \n        @Override\n        public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n            if(parser.isNextNumber()) {\n                regex.append(\"(\\\\p{IsNd}{\").append(parser.getFieldWidth()).append(\"}+)\");\n            }\n            else {\n                regex.append(\"(\\\\p{IsNd}++)\");\n            }\n            return true;\n        }\n\n        \n        @Override\n        public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n            cal.set(field, modify(Integer.parseInt(value)));\n        }\n\n        \n        public int modify(int iValue) {\n            return iValue;\n        }\n    }\n\n    private static final Strategy ABBREVIATED_YEAR_STRATEGY = new NumberStrategy(Calendar.YEAR) {\n        \n        @Override\n        public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n            int iValue= Integer.parseInt(value);\n            if(iValue<100) {\n                iValue= parser.adjustYear(iValue);\n            }\n            cal.set(Calendar.YEAR, iValue);\n        }\n    };\n\n    \n    private static class TimeZoneStrategy implements Strategy { final String validTimeZoneChars; final SortedMap<String, TimeZone> tzNames= new TreeMap<String, TimeZone>(String.CASE_INSENSITIVE_ORDER); TimeZoneStrategy(Locale locale) {\n            for(String id : TimeZone.getAvailableIDs()) {\n                if(id.startsWith(\"GMT\")) {\n                    continue;\n                }\n                TimeZone tz= TimeZone.getTimeZone(id);\n                tzNames.put(tz.getDisplayName(false, TimeZone.SHORT, locale), tz);\n                tzNames.put(tz.getDisplayName(false, TimeZone.LONG, locale), tz);\n                if(tz.useDaylightTime()) {\n                    tzNames.put(tz.getDisplayName(true, TimeZone.SHORT, locale), tz);\n                    tzNames.put(tz.getDisplayName(true, TimeZone.LONG, locale), tz);\n                }\n            }\n            StringBuilder sb= new StringBuilder();\n            sb.append(\"(GMT[+\\\\-]\\\\d{0,1}\\\\d{2}|[+\\\\-]\\\\d{2}:?\\\\d{2}|\");\n            for(String id : tzNames.keySet()) {\n                escapeRegex(sb, id, false).append('|');\n            }\n            sb.setCharAt(sb.length()-1, ')');\n            validTimeZoneChars= sb.toString();\n        }\n\n        \n        @Override\n        public boolean isNumber() {\n            return false;\n        }\n\n        \n        @Override\n        public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n            regex.append(validTimeZoneChars);\n            return true;\n        }\n\n        \n        @Override\n        public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n            TimeZone tz;\n            if(value.charAt(0)=='+' || value.charAt(0)=='-') {\n                tz= TimeZone.getTimeZone(\"GMT\"+value);\n            }\n            else if(value.startsWith(\"GMT\")) {\n                tz= TimeZone.getTimeZone(value);\n            }\n            else {\n                tz= tzNames.get(value);\n                if(tz==null) {\n                    throw new IllegalArgumentException(value + \" is not a supported timezone name\");\n                }\n            }\n            cal.setTimeZone(tz);\n        }\n    }\n\n\n    private static final Strategy ERA_STRATEGY = new TextStrategy(Calendar.ERA); private static final Strategy DAY_OF_WEEK_STRATEGY = new TextStrategy(Calendar.DAY_OF_WEEK); private static final Strategy AM_PM_STRATEGY = new TextStrategy(Calendar.AM_PM); private static final Strategy TEXT_MONTH_STRATEGY = new TextStrategy(Calendar.MONTH); private static final Strategy NUMBER_MONTH_STRATEGY = new NumberStrategy(Calendar.MONTH) {\n        @Override\n        public int modify(int iValue) {\n            return iValue-1;\n        }\n    };\n    private static final Strategy LITERAL_YEAR_STRATEGY = new NumberStrategy(Calendar.YEAR); private static final Strategy WEEK_OF_YEAR_STRATEGY = new NumberStrategy(Calendar.WEEK_OF_YEAR); private static final Strategy WEEK_OF_MONTH_STRATEGY = new NumberStrategy(Calendar.WEEK_OF_MONTH); private static final Strategy DAY_OF_YEAR_STRATEGY = new NumberStrategy(Calendar.DAY_OF_YEAR); private static final Strategy DAY_OF_MONTH_STRATEGY = new NumberStrategy(Calendar.DAY_OF_MONTH); private static final Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY = new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); private static final Strategy HOUR_OF_DAY_STRATEGY = new NumberStrategy(Calendar.HOUR_OF_DAY); private static final Strategy MODULO_HOUR_OF_DAY_STRATEGY = new NumberStrategy(Calendar.HOUR_OF_DAY) {\n        @Override\n        public int modify(int iValue) {\n            return iValue%24;\n        }\n    };\n    private static final Strategy MODULO_HOUR_STRATEGY = new NumberStrategy(Calendar.HOUR) {\n        @Override\n        public int modify(int iValue) {\n            return iValue%12;\n        }\n    };\n    private static final Strategy HOUR_STRATEGY = new NumberStrategy(Calendar.HOUR);\n    private static final Strategy MINUTE_STRATEGY = new NumberStrategy(Calendar.MINUTE);\n    private static final Strategy SECOND_STRATEGY = new NumberStrategy(Calendar.SECOND);\n    private static final Strategy MILLISECOND_STRATEGY = new NumberStrategy(Calendar.MILLISECOND);\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.lang3.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.text.DateFormatSymbols;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.SortedMap;\nimport java.util.TimeZone;\nimport java.util.TreeMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n\npublic class FastDateParser implements DateParser, Serializable { private static final long serialVersionUID = 1L; private static final ConcurrentMap<Locale,TimeZoneStrategy> tzsCache= new ConcurrentHashMap<Locale,TimeZoneStrategy>(3); static final Locale JAPANESE_IMPERIAL = new Locale(\"ja\",\"JP\",\"JP\"); private final String pattern; private final TimeZone timeZone; private final Locale locale; private transient Pattern parsePattern; private transient Strategy[] strategies; private transient int thisYear; private transient ConcurrentMap<Integer, KeyValue[]> nameValues; private transient String currentFormatField; private transient Strategy nextStrategy; protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }\n\n    \n    private void init() {\n        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n\n        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n\n        StringBuilder regex= new StringBuilder();\n        List<Strategy> collector = new ArrayList<Strategy>();\n\n        Matcher patternMatcher= formatPattern.matcher(pattern);\n        if(!patternMatcher.lookingAt()) {\n            throw new IllegalArgumentException(\"Invalid pattern\");\n        }\n\n        currentFormatField= patternMatcher.group();\n        Strategy currentStrategy= getStrategy(currentFormatField);\n        for(;;) {\n            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\n            if(!patternMatcher.lookingAt()) {\n                nextStrategy = null;\n                break;\n            }\n            String nextFormatField= patternMatcher.group();\n            nextStrategy = getStrategy(nextFormatField);\n            if(currentStrategy.addRegex(this, regex)) {\n                collector.add(currentStrategy);\n            }\n            currentFormatField= nextFormatField;\n            currentStrategy= nextStrategy;\n        }\n        if (patternMatcher.regionStart() != patternMatcher.regionEnd()) {\n            throw new IllegalArgumentException(\"Failed to parse \\\"\"+pattern+\"\\\" ; gave up at index \"+patternMatcher.regionStart());\n        }\n        if(currentStrategy.addRegex(this, regex)) {\n            collector.add(currentStrategy);\n        }\n        currentFormatField= null;\n        strategies= collector.toArray(new Strategy[collector.size()]);\n        parsePattern= Pattern.compile(regex.toString());\n    }\n\n    \n    \n    \n    @Override\n    public String getPattern() {\n        return pattern;\n    }\n\n    \n    @Override\n    public TimeZone getTimeZone() {\n        return timeZone;\n    }\n\n    \n    @Override\n    public Locale getLocale() {\n        return locale;\n    }\n\n    \n    Pattern getParsePattern() {\n        return parsePattern;\n    }\n\n    \n    \n    \n    @Override\n    public boolean equals(Object obj) {\n        if (! (obj instanceof FastDateParser) ) {\n            return false;\n        }\n        FastDateParser other = (FastDateParser) obj;\n        return pattern.equals(other.pattern)\n            && timeZone.equals(other.timeZone)\n            && locale.equals(other.locale);\n    }\n\n    \n    @Override\n    public int hashCode() {\n        return pattern.hashCode() + 13 * (timeZone.hashCode() + 13 * locale.hashCode());\n    }\n\n    \n    @Override\n    public String toString() {\n        return \"FastDateParser[\" + pattern + \",\" + locale + \",\" + timeZone.getID() + \"]\";\n    }\n\n    \n    \n    \n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        init();\n    }\n\n    \n    @Override\n    public Object parseObject(String source) throws ParseException {\n        return parse(source);\n    }\n\n    \n    @Override\n    public Date parse(String source) throws ParseException {\n        Date date= parse(source, new ParsePosition(0));\n        if(date==null) {\n            \n            if (locale.equals(JAPANESE_IMPERIAL)) {\n                throw new ParseException(\n                        \"(The \" +locale + \" locale does not support dates before 1868 AD)\\n\" +\n                                \"Unparseable date: \\\"\"+source+\"\\\" does not match \"+parsePattern.pattern(), 0);\n            }\n            throw new ParseException(\"Unparseable date: \\\"\"+source+\"\\\" does not match \"+parsePattern.pattern(), 0);\n        }\n        return date;\n    }\n\n    \n    @Override\n    public Object parseObject(String source, ParsePosition pos) {\n        return parse(source, pos);\n    }\n\n    \n    @Override\n    public Date parse(String source, ParsePosition pos) {\n        int offset= pos.getIndex();\n        Matcher matcher= parsePattern.matcher(source.substring(offset));\n        if(!matcher.lookingAt()) {\n            return null;\n        }\n        \n        Calendar cal= Calendar.getInstance(timeZone, locale);\n        cal.clear();\n\n        for(int i=0; i<strategies.length;) {\n            Strategy strategy= strategies[i++];\n            strategy.setCalendar(this, cal, matcher.group(i));\n        }\n        pos.setIndex(offset+matcher.end());\n        return cal.getTime();\n    }\n\n    \n    \n\n    \n    private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n        for(int i= 0; i<value.length(); ++i) {\n            char c= value.charAt(i);\n            switch(c) {\n            case '\\'':\n                if(unquote) {\n                    if(++i==value.length()) {\n                        return regex;\n                    }\n                    c= value.charAt(i);\n                }\n                break;\n            case '?':\n            case '[':\n            case ']':\n            case '(':\n            case ')':\n            case '{':\n            case '}':\n            case '\\\\':\n            case '|':\n            case '*':\n            case '+':\n            case '^':\n            case '$':\n            case '.':\n                regex.append('\\\\');\n            }\n            regex.append(c);\n        }\n        return regex;\n    }\n\n    \n    private static class KeyValue { public String key; public int value; public KeyValue(String key, int value) {\n            this.key= key;\n            this.value= value;\n        }\n    }\n\n    \n    private static final Comparator<KeyValue> IGNORE_CASE_COMPARATOR = new Comparator<KeyValue> () {\n        @Override\n        public int compare(KeyValue left, KeyValue right) {\n            return left.key.compareToIgnoreCase(right.key);\n        }\n    };\n\n    \n    KeyValue[] getDisplayNames(int field) {\n        Integer fieldInt = Integer.valueOf(field);\n        KeyValue[] fieldKeyValues= nameValues.get(fieldInt);\n        if(fieldKeyValues==null) {\n            DateFormatSymbols symbols= DateFormatSymbols.getInstance(locale);\n            switch(field) {\n            case Calendar.ERA:\n                \n                \n                \n                Calendar c = Calendar.getInstance(locale);\n                \n                String[] shortEras = toArray(c.getDisplayNames(Calendar.ERA, Calendar.SHORT, locale));\n                String[] longEras = toArray(c.getDisplayNames(Calendar.ERA, Calendar.LONG, locale));\n                fieldKeyValues= createKeyValues(longEras, shortEras);\n                break;\n            case Calendar.DAY_OF_WEEK:\n                fieldKeyValues= createKeyValues(symbols.getWeekdays(), symbols.getShortWeekdays());\n                break;\n            case Calendar.AM_PM:\n                fieldKeyValues= createKeyValues(symbols.getAmPmStrings(), null);\n                break;\n            case Calendar.MONTH:\n                fieldKeyValues= createKeyValues(symbols.getMonths(), symbols.getShortMonths());\n                break;\n            default:\n                throw new IllegalArgumentException(\"Invalid field value \"+field);\n            }\n            KeyValue[] prior = nameValues.putIfAbsent(fieldInt, fieldKeyValues);\n            if(prior!=null) {\n                fieldKeyValues= prior;\n            }\n        }\n        return fieldKeyValues;\n    }\n\n    private String[] toArray(Map<String, Integer> era) {\n        String[] eras = new String[era.size()]; \n        for(Map.Entry<String, Integer> me : era.entrySet()) {\n            int idx = me.getValue().intValue();\n            final String key = me.getKey();\n            if (key == null) {\n                throw new IllegalArgumentException();\n            }\n            eras[idx] = key;\n        }\n        return eras;\n    }\n\n    \n    private static KeyValue[] createKeyValues(String[] longValues, String[] shortValues) {\n        KeyValue[] fieldKeyValues= new KeyValue[count(longValues)+count(shortValues)];\n        copy(fieldKeyValues, copy(fieldKeyValues, 0, longValues), shortValues);\n        Arrays.sort(fieldKeyValues, IGNORE_CASE_COMPARATOR);\n        return fieldKeyValues;\n    }\n\n    \n    private static int count(String[] values) {\n        int count= 0;\n        if(values!=null) {\n            for(String value : values) {\n                if(value.length()>0) {\n                    ++count;\n                }\n            }\n        }\n        return count;\n    }\n\n    \n    private static int copy(KeyValue[] fieldKeyValues, int offset, String[] values) {\n        if(values!=null) {\n            for(int i= 0; i<values.length; ++i) {\n                String value= values[i];\n                if(value.length()>0) {\n                    fieldKeyValues[offset++]= new KeyValue(value, i);\n                }\n            }\n        }\n        return offset;\n    }\n\n    \n    int adjustYear(int twoDigitYear) {\n        int trial= twoDigitYear + thisYear - thisYear%100;\n        if(trial < thisYear+20) {\n            return trial;\n        }\n        return trial-100;\n    }\n\n    \n    boolean isNextNumber() {\n        return nextStrategy!=null && nextStrategy.isNumber();\n    }\n\n    \n    int getFieldWidth() {\n        return currentFormatField.length();\n    }\n\n    \n    private interface Strategy { boolean isNumber(); void setCalendar(FastDateParser parser, Calendar cal, String value); boolean addRegex(FastDateParser parser, StringBuilder regex); } private static final Pattern formatPattern= Pattern.compile( \"D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++\"); private Strategy getStrategy(String formatField) {\n        switch(formatField.charAt(0)) {\n        case '\\'':\n            if(formatField.length()>2) {\n                formatField= formatField.substring(1, formatField.length()-1);\n            }\n            \n        default:\n            return new CopyQuotedStrategy(formatField);\n        case 'D':\n            return DAY_OF_YEAR_STRATEGY;\n        case 'E':\n            return DAY_OF_WEEK_STRATEGY;\n        case 'F':\n            return DAY_OF_WEEK_IN_MONTH_STRATEGY;\n        case 'G':\n            return ERA_STRATEGY;\n        case 'H':\n            return MODULO_HOUR_OF_DAY_STRATEGY;\n        case 'K':\n            return HOUR_STRATEGY;\n        case 'M':\n            return formatField.length()>=3 ?TEXT_MONTH_STRATEGY :NUMBER_MONTH_STRATEGY;\n        case 'S':\n            return MILLISECOND_STRATEGY;\n        case 'W':\n            return WEEK_OF_MONTH_STRATEGY;\n        case 'Z':\n            break;\n        case 'a':\n            return AM_PM_STRATEGY;\n        case 'd':\n            return DAY_OF_MONTH_STRATEGY;\n        case 'h':\n            return MODULO_HOUR_STRATEGY;\n        case 'k':\n            return HOUR_OF_DAY_STRATEGY;\n        case 'm':\n            return MINUTE_STRATEGY;\n        case 's':\n            return SECOND_STRATEGY;\n        case 'w':\n            return WEEK_OF_YEAR_STRATEGY;\n        case 'y':\n            return formatField.length()>2 ?LITERAL_YEAR_STRATEGY :ABBREVIATED_YEAR_STRATEGY;\n        case 'z':\n            break;\n        }\n        TimeZoneStrategy tzs= tzsCache.get(locale);\n        if(tzs==null) {\n            tzs= new TimeZoneStrategy(locale);\n            TimeZoneStrategy inCache= tzsCache.putIfAbsent(locale, tzs);\n            if(inCache!=null) {\n                return inCache;\n            }\n        }\n        return tzs;\n    }\n\n    \n    private static class CopyQuotedStrategy implements Strategy { private final String formatField; CopyQuotedStrategy(String formatField) {\n            this.formatField= formatField;\n        }\n\n        \n        @Override\n        public boolean isNumber() {\n            char c= formatField.charAt(0);\n            if(c=='\\'') {\n                c= formatField.charAt(1);\n            }\n            return Character.isDigit(c);\n        }\n\n        \n        @Override\n        public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n            escapeRegex(regex, formatField, true);\n            return false;\n        }\n\n        \n        @Override\n        public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n        }\n    }\n\n    \n    private static class TextStrategy implements Strategy { private final int field; TextStrategy(int field) {\n            this.field= field;\n        }\n\n        \n        @Override\n        public boolean isNumber() {\n            return false;\n        }\n\n        \n        @Override\n        public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n            regex.append('(');\n            for(KeyValue textKeyValue : parser.getDisplayNames(field)) {\n                escapeRegex(regex, textKeyValue.key, false).append('|');\n            }\n            regex.setCharAt(regex.length()-1, ')');\n            return true;\n        }\n\n        \n        @Override\n        public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n            KeyValue[] textKeyValues= parser.getDisplayNames(field);\n            int idx= Arrays.binarySearch(textKeyValues, new KeyValue(value, -1), IGNORE_CASE_COMPARATOR);\n            if(idx<0) {\n                StringBuilder sb= new StringBuilder(value);\n                sb.append(\" not in (\");\n                for(KeyValue textKeyValue : textKeyValues) {\n                    sb.append(textKeyValue.key).append(' ');\n                }\n                sb.setCharAt(sb.length()-1, ')');\n                throw new IllegalArgumentException(sb.toString());\n            }\n            cal.set(field, textKeyValues[idx].value);\n        }\n    }\n\n    \n    private static class NumberStrategy implements Strategy { protected final int field; NumberStrategy(int field) {\n             this.field= field;\n        }\n\n        \n        @Override\n        public boolean isNumber() {\n            return true;\n        }\n\n        \n        @Override\n        public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n            if(parser.isNextNumber()) {\n                regex.append(\"(\\\\p{IsNd}{\").append(parser.getFieldWidth()).append(\"}+)\");\n            }\n            else {\n                regex.append(\"(\\\\p{IsNd}++)\");\n            }\n            return true;\n        }\n\n        \n        @Override\n        public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n            cal.set(field, modify(Integer.parseInt(value)));\n        }\n\n        \n        public int modify(int iValue) {\n            return iValue;\n        }\n    }\n\n    private static final Strategy ABBREVIATED_YEAR_STRATEGY = new NumberStrategy(Calendar.YEAR) {\n        \n        @Override\n        public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n            int iValue= Integer.parseInt(value);\n            if(iValue<100) {\n                iValue= parser.adjustYear(iValue);\n            }\n            cal.set(Calendar.YEAR, iValue);\n        }\n    };\n\n    \n    private static class TimeZoneStrategy implements Strategy { final String validTimeZoneChars; final SortedMap<String, TimeZone> tzNames= new TreeMap<String, TimeZone>(String.CASE_INSENSITIVE_ORDER); TimeZoneStrategy(Locale locale) {\n            for(String id : TimeZone.getAvailableIDs()) {\n                if(id.startsWith(\"GMT\")) {\n                    continue;\n                }\n                TimeZone tz= TimeZone.getTimeZone(id);\n                tzNames.put(tz.getDisplayName(false, TimeZone.SHORT, locale), tz);\n                tzNames.put(tz.getDisplayName(false, TimeZone.LONG, locale), tz);\n                if(tz.useDaylightTime()) {\n                    tzNames.put(tz.getDisplayName(true, TimeZone.SHORT, locale), tz);\n                    tzNames.put(tz.getDisplayName(true, TimeZone.LONG, locale), tz);\n                }\n            }\n            StringBuilder sb= new StringBuilder();\n            sb.append(\"(GMT[+\\\\-]\\\\d{0,1}\\\\d{2}|[+\\\\-]\\\\d{2}:?\\\\d{2}|\");\n            for(String id : tzNames.keySet()) {\n                escapeRegex(sb, id, false).append('|');\n            }\n            sb.setCharAt(sb.length()-1, ')');\n            validTimeZoneChars= sb.toString();\n        }\n\n        \n        @Override\n        public boolean isNumber() {\n            return false;\n        }\n\n        \n        @Override\n        public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n            regex.append(validTimeZoneChars);\n            return true;\n        }\n\n        \n        @Override\n        public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n            TimeZone tz;\n            if(value.charAt(0)=='+' || value.charAt(0)=='-') {\n                tz= TimeZone.getTimeZone(\"GMT\"+value);\n            }\n            else if(value.startsWith(\"GMT\")) {\n                tz= TimeZone.getTimeZone(value);\n            }\n            else {\n                tz= tzNames.get(value);\n                if(tz==null) {\n                    throw new IllegalArgumentException(value + \" is not a supported timezone name\");\n                }\n            }\n            cal.setTimeZone(tz);\n        }\n    }\n\n\n    private static final Strategy ERA_STRATEGY = new TextStrategy(Calendar.ERA); private static final Strategy DAY_OF_WEEK_STRATEGY = new TextStrategy(Calendar.DAY_OF_WEEK); private static final Strategy AM_PM_STRATEGY = new TextStrategy(Calendar.AM_PM); private static final Strategy TEXT_MONTH_STRATEGY = new TextStrategy(Calendar.MONTH); private static final Strategy NUMBER_MONTH_STRATEGY = new NumberStrategy(Calendar.MONTH) {\n        @Override\n        public int modify(int iValue) {\n            return iValue-1;\n        }\n    };\n    private static final Strategy LITERAL_YEAR_STRATEGY = new NumberStrategy(Calendar.YEAR); private static final Strategy WEEK_OF_YEAR_STRATEGY = new NumberStrategy(Calendar.WEEK_OF_YEAR); private static final Strategy WEEK_OF_MONTH_STRATEGY = new NumberStrategy(Calendar.WEEK_OF_MONTH); private static final Strategy DAY_OF_YEAR_STRATEGY = new NumberStrategy(Calendar.DAY_OF_YEAR); private static final Strategy DAY_OF_MONTH_STRATEGY = new NumberStrategy(Calendar.DAY_OF_MONTH); private static final Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY = new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); private static final Strategy HOUR_OF_DAY_STRATEGY = new NumberStrategy(Calendar.HOUR_OF_DAY); private static final Strategy MODULO_HOUR_OF_DAY_STRATEGY = new NumberStrategy(Calendar.HOUR_OF_DAY) {\n        @Override\n        public int modify(int iValue) {\n            return iValue%24;\n        }\n    };\n    private static final Strategy MODULO_HOUR_STRATEGY = new NumberStrategy(Calendar.HOUR) {\n        @Override\n        public int modify(int iValue) {\n            return iValue%12;\n        }\n    };\n    private static final Strategy HOUR_STRATEGY = new NumberStrategy(Calendar.HOUR);\n    private static final Strategy MINUTE_STRATEGY = new NumberStrategy(Calendar.MINUTE);\n    private static final Strategy SECOND_STRATEGY = new NumberStrategy(Calendar.SECOND);\n    private static final Strategy MILLISECOND_STRATEGY = new NumberStrategy(Calendar.MILLISECOND);\n}\n",
      "buggy_signatures": [
        "private void init()",
        "public String getPattern()",
        "public TimeZone getTimeZone()",
        "public Locale getLocale()",
        "public boolean equals(Object obj)",
        "public int hashCode()",
        "public String toString()",
        "private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException",
        "public Object parseObject(String source) throws ParseException",
        "public Date parse(String source) throws ParseException",
        "public Object parseObject(String source, ParsePosition pos)",
        "public Date parse(String source, ParsePosition pos)",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote)",
        "private static class KeyValue { public String key; public int value; public KeyValue(String key, int value)",
        "public int compare(KeyValue left, KeyValue right)",
        "private String[] toArray(Map<String, Integer> era)",
        "private static KeyValue[] createKeyValues(String[] longValues, String[] shortValues)",
        "private static int count(String[] values)",
        "private static int copy(KeyValue[] fieldKeyValues, int offset, String[] values)",
        "private interface Strategy { boolean isNumber(); void setCalendar(FastDateParser parser, Calendar cal, String value); boolean addRegex(FastDateParser parser, StringBuilder regex); } private static final Pattern formatPattern= Pattern.compile( \"D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++\"); private Strategy getStrategy(String formatField)",
        "private static class CopyQuotedStrategy implements Strategy { private final String formatField; CopyQuotedStrategy(String formatField)",
        "public boolean isNumber()",
        "public boolean addRegex(FastDateParser parser, StringBuilder regex)",
        "public void setCalendar(FastDateParser parser, Calendar cal, String value)",
        "private static class TextStrategy implements Strategy { private final int field; TextStrategy(int field)",
        "public boolean isNumber()",
        "public boolean addRegex(FastDateParser parser, StringBuilder regex)",
        "public void setCalendar(FastDateParser parser, Calendar cal, String value)",
        "private static class NumberStrategy implements Strategy { protected final int field; NumberStrategy(int field)",
        "public boolean isNumber()",
        "public boolean addRegex(FastDateParser parser, StringBuilder regex)",
        "public void setCalendar(FastDateParser parser, Calendar cal, String value)",
        "public int modify(int iValue)",
        "public void setCalendar(FastDateParser parser, Calendar cal, String value)",
        "public boolean isNumber()",
        "public boolean addRegex(FastDateParser parser, StringBuilder regex)",
        "public void setCalendar(FastDateParser parser, Calendar cal, String value)",
        "public int modify(int iValue)",
        "public int modify(int iValue)",
        "public int modify(int iValue)"
      ],
      "fixed_signatures": [
        "private void init()",
        "public String getPattern()",
        "public TimeZone getTimeZone()",
        "public Locale getLocale()",
        "public boolean equals(Object obj)",
        "public int hashCode()",
        "public String toString()",
        "private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException",
        "public Object parseObject(String source) throws ParseException",
        "public Date parse(String source) throws ParseException",
        "public Object parseObject(String source, ParsePosition pos)",
        "public Date parse(String source, ParsePosition pos)",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote)",
        "private static class KeyValue { public String key; public int value; public KeyValue(String key, int value)",
        "public int compare(KeyValue left, KeyValue right)",
        "private String[] toArray(Map<String, Integer> era)",
        "private static KeyValue[] createKeyValues(String[] longValues, String[] shortValues)",
        "private static int count(String[] values)",
        "private static int copy(KeyValue[] fieldKeyValues, int offset, String[] values)",
        "private interface Strategy { boolean isNumber(); void setCalendar(FastDateParser parser, Calendar cal, String value); boolean addRegex(FastDateParser parser, StringBuilder regex); } private static final Pattern formatPattern= Pattern.compile( \"D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++\"); private Strategy getStrategy(String formatField)",
        "private static class CopyQuotedStrategy implements Strategy { private final String formatField; CopyQuotedStrategy(String formatField)",
        "public boolean isNumber()",
        "public boolean addRegex(FastDateParser parser, StringBuilder regex)",
        "public void setCalendar(FastDateParser parser, Calendar cal, String value)",
        "private static class TextStrategy implements Strategy { private final int field; TextStrategy(int field)",
        "public boolean isNumber()",
        "public boolean addRegex(FastDateParser parser, StringBuilder regex)",
        "public void setCalendar(FastDateParser parser, Calendar cal, String value)",
        "private static class NumberStrategy implements Strategy { protected final int field; NumberStrategy(int field)",
        "public boolean isNumber()",
        "public boolean addRegex(FastDateParser parser, StringBuilder regex)",
        "public void setCalendar(FastDateParser parser, Calendar cal, String value)",
        "public int modify(int iValue)",
        "public void setCalendar(FastDateParser parser, Calendar cal, String value)",
        "public boolean isNumber()",
        "public boolean addRegex(FastDateParser parser, StringBuilder regex)",
        "public void setCalendar(FastDateParser parser, Calendar cal, String value)",
        "public int modify(int iValue)",
        "public int modify(int iValue)",
        "public int modify(int iValue)"
      ],
      "methods": [
        {
          "buggy_method": "  private void init() {\n  thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n\n  nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n\n  StringBuilder regex= new StringBuilder();\n  List<Strategy> collector = new ArrayList<Strategy>();\n\n  Matcher patternMatcher= formatPattern.matcher(pattern);\n  if(!patternMatcher.lookingAt()) {\n  throw new IllegalArgumentException(\"Invalid pattern\");\n  }\n\n  currentFormatField= patternMatcher.group();\n  Strategy currentStrategy= getStrategy(currentFormatField);\n  for(;;) {\n  patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\n  if(!patternMatcher.lookingAt()) {\n  nextStrategy = null;\n  break;\n  }\n  String nextFormatField= patternMatcher.group();\n  nextStrategy = getStrategy(nextFormatField);\n  if(currentStrategy.addRegex(this, regex)) {\n  collector.add(currentStrategy);\n  }\n  currentFormatField= nextFormatField;\n  currentStrategy= nextStrategy;\n  }\n  if(currentStrategy.addRegex(this, regex)) {\n  collector.add(currentStrategy);\n  }\n  currentFormatField= null;\n  strategies= collector.toArray(new Strategy[collector.size()]);\n  parsePattern= Pattern.compile(regex.toString());\n  }",
          "fixed_method": "  private void init() {\n  thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n\n  nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n\n  StringBuilder regex= new StringBuilder();\n  List<Strategy> collector = new ArrayList<Strategy>();\n\n  Matcher patternMatcher= formatPattern.matcher(pattern);\n  if(!patternMatcher.lookingAt()) {\n  throw new IllegalArgumentException(\"Invalid pattern\");\n  }\n\n  currentFormatField= patternMatcher.group();\n  Strategy currentStrategy= getStrategy(currentFormatField);\n  for(;;) {\n  patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\n  if(!patternMatcher.lookingAt()) {\n  nextStrategy = null;\n  break;\n  }\n  String nextFormatField= patternMatcher.group();\n  nextStrategy = getStrategy(nextFormatField);\n  if(currentStrategy.addRegex(this, regex)) {\n  collector.add(currentStrategy);\n  }\n  currentFormatField= nextFormatField;\n  currentStrategy= nextStrategy;\n  }\n  if (patternMatcher.regionStart() != patternMatcher.regionEnd()) {\n  throw new IllegalArgumentException(\"Failed to parse \\\"\"+pattern+\"\\\" ; gave up at index \"+patternMatcher.regionStart());\n  }\n  if(currentStrategy.addRegex(this, regex)) {\n  collector.add(currentStrategy);\n  }\n  currentFormatField= null;\n  strategies= collector.toArray(new Strategy[collector.size()]);\n  parsePattern= Pattern.compile(regex.toString());\n  }",
          "diff": [
            "@@ -140,6 +140,9 @@",
            "             }\n",
            "             currentFormatField= nextFormatField;\n",
            "             currentStrategy= nextStrategy;\n",
            "+        }\n",
            "+        if (patternMatcher.regionStart() != patternMatcher.regionEnd()) {\n",
            "+            throw new IllegalArgumentException(\"Failed to parse \\\"\"+pattern+\"\\\" ; gave up at index \"+patternMatcher.regionStart());\n",
            "         }\n",
            "         if(currentStrategy.addRegex(this, regex)) {\n",
            "             collector.add(currentStrategy);\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
