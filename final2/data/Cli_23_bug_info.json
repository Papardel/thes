{
  "bug_id": "23",
  "failed_tests": {
    "org.apache.commons.cli.bug.BugCLI162Test": [
      {
        "methodName": "testInfiniteLoop",
        "error": "java.lang.RuntimeException",
        "message": "Text too long for line - throwing exception to avoid infinite loop [CLI-162]:              looooong description",
        "fail_line": "        formatter.printHelp(\"app\", options); // used to hang & crash",
        "test_source": "  public void testInfiniteLoop() {\n  HelpFormatter formatter = new HelpFormatter();\n  formatter.setWidth(20);\n  formatter.printHelp(\"app\", options); // used to hang & crash\n  }",
        "stack": [
          "HelpFormatter.renderWrappedText line 836, HelpFormatter.renderOptions line 783, HelpFormatter.printOptions line 662, HelpFormatter.printHelp line 485, HelpFormatter.printHelp line 418, HelpFormatter.printHelp line 334, BugCLI162Test.testInfiniteLoop line 45"
        ]
      },
      {
        "methodName": "testPrintHelpLongLines",
        "error": "java.lang.RuntimeException",
        "message": "Text too long for line - throwing exception to avoid infinite loop [CLI-162]:                              used if omited. Example: -e \"Runs such and such\"",
        "fail_line": "        this.testPrintHelp(commandLineOptions);",
        "test_source": "  public void testPrintHelpLongLines() throws ParseException, IOException {\n  // Constants used for options\n  final String OPT = \"-\";\n\n  final String OPT_COLUMN_NAMES = \"l\";\n\n  final String OPT_CONNECTION = \"c\";\n\n  final String OPT_DESCRIPTION = \"e\";\n\n  final String OPT_DRIVER = \"d\";\n\n  final String OPT_DRIVER_INFO = \"n\";\n\n  final String OPT_FILE_BINDING = \"b\";\n\n  final String OPT_FILE_JDBC = \"j\";\n\n  final String OPT_FILE_SFMD = \"f\";\n\n  final String OPT_HELP = \"h\";\n\n  final String OPT_HELP_ = \"help\";\n\n  final String OPT_INTERACTIVE = \"i\";\n\n  final String OPT_JDBC_TO_SFMD = \"2\";\n\n  final String OPT_JDBC_TO_SFMD_L = \"jdbc2sfmd\";\n\n  final String OPT_METADATA = \"m\";\n\n  final String OPT_PARAM_MODES_INT = \"o\";\n\n  final String OPT_PARAM_MODES_NAME = \"O\";\n\n  final String OPT_PARAM_NAMES = \"a\";\n\n  final String OPT_PARAM_TYPES_INT = \"y\";\n\n  final String OPT_PARAM_TYPES_NAME = \"Y\";\n\n  final String OPT_PASSWORD = \"p\";\n\n  final String OPT_PASSWORD_L = \"password\";\n\n  final String OPT_SQL = \"s\";\n\n  final String OPT_SQL_L = \"sql\";\n\n  final String OPT_SQL_SPLIT_DEFAULT = \"###\";\n\n  final String OPT_SQL_SPLIT_L = \"splitSql\";\n\n  final String OPT_STACK_TRACE = \"t\";\n\n  final String OPT_TIMING = \"g\";\n\n  final String OPT_TRIM_L = \"trim\";\n\n  final String OPT_USER = \"u\";\n\n  final String OPT_WRITE_TO_FILE = \"w\";\n  \n  final String _PMODE_IN = \"IN\";\n\n  final String _PMODE_INOUT = \"INOUT\";\n\n  final String _PMODE_OUT = \"OUT\";\n  \n  final String _PMODE_UNK = \"Unknown\";\n  \n  final String PMODES = _PMODE_IN + \", \" + _PMODE_INOUT + \", \" + _PMODE_OUT + \", \" + _PMODE_UNK;\n  \n  // Options build\n  Options commandLineOptions;\n  commandLineOptions = new Options();\n  commandLineOptions.addOption(OPT_HELP, OPT_HELP_, false, \"Prints help and quits\");\n  commandLineOptions.addOption(OPT_DRIVER, \"driver\", true, \"JDBC driver class name\");\n  commandLineOptions.addOption(OPT_DRIVER_INFO, \"info\", false, \"Prints driver information and properties. If \"\n  + OPT\n  + OPT_CONNECTION\n  + \" is not specified, all drivers on the classpath are displayed.\");\n  commandLineOptions.addOption(OPT_CONNECTION, \"url\", true, \"Connection URL\");\n  commandLineOptions.addOption(OPT_USER, \"user\", true, \"A database user name\");\n  commandLineOptions\n  .addOption(\n  OPT_PASSWORD,\n  OPT_PASSWORD_L,\n  true,\n  \"The database password for the user specified with the \"\n  + OPT\n  + OPT_USER\n  + \" option. You can obfuscate the password with org.mortbay.jetty.security.Password, see http://docs.codehaus.org/display/JETTY/Securing+Passwords\");\n  commandLineOptions.addOption(OPT_SQL, OPT_SQL_L, true, \"Runs SQL or {call stored_procedure(?, ?)} or {?=call function(?, ?)}\");\n  commandLineOptions.addOption(OPT_FILE_SFMD, \"sfmd\", true, \"Writes a SFMD file for the given SQL\");\n  commandLineOptions.addOption(OPT_FILE_BINDING, \"jdbc\", true, \"Writes a JDBC binding node file for the given SQL\");\n  commandLineOptions.addOption(OPT_FILE_JDBC, \"node\", true, \"Writes a JDBC node file for the given SQL (internal debugging)\");\n  commandLineOptions.addOption(OPT_WRITE_TO_FILE, \"outfile\", true, \"Writes the SQL output to the given file\");\n  commandLineOptions.addOption(OPT_DESCRIPTION, \"description\", true,\n  \"SFMD description. A default description is used if omited. Example: \" + OPT + OPT_DESCRIPTION + \" \\\"Runs such and such\\\"\");\n  commandLineOptions.addOption(OPT_INTERACTIVE, \"interactive\", false,\n  \"Runs in interactive mode, reading and writing from the console, 'go' or '/' sends a statement\");\n  commandLineOptions.addOption(OPT_TIMING, \"printTiming\", false, \"Prints timing information\");\n  commandLineOptions.addOption(OPT_METADATA, \"printMetaData\", false, \"Prints metadata information\");\n  commandLineOptions.addOption(OPT_STACK_TRACE, \"printStack\", false, \"Prints stack traces on errors\");\n  Option option = new Option(OPT_COLUMN_NAMES, \"columnNames\", true, \"Column XML names; default names column labels. Example: \"\n  + OPT\n  + OPT_COLUMN_NAMES\n  + \" \\\"cname1 cname2\\\"\");\n  commandLineOptions.addOption(option);\n  option = new Option(OPT_PARAM_NAMES, \"paramNames\", true, \"Parameter XML names; default names are param1, param2, etc. Example: \"\n  + OPT\n  + OPT_PARAM_NAMES\n  + \" \\\"pname1 pname2\\\"\");\n  commandLineOptions.addOption(option);\n  //\n  OptionGroup pOutTypesOptionGroup = new OptionGroup();\n  String pOutTypesOptionGroupDoc = OPT + OPT_PARAM_TYPES_INT + \" and \" + OPT + OPT_PARAM_TYPES_NAME + \" are mutually exclusive.\";\n  final String typesClassName = Types.class.getName();\n  option = new Option(OPT_PARAM_TYPES_INT, \"paramTypes\", true, \"Parameter types from \"\n  + typesClassName\n  + \". \"\n  + pOutTypesOptionGroupDoc\n  + \" Example: \"\n  + OPT\n  + OPT_PARAM_TYPES_INT\n  + \" \\\"-10 12\\\"\");\n  commandLineOptions.addOption(option);\n  option = new Option(OPT_PARAM_TYPES_NAME, \"paramTypeNames\", true, \"Parameter \"\n  + typesClassName\n  + \" names. \"\n  + pOutTypesOptionGroupDoc\n  + \" Example: \"\n  + OPT\n  + OPT_PARAM_TYPES_NAME\n  + \" \\\"CURSOR VARCHAR\\\"\");\n  commandLineOptions.addOption(option);\n  commandLineOptions.addOptionGroup(pOutTypesOptionGroup);\n  //\n  OptionGroup modesOptionGroup = new OptionGroup();\n  String modesOptionGroupDoc = OPT + OPT_PARAM_MODES_INT + \" and \" + OPT + OPT_PARAM_MODES_NAME + \" are mutually exclusive.\";\n  option = new Option(OPT_PARAM_MODES_INT, \"paramModes\", true, \"Parameters modes (\"\n  + ParameterMetaData.parameterModeIn\n  + \"=IN, \"\n  + ParameterMetaData.parameterModeInOut\n  + \"=INOUT, \"\n  + ParameterMetaData.parameterModeOut\n  + \"=OUT, \"\n  + ParameterMetaData.parameterModeUnknown\n  + \"=Unknown\"\n  + \"). \"\n  + modesOptionGroupDoc\n  + \" Example for 2 parameters, OUT and IN: \"\n  + OPT\n  + OPT_PARAM_MODES_INT\n  + \" \\\"\"\n  + ParameterMetaData.parameterModeOut\n  + \" \"\n  + ParameterMetaData.parameterModeIn\n  + \"\\\"\");\n  modesOptionGroup.addOption(option);\n  option = new Option(OPT_PARAM_MODES_NAME, \"paramModeNames\", true, \"Parameters mode names (\"\n  + PMODES\n  + \"). \"\n  + modesOptionGroupDoc\n  + \" Example for 2 parameters, OUT and IN: \"\n  + OPT\n  + OPT_PARAM_MODES_NAME\n  + \" \\\"\"\n  + _PMODE_OUT\n  + \" \"\n  + _PMODE_IN\n  + \"\\\"\");\n  modesOptionGroup.addOption(option);\n  commandLineOptions.addOptionGroup(modesOptionGroup);\n  option = new Option(null, OPT_TRIM_L, true,\n  \"Trims leading and trailing spaces from all column values. Column XML names can be optionally specified to set which columns to trim.\");\n  option.setOptionalArg(true);\n  commandLineOptions.addOption(option);\n  option = new Option(OPT_JDBC_TO_SFMD, OPT_JDBC_TO_SFMD_L, true,\n  \"Converts the JDBC file in the first argument to an SMFD file specified in the second argument.\");\n  option.setArgs(2);\n  commandLineOptions.addOption(option);\n  this.testPrintHelp(commandLineOptions);\n  }",
        "stack": [
          "HelpFormatter.renderWrappedText line 836, HelpFormatter.renderOptions line 783, HelpFormatter.printOptions line 662, HelpFormatter.printHelp line 485, HelpFormatter.printHelp line 418, HelpFormatter.printHelp line 334, BugCLI162Test.testPrintHelp line 49, BugCLI162Test.testPrintHelpLongLines line 236"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/cli/HelpFormatter.java",
      "buggy_full_code": "\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n\npublic class HelpFormatter { public static final int DEFAULT_WIDTH = 74; public static final int DEFAULT_LEFT_PAD = 1; public static final int DEFAULT_DESC_PAD = 3; public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \"; public static final String DEFAULT_OPT_PREFIX = \"-\"; public static final String DEFAULT_LONG_OPT_PREFIX = \"--\"; public static final String DEFAULT_ARG_NAME = \"arg\"; public int defaultWidth = DEFAULT_WIDTH; public int defaultLeftPad = DEFAULT_LEFT_PAD; public int defaultDescPad = DEFAULT_DESC_PAD; public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX; public String defaultNewLine = System.getProperty(\"line.separator\"); public String defaultOptPrefix = DEFAULT_OPT_PREFIX; public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX; public String defaultArgName = DEFAULT_ARG_NAME; protected Comparator optionComparator = new OptionComparator(); public void setWidth(int width) {\n        this.defaultWidth = width;\n    }\n\n    \n    public int getWidth() {\n        return defaultWidth;\n    }\n\n    \n    public void setLeftPadding(int padding) {\n        this.defaultLeftPad = padding;\n    }\n\n    \n    public int getLeftPadding() {\n        return defaultLeftPad;\n    }\n\n    \n    public void setDescPadding(int padding) {\n        this.defaultDescPad = padding;\n    }\n\n    \n    public int getDescPadding() {\n        return defaultDescPad;\n    }\n\n    \n    public void setSyntaxPrefix(String prefix) {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    \n    public String getSyntaxPrefix() {\n        return defaultSyntaxPrefix;\n    }\n\n    \n    public void setNewLine(String newline) {\n        this.defaultNewLine = newline;\n    }\n\n    \n    public String getNewLine() {\n        return defaultNewLine;\n    }\n\n    \n    public void setOptPrefix(String prefix) {\n        this.defaultOptPrefix = prefix;\n    }\n\n    \n    public String getOptPrefix() {\n        return defaultOptPrefix;\n    }\n\n    \n    public void setLongOptPrefix(String prefix) {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    \n    public String getLongOptPrefix() {\n        return defaultLongOptPrefix;\n    }\n\n    \n    public void setArgName(String name) {\n        this.defaultArgName = name;\n    }\n\n    \n    public String getArgName() {\n        return defaultArgName;\n    }\n\n    \n    public Comparator getOptionComparator() {\n        return optionComparator;\n    }\n\n    \n    public void setOptionComparator(Comparator comparator) {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    \n    public void printHelp(String cmdLineSyntax, Options options) {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    \n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage) {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    \n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer) {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    \n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage) {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    \n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer) {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    \n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage) {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    \n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, String header, Options options, int leftPad, int descPad, String footer) {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    \n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, String header, Options options, int leftPad, int descPad, String footer, boolean autoUsage) {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    \n    public void printUsage(PrintWriter pw, int width, String app, Options options) {\n        \n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        \n        final Collection processedGroups = new ArrayList();\n\n        \n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        \n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            \n            option = (Option) i.next();\n\n            \n            OptionGroup group = options.getOptionGroup(option);\n\n            \n            if (group != null)\n            {\n                \n                if (!processedGroups.contains(group))\n                {\n                    \n                    processedGroups.add(group);\n\n\n                    \n                    appendOptionGroup(buff, group);\n                }\n\n                \n                \n            }\n\n            \n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        \n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    \n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group) {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        \n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            \n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    \n    private static void appendOption(final StringBuffer buff, final Option option, final boolean required) {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n\n        \n        if (option.hasArg() && option.hasArgName())\n        {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n\n        \n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    \n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax) {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    \n    public void printOptions(PrintWriter pw, int width, Options options, int leftPad, int descPad) {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    \n    public void printWrapped(PrintWriter pw, int width, String text) {\n        printWrapped(pw, width, 0, text);\n    }\n\n    \n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text) {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    \n\n    \n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad) {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        \n        \n        \n        \n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    \n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        \n        \n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            int lastPos = pos;\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            } else\n            if (pos == lastPos)\n            {\n                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    \n    protected int findWrapPos(String text, int width, int startPos) {\n        int pos = -1;\n\n        \n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        \n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        \n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        \n        \n        pos = startPos + width;\n\n        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            ++pos;\n        }\n\n        return (pos == text.length()) ? (-1) : pos;\n    }\n\n    \n    protected String createPadding(int len) {\n        StringBuffer sb = new StringBuffer(len);\n\n        for (int i = 0; i < len; ++i)\n        {\n            sb.append(' ');\n        }\n\n        return sb.toString();\n    }\n\n    \n    protected String rtrim(String s) {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    \n    \n    \n    \n    private static class OptionComparator implements Comparator { public int compare(Object o1, Object o2) {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n\npublic class HelpFormatter { public static final int DEFAULT_WIDTH = 74; public static final int DEFAULT_LEFT_PAD = 1; public static final int DEFAULT_DESC_PAD = 3; public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \"; public static final String DEFAULT_OPT_PREFIX = \"-\"; public static final String DEFAULT_LONG_OPT_PREFIX = \"--\"; public static final String DEFAULT_ARG_NAME = \"arg\"; public int defaultWidth = DEFAULT_WIDTH; public int defaultLeftPad = DEFAULT_LEFT_PAD; public int defaultDescPad = DEFAULT_DESC_PAD; public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX; public String defaultNewLine = System.getProperty(\"line.separator\"); public String defaultOptPrefix = DEFAULT_OPT_PREFIX; public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX; public String defaultArgName = DEFAULT_ARG_NAME; protected Comparator optionComparator = new OptionComparator(); public void setWidth(int width) {\n        this.defaultWidth = width;\n    }\n\n    \n    public int getWidth() {\n        return defaultWidth;\n    }\n\n    \n    public void setLeftPadding(int padding) {\n        this.defaultLeftPad = padding;\n    }\n\n    \n    public int getLeftPadding() {\n        return defaultLeftPad;\n    }\n\n    \n    public void setDescPadding(int padding) {\n        this.defaultDescPad = padding;\n    }\n\n    \n    public int getDescPadding() {\n        return defaultDescPad;\n    }\n\n    \n    public void setSyntaxPrefix(String prefix) {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    \n    public String getSyntaxPrefix() {\n        return defaultSyntaxPrefix;\n    }\n\n    \n    public void setNewLine(String newline) {\n        this.defaultNewLine = newline;\n    }\n\n    \n    public String getNewLine() {\n        return defaultNewLine;\n    }\n\n    \n    public void setOptPrefix(String prefix) {\n        this.defaultOptPrefix = prefix;\n    }\n\n    \n    public String getOptPrefix() {\n        return defaultOptPrefix;\n    }\n\n    \n    public void setLongOptPrefix(String prefix) {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    \n    public String getLongOptPrefix() {\n        return defaultLongOptPrefix;\n    }\n\n    \n    public void setArgName(String name) {\n        this.defaultArgName = name;\n    }\n\n    \n    public String getArgName() {\n        return defaultArgName;\n    }\n\n    \n    public Comparator getOptionComparator() {\n        return optionComparator;\n    }\n\n    \n    public void setOptionComparator(Comparator comparator) {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    \n    public void printHelp(String cmdLineSyntax, Options options) {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    \n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage) {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    \n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer) {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    \n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage) {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    \n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer) {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    \n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage) {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    \n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, String header, Options options, int leftPad, int descPad, String footer) {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    \n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, String header, Options options, int leftPad, int descPad, String footer, boolean autoUsage) {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    \n    public void printUsage(PrintWriter pw, int width, String app, Options options) {\n        \n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        \n        final Collection processedGroups = new ArrayList();\n\n        \n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        \n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            \n            option = (Option) i.next();\n\n            \n            OptionGroup group = options.getOptionGroup(option);\n\n            \n            if (group != null)\n            {\n                \n                if (!processedGroups.contains(group))\n                {\n                    \n                    processedGroups.add(group);\n\n\n                    \n                    appendOptionGroup(buff, group);\n                }\n\n                \n                \n            }\n\n            \n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        \n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    \n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group) {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        \n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            \n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    \n    private static void appendOption(final StringBuffer buff, final Option option, final boolean required) {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n\n        \n        if (option.hasArg() && option.hasArgName())\n        {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n\n        \n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    \n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax) {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    \n    public void printOptions(PrintWriter pw, int width, Options options, int leftPad, int descPad) {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    \n    public void printWrapped(PrintWriter pw, int width, String text) {\n        printWrapped(pw, width, 0, text);\n    }\n\n    \n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text) {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    \n\n    \n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad) {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        \n        \n        \n        \n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    \n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        \n        \n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) {\n                sb.append(text);\n\n                return sb;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    \n    protected int findWrapPos(String text, int width, int startPos) {\n        int pos = -1;\n\n        \n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        \n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        \n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        \n        \n        pos = startPos + width;\n\n        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            ++pos;\n        }\n\n        return (pos == text.length()) ? (-1) : pos;\n    }\n\n    \n    protected String createPadding(int len) {\n        StringBuffer sb = new StringBuffer(len);\n\n        for (int i = 0; i < len; ++i)\n        {\n            sb.append(' ');\n        }\n\n        return sb.toString();\n    }\n\n    \n    protected String rtrim(String s) {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    \n    \n    \n    \n    private static class OptionComparator implements Comparator { public int compare(Object o1, Object o2) {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public int getWidth()",
        "public void setLeftPadding(int padding)",
        "public int getLeftPadding()",
        "public void setDescPadding(int padding)",
        "public int getDescPadding()",
        "public void setSyntaxPrefix(String prefix)",
        "public String getSyntaxPrefix()",
        "public void setNewLine(String newline)",
        "public String getNewLine()",
        "public void setOptPrefix(String prefix)",
        "public String getOptPrefix()",
        "public void setLongOptPrefix(String prefix)",
        "public String getLongOptPrefix()",
        "public void setArgName(String name)",
        "public String getArgName()",
        "public Comparator getOptionComparator()",
        "public void setOptionComparator(Comparator comparator)",
        "public void printHelp(String cmdLineSyntax, Options options)",
        "public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)",
        "public void printHelp(String cmdLineSyntax, String header, Options options, String footer)",
        "public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)",
        "public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)",
        "public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)",
        "public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, String header, Options options, int leftPad, int descPad, String footer)",
        "public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, String header, Options options, int leftPad, int descPad, String footer, boolean autoUsage)",
        "public void printUsage(PrintWriter pw, int width, String app, Options options)",
        "private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)",
        "private static void appendOption(final StringBuffer buff, final Option option, final boolean required)",
        "public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)",
        "public void printOptions(PrintWriter pw, int width, Options options, int leftPad, int descPad)",
        "public void printWrapped(PrintWriter pw, int width, String text)",
        "public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)",
        "protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text)",
        "protected int findWrapPos(String text, int width, int startPos)",
        "protected String createPadding(int len)",
        "protected String rtrim(String s)",
        "private static class OptionComparator implements Comparator { public int compare(Object o1, Object o2)"
      ],
      "fixed_signatures": [
        "public int getWidth()",
        "public void setLeftPadding(int padding)",
        "public int getLeftPadding()",
        "public void setDescPadding(int padding)",
        "public int getDescPadding()",
        "public void setSyntaxPrefix(String prefix)",
        "public String getSyntaxPrefix()",
        "public void setNewLine(String newline)",
        "public String getNewLine()",
        "public void setOptPrefix(String prefix)",
        "public String getOptPrefix()",
        "public void setLongOptPrefix(String prefix)",
        "public String getLongOptPrefix()",
        "public void setArgName(String name)",
        "public String getArgName()",
        "public Comparator getOptionComparator()",
        "public void setOptionComparator(Comparator comparator)",
        "public void printHelp(String cmdLineSyntax, Options options)",
        "public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)",
        "public void printHelp(String cmdLineSyntax, String header, Options options, String footer)",
        "public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)",
        "public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)",
        "public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)",
        "public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, String header, Options options, int leftPad, int descPad, String footer)",
        "public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, String header, Options options, int leftPad, int descPad, String footer, boolean autoUsage)",
        "public void printUsage(PrintWriter pw, int width, String app, Options options)",
        "private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)",
        "private static void appendOption(final StringBuffer buff, final Option option, final boolean required)",
        "public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)",
        "public void printOptions(PrintWriter pw, int width, Options options, int leftPad, int descPad)",
        "public void printWrapped(PrintWriter pw, int width, String text)",
        "public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)",
        "protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text)",
        "protected int findWrapPos(String text, int width, int startPos)",
        "protected String createPadding(int len)",
        "protected String rtrim(String s)",
        "private static class OptionComparator implements Comparator { public int compare(Object o1, Object o2)"
      ],
      "methods": [
        {
          "buggy_method": "  protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) {\n  int pos = findWrapPos(text, width, 0);\n\n  if (pos == -1)\n  {\n  sb.append(rtrim(text));\n\n  return sb;\n  }\n  sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n  \n  \n  final String padding = createPadding(nextLineTabStop);\n\n  while (true)\n  {\n  int lastPos = pos;\n  text = padding + text.substring(pos).trim();\n  pos = findWrapPos(text, width, 0);\n\n  if (pos == -1)\n  {\n  sb.append(text);\n\n  return sb;\n  } else\n  if (pos == lastPos)\n  {\n  throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n  }\n\n  sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n  }\n  }",
          "fixed_method": "  protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) {\n  int pos = findWrapPos(text, width, 0);\n\n  if (pos == -1)\n  {\n  sb.append(rtrim(text));\n\n  return sb;\n  }\n  sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n  \n  \n  final String padding = createPadding(nextLineTabStop);\n\n  while (true)\n  {\n  text = padding + text.substring(pos).trim();\n  pos = findWrapPos(text, width, 0);\n\n  if (pos == -1)\n  {\n  sb.append(text);\n\n  return sb;\n  }\n  \n  if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) {\n  sb.append(text);\n\n  return sb;\n  }\n\n  sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n  }\n  }",
          "diff": [
            "@@ -821,7 +821,6 @@",
            " \n",
            "         while (true)\n",
            "         {\n",
            "-            int lastPos = pos;\n",
            "             text = padding + text.substring(pos).trim();\n",
            "             pos = findWrapPos(text, width, 0);\n",
            " \n",
            "@@ -830,10 +829,12 @@",
            "                 sb.append(text);\n",
            " \n",
            "                 return sb;\n",
            "-            } else\n",
            "-            if (pos == lastPos)\n",
            "-            {\n",
            "-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n",
            "+            }\n",
            "+            \n",
            "+            if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) {\n",
            "+                sb.append(text);\n",
            "+\n",
            "+                return sb;\n",
            "             }\n",
            " \n",
            "             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n"
          ],
          "changed_lines": 11
        }
      ]
    }
  ]
}
