{
  "bug_id": "11",
  "failed_tests": {
    "org.apache.commons.csv.CSVParserTest": [
      {
        "methodName": "testHeaderMissingWithNull",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "        CSVFormat.DEFAULT.withHeader().withNullString(\"\").withIgnoreEmptyHeaders(true).parse(in).iterator();",
        "test_source": "  public void testHeaderMissingWithNull() throws Exception {\n  final Reader in = new StringReader(\"a,,c,,d\\n1,2,3,4\\nx,y,z,zz\");\n  CSVFormat.DEFAULT.withHeader().withNullString(\"\").withIgnoreEmptyHeaders(true).parse(in).iterator();\n  }",
        "stack": [
          "CSVParser.initializeHeader line 384, CSVParser.<init> line 250, CSVFormat.parse line 611, CSVParserTest.testHeaderMissingWithNull line 670"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/csv/CSVParser.java",
      "buggy_full_code": "\n\npackage org.apache.commons.csv;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\nimport static org.apache.commons.csv.Token.Type.*; public final class CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        \n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    \n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    \n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    \n\n    private final CSVFormat format; private final Map<String, Integer> headerMap; private final Lexer lexer; private final List<String> record = new ArrayList<String>(); private long recordNumber; private final Token reusableToken = new Token(); public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.headerMap = this.initializeHeader();\n    }\n\n    private void addRecordValue() {\n        final String input = this.reusableToken.content.toString();\n        final String nullString = this.format.getNullString();\n        if (nullString == null) {\n            this.record.add(input);\n        } else {\n            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n        }\n    }\n\n    \n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    \n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    \n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n\n    \n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    \n    public List<CSVRecord> getRecords() throws IOException {\n        return getRecords(new ArrayList<CSVRecord>());\n    }\n\n    \n    public <T extends Collection<CSVRecord>> T getRecords(final T records) throws IOException {\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    \n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                \n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            \n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    \n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current; private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    \n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    \n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n\n    \n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.record.clear();\n        StringBuilder sb = null;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: \n                if (sb == null) { \n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; \n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.record.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n                    this.recordNumber);\n        }\n        return result;\n    }\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.csv;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\nimport static org.apache.commons.csv.Token.Type.*; public final class CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        \n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    \n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    \n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    \n\n    private final CSVFormat format; private final Map<String, Integer> headerMap; private final Lexer lexer; private final List<String> record = new ArrayList<String>(); private long recordNumber; private final Token reusableToken = new Token(); public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.headerMap = this.initializeHeader();\n    }\n\n    private void addRecordValue() {\n        final String input = this.reusableToken.content.toString();\n        final String nullString = this.format.getNullString();\n        if (nullString == null) {\n            this.record.add(input);\n        } else {\n            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n        }\n    }\n\n    \n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    \n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    \n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n\n    \n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    \n    public List<CSVRecord> getRecords() throws IOException {\n        return getRecords(new ArrayList<CSVRecord>());\n    }\n\n    \n    public <T extends Collection<CSVRecord>> T getRecords(final T records) throws IOException {\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    \n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                \n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            \n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    \n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current; private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    \n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    \n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n\n    \n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.record.clear();\n        StringBuilder sb = null;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: \n                if (sb == null) { \n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; \n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.record.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n                    this.recordNumber);\n        }\n        return result;\n    }\n\n}\n",
      "buggy_signatures": [
        "static org.apache.commons.csv.Token.Type.*; public final class CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException",
        "public static CSVParser parse(final String string, final CSVFormat format) throws IOException",
        "public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException",
        "private void addRecordValue()",
        "public void close() throws IOException",
        "public long getCurrentLineNumber()",
        "public Map<String, Integer> getHeaderMap()",
        "public long getRecordNumber()",
        "public List<CSVRecord> getRecords() throws IOException",
        "public <T extends Collection<CSVRecord>> T getRecords(final T records) throws IOException",
        "private Map<String, Integer> initializeHeader() throws IOException",
        "public boolean isClosed()",
        "public Iterator<CSVRecord> iterator()",
        "private CSVRecord current; private CSVRecord getNextRecord()",
        "public boolean hasNext()",
        "public CSVRecord next()",
        "public void remove()"
      ],
      "fixed_signatures": [
        "static org.apache.commons.csv.Token.Type.*; public final class CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException",
        "public static CSVParser parse(final String string, final CSVFormat format) throws IOException",
        "public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException",
        "private void addRecordValue()",
        "public void close() throws IOException",
        "public long getCurrentLineNumber()",
        "public Map<String, Integer> getHeaderMap()",
        "public long getRecordNumber()",
        "public List<CSVRecord> getRecords() throws IOException",
        "public <T extends Collection<CSVRecord>> T getRecords(final T records) throws IOException",
        "private Map<String, Integer> initializeHeader() throws IOException",
        "public boolean isClosed()",
        "public Iterator<CSVRecord> iterator()",
        "private CSVRecord current; private CSVRecord getNextRecord()",
        "public boolean hasNext()",
        "public CSVRecord next()",
        "public void remove()"
      ],
      "methods": [
        {
          "buggy_method": "  private Map<String, Integer> initializeHeader() throws IOException {\n  Map<String, Integer> hdrMap = null;\n  final String[] formatHeader = this.format.getHeader();\n  if (formatHeader != null) {\n  hdrMap = new LinkedHashMap<String, Integer>();\n\n  String[] headerRecord = null;\n  if (formatHeader.length == 0) {\n  \n  final CSVRecord nextRecord = this.nextRecord();\n  if (nextRecord != null) {\n  headerRecord = nextRecord.values();\n  }\n  } else {\n  if (this.format.getSkipHeaderRecord()) {\n  this.nextRecord();\n  }\n  headerRecord = formatHeader;\n  }\n\n  \n  if (headerRecord != null) {\n  for (int i = 0; i < headerRecord.length; i++) {\n  final String header = headerRecord[i];\n  final boolean containsHeader = hdrMap.containsKey(header);\n  final boolean emptyHeader = header.trim().isEmpty();\n  if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n  throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n  \"\\\" in \" + Arrays.toString(headerRecord));\n  }\n  hdrMap.put(header, Integer.valueOf(i));\n  }\n  }\n  }\n  return hdrMap;\n  }",
          "fixed_method": "  private Map<String, Integer> initializeHeader() throws IOException {\n  Map<String, Integer> hdrMap = null;\n  final String[] formatHeader = this.format.getHeader();\n  if (formatHeader != null) {\n  hdrMap = new LinkedHashMap<String, Integer>();\n\n  String[] headerRecord = null;\n  if (formatHeader.length == 0) {\n  \n  final CSVRecord nextRecord = this.nextRecord();\n  if (nextRecord != null) {\n  headerRecord = nextRecord.values();\n  }\n  } else {\n  if (this.format.getSkipHeaderRecord()) {\n  this.nextRecord();\n  }\n  headerRecord = formatHeader;\n  }\n\n  \n  if (headerRecord != null) {\n  for (int i = 0; i < headerRecord.length; i++) {\n  final String header = headerRecord[i];\n  final boolean containsHeader = hdrMap.containsKey(header);\n  final boolean emptyHeader = header == null || header.trim().isEmpty();\n  if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n  throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n  \"\\\" in \" + Arrays.toString(headerRecord));\n  }\n  hdrMap.put(header, Integer.valueOf(i));\n  }\n  }\n  }\n  return hdrMap;\n  }",
          "diff": [
            "@@ -381,7 +381,7 @@",
            "                 for (int i = 0; i < headerRecord.length; i++) {\n",
            "                     final String header = headerRecord[i];\n",
            "                     final boolean containsHeader = hdrMap.containsKey(header);\n",
            "-                    final boolean emptyHeader = header.trim().isEmpty();\n",
            "+                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n",
            "                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n",
            "                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n",
            "                                 \"\\\" in \" + Arrays.toString(headerRecord));\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
