{
  "bug_id": "8",
  "failed_tests": {
    "com.fasterxml.jackson.databind.deser.TestJdkTypes": [
      {
        "methodName": "testStringBuilder",
        "error": "com.fasterxml.jackson.databind.JsonMappingException",
        "message": "Conflicting String creators: already had explicitly marked [constructor for java.lang.StringBuilder, annotations: [null]], encountered [constructor for java.lang.StringBuilder, annotations: {interface jdk.internal.HotSpotIntrinsicCandidate=@jdk.internal.HotSpotIntrinsicCandidate()}]",
        "fail_line": "        StringBuilder sb = MAPPER.readValue(quote(\"abc\"), StringBuilder.class);",
        "test_source": "  public void testStringBuilder() throws Exception {\n  StringBuilder sb = MAPPER.readValue(quote(\"abc\"), StringBuilder.class);\n  assertEquals(\"abc\", sb.toString());\n  }",
        "stack": [
          "DeserializerCache._createAndCache2 line 267, DeserializerCache._createAndCacheValueDeserializer line 242, DeserializerCache.findValueDeserializer line 143, DeserializationContext.findRootValueDeserializer line 439, ObjectMapper._findRootDeserializer line 3664, ObjectMapper._readMapAndClose line 3556, ObjectMapper.readValue line 2576, TestJdkTypes.testStringBuilder line 425, CreatorCollector.verifyNonDup line 297, CreatorCollector.addStringCreator line 158, BasicDeserializerFactory._handleSingleArgumentConstructor line 555, BasicDeserializerFactory._addDeserializerConstructors line 439, BasicDeserializerFactory._constructDefaultValueInstantiator line 325, BasicDeserializerFactory.findValueInstantiator line 258, BeanDeserializerFactory.buildBeanDeserializer line 216, BeanDeserializerFactory.createBeanDeserializer line 143, DeserializerCache._createDeserializer2 line 405, DeserializerCache._createDeserializer line 354, DeserializerCache._createAndCache2 line 262"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.deser.impl;\n\nimport java.io.IOException;\nimport java.lang.reflect.Member;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.BeanDescription;\nimport com.fasterxml.jackson.databind.DeserializationConfig;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.deser.CreatorProperty;\nimport com.fasterxml.jackson.databind.deser.ValueInstantiator;\nimport com.fasterxml.jackson.databind.deser.std.StdValueInstantiator;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.type.TypeBindings;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\npublic class CreatorCollector { protected final static int C_DEFAULT = 0; protected final static int C_STRING = 1; protected final static int C_INT = 2; protected final static int C_LONG = 3; protected final static int C_DOUBLE = 4; protected final static int C_BOOLEAN = 5; protected final static int C_DELEGATE = 6; protected final static int C_PROPS = 7; protected final static String[] TYPE_DESCS = new String[] { \"default\", \"String\", \"int\", \"long\", \"double\", \"boolean\", \"delegate\", \"property-based\" }; final protected BeanDescription _beanDesc; final protected boolean _canFixAccess; protected final AnnotatedWithParams[] _creators = new AnnotatedWithParams[8]; protected int _explicitCreators = 0; protected boolean _hasNonDefaultCreator = false; protected CreatorProperty[] _delegateArgs; protected CreatorProperty[] _propertyBasedArgs; protected AnnotatedParameter _incompleteParameter; public CreatorCollector(BeanDescription beanDesc, boolean canFixAccess) {\n        _beanDesc = beanDesc;\n        _canFixAccess = canFixAccess;\n    }\n\n    public ValueInstantiator constructValueInstantiator(DeserializationConfig config) {\n        JavaType delegateType;\n        boolean maybeVanilla = !_hasNonDefaultCreator;\n\n        if (maybeVanilla || (_creators[C_DELEGATE] == null)) {\n            delegateType = null;\n        } else {\n            \n            int ix = 0;\n            if (_delegateArgs != null) {\n                for (int i = 0, len = _delegateArgs.length; i < len; ++i) {\n                    if (_delegateArgs[i] == null) { \n                        ix = i;\n                        break;\n                    }\n                }\n            }\n            TypeBindings bindings = _beanDesc.bindingsForBeanType();\n            delegateType = bindings.resolveType(_creators[C_DELEGATE].getGenericParameterType(ix));\n        }\n\n        final JavaType type = _beanDesc.getType();\n\n        \n        \n        maybeVanilla &= !_hasNonDefaultCreator;\n\n        if (maybeVanilla) {\n            \n            final Class<?> rawType = type.getRawClass();\n            if (rawType == Collection.class || rawType == List.class || rawType == ArrayList.class) {\n                return new Vanilla(Vanilla.TYPE_COLLECTION);\n            }\n            if (rawType == Map.class || rawType == LinkedHashMap.class) {\n                return new Vanilla(Vanilla.TYPE_MAP);\n            }\n            if (rawType == HashMap.class) {\n                return new Vanilla(Vanilla.TYPE_HASH_MAP);\n            }\n        }\n        \n        StdValueInstantiator inst = new StdValueInstantiator(config, type);\n        inst.configureFromObjectSettings(_creators[C_DEFAULT],\n                _creators[C_DELEGATE], delegateType, _delegateArgs,\n                _creators[C_PROPS], _propertyBasedArgs);\n        inst.configureFromStringCreator(_creators[C_STRING]);\n        inst.configureFromIntCreator(_creators[C_INT]);\n        inst.configureFromLongCreator(_creators[C_LONG]);\n        inst.configureFromDoubleCreator(_creators[C_DOUBLE]);\n        inst.configureFromBooleanCreator(_creators[C_BOOLEAN]);\n        inst.configureIncompleteParameter(_incompleteParameter);\n        return inst;\n    }\n    \n    \n    \n    \n    public void setDefaultCreator(AnnotatedWithParams creator) {\n        _creators[C_DEFAULT] = _fixAccess(creator);\n    }\n    \n    public void addStringCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_STRING, explicit);\n    }\n    public void addIntCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_INT, explicit);\n    }\n    public void addLongCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_LONG, explicit);\n    }\n    public void addDoubleCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_DOUBLE, explicit);\n    }\n    public void addBooleanCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_BOOLEAN, explicit);\n    }\n\n    public void addDelegatingCreator(AnnotatedWithParams creator, boolean explicit, CreatorProperty[] injectables) {\n        verifyNonDup(creator, C_DELEGATE, explicit);\n        _delegateArgs = injectables;\n    }\n    \n    public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit, CreatorProperty[] properties) {\n        verifyNonDup(creator, C_PROPS, explicit);\n        \n        if (properties.length > 1) {\n            HashMap<String,Integer> names = new HashMap<String,Integer>();\n            for (int i = 0, len = properties.length; i < len; ++i) {\n                String name = properties[i].getName();\n                \n                if (name.length() == 0 && properties[i].getInjectableValueId() != null) {\n                    continue;\n                }\n                Integer old = names.put(name, Integer.valueOf(i));\n                if (old != null) {\n                    throw new IllegalArgumentException(\"Duplicate creator property \\\"\"+name+\"\\\" (index \"+old+\" vs \"+i+\")\");\n                }\n            }\n        }\n        _propertyBasedArgs = properties;\n    }\n\n    public void addIncompeteParameter(AnnotatedParameter parameter) {\n        if (_incompleteParameter == null) {\n            _incompleteParameter = parameter;\n        }\n    }\n\n    \n    \n    @Deprecated \n    public void addStringCreator(AnnotatedWithParams creator) {\n        addStringCreator(creator, false);\n    }\n    @Deprecated \n    public void addIntCreator(AnnotatedWithParams creator) {\n        addBooleanCreator(creator, false);\n    }\n    @Deprecated \n    public void addLongCreator(AnnotatedWithParams creator) {\n        addBooleanCreator(creator, false);\n    }\n    @Deprecated \n    public void addDoubleCreator(AnnotatedWithParams creator) {\n        addBooleanCreator(creator, false);\n    }\n    @Deprecated \n    public void addBooleanCreator(AnnotatedWithParams creator) {\n        addBooleanCreator(creator, false);\n    }\n\n    @Deprecated \n    public void addDelegatingCreator(AnnotatedWithParams creator, CreatorProperty[] injectables) {\n        addDelegatingCreator(creator, false, injectables);\n    }\n\n    @Deprecated \n    public void addPropertyCreator(AnnotatedWithParams creator, CreatorProperty[] properties) {\n        addPropertyCreator(creator, false, properties);\n    }\n\n    @Deprecated \n    protected AnnotatedWithParams verifyNonDup(AnnotatedWithParams newOne, int typeIndex) {\n        verifyNonDup(newOne, typeIndex, false);\n        return _creators[typeIndex];\n    }\n    \n    \n\n    \n    public boolean hasDefaultCreator() {\n        return _creators[C_DEFAULT] != null;\n    }\n\n    \n\n    private <T extends AnnotatedMember> T _fixAccess(T member) {\n        if (member != null && _canFixAccess) {\n            ClassUtil.checkAndFixAccess((Member) member.getAnnotated());\n        }\n        return member;\n    }\n\n    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit) {\n        final int mask = (1 << typeIndex);\n        _hasNonDefaultCreator = true;\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n        \n        if (oldOne != null) {\n\n            if ((_explicitCreators & mask) != 0) { \n                \n                if (!explicit) {\n                    return;\n                }\n                \n                \n            }\n\n            \n            if (oldOne.getClass() == newOne.getClass()) {\n                \n\n                    throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                            +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                \n                    \n                \n            }\n        }\n        if (explicit) {\n            _explicitCreators |= mask;\n        }\n        _creators[typeIndex] = _fixAccess(newOne);\n    }\n\n    \n\n    protected final static class Vanilla extends ValueInstantiator implements java.io.Serializable { private static final long serialVersionUID = 1L; public final static int TYPE_COLLECTION = 1; public final static int TYPE_MAP = 2; public final static int TYPE_HASH_MAP = 3; private final int _type; public Vanilla(int t) {\n            _type = t;\n        }\n        \n        \n        @Override\n        public String getValueTypeDesc() {\n            switch (_type) {\n            case TYPE_COLLECTION: return ArrayList.class.getName();\n            case TYPE_MAP: return LinkedHashMap.class.getName();\n            case TYPE_HASH_MAP: return HashMap.class.getName();\n            }\n            return Object.class.getName();\n        }\n\n        @Override\n        public boolean canInstantiate() { return true; }\n\n        @Override\n        public boolean canCreateUsingDefault() {  return true; }\n\n        @Override\n        public Object createUsingDefault(DeserializationContext ctxt) throws IOException {\n            switch (_type) {\n            case TYPE_COLLECTION: return new ArrayList<Object>();\n            case TYPE_MAP: return new LinkedHashMap<String,Object>();\n            case TYPE_HASH_MAP: return new HashMap<String,Object>();\n            }\n            throw new IllegalStateException(\"Unknown type \"+_type);\n        }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.deser.impl;\n\nimport java.io.IOException;\nimport java.lang.reflect.Member;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.BeanDescription;\nimport com.fasterxml.jackson.databind.DeserializationConfig;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.deser.CreatorProperty;\nimport com.fasterxml.jackson.databind.deser.ValueInstantiator;\nimport com.fasterxml.jackson.databind.deser.std.StdValueInstantiator;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.type.TypeBindings;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\npublic class CreatorCollector { protected final static int C_DEFAULT = 0; protected final static int C_STRING = 1; protected final static int C_INT = 2; protected final static int C_LONG = 3; protected final static int C_DOUBLE = 4; protected final static int C_BOOLEAN = 5; protected final static int C_DELEGATE = 6; protected final static int C_PROPS = 7; protected final static String[] TYPE_DESCS = new String[] { \"default\", \"String\", \"int\", \"long\", \"double\", \"boolean\", \"delegate\", \"property-based\" }; final protected BeanDescription _beanDesc; final protected boolean _canFixAccess; protected final AnnotatedWithParams[] _creators = new AnnotatedWithParams[8]; protected int _explicitCreators = 0; protected boolean _hasNonDefaultCreator = false; protected CreatorProperty[] _delegateArgs; protected CreatorProperty[] _propertyBasedArgs; protected AnnotatedParameter _incompleteParameter; public CreatorCollector(BeanDescription beanDesc, boolean canFixAccess) {\n        _beanDesc = beanDesc;\n        _canFixAccess = canFixAccess;\n    }\n\n    public ValueInstantiator constructValueInstantiator(DeserializationConfig config) {\n        JavaType delegateType;\n        boolean maybeVanilla = !_hasNonDefaultCreator;\n\n        if (maybeVanilla || (_creators[C_DELEGATE] == null)) {\n            delegateType = null;\n        } else {\n            \n            int ix = 0;\n            if (_delegateArgs != null) {\n                for (int i = 0, len = _delegateArgs.length; i < len; ++i) {\n                    if (_delegateArgs[i] == null) { \n                        ix = i;\n                        break;\n                    }\n                }\n            }\n            TypeBindings bindings = _beanDesc.bindingsForBeanType();\n            delegateType = bindings.resolveType(_creators[C_DELEGATE].getGenericParameterType(ix));\n        }\n\n        final JavaType type = _beanDesc.getType();\n\n        \n        \n        maybeVanilla &= !_hasNonDefaultCreator;\n\n        if (maybeVanilla) {\n            \n            final Class<?> rawType = type.getRawClass();\n            if (rawType == Collection.class || rawType == List.class || rawType == ArrayList.class) {\n                return new Vanilla(Vanilla.TYPE_COLLECTION);\n            }\n            if (rawType == Map.class || rawType == LinkedHashMap.class) {\n                return new Vanilla(Vanilla.TYPE_MAP);\n            }\n            if (rawType == HashMap.class) {\n                return new Vanilla(Vanilla.TYPE_HASH_MAP);\n            }\n        }\n        \n        StdValueInstantiator inst = new StdValueInstantiator(config, type);\n        inst.configureFromObjectSettings(_creators[C_DEFAULT],\n                _creators[C_DELEGATE], delegateType, _delegateArgs,\n                _creators[C_PROPS], _propertyBasedArgs);\n        inst.configureFromStringCreator(_creators[C_STRING]);\n        inst.configureFromIntCreator(_creators[C_INT]);\n        inst.configureFromLongCreator(_creators[C_LONG]);\n        inst.configureFromDoubleCreator(_creators[C_DOUBLE]);\n        inst.configureFromBooleanCreator(_creators[C_BOOLEAN]);\n        inst.configureIncompleteParameter(_incompleteParameter);\n        return inst;\n    }\n    \n    \n    \n    \n    public void setDefaultCreator(AnnotatedWithParams creator) {\n        _creators[C_DEFAULT] = _fixAccess(creator);\n    }\n    \n    public void addStringCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_STRING, explicit);\n    }\n    public void addIntCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_INT, explicit);\n    }\n    public void addLongCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_LONG, explicit);\n    }\n    public void addDoubleCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_DOUBLE, explicit);\n    }\n    public void addBooleanCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_BOOLEAN, explicit);\n    }\n\n    public void addDelegatingCreator(AnnotatedWithParams creator, boolean explicit, CreatorProperty[] injectables) {\n        verifyNonDup(creator, C_DELEGATE, explicit);\n        _delegateArgs = injectables;\n    }\n    \n    public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit, CreatorProperty[] properties) {\n        verifyNonDup(creator, C_PROPS, explicit);\n        \n        if (properties.length > 1) {\n            HashMap<String,Integer> names = new HashMap<String,Integer>();\n            for (int i = 0, len = properties.length; i < len; ++i) {\n                String name = properties[i].getName();\n                \n                if (name.length() == 0 && properties[i].getInjectableValueId() != null) {\n                    continue;\n                }\n                Integer old = names.put(name, Integer.valueOf(i));\n                if (old != null) {\n                    throw new IllegalArgumentException(\"Duplicate creator property \\\"\"+name+\"\\\" (index \"+old+\" vs \"+i+\")\");\n                }\n            }\n        }\n        _propertyBasedArgs = properties;\n    }\n\n    public void addIncompeteParameter(AnnotatedParameter parameter) {\n        if (_incompleteParameter == null) {\n            _incompleteParameter = parameter;\n        }\n    }\n\n    \n    \n    @Deprecated \n    public void addStringCreator(AnnotatedWithParams creator) {\n        addStringCreator(creator, false);\n    }\n    @Deprecated \n    public void addIntCreator(AnnotatedWithParams creator) {\n        addBooleanCreator(creator, false);\n    }\n    @Deprecated \n    public void addLongCreator(AnnotatedWithParams creator) {\n        addBooleanCreator(creator, false);\n    }\n    @Deprecated \n    public void addDoubleCreator(AnnotatedWithParams creator) {\n        addBooleanCreator(creator, false);\n    }\n    @Deprecated \n    public void addBooleanCreator(AnnotatedWithParams creator) {\n        addBooleanCreator(creator, false);\n    }\n\n    @Deprecated \n    public void addDelegatingCreator(AnnotatedWithParams creator, CreatorProperty[] injectables) {\n        addDelegatingCreator(creator, false, injectables);\n    }\n\n    @Deprecated \n    public void addPropertyCreator(AnnotatedWithParams creator, CreatorProperty[] properties) {\n        addPropertyCreator(creator, false, properties);\n    }\n\n    @Deprecated \n    protected AnnotatedWithParams verifyNonDup(AnnotatedWithParams newOne, int typeIndex) {\n        verifyNonDup(newOne, typeIndex, false);\n        return _creators[typeIndex];\n    }\n    \n    \n\n    \n    public boolean hasDefaultCreator() {\n        return _creators[C_DEFAULT] != null;\n    }\n\n    \n\n    private <T extends AnnotatedMember> T _fixAccess(T member) {\n        if (member != null && _canFixAccess) {\n            ClassUtil.checkAndFixAccess((Member) member.getAnnotated());\n        }\n        return member;\n    }\n\n    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit) {\n        final int mask = (1 << typeIndex);\n        _hasNonDefaultCreator = true;\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n        \n        if (oldOne != null) {\n            boolean verify;\n\n            if ((_explicitCreators & mask) != 0) { \n                \n                if (!explicit) {\n                    return;\n                }\n                \n                verify = true;\n            } else {\n                \n                verify = !explicit;\n            }\n\n            \n            if (verify && (oldOne.getClass() == newOne.getClass())) {\n                \n                Class<?> oldType = oldOne.getRawParameterType(0);\n                Class<?> newType = newOne.getRawParameterType(0);\n\n                if (oldType == newType) {\n                    throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                            +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                }\n                \n                if (newType.isAssignableFrom(oldType)) {\n                    \n                    return;\n                }\n                \n            }\n        }\n        if (explicit) {\n            _explicitCreators |= mask;\n        }\n        _creators[typeIndex] = _fixAccess(newOne);\n    }\n\n    \n\n    protected final static class Vanilla extends ValueInstantiator implements java.io.Serializable { private static final long serialVersionUID = 1L; public final static int TYPE_COLLECTION = 1; public final static int TYPE_MAP = 2; public final static int TYPE_HASH_MAP = 3; private final int _type; public Vanilla(int t) {\n            _type = t;\n        }\n        \n        \n        @Override\n        public String getValueTypeDesc() {\n            switch (_type) {\n            case TYPE_COLLECTION: return ArrayList.class.getName();\n            case TYPE_MAP: return LinkedHashMap.class.getName();\n            case TYPE_HASH_MAP: return HashMap.class.getName();\n            }\n            return Object.class.getName();\n        }\n\n        @Override\n        public boolean canInstantiate() { return true; }\n\n        @Override\n        public boolean canCreateUsingDefault() {  return true; }\n\n        @Override\n        public Object createUsingDefault(DeserializationContext ctxt) throws IOException {\n            switch (_type) {\n            case TYPE_COLLECTION: return new ArrayList<Object>();\n            case TYPE_MAP: return new LinkedHashMap<String,Object>();\n            case TYPE_HASH_MAP: return new HashMap<String,Object>();\n            }\n            throw new IllegalStateException(\"Unknown type \"+_type);\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public ValueInstantiator constructValueInstantiator(DeserializationConfig config)",
        "public void setDefaultCreator(AnnotatedWithParams creator)",
        "public void addStringCreator(AnnotatedWithParams creator, boolean explicit)",
        "public void addIntCreator(AnnotatedWithParams creator, boolean explicit)",
        "public void addLongCreator(AnnotatedWithParams creator, boolean explicit)",
        "public void addDoubleCreator(AnnotatedWithParams creator, boolean explicit)",
        "public void addBooleanCreator(AnnotatedWithParams creator, boolean explicit)",
        "public void addDelegatingCreator(AnnotatedWithParams creator, boolean explicit, CreatorProperty[] injectables)",
        "public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit, CreatorProperty[] properties)",
        "public void addIncompeteParameter(AnnotatedParameter parameter)",
        "public void addStringCreator(AnnotatedWithParams creator)",
        "public void addIntCreator(AnnotatedWithParams creator)",
        "public void addLongCreator(AnnotatedWithParams creator)",
        "public void addDoubleCreator(AnnotatedWithParams creator)",
        "public void addBooleanCreator(AnnotatedWithParams creator)",
        "public void addDelegatingCreator(AnnotatedWithParams creator, CreatorProperty[] injectables)",
        "public void addPropertyCreator(AnnotatedWithParams creator, CreatorProperty[] properties)",
        "protected AnnotatedWithParams verifyNonDup(AnnotatedWithParams newOne, int typeIndex)",
        "public boolean hasDefaultCreator()",
        "private <T extends AnnotatedMember> T _fixAccess(T member)",
        "protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)",
        "public String getValueTypeDesc()",
        "public boolean canInstantiate()",
        "public boolean canCreateUsingDefault()",
        "public Object createUsingDefault(DeserializationContext ctxt) throws IOException"
      ],
      "fixed_signatures": [
        "public ValueInstantiator constructValueInstantiator(DeserializationConfig config)",
        "public void setDefaultCreator(AnnotatedWithParams creator)",
        "public void addStringCreator(AnnotatedWithParams creator, boolean explicit)",
        "public void addIntCreator(AnnotatedWithParams creator, boolean explicit)",
        "public void addLongCreator(AnnotatedWithParams creator, boolean explicit)",
        "public void addDoubleCreator(AnnotatedWithParams creator, boolean explicit)",
        "public void addBooleanCreator(AnnotatedWithParams creator, boolean explicit)",
        "public void addDelegatingCreator(AnnotatedWithParams creator, boolean explicit, CreatorProperty[] injectables)",
        "public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit, CreatorProperty[] properties)",
        "public void addIncompeteParameter(AnnotatedParameter parameter)",
        "public void addStringCreator(AnnotatedWithParams creator)",
        "public void addIntCreator(AnnotatedWithParams creator)",
        "public void addLongCreator(AnnotatedWithParams creator)",
        "public void addDoubleCreator(AnnotatedWithParams creator)",
        "public void addBooleanCreator(AnnotatedWithParams creator)",
        "public void addDelegatingCreator(AnnotatedWithParams creator, CreatorProperty[] injectables)",
        "public void addPropertyCreator(AnnotatedWithParams creator, CreatorProperty[] properties)",
        "protected AnnotatedWithParams verifyNonDup(AnnotatedWithParams newOne, int typeIndex)",
        "public boolean hasDefaultCreator()",
        "private <T extends AnnotatedMember> T _fixAccess(T member)",
        "protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)",
        "public String getValueTypeDesc()",
        "public boolean canInstantiate()",
        "public boolean canCreateUsingDefault()",
        "public Object createUsingDefault(DeserializationContext ctxt) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit) {\n  final int mask = (1 << typeIndex);\n  _hasNonDefaultCreator = true;\n  AnnotatedWithParams oldOne = _creators[typeIndex];\n  \n  if (oldOne != null) {\n\n  if ((_explicitCreators & mask) != 0) { \n  \n  if (!explicit) {\n  return;\n  }\n  \n  \n  }\n\n  \n  if (oldOne.getClass() == newOne.getClass()) {\n  \n\n  throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n  +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n  \n  \n  \n  }\n  }\n  if (explicit) {\n  _explicitCreators |= mask;\n  }\n  _creators[typeIndex] = _fixAccess(newOne);\n  }",
          "fixed_method": "  protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit) {\n  final int mask = (1 << typeIndex);\n  _hasNonDefaultCreator = true;\n  AnnotatedWithParams oldOne = _creators[typeIndex];\n  \n  if (oldOne != null) {\n  boolean verify;\n\n  if ((_explicitCreators & mask) != 0) { \n  \n  if (!explicit) {\n  return;\n  }\n  \n  verify = true;\n  } else {\n  \n  verify = !explicit;\n  }\n\n  \n  if (verify && (oldOne.getClass() == newOne.getClass())) {\n  \n  Class<?> oldType = oldOne.getRawParameterType(0);\n  Class<?> newType = newOne.getRawParameterType(0);\n\n  if (oldType == newType) {\n  throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n  +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n  }\n  \n  if (newType.isAssignableFrom(oldType)) {\n  \n  return;\n  }\n  \n  }\n  }\n  if (explicit) {\n  _explicitCreators |= mask;\n  }\n  _creators[typeIndex] = _fixAccess(newOne);\n  }",
          "diff": [
            "@@ -280,6 +280,7 @@",
            "         AnnotatedWithParams oldOne = _creators[typeIndex];\n",
            "         // already had an explicitly marked one?\n",
            "         if (oldOne != null) {\n",
            "+            boolean verify;\n",
            " \n",
            "             if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is\n",
            "                 // but skip, if new one not annotated\n",
            "@@ -287,17 +288,27 @@",
            "                     return;\n",
            "                 }\n",
            "                 // both explicit: verify\n",
            "+                verify = true;\n",
            "+            } else {\n",
            "                 // otherwise only verify if neither explicitly annotated.\n",
            "+                verify = !explicit;\n",
            "             }\n",
            " \n",
            "             // one more thing: ok to override in sub-class\n",
            "-            if (oldOne.getClass() == newOne.getClass()) {\n",
            "+            if (verify && (oldOne.getClass() == newOne.getClass())) {\n",
            "                 // [databind#667]: avoid one particular class of bogus problems\n",
            "-\n",
            "+                Class<?> oldType = oldOne.getRawParameterType(0);\n",
            "+                Class<?> newType = newOne.getRawParameterType(0);\n",
            "+\n",
            "+                if (oldType == newType) {\n",
            "                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n",
            "                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n",
            "+                }\n",
            "                 // otherwise, which one to choose?\n",
            "+                if (newType.isAssignableFrom(oldType)) {\n",
            "                     // new type more generic, use old\n",
            "+                    return;\n",
            "+                }\n",
            "                 // new type more specific, use it\n",
            "             }\n",
            "         }\n"
          ],
          "changed_lines": 15
        }
      ]
    }
  ]
}
