{
  "bug_id": "32",
  "failed_tests": {
    "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSetTest": [
      {
        "methodName": "testIssue780",
        "error": "java.lang.ClassCastException",
        "message": "class org.apache.commons.math3.geometry.partitioning.BoundaryAttribute cannot be cast to class java.lang.Boolean (org.apache.commons.math3.geometry.partitioning.BoundaryAttribute is in unnamed module of loader org.apache.tools.ant.loader.AntClassLoader5 @baa9ce4; java.lang.Boolean is in module java.base of loader 'bootstrap')",
        "fail_line": "        Assert.assertEquals( 8.0, polyhedronsSet.getSize(), 3.0e-6);",
        "test_source": "  public void testIssue780() {\n  float[] coords = {\n  1.000000f, -1.000000f, -1.000000f, \n  1.000000f, -1.000000f, 1.000000f, \n  -1.000000f, -1.000000f, 1.000000f, \n  -1.000000f, -1.000000f, -1.000000f, \n  1.000000f, 1.000000f, -1f, \n  0.999999f, 1.000000f, 1.000000f,  // 1.000000f, 1.000000f, 1.000000f, \n  -1.000000f, 1.000000f, 1.000000f, \n  -1.000000f, 1.000000f, -1.000000f};\n  int[] indices = {\n  0, 1, 2, 0, 2, 3, \n  4, 7, 6, 4, 6, 5, \n  0, 4, 5, 0, 5, 1, \n  1, 5, 6, 1, 6, 2, \n  2, 6, 7, 2, 7, 3, \n  4, 0, 3, 4, 3, 7};\n  ArrayList<SubHyperplane<Euclidean3D>> subHyperplaneList = new ArrayList<SubHyperplane<Euclidean3D>>();\n  for (int idx = 0; idx < indices.length; idx += 3) {\n  int idxA = indices[idx] * 3;\n  int idxB = indices[idx + 1] * 3;\n  int idxC = indices[idx + 2] * 3;\n  Vector3D v_1 = new Vector3D(coords[idxA], coords[idxA + 1], coords[idxA + 2]);\n  Vector3D v_2 = new Vector3D(coords[idxB], coords[idxB + 1], coords[idxB + 2]);\n  Vector3D v_3 = new Vector3D(coords[idxC], coords[idxC + 1], coords[idxC + 2]);\n  Vector3D[] vertices = {v_1, v_2, v_3};\n  Plane polyPlane = new Plane(v_1, v_2, v_3);\n  ArrayList<SubHyperplane<Euclidean2D>> lines = new ArrayList<SubHyperplane<Euclidean2D>>();\n\n  Vector2D[] projPts = new Vector2D[vertices.length];\n  for (int ptIdx = 0; ptIdx < projPts.length; ptIdx++) {\n  projPts[ptIdx] = polyPlane.toSubSpace(vertices[ptIdx]);\n  }\n\n  SubLine lineInPlane = null;\n  for (int ptIdx = 0; ptIdx < projPts.length; ptIdx++) {\n  lineInPlane = new SubLine(projPts[ptIdx], projPts[(ptIdx + 1) % projPts.length]);\n  lines.add(lineInPlane);\n  }\n  Region<Euclidean2D> polyRegion = new PolygonsSet(lines);\n  SubPlane polygon = new SubPlane(polyPlane, polyRegion);\n  subHyperplaneList.add(polygon);\n  }\n  PolyhedronsSet polyhedronsSet = new PolyhedronsSet(subHyperplaneList);\n  Assert.assertEquals( 8.0, polyhedronsSet.getSize(), 3.0e-6);\n  Assert.assertEquals(24.0, polyhedronsSet.getBoundarySize(), 5.0e-6);\n  }",
        "stack": [
          "PolygonsSet.computeGeometricalProperties line 136, AbstractRegion.getSize line 381, PolyhedronsSet$FacetsContributionVisitor.addContribution line 171, PolyhedronsSet$FacetsContributionVisitor.visitInternalNode line 153, BSPTree.visit line 263, BSPTree.visit line 262, BSPTree.visit line 262, BSPTree.visit line 264, PolyhedronsSet.computeGeometricalProperties line 118, AbstractRegion.getSize line 381, PolyhedronsSetTest.testIssue780 line 281"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java",
      "buggy_full_code": "\npackage org.apache.commons.math3.geometry.euclidean.twod;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.apache.commons.math3.exception.MathInternalError;\nimport org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D;\nimport org.apache.commons.math3.geometry.euclidean.oned.Interval;\nimport org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet;\nimport org.apache.commons.math3.geometry.euclidean.oned.Vector1D;\nimport org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane;\nimport org.apache.commons.math3.geometry.partitioning.BSPTree;\nimport org.apache.commons.math3.geometry.partitioning.BSPTreeVisitor;\nimport org.apache.commons.math3.geometry.partitioning.BoundaryAttribute;\nimport org.apache.commons.math3.geometry.partitioning.SubHyperplane;\nimport org.apache.commons.math3.geometry.partitioning.AbstractRegion;\nimport org.apache.commons.math3.geometry.partitioning.utilities.AVLTree;\nimport org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple;\nimport org.apache.commons.math3.util.FastMath;\n\n\npublic class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> { private Vector2D[][] vertices; public PolygonsSet() {\n        super();\n    }\n\n    \n    public PolygonsSet(final BSPTree<Euclidean2D> tree) {\n        super(tree);\n    }\n\n    \n    public PolygonsSet(final Collection<SubHyperplane<Euclidean2D>> boundary) {\n        super(boundary);\n    }\n\n    \n    public PolygonsSet(final double xMin, final double xMax, final double yMin, final double yMax) {\n        super(boxBoundary(xMin, xMax, yMin, yMax));\n    }\n\n    \n    private static Line[] boxBoundary(final double xMin, final double xMax, final double yMin, final double yMax) {\n        final Vector2D minMin = new Vector2D(xMin, yMin);\n        final Vector2D minMax = new Vector2D(xMin, yMax);\n        final Vector2D maxMin = new Vector2D(xMax, yMin);\n        final Vector2D maxMax = new Vector2D(xMax, yMax);\n        return new Line[] {\n            new Line(minMin, maxMin),\n            new Line(maxMin, maxMax),\n            new Line(maxMax, minMax),\n            new Line(minMax, minMin)\n        };\n    }\n\n    \n    @Override\n    public PolygonsSet buildNew(final BSPTree<Euclidean2D> tree) {\n        return new PolygonsSet(tree);\n    }\n\n    \n    @Override\n    protected void computeGeometricalProperties() {\n\n        final Vector2D[][] v = getVertices();\n\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n            if ((Boolean) tree.getAttribute()) {\n                \n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (v[0][0] == null) {\n            \n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            \n\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n                    x1 = point.getX();\n                    y1 = point.getY();\n                    final double factor = x0 * y1 - y0 * x1;\n                    sum  += factor;\n                    sumX += factor * (x0 + x1);\n                    sumY += factor * (y0 + y1);\n                }\n            }\n\n            if (sum < 0) {\n                \n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(sum / 2);\n                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n            }\n\n        }\n\n    }\n\n    \n    public Vector2D[][] getVertices() {\n        if (vertices == null) {\n            if (getTree(false).getCut() == null) {\n                vertices = new Vector2D[0][];\n            } else {\n\n                \n                final SegmentsBuilder visitor = new SegmentsBuilder();\n                getTree(true).visit(visitor);\n                final AVLTree<ComparableSegment> sorted = visitor.getSorted();\n\n                \n                \n                final ArrayList<List<ComparableSegment>> loops = new ArrayList<List<ComparableSegment>>();\n                while (!sorted.isEmpty()) {\n                    final AVLTree<ComparableSegment>.Node node = sorted.getSmallest();\n                    final List<ComparableSegment> loop = followLoop(node, sorted);\n                    if (loop != null) {\n                        loops.add(loop);\n                    }\n                }\n\n                \n                vertices = new Vector2D[loops.size()][];\n                int i = 0;\n\n                for (final List<ComparableSegment> loop : loops) {\n                    if (loop.size() < 2) {\n                        \n                        final Line line = loop.get(0).getLine();\n                        vertices[i++] = new Vector2D[] {\n                            null,\n                            line.toSpace(new Vector1D(-Float.MAX_VALUE)),\n                            line.toSpace(new Vector1D(+Float.MAX_VALUE))\n                        };\n                    } else if (loop.get(0).getStart() == null) {\n                        \n                        final Vector2D[] array = new Vector2D[loop.size() + 2];\n                        int j = 0;\n                        for (Segment segment : loop) {\n\n                            if (j == 0) {\n                                \n                                double x = segment.getLine().toSubSpace(segment.getEnd()).getX();\n                                x -= FastMath.max(1.0, FastMath.abs(x / 2));\n                                array[j++] = null;\n                                array[j++] = segment.getLine().toSpace(new Vector1D(x));\n                            }\n\n                            if (j < (array.length - 1)) {\n                                \n                                array[j++] = segment.getEnd();\n                            }\n\n                            if (j == (array.length - 1)) {\n                                \n                                double x = segment.getLine().toSubSpace(segment.getStart()).getX();\n                                x += FastMath.max(1.0, FastMath.abs(x / 2));\n                                array[j++] = segment.getLine().toSpace(new Vector1D(x));\n                            }\n\n                        }\n                        vertices[i++] = array;\n                    } else {\n                        final Vector2D[] array = new Vector2D[loop.size()];\n                        int j = 0;\n                        for (Segment segment : loop) {\n                            array[j++] = segment.getStart();\n                        }\n                        vertices[i++] = array;\n                    }\n                }\n\n            }\n        }\n\n        return vertices.clone();\n\n    }\n\n    \n    private List<ComparableSegment> followLoop(final AVLTree<ComparableSegment>.Node node, final AVLTree<ComparableSegment> sorted) {\n\n        final ArrayList<ComparableSegment> loop = new ArrayList<ComparableSegment>();\n        ComparableSegment segment = node.getElement();\n        loop.add(segment);\n        final Vector2D globalStart = segment.getStart();\n        Vector2D end = segment.getEnd();\n        node.delete();\n\n        \n        final boolean open = segment.getStart() == null;\n\n        while ((end != null) && (open || (globalStart.distance(end) > 1.0e-10))) {\n\n            \n            AVLTree<ComparableSegment>.Node selectedNode = null;\n            ComparableSegment       selectedSegment  = null;\n            double                  selectedDistance = Double.POSITIVE_INFINITY;\n            final ComparableSegment lowerLeft        = new ComparableSegment(end, -1.0e-10, -1.0e-10);\n            final ComparableSegment upperRight       = new ComparableSegment(end, +1.0e-10, +1.0e-10);\n            for (AVLTree<ComparableSegment>.Node n = sorted.getNotSmaller(lowerLeft);\n                 (n != null) && (n.getElement().compareTo(upperRight) <= 0);\n                 n = n.getNext()) {\n                segment = n.getElement();\n                final double distance = end.distance(segment.getStart());\n                if (distance < selectedDistance) {\n                    selectedNode     = n;\n                    selectedSegment  = segment;\n                    selectedDistance = distance;\n                }\n            }\n\n            if (selectedDistance > 1.0e-10) {\n                \n                \n                \n                return null;\n            }\n\n            end = selectedSegment.getEnd();\n            loop.add(selectedSegment);\n            selectedNode.delete();\n\n        }\n\n        if ((loop.size() == 2) && !open) {\n            \n            return null;\n        }\n\n        if ((end == null) && !open) {\n            throw new MathInternalError();\n        }\n\n        return loop;\n\n    }\n\n    \n    private static class ComparableSegment extends Segment implements Comparable<ComparableSegment> { private OrderedTuple sortingKey; public ComparableSegment(final Vector2D start, final Vector2D end, final Line line) {\n            super(start, end, line);\n            sortingKey = (start == null) ?\n                         new OrderedTuple(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY) :\n                         new OrderedTuple(start.getX(), start.getY());\n        }\n\n        \n        public ComparableSegment(final Vector2D start, final double dx, final double dy) {\n            super(null, null, null);\n            sortingKey = new OrderedTuple(start.getX() + dx, start.getY() + dy);\n        }\n\n        \n        public int compareTo(final ComparableSegment o) {\n            return sortingKey.compareTo(o.sortingKey);\n        }\n\n        \n        @Override\n        public boolean equals(final Object other) {\n            if (this == other) {\n                return true;\n            } else if (other instanceof ComparableSegment) {\n                return compareTo((ComparableSegment) other) == 0;\n            } else {\n                return false;\n            }\n        }\n\n        \n        @Override\n        public int hashCode() {\n            return getStart().hashCode() ^ getEnd().hashCode() ^\n                   getLine().hashCode() ^ sortingKey.hashCode();\n        }\n\n    }\n\n    \n    private static class SegmentsBuilder implements BSPTreeVisitor<Euclidean2D> { private AVLTree<ComparableSegment> sorted; public SegmentsBuilder() {\n            sorted = new AVLTree<ComparableSegment>();\n        }\n\n        \n        public Order visitOrder(final BSPTree<Euclidean2D> node) {\n            return Order.MINUS_SUB_PLUS;\n        }\n\n        \n        public void visitInternalNode(final BSPTree<Euclidean2D> node) {\n            @SuppressWarnings(\"unchecked\")\n            final BoundaryAttribute<Euclidean2D> attribute = (BoundaryAttribute<Euclidean2D>) node.getAttribute();\n            if (attribute.getPlusOutside() != null) {\n                addContribution(attribute.getPlusOutside(), false);\n            }\n            if (attribute.getPlusInside() != null) {\n                addContribution(attribute.getPlusInside(), true);\n            }\n        }\n\n        \n        public void visitLeafNode(final BSPTree<Euclidean2D> node) {\n        }\n\n        \n        private void addContribution(final SubHyperplane<Euclidean2D> sub, final boolean reversed) {\n            @SuppressWarnings(\"unchecked\")\n            final AbstractSubHyperplane<Euclidean2D, Euclidean1D> absSub =\n                (AbstractSubHyperplane<Euclidean2D, Euclidean1D>) sub;\n            final Line line      = (Line) sub.getHyperplane();\n            final List<Interval> intervals = ((IntervalsSet) absSub.getRemainingRegion()).asList();\n            for (final Interval i : intervals) {\n                final Vector2D start = Double.isInfinite(i.getLower()) ?\n                                      null : (Vector2D) line.toSpace(new Vector1D(i.getLower()));\n                final Vector2D end   = Double.isInfinite(i.getUpper()) ?\n                                      null : (Vector2D) line.toSpace(new Vector1D(i.getUpper()));\n                if (reversed) {\n                    sorted.insert(new ComparableSegment(end, start, line.getReverse()));\n                } else {\n                    sorted.insert(new ComparableSegment(start, end, line));\n                }\n            }\n        }\n\n        \n        public AVLTree<ComparableSegment> getSorted() {\n            return sorted;\n        }\n\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.math3.geometry.euclidean.twod;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.apache.commons.math3.exception.MathInternalError;\nimport org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D;\nimport org.apache.commons.math3.geometry.euclidean.oned.Interval;\nimport org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet;\nimport org.apache.commons.math3.geometry.euclidean.oned.Vector1D;\nimport org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane;\nimport org.apache.commons.math3.geometry.partitioning.BSPTree;\nimport org.apache.commons.math3.geometry.partitioning.BSPTreeVisitor;\nimport org.apache.commons.math3.geometry.partitioning.BoundaryAttribute;\nimport org.apache.commons.math3.geometry.partitioning.SubHyperplane;\nimport org.apache.commons.math3.geometry.partitioning.AbstractRegion;\nimport org.apache.commons.math3.geometry.partitioning.utilities.AVLTree;\nimport org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple;\nimport org.apache.commons.math3.util.FastMath;\n\n\npublic class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> { private Vector2D[][] vertices; public PolygonsSet() {\n        super();\n    }\n\n    \n    public PolygonsSet(final BSPTree<Euclidean2D> tree) {\n        super(tree);\n    }\n\n    \n    public PolygonsSet(final Collection<SubHyperplane<Euclidean2D>> boundary) {\n        super(boundary);\n    }\n\n    \n    public PolygonsSet(final double xMin, final double xMax, final double yMin, final double yMax) {\n        super(boxBoundary(xMin, xMax, yMin, yMax));\n    }\n\n    \n    private static Line[] boxBoundary(final double xMin, final double xMax, final double yMin, final double yMax) {\n        final Vector2D minMin = new Vector2D(xMin, yMin);\n        final Vector2D minMax = new Vector2D(xMin, yMax);\n        final Vector2D maxMin = new Vector2D(xMax, yMin);\n        final Vector2D maxMax = new Vector2D(xMax, yMax);\n        return new Line[] {\n            new Line(minMin, maxMin),\n            new Line(maxMin, maxMax),\n            new Line(maxMax, minMax),\n            new Line(minMax, minMin)\n        };\n    }\n\n    \n    @Override\n    public PolygonsSet buildNew(final BSPTree<Euclidean2D> tree) {\n        return new PolygonsSet(tree);\n    }\n\n    \n    @Override\n    protected void computeGeometricalProperties() {\n\n        final Vector2D[][] v = getVertices();\n\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n            if (tree.getCut() == null && (Boolean) tree.getAttribute()) {\n                \n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (v[0][0] == null) {\n            \n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            \n\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n                    x1 = point.getX();\n                    y1 = point.getY();\n                    final double factor = x0 * y1 - y0 * x1;\n                    sum  += factor;\n                    sumX += factor * (x0 + x1);\n                    sumY += factor * (y0 + y1);\n                }\n            }\n\n            if (sum < 0) {\n                \n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(sum / 2);\n                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n            }\n\n        }\n\n    }\n\n    \n    public Vector2D[][] getVertices() {\n        if (vertices == null) {\n            if (getTree(false).getCut() == null) {\n                vertices = new Vector2D[0][];\n            } else {\n\n                \n                final SegmentsBuilder visitor = new SegmentsBuilder();\n                getTree(true).visit(visitor);\n                final AVLTree<ComparableSegment> sorted = visitor.getSorted();\n\n                \n                \n                final ArrayList<List<ComparableSegment>> loops = new ArrayList<List<ComparableSegment>>();\n                while (!sorted.isEmpty()) {\n                    final AVLTree<ComparableSegment>.Node node = sorted.getSmallest();\n                    final List<ComparableSegment> loop = followLoop(node, sorted);\n                    if (loop != null) {\n                        loops.add(loop);\n                    }\n                }\n\n                \n                vertices = new Vector2D[loops.size()][];\n                int i = 0;\n\n                for (final List<ComparableSegment> loop : loops) {\n                    if (loop.size() < 2) {\n                        \n                        final Line line = loop.get(0).getLine();\n                        vertices[i++] = new Vector2D[] {\n                            null,\n                            line.toSpace(new Vector1D(-Float.MAX_VALUE)),\n                            line.toSpace(new Vector1D(+Float.MAX_VALUE))\n                        };\n                    } else if (loop.get(0).getStart() == null) {\n                        \n                        final Vector2D[] array = new Vector2D[loop.size() + 2];\n                        int j = 0;\n                        for (Segment segment : loop) {\n\n                            if (j == 0) {\n                                \n                                double x = segment.getLine().toSubSpace(segment.getEnd()).getX();\n                                x -= FastMath.max(1.0, FastMath.abs(x / 2));\n                                array[j++] = null;\n                                array[j++] = segment.getLine().toSpace(new Vector1D(x));\n                            }\n\n                            if (j < (array.length - 1)) {\n                                \n                                array[j++] = segment.getEnd();\n                            }\n\n                            if (j == (array.length - 1)) {\n                                \n                                double x = segment.getLine().toSubSpace(segment.getStart()).getX();\n                                x += FastMath.max(1.0, FastMath.abs(x / 2));\n                                array[j++] = segment.getLine().toSpace(new Vector1D(x));\n                            }\n\n                        }\n                        vertices[i++] = array;\n                    } else {\n                        final Vector2D[] array = new Vector2D[loop.size()];\n                        int j = 0;\n                        for (Segment segment : loop) {\n                            array[j++] = segment.getStart();\n                        }\n                        vertices[i++] = array;\n                    }\n                }\n\n            }\n        }\n\n        return vertices.clone();\n\n    }\n\n    \n    private List<ComparableSegment> followLoop(final AVLTree<ComparableSegment>.Node node, final AVLTree<ComparableSegment> sorted) {\n\n        final ArrayList<ComparableSegment> loop = new ArrayList<ComparableSegment>();\n        ComparableSegment segment = node.getElement();\n        loop.add(segment);\n        final Vector2D globalStart = segment.getStart();\n        Vector2D end = segment.getEnd();\n        node.delete();\n\n        \n        final boolean open = segment.getStart() == null;\n\n        while ((end != null) && (open || (globalStart.distance(end) > 1.0e-10))) {\n\n            \n            AVLTree<ComparableSegment>.Node selectedNode = null;\n            ComparableSegment       selectedSegment  = null;\n            double                  selectedDistance = Double.POSITIVE_INFINITY;\n            final ComparableSegment lowerLeft        = new ComparableSegment(end, -1.0e-10, -1.0e-10);\n            final ComparableSegment upperRight       = new ComparableSegment(end, +1.0e-10, +1.0e-10);\n            for (AVLTree<ComparableSegment>.Node n = sorted.getNotSmaller(lowerLeft);\n                 (n != null) && (n.getElement().compareTo(upperRight) <= 0);\n                 n = n.getNext()) {\n                segment = n.getElement();\n                final double distance = end.distance(segment.getStart());\n                if (distance < selectedDistance) {\n                    selectedNode     = n;\n                    selectedSegment  = segment;\n                    selectedDistance = distance;\n                }\n            }\n\n            if (selectedDistance > 1.0e-10) {\n                \n                \n                \n                return null;\n            }\n\n            end = selectedSegment.getEnd();\n            loop.add(selectedSegment);\n            selectedNode.delete();\n\n        }\n\n        if ((loop.size() == 2) && !open) {\n            \n            return null;\n        }\n\n        if ((end == null) && !open) {\n            throw new MathInternalError();\n        }\n\n        return loop;\n\n    }\n\n    \n    private static class ComparableSegment extends Segment implements Comparable<ComparableSegment> { private OrderedTuple sortingKey; public ComparableSegment(final Vector2D start, final Vector2D end, final Line line) {\n            super(start, end, line);\n            sortingKey = (start == null) ?\n                         new OrderedTuple(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY) :\n                         new OrderedTuple(start.getX(), start.getY());\n        }\n\n        \n        public ComparableSegment(final Vector2D start, final double dx, final double dy) {\n            super(null, null, null);\n            sortingKey = new OrderedTuple(start.getX() + dx, start.getY() + dy);\n        }\n\n        \n        public int compareTo(final ComparableSegment o) {\n            return sortingKey.compareTo(o.sortingKey);\n        }\n\n        \n        @Override\n        public boolean equals(final Object other) {\n            if (this == other) {\n                return true;\n            } else if (other instanceof ComparableSegment) {\n                return compareTo((ComparableSegment) other) == 0;\n            } else {\n                return false;\n            }\n        }\n\n        \n        @Override\n        public int hashCode() {\n            return getStart().hashCode() ^ getEnd().hashCode() ^\n                   getLine().hashCode() ^ sortingKey.hashCode();\n        }\n\n    }\n\n    \n    private static class SegmentsBuilder implements BSPTreeVisitor<Euclidean2D> { private AVLTree<ComparableSegment> sorted; public SegmentsBuilder() {\n            sorted = new AVLTree<ComparableSegment>();\n        }\n\n        \n        public Order visitOrder(final BSPTree<Euclidean2D> node) {\n            return Order.MINUS_SUB_PLUS;\n        }\n\n        \n        public void visitInternalNode(final BSPTree<Euclidean2D> node) {\n            @SuppressWarnings(\"unchecked\")\n            final BoundaryAttribute<Euclidean2D> attribute = (BoundaryAttribute<Euclidean2D>) node.getAttribute();\n            if (attribute.getPlusOutside() != null) {\n                addContribution(attribute.getPlusOutside(), false);\n            }\n            if (attribute.getPlusInside() != null) {\n                addContribution(attribute.getPlusInside(), true);\n            }\n        }\n\n        \n        public void visitLeafNode(final BSPTree<Euclidean2D> node) {\n        }\n\n        \n        private void addContribution(final SubHyperplane<Euclidean2D> sub, final boolean reversed) {\n            @SuppressWarnings(\"unchecked\")\n            final AbstractSubHyperplane<Euclidean2D, Euclidean1D> absSub =\n                (AbstractSubHyperplane<Euclidean2D, Euclidean1D>) sub;\n            final Line line      = (Line) sub.getHyperplane();\n            final List<Interval> intervals = ((IntervalsSet) absSub.getRemainingRegion()).asList();\n            for (final Interval i : intervals) {\n                final Vector2D start = Double.isInfinite(i.getLower()) ?\n                                      null : (Vector2D) line.toSpace(new Vector1D(i.getLower()));\n                final Vector2D end   = Double.isInfinite(i.getUpper()) ?\n                                      null : (Vector2D) line.toSpace(new Vector1D(i.getUpper()));\n                if (reversed) {\n                    sorted.insert(new ComparableSegment(end, start, line.getReverse()));\n                } else {\n                    sorted.insert(new ComparableSegment(start, end, line));\n                }\n            }\n        }\n\n        \n        public AVLTree<ComparableSegment> getSorted() {\n            return sorted;\n        }\n\n    }\n\n}\n",
      "buggy_signatures": [
        "public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> { private Vector2D[][] vertices; public PolygonsSet()",
        "public PolygonsSet(final BSPTree<Euclidean2D> tree)",
        "public PolygonsSet(final Collection<SubHyperplane<Euclidean2D>> boundary)",
        "public PolygonsSet(final double xMin, final double xMax, final double yMin, final double yMax)",
        "private static Line[] boxBoundary(final double xMin, final double xMax, final double yMin, final double yMax)",
        "public PolygonsSet buildNew(final BSPTree<Euclidean2D> tree)",
        "protected void computeGeometricalProperties()",
        "public Vector2D[][] getVertices()",
        "private List<ComparableSegment> followLoop(final AVLTree<ComparableSegment>.Node node, final AVLTree<ComparableSegment> sorted)",
        "private static class ComparableSegment extends Segment implements Comparable<ComparableSegment> { private OrderedTuple sortingKey; public ComparableSegment(final Vector2D start, final Vector2D end, final Line line)",
        "public ComparableSegment(final Vector2D start, final double dx, final double dy)",
        "public int compareTo(final ComparableSegment o)",
        "public boolean equals(final Object other)",
        "public int hashCode()",
        "private static class SegmentsBuilder implements BSPTreeVisitor<Euclidean2D> { private AVLTree<ComparableSegment> sorted; public SegmentsBuilder()",
        "public Order visitOrder(final BSPTree<Euclidean2D> node)",
        "public void visitInternalNode(final BSPTree<Euclidean2D> node)",
        "public void visitLeafNode(final BSPTree<Euclidean2D> node)",
        "private void addContribution(final SubHyperplane<Euclidean2D> sub, final boolean reversed)",
        "public AVLTree<ComparableSegment> getSorted()"
      ],
      "fixed_signatures": [
        "public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> { private Vector2D[][] vertices; public PolygonsSet()",
        "public PolygonsSet(final BSPTree<Euclidean2D> tree)",
        "public PolygonsSet(final Collection<SubHyperplane<Euclidean2D>> boundary)",
        "public PolygonsSet(final double xMin, final double xMax, final double yMin, final double yMax)",
        "private static Line[] boxBoundary(final double xMin, final double xMax, final double yMin, final double yMax)",
        "public PolygonsSet buildNew(final BSPTree<Euclidean2D> tree)",
        "protected void computeGeometricalProperties()",
        "public Vector2D[][] getVertices()",
        "private List<ComparableSegment> followLoop(final AVLTree<ComparableSegment>.Node node, final AVLTree<ComparableSegment> sorted)",
        "private static class ComparableSegment extends Segment implements Comparable<ComparableSegment> { private OrderedTuple sortingKey; public ComparableSegment(final Vector2D start, final Vector2D end, final Line line)",
        "public ComparableSegment(final Vector2D start, final double dx, final double dy)",
        "public int compareTo(final ComparableSegment o)",
        "public boolean equals(final Object other)",
        "public int hashCode()",
        "private static class SegmentsBuilder implements BSPTreeVisitor<Euclidean2D> { private AVLTree<ComparableSegment> sorted; public SegmentsBuilder()",
        "public Order visitOrder(final BSPTree<Euclidean2D> node)",
        "public void visitInternalNode(final BSPTree<Euclidean2D> node)",
        "public void visitLeafNode(final BSPTree<Euclidean2D> node)",
        "private void addContribution(final SubHyperplane<Euclidean2D> sub, final boolean reversed)",
        "public AVLTree<ComparableSegment> getSorted()"
      ],
      "methods": [
        {
          "buggy_method": "  protected void computeGeometricalProperties() {\n\n  final Vector2D[][] v = getVertices();\n\n  if (v.length == 0) {\n  final BSPTree<Euclidean2D> tree = getTree(false);\n  if ((Boolean) tree.getAttribute()) {\n  \n  setSize(Double.POSITIVE_INFINITY);\n  setBarycenter(Vector2D.NaN);\n  } else {\n  setSize(0);\n  setBarycenter(new Vector2D(0, 0));\n  }\n  } else if (v[0][0] == null) {\n  \n  setSize(Double.POSITIVE_INFINITY);\n  setBarycenter(Vector2D.NaN);\n  } else {\n  \n\n  double sum  = 0;\n  double sumX = 0;\n  double sumY = 0;\n\n  for (Vector2D[] loop : v) {\n  double x1 = loop[loop.length - 1].getX();\n  double y1 = loop[loop.length - 1].getY();\n  for (final Vector2D point : loop) {\n  final double x0 = x1;\n  final double y0 = y1;\n  x1 = point.getX();\n  y1 = point.getY();\n  final double factor = x0 * y1 - y0 * x1;\n  sum  += factor;\n  sumX += factor * (x0 + x1);\n  sumY += factor * (y0 + y1);\n  }\n  }\n\n  if (sum < 0) {\n  \n  setSize(Double.POSITIVE_INFINITY);\n  setBarycenter(Vector2D.NaN);\n  } else {\n  setSize(sum / 2);\n  setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n  }\n\n  }\n\n  }",
          "fixed_method": "  protected void computeGeometricalProperties() {\n\n  final Vector2D[][] v = getVertices();\n\n  if (v.length == 0) {\n  final BSPTree<Euclidean2D> tree = getTree(false);\n  if (tree.getCut() == null && (Boolean) tree.getAttribute()) {\n  \n  setSize(Double.POSITIVE_INFINITY);\n  setBarycenter(Vector2D.NaN);\n  } else {\n  setSize(0);\n  setBarycenter(new Vector2D(0, 0));\n  }\n  } else if (v[0][0] == null) {\n  \n  setSize(Double.POSITIVE_INFINITY);\n  setBarycenter(Vector2D.NaN);\n  } else {\n  \n\n  double sum  = 0;\n  double sumX = 0;\n  double sumY = 0;\n\n  for (Vector2D[] loop : v) {\n  double x1 = loop[loop.length - 1].getX();\n  double y1 = loop[loop.length - 1].getY();\n  for (final Vector2D point : loop) {\n  final double x0 = x1;\n  final double y0 = y1;\n  x1 = point.getX();\n  y1 = point.getY();\n  final double factor = x0 * y1 - y0 * x1;\n  sum  += factor;\n  sumX += factor * (x0 + x1);\n  sumY += factor * (y0 + y1);\n  }\n  }\n\n  if (sum < 0) {\n  \n  setSize(Double.POSITIVE_INFINITY);\n  setBarycenter(Vector2D.NaN);\n  } else {\n  setSize(sum / 2);\n  setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n  }\n\n  }\n\n  }",
          "diff": [
            "@@ -133,7 +133,7 @@",
            " \n",
            "         if (v.length == 0) {\n",
            "             final BSPTree<Euclidean2D> tree = getTree(false);\n",
            "-            if ((Boolean) tree.getAttribute()) {\n",
            "+            if (tree.getCut() == null && (Boolean) tree.getAttribute()) {\n",
            "                 // the instance covers the whole space\n",
            "                 setSize(Double.POSITIVE_INFINITY);\n",
            "                 setBarycenter(Vector2D.NaN);\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
