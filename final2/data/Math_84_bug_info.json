{
  "bug_id": "84",
  "failed_tests": {
    "org.apache.commons.math.optimization.direct.MultiDirectionalTest": [
      {
        "methodName": "testMinimizeMaximize",
        "error": "junit.framework.AssertionFailedError",
        "message": "",
        "fail_line": "      Assert.assertTrue(optimizer.getEvaluations() < 150);",
        "test_source": "  public void testMinimizeMaximize() throws FunctionEvaluationException, ConvergenceException {\n\n  // the following function has 4 local extrema:\n  final double xM  = -3.841947088256863675365;\n  final double yM  = -1.391745200270734924416;\n  final double xP  =  0.2286682237349059125691;\n  final double yP  = -yM;\n  final double valueXmYm =  0.2373295333134216789769; // local  maximum\n  final double valueXmYp = -valueXmYm;  // local  minimum\n  final double valueXpYm = -0.7290400707055187115322; // global minimum\n  final double valueXpYp = -valueXpYm;  // global maximum\n  MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n  private static final long serialVersionUID = -7039124064449091152L; public double value(double[] variables) throws FunctionEvaluationException {\n  final double x = variables[0];\n  final double y = variables[1];\n  return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n  }\n  };\n\n  MultiDirectional optimizer = new MultiDirectional();\n  optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n  optimizer.setMaxIterations(200);\n  optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n  RealPointValuePair optimum;\n\n  // minimization\n  optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n  Assert.assertEquals(xM,  optimum.getPoint()[0], 4.0e-6);\n  Assert.assertEquals(yP,  optimum.getPoint()[1], 3.0e-6);\n  Assert.assertEquals(valueXmYp, optimum.getValue(),  8.0e-13);\n  Assert.assertTrue(optimizer.getEvaluations() > 120);\n  Assert.assertTrue(optimizer.getEvaluations() < 150);\n\n  optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n  Assert.assertEquals(xP,  optimum.getPoint()[0], 2.0e-8);\n  Assert.assertEquals(yM,  optimum.getPoint()[1], 3.0e-6);\n  Assert.assertEquals(valueXpYm, optimum.getValue(),  2.0e-12);  \n  Assert.assertTrue(optimizer.getEvaluations() > 120);\n  Assert.assertTrue(optimizer.getEvaluations() < 150);\n\n  // maximization\n  optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n  Assert.assertEquals(xM,  optimum.getPoint()[0], 7.0e-7);\n  Assert.assertEquals(yM,  optimum.getPoint()[1], 3.0e-7);\n  Assert.assertEquals(valueXmYm, optimum.getValue(),  2.0e-14);\n  Assert.assertTrue(optimizer.getEvaluations() > 120);\n  Assert.assertTrue(optimizer.getEvaluations() < 150);\n\n  optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n  optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n  Assert.assertEquals(xP,  optimum.getPoint()[0], 2.0e-8);\n  Assert.assertEquals(yP,  optimum.getPoint()[1], 3.0e-6);\n  Assert.assertEquals(valueXpYp, optimum.getValue(),  2.0e-12);\n  Assert.assertTrue(optimizer.getEvaluations() > 180);\n  Assert.assertTrue(optimizer.getEvaluations() < 220);\n\n  }",
        "stack": [
          "MultiDirectionalTest.testMinimizeMaximize line 103"
        ]
      },
      {
        "methodName": "testMath283",
        "error": "org.apache.commons.math.optimization.OptimizationException",
        "message": "org.apache.commons.math.MaxIterationsExceededException: Maximal number of iterations (100) exceeded",
        "fail_line": "      RealPointValuePair estimate = multiDirectional.optimize(function,",
        "test_source": "  public void testMath283() throws FunctionEvaluationException, OptimizationException {\n  // fails because MultiDirectional.iterateSimplex is looping forever\n  // the while(true) should be replaced with a convergence check\n  MultiDirectional multiDirectional = new MultiDirectional();\n  multiDirectional.setMaxIterations(100);\n  multiDirectional.setMaxEvaluations(1000);\n\n  final Gaussian2D function = new Gaussian2D(0.0, 0.0, 1.0);\n\n  RealPointValuePair estimate = multiDirectional.optimize(function,\n  GoalType.MAXIMIZE, function.getMaximumPosition());\n\n  final double EPSILON = 1e-5;\n\n  final double expectedMaximum = function.getMaximum();\n  final double actualMaximum = estimate.getValue();\n  Assert.assertEquals(expectedMaximum, actualMaximum, EPSILON);\n\n  final double[] expectedPosition = function.getMaximumPosition();\n  final double[] actualPosition = estimate.getPoint();\n  Assert.assertEquals(expectedPosition[0], actualPosition[0], EPSILON );\n  Assert.assertEquals(expectedPosition[1], actualPosition[1], EPSILON );\n  \n  }",
        "stack": [
          "DirectSearchOptimizer.incrementIterationsCounter line 320, MultiDirectional.iterateSimplex line 66, DirectSearchOptimizer.optimize line 307, MultiDirectionalTest.testMath283 line 203"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/optimization/direct/MultiDirectional.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.optimization.direct;\n\nimport java.util.Comparator;\n\nimport org.apache.commons.math.FunctionEvaluationException;\nimport org.apache.commons.math.optimization.OptimizationException;\nimport org.apache.commons.math.optimization.RealConvergenceChecker;\nimport org.apache.commons.math.optimization.RealPointValuePair;\n\n\npublic class MultiDirectional extends DirectSearchOptimizer { private final double khi; private final double gamma; public MultiDirectional() {\n        this.khi   = 2.0;\n        this.gamma = 0.5;\n    }\n\n    \n    public MultiDirectional(final double khi, final double gamma) {\n        this.khi   = khi;\n        this.gamma = gamma;\n    }\n\n    \n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) {\n\n            incrementIterationsCounter();\n\n            \n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n\n            \n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n\n                \n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    \n                    simplex = reflectedSimplex;\n                }\n\n                return;\n\n            }\n\n            \n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n            if (comparator.compare(contracted, best) < 0) {\n                \n\n            \n                return;\n            }\n\n        }\n\n    }\n\n    \n    private RealPointValuePair evaluateNewSimplex(final RealPointValuePair[] original, final double coeff, final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException {\n\n        final double[] xSmallest = original[0].getPointRef();\n        final int n = xSmallest.length;\n\n        \n        simplex = new RealPointValuePair[n + 1];\n        simplex[0] = original[0];\n        for (int i = 1; i <= n; ++i) {\n            final double[] xOriginal    = original[i].getPointRef();\n            final double[] xTransformed = new double[n];\n            for (int j = 0; j < n; ++j) {\n                xTransformed[j] = xSmallest[j] + coeff * (xSmallest[j] - xOriginal[j]);\n            }\n            simplex[i] = new RealPointValuePair(xTransformed, Double.NaN, false);\n        }\n\n        \n        evaluateSimplex(comparator);\n        return simplex[0];\n\n    }\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.optimization.direct;\n\nimport java.util.Comparator;\n\nimport org.apache.commons.math.FunctionEvaluationException;\nimport org.apache.commons.math.optimization.OptimizationException;\nimport org.apache.commons.math.optimization.RealConvergenceChecker;\nimport org.apache.commons.math.optimization.RealPointValuePair;\n\n\npublic class MultiDirectional extends DirectSearchOptimizer { private final double khi; private final double gamma; public MultiDirectional() {\n        this.khi   = 2.0;\n        this.gamma = 0.5;\n    }\n\n    \n    public MultiDirectional(final double khi, final double gamma) {\n        this.khi   = khi;\n        this.gamma = gamma;\n    }\n\n    \n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        final RealConvergenceChecker checker = getConvergenceChecker();\n        while (true) {\n\n            incrementIterationsCounter();\n\n            \n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n\n            \n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n\n                \n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    \n                    simplex = reflectedSimplex;\n                }\n\n                return;\n\n            }\n\n            \n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n            if (comparator.compare(contracted, best) < 0) {\n                \n                return;\n            }\n\n            \n            final int iter = getIterations();\n            boolean converged = true;\n            for (int i = 0; i < simplex.length; ++i) {\n                converged &= checker.converged(iter, original[i], simplex[i]);\n            }\n            if (converged) {\n                return;\n            }\n\n        }\n\n    }\n\n    \n    private RealPointValuePair evaluateNewSimplex(final RealPointValuePair[] original, final double coeff, final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException {\n\n        final double[] xSmallest = original[0].getPointRef();\n        final int n = xSmallest.length;\n\n        \n        simplex = new RealPointValuePair[n + 1];\n        simplex[0] = original[0];\n        for (int i = 1; i <= n; ++i) {\n            final double[] xOriginal    = original[i].getPointRef();\n            final double[] xTransformed = new double[n];\n            for (int j = 0; j < n; ++j) {\n                xTransformed[j] = xSmallest[j] + coeff * (xSmallest[j] - xOriginal[j]);\n            }\n            simplex[i] = new RealPointValuePair(xTransformed, Double.NaN, false);\n        }\n\n        \n        evaluateSimplex(comparator);\n        return simplex[0];\n\n    }\n\n}\n",
      "buggy_signatures": [
        "public class MultiDirectional extends DirectSearchOptimizer { private final double khi; private final double gamma; public MultiDirectional()",
        "public MultiDirectional(final double khi, final double gamma)",
        "protected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException",
        "private RealPointValuePair evaluateNewSimplex(final RealPointValuePair[] original, final double coeff, final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException"
      ],
      "fixed_signatures": [
        "public class MultiDirectional extends DirectSearchOptimizer { private final double khi; private final double gamma; public MultiDirectional()",
        "public MultiDirectional(final double khi, final double gamma)",
        "protected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException",
        "private RealPointValuePair evaluateNewSimplex(final RealPointValuePair[] original, final double coeff, final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException"
      ],
      "methods": [
        {
          "buggy_method": "  protected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n  while (true) {\n\n  incrementIterationsCounter();\n\n  \n  final RealPointValuePair[] original = simplex;\n  final RealPointValuePair best = original[0];\n\n  \n  final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n  if (comparator.compare(reflected, best) < 0) {\n\n  \n  final RealPointValuePair[] reflectedSimplex = simplex;\n  final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n  if (comparator.compare(reflected, expanded) <= 0) {\n  \n  simplex = reflectedSimplex;\n  }\n\n  return;\n\n  }\n\n  \n  final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n  if (comparator.compare(contracted, best) < 0) {\n  \n\n  \n  return;\n  }\n\n  }\n\n  }",
          "fixed_method": "  protected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n  final RealConvergenceChecker checker = getConvergenceChecker();\n  while (true) {\n\n  incrementIterationsCounter();\n\n  \n  final RealPointValuePair[] original = simplex;\n  final RealPointValuePair best = original[0];\n\n  \n  final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n  if (comparator.compare(reflected, best) < 0) {\n\n  \n  final RealPointValuePair[] reflectedSimplex = simplex;\n  final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n  if (comparator.compare(reflected, expanded) <= 0) {\n  \n  simplex = reflectedSimplex;\n  }\n\n  return;\n\n  }\n\n  \n  final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n  if (comparator.compare(contracted, best) < 0) {\n  \n  return;\n  }\n\n  \n  final int iter = getIterations();\n  boolean converged = true;\n  for (int i = 0; i < simplex.length; ++i) {\n  converged &= checker.converged(iter, original[i], simplex[i]);\n  }\n  if (converged) {\n  return;\n  }\n\n  }\n\n  }",
          "diff": [
            "@@ -61,6 +61,7 @@",
            "     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n",
            "         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n",
            " \n",
            "+        final RealConvergenceChecker checker = getConvergenceChecker();\n",
            "         while (true) {\n",
            " \n",
            "             incrementIterationsCounter();\n",
            "@@ -89,8 +90,16 @@",
            "             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n",
            "             if (comparator.compare(contracted, best) < 0) {\n",
            "                 // accept the contracted simplex\n",
            "+                return;\n",
            "+            }\n",
            " \n",
            "             // check convergence\n",
            "+            final int iter = getIterations();\n",
            "+            boolean converged = true;\n",
            "+            for (int i = 0; i < simplex.length; ++i) {\n",
            "+                converged &= checker.converged(iter, original[i], simplex[i]);\n",
            "+            }\n",
            "+            if (converged) {\n",
            "                 return;\n",
            "             }\n",
            " \n"
          ],
          "changed_lines": 9
        }
      ]
    }
  ]
}
