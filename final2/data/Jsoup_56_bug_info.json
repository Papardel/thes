{
  "bug_id": "56",
  "failed_tests": {
    "org.jsoup.nodes.DocumentTypeTest": [
      {
        "methodName": "testRoundTrip",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<<!DOCTYPE html [SYSTEM ]\"exampledtdfile.dtd\"...> but was:<<!DOCTYPE html []\"exampledtdfile.dtd\"...>",
        "fail_line": "        assertEquals(systemDoc, htmlOutput(systemDoc));",
        "test_source": "",
        "stack": [
          "DocumentTypeTest.testRoundTrip line 54"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/nodes/DocumentType.java",
      "buggy_full_code": "package org.jsoup.nodes;\n\nimport java.io.IOException;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.nodes.Document.OutputSettings.*;\n\n\npublic class DocumentType extends Node { public static final String PUBLIC_KEY = \"PUBLIC\"; public static final String SYSTEM_KEY = \"SYSTEM\"; private static final String NAME = \"name\"; private static final String PUBLIC_ID = \"publicId\"; private static final String SYSTEM_ID = \"systemId\"; public DocumentType(String name, String publicId, String systemId, String baseUri) {\n        super(baseUri);\n\n        attr(NAME, name);\n        attr(PUBLIC_ID, publicId);\n        attr(SYSTEM_ID, systemId);\n    }\n\n    \n\n\n    @Override\n    public String nodeName() {\n        return \"#doctype\";\n    }\n\n    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        if (out.syntax() == Syntax.html && !has(PUBLIC_ID) && !has(SYSTEM_ID)) {\n            \n            accum.append(\"<!doctype\");\n        } else {\n            accum.append(\"<!DOCTYPE\");\n        }\n        if (has(NAME))\n            accum.append(\" \").append(attr(NAME));\n        if (has(PUBLIC_ID))\n            accum.append(\" PUBLIC \\\"\").append(attr(PUBLIC_ID)).append('\"');\n        if (has(SYSTEM_ID))\n            accum.append(\" \\\"\").append(attr(SYSTEM_ID)).append('\"');\n        accum.append('>');\n    }\n\n    @Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {\n    }\n\n    private boolean has(final String attribute) {\n        return !StringUtil.isBlank(attr(attribute));\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.nodes;\n\nimport java.io.IOException;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.nodes.Document.OutputSettings.*;\n\n\npublic class DocumentType extends Node { public static final String PUBLIC_KEY = \"PUBLIC\"; public static final String SYSTEM_KEY = \"SYSTEM\"; private static final String NAME = \"name\"; private static final String PUB_SYS_KEY = \"pubSysKey\"; private static final String PUBLIC_ID = \"publicId\"; private static final String SYSTEM_ID = \"systemId\"; public DocumentType(String name, String publicId, String systemId, String baseUri) {\n        super(baseUri);\n\n        attr(NAME, name);\n        attr(PUBLIC_ID, publicId);\n        if (has(PUBLIC_ID)) {\n            attr(PUB_SYS_KEY, PUBLIC_KEY);\n        }\n        attr(SYSTEM_ID, systemId);\n    }\n\n    \n    public DocumentType(String name, String pubSysKey, String publicId, String systemId, String baseUri) {\n        super(baseUri);\n\n        attr(NAME, name);\n        if (pubSysKey != null) {\n            attr(PUB_SYS_KEY, pubSysKey);\n        }\n        attr(PUBLIC_ID, publicId);\n        attr(SYSTEM_ID, systemId);\n    }\n\n    @Override\n    public String nodeName() {\n        return \"#doctype\";\n    }\n\n    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        if (out.syntax() == Syntax.html && !has(PUBLIC_ID) && !has(SYSTEM_ID)) {\n            \n            accum.append(\"<!doctype\");\n        } else {\n            accum.append(\"<!DOCTYPE\");\n        }\n        if (has(NAME))\n            accum.append(\" \").append(attr(NAME));\n        if (has(PUB_SYS_KEY))\n            accum.append(\" \").append(attr(PUB_SYS_KEY));\n        if (has(PUBLIC_ID))\n            accum.append(\" \\\"\").append(attr(PUBLIC_ID)).append('\"');\n        if (has(SYSTEM_ID))\n            accum.append(\" \\\"\").append(attr(SYSTEM_ID)).append('\"');\n        accum.append('>');\n    }\n\n    @Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {\n    }\n\n    private boolean has(final String attribute) {\n        return !StringUtil.isBlank(attr(attribute));\n    }\n}\n",
      "buggy_signatures": [
        "public String nodeName()",
        "private boolean has(final String attribute)"
      ],
      "fixed_signatures": [
        "public DocumentType(String name, String pubSysKey, String publicId, String systemId, String baseUri)",
        "public String nodeName()",
        "private boolean has(final String attribute)"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -12,6 +12,7 @@",
            "     public static final String PUBLIC_KEY = \"PUBLIC\";\n",
            "     public static final String SYSTEM_KEY = \"SYSTEM\";\n",
            "     private static final String NAME = \"name\";\n",
            "+    private static final String PUB_SYS_KEY = \"pubSysKey\"; // PUBLIC or SYSTEM\n",
            "     private static final String PUBLIC_ID = \"publicId\";\n",
            "     private static final String SYSTEM_ID = \"systemId\";\n",
            "     // todo: quirk mode from publicId and systemId\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  public DocumentType(String name, String publicId, String systemId, String baseUri) {\n  super(baseUri);\n\n  attr(NAME, name);\n  attr(PUBLIC_ID, publicId);\n  attr(SYSTEM_ID, systemId);\n  }",
          "fixed_method": "  public DocumentType(String name, String publicId, String systemId, String baseUri) {\n  super(baseUri);\n\n  attr(NAME, name);\n  attr(PUBLIC_ID, publicId);\n  if (has(PUBLIC_ID)) {\n  attr(PUB_SYS_KEY, PUBLIC_KEY);\n  }\n  attr(SYSTEM_ID, systemId);\n  }",
          "diff": [
            "@@ -28,6 +29,9 @@",
            " \n",
            "         attr(NAME, name);\n",
            "         attr(PUBLIC_ID, publicId);\n",
            "+        if (has(PUBLIC_ID)) {\n",
            "+            attr(PUB_SYS_KEY, PUBLIC_KEY);\n",
            "+        }\n",
            "         attr(SYSTEM_ID, systemId);\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 3
        },
        {
          "buggy_method": "  public String nodeName() {\n  return \"#doctype\";\n  }",
          "fixed_method": "  public DocumentType(String name, String pubSysKey, String publicId, String systemId, String baseUri) {\n  super(baseUri);\n\n  attr(NAME, name);\n  if (pubSysKey != null) {\n  attr(PUB_SYS_KEY, pubSysKey);\n  }\n  attr(PUBLIC_ID, publicId);\n  attr(SYSTEM_ID, systemId);\n  }",
          "diff": [
            "@@ -38,7 +42,16 @@",
            "      * @param systemId the doctype's system ID\n",
            "      * @param baseUri the doctype's base URI\n",
            "      */\n",
            "+    public DocumentType(String name, String pubSysKey, String publicId, String systemId, String baseUri) {\n",
            "+        super(baseUri);\n",
            " \n",
            "+        attr(NAME, name);\n",
            "+        if (pubSysKey != null) {\n",
            "+            attr(PUB_SYS_KEY, pubSysKey);\n",
            "+        }\n",
            "+        attr(PUBLIC_ID, publicId);\n",
            "+        attr(SYSTEM_ID, systemId);\n",
            "+    }\n",
            " \n",
            "     @Override\n",
            "     public String nodeName() {\n",
            "@@ -55,8 +68,10 @@",
            "         }\n",
            "         if (has(NAME))\n",
            "             accum.append(\" \").append(attr(NAME));\n",
            "+        if (has(PUB_SYS_KEY))\n",
            "+            accum.append(\" \").append(attr(PUB_SYS_KEY));\n",
            "         if (has(PUBLIC_ID))\n",
            "-            accum.append(\" PUBLIC \\\"\").append(attr(PUBLIC_ID)).append('\"');\n",
            "+            accum.append(\" \\\"\").append(attr(PUBLIC_ID)).append('\"');\n",
            "         if (has(SYSTEM_ID))\n",
            "             accum.append(\" \\\"\").append(attr(SYSTEM_ID)).append('\"');\n",
            "         accum.append('>');\n"
          ],
          "changed_lines": 13
        }
      ]
    },
    {
      "name": "org/jsoup/parser/HtmlTreeBuilderState.java",
      "buggy_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.nodes.*;\n\nimport java.util.ArrayList;\n\n\nenum HtmlTreeBuilderState {\n    Initial {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                return true; \n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                \n                \n                Token.Doctype d = t.asDoctype();\n                DocumentType doctype = new DocumentType(\n                    tb.settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());\n                tb.getDocument().appendChild(doctype);\n                if (d.isForceQuirks())\n                    tb.getDocument().quirksMode(Document.QuirksMode.quirks);\n                tb.transition(BeforeHtml);\n            } else {\n                \n                tb.transition(BeforeHtml);\n                return tb.process(t); \n            }\n            return true;\n        }\n    },\n    BeforeHtml {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (isWhitespace(t)) {\n                return true; \n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                tb.insert(t.asStartTag());\n                tb.transition(BeforeHead);\n            } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().normalName(), \"head\", \"body\", \"html\", \"br\"))) {\n                return anythingElse(t, tb);\n            } else if (t.isEndTag()) {\n                tb.error(this);\n                return false;\n            } else {\n                return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.insertStartTag(\"html\");\n            tb.transition(BeforeHead);\n            return tb.process(t);\n        }\n    },\n    BeforeHead {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                return true;\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                return InBody.process(t, tb); \n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"head\")) {\n                Element head = tb.insert(t.asStartTag());\n                tb.setHeadElement(head);\n                tb.transition(InHead);\n            } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().normalName(), \"head\", \"body\", \"html\", \"br\"))) {\n                tb.processStartTag(\"head\");\n                return tb.process(t);\n            } else if (t.isEndTag()) {\n                tb.error(this);\n                return false;\n            } else {\n                tb.processStartTag(\"head\");\n                return tb.process(t);\n            }\n            return true;\n        }\n    },\n    InHead {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n                return true;\n            }\n            switch (t.type) {\n                case Comment:\n                    tb.insert(t.asComment());\n                    break;\n                case Doctype:\n                    tb.error(this);\n                    return false;\n                case StartTag:\n                    Token.StartTag start = t.asStartTag();\n                    String name = start.normalName();\n                    if (name.equals(\"html\")) {\n                        return InBody.process(t, tb);\n                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\")) {\n                        Element el = tb.insertEmpty(start);\n                        \n                        if (name.equals(\"base\") && el.hasAttr(\"href\"))\n                            tb.maybeSetBaseUri(el);\n                    } else if (name.equals(\"meta\")) {\n                        Element meta = tb.insertEmpty(start);\n                        \n                    } else if (name.equals(\"title\")) {\n                        handleRcData(start, tb);\n                    } else if (StringUtil.in(name, \"noframes\", \"style\")) {\n                        handleRawtext(start, tb);\n                    } else if (name.equals(\"noscript\")) {\n                        \n                        tb.insert(start);\n                        tb.transition(InHeadNoscript);\n                    } else if (name.equals(\"script\")) {\n                        \n\n                        tb.tokeniser.transition(TokeniserState.ScriptData);\n                        tb.markInsertionMode();\n                        tb.transition(Text);\n                        tb.insert(start);\n                    } else if (name.equals(\"head\")) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        return anythingElse(t, tb);\n                    }\n                    break;\n                case EndTag:\n                    Token.EndTag end = t.asEndTag();\n                    name = end.normalName();\n                    if (name.equals(\"head\")) {\n                        tb.pop();\n                        tb.transition(AfterHead);\n                    } else if (StringUtil.in(name, \"body\", \"html\", \"br\")) {\n                        return anythingElse(t, tb);\n                    } else {\n                        tb.error(this);\n                        return false;\n                    }\n                    break;\n                default:\n                    return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, TreeBuilder tb) {\n            tb.processEndTag(\"head\");\n            return tb.process(t);\n        }\n    },\n    InHeadNoscript {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isDoctype()) {\n                tb.error(this);\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                return tb.process(t, InBody);\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"noscript\")) {\n                tb.pop();\n                tb.transition(InHead);\n            } else if (isWhitespace(t) || t.isComment() || (t.isStartTag() && StringUtil.in(t.asStartTag().normalName(),\n                    \"basefont\", \"bgsound\", \"link\", \"meta\", \"noframes\", \"style\"))) {\n                return tb.process(t, InHead);\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"br\")) {\n                return anythingElse(t, tb);\n            } else if ((t.isStartTag() && StringUtil.in(t.asStartTag().normalName(), \"head\", \"noscript\")) || t.isEndTag()) {\n                tb.error(this);\n                return false;\n            } else {\n                return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.error(this);\n            tb.insert(new Token.Character().data(t.toString()));\n            return true;\n        }\n    },\n    AfterHead {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                tb.error(this);\n            } else if (t.isStartTag()) {\n                Token.StartTag startTag = t.asStartTag();\n                String name = startTag.normalName();\n                if (name.equals(\"html\")) {\n                    return tb.process(t, InBody);\n                } else if (name.equals(\"body\")) {\n                    tb.insert(startTag);\n                    tb.framesetOk(false);\n                    tb.transition(InBody);\n                } else if (name.equals(\"frameset\")) {\n                    tb.insert(startTag);\n                    tb.transition(InFrameset);\n                } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                    tb.error(this);\n                    Element head = tb.getHeadElement();\n                    tb.push(head);\n                    tb.process(t, InHead);\n                    tb.removeFromStack(head);\n                } else if (name.equals(\"head\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    anythingElse(t, tb);\n                }\n            } else if (t.isEndTag()) {\n                if (StringUtil.in(t.asEndTag().normalName(), \"body\", \"html\")) {\n                    anythingElse(t, tb);\n                } else {\n                    tb.error(this);\n                    return false;\n                }\n            } else {\n                anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.processStartTag(\"body\");\n            tb.framesetOk(true);\n            return tb.process(t);\n        }\n    },\n    InBody {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character: {\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        \n                        tb.error(this);\n                        return false;\n                    } else if (tb.framesetOk() && isWhitespace(c)) { \n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.normalName();\n                    if (name.equals(\"a\")) {\n                        if (tb.getActiveFormattingElement(\"a\") != null) {\n                            tb.error(this);\n                            tb.processEndTag(\"a\");\n\n                            \n                            Element remainingA = tb.getFromStack(\"a\");\n                            if (remainingA != null) {\n                                tb.removeFromActiveFormattingElements(remainingA);\n                                tb.removeFromStack(remainingA);\n                            }\n                        }\n                        tb.reconstructFormattingElements();\n                        Element a = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(a);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n                        tb.reconstructFormattingElements();\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"span\")) {\n                        \n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (name.equals(\"li\")) {\n                        tb.framesetOk(false);\n                        ArrayList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (el.nodeName().equals(\"li\")) {\n                                tb.processEndTag(\"li\");\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"html\")) {\n                        tb.error(this);\n                        \n                        Element html = tb.getStack().get(0);\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        ArrayList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            \n                            return false; \n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        ArrayList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            \n                            return false; \n                        } else if (!tb.framesetOk()) {\n                            return false; \n                        } else {\n                            Element second = stack.get(1);\n                            if (second.parent() != null)\n                                second.remove();\n                            \n                            while (stack.size() > 1)\n                                stack.remove(stack.size()-1);\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n                            tb.error(this);\n                            tb.pop();\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        \n                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null) {\n                            tb.error(this);\n                            return false;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insertForm(startTag, true);\n                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                        tb.framesetOk(false);\n                        ArrayList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n                                tb.processEndTag(el.nodeName());\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"plaintext\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); \n                    } else if (name.equals(\"button\")) {\n                        if (tb.inButtonScope(\"button\")) {\n                            \n                            tb.error(this);\n                            tb.processEndTag(\"button\");\n                            tb.process(startTag);\n                        } else {\n                            tb.reconstructFormattingElements();\n                            tb.insert(startTag);\n                            tb.framesetOk(false);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Formatters)) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (name.equals(\"nobr\")) {\n                        tb.reconstructFormattingElements();\n                        if (tb.inScope(\"nobr\")) {\n                            tb.error(this);\n                            tb.processEndTag(\"nobr\");\n                            tb.reconstructFormattingElements();\n                        }\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.insertMarkerToFormattingElements();\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"table\")) {\n                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        tb.transition(InTable);\n                    } else if (name.equals(\"input\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insertEmpty(startTag);\n                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                            tb.framesetOk(false);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n                        tb.insertEmpty(startTag);\n                    } else if (name.equals(\"hr\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"image\")) {\n                        if (tb.getFromStack(\"svg\") == null)\n                            return tb.process(startTag.name(\"img\")); \n                        else\n                            tb.insert(startTag);\n                    } else if (name.equals(\"isindex\")) {\n                        \n                        tb.error(this);\n                        if (tb.getFormElement() != null)\n                            return false;\n\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                        tb.processStartTag(\"form\");\n                        if (startTag.attributes.hasKey(\"action\")) {\n                            Element form = tb.getFormElement();\n                            form.attr(\"action\", startTag.attributes.get(\"action\"));\n                        }\n                        tb.processStartTag(\"hr\");\n                        tb.processStartTag(\"label\");\n                        \n                        String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                                startTag.attributes.get(\"prompt\") :\n                                \"This is a searchable index. Enter search keywords: \";\n\n                        tb.process(new Token.Character().data(prompt));\n\n                        \n                        Attributes inputAttribs = new Attributes();\n                        for (Attribute attr : startTag.attributes) {\n                            if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n                                inputAttribs.put(attr);\n                        }\n                        inputAttribs.put(\"name\", \"isindex\");\n                        tb.processStartTag(\"input\", inputAttribs);\n                        tb.processEndTag(\"label\");\n                        tb.processStartTag(\"hr\");\n                        tb.processEndTag(\"form\");\n                    } else if (name.equals(\"textarea\")) {\n                        tb.insert(startTag);\n                        \n                        tb.tokeniser.transition(TokeniserState.Rcdata);\n                        tb.markInsertionMode();\n                        tb.framesetOk(false);\n                        tb.transition(Text);\n                    } else if (name.equals(\"xmp\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.reconstructFormattingElements();\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"iframe\")) {\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"noembed\")) {\n                        \n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"select\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n\n                        HtmlTreeBuilderState state = tb.state();\n                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                            tb.transition(InSelectInTable);\n                        else\n                            tb.transition(InSelect);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.processEndTag(\"option\");\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n                        if (tb.inScope(\"ruby\")) {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                                tb.error(this);\n                                tb.popStackToBefore(\"ruby\"); \n                            }\n                            tb.insert(startTag);\n                        }\n                    } else if (name.equals(\"math\")) {\n                        tb.reconstructFormattingElements();\n                        \n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (name.equals(\"svg\")) {\n                        tb.reconstructFormattingElements();\n                        \n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    }\n                    break;\n\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.normalName();\n                    if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n                        \n                        for (int i = 0; i < 8; i++) {\n                            Element formatEl = tb.getActiveFormattingElement(name);\n                            if (formatEl == null)\n                                return anyOtherEndTag(t, tb);\n                            else if (!tb.onStack(formatEl)) {\n                                tb.error(this);\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            } else if (!tb.inScope(formatEl.nodeName())) {\n                                tb.error(this);\n                                return false;\n                            } else if (tb.currentElement() != formatEl)\n                                tb.error(this);\n\n                            Element furthestBlock = null;\n                            Element commonAncestor = null;\n                            boolean seenFormattingElement = false;\n                            ArrayList<Element> stack = tb.getStack();\n                            \n                            \n                            final int stackSize = stack.size();\n                            for (int si = 0; si < stackSize && si < 64; si++) {\n                                Element el = stack.get(si);\n                                if (el == formatEl) {\n                                    commonAncestor = stack.get(si - 1);\n                                    seenFormattingElement = true;\n                                } else if (seenFormattingElement && tb.isSpecial(el)) {\n                                    furthestBlock = el;\n                                    break;\n                                }\n                            }\n                            if (furthestBlock == null) {\n                                tb.popStackToClose(formatEl.nodeName());\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            }\n\n                            \n                            \n                            Element node = furthestBlock;\n                            Element lastNode = furthestBlock;\n                            for (int j = 0; j < 3; j++) {\n                                if (tb.onStack(node))\n                                    node = tb.aboveOnStack(node);\n                                if (!tb.isInActiveFormattingElements(node)) { \n                                    tb.removeFromStack(node);\n                                    continue;\n                                } else if (node == formatEl)\n                                    break;\n\n                                Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n                                \n                                tb.replaceActiveFormattingElement(node, replacement);\n                                tb.replaceOnStack(node, replacement);\n                                node = replacement;\n\n                                if (lastNode == furthestBlock) {\n                                    \n                                    \n                                }\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                node.appendChild(lastNode);\n\n                                lastNode = node;\n                            }\n\n                            if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                tb.insertInFosterParent(lastNode);\n                            } else {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                commonAncestor.appendChild(lastNode);\n                            }\n\n                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                            adopter.attributes().addAll(formatEl.attributes());\n                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                            for (Node childNode : childNodes) {\n                                adopter.appendChild(childNode); \n                            }\n                            furthestBlock.appendChild(adopter);\n                            tb.removeFromActiveFormattingElements(formatEl);\n                            \n                            tb.removeFromStack(formatEl);\n                            tb.insertOnStackAfter(furthestBlock, adopter);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n                        if (!tb.inScope(name)) {\n                            \n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"span\")) {\n                        \n                        return anyOtherEndTag(t, tb);\n                    } else if (name.equals(\"li\")) {\n                        if (!tb.inListItemScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"body\")) {\n                        if (!tb.inScope(\"body\")) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            \n                            tb.transition(AfterBody);\n                        }\n                    } else if (name.equals(\"html\")) {\n                        boolean notIgnored = tb.processEndTag(\"body\");\n                        if (notIgnored)\n                            return tb.process(endTag);\n                    } else if (name.equals(\"form\")) {\n                        Element currentForm = tb.getFormElement();\n                        tb.setFormElement(null);\n                        if (currentForm == null || !tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            \n                            tb.removeFromStack(currentForm);\n                        }\n                    } else if (name.equals(\"p\")) {\n                        if (!tb.inButtonScope(name)) {\n                            tb.error(this);\n                            tb.processStartTag(name); \n                            return tb.process(endTag);\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                        if (!tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                        if (!tb.inScope(Constants.Headings)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(Constants.Headings);\n                        }\n                    } else if (name.equals(\"sarcasm\")) {\n                        \n                        return anyOtherEndTag(t, tb);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                        if (!tb.inScope(\"name\")) {\n                            if (!tb.inScope(name)) {\n                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker();\n                        }\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.processStartTag(\"br\");\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n\n                    break;\n                case EOF:\n                    \n                    \n                    break;\n            }\n            return true;\n        }\n\n        boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n            String name = t.asEndTag().normalName();\n            ArrayList<Element> stack = tb.getStack();\n            for (int pos = stack.size() -1; pos >= 0; pos--) {\n                Element node = stack.get(pos);\n                if (node.nodeName().equals(name)) {\n                    tb.generateImpliedEndTags(name);\n                    if (!name.equals(tb.currentElement().nodeName()))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    break;\n                } else {\n                    if (tb.isSpecial(node)) {\n                        tb.error(this);\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    Text {\n        \n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isCharacter()) {\n                tb.insert(t.asCharacter());\n            } else if (t.isEOF()) {\n                tb.error(this);\n                \n                tb.pop();\n                tb.transition(tb.originalState());\n                return tb.process(t);\n            } else if (t.isEndTag()) {\n                \n                tb.pop();\n                tb.transition(tb.originalState());\n            }\n            return true;\n        }\n    },\n    InTable {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isCharacter()) {\n                tb.newPendingTableCharacters();\n                tb.markInsertionMode();\n                tb.transition(InTableText);\n                return tb.process(t);\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n                return true;\n            } else if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isStartTag()) {\n                Token.StartTag startTag = t.asStartTag();\n                String name = startTag.normalName();\n                if (name.equals(\"caption\")) {\n                    tb.clearStackToTableContext();\n                    tb.insertMarkerToFormattingElements();\n                    tb.insert(startTag);\n                    tb.transition(InCaption);\n                } else if (name.equals(\"colgroup\")) {\n                    tb.clearStackToTableContext();\n                    tb.insert(startTag);\n                    tb.transition(InColumnGroup);\n                } else if (name.equals(\"col\")) {\n                    tb.processStartTag(\"colgroup\");\n                    return tb.process(t);\n                } else if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n                    tb.clearStackToTableContext();\n                    tb.insert(startTag);\n                    tb.transition(InTableBody);\n                } else if (StringUtil.in(name, \"td\", \"th\", \"tr\")) {\n                    tb.processStartTag(\"tbody\");\n                    return tb.process(t);\n                } else if (name.equals(\"table\")) {\n                    tb.error(this);\n                    boolean processed = tb.processEndTag(\"table\");\n                    if (processed) \n                        return tb.process(t);\n                } else if (StringUtil.in(name, \"style\", \"script\")) {\n                    return tb.process(t, InHead);\n                } else if (name.equals(\"input\")) {\n                    if (!startTag.attributes.get(\"type\").equalsIgnoreCase(\"hidden\")) {\n                        return anythingElse(t, tb);\n                    } else {\n                        tb.insertEmpty(startTag);\n                    }\n                } else if (name.equals(\"form\")) {\n                    tb.error(this);\n                    if (tb.getFormElement() != null)\n                        return false;\n                    else {\n                        tb.insertForm(startTag, false);\n                    }\n                } else {\n                    return anythingElse(t, tb);\n                }\n                return true; \n            } else if (t.isEndTag()) {\n                Token.EndTag endTag = t.asEndTag();\n                String name = endTag.normalName();\n\n                if (name.equals(\"table\")) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.popStackToClose(\"table\");\n                    }\n                    tb.resetInsertionMode();\n                } else if (StringUtil.in(name,\n                        \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    return anythingElse(t, tb);\n                }\n                return true; \n            } else if (t.isEOF()) {\n                if (tb.currentElement().nodeName().equals(\"html\"))\n                    tb.error(this);\n                return true; \n            }\n            return anythingElse(t, tb);\n        }\n\n        boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.error(this);\n            boolean processed;\n            if (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                tb.setFosterInserts(true);\n                processed = tb.process(t, InBody);\n                tb.setFosterInserts(false);\n            } else {\n                processed = tb.process(t, InBody);\n            }\n            return processed;\n        }\n    },\n    InTableText {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character:\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.getPendingTableCharacters().add(c.getData());\n                    }\n                    break;\n                default:\n                    \n                    if (tb.getPendingTableCharacters().size() > 0) {\n                        for (String character : tb.getPendingTableCharacters()) {\n                            if (!isWhitespace(character)) {\n                                \n                                tb.error(this);\n                                if (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                                    tb.setFosterInserts(true);\n                                    tb.process(new Token.Character().data(character), InBody);\n                                    tb.setFosterInserts(false);\n                                } else {\n                                    tb.process(new Token.Character().data(character), InBody);\n                                }\n                            } else\n                                tb.insert(new Token.Character().data(character));\n                        }\n                        tb.newPendingTableCharacters();\n                    }\n                    tb.transition(tb.originalState());\n                    return tb.process(t);\n            }\n            return true;\n        }\n    },\n    InCaption {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isEndTag() && t.asEndTag().normalName().equals(\"caption\")) {\n                Token.EndTag endTag = t.asEndTag();\n                String name = endTag.normalName();\n                if (!tb.inTableScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(\"caption\"))\n                        tb.error(this);\n                    tb.popStackToClose(\"caption\");\n                    tb.clearFormattingElementsToLastMarker();\n                    tb.transition(InTable);\n                }\n            } else if ((\n                    t.isStartTag() && StringUtil.in(t.asStartTag().normalName(),\n                            \"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\") ||\n                            t.isEndTag() && t.asEndTag().normalName().equals(\"table\"))\n                    ) {\n                tb.error(this);\n                boolean processed = tb.processEndTag(\"caption\");\n                if (processed)\n                    return tb.process(t);\n            } else if (t.isEndTag() && StringUtil.in(t.asEndTag().normalName(),\n                    \"body\", \"col\", \"colgroup\", \"html\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                tb.error(this);\n                return false;\n            } else {\n                return tb.process(t, InBody);\n            }\n            return true;\n        }\n    },\n    InColumnGroup {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n                return true;\n            }\n            switch (t.type) {\n                case Comment:\n                    tb.insert(t.asComment());\n                    break;\n                case Doctype:\n                    tb.error(this);\n                    break;\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.normalName();\n                    if (name.equals(\"html\"))\n                        return tb.process(t, InBody);\n                    else if (name.equals(\"col\"))\n                        tb.insertEmpty(startTag);\n                    else\n                        return anythingElse(t, tb);\n                    break;\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.normalName();\n                    if (name.equals(\"colgroup\")) {\n                        if (tb.currentElement().nodeName().equals(\"html\")) { \n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.pop();\n                            tb.transition(InTable);\n                        }\n                    } else\n                        return anythingElse(t, tb);\n                    break;\n                case EOF:\n                    if (tb.currentElement().nodeName().equals(\"html\"))\n                        return true; \n                    else\n                        return anythingElse(t, tb);\n                default:\n                    return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, TreeBuilder tb) {\n            boolean processed = tb.processEndTag(\"colgroup\");\n            if (processed) \n                return tb.process(t);\n            return true;\n        }\n    },\n    InTableBody {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.normalName();\n                    if (name.equals(\"tr\")) {\n                        tb.clearStackToTableBodyContext();\n                        tb.insert(startTag);\n                        tb.transition(InRow);\n                    } else if (StringUtil.in(name, \"th\", \"td\")) {\n                        tb.error(this);\n                        tb.processStartTag(\"tr\");\n                        return tb.process(startTag);\n                    } else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\")) {\n                        return exitTableBody(t, tb);\n                    } else\n                        return anythingElse(t, tb);\n                    break;\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.normalName();\n                    if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n                        if (!tb.inTableScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.clearStackToTableBodyContext();\n                            tb.pop();\n                            tb.transition(InTable);\n                        }\n                    } else if (name.equals(\"table\")) {\n                        return exitTableBody(t, tb);\n                    } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\", \"tr\")) {\n                        tb.error(this);\n                        return false;\n                    } else\n                        return anythingElse(t, tb);\n                    break;\n                default:\n                    return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean exitTableBody(Token t, HtmlTreeBuilder tb) {\n            if (!(tb.inTableScope(\"tbody\") || tb.inTableScope(\"thead\") || tb.inScope(\"tfoot\"))) {\n                \n                tb.error(this);\n                return false;\n            }\n            tb.clearStackToTableBodyContext();\n            tb.processEndTag(tb.currentElement().nodeName()); \n            return tb.process(t);\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            return tb.process(t, InTable);\n        }\n    },\n    InRow {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isStartTag()) {\n                Token.StartTag startTag = t.asStartTag();\n                String name = startTag.normalName();\n\n                if (StringUtil.in(name, \"th\", \"td\")) {\n                    tb.clearStackToTableRowContext();\n                    tb.insert(startTag);\n                    tb.transition(InCell);\n                    tb.insertMarkerToFormattingElements();\n                } else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                    return handleMissingTr(t, tb);\n                } else {\n                    return anythingElse(t, tb);\n                }\n            } else if (t.isEndTag()) {\n                Token.EndTag endTag = t.asEndTag();\n                String name = endTag.normalName();\n\n                if (name.equals(\"tr\")) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this); \n                        return false;\n                    }\n                    tb.clearStackToTableRowContext();\n                    tb.pop(); \n                    tb.transition(InTableBody);\n                } else if (name.equals(\"table\")) {\n                    return handleMissingTr(t, tb);\n                } else if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this);\n                        return false;\n                    }\n                    tb.processEndTag(\"tr\");\n                    return tb.process(t);\n                } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    return anythingElse(t, tb);\n                }\n            } else {\n                return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            return tb.process(t, InTable);\n        }\n\n        private boolean handleMissingTr(Token t, TreeBuilder tb) {\n            boolean processed = tb.processEndTag(\"tr\");\n            if (processed)\n                return tb.process(t);\n            else\n                return false;\n        }\n    },\n    InCell {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isEndTag()) {\n                Token.EndTag endTag = t.asEndTag();\n                String name = endTag.normalName();\n\n                if (StringUtil.in(name, \"td\", \"th\")) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this);\n                        tb.transition(InRow); \n                        return false;\n                    }\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    tb.clearFormattingElementsToLastMarker();\n                    tb.transition(InRow);\n                } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\")) {\n                    tb.error(this);\n                    return false;\n                } else if (StringUtil.in(name, \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this);\n                        return false;\n                    }\n                    closeCell(tb);\n                    return tb.process(t);\n                } else {\n                    return anythingElse(t, tb);\n                }\n            } else if (t.isStartTag() &&\n                    StringUtil.in(t.asStartTag().normalName(),\n                            \"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                if (!(tb.inTableScope(\"td\") || tb.inTableScope(\"th\"))) {\n                    tb.error(this);\n                    return false;\n                }\n                closeCell(tb);\n                return tb.process(t);\n            } else {\n                return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            return tb.process(t, InBody);\n        }\n\n        private void closeCell(HtmlTreeBuilder tb) {\n            if (tb.inTableScope(\"td\"))\n                tb.processEndTag(\"td\");\n            else\n                tb.processEndTag(\"th\"); \n        }\n    },\n    InSelect {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character:\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.insert(c);\n                    }\n                    break;\n                case Comment:\n                    tb.insert(t.asComment());\n                    break;\n                case Doctype:\n                    tb.error(this);\n                    return false;\n                case StartTag:\n                    Token.StartTag start = t.asStartTag();\n                    String name = start.normalName();\n                    if (name.equals(\"html\"))\n                        return tb.process(start, InBody);\n                    else if (name.equals(\"option\")) {\n                        tb.processEndTag(\"option\");\n                        tb.insert(start);\n                    } else if (name.equals(\"optgroup\")) {\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.processEndTag(\"option\");\n                        else if (tb.currentElement().nodeName().equals(\"optgroup\"))\n                            tb.processEndTag(\"optgroup\");\n                        tb.insert(start);\n                    } else if (name.equals(\"select\")) {\n                        tb.error(this);\n                        return tb.processEndTag(\"select\");\n                    } else if (StringUtil.in(name, \"input\", \"keygen\", \"textarea\")) {\n                        tb.error(this);\n                        if (!tb.inSelectScope(\"select\"))\n                            return false; \n                        tb.processEndTag(\"select\");\n                        return tb.process(start);\n                    } else if (name.equals(\"script\")) {\n                        return tb.process(t, InHead);\n                    } else {\n                        return anythingElse(t, tb);\n                    }\n                    break;\n                case EndTag:\n                    Token.EndTag end = t.asEndTag();\n                    name = end.normalName();\n                    if (name.equals(\"optgroup\")) {\n                        if (tb.currentElement().nodeName().equals(\"option\") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).nodeName().equals(\"optgroup\"))\n                            tb.processEndTag(\"option\");\n                        if (tb.currentElement().nodeName().equals(\"optgroup\"))\n                            tb.pop();\n                        else\n                            tb.error(this);\n                    } else if (name.equals(\"option\")) {\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.pop();\n                        else\n                            tb.error(this);\n                    } else if (name.equals(\"select\")) {\n                        if (!tb.inSelectScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.popStackToClose(name);\n                            tb.resetInsertionMode();\n                        }\n                    } else\n                        return anythingElse(t, tb);\n                    break;\n                case EOF:\n                    if (!tb.currentElement().nodeName().equals(\"html\"))\n                        tb.error(this);\n                    break;\n                default:\n                    return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.error(this);\n            return false;\n        }\n    },\n    InSelectInTable {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isStartTag() && StringUtil.in(t.asStartTag().normalName(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n                tb.error(this);\n                tb.processEndTag(\"select\");\n                return tb.process(t);\n            } else if (t.isEndTag() && StringUtil.in(t.asEndTag().normalName(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n                tb.error(this);\n                if (tb.inTableScope(t.asEndTag().normalName())) {\n                    tb.processEndTag(\"select\");\n                    return (tb.process(t));\n                } else\n                    return false;\n            } else {\n                return tb.process(t, InSelect);\n            }\n        }\n    },\n    AfterBody {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                return tb.process(t, InBody);\n            } else if (t.isComment()) {\n                tb.insert(t.asComment()); \n            } else if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                return tb.process(t, InBody);\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"html\")) {\n                if (tb.isFragmentParsing()) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.transition(AfterAfterBody);\n                }\n            } else if (t.isEOF()) {\n                \n            } else {\n                tb.error(this);\n                tb.transition(InBody);\n                return tb.process(t);\n            }\n            return true;\n        }\n    },\n    InFrameset {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isStartTag()) {\n                Token.StartTag start = t.asStartTag();\n                String name = start.normalName();\n                if (name.equals(\"html\")) {\n                    return tb.process(start, InBody);\n                } else if (name.equals(\"frameset\")) {\n                    tb.insert(start);\n                } else if (name.equals(\"frame\")) {\n                    tb.insertEmpty(start);\n                } else if (name.equals(\"noframes\")) {\n                    return tb.process(start, InHead);\n                } else {\n                    tb.error(this);\n                    return false;\n                }\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"frameset\")) {\n                if (tb.currentElement().nodeName().equals(\"html\")) { \n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.pop();\n                    if (!tb.isFragmentParsing() && !tb.currentElement().nodeName().equals(\"frameset\")) {\n                        tb.transition(AfterFrameset);\n                    }\n                }\n            } else if (t.isEOF()) {\n                if (!tb.currentElement().nodeName().equals(\"html\")) {\n                    tb.error(this);\n                    return true;\n                }\n            } else {\n                tb.error(this);\n                return false;\n            }\n            return true;\n        }\n    },\n    AfterFrameset {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                return tb.process(t, InBody);\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"html\")) {\n                tb.transition(AfterAfterFrameset);\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"noframes\")) {\n                return tb.process(t, InHead);\n            } else if (t.isEOF()) {\n                \n            } else {\n                tb.error(this);\n                return false;\n            }\n            return true;\n        }\n    },\n    AfterAfterBody {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().normalName().equals(\"html\"))) {\n                return tb.process(t, InBody);\n            } else if (t.isEOF()) {\n                \n            } else {\n                tb.error(this);\n                tb.transition(InBody);\n                return tb.process(t);\n            }\n            return true;\n        }\n    },\n    AfterAfterFrameset {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().normalName().equals(\"html\"))) {\n                return tb.process(t, InBody);\n            } else if (t.isEOF()) {\n                \n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"noframes\")) {\n                return tb.process(t, InHead);\n            } else {\n                tb.error(this);\n                return false;\n            }\n            return true;\n        }\n    },\n    ForeignContent {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            return true;\n            \n        }\n    };\n\n    private static String nullString = String.valueOf('\\u0000'); abstract boolean process(Token t, HtmlTreeBuilder tb); private static boolean isWhitespace(Token t) {\n        if (t.isCharacter()) {\n            String data = t.asCharacter().getData();\n            return isWhitespace(data);\n        }\n        return false;\n    }\n\n    private static boolean isWhitespace(String data) {\n        \n        for (int i = 0; i < data.length(); i++) {\n            char c = data.charAt(i);\n            if (!StringUtil.isWhitespace(c))\n                return false;\n        }\n        return true;\n    }\n\n    private static void handleRcData(Token.StartTag startTag, HtmlTreeBuilder tb) {\n        tb.insert(startTag);\n        tb.tokeniser.transition(TokeniserState.Rcdata);\n        tb.markInsertionMode();\n        tb.transition(Text);\n    }\n\n    private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb) {\n        tb.insert(startTag);\n        tb.tokeniser.transition(TokeniserState.Rawtext);\n        tb.markInsertionMode();\n        tb.transition(Text);\n    }\n\n    \n    \n    private static final class Constants {\n        private static final String[] InBodyStartToHead = new String[]{\"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\"};\n        private static final String[] InBodyStartPClosers = new String[]{\"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\",\n                \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n                \"p\", \"section\", \"summary\", \"ul\"};\n        private static final String[] Headings = new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"};\n        private static final String[] InBodyStartPreListing = new String[]{\"pre\", \"listing\"};\n        private static final String[] InBodyStartLiBreakers = new String[]{\"address\", \"div\", \"p\"};\n        private static final String[] DdDt = new String[]{\"dd\", \"dt\"};\n        private static final String[] Formatters = new String[]{\"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\"};\n        private static final String[] InBodyStartApplets = new String[]{\"applet\", \"marquee\", \"object\"};\n        private static final String[] InBodyStartEmptyFormatters = new String[]{\"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\"};\n        private static final String[] InBodyStartMedia = new String[]{\"param\", \"source\", \"track\"};\n        private static final String[] InBodyStartInputAttribs = new String[]{\"name\", \"action\", \"prompt\"};\n        private static final String[] InBodyStartOptions = new String[]{\"optgroup\", \"option\"};\n        private static final String[] InBodyStartRuby = new String[]{\"rp\", \"rt\"};\n        private static final String[] InBodyStartDrop = new String[]{\"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\"};\n        private static final String[] InBodyEndClosers = new String[]{\"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\",\n                \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\",\n                \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\"};\n        private static final String[] InBodyEndAdoptionFormatters = new String[]{\"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\"};\n        private static final String[] InBodyEndTableFosters = new String[]{\"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\"};\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.nodes.*;\n\nimport java.util.ArrayList;\n\n\nenum HtmlTreeBuilderState {\n    Initial {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                return true; \n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                \n                \n                Token.Doctype d = t.asDoctype();\n                DocumentType doctype = new DocumentType(\n                    tb.settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());\n                tb.getDocument().appendChild(doctype);\n                if (d.isForceQuirks())\n                    tb.getDocument().quirksMode(Document.QuirksMode.quirks);\n                tb.transition(BeforeHtml);\n            } else {\n                \n                tb.transition(BeforeHtml);\n                return tb.process(t); \n            }\n            return true;\n        }\n    },\n    BeforeHtml {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (isWhitespace(t)) {\n                return true; \n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                tb.insert(t.asStartTag());\n                tb.transition(BeforeHead);\n            } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().normalName(), \"head\", \"body\", \"html\", \"br\"))) {\n                return anythingElse(t, tb);\n            } else if (t.isEndTag()) {\n                tb.error(this);\n                return false;\n            } else {\n                return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.insertStartTag(\"html\");\n            tb.transition(BeforeHead);\n            return tb.process(t);\n        }\n    },\n    BeforeHead {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                return true;\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                return InBody.process(t, tb); \n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"head\")) {\n                Element head = tb.insert(t.asStartTag());\n                tb.setHeadElement(head);\n                tb.transition(InHead);\n            } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().normalName(), \"head\", \"body\", \"html\", \"br\"))) {\n                tb.processStartTag(\"head\");\n                return tb.process(t);\n            } else if (t.isEndTag()) {\n                tb.error(this);\n                return false;\n            } else {\n                tb.processStartTag(\"head\");\n                return tb.process(t);\n            }\n            return true;\n        }\n    },\n    InHead {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n                return true;\n            }\n            switch (t.type) {\n                case Comment:\n                    tb.insert(t.asComment());\n                    break;\n                case Doctype:\n                    tb.error(this);\n                    return false;\n                case StartTag:\n                    Token.StartTag start = t.asStartTag();\n                    String name = start.normalName();\n                    if (name.equals(\"html\")) {\n                        return InBody.process(t, tb);\n                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\")) {\n                        Element el = tb.insertEmpty(start);\n                        \n                        if (name.equals(\"base\") && el.hasAttr(\"href\"))\n                            tb.maybeSetBaseUri(el);\n                    } else if (name.equals(\"meta\")) {\n                        Element meta = tb.insertEmpty(start);\n                        \n                    } else if (name.equals(\"title\")) {\n                        handleRcData(start, tb);\n                    } else if (StringUtil.in(name, \"noframes\", \"style\")) {\n                        handleRawtext(start, tb);\n                    } else if (name.equals(\"noscript\")) {\n                        \n                        tb.insert(start);\n                        tb.transition(InHeadNoscript);\n                    } else if (name.equals(\"script\")) {\n                        \n\n                        tb.tokeniser.transition(TokeniserState.ScriptData);\n                        tb.markInsertionMode();\n                        tb.transition(Text);\n                        tb.insert(start);\n                    } else if (name.equals(\"head\")) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        return anythingElse(t, tb);\n                    }\n                    break;\n                case EndTag:\n                    Token.EndTag end = t.asEndTag();\n                    name = end.normalName();\n                    if (name.equals(\"head\")) {\n                        tb.pop();\n                        tb.transition(AfterHead);\n                    } else if (StringUtil.in(name, \"body\", \"html\", \"br\")) {\n                        return anythingElse(t, tb);\n                    } else {\n                        tb.error(this);\n                        return false;\n                    }\n                    break;\n                default:\n                    return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, TreeBuilder tb) {\n            tb.processEndTag(\"head\");\n            return tb.process(t);\n        }\n    },\n    InHeadNoscript {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isDoctype()) {\n                tb.error(this);\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                return tb.process(t, InBody);\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"noscript\")) {\n                tb.pop();\n                tb.transition(InHead);\n            } else if (isWhitespace(t) || t.isComment() || (t.isStartTag() && StringUtil.in(t.asStartTag().normalName(),\n                    \"basefont\", \"bgsound\", \"link\", \"meta\", \"noframes\", \"style\"))) {\n                return tb.process(t, InHead);\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"br\")) {\n                return anythingElse(t, tb);\n            } else if ((t.isStartTag() && StringUtil.in(t.asStartTag().normalName(), \"head\", \"noscript\")) || t.isEndTag()) {\n                tb.error(this);\n                return false;\n            } else {\n                return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.error(this);\n            tb.insert(new Token.Character().data(t.toString()));\n            return true;\n        }\n    },\n    AfterHead {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                tb.error(this);\n            } else if (t.isStartTag()) {\n                Token.StartTag startTag = t.asStartTag();\n                String name = startTag.normalName();\n                if (name.equals(\"html\")) {\n                    return tb.process(t, InBody);\n                } else if (name.equals(\"body\")) {\n                    tb.insert(startTag);\n                    tb.framesetOk(false);\n                    tb.transition(InBody);\n                } else if (name.equals(\"frameset\")) {\n                    tb.insert(startTag);\n                    tb.transition(InFrameset);\n                } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                    tb.error(this);\n                    Element head = tb.getHeadElement();\n                    tb.push(head);\n                    tb.process(t, InHead);\n                    tb.removeFromStack(head);\n                } else if (name.equals(\"head\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    anythingElse(t, tb);\n                }\n            } else if (t.isEndTag()) {\n                if (StringUtil.in(t.asEndTag().normalName(), \"body\", \"html\")) {\n                    anythingElse(t, tb);\n                } else {\n                    tb.error(this);\n                    return false;\n                }\n            } else {\n                anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.processStartTag(\"body\");\n            tb.framesetOk(true);\n            return tb.process(t);\n        }\n    },\n    InBody {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character: {\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        \n                        tb.error(this);\n                        return false;\n                    } else if (tb.framesetOk() && isWhitespace(c)) { \n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.normalName();\n                    if (name.equals(\"a\")) {\n                        if (tb.getActiveFormattingElement(\"a\") != null) {\n                            tb.error(this);\n                            tb.processEndTag(\"a\");\n\n                            \n                            Element remainingA = tb.getFromStack(\"a\");\n                            if (remainingA != null) {\n                                tb.removeFromActiveFormattingElements(remainingA);\n                                tb.removeFromStack(remainingA);\n                            }\n                        }\n                        tb.reconstructFormattingElements();\n                        Element a = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(a);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n                        tb.reconstructFormattingElements();\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"span\")) {\n                        \n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (name.equals(\"li\")) {\n                        tb.framesetOk(false);\n                        ArrayList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (el.nodeName().equals(\"li\")) {\n                                tb.processEndTag(\"li\");\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"html\")) {\n                        tb.error(this);\n                        \n                        Element html = tb.getStack().get(0);\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        ArrayList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            \n                            return false; \n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        ArrayList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            \n                            return false; \n                        } else if (!tb.framesetOk()) {\n                            return false; \n                        } else {\n                            Element second = stack.get(1);\n                            if (second.parent() != null)\n                                second.remove();\n                            \n                            while (stack.size() > 1)\n                                stack.remove(stack.size()-1);\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n                            tb.error(this);\n                            tb.pop();\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        \n                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null) {\n                            tb.error(this);\n                            return false;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insertForm(startTag, true);\n                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                        tb.framesetOk(false);\n                        ArrayList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n                                tb.processEndTag(el.nodeName());\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"plaintext\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); \n                    } else if (name.equals(\"button\")) {\n                        if (tb.inButtonScope(\"button\")) {\n                            \n                            tb.error(this);\n                            tb.processEndTag(\"button\");\n                            tb.process(startTag);\n                        } else {\n                            tb.reconstructFormattingElements();\n                            tb.insert(startTag);\n                            tb.framesetOk(false);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Formatters)) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (name.equals(\"nobr\")) {\n                        tb.reconstructFormattingElements();\n                        if (tb.inScope(\"nobr\")) {\n                            tb.error(this);\n                            tb.processEndTag(\"nobr\");\n                            tb.reconstructFormattingElements();\n                        }\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.insertMarkerToFormattingElements();\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"table\")) {\n                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        tb.transition(InTable);\n                    } else if (name.equals(\"input\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insertEmpty(startTag);\n                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                            tb.framesetOk(false);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n                        tb.insertEmpty(startTag);\n                    } else if (name.equals(\"hr\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"image\")) {\n                        if (tb.getFromStack(\"svg\") == null)\n                            return tb.process(startTag.name(\"img\")); \n                        else\n                            tb.insert(startTag);\n                    } else if (name.equals(\"isindex\")) {\n                        \n                        tb.error(this);\n                        if (tb.getFormElement() != null)\n                            return false;\n\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                        tb.processStartTag(\"form\");\n                        if (startTag.attributes.hasKey(\"action\")) {\n                            Element form = tb.getFormElement();\n                            form.attr(\"action\", startTag.attributes.get(\"action\"));\n                        }\n                        tb.processStartTag(\"hr\");\n                        tb.processStartTag(\"label\");\n                        \n                        String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                                startTag.attributes.get(\"prompt\") :\n                                \"This is a searchable index. Enter search keywords: \";\n\n                        tb.process(new Token.Character().data(prompt));\n\n                        \n                        Attributes inputAttribs = new Attributes();\n                        for (Attribute attr : startTag.attributes) {\n                            if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n                                inputAttribs.put(attr);\n                        }\n                        inputAttribs.put(\"name\", \"isindex\");\n                        tb.processStartTag(\"input\", inputAttribs);\n                        tb.processEndTag(\"label\");\n                        tb.processStartTag(\"hr\");\n                        tb.processEndTag(\"form\");\n                    } else if (name.equals(\"textarea\")) {\n                        tb.insert(startTag);\n                        \n                        tb.tokeniser.transition(TokeniserState.Rcdata);\n                        tb.markInsertionMode();\n                        tb.framesetOk(false);\n                        tb.transition(Text);\n                    } else if (name.equals(\"xmp\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.reconstructFormattingElements();\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"iframe\")) {\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"noembed\")) {\n                        \n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"select\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n\n                        HtmlTreeBuilderState state = tb.state();\n                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                            tb.transition(InSelectInTable);\n                        else\n                            tb.transition(InSelect);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.processEndTag(\"option\");\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n                        if (tb.inScope(\"ruby\")) {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                                tb.error(this);\n                                tb.popStackToBefore(\"ruby\"); \n                            }\n                            tb.insert(startTag);\n                        }\n                    } else if (name.equals(\"math\")) {\n                        tb.reconstructFormattingElements();\n                        \n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (name.equals(\"svg\")) {\n                        tb.reconstructFormattingElements();\n                        \n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    }\n                    break;\n\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.normalName();\n                    if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n                        \n                        for (int i = 0; i < 8; i++) {\n                            Element formatEl = tb.getActiveFormattingElement(name);\n                            if (formatEl == null)\n                                return anyOtherEndTag(t, tb);\n                            else if (!tb.onStack(formatEl)) {\n                                tb.error(this);\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            } else if (!tb.inScope(formatEl.nodeName())) {\n                                tb.error(this);\n                                return false;\n                            } else if (tb.currentElement() != formatEl)\n                                tb.error(this);\n\n                            Element furthestBlock = null;\n                            Element commonAncestor = null;\n                            boolean seenFormattingElement = false;\n                            ArrayList<Element> stack = tb.getStack();\n                            \n                            \n                            final int stackSize = stack.size();\n                            for (int si = 0; si < stackSize && si < 64; si++) {\n                                Element el = stack.get(si);\n                                if (el == formatEl) {\n                                    commonAncestor = stack.get(si - 1);\n                                    seenFormattingElement = true;\n                                } else if (seenFormattingElement && tb.isSpecial(el)) {\n                                    furthestBlock = el;\n                                    break;\n                                }\n                            }\n                            if (furthestBlock == null) {\n                                tb.popStackToClose(formatEl.nodeName());\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            }\n\n                            \n                            \n                            Element node = furthestBlock;\n                            Element lastNode = furthestBlock;\n                            for (int j = 0; j < 3; j++) {\n                                if (tb.onStack(node))\n                                    node = tb.aboveOnStack(node);\n                                if (!tb.isInActiveFormattingElements(node)) { \n                                    tb.removeFromStack(node);\n                                    continue;\n                                } else if (node == formatEl)\n                                    break;\n\n                                Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n                                \n                                tb.replaceActiveFormattingElement(node, replacement);\n                                tb.replaceOnStack(node, replacement);\n                                node = replacement;\n\n                                if (lastNode == furthestBlock) {\n                                    \n                                    \n                                }\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                node.appendChild(lastNode);\n\n                                lastNode = node;\n                            }\n\n                            if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                tb.insertInFosterParent(lastNode);\n                            } else {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                commonAncestor.appendChild(lastNode);\n                            }\n\n                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                            adopter.attributes().addAll(formatEl.attributes());\n                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                            for (Node childNode : childNodes) {\n                                adopter.appendChild(childNode); \n                            }\n                            furthestBlock.appendChild(adopter);\n                            tb.removeFromActiveFormattingElements(formatEl);\n                            \n                            tb.removeFromStack(formatEl);\n                            tb.insertOnStackAfter(furthestBlock, adopter);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n                        if (!tb.inScope(name)) {\n                            \n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"span\")) {\n                        \n                        return anyOtherEndTag(t, tb);\n                    } else if (name.equals(\"li\")) {\n                        if (!tb.inListItemScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"body\")) {\n                        if (!tb.inScope(\"body\")) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            \n                            tb.transition(AfterBody);\n                        }\n                    } else if (name.equals(\"html\")) {\n                        boolean notIgnored = tb.processEndTag(\"body\");\n                        if (notIgnored)\n                            return tb.process(endTag);\n                    } else if (name.equals(\"form\")) {\n                        Element currentForm = tb.getFormElement();\n                        tb.setFormElement(null);\n                        if (currentForm == null || !tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            \n                            tb.removeFromStack(currentForm);\n                        }\n                    } else if (name.equals(\"p\")) {\n                        if (!tb.inButtonScope(name)) {\n                            tb.error(this);\n                            tb.processStartTag(name); \n                            return tb.process(endTag);\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                        if (!tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                        if (!tb.inScope(Constants.Headings)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(Constants.Headings);\n                        }\n                    } else if (name.equals(\"sarcasm\")) {\n                        \n                        return anyOtherEndTag(t, tb);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                        if (!tb.inScope(\"name\")) {\n                            if (!tb.inScope(name)) {\n                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker();\n                        }\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.processStartTag(\"br\");\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n\n                    break;\n                case EOF:\n                    \n                    \n                    break;\n            }\n            return true;\n        }\n\n        boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n            String name = t.asEndTag().normalName();\n            ArrayList<Element> stack = tb.getStack();\n            for (int pos = stack.size() -1; pos >= 0; pos--) {\n                Element node = stack.get(pos);\n                if (node.nodeName().equals(name)) {\n                    tb.generateImpliedEndTags(name);\n                    if (!name.equals(tb.currentElement().nodeName()))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    break;\n                } else {\n                    if (tb.isSpecial(node)) {\n                        tb.error(this);\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    Text {\n        \n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isCharacter()) {\n                tb.insert(t.asCharacter());\n            } else if (t.isEOF()) {\n                tb.error(this);\n                \n                tb.pop();\n                tb.transition(tb.originalState());\n                return tb.process(t);\n            } else if (t.isEndTag()) {\n                \n                tb.pop();\n                tb.transition(tb.originalState());\n            }\n            return true;\n        }\n    },\n    InTable {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isCharacter()) {\n                tb.newPendingTableCharacters();\n                tb.markInsertionMode();\n                tb.transition(InTableText);\n                return tb.process(t);\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n                return true;\n            } else if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isStartTag()) {\n                Token.StartTag startTag = t.asStartTag();\n                String name = startTag.normalName();\n                if (name.equals(\"caption\")) {\n                    tb.clearStackToTableContext();\n                    tb.insertMarkerToFormattingElements();\n                    tb.insert(startTag);\n                    tb.transition(InCaption);\n                } else if (name.equals(\"colgroup\")) {\n                    tb.clearStackToTableContext();\n                    tb.insert(startTag);\n                    tb.transition(InColumnGroup);\n                } else if (name.equals(\"col\")) {\n                    tb.processStartTag(\"colgroup\");\n                    return tb.process(t);\n                } else if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n                    tb.clearStackToTableContext();\n                    tb.insert(startTag);\n                    tb.transition(InTableBody);\n                } else if (StringUtil.in(name, \"td\", \"th\", \"tr\")) {\n                    tb.processStartTag(\"tbody\");\n                    return tb.process(t);\n                } else if (name.equals(\"table\")) {\n                    tb.error(this);\n                    boolean processed = tb.processEndTag(\"table\");\n                    if (processed) \n                        return tb.process(t);\n                } else if (StringUtil.in(name, \"style\", \"script\")) {\n                    return tb.process(t, InHead);\n                } else if (name.equals(\"input\")) {\n                    if (!startTag.attributes.get(\"type\").equalsIgnoreCase(\"hidden\")) {\n                        return anythingElse(t, tb);\n                    } else {\n                        tb.insertEmpty(startTag);\n                    }\n                } else if (name.equals(\"form\")) {\n                    tb.error(this);\n                    if (tb.getFormElement() != null)\n                        return false;\n                    else {\n                        tb.insertForm(startTag, false);\n                    }\n                } else {\n                    return anythingElse(t, tb);\n                }\n                return true; \n            } else if (t.isEndTag()) {\n                Token.EndTag endTag = t.asEndTag();\n                String name = endTag.normalName();\n\n                if (name.equals(\"table\")) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.popStackToClose(\"table\");\n                    }\n                    tb.resetInsertionMode();\n                } else if (StringUtil.in(name,\n                        \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    return anythingElse(t, tb);\n                }\n                return true; \n            } else if (t.isEOF()) {\n                if (tb.currentElement().nodeName().equals(\"html\"))\n                    tb.error(this);\n                return true; \n            }\n            return anythingElse(t, tb);\n        }\n\n        boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.error(this);\n            boolean processed;\n            if (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                tb.setFosterInserts(true);\n                processed = tb.process(t, InBody);\n                tb.setFosterInserts(false);\n            } else {\n                processed = tb.process(t, InBody);\n            }\n            return processed;\n        }\n    },\n    InTableText {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character:\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.getPendingTableCharacters().add(c.getData());\n                    }\n                    break;\n                default:\n                    \n                    if (tb.getPendingTableCharacters().size() > 0) {\n                        for (String character : tb.getPendingTableCharacters()) {\n                            if (!isWhitespace(character)) {\n                                \n                                tb.error(this);\n                                if (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                                    tb.setFosterInserts(true);\n                                    tb.process(new Token.Character().data(character), InBody);\n                                    tb.setFosterInserts(false);\n                                } else {\n                                    tb.process(new Token.Character().data(character), InBody);\n                                }\n                            } else\n                                tb.insert(new Token.Character().data(character));\n                        }\n                        tb.newPendingTableCharacters();\n                    }\n                    tb.transition(tb.originalState());\n                    return tb.process(t);\n            }\n            return true;\n        }\n    },\n    InCaption {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isEndTag() && t.asEndTag().normalName().equals(\"caption\")) {\n                Token.EndTag endTag = t.asEndTag();\n                String name = endTag.normalName();\n                if (!tb.inTableScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(\"caption\"))\n                        tb.error(this);\n                    tb.popStackToClose(\"caption\");\n                    tb.clearFormattingElementsToLastMarker();\n                    tb.transition(InTable);\n                }\n            } else if ((\n                    t.isStartTag() && StringUtil.in(t.asStartTag().normalName(),\n                            \"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\") ||\n                            t.isEndTag() && t.asEndTag().normalName().equals(\"table\"))\n                    ) {\n                tb.error(this);\n                boolean processed = tb.processEndTag(\"caption\");\n                if (processed)\n                    return tb.process(t);\n            } else if (t.isEndTag() && StringUtil.in(t.asEndTag().normalName(),\n                    \"body\", \"col\", \"colgroup\", \"html\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                tb.error(this);\n                return false;\n            } else {\n                return tb.process(t, InBody);\n            }\n            return true;\n        }\n    },\n    InColumnGroup {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n                return true;\n            }\n            switch (t.type) {\n                case Comment:\n                    tb.insert(t.asComment());\n                    break;\n                case Doctype:\n                    tb.error(this);\n                    break;\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.normalName();\n                    if (name.equals(\"html\"))\n                        return tb.process(t, InBody);\n                    else if (name.equals(\"col\"))\n                        tb.insertEmpty(startTag);\n                    else\n                        return anythingElse(t, tb);\n                    break;\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.normalName();\n                    if (name.equals(\"colgroup\")) {\n                        if (tb.currentElement().nodeName().equals(\"html\")) { \n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.pop();\n                            tb.transition(InTable);\n                        }\n                    } else\n                        return anythingElse(t, tb);\n                    break;\n                case EOF:\n                    if (tb.currentElement().nodeName().equals(\"html\"))\n                        return true; \n                    else\n                        return anythingElse(t, tb);\n                default:\n                    return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, TreeBuilder tb) {\n            boolean processed = tb.processEndTag(\"colgroup\");\n            if (processed) \n                return tb.process(t);\n            return true;\n        }\n    },\n    InTableBody {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.normalName();\n                    if (name.equals(\"tr\")) {\n                        tb.clearStackToTableBodyContext();\n                        tb.insert(startTag);\n                        tb.transition(InRow);\n                    } else if (StringUtil.in(name, \"th\", \"td\")) {\n                        tb.error(this);\n                        tb.processStartTag(\"tr\");\n                        return tb.process(startTag);\n                    } else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\")) {\n                        return exitTableBody(t, tb);\n                    } else\n                        return anythingElse(t, tb);\n                    break;\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.normalName();\n                    if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n                        if (!tb.inTableScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.clearStackToTableBodyContext();\n                            tb.pop();\n                            tb.transition(InTable);\n                        }\n                    } else if (name.equals(\"table\")) {\n                        return exitTableBody(t, tb);\n                    } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\", \"tr\")) {\n                        tb.error(this);\n                        return false;\n                    } else\n                        return anythingElse(t, tb);\n                    break;\n                default:\n                    return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean exitTableBody(Token t, HtmlTreeBuilder tb) {\n            if (!(tb.inTableScope(\"tbody\") || tb.inTableScope(\"thead\") || tb.inScope(\"tfoot\"))) {\n                \n                tb.error(this);\n                return false;\n            }\n            tb.clearStackToTableBodyContext();\n            tb.processEndTag(tb.currentElement().nodeName()); \n            return tb.process(t);\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            return tb.process(t, InTable);\n        }\n    },\n    InRow {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isStartTag()) {\n                Token.StartTag startTag = t.asStartTag();\n                String name = startTag.normalName();\n\n                if (StringUtil.in(name, \"th\", \"td\")) {\n                    tb.clearStackToTableRowContext();\n                    tb.insert(startTag);\n                    tb.transition(InCell);\n                    tb.insertMarkerToFormattingElements();\n                } else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                    return handleMissingTr(t, tb);\n                } else {\n                    return anythingElse(t, tb);\n                }\n            } else if (t.isEndTag()) {\n                Token.EndTag endTag = t.asEndTag();\n                String name = endTag.normalName();\n\n                if (name.equals(\"tr\")) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this); \n                        return false;\n                    }\n                    tb.clearStackToTableRowContext();\n                    tb.pop(); \n                    tb.transition(InTableBody);\n                } else if (name.equals(\"table\")) {\n                    return handleMissingTr(t, tb);\n                } else if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this);\n                        return false;\n                    }\n                    tb.processEndTag(\"tr\");\n                    return tb.process(t);\n                } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    return anythingElse(t, tb);\n                }\n            } else {\n                return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            return tb.process(t, InTable);\n        }\n\n        private boolean handleMissingTr(Token t, TreeBuilder tb) {\n            boolean processed = tb.processEndTag(\"tr\");\n            if (processed)\n                return tb.process(t);\n            else\n                return false;\n        }\n    },\n    InCell {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isEndTag()) {\n                Token.EndTag endTag = t.asEndTag();\n                String name = endTag.normalName();\n\n                if (StringUtil.in(name, \"td\", \"th\")) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this);\n                        tb.transition(InRow); \n                        return false;\n                    }\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    tb.clearFormattingElementsToLastMarker();\n                    tb.transition(InRow);\n                } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\")) {\n                    tb.error(this);\n                    return false;\n                } else if (StringUtil.in(name, \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this);\n                        return false;\n                    }\n                    closeCell(tb);\n                    return tb.process(t);\n                } else {\n                    return anythingElse(t, tb);\n                }\n            } else if (t.isStartTag() &&\n                    StringUtil.in(t.asStartTag().normalName(),\n                            \"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                if (!(tb.inTableScope(\"td\") || tb.inTableScope(\"th\"))) {\n                    tb.error(this);\n                    return false;\n                }\n                closeCell(tb);\n                return tb.process(t);\n            } else {\n                return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            return tb.process(t, InBody);\n        }\n\n        private void closeCell(HtmlTreeBuilder tb) {\n            if (tb.inTableScope(\"td\"))\n                tb.processEndTag(\"td\");\n            else\n                tb.processEndTag(\"th\"); \n        }\n    },\n    InSelect {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character:\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.insert(c);\n                    }\n                    break;\n                case Comment:\n                    tb.insert(t.asComment());\n                    break;\n                case Doctype:\n                    tb.error(this);\n                    return false;\n                case StartTag:\n                    Token.StartTag start = t.asStartTag();\n                    String name = start.normalName();\n                    if (name.equals(\"html\"))\n                        return tb.process(start, InBody);\n                    else if (name.equals(\"option\")) {\n                        tb.processEndTag(\"option\");\n                        tb.insert(start);\n                    } else if (name.equals(\"optgroup\")) {\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.processEndTag(\"option\");\n                        else if (tb.currentElement().nodeName().equals(\"optgroup\"))\n                            tb.processEndTag(\"optgroup\");\n                        tb.insert(start);\n                    } else if (name.equals(\"select\")) {\n                        tb.error(this);\n                        return tb.processEndTag(\"select\");\n                    } else if (StringUtil.in(name, \"input\", \"keygen\", \"textarea\")) {\n                        tb.error(this);\n                        if (!tb.inSelectScope(\"select\"))\n                            return false; \n                        tb.processEndTag(\"select\");\n                        return tb.process(start);\n                    } else if (name.equals(\"script\")) {\n                        return tb.process(t, InHead);\n                    } else {\n                        return anythingElse(t, tb);\n                    }\n                    break;\n                case EndTag:\n                    Token.EndTag end = t.asEndTag();\n                    name = end.normalName();\n                    if (name.equals(\"optgroup\")) {\n                        if (tb.currentElement().nodeName().equals(\"option\") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).nodeName().equals(\"optgroup\"))\n                            tb.processEndTag(\"option\");\n                        if (tb.currentElement().nodeName().equals(\"optgroup\"))\n                            tb.pop();\n                        else\n                            tb.error(this);\n                    } else if (name.equals(\"option\")) {\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.pop();\n                        else\n                            tb.error(this);\n                    } else if (name.equals(\"select\")) {\n                        if (!tb.inSelectScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.popStackToClose(name);\n                            tb.resetInsertionMode();\n                        }\n                    } else\n                        return anythingElse(t, tb);\n                    break;\n                case EOF:\n                    if (!tb.currentElement().nodeName().equals(\"html\"))\n                        tb.error(this);\n                    break;\n                default:\n                    return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.error(this);\n            return false;\n        }\n    },\n    InSelectInTable {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isStartTag() && StringUtil.in(t.asStartTag().normalName(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n                tb.error(this);\n                tb.processEndTag(\"select\");\n                return tb.process(t);\n            } else if (t.isEndTag() && StringUtil.in(t.asEndTag().normalName(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n                tb.error(this);\n                if (tb.inTableScope(t.asEndTag().normalName())) {\n                    tb.processEndTag(\"select\");\n                    return (tb.process(t));\n                } else\n                    return false;\n            } else {\n                return tb.process(t, InSelect);\n            }\n        }\n    },\n    AfterBody {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                return tb.process(t, InBody);\n            } else if (t.isComment()) {\n                tb.insert(t.asComment()); \n            } else if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                return tb.process(t, InBody);\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"html\")) {\n                if (tb.isFragmentParsing()) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.transition(AfterAfterBody);\n                }\n            } else if (t.isEOF()) {\n                \n            } else {\n                tb.error(this);\n                tb.transition(InBody);\n                return tb.process(t);\n            }\n            return true;\n        }\n    },\n    InFrameset {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isStartTag()) {\n                Token.StartTag start = t.asStartTag();\n                String name = start.normalName();\n                if (name.equals(\"html\")) {\n                    return tb.process(start, InBody);\n                } else if (name.equals(\"frameset\")) {\n                    tb.insert(start);\n                } else if (name.equals(\"frame\")) {\n                    tb.insertEmpty(start);\n                } else if (name.equals(\"noframes\")) {\n                    return tb.process(start, InHead);\n                } else {\n                    tb.error(this);\n                    return false;\n                }\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"frameset\")) {\n                if (tb.currentElement().nodeName().equals(\"html\")) { \n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.pop();\n                    if (!tb.isFragmentParsing() && !tb.currentElement().nodeName().equals(\"frameset\")) {\n                        tb.transition(AfterFrameset);\n                    }\n                }\n            } else if (t.isEOF()) {\n                if (!tb.currentElement().nodeName().equals(\"html\")) {\n                    tb.error(this);\n                    return true;\n                }\n            } else {\n                tb.error(this);\n                return false;\n            }\n            return true;\n        }\n    },\n    AfterFrameset {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                return tb.process(t, InBody);\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"html\")) {\n                tb.transition(AfterAfterFrameset);\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"noframes\")) {\n                return tb.process(t, InHead);\n            } else if (t.isEOF()) {\n                \n            } else {\n                tb.error(this);\n                return false;\n            }\n            return true;\n        }\n    },\n    AfterAfterBody {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().normalName().equals(\"html\"))) {\n                return tb.process(t, InBody);\n            } else if (t.isEOF()) {\n                \n            } else {\n                tb.error(this);\n                tb.transition(InBody);\n                return tb.process(t);\n            }\n            return true;\n        }\n    },\n    AfterAfterFrameset {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().normalName().equals(\"html\"))) {\n                return tb.process(t, InBody);\n            } else if (t.isEOF()) {\n                \n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"noframes\")) {\n                return tb.process(t, InHead);\n            } else {\n                tb.error(this);\n                return false;\n            }\n            return true;\n        }\n    },\n    ForeignContent {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            return true;\n            \n        }\n    };\n\n    private static String nullString = String.valueOf('\\u0000'); abstract boolean process(Token t, HtmlTreeBuilder tb); private static boolean isWhitespace(Token t) {\n        if (t.isCharacter()) {\n            String data = t.asCharacter().getData();\n            return isWhitespace(data);\n        }\n        return false;\n    }\n\n    private static boolean isWhitespace(String data) {\n        \n        for (int i = 0; i < data.length(); i++) {\n            char c = data.charAt(i);\n            if (!StringUtil.isWhitespace(c))\n                return false;\n        }\n        return true;\n    }\n\n    private static void handleRcData(Token.StartTag startTag, HtmlTreeBuilder tb) {\n        tb.insert(startTag);\n        tb.tokeniser.transition(TokeniserState.Rcdata);\n        tb.markInsertionMode();\n        tb.transition(Text);\n    }\n\n    private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb) {\n        tb.insert(startTag);\n        tb.tokeniser.transition(TokeniserState.Rawtext);\n        tb.markInsertionMode();\n        tb.transition(Text);\n    }\n\n    \n    \n    private static final class Constants {\n        private static final String[] InBodyStartToHead = new String[]{\"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\"};\n        private static final String[] InBodyStartPClosers = new String[]{\"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\",\n                \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n                \"p\", \"section\", \"summary\", \"ul\"};\n        private static final String[] Headings = new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"};\n        private static final String[] InBodyStartPreListing = new String[]{\"pre\", \"listing\"};\n        private static final String[] InBodyStartLiBreakers = new String[]{\"address\", \"div\", \"p\"};\n        private static final String[] DdDt = new String[]{\"dd\", \"dt\"};\n        private static final String[] Formatters = new String[]{\"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\"};\n        private static final String[] InBodyStartApplets = new String[]{\"applet\", \"marquee\", \"object\"};\n        private static final String[] InBodyStartEmptyFormatters = new String[]{\"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\"};\n        private static final String[] InBodyStartMedia = new String[]{\"param\", \"source\", \"track\"};\n        private static final String[] InBodyStartInputAttribs = new String[]{\"name\", \"action\", \"prompt\"};\n        private static final String[] InBodyStartOptions = new String[]{\"optgroup\", \"option\"};\n        private static final String[] InBodyStartRuby = new String[]{\"rp\", \"rt\"};\n        private static final String[] InBodyStartDrop = new String[]{\"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\"};\n        private static final String[] InBodyEndClosers = new String[]{\"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\",\n                \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\",\n                \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\"};\n        private static final String[] InBodyEndAdoptionFormatters = new String[]{\"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\"};\n        private static final String[] InBodyEndTableFosters = new String[]{\"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\"};\n    }\n}\n",
      "buggy_signatures": [
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private boolean anythingElse(Token t, TreeBuilder tb)",
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private boolean anythingElse(Token t, TreeBuilder tb)",
        "private boolean exitTableBody(Token t, HtmlTreeBuilder tb)",
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private boolean handleMissingTr(Token t, TreeBuilder tb)",
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private void closeCell(HtmlTreeBuilder tb)",
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private static boolean isWhitespace(String data)",
        "private static void handleRcData(Token.StartTag startTag, HtmlTreeBuilder tb)",
        "private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb)"
      ],
      "fixed_signatures": [
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private boolean anythingElse(Token t, TreeBuilder tb)",
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private boolean anythingElse(Token t, TreeBuilder tb)",
        "private boolean exitTableBody(Token t, HtmlTreeBuilder tb)",
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private boolean handleMissingTr(Token t, TreeBuilder tb)",
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private void closeCell(HtmlTreeBuilder tb)",
        "private boolean anythingElse(Token t, HtmlTreeBuilder tb)",
        "private static boolean isWhitespace(String data)",
        "private static void handleRcData(Token.StartTag startTag, HtmlTreeBuilder tb)",
        "private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb)"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -20,7 +20,7 @@",
            "                 // todo: quirk state check on doctype ids\n",
            "                 Token.Doctype d = t.asDoctype();\n",
            "                 DocumentType doctype = new DocumentType(\n",
            "-                    tb.settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());\n",
            "+                    tb.settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());\n",
            "                 tb.getDocument().appendChild(doctype);\n",
            "                 if (d.isForceQuirks())\n",
            "                     tb.getDocument().quirksMode(Document.QuirksMode.quirks);\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "org/jsoup/parser/Token.java",
      "buggy_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Attribute;\nimport org.jsoup.nodes.Attributes;\nimport org.jsoup.nodes.BooleanAttribute;\n\n\nabstract class Token { TokenType type; private Token() {\n    }\n    \n    String tokenType() {\n        return this.getClass().getSimpleName();\n    }\n\n    \n    abstract Token reset(); static void reset(StringBuilder sb) {\n        if (sb != null) {\n            sb.delete(0, sb.length());\n        }\n    }\n\n    static final class Doctype extends Token { final StringBuilder name = new StringBuilder(); final StringBuilder publicIdentifier = new StringBuilder(); final StringBuilder systemIdentifier = new StringBuilder(); boolean forceQuirks = false; Doctype() {\n            type = TokenType.Doctype;\n        }\n\n        @Override\n        Token reset() {\n            reset(name);\n            reset(publicIdentifier);\n            reset(systemIdentifier);\n            forceQuirks = false;\n            return this;\n        }\n\n        String getName() {\n            return name.toString();\n        }\n\n\n        String getPublicIdentifier() {\n            return publicIdentifier.toString();\n        }\n\n        public String getSystemIdentifier() {\n            return systemIdentifier.toString();\n        }\n\n        public boolean isForceQuirks() {\n            return forceQuirks;\n        }\n    }\n\n    static abstract class Tag extends Token { protected String tagName; protected String normalName; private String pendingAttributeName; private StringBuilder pendingAttributeValue = new StringBuilder(); private String pendingAttributeValueS; private boolean hasEmptyAttributeValue = false; private boolean hasPendingAttributeValue = false; boolean selfClosing = false; Attributes attributes; @Override Tag reset() {\n            tagName = null;\n            normalName = null;\n            pendingAttributeName = null;\n            reset(pendingAttributeValue);\n            pendingAttributeValueS = null;\n            hasEmptyAttributeValue = false;\n            hasPendingAttributeValue = false;\n            selfClosing = false;\n            attributes = null;\n            return this;\n        }\n\n        final void newAttribute() {\n            if (attributes == null)\n                attributes = new Attributes();\n\n            if (pendingAttributeName != null) {\n                Attribute attribute;\n                if (hasPendingAttributeValue)\n                    attribute = new Attribute(pendingAttributeName,\n                        pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n                else if (hasEmptyAttributeValue)\n                    attribute = new Attribute(pendingAttributeName, \"\");\n                else\n                    attribute = new BooleanAttribute(pendingAttributeName);\n                attributes.put(attribute);\n            }\n            pendingAttributeName = null;\n            hasEmptyAttributeValue = false;\n            hasPendingAttributeValue = false;\n            reset(pendingAttributeValue);\n            pendingAttributeValueS = null;\n        }\n\n        final void finaliseTag() {\n            \n            if (pendingAttributeName != null) {\n                \n                newAttribute();\n            }\n        }\n\n        final String name() { \n            Validate.isFalse(tagName == null || tagName.length() == 0);\n            return tagName;\n        }\n\n        final String normalName() { \n            return normalName;\n        }\n\n        final Tag name(String name) {\n            tagName = name;\n            normalName = name.toLowerCase();\n            return this;\n        }\n\n        final boolean isSelfClosing() {\n            return selfClosing;\n        }\n\n        @SuppressWarnings({\"TypeMayBeWeakened\"})\n        final Attributes getAttributes() {\n            return attributes;\n        }\n\n        \n        final void appendTagName(String append) {\n            tagName = tagName == null ? append : tagName.concat(append);\n            normalName = tagName.toLowerCase();\n        }\n\n        final void appendTagName(char append) {\n            appendTagName(String.valueOf(append));\n        }\n\n        final void appendAttributeName(String append) {\n            pendingAttributeName = pendingAttributeName == null ? append : pendingAttributeName.concat(append);\n        }\n\n        final void appendAttributeName(char append) {\n            appendAttributeName(String.valueOf(append));\n        }\n\n        final void appendAttributeValue(String append) {\n            ensureAttributeValue();\n            if (pendingAttributeValue.length() == 0) {\n                pendingAttributeValueS = append;\n            } else {\n                pendingAttributeValue.append(append);\n            }\n        }\n\n        final void appendAttributeValue(char append) {\n            ensureAttributeValue();\n            pendingAttributeValue.append(append);\n        }\n\n        final void appendAttributeValue(char[] append) {\n            ensureAttributeValue();\n            pendingAttributeValue.append(append);\n        }\n\n        final void appendAttributeValue(int[] appendCodepoints) {\n            ensureAttributeValue();\n            for (int codepoint : appendCodepoints) {\n                pendingAttributeValue.appendCodePoint(codepoint);\n            }\n        }\n        \n        final void setEmptyAttributeValue() {\n            hasEmptyAttributeValue = true;\n        }\n\n        private void ensureAttributeValue() {\n            hasPendingAttributeValue = true;\n            \n            if (pendingAttributeValueS != null) {\n                pendingAttributeValue.append(pendingAttributeValueS);\n                pendingAttributeValueS = null;\n            }\n        }\n    }\n\n    final static class StartTag extends Tag { StartTag() {\n            super();\n            attributes = new Attributes();\n            type = TokenType.StartTag;\n        }\n\n        @Override\n        Tag reset() {\n            super.reset();\n            attributes = new Attributes();\n            \n            return this;\n        }\n\n        StartTag nameAttr(String name, Attributes attributes) {\n            this.tagName = name;\n            this.attributes = attributes;\n            normalName = tagName.toLowerCase();\n            return this;\n        }\n\n        @Override\n        public String toString() {\n            if (attributes != null && attributes.size() > 0)\n                return \"<\" + name() + \" \" + attributes.toString() + \">\";\n            else\n                return \"<\" + name() + \">\";\n        }\n    }\n\n    final static class EndTag extends Tag{ EndTag() {\n            super();\n            type = TokenType.EndTag;\n        }\n\n        @Override\n        public String toString() {\n            return \"</\" + name() + \">\";\n        }\n    }\n\n    final static class Comment extends Token { final StringBuilder data = new StringBuilder(); boolean bogus = false; @Override Token reset() {\n            reset(data);\n            bogus = false;\n            return this;\n        }\n\n        Comment() {\n            type = TokenType.Comment;\n        }\n\n        String getData() {\n            return data.toString();\n        }\n\n        @Override\n        public String toString() {\n            return \"<!--\" + getData() + \"-->\";\n        }\n    }\n\n    final static class Character extends Token { private String data; Character() {\n            super();\n            type = TokenType.Character;\n        }\n\n        @Override\n        Token reset() {\n            data = null;\n            return this;\n        }\n\n        Character data(String data) {\n            this.data = data;\n            return this;\n        }\n\n        String getData() {\n            return data;\n        }\n\n        @Override\n        public String toString() {\n            return getData();\n        }\n    }\n\n    final static class EOF extends Token { EOF() {\n            type = Token.TokenType.EOF;\n        }\n\n        @Override\n        Token reset() {\n            return this;\n        }\n    }\n\n    final boolean isDoctype() {\n        return type == TokenType.Doctype;\n    }\n\n    final Doctype asDoctype() {\n        return (Doctype) this;\n    }\n\n    final boolean isStartTag() {\n        return type == TokenType.StartTag;\n    }\n\n    final StartTag asStartTag() {\n        return (StartTag) this;\n    }\n\n    final boolean isEndTag() {\n        return type == TokenType.EndTag;\n    }\n\n    final EndTag asEndTag() {\n        return (EndTag) this;\n    }\n\n    final boolean isComment() {\n        return type == TokenType.Comment;\n    }\n\n    final Comment asComment() {\n        return (Comment) this;\n    }\n\n    final boolean isCharacter() {\n        return type == TokenType.Character;\n    }\n\n    final Character asCharacter() {\n        return (Character) this;\n    }\n\n    final boolean isEOF() {\n        return type == TokenType.EOF;\n    }\n\n    enum TokenType {\n        Doctype,\n        StartTag,\n        EndTag,\n        Comment,\n        Character,\n        EOF\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Attribute;\nimport org.jsoup.nodes.Attributes;\nimport org.jsoup.nodes.BooleanAttribute;\n\n\nabstract class Token { TokenType type; private Token() {\n    }\n    \n    String tokenType() {\n        return this.getClass().getSimpleName();\n    }\n\n    \n    abstract Token reset(); static void reset(StringBuilder sb) {\n        if (sb != null) {\n            sb.delete(0, sb.length());\n        }\n    }\n\n    static final class Doctype extends Token { final StringBuilder name = new StringBuilder(); String pubSysKey = null; final StringBuilder publicIdentifier = new StringBuilder(); final StringBuilder systemIdentifier = new StringBuilder(); boolean forceQuirks = false; Doctype() {\n            type = TokenType.Doctype;\n        }\n\n        @Override\n        Token reset() {\n            reset(name);\n            pubSysKey = null;\n            reset(publicIdentifier);\n            reset(systemIdentifier);\n            forceQuirks = false;\n            return this;\n        }\n\n        String getName() {\n            return name.toString();\n        }\n\n        String getPubSysKey() {\n            return pubSysKey;\n        }\n\n        String getPublicIdentifier() {\n            return publicIdentifier.toString();\n        }\n\n        public String getSystemIdentifier() {\n            return systemIdentifier.toString();\n        }\n\n        public boolean isForceQuirks() {\n            return forceQuirks;\n        }\n    }\n\n    static abstract class Tag extends Token { protected String tagName; protected String normalName; private String pendingAttributeName; private StringBuilder pendingAttributeValue = new StringBuilder(); private String pendingAttributeValueS; private boolean hasEmptyAttributeValue = false; private boolean hasPendingAttributeValue = false; boolean selfClosing = false; Attributes attributes; @Override Tag reset() {\n            tagName = null;\n            normalName = null;\n            pendingAttributeName = null;\n            reset(pendingAttributeValue);\n            pendingAttributeValueS = null;\n            hasEmptyAttributeValue = false;\n            hasPendingAttributeValue = false;\n            selfClosing = false;\n            attributes = null;\n            return this;\n        }\n\n        final void newAttribute() {\n            if (attributes == null)\n                attributes = new Attributes();\n\n            if (pendingAttributeName != null) {\n                Attribute attribute;\n                if (hasPendingAttributeValue)\n                    attribute = new Attribute(pendingAttributeName,\n                        pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n                else if (hasEmptyAttributeValue)\n                    attribute = new Attribute(pendingAttributeName, \"\");\n                else\n                    attribute = new BooleanAttribute(pendingAttributeName);\n                attributes.put(attribute);\n            }\n            pendingAttributeName = null;\n            hasEmptyAttributeValue = false;\n            hasPendingAttributeValue = false;\n            reset(pendingAttributeValue);\n            pendingAttributeValueS = null;\n        }\n\n        final void finaliseTag() {\n            \n            if (pendingAttributeName != null) {\n                \n                newAttribute();\n            }\n        }\n\n        final String name() { \n            Validate.isFalse(tagName == null || tagName.length() == 0);\n            return tagName;\n        }\n\n        final String normalName() { \n            return normalName;\n        }\n\n        final Tag name(String name) {\n            tagName = name;\n            normalName = name.toLowerCase();\n            return this;\n        }\n\n        final boolean isSelfClosing() {\n            return selfClosing;\n        }\n\n        @SuppressWarnings({\"TypeMayBeWeakened\"})\n        final Attributes getAttributes() {\n            return attributes;\n        }\n\n        \n        final void appendTagName(String append) {\n            tagName = tagName == null ? append : tagName.concat(append);\n            normalName = tagName.toLowerCase();\n        }\n\n        final void appendTagName(char append) {\n            appendTagName(String.valueOf(append));\n        }\n\n        final void appendAttributeName(String append) {\n            pendingAttributeName = pendingAttributeName == null ? append : pendingAttributeName.concat(append);\n        }\n\n        final void appendAttributeName(char append) {\n            appendAttributeName(String.valueOf(append));\n        }\n\n        final void appendAttributeValue(String append) {\n            ensureAttributeValue();\n            if (pendingAttributeValue.length() == 0) {\n                pendingAttributeValueS = append;\n            } else {\n                pendingAttributeValue.append(append);\n            }\n        }\n\n        final void appendAttributeValue(char append) {\n            ensureAttributeValue();\n            pendingAttributeValue.append(append);\n        }\n\n        final void appendAttributeValue(char[] append) {\n            ensureAttributeValue();\n            pendingAttributeValue.append(append);\n        }\n\n        final void appendAttributeValue(int[] appendCodepoints) {\n            ensureAttributeValue();\n            for (int codepoint : appendCodepoints) {\n                pendingAttributeValue.appendCodePoint(codepoint);\n            }\n        }\n        \n        final void setEmptyAttributeValue() {\n            hasEmptyAttributeValue = true;\n        }\n\n        private void ensureAttributeValue() {\n            hasPendingAttributeValue = true;\n            \n            if (pendingAttributeValueS != null) {\n                pendingAttributeValue.append(pendingAttributeValueS);\n                pendingAttributeValueS = null;\n            }\n        }\n    }\n\n    final static class StartTag extends Tag { StartTag() {\n            super();\n            attributes = new Attributes();\n            type = TokenType.StartTag;\n        }\n\n        @Override\n        Tag reset() {\n            super.reset();\n            attributes = new Attributes();\n            \n            return this;\n        }\n\n        StartTag nameAttr(String name, Attributes attributes) {\n            this.tagName = name;\n            this.attributes = attributes;\n            normalName = tagName.toLowerCase();\n            return this;\n        }\n\n        @Override\n        public String toString() {\n            if (attributes != null && attributes.size() > 0)\n                return \"<\" + name() + \" \" + attributes.toString() + \">\";\n            else\n                return \"<\" + name() + \">\";\n        }\n    }\n\n    final static class EndTag extends Tag{ EndTag() {\n            super();\n            type = TokenType.EndTag;\n        }\n\n        @Override\n        public String toString() {\n            return \"</\" + name() + \">\";\n        }\n    }\n\n    final static class Comment extends Token { final StringBuilder data = new StringBuilder(); boolean bogus = false; @Override Token reset() {\n            reset(data);\n            bogus = false;\n            return this;\n        }\n\n        Comment() {\n            type = TokenType.Comment;\n        }\n\n        String getData() {\n            return data.toString();\n        }\n\n        @Override\n        public String toString() {\n            return \"<!--\" + getData() + \"-->\";\n        }\n    }\n\n    final static class Character extends Token { private String data; Character() {\n            super();\n            type = TokenType.Character;\n        }\n\n        @Override\n        Token reset() {\n            data = null;\n            return this;\n        }\n\n        Character data(String data) {\n            this.data = data;\n            return this;\n        }\n\n        String getData() {\n            return data;\n        }\n\n        @Override\n        public String toString() {\n            return getData();\n        }\n    }\n\n    final static class EOF extends Token { EOF() {\n            type = Token.TokenType.EOF;\n        }\n\n        @Override\n        Token reset() {\n            return this;\n        }\n    }\n\n    final boolean isDoctype() {\n        return type == TokenType.Doctype;\n    }\n\n    final Doctype asDoctype() {\n        return (Doctype) this;\n    }\n\n    final boolean isStartTag() {\n        return type == TokenType.StartTag;\n    }\n\n    final StartTag asStartTag() {\n        return (StartTag) this;\n    }\n\n    final boolean isEndTag() {\n        return type == TokenType.EndTag;\n    }\n\n    final EndTag asEndTag() {\n        return (EndTag) this;\n    }\n\n    final boolean isComment() {\n        return type == TokenType.Comment;\n    }\n\n    final Comment asComment() {\n        return (Comment) this;\n    }\n\n    final boolean isCharacter() {\n        return type == TokenType.Character;\n    }\n\n    final Character asCharacter() {\n        return (Character) this;\n    }\n\n    final boolean isEOF() {\n        return type == TokenType.EOF;\n    }\n\n    enum TokenType {\n        Doctype,\n        StartTag,\n        EndTag,\n        Comment,\n        Character,\n        EOF\n    }\n}\n",
      "buggy_signatures": [
        "abstract class Token { TokenType type; private Token()",
        "abstract Token reset(); static void reset(StringBuilder sb)",
        "public String getSystemIdentifier()",
        "public boolean isForceQuirks()",
        "private void ensureAttributeValue()",
        "static class StartTag extends Tag { StartTag()",
        "public String toString()",
        "static class EndTag extends Tag{ EndTag()",
        "public String toString()",
        "public String toString()",
        "static class Character extends Token { private String data; Character()",
        "public String toString()",
        "static class EOF extends Token { EOF()"
      ],
      "fixed_signatures": [
        "abstract class Token { TokenType type; private Token()",
        "abstract Token reset(); static void reset(StringBuilder sb)",
        "public String getSystemIdentifier()",
        "public boolean isForceQuirks()",
        "private void ensureAttributeValue()",
        "static class StartTag extends Tag { StartTag()",
        "public String toString()",
        "static class EndTag extends Tag{ EndTag()",
        "public String toString()",
        "public String toString()",
        "static class Character extends Token { private String data; Character()",
        "public String toString()",
        "static class EOF extends Token { EOF()"
      ],
      "methods": [
        {
          "buggy_method": "  static void reset(StringBuilder sb) {\n  if (sb != null) {\n  sb.delete(0, sb.length());\n  }\n  }",
          "fixed_method": "  static void reset(StringBuilder sb) {\n  if (sb != null) {\n  sb.delete(0, sb.length());\n  }\n  }",
          "diff": [
            "@@ -32,6 +32,7 @@",
            " \n",
            "     static final class Doctype extends Token {\n",
            "         final StringBuilder name = new StringBuilder();\n",
            "+        String pubSysKey = null;\n",
            "         final StringBuilder publicIdentifier = new StringBuilder();\n",
            "         final StringBuilder systemIdentifier = new StringBuilder();\n",
            "         boolean forceQuirks = false;\n",
            "@@ -43,6 +44,7 @@",
            "         @Override\n",
            "         Token reset() {\n",
            "             reset(name);\n",
            "+            pubSysKey = null;\n",
            "             reset(publicIdentifier);\n",
            "             reset(systemIdentifier);\n",
            "             forceQuirks = false;\n",
            "@@ -53,6 +55,9 @@",
            "             return name.toString();\n",
            "         }\n",
            " \n",
            "+        String getPubSysKey() {\n",
            "+            return pubSysKey;\n",
            "+        }\n",
            " \n",
            "         String getPublicIdentifier() {\n",
            "             return publicIdentifier.toString();\n"
          ],
          "changed_lines": 5
        }
      ]
    },
    {
      "name": "org/jsoup/parser/TokeniserState.java",
      "buggy_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.nodes.DocumentType;\n\nimport java.util.Arrays;\n\n\nenum TokeniserState {\n    Data {\n        \n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '&':\n                    t.advanceTransition(CharacterReferenceInData);\n                    break;\n                case '<':\n                    t.advanceTransition(TagOpen);\n                    break;\n                case nullChar:\n                    t.error(this); \n                    t.emit(r.consume());\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeData();\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    CharacterReferenceInData {\n        \n        void read(Tokeniser t, CharacterReader r) {\n            readCharRef(t, Data);\n        }\n    },\n    Rcdata {\n        \n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '&':\n                    t.advanceTransition(CharacterReferenceInRcdata);\n                    break;\n                case '<':\n                    t.advanceTransition(RcdataLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeToAny('&', '<', nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    CharacterReferenceInRcdata {\n        void read(Tokeniser t, CharacterReader r) {\n            readCharRef(t, Rcdata);\n        }\n    },\n    Rawtext {\n        void read(Tokeniser t, CharacterReader r) {\n            readData(t, r, this, RawtextLessthanSign);\n        }\n    },\n    ScriptData {\n        void read(Tokeniser t, CharacterReader r) {\n            readData(t, r, this, ScriptDataLessthanSign);\n        }\n    },\n    PLAINTEXT {\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeTo(nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    TagOpen {\n        \n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '!':\n                    t.advanceTransition(MarkupDeclarationOpen);\n                    break;\n                case '/':\n                    t.advanceTransition(EndTagOpen);\n                    break;\n                case '?':\n                    t.advanceTransition(BogusComment);\n                    break;\n                default:\n                    if (r.matchesLetter()) {\n                        t.createTagPending(true);\n                        t.transition(TagName);\n                    } else {\n                        t.error(this);\n                        t.emit('<'); \n                        t.transition(Data);\n                    }\n                    break;\n            }\n        }\n    },\n    EndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.emit(\"</\");\n                t.transition(Data);\n            } else if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.transition(TagName);\n            } else if (r.matches('>')) {\n                t.error(this);\n                t.advanceTransition(Data);\n            } else {\n                t.error(this);\n                t.advanceTransition(BogusComment);\n            }\n        }\n    },\n    TagName {\n        \n        void read(Tokeniser t, CharacterReader r) {\n            \n            \n            String tagName = r.consumeTagName();\n            t.tagPending.appendTagName(tagName);\n\n            switch (r.consume()) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar: \n                    t.tagPending.appendTagName(replacementStr);\n                    break;\n                case eof: \n                    t.eofError(this);\n                    t.transition(Data);\n                \n            }\n        }\n    },\n    RcdataLessthanSign {\n        \n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(RCDATAEndTagOpen);\n            } else if (r.matchesLetter() && t.appropriateEndTagName() != null && !r.containsIgnoreCase(\"</\" + t.appropriateEndTagName())) {\n                \n                \n                t.tagPending = t.createTagPending(false).name(t.appropriateEndTagName());\n                t.emitTagPending();\n                r.unconsume(); \n                t.transition(Data);\n            } else {\n                t.emit(\"<\");\n                t.transition(Rcdata);\n            }\n        }\n    },\n    RCDATAEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.tagPending.appendTagName(r.current());\n                t.dataBuffer.append(r.current());\n                t.advanceTransition(RCDATAEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(Rcdata);\n            }\n        }\n    },\n    RCDATAEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.tagPending.appendTagName(name);\n                t.dataBuffer.append(name);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    if (t.isAppropriateEndTagToken())\n                        t.transition(BeforeAttributeName);\n                    else\n                        anythingElse(t, r);\n                    break;\n                case '/':\n                    if (t.isAppropriateEndTagToken())\n                        t.transition(SelfClosingStartTag);\n                    else\n                        anythingElse(t, r);\n                    break;\n                case '>':\n                    if (t.isAppropriateEndTagToken()) {\n                        t.emitTagPending();\n                        t.transition(Data);\n                    }\n                    else\n                        anythingElse(t, r);\n                    break;\n                default:\n                    anythingElse(t, r);\n            }\n        }\n\n        private void anythingElse(Tokeniser t, CharacterReader r) {\n            t.emit(\"</\" + t.dataBuffer.toString());\n            r.unconsume();\n            t.transition(Rcdata);\n        }\n    },\n    RawtextLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(RawtextEndTagOpen);\n            } else {\n                t.emit('<');\n                t.transition(Rawtext);\n            }\n        }\n    },\n    RawtextEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            readEndTag(t, r, RawtextEndTagName, Rawtext);\n        }\n    },\n    RawtextEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataEndTag(t, r, Rawtext);\n        }\n    },\n    ScriptDataLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.consume()) {\n                case '/':\n                    t.createTempBuffer();\n                    t.transition(ScriptDataEndTagOpen);\n                    break;\n                case '!':\n                    t.emit(\"<!\");\n                    t.transition(ScriptDataEscapeStart);\n                    break;\n                default:\n                    t.emit(\"<\");\n                    r.unconsume();\n                    t.transition(ScriptData);\n            }\n        }\n    },\n    ScriptDataEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            readEndTag(t, r, ScriptDataEndTagName, ScriptData);\n        }\n    },\n    ScriptDataEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataEndTag(t, r, ScriptData);\n        }\n    },\n    ScriptDataEscapeStart {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('-')) {\n                t.emit('-');\n                t.advanceTransition(ScriptDataEscapeStartDash);\n            } else {\n                t.transition(ScriptData);\n            }\n        }\n    },\n    ScriptDataEscapeStartDash {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('-')) {\n                t.emit('-');\n                t.advanceTransition(ScriptDataEscapedDashDash);\n            } else {\n                t.transition(ScriptData);\n            }\n        }\n    },\n    ScriptDataEscaped {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            switch (r.current()) {\n                case '-':\n                    t.emit('-');\n                    t.advanceTransition(ScriptDataEscapedDash);\n                    break;\n                case '<':\n                    t.advanceTransition(ScriptDataEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                default:\n                    String data = r.consumeToAny('-', '<', nullChar);\n                    t.emit(data);\n            }\n        }\n    },\n    ScriptDataEscapedDash {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    t.transition(ScriptDataEscapedDashDash);\n                    break;\n                case '<':\n                    t.transition(ScriptDataEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataEscaped);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedDashDash {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    break;\n                case '<':\n                    t.transition(ScriptDataEscapedLessthanSign);\n                    break;\n                case '>':\n                    t.emit(c);\n                    t.transition(ScriptData);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataEscaped);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTempBuffer();\n                t.dataBuffer.append(r.current());\n                t.emit(\"<\" + r.current());\n                t.advanceTransition(ScriptDataDoubleEscapeStart);\n            } else if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(ScriptDataEscapedEndTagOpen);\n            } else {\n                t.emit('<');\n                t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.tagPending.appendTagName(r.current());\n                t.dataBuffer.append(r.current());\n                t.advanceTransition(ScriptDataEscapedEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataEndTag(t, r, ScriptDataEscaped);\n        }\n    },\n    ScriptDataDoubleEscapeStart {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataDoubleEscapeTag(t, r, ScriptDataDoubleEscaped, ScriptDataEscaped);\n        }\n    },\n    ScriptDataDoubleEscaped {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.current();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    t.advanceTransition(ScriptDataDoubleEscapedDash);\n                    break;\n                case '<':\n                    t.emit(c);\n                    t.advanceTransition(ScriptDataDoubleEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    String data = r.consumeToAny('-', '<', nullChar);\n                    t.emit(data);\n            }\n        }\n    },\n    ScriptDataDoubleEscapedDash {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscapedDashDash);\n                    break;\n                case '<':\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataDoubleEscaped);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscaped);\n            }\n        }\n    },\n    ScriptDataDoubleEscapedDashDash {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    break;\n                case '<':\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscapedLessthanSign);\n                    break;\n                case '>':\n                    t.emit(c);\n                    t.transition(ScriptData);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataDoubleEscaped);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscaped);\n            }\n        }\n    },\n    ScriptDataDoubleEscapedLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('/')) {\n                t.emit('/');\n                t.createTempBuffer();\n                t.advanceTransition(ScriptDataDoubleEscapeEnd);\n            } else {\n                t.transition(ScriptDataDoubleEscaped);\n            }\n        }\n    },\n    ScriptDataDoubleEscapeEnd {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataDoubleEscapeTag(t,r, ScriptDataEscaped, ScriptDataDoubleEscaped);\n        }\n    },\n    BeforeAttributeName {\n        \n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break; \n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                case '=':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                default: \n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n            }\n        }\n    },\n    AttributeName {\n        \n        void read(Tokeniser t, CharacterReader r) {\n            String name = r.consumeToAnySorted(attributeNameCharsSorted);\n            t.tagPending.appendAttributeName(name);\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(AfterAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '=':\n                    t.transition(BeforeAttributeValue);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeName(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                    t.error(this);\n                    t.tagPending.appendAttributeName(c);\n                \n            }\n        }\n    },\n    AfterAttributeName {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    \n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '=':\n                    t.transition(BeforeAttributeValue);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeName(replacementChar);\n                    t.transition(AttributeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                default: \n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n            }\n        }\n    },\n    BeforeAttributeValue {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    \n                    break;\n                case '\"':\n                    t.transition(AttributeValue_doubleQuoted);\n                    break;\n                case '&':\n                    r.unconsume();\n                    t.transition(AttributeValue_unquoted);\n                    break;\n                case '\\'':\n                    t.transition(AttributeValue_singleQuoted);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    t.transition(AttributeValue_unquoted);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case '<':\n                case '=':\n                case '`':\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(c);\n                    t.transition(AttributeValue_unquoted);\n                    break;\n                default:\n                    r.unconsume();\n                    t.transition(AttributeValue_unquoted);\n            }\n        }\n    },\n    AttributeValue_doubleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            String value = r.consumeToAny(attributeDoubleValueCharsSorted);\n            if (value.length() > 0)\n                t.tagPending.appendAttributeValue(value);\n            else\n                t.tagPending.setEmptyAttributeValue();\n\n            char c = r.consume();\n            switch (c) {\n                case '\"':\n                    t.transition(AfterAttributeValue_quoted);\n                    break;\n                case '&':\n                    int[] ref = t.consumeCharacterReference('\"', true);\n                    if (ref != null)\n                        t.tagPending.appendAttributeValue(ref);\n                    else\n                        t.tagPending.appendAttributeValue('&');\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                \n            }\n        }\n    },\n    AttributeValue_singleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            String value = r.consumeToAny(attributeSingleValueCharsSorted);\n            if (value.length() > 0)\n                t.tagPending.appendAttributeValue(value);\n            else\n                t.tagPending.setEmptyAttributeValue();\n\n            char c = r.consume();\n            switch (c) {\n                case '\\'':\n                    t.transition(AfterAttributeValue_quoted);\n                    break;\n                case '&':\n                    int[] ref = t.consumeCharacterReference('\\'', true);\n                    if (ref != null)\n                        t.tagPending.appendAttributeValue(ref);\n                    else\n                        t.tagPending.appendAttributeValue('&');\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                \n            }\n        }\n    },\n    AttributeValue_unquoted {\n        void read(Tokeniser t, CharacterReader r) {\n            String value = r.consumeToAnySorted(attributeValueUnquoted);\n            if (value.length() > 0)\n                t.tagPending.appendAttributeValue(value);\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '&':\n                    int[] ref = t.consumeCharacterReference('>', true);\n                    if (ref != null)\n                        t.tagPending.appendAttributeValue(ref);\n                    else\n                        t.tagPending.appendAttributeValue('&');\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                case '=':\n                case '`':\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(c);\n                    break;\n                \n            }\n\n        }\n    },\n    \n    AfterAttributeValue_quoted {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    r.unconsume();\n                    t.transition(BeforeAttributeName);\n            }\n\n        }\n    },\n    SelfClosingStartTag {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.tagPending.selfClosing = true;\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    r.unconsume();\n                    t.transition(BeforeAttributeName);\n            }\n        }\n    },\n    BogusComment {\n        void read(Tokeniser t, CharacterReader r) {\n            \n            \n            r.unconsume();\n            Token.Comment comment = new Token.Comment();\n            comment.bogus = true;\n            comment.data.append(r.consumeTo('>'));\n            \n            t.emit(comment);\n            t.advanceTransition(Data);\n        }\n    },\n    MarkupDeclarationOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchConsume(\"--\")) {\n                t.createCommentPending();\n                t.transition(CommentStart);\n            } else if (r.matchConsumeIgnoreCase(\"DOCTYPE\")) {\n                t.transition(Doctype);\n            } else if (r.matchConsume(\"[CDATA[\")) {\n                \n                \n                \n                t.transition(CdataSection);\n            } else {\n                t.error(this);\n                t.advanceTransition(BogusComment); \n            }\n        }\n    },\n    CommentStart {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.transition(CommentStartDash);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append(c);\n                    t.transition(Comment);\n            }\n        }\n    },\n    CommentStartDash {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.transition(CommentStartDash);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append(c);\n                    t.transition(Comment);\n            }\n        }\n    },\n    Comment {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.current();\n            switch (c) {\n                case '-':\n                    t.advanceTransition(CommentEndDash);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.commentPending.data.append(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append(r.consumeToAny('-', nullChar));\n            }\n        }\n    },\n    CommentEndDash {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.transition(CommentEnd);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append('-').append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append('-').append(c);\n                    t.transition(Comment);\n            }\n        }\n    },\n    CommentEnd {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append(\"--\").append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case '!':\n                    t.error(this);\n                    t.transition(CommentEndBang);\n                    break;\n                case '-':\n                    t.error(this);\n                    t.commentPending.data.append('-');\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.commentPending.data.append(\"--\").append(c);\n                    t.transition(Comment);\n            }\n        }\n    },\n    CommentEndBang {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.commentPending.data.append(\"--!\");\n                    t.transition(CommentEndDash);\n                    break;\n                case '>':\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append(\"--!\").append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append(\"--!\").append(c);\n                    t.transition(Comment);\n            }\n        }\n    },\n    Doctype {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeDoctypeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    \n                case '>': \n                    t.error(this);\n                    t.createDoctypePending();\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.transition(BeforeDoctypeName);\n            }\n        }\n    },\n    BeforeDoctypeName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createDoctypePending();\n                t.transition(DoctypeName);\n                return;\n            }\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break; \n                case nullChar:\n                    t.error(this);\n                    t.createDoctypePending();\n                    t.doctypePending.name.append(replacementChar);\n                    t.transition(DoctypeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.createDoctypePending();\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.createDoctypePending();\n                    t.doctypePending.name.append(c);\n                    t.transition(DoctypeName);\n            }\n        }\n    },\n    DoctypeName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.doctypePending.name.append(name);\n                return;\n            }\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(AfterDoctypeName);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.name.append(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.name.append(c);\n            }\n        }\n    },\n    AfterDoctypeName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.doctypePending.forceQuirks = true;\n                t.emitDoctypePending();\n                t.transition(Data);\n                return;\n            }\n            if (r.matchesAny('\\t', '\\n', '\\r', '\\f', ' '))\n                r.advance(); \n            else if (r.matches('>')) {\n                t.emitDoctypePending();\n                t.advanceTransition(Data);\n            } else if (r.matchConsumeIgnoreCase(DocumentType.PUBLIC_KEY)) {\n                t.transition(AfterDoctypePublicKeyword);\n            } else if (r.matchConsumeIgnoreCase(DocumentType.SYSTEM_KEY)) {\n                t.transition(AfterDoctypeSystemKeyword);\n            } else {\n                t.error(this);\n                t.doctypePending.forceQuirks = true;\n                t.advanceTransition(BogusDoctype);\n            }\n\n        }\n    },\n    AfterDoctypePublicKeyword {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeDoctypePublicIdentifier);\n                    break;\n                case '\"':\n                    t.error(this);\n                    \n                    t.transition(DoctypePublicIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    t.error(this);\n                    \n                    t.transition(DoctypePublicIdentifier_singleQuoted);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }\n    },\n    BeforeDoctypePublicIdentifier {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break;\n                case '\"':\n                    \n                    t.transition(DoctypePublicIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    \n                    t.transition(DoctypePublicIdentifier_singleQuoted);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }\n    },\n    DoctypePublicIdentifier_doubleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\"':\n                    t.transition(AfterDoctypePublicIdentifier);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.publicIdentifier.append(replacementChar);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.publicIdentifier.append(c);\n            }\n        }\n    },\n    DoctypePublicIdentifier_singleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\'':\n                    t.transition(AfterDoctypePublicIdentifier);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.publicIdentifier.append(replacementChar);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.publicIdentifier.append(c);\n            }\n        }\n    },\n    AfterDoctypePublicIdentifier {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BetweenDoctypePublicAndSystemIdentifiers);\n                    break;\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case '\"':\n                    t.error(this);\n                    \n                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    t.error(this);\n                    \n                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }\n    },\n    BetweenDoctypePublicAndSystemIdentifiers {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break;\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case '\"':\n                    t.error(this);\n                    \n                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    t.error(this);\n                    \n                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }\n    },\n    AfterDoctypeSystemKeyword {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeDoctypeSystemIdentifier);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case '\"':\n                    t.error(this);\n                    \n                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    t.error(this);\n                    \n                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n            }\n        }\n    },\n    BeforeDoctypeSystemIdentifier {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break;\n                case '\"':\n                    \n                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    \n                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }\n    },\n    DoctypeSystemIdentifier_doubleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\"':\n                    t.transition(AfterDoctypeSystemIdentifier);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.systemIdentifier.append(replacementChar);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.systemIdentifier.append(c);\n            }\n        }\n    },\n    DoctypeSystemIdentifier_singleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\'':\n                    t.transition(AfterDoctypeSystemIdentifier);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.systemIdentifier.append(replacementChar);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.systemIdentifier.append(c);\n            }\n        }\n    },\n    AfterDoctypeSystemIdentifier {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break;\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.transition(BogusDoctype);\n                    \n            }\n        }\n    },\n    BogusDoctype {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    \n                    break;\n            }\n        }\n    },\n    CdataSection {\n        void read(Tokeniser t, CharacterReader r) {\n            String data = r.consumeTo(\"]]>\");\n            t.emit(data);\n            r.matchConsume(\"]]>\");\n            t.transition(Data);\n        }\n    };\n\n\n    abstract void read(Tokeniser t, CharacterReader r); static final char nullChar = '\\u0000'; private static final char[] attributeSingleValueCharsSorted = new char[] {'\\'', '&', nullChar};\n    private static final char[] attributeDoubleValueCharsSorted = new char[]{'\"', '&', nullChar}; private static final char[] attributeNameCharsSorted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '/', '=', '>', nullChar, '\"', '\\'', '<'}; private static final char[] attributeValueUnquoted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '&', '>', nullChar, '\"', '\\'', '<', '=', '`'}; private static final char replacementChar = Tokeniser.replacementChar; private static final String replacementStr = String.valueOf(Tokeniser.replacementChar); private static final char eof = CharacterReader.EOF; static {\n        Arrays.sort(attributeSingleValueCharsSorted);\n        Arrays.sort(attributeDoubleValueCharsSorted);\n        Arrays.sort(attributeNameCharsSorted);\n        Arrays.sort(attributeValueUnquoted);\n    }\n\n    \n    private static void handleDataEndTag(Tokeniser t, CharacterReader r, TokeniserState elseTransition) {\n        if (r.matchesLetter()) {\n            String name = r.consumeLetterSequence();\n            t.tagPending.appendTagName(name);\n            t.dataBuffer.append(name);\n            return;\n        }\n\n        boolean needsExitTransition = false;\n        if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.dataBuffer.append(c);\n                    needsExitTransition = true;\n            }\n        } else {\n            needsExitTransition = true;\n        }\n\n        if (needsExitTransition) {\n            t.emit(\"</\" + t.dataBuffer.toString());\n            t.transition(elseTransition);\n        }\n    }\n\n    private static void readData(Tokeniser t, CharacterReader r, TokeniserState current, TokeniserState advance) {\n        switch (r.current()) {\n            case '<':\n                t.advanceTransition(advance);\n                break;\n            case nullChar:\n                t.error(current);\n                r.advance();\n                t.emit(replacementChar);\n                break;\n            case eof:\n                t.emit(new Token.EOF());\n                break;\n            default:\n                String data = r.consumeToAny('<', nullChar);\n                t.emit(data);\n                break;\n        }\n    }\n\n    private static void readCharRef(Tokeniser t, TokeniserState advance) {\n        int[] c = t.consumeCharacterReference(null, false);\n        if (c == null)\n            t.emit('&');\n        else\n            t.emit(c);\n        t.transition(advance);\n    }\n\n    private static void readEndTag(Tokeniser t, CharacterReader r, TokeniserState a, TokeniserState b) {\n        if (r.matchesLetter()) {\n            t.createTagPending(false);\n            t.transition(a);\n        } else {\n            t.emit(\"</\");\n            t.transition(b);\n        }\n    }\n\n    private static void handleDataDoubleEscapeTag(Tokeniser t, CharacterReader r, TokeniserState primary, TokeniserState fallback) {\n        if (r.matchesLetter()) {\n            String name = r.consumeLetterSequence();\n            t.dataBuffer.append(name);\n            t.emit(name);\n            return;\n        }\n\n        char c = r.consume();\n        switch (c) {\n            case '\\t':\n            case '\\n':\n            case '\\r':\n            case '\\f':\n            case ' ':\n            case '/':\n            case '>':\n                if (t.dataBuffer.toString().equals(\"script\"))\n                    t.transition(primary);\n                else\n                    t.transition(fallback);\n                t.emit(c);\n                break;\n            default:\n                r.unconsume();\n                t.transition(fallback);\n        }\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.nodes.DocumentType;\n\nimport java.util.Arrays;\n\n\nenum TokeniserState {\n    Data {\n        \n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '&':\n                    t.advanceTransition(CharacterReferenceInData);\n                    break;\n                case '<':\n                    t.advanceTransition(TagOpen);\n                    break;\n                case nullChar:\n                    t.error(this); \n                    t.emit(r.consume());\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeData();\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    CharacterReferenceInData {\n        \n        void read(Tokeniser t, CharacterReader r) {\n            readCharRef(t, Data);\n        }\n    },\n    Rcdata {\n        \n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '&':\n                    t.advanceTransition(CharacterReferenceInRcdata);\n                    break;\n                case '<':\n                    t.advanceTransition(RcdataLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeToAny('&', '<', nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    CharacterReferenceInRcdata {\n        void read(Tokeniser t, CharacterReader r) {\n            readCharRef(t, Rcdata);\n        }\n    },\n    Rawtext {\n        void read(Tokeniser t, CharacterReader r) {\n            readData(t, r, this, RawtextLessthanSign);\n        }\n    },\n    ScriptData {\n        void read(Tokeniser t, CharacterReader r) {\n            readData(t, r, this, ScriptDataLessthanSign);\n        }\n    },\n    PLAINTEXT {\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeTo(nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    TagOpen {\n        \n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '!':\n                    t.advanceTransition(MarkupDeclarationOpen);\n                    break;\n                case '/':\n                    t.advanceTransition(EndTagOpen);\n                    break;\n                case '?':\n                    t.advanceTransition(BogusComment);\n                    break;\n                default:\n                    if (r.matchesLetter()) {\n                        t.createTagPending(true);\n                        t.transition(TagName);\n                    } else {\n                        t.error(this);\n                        t.emit('<'); \n                        t.transition(Data);\n                    }\n                    break;\n            }\n        }\n    },\n    EndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.emit(\"</\");\n                t.transition(Data);\n            } else if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.transition(TagName);\n            } else if (r.matches('>')) {\n                t.error(this);\n                t.advanceTransition(Data);\n            } else {\n                t.error(this);\n                t.advanceTransition(BogusComment);\n            }\n        }\n    },\n    TagName {\n        \n        void read(Tokeniser t, CharacterReader r) {\n            \n            \n            String tagName = r.consumeTagName();\n            t.tagPending.appendTagName(tagName);\n\n            switch (r.consume()) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar: \n                    t.tagPending.appendTagName(replacementStr);\n                    break;\n                case eof: \n                    t.eofError(this);\n                    t.transition(Data);\n                \n            }\n        }\n    },\n    RcdataLessthanSign {\n        \n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(RCDATAEndTagOpen);\n            } else if (r.matchesLetter() && t.appropriateEndTagName() != null && !r.containsIgnoreCase(\"</\" + t.appropriateEndTagName())) {\n                \n                \n                t.tagPending = t.createTagPending(false).name(t.appropriateEndTagName());\n                t.emitTagPending();\n                r.unconsume(); \n                t.transition(Data);\n            } else {\n                t.emit(\"<\");\n                t.transition(Rcdata);\n            }\n        }\n    },\n    RCDATAEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.tagPending.appendTagName(r.current());\n                t.dataBuffer.append(r.current());\n                t.advanceTransition(RCDATAEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(Rcdata);\n            }\n        }\n    },\n    RCDATAEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.tagPending.appendTagName(name);\n                t.dataBuffer.append(name);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    if (t.isAppropriateEndTagToken())\n                        t.transition(BeforeAttributeName);\n                    else\n                        anythingElse(t, r);\n                    break;\n                case '/':\n                    if (t.isAppropriateEndTagToken())\n                        t.transition(SelfClosingStartTag);\n                    else\n                        anythingElse(t, r);\n                    break;\n                case '>':\n                    if (t.isAppropriateEndTagToken()) {\n                        t.emitTagPending();\n                        t.transition(Data);\n                    }\n                    else\n                        anythingElse(t, r);\n                    break;\n                default:\n                    anythingElse(t, r);\n            }\n        }\n\n        private void anythingElse(Tokeniser t, CharacterReader r) {\n            t.emit(\"</\" + t.dataBuffer.toString());\n            r.unconsume();\n            t.transition(Rcdata);\n        }\n    },\n    RawtextLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(RawtextEndTagOpen);\n            } else {\n                t.emit('<');\n                t.transition(Rawtext);\n            }\n        }\n    },\n    RawtextEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            readEndTag(t, r, RawtextEndTagName, Rawtext);\n        }\n    },\n    RawtextEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataEndTag(t, r, Rawtext);\n        }\n    },\n    ScriptDataLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.consume()) {\n                case '/':\n                    t.createTempBuffer();\n                    t.transition(ScriptDataEndTagOpen);\n                    break;\n                case '!':\n                    t.emit(\"<!\");\n                    t.transition(ScriptDataEscapeStart);\n                    break;\n                default:\n                    t.emit(\"<\");\n                    r.unconsume();\n                    t.transition(ScriptData);\n            }\n        }\n    },\n    ScriptDataEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            readEndTag(t, r, ScriptDataEndTagName, ScriptData);\n        }\n    },\n    ScriptDataEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataEndTag(t, r, ScriptData);\n        }\n    },\n    ScriptDataEscapeStart {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('-')) {\n                t.emit('-');\n                t.advanceTransition(ScriptDataEscapeStartDash);\n            } else {\n                t.transition(ScriptData);\n            }\n        }\n    },\n    ScriptDataEscapeStartDash {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('-')) {\n                t.emit('-');\n                t.advanceTransition(ScriptDataEscapedDashDash);\n            } else {\n                t.transition(ScriptData);\n            }\n        }\n    },\n    ScriptDataEscaped {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            switch (r.current()) {\n                case '-':\n                    t.emit('-');\n                    t.advanceTransition(ScriptDataEscapedDash);\n                    break;\n                case '<':\n                    t.advanceTransition(ScriptDataEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                default:\n                    String data = r.consumeToAny('-', '<', nullChar);\n                    t.emit(data);\n            }\n        }\n    },\n    ScriptDataEscapedDash {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    t.transition(ScriptDataEscapedDashDash);\n                    break;\n                case '<':\n                    t.transition(ScriptDataEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataEscaped);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedDashDash {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    break;\n                case '<':\n                    t.transition(ScriptDataEscapedLessthanSign);\n                    break;\n                case '>':\n                    t.emit(c);\n                    t.transition(ScriptData);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataEscaped);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTempBuffer();\n                t.dataBuffer.append(r.current());\n                t.emit(\"<\" + r.current());\n                t.advanceTransition(ScriptDataDoubleEscapeStart);\n            } else if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(ScriptDataEscapedEndTagOpen);\n            } else {\n                t.emit('<');\n                t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.tagPending.appendTagName(r.current());\n                t.dataBuffer.append(r.current());\n                t.advanceTransition(ScriptDataEscapedEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataEndTag(t, r, ScriptDataEscaped);\n        }\n    },\n    ScriptDataDoubleEscapeStart {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataDoubleEscapeTag(t, r, ScriptDataDoubleEscaped, ScriptDataEscaped);\n        }\n    },\n    ScriptDataDoubleEscaped {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.current();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    t.advanceTransition(ScriptDataDoubleEscapedDash);\n                    break;\n                case '<':\n                    t.emit(c);\n                    t.advanceTransition(ScriptDataDoubleEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    String data = r.consumeToAny('-', '<', nullChar);\n                    t.emit(data);\n            }\n        }\n    },\n    ScriptDataDoubleEscapedDash {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscapedDashDash);\n                    break;\n                case '<':\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataDoubleEscaped);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscaped);\n            }\n        }\n    },\n    ScriptDataDoubleEscapedDashDash {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    break;\n                case '<':\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscapedLessthanSign);\n                    break;\n                case '>':\n                    t.emit(c);\n                    t.transition(ScriptData);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataDoubleEscaped);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscaped);\n            }\n        }\n    },\n    ScriptDataDoubleEscapedLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('/')) {\n                t.emit('/');\n                t.createTempBuffer();\n                t.advanceTransition(ScriptDataDoubleEscapeEnd);\n            } else {\n                t.transition(ScriptDataDoubleEscaped);\n            }\n        }\n    },\n    ScriptDataDoubleEscapeEnd {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataDoubleEscapeTag(t,r, ScriptDataEscaped, ScriptDataDoubleEscaped);\n        }\n    },\n    BeforeAttributeName {\n        \n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break; \n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                case '=':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                default: \n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n            }\n        }\n    },\n    AttributeName {\n        \n        void read(Tokeniser t, CharacterReader r) {\n            String name = r.consumeToAnySorted(attributeNameCharsSorted);\n            t.tagPending.appendAttributeName(name);\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(AfterAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '=':\n                    t.transition(BeforeAttributeValue);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeName(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                    t.error(this);\n                    t.tagPending.appendAttributeName(c);\n                \n            }\n        }\n    },\n    AfterAttributeName {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    \n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '=':\n                    t.transition(BeforeAttributeValue);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeName(replacementChar);\n                    t.transition(AttributeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                default: \n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n            }\n        }\n    },\n    BeforeAttributeValue {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    \n                    break;\n                case '\"':\n                    t.transition(AttributeValue_doubleQuoted);\n                    break;\n                case '&':\n                    r.unconsume();\n                    t.transition(AttributeValue_unquoted);\n                    break;\n                case '\\'':\n                    t.transition(AttributeValue_singleQuoted);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    t.transition(AttributeValue_unquoted);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case '<':\n                case '=':\n                case '`':\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(c);\n                    t.transition(AttributeValue_unquoted);\n                    break;\n                default:\n                    r.unconsume();\n                    t.transition(AttributeValue_unquoted);\n            }\n        }\n    },\n    AttributeValue_doubleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            String value = r.consumeToAny(attributeDoubleValueCharsSorted);\n            if (value.length() > 0)\n                t.tagPending.appendAttributeValue(value);\n            else\n                t.tagPending.setEmptyAttributeValue();\n\n            char c = r.consume();\n            switch (c) {\n                case '\"':\n                    t.transition(AfterAttributeValue_quoted);\n                    break;\n                case '&':\n                    int[] ref = t.consumeCharacterReference('\"', true);\n                    if (ref != null)\n                        t.tagPending.appendAttributeValue(ref);\n                    else\n                        t.tagPending.appendAttributeValue('&');\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                \n            }\n        }\n    },\n    AttributeValue_singleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            String value = r.consumeToAny(attributeSingleValueCharsSorted);\n            if (value.length() > 0)\n                t.tagPending.appendAttributeValue(value);\n            else\n                t.tagPending.setEmptyAttributeValue();\n\n            char c = r.consume();\n            switch (c) {\n                case '\\'':\n                    t.transition(AfterAttributeValue_quoted);\n                    break;\n                case '&':\n                    int[] ref = t.consumeCharacterReference('\\'', true);\n                    if (ref != null)\n                        t.tagPending.appendAttributeValue(ref);\n                    else\n                        t.tagPending.appendAttributeValue('&');\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                \n            }\n        }\n    },\n    AttributeValue_unquoted {\n        void read(Tokeniser t, CharacterReader r) {\n            String value = r.consumeToAnySorted(attributeValueUnquoted);\n            if (value.length() > 0)\n                t.tagPending.appendAttributeValue(value);\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '&':\n                    int[] ref = t.consumeCharacterReference('>', true);\n                    if (ref != null)\n                        t.tagPending.appendAttributeValue(ref);\n                    else\n                        t.tagPending.appendAttributeValue('&');\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                case '=':\n                case '`':\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(c);\n                    break;\n                \n            }\n\n        }\n    },\n    \n    AfterAttributeValue_quoted {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    r.unconsume();\n                    t.transition(BeforeAttributeName);\n            }\n\n        }\n    },\n    SelfClosingStartTag {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.tagPending.selfClosing = true;\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    r.unconsume();\n                    t.transition(BeforeAttributeName);\n            }\n        }\n    },\n    BogusComment {\n        void read(Tokeniser t, CharacterReader r) {\n            \n            \n            r.unconsume();\n            Token.Comment comment = new Token.Comment();\n            comment.bogus = true;\n            comment.data.append(r.consumeTo('>'));\n            \n            t.emit(comment);\n            t.advanceTransition(Data);\n        }\n    },\n    MarkupDeclarationOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchConsume(\"--\")) {\n                t.createCommentPending();\n                t.transition(CommentStart);\n            } else if (r.matchConsumeIgnoreCase(\"DOCTYPE\")) {\n                t.transition(Doctype);\n            } else if (r.matchConsume(\"[CDATA[\")) {\n                \n                \n                \n                t.transition(CdataSection);\n            } else {\n                t.error(this);\n                t.advanceTransition(BogusComment); \n            }\n        }\n    },\n    CommentStart {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.transition(CommentStartDash);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append(c);\n                    t.transition(Comment);\n            }\n        }\n    },\n    CommentStartDash {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.transition(CommentStartDash);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append(c);\n                    t.transition(Comment);\n            }\n        }\n    },\n    Comment {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.current();\n            switch (c) {\n                case '-':\n                    t.advanceTransition(CommentEndDash);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.commentPending.data.append(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append(r.consumeToAny('-', nullChar));\n            }\n        }\n    },\n    CommentEndDash {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.transition(CommentEnd);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append('-').append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append('-').append(c);\n                    t.transition(Comment);\n            }\n        }\n    },\n    CommentEnd {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append(\"--\").append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case '!':\n                    t.error(this);\n                    t.transition(CommentEndBang);\n                    break;\n                case '-':\n                    t.error(this);\n                    t.commentPending.data.append('-');\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.commentPending.data.append(\"--\").append(c);\n                    t.transition(Comment);\n            }\n        }\n    },\n    CommentEndBang {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.commentPending.data.append(\"--!\");\n                    t.transition(CommentEndDash);\n                    break;\n                case '>':\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append(\"--!\").append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append(\"--!\").append(c);\n                    t.transition(Comment);\n            }\n        }\n    },\n    Doctype {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeDoctypeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    \n                case '>': \n                    t.error(this);\n                    t.createDoctypePending();\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.transition(BeforeDoctypeName);\n            }\n        }\n    },\n    BeforeDoctypeName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createDoctypePending();\n                t.transition(DoctypeName);\n                return;\n            }\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break; \n                case nullChar:\n                    t.error(this);\n                    t.createDoctypePending();\n                    t.doctypePending.name.append(replacementChar);\n                    t.transition(DoctypeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.createDoctypePending();\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.createDoctypePending();\n                    t.doctypePending.name.append(c);\n                    t.transition(DoctypeName);\n            }\n        }\n    },\n    DoctypeName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.doctypePending.name.append(name);\n                return;\n            }\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(AfterDoctypeName);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.name.append(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.name.append(c);\n            }\n        }\n    },\n    AfterDoctypeName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.doctypePending.forceQuirks = true;\n                t.emitDoctypePending();\n                t.transition(Data);\n                return;\n            }\n            if (r.matchesAny('\\t', '\\n', '\\r', '\\f', ' '))\n                r.advance(); \n            else if (r.matches('>')) {\n                t.emitDoctypePending();\n                t.advanceTransition(Data);\n            } else if (r.matchConsumeIgnoreCase(DocumentType.PUBLIC_KEY)) {\n                t.doctypePending.pubSysKey = DocumentType.PUBLIC_KEY;\n                t.transition(AfterDoctypePublicKeyword);\n            } else if (r.matchConsumeIgnoreCase(DocumentType.SYSTEM_KEY)) {\n                t.doctypePending.pubSysKey = DocumentType.SYSTEM_KEY;\n                t.transition(AfterDoctypeSystemKeyword);\n            } else {\n                t.error(this);\n                t.doctypePending.forceQuirks = true;\n                t.advanceTransition(BogusDoctype);\n            }\n\n        }\n    },\n    AfterDoctypePublicKeyword {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeDoctypePublicIdentifier);\n                    break;\n                case '\"':\n                    t.error(this);\n                    \n                    t.transition(DoctypePublicIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    t.error(this);\n                    \n                    t.transition(DoctypePublicIdentifier_singleQuoted);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }\n    },\n    BeforeDoctypePublicIdentifier {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break;\n                case '\"':\n                    \n                    t.transition(DoctypePublicIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    \n                    t.transition(DoctypePublicIdentifier_singleQuoted);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }\n    },\n    DoctypePublicIdentifier_doubleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\"':\n                    t.transition(AfterDoctypePublicIdentifier);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.publicIdentifier.append(replacementChar);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.publicIdentifier.append(c);\n            }\n        }\n    },\n    DoctypePublicIdentifier_singleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\'':\n                    t.transition(AfterDoctypePublicIdentifier);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.publicIdentifier.append(replacementChar);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.publicIdentifier.append(c);\n            }\n        }\n    },\n    AfterDoctypePublicIdentifier {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BetweenDoctypePublicAndSystemIdentifiers);\n                    break;\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case '\"':\n                    t.error(this);\n                    \n                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    t.error(this);\n                    \n                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }\n    },\n    BetweenDoctypePublicAndSystemIdentifiers {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break;\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case '\"':\n                    t.error(this);\n                    \n                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    t.error(this);\n                    \n                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }\n    },\n    AfterDoctypeSystemKeyword {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeDoctypeSystemIdentifier);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case '\"':\n                    t.error(this);\n                    \n                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    t.error(this);\n                    \n                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n            }\n        }\n    },\n    BeforeDoctypeSystemIdentifier {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break;\n                case '\"':\n                    \n                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    \n                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }\n    },\n    DoctypeSystemIdentifier_doubleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\"':\n                    t.transition(AfterDoctypeSystemIdentifier);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.systemIdentifier.append(replacementChar);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.systemIdentifier.append(c);\n            }\n        }\n    },\n    DoctypeSystemIdentifier_singleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\'':\n                    t.transition(AfterDoctypeSystemIdentifier);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.systemIdentifier.append(replacementChar);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.systemIdentifier.append(c);\n            }\n        }\n    },\n    AfterDoctypeSystemIdentifier {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break;\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.transition(BogusDoctype);\n                    \n            }\n        }\n    },\n    BogusDoctype {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    \n                    break;\n            }\n        }\n    },\n    CdataSection {\n        void read(Tokeniser t, CharacterReader r) {\n            String data = r.consumeTo(\"]]>\");\n            t.emit(data);\n            r.matchConsume(\"]]>\");\n            t.transition(Data);\n        }\n    };\n\n\n    abstract void read(Tokeniser t, CharacterReader r); static final char nullChar = '\\u0000'; private static final char[] attributeSingleValueCharsSorted = new char[] {'\\'', '&', nullChar};\n    private static final char[] attributeDoubleValueCharsSorted = new char[]{'\"', '&', nullChar}; private static final char[] attributeNameCharsSorted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '/', '=', '>', nullChar, '\"', '\\'', '<'}; private static final char[] attributeValueUnquoted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '&', '>', nullChar, '\"', '\\'', '<', '=', '`'}; private static final char replacementChar = Tokeniser.replacementChar; private static final String replacementStr = String.valueOf(Tokeniser.replacementChar); private static final char eof = CharacterReader.EOF; static {\n        Arrays.sort(attributeSingleValueCharsSorted);\n        Arrays.sort(attributeDoubleValueCharsSorted);\n        Arrays.sort(attributeNameCharsSorted);\n        Arrays.sort(attributeValueUnquoted);\n    }\n\n    \n    private static void handleDataEndTag(Tokeniser t, CharacterReader r, TokeniserState elseTransition) {\n        if (r.matchesLetter()) {\n            String name = r.consumeLetterSequence();\n            t.tagPending.appendTagName(name);\n            t.dataBuffer.append(name);\n            return;\n        }\n\n        boolean needsExitTransition = false;\n        if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.dataBuffer.append(c);\n                    needsExitTransition = true;\n            }\n        } else {\n            needsExitTransition = true;\n        }\n\n        if (needsExitTransition) {\n            t.emit(\"</\" + t.dataBuffer.toString());\n            t.transition(elseTransition);\n        }\n    }\n\n    private static void readData(Tokeniser t, CharacterReader r, TokeniserState current, TokeniserState advance) {\n        switch (r.current()) {\n            case '<':\n                t.advanceTransition(advance);\n                break;\n            case nullChar:\n                t.error(current);\n                r.advance();\n                t.emit(replacementChar);\n                break;\n            case eof:\n                t.emit(new Token.EOF());\n                break;\n            default:\n                String data = r.consumeToAny('<', nullChar);\n                t.emit(data);\n                break;\n        }\n    }\n\n    private static void readCharRef(Tokeniser t, TokeniserState advance) {\n        int[] c = t.consumeCharacterReference(null, false);\n        if (c == null)\n            t.emit('&');\n        else\n            t.emit(c);\n        t.transition(advance);\n    }\n\n    private static void readEndTag(Tokeniser t, CharacterReader r, TokeniserState a, TokeniserState b) {\n        if (r.matchesLetter()) {\n            t.createTagPending(false);\n            t.transition(a);\n        } else {\n            t.emit(\"</\");\n            t.transition(b);\n        }\n    }\n\n    private static void handleDataDoubleEscapeTag(Tokeniser t, CharacterReader r, TokeniserState primary, TokeniserState fallback) {\n        if (r.matchesLetter()) {\n            String name = r.consumeLetterSequence();\n            t.dataBuffer.append(name);\n            t.emit(name);\n            return;\n        }\n\n        char c = r.consume();\n        switch (c) {\n            case '\\t':\n            case '\\n':\n            case '\\r':\n            case '\\f':\n            case ' ':\n            case '/':\n            case '>':\n                if (t.dataBuffer.toString().equals(\"script\"))\n                    t.transition(primary);\n                else\n                    t.transition(fallback);\n                t.emit(c);\n                break;\n            default:\n                r.unconsume();\n                t.transition(fallback);\n        }\n    }\n}\n",
      "buggy_signatures": [
        "private void anythingElse(Tokeniser t, CharacterReader r)",
        "abstract void read(Tokeniser t, CharacterReader r); static final char nullChar = '\\u0000'; private static final char[] attributeSingleValueCharsSorted = new char[]",
        "private static void handleDataEndTag(Tokeniser t, CharacterReader r, TokeniserState elseTransition)",
        "private static void readData(Tokeniser t, CharacterReader r, TokeniserState current, TokeniserState advance)",
        "private static void readCharRef(Tokeniser t, TokeniserState advance)",
        "private static void readEndTag(Tokeniser t, CharacterReader r, TokeniserState a, TokeniserState b)",
        "private static void handleDataDoubleEscapeTag(Tokeniser t, CharacterReader r, TokeniserState primary, TokeniserState fallback)"
      ],
      "fixed_signatures": [
        "private void anythingElse(Tokeniser t, CharacterReader r)",
        "abstract void read(Tokeniser t, CharacterReader r); static final char nullChar = '\\u0000'; private static final char[] attributeSingleValueCharsSorted = new char[]",
        "private static void handleDataEndTag(Tokeniser t, CharacterReader r, TokeniserState elseTransition)",
        "private static void readData(Tokeniser t, CharacterReader r, TokeniserState current, TokeniserState advance)",
        "private static void readCharRef(Tokeniser t, TokeniserState advance)",
        "private static void readEndTag(Tokeniser t, CharacterReader r, TokeniserState a, TokeniserState b)",
        "private static void handleDataDoubleEscapeTag(Tokeniser t, CharacterReader r, TokeniserState primary, TokeniserState fallback)"
      ],
      "methods": [
        {
          "buggy_method": "  private void anythingElse(Tokeniser t, CharacterReader r) {\n  t.emit(\"</\" + t.dataBuffer.toString());\n  r.unconsume();\n  t.transition(Rcdata);\n  }",
          "fixed_method": "  private void anythingElse(Tokeniser t, CharacterReader r) {\n  t.emit(\"</\" + t.dataBuffer.toString());\n  r.unconsume();\n  t.transition(Rcdata);\n  }",
          "diff": [
            "@@ -1192,8 +1192,10 @@",
            "                 t.emitDoctypePending();\n",
            "                 t.advanceTransition(Data);\n",
            "             } else if (r.matchConsumeIgnoreCase(DocumentType.PUBLIC_KEY)) {\n",
            "+                t.doctypePending.pubSysKey = DocumentType.PUBLIC_KEY;\n",
            "                 t.transition(AfterDoctypePublicKeyword);\n",
            "             } else if (r.matchConsumeIgnoreCase(DocumentType.SYSTEM_KEY)) {\n",
            "+                t.doctypePending.pubSysKey = DocumentType.SYSTEM_KEY;\n",
            "                 t.transition(AfterDoctypeSystemKeyword);\n",
            "             } else {\n",
            "                 t.error(this);\n"
          ],
          "changed_lines": 2
        }
      ]
    },
    {
      "name": "org/jsoup/parser/XmlTreeBuilder.java",
      "buggy_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.Jsoup;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.*;\n\nimport java.util.List;\n\n\npublic class XmlTreeBuilder extends TreeBuilder { ParseSettings defaultSettings() {\n        return ParseSettings.preserveCase;\n    }\n\n    Document parse(String input, String baseUri) {\n        return parse(input, baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);\n    }\n\n    @Override\n    protected void initialiseParse(String input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        super.initialiseParse(input, baseUri, errors, settings);\n        stack.add(doc); \n        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        \n        switch (token.type) {\n            case StartTag:\n                insert(token.asStartTag());\n                break;\n            case EndTag:\n                popStackToClose(token.asEndTag());\n                break;\n            case Comment:\n                insert(token.asComment());\n                break;\n            case Character:\n                insert(token.asCharacter());\n                break;\n            case Doctype:\n                insert(token.asDoctype());\n                break;\n            case EOF: \n                break;\n            default:\n                Validate.fail(\"Unexpected token type: \" + token.type);\n        }\n        return true;\n    }\n\n    private void insertNode(Node node) {\n        currentElement().appendChild(node);\n    }\n\n    Element insert(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        \n        Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes));\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            tokeniser.acknowledgeSelfClosingFlag();\n            if (!tag.isKnownTag()) \n                tag.setSelfClosing();\n        } else {\n            stack.add(el);\n        }\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData(), baseUri);\n        Node insert = comment;\n        if (commentToken.bogus) { \n            \n            String data = comment.getData();\n            if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n                Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n                Element el = doc.child(0);\n                insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), comment.baseUri(), data.startsWith(\"!\"));\n                insert.attributes().addAll(el.attributes());\n            }\n        }\n        insertNode(insert);\n    }\n\n    void insert(Token.Character characterToken) {\n        Node node = new TextNode(characterToken.getData(), baseUri);\n        insertNode(node);\n    }\n\n    void insert(Token.Doctype d) {\n        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n        insertNode(doctypeNode);\n    }\n\n    \n    private void popStackToClose(Token.EndTag endTag) {\n        String elName = endTag.name();\n        Element firstFound = null;\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                firstFound = next;\n                break;\n            }\n        }\n        if (firstFound == null)\n            return; \n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next == firstFound)\n                break;\n        }\n    }\n\n    List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        initialiseParse(inputFragment, baseUri, errors, settings);\n        runParser();\n        return doc.childNodes();\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.Jsoup;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.*;\n\nimport java.util.List;\n\n\npublic class XmlTreeBuilder extends TreeBuilder { ParseSettings defaultSettings() {\n        return ParseSettings.preserveCase;\n    }\n\n    Document parse(String input, String baseUri) {\n        return parse(input, baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);\n    }\n\n    @Override\n    protected void initialiseParse(String input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        super.initialiseParse(input, baseUri, errors, settings);\n        stack.add(doc); \n        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        \n        switch (token.type) {\n            case StartTag:\n                insert(token.asStartTag());\n                break;\n            case EndTag:\n                popStackToClose(token.asEndTag());\n                break;\n            case Comment:\n                insert(token.asComment());\n                break;\n            case Character:\n                insert(token.asCharacter());\n                break;\n            case Doctype:\n                insert(token.asDoctype());\n                break;\n            case EOF: \n                break;\n            default:\n                Validate.fail(\"Unexpected token type: \" + token.type);\n        }\n        return true;\n    }\n\n    private void insertNode(Node node) {\n        currentElement().appendChild(node);\n    }\n\n    Element insert(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        \n        Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes));\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            tokeniser.acknowledgeSelfClosingFlag();\n            if (!tag.isKnownTag()) \n                tag.setSelfClosing();\n        } else {\n            stack.add(el);\n        }\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData(), baseUri);\n        Node insert = comment;\n        if (commentToken.bogus) { \n            \n            String data = comment.getData();\n            if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n                Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n                Element el = doc.child(0);\n                insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), comment.baseUri(), data.startsWith(\"!\"));\n                insert.attributes().addAll(el.attributes());\n            }\n        }\n        insertNode(insert);\n    }\n\n    void insert(Token.Character characterToken) {\n        Node node = new TextNode(characterToken.getData(), baseUri);\n        insertNode(node);\n    }\n\n    void insert(Token.Doctype d) {\n        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n        insertNode(doctypeNode);\n    }\n\n    \n    private void popStackToClose(Token.EndTag endTag) {\n        String elName = endTag.name();\n        Element firstFound = null;\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                firstFound = next;\n                break;\n            }\n        }\n        if (firstFound == null)\n            return; \n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next == firstFound)\n                break;\n        }\n    }\n\n    List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        initialiseParse(inputFragment, baseUri, errors, settings);\n        runParser();\n        return doc.childNodes();\n    }\n}\n",
      "buggy_signatures": [
        "public class XmlTreeBuilder extends TreeBuilder { ParseSettings defaultSettings()",
        "protected void initialiseParse(String input, String baseUri, ParseErrorList errors, ParseSettings settings)",
        "protected boolean process(Token token)",
        "private void insertNode(Node node)",
        "private void popStackToClose(Token.EndTag endTag)"
      ],
      "fixed_signatures": [
        "public class XmlTreeBuilder extends TreeBuilder { ParseSettings defaultSettings()",
        "protected void initialiseParse(String input, String baseUri, ParseErrorList errors, ParseSettings settings)",
        "protected boolean process(Token token)",
        "private void insertNode(Node node)",
        "private void popStackToClose(Token.EndTag endTag)"
      ],
      "methods": [
        {
          "buggy_method": "  private void insertNode(Node node) {\n  currentElement().appendChild(node);\n  }",
          "fixed_method": "  private void insertNode(Node node) {\n  currentElement().appendChild(node);\n  }",
          "diff": [
            "@@ -97,7 +97,7 @@",
            "     }\n",
            " \n",
            "     void insert(Token.Doctype d) {\n",
            "-        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n",
            "+        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n",
            "         insertNode(doctypeNode);\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
