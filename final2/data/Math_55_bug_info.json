{
  "bug_id": "55",
  "failed_tests": {
    "org.apache.commons.math.geometry.Vector3DTest": [
      {
        "methodName": "testCrossProductCancellation",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<1.0> but was:<0.0>",
        "fail_line": "        checkVector(Vector3D.crossProduct(v1, v2), -1, 2, 1);",
        "test_source": "  public void testCrossProductCancellation() {\n  Vector3D v1 = new Vector3D(9070467121.0, 4535233560.0, 1);\n  Vector3D v2 = new Vector3D(9070467123.0, 4535233561.0, 1);\n  checkVector(Vector3D.crossProduct(v1, v2), -1, 2, 1);\n\n  double scale  = FastMath.scalb(1.0, 100);\n  Vector3D big1  = new Vector3D(scale, v1);\n  Vector3D small2 = new Vector3D(1 / scale, v2);\n  checkVector(Vector3D.crossProduct(big1, small2), -1, 2, 1);\n\n  }",
        "stack": [
          "Vector3DTest.checkVector line 242, Vector3DTest.testCrossProductCancellation line 159"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/geometry/Vector3D.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.geometry;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math.exception.MathArithmeticException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.util.MathUtils;\nimport org.apache.commons.math.util.FastMath;\n\n\npublic class Vector3D implements Serializable { public static final Vector3D ZERO = new Vector3D(0, 0, 0); public static final Vector3D PLUS_I = new Vector3D(1, 0, 0); public static final Vector3D MINUS_I = new Vector3D(-1, 0, 0); public static final Vector3D PLUS_J = new Vector3D(0, 1, 0); public static final Vector3D MINUS_J = new Vector3D(0, -1, 0); public static final Vector3D PLUS_K = new Vector3D(0, 0, 1); public static final Vector3D MINUS_K = new Vector3D(0, 0, -1); public static final Vector3D NaN = new Vector3D(Double.NaN, Double.NaN, Double.NaN); public static final Vector3D POSITIVE_INFINITY = new Vector3D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY); public static final Vector3D NEGATIVE_INFINITY = new Vector3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY); private static final Vector3DFormat DEFAULT_FORMAT = Vector3DFormat.getInstance(); private static final long serialVersionUID = 5133268763396045979L; private final double x; private final double y; private final double z; public Vector3D(double x, double y, double z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  \n  public Vector3D(double alpha, double delta) {\n    double cosDelta = FastMath.cos(delta);\n    this.x = FastMath.cos(alpha) * cosDelta;\n    this.y = FastMath.sin(alpha) * cosDelta;\n    this.z = FastMath.sin(delta);\n  }\n\n  \n  public Vector3D(double a, Vector3D u) {\n    this.x = a * u.x;\n    this.y = a * u.y;\n    this.z = a * u.z;\n  }\n\n  \n  public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2) {\n    this.x = a1 * u1.x + a2 * u2.x;\n    this.y = a1 * u1.y + a2 * u2.y;\n    this.z = a1 * u1.z + a2 * u2.z;\n  }\n\n  \n  public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2, double a3, Vector3D u3) {\n    this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x;\n    this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y;\n    this.z = a1 * u1.z + a2 * u2.z + a3 * u3.z;\n  }\n\n  \n  public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2, double a3, Vector3D u3, double a4, Vector3D u4) {\n    this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x + a4 * u4.x;\n    this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y + a4 * u4.y;\n    this.z = a1 * u1.z + a2 * u2.z + a3 * u3.z + a4 * u4.z;\n  }\n\n  \n  public double getX() {\n    return x;\n  }\n\n  \n  public double getY() {\n    return y;\n  }\n\n  \n  public double getZ() {\n    return z;\n  }\n\n  \n  public double getNorm1() {\n    return FastMath.abs(x) + FastMath.abs(y) + FastMath.abs(z);\n  }\n\n  \n  public double getNorm() {\n    return FastMath.sqrt (x * x + y * y + z * z);\n  }\n\n  \n  public double getNormSq() {\n    return x * x + y * y + z * z;\n  }\n\n  \n  public double getNormInf() {\n    return FastMath.max(FastMath.max(FastMath.abs(x), FastMath.abs(y)), FastMath.abs(z));\n  }\n\n  \n  public double getAlpha() {\n    return FastMath.atan2(y, x);\n  }\n\n  \n  public double getDelta() {\n    return FastMath.asin(z / getNorm());\n  }\n\n  \n  public Vector3D add(Vector3D v) {\n    return new Vector3D(x + v.x, y + v.y, z + v.z);\n  }\n\n  \n  public Vector3D add(double factor, Vector3D v) {\n    return new Vector3D(x + factor * v.x, y + factor * v.y, z + factor * v.z);\n  }\n\n  \n  public Vector3D subtract(Vector3D v) {\n    return new Vector3D(x - v.x, y - v.y, z - v.z);\n  }\n\n  \n  public Vector3D subtract(double factor, Vector3D v) {\n    return new Vector3D(x - factor * v.x, y - factor * v.y, z - factor * v.z);\n  }\n\n  \n  public Vector3D normalize() {\n    double s = getNorm();\n    if (s == 0) {\n      throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    return scalarMultiply(1 / s);\n  }\n\n  \n  public Vector3D orthogonal() {\n\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n      throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if ((x >= -threshold) && (x <= threshold)) {\n      double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n      return new Vector3D(0, inverse * z, -inverse * y);\n    } else if ((y >= -threshold) && (y <= threshold)) {\n      double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n      return new Vector3D(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new Vector3D(inverse * y, -inverse * x, 0);\n\n  }\n\n  \n  public static double angle(Vector3D v1, Vector3D v2) {\n\n    double normProduct = v1.getNorm() * v2.getNorm();\n    if (normProduct == 0) {\n      throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    double dot = dotProduct(v1, v2);\n    double threshold = normProduct * 0.9999;\n    if ((dot < -threshold) || (dot > threshold)) {\n      \n      Vector3D v3 = crossProduct(v1, v2);\n      if (dot >= 0) {\n        return FastMath.asin(v3.getNorm() / normProduct);\n      }\n      return FastMath.PI - FastMath.asin(v3.getNorm() / normProduct);\n    }\n\n    \n    return FastMath.acos(dot / normProduct);\n\n  }\n\n  \n  public Vector3D negate() {\n    return new Vector3D(-x, -y, -z);\n  }\n\n  \n  public Vector3D scalarMultiply(double a) {\n    return new Vector3D(a * x, a * y, a * z);\n  }\n\n  \n  public boolean isNaN() {\n      return Double.isNaN(x) || Double.isNaN(y) || Double.isNaN(z);\n  }\n\n  \n  public boolean isInfinite() {\n      return !isNaN() && (Double.isInfinite(x) || Double.isInfinite(y) || Double.isInfinite(z));\n  }\n\n  \n  @Override\n  public boolean equals(Object other) {\n\n    if (this == other) {\n      return true;\n    }\n\n    if (other instanceof Vector3D) {\n      final Vector3D rhs = (Vector3D)other;\n      if (rhs.isNaN()) {\n          return this.isNaN();\n      }\n\n      return (x == rhs.x) && (y == rhs.y) && (z == rhs.z);\n    }\n    return false;\n  }\n\n  \n  @Override\n  public int hashCode() {\n      if (isNaN()) {\n          return 8;\n      }\n      return 31 * (23 * MathUtils.hash(x) +  19 * MathUtils.hash(y) +  MathUtils.hash(z));\n  }\n\n  \n  public static double dotProduct(Vector3D v1, Vector3D v2) {\n    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n  }\n\n  \n  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n\n\n      \n      \n\n      \n      \n      \n      \n      \n\n      \n\n\n      \n      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n\n  }\n\n  \n  public static double distance1(Vector3D v1, Vector3D v2) {\n    final double dx = FastMath.abs(v2.x - v1.x);\n    final double dy = FastMath.abs(v2.y - v1.y);\n    final double dz = FastMath.abs(v2.z - v1.z);\n    return dx + dy + dz;\n  }\n\n  \n  public static double distance(Vector3D v1, Vector3D v2) {\n    final double dx = v2.x - v1.x;\n    final double dy = v2.y - v1.y;\n    final double dz = v2.z - v1.z;\n    return FastMath.sqrt(dx * dx + dy * dy + dz * dz);\n  }\n\n  \n  public static double distanceInf(Vector3D v1, Vector3D v2) {\n    final double dx = FastMath.abs(v2.x - v1.x);\n    final double dy = FastMath.abs(v2.y - v1.y);\n    final double dz = FastMath.abs(v2.z - v1.z);\n    return FastMath.max(FastMath.max(dx, dy), dz);\n  }\n\n  \n  public static double distanceSq(Vector3D v1, Vector3D v2) {\n    final double dx = v2.x - v1.x;\n    final double dy = v2.y - v1.y;\n    final double dz = v2.z - v1.z;\n    return dx * dx + dy * dy + dz * dz;\n  }\n\n  \n  @Override\n  public String toString() {\n      return DEFAULT_FORMAT.format(this);\n  }\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.geometry;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math.exception.MathArithmeticException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.util.MathUtils;\nimport org.apache.commons.math.util.FastMath;\n\n\npublic class Vector3D implements Serializable { public static final Vector3D ZERO = new Vector3D(0, 0, 0); public static final Vector3D PLUS_I = new Vector3D(1, 0, 0); public static final Vector3D MINUS_I = new Vector3D(-1, 0, 0); public static final Vector3D PLUS_J = new Vector3D(0, 1, 0); public static final Vector3D MINUS_J = new Vector3D(0, -1, 0); public static final Vector3D PLUS_K = new Vector3D(0, 0, 1); public static final Vector3D MINUS_K = new Vector3D(0, 0, -1); public static final Vector3D NaN = new Vector3D(Double.NaN, Double.NaN, Double.NaN); public static final Vector3D POSITIVE_INFINITY = new Vector3D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY); public static final Vector3D NEGATIVE_INFINITY = new Vector3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY); private static final Vector3DFormat DEFAULT_FORMAT = Vector3DFormat.getInstance(); private static final long serialVersionUID = 5133268763396045979L; private final double x; private final double y; private final double z; public Vector3D(double x, double y, double z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  \n  public Vector3D(double alpha, double delta) {\n    double cosDelta = FastMath.cos(delta);\n    this.x = FastMath.cos(alpha) * cosDelta;\n    this.y = FastMath.sin(alpha) * cosDelta;\n    this.z = FastMath.sin(delta);\n  }\n\n  \n  public Vector3D(double a, Vector3D u) {\n    this.x = a * u.x;\n    this.y = a * u.y;\n    this.z = a * u.z;\n  }\n\n  \n  public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2) {\n    this.x = a1 * u1.x + a2 * u2.x;\n    this.y = a1 * u1.y + a2 * u2.y;\n    this.z = a1 * u1.z + a2 * u2.z;\n  }\n\n  \n  public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2, double a3, Vector3D u3) {\n    this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x;\n    this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y;\n    this.z = a1 * u1.z + a2 * u2.z + a3 * u3.z;\n  }\n\n  \n  public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2, double a3, Vector3D u3, double a4, Vector3D u4) {\n    this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x + a4 * u4.x;\n    this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y + a4 * u4.y;\n    this.z = a1 * u1.z + a2 * u2.z + a3 * u3.z + a4 * u4.z;\n  }\n\n  \n  public double getX() {\n    return x;\n  }\n\n  \n  public double getY() {\n    return y;\n  }\n\n  \n  public double getZ() {\n    return z;\n  }\n\n  \n  public double getNorm1() {\n    return FastMath.abs(x) + FastMath.abs(y) + FastMath.abs(z);\n  }\n\n  \n  public double getNorm() {\n    return FastMath.sqrt (x * x + y * y + z * z);\n  }\n\n  \n  public double getNormSq() {\n    return x * x + y * y + z * z;\n  }\n\n  \n  public double getNormInf() {\n    return FastMath.max(FastMath.max(FastMath.abs(x), FastMath.abs(y)), FastMath.abs(z));\n  }\n\n  \n  public double getAlpha() {\n    return FastMath.atan2(y, x);\n  }\n\n  \n  public double getDelta() {\n    return FastMath.asin(z / getNorm());\n  }\n\n  \n  public Vector3D add(Vector3D v) {\n    return new Vector3D(x + v.x, y + v.y, z + v.z);\n  }\n\n  \n  public Vector3D add(double factor, Vector3D v) {\n    return new Vector3D(x + factor * v.x, y + factor * v.y, z + factor * v.z);\n  }\n\n  \n  public Vector3D subtract(Vector3D v) {\n    return new Vector3D(x - v.x, y - v.y, z - v.z);\n  }\n\n  \n  public Vector3D subtract(double factor, Vector3D v) {\n    return new Vector3D(x - factor * v.x, y - factor * v.y, z - factor * v.z);\n  }\n\n  \n  public Vector3D normalize() {\n    double s = getNorm();\n    if (s == 0) {\n      throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    return scalarMultiply(1 / s);\n  }\n\n  \n  public Vector3D orthogonal() {\n\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n      throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if ((x >= -threshold) && (x <= threshold)) {\n      double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n      return new Vector3D(0, inverse * z, -inverse * y);\n    } else if ((y >= -threshold) && (y <= threshold)) {\n      double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n      return new Vector3D(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new Vector3D(inverse * y, -inverse * x, 0);\n\n  }\n\n  \n  public static double angle(Vector3D v1, Vector3D v2) {\n\n    double normProduct = v1.getNorm() * v2.getNorm();\n    if (normProduct == 0) {\n      throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    double dot = dotProduct(v1, v2);\n    double threshold = normProduct * 0.9999;\n    if ((dot < -threshold) || (dot > threshold)) {\n      \n      Vector3D v3 = crossProduct(v1, v2);\n      if (dot >= 0) {\n        return FastMath.asin(v3.getNorm() / normProduct);\n      }\n      return FastMath.PI - FastMath.asin(v3.getNorm() / normProduct);\n    }\n\n    \n    return FastMath.acos(dot / normProduct);\n\n  }\n\n  \n  public Vector3D negate() {\n    return new Vector3D(-x, -y, -z);\n  }\n\n  \n  public Vector3D scalarMultiply(double a) {\n    return new Vector3D(a * x, a * y, a * z);\n  }\n\n  \n  public boolean isNaN() {\n      return Double.isNaN(x) || Double.isNaN(y) || Double.isNaN(z);\n  }\n\n  \n  public boolean isInfinite() {\n      return !isNaN() && (Double.isInfinite(x) || Double.isInfinite(y) || Double.isInfinite(z));\n  }\n\n  \n  @Override\n  public boolean equals(Object other) {\n\n    if (this == other) {\n      return true;\n    }\n\n    if (other instanceof Vector3D) {\n      final Vector3D rhs = (Vector3D)other;\n      if (rhs.isNaN()) {\n          return this.isNaN();\n      }\n\n      return (x == rhs.x) && (y == rhs.y) && (z == rhs.z);\n    }\n    return false;\n  }\n\n  \n  @Override\n  public int hashCode() {\n      if (isNaN()) {\n          return 8;\n      }\n      return 31 * (23 * MathUtils.hash(x) +  19 * MathUtils.hash(y) +  MathUtils.hash(z));\n  }\n\n  \n  public static double dotProduct(Vector3D v1, Vector3D v2) {\n    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n  }\n\n  \n  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n\n      final double n1 = v1.getNormSq();\n      final double n2 = v2.getNormSq();\n      if ((n1 * n2) < MathUtils.SAFE_MIN) {\n          return ZERO;\n      }\n\n      \n      \n      final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4;\n      final double x1    = FastMath.scalb(v1.x, -deltaExp);\n      final double y1    = FastMath.scalb(v1.y, -deltaExp);\n      final double z1    = FastMath.scalb(v1.z, -deltaExp);\n      final double x2    = FastMath.scalb(v2.x,  deltaExp);\n      final double y2    = FastMath.scalb(v2.y,  deltaExp);\n      final double z2    = FastMath.scalb(v2.z,  deltaExp);\n\n      \n      \n      \n      \n      \n\n      \n      final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);\n      final double rho   = FastMath.rint(256 * ratio) / 256;\n\n      final double x3 = x1 - rho * x2;\n      final double y3 = y1 - rho * y2;\n      final double z3 = z1 - rho * z2;\n\n      \n      return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);\n\n  }\n\n  \n  public static double distance1(Vector3D v1, Vector3D v2) {\n    final double dx = FastMath.abs(v2.x - v1.x);\n    final double dy = FastMath.abs(v2.y - v1.y);\n    final double dz = FastMath.abs(v2.z - v1.z);\n    return dx + dy + dz;\n  }\n\n  \n  public static double distance(Vector3D v1, Vector3D v2) {\n    final double dx = v2.x - v1.x;\n    final double dy = v2.y - v1.y;\n    final double dz = v2.z - v1.z;\n    return FastMath.sqrt(dx * dx + dy * dy + dz * dz);\n  }\n\n  \n  public static double distanceInf(Vector3D v1, Vector3D v2) {\n    final double dx = FastMath.abs(v2.x - v1.x);\n    final double dy = FastMath.abs(v2.y - v1.y);\n    final double dz = FastMath.abs(v2.z - v1.z);\n    return FastMath.max(FastMath.max(dx, dy), dz);\n  }\n\n  \n  public static double distanceSq(Vector3D v1, Vector3D v2) {\n    final double dx = v2.x - v1.x;\n    final double dy = v2.y - v1.y;\n    final double dz = v2.z - v1.z;\n    return dx * dx + dy * dy + dz * dz;\n  }\n\n  \n  @Override\n  public String toString() {\n      return DEFAULT_FORMAT.format(this);\n  }\n\n}\n",
      "buggy_signatures": [
        "public Vector3D(double alpha, double delta)",
        "public Vector3D(double a, Vector3D u)",
        "public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2)",
        "public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2, double a3, Vector3D u3)",
        "public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2, double a3, Vector3D u3, double a4, Vector3D u4)",
        "public double getX()",
        "public double getY()",
        "public double getZ()",
        "public double getNorm1()",
        "public double getNorm()",
        "public double getNormSq()",
        "public double getNormInf()",
        "public double getAlpha()",
        "public double getDelta()",
        "public Vector3D add(Vector3D v)",
        "public Vector3D add(double factor, Vector3D v)",
        "public Vector3D subtract(Vector3D v)",
        "public Vector3D subtract(double factor, Vector3D v)",
        "public Vector3D normalize()",
        "public Vector3D orthogonal()",
        "public static double angle(Vector3D v1, Vector3D v2)",
        "public Vector3D negate()",
        "public Vector3D scalarMultiply(double a)",
        "public boolean isNaN()",
        "public boolean isInfinite()",
        "public boolean equals(Object other)",
        "public int hashCode()",
        "public static double dotProduct(Vector3D v1, Vector3D v2)",
        "public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2)",
        "public static double distance1(Vector3D v1, Vector3D v2)",
        "public static double distance(Vector3D v1, Vector3D v2)",
        "public static double distanceInf(Vector3D v1, Vector3D v2)",
        "public static double distanceSq(Vector3D v1, Vector3D v2)",
        "public String toString()"
      ],
      "fixed_signatures": [
        "public Vector3D(double alpha, double delta)",
        "public Vector3D(double a, Vector3D u)",
        "public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2)",
        "public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2, double a3, Vector3D u3)",
        "public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2, double a3, Vector3D u3, double a4, Vector3D u4)",
        "public double getX()",
        "public double getY()",
        "public double getZ()",
        "public double getNorm1()",
        "public double getNorm()",
        "public double getNormSq()",
        "public double getNormInf()",
        "public double getAlpha()",
        "public double getDelta()",
        "public Vector3D add(Vector3D v)",
        "public Vector3D add(double factor, Vector3D v)",
        "public Vector3D subtract(Vector3D v)",
        "public Vector3D subtract(double factor, Vector3D v)",
        "public Vector3D normalize()",
        "public Vector3D orthogonal()",
        "public static double angle(Vector3D v1, Vector3D v2)",
        "public Vector3D negate()",
        "public Vector3D scalarMultiply(double a)",
        "public boolean isNaN()",
        "public boolean isInfinite()",
        "public boolean equals(Object other)",
        "public int hashCode()",
        "public static double dotProduct(Vector3D v1, Vector3D v2)",
        "public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2)",
        "public static double distance1(Vector3D v1, Vector3D v2)",
        "public static double distance(Vector3D v1, Vector3D v2)",
        "public static double distanceInf(Vector3D v1, Vector3D v2)",
        "public static double distanceSq(Vector3D v1, Vector3D v2)",
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n\n\n  \n  \n\n  \n  \n  \n  \n  \n\n  \n\n\n  \n  return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n\n  }",
          "fixed_method": "  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n\n  final double n1 = v1.getNormSq();\n  final double n2 = v2.getNormSq();\n  if ((n1 * n2) < MathUtils.SAFE_MIN) {\n  return ZERO;\n  }\n\n  \n  \n  final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4;\n  final double x1  = FastMath.scalb(v1.x, -deltaExp);\n  final double y1  = FastMath.scalb(v1.y, -deltaExp);\n  final double z1  = FastMath.scalb(v1.z, -deltaExp);\n  final double x2  = FastMath.scalb(v2.x,  deltaExp);\n  final double y2  = FastMath.scalb(v2.y,  deltaExp);\n  final double z2  = FastMath.scalb(v2.z,  deltaExp);\n\n  \n  \n  \n  \n  \n\n  \n  final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);\n  final double rho  = FastMath.rint(256 * ratio) / 256;\n\n  final double x3 = x1 - rho * x2;\n  final double y3 = y1 - rho * y2;\n  final double z3 = z1 - rho * z2;\n\n  \n  return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);\n\n  }",
          "diff": [
            "@@ -456,9 +456,21 @@",
            "    */\n",
            "   public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n",
            " \n",
            "+      final double n1 = v1.getNormSq();\n",
            "+      final double n2 = v2.getNormSq();\n",
            "+      if ((n1 * n2) < MathUtils.SAFE_MIN) {\n",
            "+          return ZERO;\n",
            "+      }\n",
            " \n",
            "       // rescale both vectors without losing precision,\n",
            "       // to ensure their norm are the same order of magnitude\n",
            "+      final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4;\n",
            "+      final double x1    = FastMath.scalb(v1.x, -deltaExp);\n",
            "+      final double y1    = FastMath.scalb(v1.y, -deltaExp);\n",
            "+      final double z1    = FastMath.scalb(v1.z, -deltaExp);\n",
            "+      final double x2    = FastMath.scalb(v2.x,  deltaExp);\n",
            "+      final double y2    = FastMath.scalb(v2.y,  deltaExp);\n",
            "+      final double z2    = FastMath.scalb(v2.z,  deltaExp);\n",
            " \n",
            "       // we reduce cancellation errors by preconditioning,\n",
            "       // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n",
            "@@ -467,10 +479,15 @@",
            "       // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n",
            " \n",
            "       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n",
            "-\n",
            "+      final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);\n",
            "+      final double rho   = FastMath.rint(256 * ratio) / 256;\n",
            "+\n",
            "+      final double x3 = x1 - rho * x2;\n",
            "+      final double y3 = y1 - rho * y2;\n",
            "+      final double z3 = z1 - rho * z2;\n",
            " \n",
            "       // compute cross product from v3 and v2 instead of v1 and v2\n",
            "-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n",
            "+      return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);\n",
            " \n",
            "   }\n",
            " \n"
          ],
          "changed_lines": 21
        }
      ]
    }
  ]
}
