{
  "bug_id": "7",
  "failed_tests": {
    "org.apache.commons.lang3.math.NumberUtilsTest": [
      {
        "methodName": "testCreateNumber",
        "error": "junit.framework.AssertionFailedError",
        "message": "Expected NumberFormatException",
        "fail_line": "            fail(\"Expected NumberFormatException\");",
        "test_source": "  public void testCreateNumber() {\n  // a lot of things can go wrong\n  assertEquals(\"createNumber(String) 1 failed\", Float.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5\"));\n  assertEquals(\"createNumber(String) 2 failed\", Integer.valueOf(\"12345\"), NumberUtils.createNumber(\"12345\"));\n  assertEquals(\"createNumber(String) 3 failed\", Double.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5D\"));\n  assertEquals(\"createNumber(String) 3 failed\", Double.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5d\"));\n  assertEquals(\"createNumber(String) 4 failed\", Float.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5F\"));\n  assertEquals(\"createNumber(String) 4 failed\", Float.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5f\"));\n  assertEquals(\"createNumber(String) 5 failed\", Long.valueOf(Integer.MAX_VALUE + 1L), NumberUtils.createNumber(\"\"\n  + (Integer.MAX_VALUE + 1L)));\n  assertEquals(\"createNumber(String) 6 failed\", Long.valueOf(12345), NumberUtils.createNumber(\"12345L\"));\n  assertEquals(\"createNumber(String) 6 failed\", Long.valueOf(12345), NumberUtils.createNumber(\"12345l\"));\n  assertEquals(\"createNumber(String) 7 failed\", Float.valueOf(\"-1234.5\"), NumberUtils.createNumber(\"-1234.5\"));\n  assertEquals(\"createNumber(String) 8 failed\", Integer.valueOf(\"-12345\"), NumberUtils.createNumber(\"-12345\"));\n  assertTrue(\"createNumber(String) 9a failed\", 0xFADE == NumberUtils.createNumber(\"0xFADE\").intValue());\n  assertTrue(\"createNumber(String) 9b failed\", 0xFADE == NumberUtils.createNumber(\"0Xfade\").intValue());\n  assertTrue(\"createNumber(String) 10a failed\", -0xFADE == NumberUtils.createNumber(\"-0xFADE\").intValue());\n  assertTrue(\"createNumber(String) 10b failed\", -0xFADE == NumberUtils.createNumber(\"-0Xfade\").intValue());\n  assertEquals(\"createNumber(String) 11 failed\", Double.valueOf(\"1.1E200\"), NumberUtils.createNumber(\"1.1E200\"));\n  assertEquals(\"createNumber(String) 12 failed\", Float.valueOf(\"1.1E20\"), NumberUtils.createNumber(\"1.1E20\"));\n  assertEquals(\"createNumber(String) 13 failed\", Double.valueOf(\"-1.1E200\"), NumberUtils.createNumber(\"-1.1E200\"));\n  assertEquals(\"createNumber(String) 14 failed\", Double.valueOf(\"1.1E-200\"), NumberUtils.createNumber(\"1.1E-200\"));\n  assertEquals(\"createNumber(null) failed\", null, NumberUtils.createNumber(null));\n  assertEquals(\"createNumber(String) failed\", new BigInteger(\"12345678901234567890\"), NumberUtils\n  .createNumber(\"12345678901234567890L\"));\n\n  // jdk 1.2 doesn't support this. unsure about jdk 1.2.2\n  if (SystemUtils.isJavaVersionAtLeast(JAVA_1_3)) {\n  assertEquals(\"createNumber(String) 15 failed\", new BigDecimal(\"1.1E-700\"), NumberUtils\n  .createNumber(\"1.1E-700F\"));\n  }\n  assertEquals(\"createNumber(String) 16 failed\", Long.valueOf(\"10\" + Integer.MAX_VALUE), NumberUtils\n  .createNumber(\"10\" + Integer.MAX_VALUE + \"L\"));\n  assertEquals(\"createNumber(String) 17 failed\", Long.valueOf(\"10\" + Integer.MAX_VALUE), NumberUtils\n  .createNumber(\"10\" + Integer.MAX_VALUE));\n  assertEquals(\"createNumber(String) 18 failed\", new BigInteger(\"10\" + Long.MAX_VALUE), NumberUtils\n  .createNumber(\"10\" + Long.MAX_VALUE));\n\n  // LANG-521\n  assertEquals(\"createNumber(String) LANG-521 failed\", Float.valueOf(\"2.\"), NumberUtils.createNumber(\"2.\"));\n\n  // LANG-638\n  assertFalse(\"createNumber(String) succeeded\", checkCreateNumber(\"1eE\"));\n\n  // LANG-693\n  assertEquals(\"createNumber(String) LANG-693 failed\", Double.valueOf(Double.MAX_VALUE), NumberUtils\n  .createNumber(\"\" + Double.MAX_VALUE));\n  \n  // LANG-822\n  // ensure that the underlying negative number would create a BigDecimal\n  final Number bigNum = NumberUtils.createNumber(\"-1.1E-700F\");\n  assertEquals(BigDecimal.class,bigNum.getClass());\n  assertNotNull(bigNum);\n\n  // Check that the code fails to create a valid number when preceeded by -- rather than -\n  try {\n  NumberUtils.createNumber(\"--1.1E-700F\");\n  fail(\"Expected NumberFormatException\");\n  } catch (NumberFormatException nfe) {\n  // expected\n  }\n  }",
        "stack": [
          "NumberUtilsTest.testCreateNumber line 242"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/lang3/math/NumberUtils.java",
      "buggy_full_code": "\npackage org.apache.commons.lang3.math;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport org.apache.commons.lang3.StringUtils;\n\n\npublic class NumberUtils { public static final Long LONG_ZERO = Long.valueOf(0L); public static final Long LONG_ONE = Long.valueOf(1L); public static final Long LONG_MINUS_ONE = Long.valueOf(-1L); public static final Integer INTEGER_ZERO = Integer.valueOf(0); public static final Integer INTEGER_ONE = Integer.valueOf(1); public static final Integer INTEGER_MINUS_ONE = Integer.valueOf(-1); public static final Short SHORT_ZERO = Short.valueOf((short) 0); public static final Short SHORT_ONE = Short.valueOf((short) 1); public static final Short SHORT_MINUS_ONE = Short.valueOf((short) -1); public static final Byte BYTE_ZERO = Byte.valueOf((byte) 0); public static final Byte BYTE_ONE = Byte.valueOf((byte) 1); public static final Byte BYTE_MINUS_ONE = Byte.valueOf((byte) -1); public static final Double DOUBLE_ZERO = Double.valueOf(0.0d); public static final Double DOUBLE_ONE = Double.valueOf(1.0d); public static final Double DOUBLE_MINUS_ONE = Double.valueOf(-1.0d); public static final Float FLOAT_ZERO = Float.valueOf(0.0f); public static final Float FLOAT_ONE = Float.valueOf(1.0f); public static final Float FLOAT_MINUS_ONE = Float.valueOf(-1.0f); public NumberUtils() {\n        super();\n    }\n\n    \n    \n    public static int toInt(String str) {\n        return toInt(str, 0);\n    }\n\n    \n    public static int toInt(String str, int defaultValue) {\n        if(str == null) {\n            return defaultValue;\n        }\n        try {\n            return Integer.parseInt(str);\n        } catch (NumberFormatException nfe) {\n            return defaultValue;\n        }\n    }\n\n    \n    public static long toLong(String str) {\n        return toLong(str, 0L);\n    }\n\n    \n    public static long toLong(String str, long defaultValue) {\n        if (str == null) {\n            return defaultValue;\n        }\n        try {\n            return Long.parseLong(str);\n        } catch (NumberFormatException nfe) {\n            return defaultValue;\n        }\n    }\n\n    \n    public static float toFloat(String str) {\n        return toFloat(str, 0.0f);\n    }\n\n    \n    public static float toFloat(String str, float defaultValue) {\n      if (str == null) {\n          return defaultValue;\n      }     \n      try {\n          return Float.parseFloat(str);\n      } catch (NumberFormatException nfe) {\n          return defaultValue;\n      }\n    }\n\n    \n    public static double toDouble(String str) {\n        return toDouble(str, 0.0d);\n    }\n\n    \n    public static double toDouble(String str, double defaultValue) {\n      if (str == null) {\n          return defaultValue;\n      }\n      try {\n          return Double.parseDouble(str);\n      } catch (NumberFormatException nfe) {\n          return defaultValue;\n      }\n    }\n\n     \n     \n    public static byte toByte(String str) {\n        return toByte(str, (byte) 0);\n    }\n\n    \n    public static byte toByte(String str, byte defaultValue) {\n        if(str == null) {\n            return defaultValue;\n        }\n        try {\n            return Byte.parseByte(str);\n        } catch (NumberFormatException nfe) {\n            return defaultValue;\n        }\n    }\n\n    \n    public static short toShort(String str) {\n        return toShort(str, (short) 0);\n    }\n\n    \n    public static short toShort(String str, short defaultValue) {\n        if(str == null) {\n            return defaultValue;\n        }\n        try {\n            return Short.parseShort(str);\n        } catch (NumberFormatException nfe) {\n            return defaultValue;\n        }\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n            int hexDigits = str.length() - 2; \n            if (str.startsWith(\"-\")) { \n                hexDigits--;\n            }\n            if (hexDigits > 8) { \n                return createLong(str);\n            }\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos || expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            \n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) { \n                            \n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            \n                            \n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) { \n                        \n                    }\n                    \n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) { \n                        \n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) { \n                        \n                    }\n                    \n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            \n            \n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                \n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) { \n                    \n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) { \n                    \n                }\n                return createBigInteger(str);\n\n            } else {\n                \n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { \n                    \n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { \n                    \n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n\n    \n    private static boolean isAllZeros(String str) {\n        if (str == null) {\n            return true;\n        }\n        for (int i = str.length() - 1; i >= 0; i--) {\n            if (str.charAt(i) != '0') {\n                return false;\n            }\n        }\n        return str.length() > 0;\n    }\n\n    \n    \n    public static Float createFloat(String str) {\n        if (str == null) {\n            return null;\n        }\n        return Float.valueOf(str);\n    }\n\n    \n    public static Double createDouble(String str) {\n        if (str == null) {\n            return null;\n        }\n        return Double.valueOf(str);\n    }\n\n    \n    public static Integer createInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        \n        return Integer.decode(str);\n    }\n\n    \n    public static Long createLong(String str) {\n        if (str == null) {\n            return null;\n        }\n        return Long.decode(str);\n    }\n\n    \n    public static BigInteger createBigInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        return new BigInteger(str);\n    }\n\n    \n    public static BigDecimal createBigDecimal(String str) {\n        if (str == null) {\n            return null;\n        }\n        \n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n            \n            \n            \n            \n        return new BigDecimal(str);\n    }\n\n    \n    \n    \n    public static long min(long[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        long min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n    \n        return min;\n    }\n\n    \n    public static int min(int[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        int min = array[0];\n        for (int j = 1; j < array.length; j++) {\n            if (array[j] < min) {\n                min = array[j];\n            }\n        }\n    \n        return min;\n    }\n\n    \n    public static short min(short[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        short min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n    \n        return min;\n    }\n\n    \n    public static byte min(byte[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        byte min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n    \n        return min;\n    }\n\n     \n    public static double min(double[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        double min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (Double.isNaN(array[i])) {\n                return Double.NaN;\n            }\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n    \n        return min;\n    }\n\n    \n    public static float min(float[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        float min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (Float.isNaN(array[i])) {\n                return Float.NaN;\n            }\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n    \n        return min;\n    }\n\n    \n    \n    \n    public static long max(long[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n\n        \n        long max = array[0];\n        for (int j = 1; j < array.length; j++) {\n            if (array[j] > max) {\n                max = array[j];\n            }\n        }\n\n        return max;\n    }\n\n    \n    public static int max(int[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        int max = array[0];\n        for (int j = 1; j < array.length; j++) {\n            if (array[j] > max) {\n                max = array[j];\n            }\n        }\n    \n        return max;\n    }\n\n    \n    public static short max(short[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        short max = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] > max) {\n                max = array[i];\n            }\n        }\n    \n        return max;\n    }\n\n    \n    public static byte max(byte[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        byte max = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] > max) {\n                max = array[i];\n            }\n        }\n    \n        return max;\n    }\n\n    \n    public static double max(double[] array) {\n        \n        if (array== null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        double max = array[0];\n        for (int j = 1; j < array.length; j++) {\n            if (Double.isNaN(array[j])) {\n                return Double.NaN;\n            }\n            if (array[j] > max) {\n                max = array[j];\n            }\n        }\n    \n        return max;\n    }\n\n    \n    public static float max(float[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n\n        \n        float max = array[0];\n        for (int j = 1; j < array.length; j++) {\n            if (Float.isNaN(array[j])) {\n                return Float.NaN;\n            }\n            if (array[j] > max) {\n                max = array[j];\n            }\n        }\n\n        return max;\n    }\n     \n    \n    \n    \n    public static long min(long a, long b, long c) {\n        if (b < a) {\n            a = b;\n        }\n        if (c < a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static int min(int a, int b, int c) {\n        if (b < a) {\n            a = b;\n        }\n        if (c < a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static short min(short a, short b, short c) {\n        if (b < a) {\n            a = b;\n        }\n        if (c < a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static byte min(byte a, byte b, byte c) {\n        if (b < a) {\n            a = b;\n        }\n        if (c < a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static double min(double a, double b, double c) {\n        return Math.min(Math.min(a, b), c);\n    }\n\n    \n    public static float min(float a, float b, float c) {\n        return Math.min(Math.min(a, b), c);\n    }\n\n    \n    \n    \n    public static long max(long a, long b, long c) {\n        if (b > a) {\n            a = b;\n        }\n        if (c > a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static int max(int a, int b, int c) {\n        if (b > a) {\n            a = b;\n        }\n        if (c > a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static short max(short a, short b, short c) {\n        if (b > a) {\n            a = b;\n        }\n        if (c > a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static byte max(byte a, byte b, byte c) {\n        if (b > a) {\n            a = b;\n        }\n        if (c > a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static double max(double a, double b, double c) {\n        return Math.max(Math.max(a, b), c);\n    }\n\n    \n    public static float max(float a, float b, float c) {\n        return Math.max(Math.max(a, b), c);\n    }\n\n    \n    \n    public static boolean isDigits(String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        for (int i = 0; i < str.length(); i++) {\n            if (!Character.isDigit(str.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isNumber(String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        char[] chars = str.toCharArray();\n        int sz = chars.length;\n        boolean hasExp = false;\n        boolean hasDecPoint = false;\n        boolean allowSigns = false;\n        boolean foundDigit = false;\n        \n        int start = (chars[0] == '-') ? 1 : 0;\n        if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') {\n            int i = start + 2;\n            if (i == sz) {\n                return false; \n            }\n            \n            for (; i < chars.length; i++) {\n                if ((chars[i] < '0' || chars[i] > '9')\n                    && (chars[i] < 'a' || chars[i] > 'f')\n                    && (chars[i] < 'A' || chars[i] > 'F')) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        sz--; \n              \n        int i = start;\n        \n        \n        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n            if (chars[i] >= '0' && chars[i] <= '9') {\n                foundDigit = true;\n                allowSigns = false;\n\n            } else if (chars[i] == '.') {\n                if (hasDecPoint || hasExp) {\n                    \n                    return false;\n                }\n                hasDecPoint = true;\n            } else if (chars[i] == 'e' || chars[i] == 'E') {\n                \n                if (hasExp) {\n                    \n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp = true;\n                allowSigns = true;\n            } else if (chars[i] == '+' || chars[i] == '-') {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns = false;\n                foundDigit = false; \n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i < chars.length) {\n            if (chars[i] >= '0' && chars[i] <= '9') {\n                \n                return true;\n            }\n            if (chars[i] == 'e' || chars[i] == 'E') {\n                \n                return false;\n            }\n            if (chars[i] == '.') {\n                if (hasDecPoint || hasExp) {\n                    \n                    return false;\n                }\n                \n                return foundDigit;\n            }\n            if (!allowSigns\n                && (chars[i] == 'd'\n                    || chars[i] == 'D'\n                    || chars[i] == 'f'\n                    || chars[i] == 'F')) {\n                return foundDigit;\n            }\n            if (chars[i] == 'l'\n                || chars[i] == 'L') {\n                \n                return foundDigit && !hasExp && !hasDecPoint;\n            }\n            \n            return false;\n        }\n        \n        \n        return !allowSigns && foundDigit;\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.lang3.math;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport org.apache.commons.lang3.StringUtils;\n\n\npublic class NumberUtils { public static final Long LONG_ZERO = Long.valueOf(0L); public static final Long LONG_ONE = Long.valueOf(1L); public static final Long LONG_MINUS_ONE = Long.valueOf(-1L); public static final Integer INTEGER_ZERO = Integer.valueOf(0); public static final Integer INTEGER_ONE = Integer.valueOf(1); public static final Integer INTEGER_MINUS_ONE = Integer.valueOf(-1); public static final Short SHORT_ZERO = Short.valueOf((short) 0); public static final Short SHORT_ONE = Short.valueOf((short) 1); public static final Short SHORT_MINUS_ONE = Short.valueOf((short) -1); public static final Byte BYTE_ZERO = Byte.valueOf((byte) 0); public static final Byte BYTE_ONE = Byte.valueOf((byte) 1); public static final Byte BYTE_MINUS_ONE = Byte.valueOf((byte) -1); public static final Double DOUBLE_ZERO = Double.valueOf(0.0d); public static final Double DOUBLE_ONE = Double.valueOf(1.0d); public static final Double DOUBLE_MINUS_ONE = Double.valueOf(-1.0d); public static final Float FLOAT_ZERO = Float.valueOf(0.0f); public static final Float FLOAT_ONE = Float.valueOf(1.0f); public static final Float FLOAT_MINUS_ONE = Float.valueOf(-1.0f); public NumberUtils() {\n        super();\n    }\n\n    \n    \n    public static int toInt(String str) {\n        return toInt(str, 0);\n    }\n\n    \n    public static int toInt(String str, int defaultValue) {\n        if(str == null) {\n            return defaultValue;\n        }\n        try {\n            return Integer.parseInt(str);\n        } catch (NumberFormatException nfe) {\n            return defaultValue;\n        }\n    }\n\n    \n    public static long toLong(String str) {\n        return toLong(str, 0L);\n    }\n\n    \n    public static long toLong(String str, long defaultValue) {\n        if (str == null) {\n            return defaultValue;\n        }\n        try {\n            return Long.parseLong(str);\n        } catch (NumberFormatException nfe) {\n            return defaultValue;\n        }\n    }\n\n    \n    public static float toFloat(String str) {\n        return toFloat(str, 0.0f);\n    }\n\n    \n    public static float toFloat(String str, float defaultValue) {\n      if (str == null) {\n          return defaultValue;\n      }     \n      try {\n          return Float.parseFloat(str);\n      } catch (NumberFormatException nfe) {\n          return defaultValue;\n      }\n    }\n\n    \n    public static double toDouble(String str) {\n        return toDouble(str, 0.0d);\n    }\n\n    \n    public static double toDouble(String str, double defaultValue) {\n      if (str == null) {\n          return defaultValue;\n      }\n      try {\n          return Double.parseDouble(str);\n      } catch (NumberFormatException nfe) {\n          return defaultValue;\n      }\n    }\n\n     \n     \n    public static byte toByte(String str) {\n        return toByte(str, (byte) 0);\n    }\n\n    \n    public static byte toByte(String str, byte defaultValue) {\n        if(str == null) {\n            return defaultValue;\n        }\n        try {\n            return Byte.parseByte(str);\n        } catch (NumberFormatException nfe) {\n            return defaultValue;\n        }\n    }\n\n    \n    public static short toShort(String str) {\n        return toShort(str, (short) 0);\n    }\n\n    \n    public static short toShort(String str, short defaultValue) {\n        if(str == null) {\n            return defaultValue;\n        }\n        try {\n            return Short.parseShort(str);\n        } catch (NumberFormatException nfe) {\n            return defaultValue;\n        }\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n            int hexDigits = str.length() - 2; \n            if (str.startsWith(\"-\")) { \n                hexDigits--;\n            }\n            if (hexDigits > 8) { \n                return createLong(str);\n            }\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos || expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            \n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) { \n                            \n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            \n                            \n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) { \n                        \n                    }\n                    \n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) { \n                        \n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) { \n                        \n                    }\n                    \n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            \n            \n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                \n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) { \n                    \n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) { \n                    \n                }\n                return createBigInteger(str);\n\n            } else {\n                \n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { \n                    \n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { \n                    \n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n\n    \n    private static boolean isAllZeros(String str) {\n        if (str == null) {\n            return true;\n        }\n        for (int i = str.length() - 1; i >= 0; i--) {\n            if (str.charAt(i) != '0') {\n                return false;\n            }\n        }\n        return str.length() > 0;\n    }\n\n    \n    \n    public static Float createFloat(String str) {\n        if (str == null) {\n            return null;\n        }\n        return Float.valueOf(str);\n    }\n\n    \n    public static Double createDouble(String str) {\n        if (str == null) {\n            return null;\n        }\n        return Double.valueOf(str);\n    }\n\n    \n    public static Integer createInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        \n        return Integer.decode(str);\n    }\n\n    \n    public static Long createLong(String str) {\n        if (str == null) {\n            return null;\n        }\n        return Long.decode(str);\n    }\n\n    \n    public static BigInteger createBigInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        return new BigInteger(str);\n    }\n\n    \n    public static BigDecimal createBigDecimal(String str) {\n        if (str == null) {\n            return null;\n        }\n        \n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        if (str.trim().startsWith(\"--\")) {\n            \n            \n            \n            \n            throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n        return new BigDecimal(str);\n    }\n\n    \n    \n    \n    public static long min(long[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        long min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n    \n        return min;\n    }\n\n    \n    public static int min(int[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        int min = array[0];\n        for (int j = 1; j < array.length; j++) {\n            if (array[j] < min) {\n                min = array[j];\n            }\n        }\n    \n        return min;\n    }\n\n    \n    public static short min(short[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        short min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n    \n        return min;\n    }\n\n    \n    public static byte min(byte[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        byte min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n    \n        return min;\n    }\n\n     \n    public static double min(double[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        double min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (Double.isNaN(array[i])) {\n                return Double.NaN;\n            }\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n    \n        return min;\n    }\n\n    \n    public static float min(float[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        float min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (Float.isNaN(array[i])) {\n                return Float.NaN;\n            }\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n    \n        return min;\n    }\n\n    \n    \n    \n    public static long max(long[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n\n        \n        long max = array[0];\n        for (int j = 1; j < array.length; j++) {\n            if (array[j] > max) {\n                max = array[j];\n            }\n        }\n\n        return max;\n    }\n\n    \n    public static int max(int[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        int max = array[0];\n        for (int j = 1; j < array.length; j++) {\n            if (array[j] > max) {\n                max = array[j];\n            }\n        }\n    \n        return max;\n    }\n\n    \n    public static short max(short[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        short max = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] > max) {\n                max = array[i];\n            }\n        }\n    \n        return max;\n    }\n\n    \n    public static byte max(byte[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        byte max = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] > max) {\n                max = array[i];\n            }\n        }\n    \n        return max;\n    }\n\n    \n    public static double max(double[] array) {\n        \n        if (array== null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        \n        double max = array[0];\n        for (int j = 1; j < array.length; j++) {\n            if (Double.isNaN(array[j])) {\n                return Double.NaN;\n            }\n            if (array[j] > max) {\n                max = array[j];\n            }\n        }\n    \n        return max;\n    }\n\n    \n    public static float max(float[] array) {\n        \n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n\n        \n        float max = array[0];\n        for (int j = 1; j < array.length; j++) {\n            if (Float.isNaN(array[j])) {\n                return Float.NaN;\n            }\n            if (array[j] > max) {\n                max = array[j];\n            }\n        }\n\n        return max;\n    }\n     \n    \n    \n    \n    public static long min(long a, long b, long c) {\n        if (b < a) {\n            a = b;\n        }\n        if (c < a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static int min(int a, int b, int c) {\n        if (b < a) {\n            a = b;\n        }\n        if (c < a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static short min(short a, short b, short c) {\n        if (b < a) {\n            a = b;\n        }\n        if (c < a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static byte min(byte a, byte b, byte c) {\n        if (b < a) {\n            a = b;\n        }\n        if (c < a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static double min(double a, double b, double c) {\n        return Math.min(Math.min(a, b), c);\n    }\n\n    \n    public static float min(float a, float b, float c) {\n        return Math.min(Math.min(a, b), c);\n    }\n\n    \n    \n    \n    public static long max(long a, long b, long c) {\n        if (b > a) {\n            a = b;\n        }\n        if (c > a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static int max(int a, int b, int c) {\n        if (b > a) {\n            a = b;\n        }\n        if (c > a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static short max(short a, short b, short c) {\n        if (b > a) {\n            a = b;\n        }\n        if (c > a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static byte max(byte a, byte b, byte c) {\n        if (b > a) {\n            a = b;\n        }\n        if (c > a) {\n            a = c;\n        }\n        return a;\n    }\n\n    \n    public static double max(double a, double b, double c) {\n        return Math.max(Math.max(a, b), c);\n    }\n\n    \n    public static float max(float a, float b, float c) {\n        return Math.max(Math.max(a, b), c);\n    }\n\n    \n    \n    public static boolean isDigits(String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        for (int i = 0; i < str.length(); i++) {\n            if (!Character.isDigit(str.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static boolean isNumber(String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        char[] chars = str.toCharArray();\n        int sz = chars.length;\n        boolean hasExp = false;\n        boolean hasDecPoint = false;\n        boolean allowSigns = false;\n        boolean foundDigit = false;\n        \n        int start = (chars[0] == '-') ? 1 : 0;\n        if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') {\n            int i = start + 2;\n            if (i == sz) {\n                return false; \n            }\n            \n            for (; i < chars.length; i++) {\n                if ((chars[i] < '0' || chars[i] > '9')\n                    && (chars[i] < 'a' || chars[i] > 'f')\n                    && (chars[i] < 'A' || chars[i] > 'F')) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        sz--; \n              \n        int i = start;\n        \n        \n        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n            if (chars[i] >= '0' && chars[i] <= '9') {\n                foundDigit = true;\n                allowSigns = false;\n\n            } else if (chars[i] == '.') {\n                if (hasDecPoint || hasExp) {\n                    \n                    return false;\n                }\n                hasDecPoint = true;\n            } else if (chars[i] == 'e' || chars[i] == 'E') {\n                \n                if (hasExp) {\n                    \n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp = true;\n                allowSigns = true;\n            } else if (chars[i] == '+' || chars[i] == '-') {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns = false;\n                foundDigit = false; \n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i < chars.length) {\n            if (chars[i] >= '0' && chars[i] <= '9') {\n                \n                return true;\n            }\n            if (chars[i] == 'e' || chars[i] == 'E') {\n                \n                return false;\n            }\n            if (chars[i] == '.') {\n                if (hasDecPoint || hasExp) {\n                    \n                    return false;\n                }\n                \n                return foundDigit;\n            }\n            if (!allowSigns\n                && (chars[i] == 'd'\n                    || chars[i] == 'D'\n                    || chars[i] == 'f'\n                    || chars[i] == 'F')) {\n                return foundDigit;\n            }\n            if (chars[i] == 'l'\n                || chars[i] == 'L') {\n                \n                return foundDigit && !hasExp && !hasDecPoint;\n            }\n            \n            return false;\n        }\n        \n        \n        return !allowSigns && foundDigit;\n    }\n\n}\n",
      "buggy_signatures": [
        "public static int toInt(String str)",
        "public static int toInt(String str, int defaultValue)",
        "public static long toLong(String str)",
        "public static long toLong(String str, long defaultValue)",
        "public static float toFloat(String str)",
        "public static float toFloat(String str, float defaultValue)",
        "public static double toDouble(String str)",
        "public static double toDouble(String str, double defaultValue)",
        "public static byte toByte(String str)",
        "public static byte toByte(String str, byte defaultValue)",
        "public static short toShort(String str)",
        "public static short toShort(String str, short defaultValue)",
        "public static Number createNumber(String str) throws NumberFormatException",
        "private static boolean isAllZeros(String str)",
        "public static Float createFloat(String str)",
        "public static Double createDouble(String str)",
        "public static Integer createInteger(String str)",
        "public static Long createLong(String str)",
        "public static BigInteger createBigInteger(String str)",
        "public static BigDecimal createBigDecimal(String str)",
        "public static long min(long[] array)",
        "public static int min(int[] array)",
        "public static short min(short[] array)",
        "public static byte min(byte[] array)",
        "public static double min(double[] array)",
        "public static float min(float[] array)",
        "public static long max(long[] array)",
        "public static int max(int[] array)",
        "public static short max(short[] array)",
        "public static byte max(byte[] array)",
        "public static double max(double[] array)",
        "public static float max(float[] array)",
        "public static long min(long a, long b, long c)",
        "public static int min(int a, int b, int c)",
        "public static short min(short a, short b, short c)",
        "public static byte min(byte a, byte b, byte c)",
        "public static double min(double a, double b, double c)",
        "public static float min(float a, float b, float c)",
        "public static long max(long a, long b, long c)",
        "public static int max(int a, int b, int c)",
        "public static short max(short a, short b, short c)",
        "public static byte max(byte a, byte b, byte c)",
        "public static double max(double a, double b, double c)",
        "public static float max(float a, float b, float c)",
        "public static boolean isDigits(String str)",
        "public static boolean isNumber(String str)"
      ],
      "fixed_signatures": [
        "public static int toInt(String str)",
        "public static int toInt(String str, int defaultValue)",
        "public static long toLong(String str)",
        "public static long toLong(String str, long defaultValue)",
        "public static float toFloat(String str)",
        "public static float toFloat(String str, float defaultValue)",
        "public static double toDouble(String str)",
        "public static double toDouble(String str, double defaultValue)",
        "public static byte toByte(String str)",
        "public static byte toByte(String str, byte defaultValue)",
        "public static short toShort(String str)",
        "public static short toShort(String str, short defaultValue)",
        "public static Number createNumber(String str) throws NumberFormatException",
        "private static boolean isAllZeros(String str)",
        "public static Float createFloat(String str)",
        "public static Double createDouble(String str)",
        "public static Integer createInteger(String str)",
        "public static Long createLong(String str)",
        "public static BigInteger createBigInteger(String str)",
        "public static BigDecimal createBigDecimal(String str)",
        "public static long min(long[] array)",
        "public static int min(int[] array)",
        "public static short min(short[] array)",
        "public static byte min(byte[] array)",
        "public static double min(double[] array)",
        "public static float min(float[] array)",
        "public static long max(long[] array)",
        "public static int max(int[] array)",
        "public static short max(short[] array)",
        "public static byte max(byte[] array)",
        "public static double max(double[] array)",
        "public static float max(float[] array)",
        "public static long min(long a, long b, long c)",
        "public static int min(int a, int b, int c)",
        "public static short min(short a, short b, short c)",
        "public static byte min(byte a, byte b, byte c)",
        "public static double min(double a, double b, double c)",
        "public static float min(float a, float b, float c)",
        "public static long max(long a, long b, long c)",
        "public static int max(int a, int b, int c)",
        "public static short max(short a, short b, short c)",
        "public static byte max(byte a, byte b, byte c)",
        "public static double max(double a, double b, double c)",
        "public static float max(float a, float b, float c)",
        "public static boolean isDigits(String str)",
        "public static boolean isNumber(String str)"
      ],
      "methods": [
        {
          "buggy_method": "  public static Number createNumber(String str) throws NumberFormatException {\n  if (str == null) {\n  return null;\n  }\n  if (StringUtils.isBlank(str)) {\n  throw new NumberFormatException(\"A blank string is not a valid number\");\n  }  \n  if (str.startsWith(\"--\")) {\n  return null;\n  }\n  if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n  int hexDigits = str.length() - 2; \n  if (str.startsWith(\"-\")) { \n  hexDigits--;\n  }\n  if (hexDigits > 8) { \n  return createLong(str);\n  }\n  return createInteger(str);\n  }  \n  char lastChar = str.charAt(str.length() - 1);\n  String mant;\n  String dec;\n  String exp;\n  int decPos = str.indexOf('.');\n  int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n  if (decPos > -1) {\n\n  if (expPos > -1) {\n  if (expPos < decPos || expPos > str.length()) {\n  throw new NumberFormatException(str + \" is not a valid number.\");\n  }\n  dec = str.substring(decPos + 1, expPos);\n  } else {\n  dec = str.substring(decPos + 1);\n  }\n  mant = str.substring(0, decPos);\n  } else {\n  if (expPos > -1) {\n  if (expPos > str.length()) {\n  throw new NumberFormatException(str + \" is not a valid number.\");\n  }\n  mant = str.substring(0, expPos);\n  } else {\n  mant = str;\n  }\n  dec = null;\n  }\n  if (!Character.isDigit(lastChar) && lastChar != '.') {\n  if (expPos > -1 && expPos < str.length() - 1) {\n  exp = str.substring(expPos + 1, str.length() - 1);\n  } else {\n  exp = null;\n  }\n  \n  String numeric = str.substring(0, str.length() - 1);\n  boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n  switch (lastChar) {\n  case 'l' :\n  case 'L' :\n  if (dec == null\n  && exp == null\n  && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n  try {\n  return createLong(numeric);\n  } catch (NumberFormatException nfe) { \n  \n  }\n  return createBigInteger(numeric);\n\n  }\n  throw new NumberFormatException(str + \" is not a valid number.\");\n  case 'f' :\n  case 'F' :\n  try {\n  Float f = NumberUtils.createFloat(numeric);\n  if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n  \n  \n  return f;\n  }\n\n  } catch (NumberFormatException nfe) { \n  \n  }\n  \n  case 'd' :\n  case 'D' :\n  try {\n  Double d = NumberUtils.createDouble(numeric);\n  if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n  return d;\n  }\n  } catch (NumberFormatException nfe) { \n  \n  }\n  try {\n  return createBigDecimal(numeric);\n  } catch (NumberFormatException e) { \n  \n  }\n  \n  default :\n  throw new NumberFormatException(str + \" is not a valid number.\");\n\n  }\n  } else {\n  \n  \n  if (expPos > -1 && expPos < str.length() - 1) {\n  exp = str.substring(expPos + 1, str.length());\n  } else {\n  exp = null;\n  }\n  if (dec == null && exp == null) {\n  \n  try {\n  return createInteger(str);\n  } catch (NumberFormatException nfe) { \n  \n  }\n  try {\n  return createLong(str);\n  } catch (NumberFormatException nfe) { \n  \n  }\n  return createBigInteger(str);\n\n  } else {\n  \n  boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n  try {\n  Float f = createFloat(str);\n  if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n  return f;\n  }\n  } catch (NumberFormatException nfe) { \n  \n  }\n  try {\n  Double d = createDouble(str);\n  if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n  return d;\n  }\n  } catch (NumberFormatException nfe) { \n  \n  }\n\n  return createBigDecimal(str);\n\n  }\n  }\n  }",
          "fixed_method": "  public static Number createNumber(String str) throws NumberFormatException {\n  if (str == null) {\n  return null;\n  }\n  if (StringUtils.isBlank(str)) {\n  throw new NumberFormatException(\"A blank string is not a valid number\");\n  }  \n  if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n  int hexDigits = str.length() - 2; \n  if (str.startsWith(\"-\")) { \n  hexDigits--;\n  }\n  if (hexDigits > 8) { \n  return createLong(str);\n  }\n  return createInteger(str);\n  }  \n  char lastChar = str.charAt(str.length() - 1);\n  String mant;\n  String dec;\n  String exp;\n  int decPos = str.indexOf('.');\n  int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n  if (decPos > -1) {\n\n  if (expPos > -1) {\n  if (expPos < decPos || expPos > str.length()) {\n  throw new NumberFormatException(str + \" is not a valid number.\");\n  }\n  dec = str.substring(decPos + 1, expPos);\n  } else {\n  dec = str.substring(decPos + 1);\n  }\n  mant = str.substring(0, decPos);\n  } else {\n  if (expPos > -1) {\n  if (expPos > str.length()) {\n  throw new NumberFormatException(str + \" is not a valid number.\");\n  }\n  mant = str.substring(0, expPos);\n  } else {\n  mant = str;\n  }\n  dec = null;\n  }\n  if (!Character.isDigit(lastChar) && lastChar != '.') {\n  if (expPos > -1 && expPos < str.length() - 1) {\n  exp = str.substring(expPos + 1, str.length() - 1);\n  } else {\n  exp = null;\n  }\n  \n  String numeric = str.substring(0, str.length() - 1);\n  boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n  switch (lastChar) {\n  case 'l' :\n  case 'L' :\n  if (dec == null\n  && exp == null\n  && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n  try {\n  return createLong(numeric);\n  } catch (NumberFormatException nfe) { \n  \n  }\n  return createBigInteger(numeric);\n\n  }\n  throw new NumberFormatException(str + \" is not a valid number.\");\n  case 'f' :\n  case 'F' :\n  try {\n  Float f = NumberUtils.createFloat(numeric);\n  if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n  \n  \n  return f;\n  }\n\n  } catch (NumberFormatException nfe) { \n  \n  }\n  \n  case 'd' :\n  case 'D' :\n  try {\n  Double d = NumberUtils.createDouble(numeric);\n  if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n  return d;\n  }\n  } catch (NumberFormatException nfe) { \n  \n  }\n  try {\n  return createBigDecimal(numeric);\n  } catch (NumberFormatException e) { \n  \n  }\n  \n  default :\n  throw new NumberFormatException(str + \" is not a valid number.\");\n\n  }\n  } else {\n  \n  \n  if (expPos > -1 && expPos < str.length() - 1) {\n  exp = str.substring(expPos + 1, str.length());\n  } else {\n  exp = null;\n  }\n  if (dec == null && exp == null) {\n  \n  try {\n  return createInteger(str);\n  } catch (NumberFormatException nfe) { \n  \n  }\n  try {\n  return createLong(str);\n  } catch (NumberFormatException nfe) { \n  \n  }\n  return createBigInteger(str);\n\n  } else {\n  \n  boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n  try {\n  Float f = createFloat(str);\n  if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n  return f;\n  }\n  } catch (NumberFormatException nfe) { \n  \n  }\n  try {\n  Double d = createDouble(str);\n  if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n  return d;\n  }\n  } catch (NumberFormatException nfe) { \n  \n  }\n\n  return createBigDecimal(str);\n\n  }\n  }\n  }",
          "diff": [
            "@@ -449,9 +449,6 @@",
            "         if (StringUtils.isBlank(str)) {\n",
            "             throw new NumberFormatException(\"A blank string is not a valid number\");\n",
            "         }  \n",
            "-        if (str.startsWith(\"--\")) {\n",
            "-            return null;\n",
            "-        }\n",
            "         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n",
            "             int hexDigits = str.length() - 2; // drop 0x\n",
            "             if (str.startsWith(\"-\")) { // drop -\n"
          ],
          "changed_lines": 3
        },
        {
          "buggy_method": "  public static BigDecimal createBigDecimal(String str) {\n  if (str == null) {\n  return null;\n  }\n  \n  if (StringUtils.isBlank(str)) {\n  throw new NumberFormatException(\"A blank string is not a valid number\");\n  }\n  \n  \n  \n  \n  return new BigDecimal(str);\n  }",
          "fixed_method": "  public static BigDecimal createBigDecimal(String str) {\n  if (str == null) {\n  return null;\n  }\n  \n  if (StringUtils.isBlank(str)) {\n  throw new NumberFormatException(\"A blank string is not a valid number\");\n  }\n  if (str.trim().startsWith(\"--\")) {\n  \n  \n  \n  \n  throw new NumberFormatException(str + \" is not a valid number.\");\n  }\n  return new BigDecimal(str);\n  }",
          "diff": [
            "@@ -718,10 +715,13 @@",
            "         if (StringUtils.isBlank(str)) {\n",
            "             throw new NumberFormatException(\"A blank string is not a valid number\");\n",
            "         }\n",
            "+        if (str.trim().startsWith(\"--\")) {\n",
            "             // this is protection for poorness in java.lang.BigDecimal.\n",
            "             // it accepts this as a legal value, but it does not appear \n",
            "             // to be in specification of class. OS X Java parses it to \n",
            "             // a wrong value.\n",
            "+            throw new NumberFormatException(str + \" is not a valid number.\");\n",
            "+        }\n",
            "         return new BigDecimal(str);\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
