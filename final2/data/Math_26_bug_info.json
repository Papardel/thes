{
  "bug_id": "26",
  "failed_tests": {
    "org.apache.commons.math3.fraction.FractionTest": [
      {
        "methodName": "testIntegerOverflow",
        "error": "junit.framework.AssertionFailedError",
        "message": "an exception should have been thrown",
        "fail_line": "        checkIntegerOverflow(-1.0e10);",
        "test_source": "  public void testIntegerOverflow() {\n  checkIntegerOverflow(0.75000000001455192);\n  checkIntegerOverflow(1.0e10);\n  checkIntegerOverflow(-1.0e10);\n  checkIntegerOverflow(-43979.60679604749);\n  }",
        "stack": [
          "FractionTest.checkIntegerOverflow line 145, FractionTest.testIntegerOverflow line 138"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math3/fraction/Fraction.java",
      "buggy_full_code": "\npackage org.apache.commons.math3.fraction;\n\nimport java.io.Serializable;\nimport java.math.BigInteger;\n\nimport org.apache.commons.math3.FieldElement;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.exception.MathArithmeticException;\nimport org.apache.commons.math3.exception.NullArgumentException;\nimport org.apache.commons.math3.util.ArithmeticUtils;\nimport org.apache.commons.math3.util.FastMath;\n\n\npublic class Fraction extends Number implements FieldElement<Fraction>, Comparable<Fraction>, Serializable { public static final Fraction TWO = new Fraction(2, 1); public static final Fraction ONE = new Fraction(1, 1); public static final Fraction ZERO = new Fraction(0, 1); public static final Fraction FOUR_FIFTHS = new Fraction(4, 5); public static final Fraction ONE_FIFTH = new Fraction(1, 5); public static final Fraction ONE_HALF = new Fraction(1, 2); public static final Fraction ONE_QUARTER = new Fraction(1, 4); public static final Fraction ONE_THIRD = new Fraction(1, 3); public static final Fraction THREE_FIFTHS = new Fraction(3, 5); public static final Fraction THREE_QUARTERS = new Fraction(3, 4); public static final Fraction TWO_FIFTHS = new Fraction(2, 5); public static final Fraction TWO_QUARTERS = new Fraction(2, 4); public static final Fraction TWO_THIRDS = new Fraction(2, 3); public static final Fraction MINUS_ONE = new Fraction(-1, 1); private static final long serialVersionUID = 3698073679419233275L; private final int denominator; private final int numerator; public Fraction(double value) throws FractionConversionException {\n        this(value, 1.0e-5, 100);\n    }\n\n    \n    public Fraction(double value, double epsilon, int maxIterations) throws FractionConversionException {\n        this(value, epsilon, Integer.MAX_VALUE, maxIterations);\n    }\n\n    \n    public Fraction(double value, int maxDenominator) throws FractionConversionException {\n       this(value, 0, maxDenominator, 100);\n    }\n\n    \n    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long)FastMath.floor(r0);\n        if (a0 > overflow) {\n            throw new FractionConversionException(value, a0, 1l);\n        }\n\n        \n        \n        if (FastMath.abs(a0 - value) < epsilon) {\n            this.numerator = (int) a0;\n            this.denominator = 1;\n            return;\n        }\n\n        long p0 = 1;\n        long q0 = 0;\n        long p1 = a0;\n        long q1 = 1;\n\n        long p2 = 0;\n        long q2 = 1;\n\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            double r1 = 1.0 / (r0 - a0);\n            long a1 = (long)FastMath.floor(r1);\n            p2 = (a1 * p1) + p0;\n            q2 = (a1 * q1) + q0;\n            if ((p2 > overflow) || (q2 > overflow)) {\n                throw new FractionConversionException(value, p2, q2);\n            }\n\n            double convergent = (double)p2 / (double)q2;\n            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n                p0 = p1;\n                p1 = p2;\n                q0 = q1;\n                q1 = q2;\n                a0 = a1;\n                r0 = r1;\n            } else {\n                stop = true;\n            }\n        } while (!stop);\n\n        if (n >= maxIterations) {\n            throw new FractionConversionException(value, maxIterations);\n        }\n\n        if (q2 < maxDenominator) {\n            this.numerator = (int) p2;\n            this.denominator = (int) q2;\n        } else {\n            this.numerator = (int) p1;\n            this.denominator = (int) q1;\n        }\n\n    }\n\n    \n    public Fraction(int num) {\n        this(num, 1);\n    }\n\n    \n    public Fraction(int num, int den) {\n        if (den == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION,\n                                              num, den);\n        }\n        if (den < 0) {\n            if (num == Integer.MIN_VALUE ||\n                den == Integer.MIN_VALUE) {\n                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION,\n                                                  num, den);\n            }\n            num = -num;\n            den = -den;\n        }\n        \n        final int d = ArithmeticUtils.gcd(num, den);\n        if (d > 1) {\n            num /= d;\n            den /= d;\n        }\n\n        \n        if (den < 0) {\n            num = -num;\n            den = -den;\n        }\n        this.numerator   = num;\n        this.denominator = den;\n    }\n\n    \n    public Fraction abs() {\n        Fraction ret;\n        if (numerator >= 0) {\n            ret = this;\n        } else {\n            ret = negate();\n        }\n        return ret;\n    }\n\n    \n    public int compareTo(Fraction object) {\n        long nOd = ((long) numerator) * object.denominator;\n        long dOn = ((long) denominator) * object.numerator;\n        return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n    }\n\n    \n    @Override\n    public double doubleValue() {\n        return (double)numerator / (double)denominator;\n    }\n\n    \n    @Override\n    public boolean equals(Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other instanceof Fraction) {\n            \n            \n            Fraction rhs = (Fraction)other;\n            return (numerator == rhs.numerator) &&\n                (denominator == rhs.denominator);\n        }\n        return false;\n    }\n\n    \n    @Override\n    public float floatValue() {\n        return (float)doubleValue();\n    }\n\n    \n    public int getDenominator() {\n        return denominator;\n    }\n\n    \n    public int getNumerator() {\n        return numerator;\n    }\n\n    \n    @Override\n    public int hashCode() {\n        return 37 * (37 * 17 + numerator) + denominator;\n    }\n\n    \n    @Override\n    public int intValue() {\n        return (int)doubleValue();\n    }\n\n    \n    @Override\n    public long longValue() {\n        return (long)doubleValue();\n    }\n\n    \n    public Fraction negate() {\n        if (numerator==Integer.MIN_VALUE) {\n            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION, numerator, denominator);\n        }\n        return new Fraction(-numerator, denominator);\n    }\n\n    \n    public Fraction reciprocal() {\n        return new Fraction(denominator, numerator);\n    }\n\n    \n    public Fraction add(Fraction fraction) {\n        return addSub(fraction, true );\n    }\n\n    \n    public Fraction add(final int i) {\n        return new Fraction(numerator + i * denominator, denominator);\n    }\n\n    \n    public Fraction subtract(Fraction fraction) {\n        return addSub(fraction, false );\n    }\n\n    \n    public Fraction subtract(final int i) {\n        return new Fraction(numerator - i * denominator, denominator);\n    }\n\n    \n    private Fraction addSub(Fraction fraction, boolean isAdd) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        \n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }\n        \n        \n        int d1 = ArithmeticUtils.gcd(denominator, fraction.denominator);\n        if (d1==1) {\n            \n            int uvp = ArithmeticUtils.mulAndCheck(numerator, fraction.denominator);\n            int upv = ArithmeticUtils.mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? ArithmeticUtils.addAndCheck(uvp, upv) :\n                 ArithmeticUtils.subAndCheck(uvp, upv),\n                 ArithmeticUtils.mulAndCheck(denominator, fraction.denominator));\n        }\n        \n        \n        \n        BigInteger uvp = BigInteger.valueOf(numerator)\n        .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        BigInteger upv = BigInteger.valueOf(fraction.numerator)\n        .multiply(BigInteger.valueOf(denominator/d1));\n        BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);\n        \n        \n        int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        int d2 = (tmodd1==0)?d1:ArithmeticUtils.gcd(tmodd1, d1);\n\n        \n        BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new MathArithmeticException(LocalizedFormats.NUMERATOR_OVERFLOW_AFTER_MULTIPLY,\n                                              w);\n        }\n        return new Fraction (w.intValue(),\n                ArithmeticUtils.mulAndCheck(denominator/d1,\n                        fraction.denominator/d2));\n    }\n\n    \n    public Fraction multiply(Fraction fraction) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        if (numerator == 0 || fraction.numerator == 0) {\n            return ZERO;\n        }\n        \n        \n        int d1 = ArithmeticUtils.gcd(numerator, fraction.denominator);\n        int d2 = ArithmeticUtils.gcd(fraction.numerator, denominator);\n        return getReducedFraction\n        (ArithmeticUtils.mulAndCheck(numerator/d1, fraction.numerator/d2),\n                ArithmeticUtils.mulAndCheck(denominator/d2, fraction.denominator/d1));\n    }\n\n    \n    public Fraction multiply(final int i) {\n        return new Fraction(numerator * i, denominator);\n    }\n\n    \n    public Fraction divide(Fraction fraction) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        if (fraction.numerator == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_FRACTION_TO_DIVIDE_BY,\n                                              fraction.numerator, fraction.denominator);\n        }\n        return multiply(fraction.reciprocal());\n    }\n\n    \n    public Fraction divide(final int i) {\n        return new Fraction(numerator, denominator * i);\n    }\n\n    \n    public double percentageValue() {\n        return 100 * doubleValue();\n    }\n\n    \n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION,\n                                              numerator, denominator);\n        }\n        if (numerator==0) {\n            return ZERO; \n        }\n        \n        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n            numerator/=2; denominator/=2;\n        }\n        if (denominator < 0) {\n            if (numerator==Integer.MIN_VALUE ||\n                    denominator==Integer.MIN_VALUE) {\n                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION,\n                                                  numerator, denominator);\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        \n        int gcd = ArithmeticUtils.gcd(numerator, denominator);\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }\n\n    \n    @Override\n    public String toString() {\n        String str = null;\n        if (denominator == 1) {\n            str = Integer.toString(numerator);\n        } else if (numerator == 0) {\n            str = \"0\";\n        } else {\n            str = numerator + \" / \" + denominator;\n        }\n        return str;\n    }\n\n    \n    public FractionField getField() {\n        return FractionField.getInstance();\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.math3.fraction;\n\nimport java.io.Serializable;\nimport java.math.BigInteger;\n\nimport org.apache.commons.math3.FieldElement;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.exception.MathArithmeticException;\nimport org.apache.commons.math3.exception.NullArgumentException;\nimport org.apache.commons.math3.util.ArithmeticUtils;\nimport org.apache.commons.math3.util.FastMath;\n\n\npublic class Fraction extends Number implements FieldElement<Fraction>, Comparable<Fraction>, Serializable { public static final Fraction TWO = new Fraction(2, 1); public static final Fraction ONE = new Fraction(1, 1); public static final Fraction ZERO = new Fraction(0, 1); public static final Fraction FOUR_FIFTHS = new Fraction(4, 5); public static final Fraction ONE_FIFTH = new Fraction(1, 5); public static final Fraction ONE_HALF = new Fraction(1, 2); public static final Fraction ONE_QUARTER = new Fraction(1, 4); public static final Fraction ONE_THIRD = new Fraction(1, 3); public static final Fraction THREE_FIFTHS = new Fraction(3, 5); public static final Fraction THREE_QUARTERS = new Fraction(3, 4); public static final Fraction TWO_FIFTHS = new Fraction(2, 5); public static final Fraction TWO_QUARTERS = new Fraction(2, 4); public static final Fraction TWO_THIRDS = new Fraction(2, 3); public static final Fraction MINUS_ONE = new Fraction(-1, 1); private static final long serialVersionUID = 3698073679419233275L; private final int denominator; private final int numerator; public Fraction(double value) throws FractionConversionException {\n        this(value, 1.0e-5, 100);\n    }\n\n    \n    public Fraction(double value, double epsilon, int maxIterations) throws FractionConversionException {\n        this(value, epsilon, Integer.MAX_VALUE, maxIterations);\n    }\n\n    \n    public Fraction(double value, int maxDenominator) throws FractionConversionException {\n       this(value, 0, maxDenominator, 100);\n    }\n\n    \n    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long)FastMath.floor(r0);\n        if (FastMath.abs(a0) > overflow) {\n            throw new FractionConversionException(value, a0, 1l);\n        }\n\n        \n        \n        if (FastMath.abs(a0 - value) < epsilon) {\n            this.numerator = (int) a0;\n            this.denominator = 1;\n            return;\n        }\n\n        long p0 = 1;\n        long q0 = 0;\n        long p1 = a0;\n        long q1 = 1;\n\n        long p2 = 0;\n        long q2 = 1;\n\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            double r1 = 1.0 / (r0 - a0);\n            long a1 = (long)FastMath.floor(r1);\n            p2 = (a1 * p1) + p0;\n            q2 = (a1 * q1) + q0;\n            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n                throw new FractionConversionException(value, p2, q2);\n            }\n\n            double convergent = (double)p2 / (double)q2;\n            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n                p0 = p1;\n                p1 = p2;\n                q0 = q1;\n                q1 = q2;\n                a0 = a1;\n                r0 = r1;\n            } else {\n                stop = true;\n            }\n        } while (!stop);\n\n        if (n >= maxIterations) {\n            throw new FractionConversionException(value, maxIterations);\n        }\n\n        if (q2 < maxDenominator) {\n            this.numerator = (int) p2;\n            this.denominator = (int) q2;\n        } else {\n            this.numerator = (int) p1;\n            this.denominator = (int) q1;\n        }\n\n    }\n\n    \n    public Fraction(int num) {\n        this(num, 1);\n    }\n\n    \n    public Fraction(int num, int den) {\n        if (den == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION,\n                                              num, den);\n        }\n        if (den < 0) {\n            if (num == Integer.MIN_VALUE ||\n                den == Integer.MIN_VALUE) {\n                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION,\n                                                  num, den);\n            }\n            num = -num;\n            den = -den;\n        }\n        \n        final int d = ArithmeticUtils.gcd(num, den);\n        if (d > 1) {\n            num /= d;\n            den /= d;\n        }\n\n        \n        if (den < 0) {\n            num = -num;\n            den = -den;\n        }\n        this.numerator   = num;\n        this.denominator = den;\n    }\n\n    \n    public Fraction abs() {\n        Fraction ret;\n        if (numerator >= 0) {\n            ret = this;\n        } else {\n            ret = negate();\n        }\n        return ret;\n    }\n\n    \n    public int compareTo(Fraction object) {\n        long nOd = ((long) numerator) * object.denominator;\n        long dOn = ((long) denominator) * object.numerator;\n        return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n    }\n\n    \n    @Override\n    public double doubleValue() {\n        return (double)numerator / (double)denominator;\n    }\n\n    \n    @Override\n    public boolean equals(Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other instanceof Fraction) {\n            \n            \n            Fraction rhs = (Fraction)other;\n            return (numerator == rhs.numerator) &&\n                (denominator == rhs.denominator);\n        }\n        return false;\n    }\n\n    \n    @Override\n    public float floatValue() {\n        return (float)doubleValue();\n    }\n\n    \n    public int getDenominator() {\n        return denominator;\n    }\n\n    \n    public int getNumerator() {\n        return numerator;\n    }\n\n    \n    @Override\n    public int hashCode() {\n        return 37 * (37 * 17 + numerator) + denominator;\n    }\n\n    \n    @Override\n    public int intValue() {\n        return (int)doubleValue();\n    }\n\n    \n    @Override\n    public long longValue() {\n        return (long)doubleValue();\n    }\n\n    \n    public Fraction negate() {\n        if (numerator==Integer.MIN_VALUE) {\n            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION, numerator, denominator);\n        }\n        return new Fraction(-numerator, denominator);\n    }\n\n    \n    public Fraction reciprocal() {\n        return new Fraction(denominator, numerator);\n    }\n\n    \n    public Fraction add(Fraction fraction) {\n        return addSub(fraction, true );\n    }\n\n    \n    public Fraction add(final int i) {\n        return new Fraction(numerator + i * denominator, denominator);\n    }\n\n    \n    public Fraction subtract(Fraction fraction) {\n        return addSub(fraction, false );\n    }\n\n    \n    public Fraction subtract(final int i) {\n        return new Fraction(numerator - i * denominator, denominator);\n    }\n\n    \n    private Fraction addSub(Fraction fraction, boolean isAdd) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        \n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }\n        \n        \n        int d1 = ArithmeticUtils.gcd(denominator, fraction.denominator);\n        if (d1==1) {\n            \n            int uvp = ArithmeticUtils.mulAndCheck(numerator, fraction.denominator);\n            int upv = ArithmeticUtils.mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? ArithmeticUtils.addAndCheck(uvp, upv) :\n                 ArithmeticUtils.subAndCheck(uvp, upv),\n                 ArithmeticUtils.mulAndCheck(denominator, fraction.denominator));\n        }\n        \n        \n        \n        BigInteger uvp = BigInteger.valueOf(numerator)\n        .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        BigInteger upv = BigInteger.valueOf(fraction.numerator)\n        .multiply(BigInteger.valueOf(denominator/d1));\n        BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);\n        \n        \n        int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        int d2 = (tmodd1==0)?d1:ArithmeticUtils.gcd(tmodd1, d1);\n\n        \n        BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new MathArithmeticException(LocalizedFormats.NUMERATOR_OVERFLOW_AFTER_MULTIPLY,\n                                              w);\n        }\n        return new Fraction (w.intValue(),\n                ArithmeticUtils.mulAndCheck(denominator/d1,\n                        fraction.denominator/d2));\n    }\n\n    \n    public Fraction multiply(Fraction fraction) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        if (numerator == 0 || fraction.numerator == 0) {\n            return ZERO;\n        }\n        \n        \n        int d1 = ArithmeticUtils.gcd(numerator, fraction.denominator);\n        int d2 = ArithmeticUtils.gcd(fraction.numerator, denominator);\n        return getReducedFraction\n        (ArithmeticUtils.mulAndCheck(numerator/d1, fraction.numerator/d2),\n                ArithmeticUtils.mulAndCheck(denominator/d2, fraction.denominator/d1));\n    }\n\n    \n    public Fraction multiply(final int i) {\n        return new Fraction(numerator * i, denominator);\n    }\n\n    \n    public Fraction divide(Fraction fraction) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        if (fraction.numerator == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_FRACTION_TO_DIVIDE_BY,\n                                              fraction.numerator, fraction.denominator);\n        }\n        return multiply(fraction.reciprocal());\n    }\n\n    \n    public Fraction divide(final int i) {\n        return new Fraction(numerator, denominator * i);\n    }\n\n    \n    public double percentageValue() {\n        return 100 * doubleValue();\n    }\n\n    \n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION,\n                                              numerator, denominator);\n        }\n        if (numerator==0) {\n            return ZERO; \n        }\n        \n        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n            numerator/=2; denominator/=2;\n        }\n        if (denominator < 0) {\n            if (numerator==Integer.MIN_VALUE ||\n                    denominator==Integer.MIN_VALUE) {\n                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION,\n                                                  numerator, denominator);\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        \n        int gcd = ArithmeticUtils.gcd(numerator, denominator);\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }\n\n    \n    @Override\n    public String toString() {\n        String str = null;\n        if (denominator == 1) {\n            str = Integer.toString(numerator);\n        } else if (numerator == 0) {\n            str = \"0\";\n        } else {\n            str = numerator + \" / \" + denominator;\n        }\n        return str;\n    }\n\n    \n    public FractionField getField() {\n        return FractionField.getInstance();\n    }\n\n}\n",
      "buggy_signatures": [
        "public Fraction(double value, double epsilon, int maxIterations) throws FractionConversionException",
        "public Fraction(double value, int maxDenominator) throws FractionConversionException",
        "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException",
        "public Fraction(int num)",
        "public Fraction(int num, int den)",
        "public Fraction abs()",
        "public int compareTo(Fraction object)",
        "public double doubleValue()",
        "public boolean equals(Object other)",
        "public float floatValue()",
        "public int getDenominator()",
        "public int getNumerator()",
        "public int hashCode()",
        "public int intValue()",
        "public long longValue()",
        "public Fraction negate()",
        "public Fraction reciprocal()",
        "public Fraction add(Fraction fraction)",
        "public Fraction add(final int i)",
        "public Fraction subtract(Fraction fraction)",
        "public Fraction subtract(final int i)",
        "private Fraction addSub(Fraction fraction, boolean isAdd)",
        "public Fraction multiply(Fraction fraction)",
        "public Fraction multiply(final int i)",
        "public Fraction divide(Fraction fraction)",
        "public Fraction divide(final int i)",
        "public double percentageValue()",
        "public static Fraction getReducedFraction(int numerator, int denominator)",
        "public String toString()",
        "public FractionField getField()"
      ],
      "fixed_signatures": [
        "public Fraction(double value, double epsilon, int maxIterations) throws FractionConversionException",
        "public Fraction(double value, int maxDenominator) throws FractionConversionException",
        "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException",
        "public Fraction(int num)",
        "public Fraction(int num, int den)",
        "public Fraction abs()",
        "public int compareTo(Fraction object)",
        "public double doubleValue()",
        "public boolean equals(Object other)",
        "public float floatValue()",
        "public int getDenominator()",
        "public int getNumerator()",
        "public int hashCode()",
        "public int intValue()",
        "public long longValue()",
        "public Fraction negate()",
        "public Fraction reciprocal()",
        "public Fraction add(Fraction fraction)",
        "public Fraction add(final int i)",
        "public Fraction subtract(Fraction fraction)",
        "public Fraction subtract(final int i)",
        "private Fraction addSub(Fraction fraction, boolean isAdd)",
        "public Fraction multiply(Fraction fraction)",
        "public Fraction multiply(final int i)",
        "public Fraction divide(Fraction fraction)",
        "public Fraction divide(final int i)",
        "public double percentageValue()",
        "public static Fraction getReducedFraction(int numerator, int denominator)",
        "public String toString()",
        "public FractionField getField()"
      ],
      "methods": [
        {
          "buggy_method": "  private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n  long overflow = Integer.MAX_VALUE;\n  double r0 = value;\n  long a0 = (long)FastMath.floor(r0);\n  if (a0 > overflow) {\n  throw new FractionConversionException(value, a0, 1l);\n  }\n\n  \n  \n  if (FastMath.abs(a0 - value) < epsilon) {\n  this.numerator = (int) a0;\n  this.denominator = 1;\n  return;\n  }\n\n  long p0 = 1;\n  long q0 = 0;\n  long p1 = a0;\n  long q1 = 1;\n\n  long p2 = 0;\n  long q2 = 1;\n\n  int n = 0;\n  boolean stop = false;\n  do {\n  ++n;\n  double r1 = 1.0 / (r0 - a0);\n  long a1 = (long)FastMath.floor(r1);\n  p2 = (a1 * p1) + p0;\n  q2 = (a1 * q1) + q0;\n  if ((p2 > overflow) || (q2 > overflow)) {\n  throw new FractionConversionException(value, p2, q2);\n  }\n\n  double convergent = (double)p2 / (double)q2;\n  if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n  p0 = p1;\n  p1 = p2;\n  q0 = q1;\n  q1 = q2;\n  a0 = a1;\n  r0 = r1;\n  } else {\n  stop = true;\n  }\n  } while (!stop);\n\n  if (n >= maxIterations) {\n  throw new FractionConversionException(value, maxIterations);\n  }\n\n  if (q2 < maxDenominator) {\n  this.numerator = (int) p2;\n  this.denominator = (int) q2;\n  } else {\n  this.numerator = (int) p1;\n  this.denominator = (int) q1;\n  }\n\n  }",
          "fixed_method": "  private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n  long overflow = Integer.MAX_VALUE;\n  double r0 = value;\n  long a0 = (long)FastMath.floor(r0);\n  if (FastMath.abs(a0) > overflow) {\n  throw new FractionConversionException(value, a0, 1l);\n  }\n\n  \n  \n  if (FastMath.abs(a0 - value) < epsilon) {\n  this.numerator = (int) a0;\n  this.denominator = 1;\n  return;\n  }\n\n  long p0 = 1;\n  long q0 = 0;\n  long p1 = a0;\n  long q1 = 1;\n\n  long p2 = 0;\n  long q2 = 1;\n\n  int n = 0;\n  boolean stop = false;\n  do {\n  ++n;\n  double r1 = 1.0 / (r0 - a0);\n  long a1 = (long)FastMath.floor(r1);\n  p2 = (a1 * p1) + p0;\n  q2 = (a1 * q1) + q0;\n  if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n  throw new FractionConversionException(value, p2, q2);\n  }\n\n  double convergent = (double)p2 / (double)q2;\n  if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n  p0 = p1;\n  p1 = p2;\n  q0 = q1;\n  q1 = q2;\n  a0 = a1;\n  r0 = r1;\n  } else {\n  stop = true;\n  }\n  } while (!stop);\n\n  if (n >= maxIterations) {\n  throw new FractionConversionException(value, maxIterations);\n  }\n\n  if (q2 < maxDenominator) {\n  this.numerator = (int) p2;\n  this.denominator = (int) q2;\n  } else {\n  this.numerator = (int) p1;\n  this.denominator = (int) q1;\n  }\n\n  }",
          "diff": [
            "@@ -178,7 +178,7 @@",
            "         long overflow = Integer.MAX_VALUE;\n",
            "         double r0 = value;\n",
            "         long a0 = (long)FastMath.floor(r0);\n",
            "-        if (a0 > overflow) {\n",
            "+        if (FastMath.abs(a0) > overflow) {\n",
            "             throw new FractionConversionException(value, a0, 1l);\n",
            "         }\n",
            " \n",
            "@@ -206,7 +206,7 @@",
            "             long a1 = (long)FastMath.floor(r1);\n",
            "             p2 = (a1 * p1) + p0;\n",
            "             q2 = (a1 * q1) + q0;\n",
            "-            if ((p2 > overflow) || (q2 > overflow)) {\n",
            "+            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n",
            "                 throw new FractionConversionException(value, p2, q2);\n",
            "             }\n",
            " \n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
