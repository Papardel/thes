{
  "bug_id": "15",
  "failed_tests": {
    "org.apache.commons.lang3.reflect.TypeUtilsTest": [
      {
        "methodName": "testGetTypeArguments",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<2> but was:<0>",
        "fail_line": "        Assert.assertEquals(2, typeVarAssigns.size());",
        "test_source": "  public void testGetTypeArguments() {\n  Map<TypeVariable<?>, Type> typeVarAssigns;\n  TypeVariable<?> treeSetTypeVar;\n  Type typeArg;\n\n  typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class);\n  treeSetTypeVar = Comparable.class.getTypeParameters()[0];\n  Assert.assertTrue(\"Type var assigns for Comparable from Integer: \" + typeVarAssigns,\n  typeVarAssigns.containsKey(treeSetTypeVar));\n  typeArg = typeVarAssigns.get(treeSetTypeVar);\n  Assert.assertEquals(\"Type argument of Comparable from Integer: \" + typeArg, Integer.class,\n  typeVarAssigns.get(treeSetTypeVar));\n\n  typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class);\n  treeSetTypeVar = Comparable.class.getTypeParameters()[0];\n  Assert.assertTrue(\"Type var assigns for Comparable from int: \" + typeVarAssigns,\n  typeVarAssigns.containsKey(treeSetTypeVar));\n  typeArg = typeVarAssigns.get(treeSetTypeVar);\n  Assert.assertEquals(\"Type argument of Comparable from int: \" + typeArg, Integer.class,\n  typeVarAssigns.get(treeSetTypeVar));\n\n  Collection<Integer> col = Arrays.asList(new Integer[0]);\n  typeVarAssigns = TypeUtils.getTypeArguments(List.class, Collection.class);\n  treeSetTypeVar = Comparable.class.getTypeParameters()[0];\n  Assert.assertFalse(\"Type var assigns for Collection from List: \" + typeVarAssigns,\n  typeVarAssigns.containsKey(treeSetTypeVar));\n\n  typeVarAssigns = TypeUtils.getTypeArguments(AAAClass.BBBClass.class, AAClass.BBClass.class);\n  Assert.assertTrue(typeVarAssigns.size() == 2);\n  Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.class.getTypeParameters()[0]));\n  Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.BBClass.class.getTypeParameters()[0]));\n\n  typeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class);\n  Assert.assertEquals(2, typeVarAssigns.size());\n  Assert.assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0]));\n  Assert.assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1]));\n  }",
        "stack": [
          "TypeUtilsTest.testGetTypeArguments line 505"
        ]
      },
      {
        "methodName": "testIsAssignable",
        "error": "junit.framework.AssertionFailedError",
        "message": "type class org.apache.commons.lang3.reflect.TypeUtilsTest$Thing not assignable to org.apache.commons.lang3.reflect.TypeUtilsTest$This<java.lang.String, java.lang.String>!",
        "fail_line": "        Assert.assertFalse(String.format(\"type %s not assignable to %s!\", dingType, disType),",
        "test_source": "  public void testIsAssignable() throws SecurityException, NoSuchMethodException, NoSuchFieldException {\n  List list0 = null;\n  List<Object> list1 = null;\n  List<?> list2 = null;\n  List<? super Object> list3 = null;\n  List<String> list4 = null;\n  List<? extends String> list5 = null;\n  List<? super String> list6 = null;\n  List[] list7 = null;\n  List<Object>[] list8 = null;\n  List<?>[] list9 = null;\n  List<? super Object>[] list10 = null;\n  List<String>[] list11 = null;\n  List<? extends String>[] list12 = null;\n  List<? super String>[] list13;\n  Class<?> clazz = getClass();\n  Method method = clazz.getMethod(\"dummyMethod\", List.class, List.class, List.class,\n  List.class, List.class, List.class, List.class, List[].class, List[].class,\n  List[].class, List[].class, List[].class, List[].class, List[].class);\n  Type[] types = method.getGenericParameterTypes();\n//  list0 = list0;\n  delegateBooleanAssertion(types, 0, 0, true);\n  list1 = list0;\n  delegateBooleanAssertion(types, 0, 1, true);\n  list0 = list1;\n  delegateBooleanAssertion(types, 1, 0, true);\n  list2 = list0;\n  delegateBooleanAssertion(types, 0, 2, true);\n  list0 = list2;\n  delegateBooleanAssertion(types, 2, 0, true);\n  list3 = list0;\n  delegateBooleanAssertion(types, 0, 3, true);\n  list0 = list3;\n  delegateBooleanAssertion(types, 3, 0, true);\n  list4 = list0;\n  delegateBooleanAssertion(types, 0, 4, true);\n  list0 = list4;\n  delegateBooleanAssertion(types, 4, 0, true);\n  list5 = list0;\n  delegateBooleanAssertion(types, 0, 5, true);\n  list0 = list5;\n  delegateBooleanAssertion(types, 5, 0, true);\n  list6 = list0;\n  delegateBooleanAssertion(types, 0, 6, true);\n  list0 = list6;\n  delegateBooleanAssertion(types, 6, 0, true);\n//  list1 = list1;\n  delegateBooleanAssertion(types, 1, 1, true);\n  list2 = list1;\n  delegateBooleanAssertion(types, 1, 2, true);\n  list1 = (List<Object>) list2;\n  delegateBooleanAssertion(types, 2, 1, false);\n  list3 = list1;\n  delegateBooleanAssertion(types, 1, 3, true);\n  list1 = (List<Object>) list3;\n  delegateBooleanAssertion(types, 3, 1, false);\n  // list4 = list1;\n  delegateBooleanAssertion(types, 1, 4, false);\n  // list1 = list4;\n  delegateBooleanAssertion(types, 4, 1, false);\n  // list5 = list1;\n  delegateBooleanAssertion(types, 1, 5, false);\n  // list1 = list5;\n  delegateBooleanAssertion(types, 5, 1, false);\n  list6 = list1;\n  delegateBooleanAssertion(types, 1, 6, true);\n  list1 = (List<Object>) list6;\n  delegateBooleanAssertion(types, 6, 1, false);\n//  list2 = list2;\n  delegateBooleanAssertion(types, 2, 2, true);\n  list2 = list3;\n  delegateBooleanAssertion(types, 2, 3, false);\n  list2 = list4;\n  delegateBooleanAssertion(types, 3, 2, true);\n  list3 = (List<? super Object>) list2;\n  delegateBooleanAssertion(types, 2, 4, false);\n  list2 = list5;\n  delegateBooleanAssertion(types, 4, 2, true);\n  list4 = (List<String>) list2;\n  delegateBooleanAssertion(types, 2, 5, false);\n  list2 = list6;\n  delegateBooleanAssertion(types, 5, 2, true);\n  list5 = (List<? extends String>) list2;\n  delegateBooleanAssertion(types, 2, 6, false);\n//  list3 = list3;\n  delegateBooleanAssertion(types, 6, 2, true);\n  list6 = (List<? super String>) list2;\n  delegateBooleanAssertion(types, 3, 3, true);\n  // list4 = list3;\n  delegateBooleanAssertion(types, 3, 4, false);\n  // list3 = list4;\n  delegateBooleanAssertion(types, 4, 3, false);\n  // list5 = list3;\n  delegateBooleanAssertion(types, 3, 5, false);\n  // list3 = list5;\n  delegateBooleanAssertion(types, 5, 3, false);\n  list6 = list3;\n  delegateBooleanAssertion(types, 3, 6, true);\n  list3 = (List<? super Object>) list6;\n  delegateBooleanAssertion(types, 6, 3, false);\n//  list4 = list4;\n  delegateBooleanAssertion(types, 4, 4, true);\n  list5 = list4;\n  delegateBooleanAssertion(types, 4, 5, true);\n  list4 = (List<String>) list5;\n  delegateBooleanAssertion(types, 5, 4, false);\n  list6 = list4;\n  delegateBooleanAssertion(types, 4, 6, true);\n  list4 = (List<String>) list6;\n  delegateBooleanAssertion(types, 6, 4, false);\n//  list5 = list5;\n  delegateBooleanAssertion(types, 5, 5, true);\n  list6 = (List<? super String>) list5;\n  delegateBooleanAssertion(types, 5, 6, false);\n  list5 = (List<? extends String>) list6;\n  delegateBooleanAssertion(types, 6, 5, false);\n//  list6 = list6;\n  delegateBooleanAssertion(types, 6, 6, true);\n\n//  list7 = list7;\n  delegateBooleanAssertion(types, 7, 7, true);\n  list8 = list7;\n  delegateBooleanAssertion(types, 7, 8, true);\n  list7 = list8;\n  delegateBooleanAssertion(types, 8, 7, true);\n  list9 = list7;\n  delegateBooleanAssertion(types, 7, 9, true);\n  list7 = list9;\n  delegateBooleanAssertion(types, 9, 7, true);\n  list10 = list7;\n  delegateBooleanAssertion(types, 7, 10, true);\n  list7 = list10;\n  delegateBooleanAssertion(types, 10, 7, true);\n  list11 = list7;\n  delegateBooleanAssertion(types, 7, 11, true);\n  list7 = list11;\n  delegateBooleanAssertion(types, 11, 7, true);\n  list12 = list7;\n  delegateBooleanAssertion(types, 7, 12, true);\n  list7 = list12;\n  delegateBooleanAssertion(types, 12, 7, true);\n  list13 = list7;\n  delegateBooleanAssertion(types, 7, 13, true);\n  list7 = list13;\n  delegateBooleanAssertion(types, 13, 7, true);\n//  list8 = list8;\n  delegateBooleanAssertion(types, 8, 8, true);\n  list9 = list8;\n  delegateBooleanAssertion(types, 8, 9, true);\n  list8 = (List<Object>[]) list9;\n  delegateBooleanAssertion(types, 9, 8, false);\n  list10 = list8;\n  delegateBooleanAssertion(types, 8, 10, true);\n  list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse\n  delegateBooleanAssertion(types, 10, 8, false);\n  // list11 = list8;\n  delegateBooleanAssertion(types, 8, 11, false);\n  // list8 = list11;\n  delegateBooleanAssertion(types, 11, 8, false);\n  // list12 = list8;\n  delegateBooleanAssertion(types, 8, 12, false);\n  // list8 = list12;\n  delegateBooleanAssertion(types, 12, 8, false);\n  list13 = list8;\n  delegateBooleanAssertion(types, 8, 13, true);\n  list8 = (List<Object>[]) list13;\n  delegateBooleanAssertion(types, 13, 8, false);\n//  list9 = list9;\n  delegateBooleanAssertion(types, 9, 9, true);\n  list10 = (List<? super Object>[]) list9;\n  delegateBooleanAssertion(types, 9, 10, false);\n  list9 = list10;\n  delegateBooleanAssertion(types, 10, 9, true);\n  list11 = (List<String>[]) list9;\n  delegateBooleanAssertion(types, 9, 11, false);\n  list9 = list11;\n  delegateBooleanAssertion(types, 11, 9, true);\n  list12 = (List<? extends String>[]) list9;\n  delegateBooleanAssertion(types, 9, 12, false);\n  list9 = list12;\n  delegateBooleanAssertion(types, 12, 9, true);\n  list13 = (List<? super String>[]) list9;\n  delegateBooleanAssertion(types, 9, 13, false);\n  list9 = list13;\n  delegateBooleanAssertion(types, 13, 9, true);\n//  list10 = list10;\n  delegateBooleanAssertion(types, 10, 10, true);\n  // list11 = list10;\n  delegateBooleanAssertion(types, 10, 11, false);\n  // list10 = list11;\n  delegateBooleanAssertion(types, 11, 10, false);\n  // list12 = list10;\n  delegateBooleanAssertion(types, 10, 12, false);\n  // list10 = list12;\n  delegateBooleanAssertion(types, 12, 10, false);\n  list13 = list10;\n  delegateBooleanAssertion(types, 10, 13, true);\n  list10 = (List<? super Object>[]) list13;\n  delegateBooleanAssertion(types, 13, 10, false);\n//  list11 = list11;\n  delegateBooleanAssertion(types, 11, 11, true);\n  list12 = list11;\n  delegateBooleanAssertion(types, 11, 12, true);\n  list11 = (List<String>[]) list12;\n  delegateBooleanAssertion(types, 12, 11, false);\n  list13 = list11;\n  delegateBooleanAssertion(types, 11, 13, true);\n  list11 = (List<String>[]) list13;\n  delegateBooleanAssertion(types, 13, 11, false);\n//  list12 = list12;\n  delegateBooleanAssertion(types, 12, 12, true);\n  list13 = (List<? super String>[]) list12;\n  delegateBooleanAssertion(types, 12, 13, false);\n  list12 = (List<? extends String>[]) list13;\n  delegateBooleanAssertion(types, 13, 12, false);\n//  list13 = list13;\n  delegateBooleanAssertion(types, 13, 13, true);\n  Type disType = getClass().getField(\"dis\").getGenericType();\n  // Reporter.log( ( ( ParameterizedType ) disType\n  // ).getOwnerType().getClass().toString() );\n  Type datType = getClass().getField(\"dat\").getGenericType();\n  Type daType = getClass().getField(\"da\").getGenericType();\n  Type uhderType = getClass().getField(\"uhder\").getGenericType();\n  Type dingType = getClass().getField(\"ding\").getGenericType();\n  Type testerType = getClass().getField(\"tester\").getGenericType();\n  Type tester2Type = getClass().getField(\"tester2\").getGenericType();\n  Type dat2Type = getClass().getField(\"dat2\").getGenericType();\n  Type dat3Type = getClass().getField(\"dat3\").getGenericType();\n  dis = dat;\n  Assert.assertTrue(TypeUtils.isAssignable(datType, disType));\n  // dis = da;\n  Assert.assertFalse(TypeUtils.isAssignable(daType, disType));\n  dis = uhder;\n  Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType));\n  dis = ding;\n  Assert.assertFalse(String.format(\"type %s not assignable to %s!\", dingType, disType),\n  TypeUtils.isAssignable(dingType, disType));\n  dis = tester;\n  Assert.assertTrue(TypeUtils.isAssignable(testerType, disType));\n  // dis = tester2;\n  Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType));\n  // dat = dat2;\n  Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType));\n  // dat2 = dat;\n  Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type));\n  // dat = dat3;\n  Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType));\n  char ch = 0;\n  boolean bo = false;\n  byte by = 0;\n  short sh = 0;\n  int in = 0;\n  long lo = 0;\n  float fl = 0;\n  double du = 0;\n  du = ch;\n  Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class));\n  du = by;\n  Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class));\n  du = sh;\n  Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class));\n  du = in;\n  Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class));\n  du = lo;\n  Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class));\n  du = fl;\n  Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class));\n  lo = in;\n  Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class));\n  lo = Integer.valueOf(0);\n  Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class));\n  // Long lngW = 1;\n  Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class));\n  // lngW = Integer.valueOf( 0 );\n  Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class));\n  in = Integer.valueOf(0);\n  Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class));\n  Integer inte = in;\n  Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class));\n  Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class));\n  Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class));\n  Type intComparableType = getClass().getField(\"intComparable\").getGenericType();\n  intComparable = 1;\n  Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType));\n  Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class));\n  Serializable ser = 1;\n  Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class));\n  Type longComparableType = getClass().getField(\"longComparable\").getGenericType();\n  // longComparable = 1;\n  Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType));\n  // longComparable = Integer.valueOf( 0 );\n  Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType));\n  // int[] ia;\n  // long[] la = ia;\n  Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class));\n  Integer[] ia = null;\n  Type caType = getClass().getField(\"intWildcardComparable\").getGenericType();\n  intWildcardComparable = ia;\n  Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType));\n  // int[] ina = ia;\n  Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class));\n  int[] ina = null;\n  Object[] oa;\n  // oa = ina;\n  Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class));\n  oa = new Integer[0];\n  Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class));\n  Type bClassType = AClass.class.getField(\"bClass\").getGenericType();\n  Type cClassType = AClass.class.getField(\"cClass\").getGenericType();\n  Type dClassType = AClass.class.getField(\"dClass\").getGenericType();\n  Type eClassType = AClass.class.getField(\"eClass\").getGenericType();\n  Type fClassType = AClass.class.getField(\"fClass\").getGenericType();\n  AClass aClass = new AClass(new AAClass<String>());\n  aClass.bClass = aClass.cClass;\n  Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType));\n  aClass.bClass = aClass.dClass;\n  Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType));\n  aClass.bClass = aClass.eClass;\n  Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType));\n  aClass.bClass = aClass.fClass;\n  Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType));\n  aClass.cClass = aClass.dClass;\n  Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType));\n  aClass.cClass = aClass.eClass;\n  Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType));\n  aClass.cClass = aClass.fClass;\n  Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType));\n  aClass.dClass = aClass.eClass;\n  Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType));\n  aClass.dClass = aClass.fClass;\n  Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType));\n  aClass.eClass = aClass.fClass;\n  Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType));\n  }",
        "stack": [
          "TypeUtilsTest.testIsAssignable line 344"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/lang3/reflect/TypeUtils.java",
      "buggy_full_code": "\npackage org.apache.commons.lang3.reflect;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.lang3.ClassUtils;\n\n\npublic class TypeUtils { public TypeUtils() {\n        super();\n    }\n\n    \n    public static boolean isAssignable(Type type, Type toType) {\n        return isAssignable(type, toType, null);\n    }\n\n    \n    private static boolean isAssignable(Type type, Type toType, Map<TypeVariable<?>, Type> typeVarAssigns) {\n        if (toType == null || toType instanceof Class<?>) {\n            return isAssignable(type, (Class<?>) toType);\n        }\n\n        if (toType instanceof ParameterizedType) {\n            return isAssignable(type, (ParameterizedType) toType, typeVarAssigns);\n        }\n\n        if (toType instanceof GenericArrayType) {\n            return isAssignable(type, (GenericArrayType) toType, typeVarAssigns);\n        }\n\n        if (toType instanceof WildcardType) {\n            return isAssignable(type, (WildcardType) toType, typeVarAssigns);\n        }\n\n        \n        if (toType instanceof TypeVariable<?>) {\n            return isAssignable(type, (TypeVariable<?>) toType, typeVarAssigns);\n        }\n        \n\n        throw new IllegalStateException(\"found an unhandled type: \" + toType);\n    }\n\n    \n    private static boolean isAssignable(Type type, Class<?> toClass) {\n        if (type == null) {\n            \n            return toClass == null || !toClass.isPrimitive();\n        }\n\n        \n        \n        if (toClass == null) {\n            return false;\n        }\n\n        \n        if (toClass.equals(type)) {\n            return true;\n        }\n\n        if (type instanceof Class<?>) {\n            \n            return ClassUtils.isAssignable((Class<?>) type, toClass);\n        }\n\n        if (type instanceof ParameterizedType) {\n            \n            return isAssignable(getRawType((ParameterizedType) type), toClass);\n        }\n\n        \n        if (type instanceof TypeVariable<?>) {\n            \n            \n            for (Type bound : ((TypeVariable<?>) type).getBounds()) {\n                if (isAssignable(bound, toClass)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        \n        \n        if (type instanceof GenericArrayType) {\n            return toClass.equals(Object.class)\n                    || toClass.isArray()\n                    && isAssignable(((GenericArrayType) type).getGenericComponentType(), toClass\n                            .getComponentType());\n        }\n\n        \n        \n        if (type instanceof WildcardType) {\n            return false;\n        }\n\n        throw new IllegalStateException(\"found an unhandled type: \" + type);\n    }\n\n    \n    private static boolean isAssignable(Type type, ParameterizedType toParameterizedType, Map<TypeVariable<?>, Type> typeVarAssigns) {\n        if (type == null) {\n            return true;\n        }\n\n        \n        \n        if (toParameterizedType == null) {\n            return false;\n        }\n\n        \n        if (toParameterizedType.equals(type)) {\n            return true;\n        }\n\n        \n        Class<?> toClass = getRawType(toParameterizedType);\n        \n        \n        Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null);\n\n        \n        if (fromTypeVarAssigns == null) {\n            return false;\n        }\n\n        \n        \n        \n        if (fromTypeVarAssigns.isEmpty()) {\n            return true;\n        }\n\n        \n        Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType,\n                toClass, typeVarAssigns);\n\n        \n        for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\n            Type toTypeArg = entry.getValue();\n            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n\n            \n            \n            \n            if (fromTypeArg != null\n                    && !toTypeArg.equals(fromTypeArg)\n                    && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,\n                            typeVarAssigns))) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private static Type unrollVariableAssignments(TypeVariable<?> var, Map<TypeVariable<?>, Type> typeVarAssigns) {\n        Type result;\n        do {\n            result = typeVarAssigns.get(var);\n            if (result instanceof TypeVariable<?> && !result.equals(var)) {\n                var = (TypeVariable<?>) result;\n                continue;\n            }\n            break;\n        } while (true);\n        return result;\n    }\n\n    \n    private static boolean isAssignable(Type type, GenericArrayType toGenericArrayType, Map<TypeVariable<?>, Type> typeVarAssigns) {\n        if (type == null) {\n            return true;\n        }\n\n        \n        \n        if (toGenericArrayType == null) {\n            return false;\n        }\n\n        \n        if (toGenericArrayType.equals(type)) {\n            return true;\n        }\n\n        Type toComponentType = toGenericArrayType.getGenericComponentType();\n\n        if (type instanceof Class<?>) {\n            Class<?> cls = (Class<?>) type;\n\n            \n            return cls.isArray()\n                    && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns);\n        }\n\n        if (type instanceof GenericArrayType) {\n            \n            return isAssignable(((GenericArrayType) type).getGenericComponentType(),\n                    toComponentType, typeVarAssigns);\n        }\n\n        if (type instanceof WildcardType) {\n            \n            for (Type bound : getImplicitUpperBounds((WildcardType) type)) {\n                if (isAssignable(bound, toGenericArrayType)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        if (type instanceof TypeVariable<?>) {\n            \n            \n            for (Type bound : getImplicitBounds((TypeVariable<?>) type)) {\n                if (isAssignable(bound, toGenericArrayType)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        if (type instanceof ParameterizedType) {\n            \n            \n            \n            return false;\n        }\n\n        throw new IllegalStateException(\"found an unhandled type: \" + type);\n    }\n\n    \n    private static boolean isAssignable(Type type, WildcardType toWildcardType, Map<TypeVariable<?>, Type> typeVarAssigns) {\n        if (type == null) {\n            return true;\n        }\n\n        \n        \n        if (toWildcardType == null) {\n            return false;\n        }\n\n        \n        if (toWildcardType.equals(type)) {\n            return true;\n        }\n\n        Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType);\n        Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType);\n\n        if (type instanceof WildcardType) {\n            WildcardType wildcardType = (WildcardType) type;\n            Type[] upperBounds = getImplicitUpperBounds(wildcardType);\n            Type[] lowerBounds = getImplicitLowerBounds(wildcardType);\n\n            for (Type toBound : toUpperBounds) {\n                \n                \n                toBound = substituteTypeVariables(toBound, typeVarAssigns);\n\n                \n                \n                \n                for (Type bound : upperBounds) {\n                    if (!isAssignable(bound, toBound, typeVarAssigns)) {\n                        return false;\n                    }\n                }\n            }\n\n            for (Type toBound : toLowerBounds) {\n                \n                \n                toBound = substituteTypeVariables(toBound, typeVarAssigns);\n\n                \n                \n                \n                for (Type bound : lowerBounds) {\n                    if (!isAssignable(toBound, bound, typeVarAssigns)) {\n                        return false;\n                    }\n                }\n            }\n\n            return true;\n        }\n\n        for (Type toBound : toUpperBounds) {\n            \n            \n            if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns),\n                    typeVarAssigns)) {\n                return false;\n            }\n        }\n\n        for (Type toBound : toLowerBounds) {\n            \n            \n            if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type,\n                    typeVarAssigns)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    \n    private static boolean isAssignable(Type type, TypeVariable<?> toTypeVariable, Map<TypeVariable<?>, Type> typeVarAssigns) {\n        if (type == null) {\n            return true;\n        }\n\n        \n        \n        if (toTypeVariable == null) {\n            return false;\n        }\n\n        \n        if (toTypeVariable.equals(type)) {\n            return true;\n        }\n\n        if (type instanceof TypeVariable<?>) {\n            \n            \n            \n            Type[] bounds = getImplicitBounds((TypeVariable<?>) type);\n\n            for (Type bound : bounds) {\n                if (isAssignable(bound, toTypeVariable, typeVarAssigns)) {\n                    return true;\n                }\n            }\n        }\n\n        if (type instanceof Class<?> || type instanceof ParameterizedType\n                || type instanceof GenericArrayType || type instanceof WildcardType) {\n            return false;\n        }\n\n        throw new IllegalStateException(\"found an unhandled type: \" + type);\n    }\n\n    \n    private static Type substituteTypeVariables(Type type, Map<TypeVariable<?>, Type> typeVarAssigns) {\n        if (type instanceof TypeVariable<?> && typeVarAssigns != null) {\n            Type replacementType = typeVarAssigns.get(type);\n\n            if (replacementType == null) {\n                throw new IllegalArgumentException(\"missing assignment type for type variable \"\n                        + type);\n            }\n\n            return replacementType;\n        }\n\n        return type;\n    }\n\n    \n    public static Map<TypeVariable<?>, Type> getTypeArguments(ParameterizedType type) {\n        return getTypeArguments(type, getRawType(type), null);\n    }\n\n    \n    public static Map<TypeVariable<?>, Type> getTypeArguments(Type type, Class<?> toClass) {\n        return getTypeArguments(type, toClass, null);\n    }\n\n    \n    private static Map<TypeVariable<?>, Type> getTypeArguments(Type type, Class<?> toClass, Map<TypeVariable<?>, Type> subtypeVarAssigns) {\n        if (type instanceof Class<?>) {\n            return getTypeArguments((Class<?>) type, toClass, subtypeVarAssigns);\n        }\n\n        if (type instanceof ParameterizedType) {\n            return getTypeArguments((ParameterizedType) type, toClass, subtypeVarAssigns);\n        }\n\n        if (type instanceof GenericArrayType) {\n            return getTypeArguments(((GenericArrayType) type).getGenericComponentType(), toClass\n                    .isArray() ? toClass.getComponentType() : toClass, subtypeVarAssigns);\n        }\n\n        \n        \n        if (type instanceof WildcardType) {\n            for (Type bound : getImplicitUpperBounds((WildcardType) type)) {\n                \n                if (isAssignable(bound, toClass)) {\n                    return getTypeArguments(bound, toClass, subtypeVarAssigns);\n                }\n            }\n\n            return null;\n        }\n\n        \n        if (type instanceof TypeVariable<?>) {\n            for (Type bound : getImplicitBounds((TypeVariable<?>) type)) {\n                \n                if (isAssignable(bound, toClass)) {\n                    return getTypeArguments(bound, toClass, subtypeVarAssigns);\n                }\n            }\n\n            return null;\n        }\n        \n\n        throw new IllegalStateException(\"found an unhandled type: \" + type);\n    }\n\n    \n    private static Map<TypeVariable<?>, Type> getTypeArguments( ParameterizedType parameterizedType, Class<?> toClass, Map<TypeVariable<?>, Type> subtypeVarAssigns) {\n        Class<?> cls = getRawType(parameterizedType);\n\n        \n        if (!isAssignable(cls, toClass)) {\n            return null;\n        }\n\n        Type ownerType = parameterizedType.getOwnerType();\n        Map<TypeVariable<?>, Type> typeVarAssigns;\n\n        if (ownerType instanceof ParameterizedType) {\n            \n            ParameterizedType parameterizedOwnerType = (ParameterizedType) ownerType;\n            typeVarAssigns = getTypeArguments(parameterizedOwnerType,\n                    getRawType(parameterizedOwnerType), subtypeVarAssigns);\n        } else {\n            \n            typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>()\n                    : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n        }\n\n        \n        Type[] typeArgs = parameterizedType.getActualTypeArguments();\n        \n        TypeVariable<?>[] typeParams = cls.getTypeParameters();\n\n        \n        for (int i = 0; i < typeParams.length; i++) {\n            Type typeArg = typeArgs[i];\n            typeVarAssigns.put(typeParams[i], typeVarAssigns.containsKey(typeArg) ? typeVarAssigns\n                    .get(typeArg) : typeArg);\n        }\n\n        if (toClass.equals(cls)) {\n            \n            return typeVarAssigns;\n        }\n\n        \n        return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);\n    }\n\n    \n    private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, Class<?> toClass, Map<TypeVariable<?>, Type> subtypeVarAssigns) {\n        \n        if (!isAssignable(cls, toClass)) {\n            return null;\n        }\n\n        \n        if (cls.isPrimitive()) {\n            \n            if (toClass.isPrimitive()) {\n                \n                \n                return new HashMap<TypeVariable<?>, Type>();\n            }\n\n            \n            cls = ClassUtils.primitiveToWrapper(cls);\n        }\n\n        \n        HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>()\n                : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n\n        \n        if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {\n            return typeVarAssigns;\n        }\n\n        \n        return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);\n    }\n\n    \n    public static Map<TypeVariable<?>, Type> determineTypeArguments(Class<?> cls, ParameterizedType superType) {\n        Class<?> superClass = getRawType(superType);\n\n        \n        if (!isAssignable(cls, superClass)) {\n            return null;\n        }\n\n        if (cls.equals(superClass)) {\n            return getTypeArguments(superType, superClass, null);\n        }\n\n        \n        Type midType = getClosestParentType(cls, superClass);\n\n        \n        if (midType instanceof Class<?>) {\n            return determineTypeArguments((Class<?>) midType, superType);\n        }\n\n        ParameterizedType midParameterizedType = (ParameterizedType) midType;\n        Class<?> midClass = getRawType(midParameterizedType);\n        \n        \n        Map<TypeVariable<?>, Type> typeVarAssigns = determineTypeArguments(midClass, superType);\n        \n        mapTypeVariablesToArguments(cls, midParameterizedType, typeVarAssigns);\n\n        return typeVarAssigns;\n    }\n\n    \n    private static <T> void mapTypeVariablesToArguments(Class<T> cls, ParameterizedType parameterizedType, Map<TypeVariable<?>, Type> typeVarAssigns) {\n        \n        Type ownerType = parameterizedType.getOwnerType();\n\n        if (ownerType instanceof ParameterizedType) {\n            \n            mapTypeVariablesToArguments(cls, (ParameterizedType) ownerType, typeVarAssigns);\n        }\n\n        \n        \n        \n        \n        Type[] typeArgs = parameterizedType.getActualTypeArguments();\n\n        \n        \n        TypeVariable<?>[] typeVars = getRawType(parameterizedType).getTypeParameters();\n\n        \n        List<TypeVariable<Class<T>>> typeVarList = Arrays.asList(cls\n                .getTypeParameters());\n\n        for (int i = 0; i < typeArgs.length; i++) {\n            TypeVariable<?> typeVar = typeVars[i];\n            Type typeArg = typeArgs[i];\n\n            \n            if (typeVarList.contains(typeArg)\n            \n                    \n                    && typeVarAssigns.containsKey(typeVar)) {\n                \n                typeVarAssigns.put((TypeVariable<?>) typeArg, typeVarAssigns.get(typeVar));\n            }\n        }\n    }\n\n    \n    private static Type getClosestParentType(Class<?> cls, Class<?> superClass) {\n        \n        if (superClass.isInterface()) {\n            \n            Type[] interfaceTypes = cls.getGenericInterfaces();\n            \n            Type genericInterface = null;\n\n            \n            for (Type midType : interfaceTypes) {\n                Class<?> midClass = null;\n\n                if (midType instanceof ParameterizedType) {\n                    midClass = getRawType((ParameterizedType) midType);\n                } else if (midType instanceof Class<?>) {\n                    midClass = (Class<?>) midType;\n                } else {\n                    throw new IllegalStateException(\"Unexpected generic\"\n                            + \" interface type found: \" + midType);\n                }\n\n                \n                \n                if (isAssignable(midClass, superClass)\n                        && isAssignable(genericInterface, (Type) midClass)) {\n                    genericInterface = midType;\n                }\n            }\n\n            \n            if (genericInterface != null) {\n                return genericInterface;\n            }\n        }\n\n        \n        \n        return cls.getGenericSuperclass();\n    }\n\n    \n    public static boolean isInstance(Object value, Type type) {\n        if (type == null) {\n            return false;\n        }\n\n        return value == null ? !(type instanceof Class<?>) || !((Class<?>) type).isPrimitive()\n                : isAssignable(value.getClass(), type, null);\n    }\n\n    \n    public static Type[] normalizeUpperBounds(Type[] bounds) {\n        \n        if (bounds.length < 2) {\n            return bounds;\n        }\n\n        Set<Type> types = new HashSet<Type>(bounds.length);\n\n        for (Type type1 : bounds) {\n            boolean subtypeFound = false;\n\n            for (Type type2 : bounds) {\n                if (type1 != type2 && isAssignable(type2, type1, null)) {\n                    subtypeFound = true;\n                    break;\n                }\n            }\n\n            if (!subtypeFound) {\n                types.add(type1);\n            }\n        }\n\n        return types.toArray(new Type[types.size()]);\n    }\n\n    \n    public static Type[] getImplicitBounds(TypeVariable<?> typeVariable) {\n        Type[] bounds = typeVariable.getBounds();\n\n        return bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds);\n    }\n\n    \n    public static Type[] getImplicitUpperBounds(WildcardType wildcardType) {\n        Type[] bounds = wildcardType.getUpperBounds();\n\n        return bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds);\n    }\n\n    \n    public static Type[] getImplicitLowerBounds(WildcardType wildcardType) {\n        Type[] bounds = wildcardType.getLowerBounds();\n\n        return bounds.length == 0 ? new Type[] { null } : bounds;\n    }\n\n    \n    public static boolean typesSatisfyVariables(Map<TypeVariable<?>, Type> typeVarAssigns) {\n        \n        \n        for (Map.Entry<TypeVariable<?>, Type> entry : typeVarAssigns.entrySet()) {\n            TypeVariable<?> typeVar = entry.getKey();\n            Type type = entry.getValue();\n\n            for (Type bound : getImplicitBounds(typeVar)) {\n                if (!isAssignable(type, substituteTypeVariables(bound, typeVarAssigns),\n                        typeVarAssigns)) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    \n    private static Class<?> getRawType(ParameterizedType parameterizedType) {\n        Type rawType = parameterizedType.getRawType();\n\n        \n        \n        \n        \n        \n        if (!(rawType instanceof Class<?>)) {\n            throw new IllegalStateException(\"Wait... What!? Type of rawType: \" + rawType);\n        }\n\n        return (Class<?>) rawType;\n    }\n\n    \n    public static Class<?> getRawType(Type type, Type assigningType) {\n        if (type instanceof Class<?>) {\n            \n            return (Class<?>) type;\n        }\n\n        if (type instanceof ParameterizedType) {\n            \n            return getRawType((ParameterizedType) type);\n        }\n\n        if (type instanceof TypeVariable<?>) {\n            if (assigningType == null) {\n                return null;\n            }\n\n            \n            Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration();\n\n            \n            \n            if (!(genericDeclaration instanceof Class<?>)) {\n                return null;\n            }\n\n            \n            \n            Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType,\n                    (Class<?>) genericDeclaration);\n\n            \n            \n            if (typeVarAssigns == null) {\n                return null;\n            }\n\n            \n            Type typeArgument = typeVarAssigns.get(type);\n\n            if (typeArgument == null) {\n                return null;\n            }\n\n            \n            return getRawType(typeArgument, assigningType);\n        }\n\n        if (type instanceof GenericArrayType) {\n            \n            Class<?> rawComponentType = getRawType(((GenericArrayType) type)\n                    .getGenericComponentType(), assigningType);\n\n            \n            return Array.newInstance(rawComponentType, 0).getClass();\n        }\n\n        \n        if (type instanceof WildcardType) {\n            return null;\n        }\n\n        throw new IllegalArgumentException(\"unknown type: \" + type);\n    }\n\n    \n    public static boolean isArrayType(Type type) {\n        return type instanceof GenericArrayType || type instanceof Class<?> && ((Class<?>) type).isArray();\n    }\n\n    \n    public static Type getArrayComponentType(Type type) {\n        if (type instanceof Class<?>) {\n            Class<?> clazz = (Class<?>) type;\n            return clazz.isArray() ? clazz.getComponentType() : null;\n        }\n        if (type instanceof GenericArrayType) {\n            return ((GenericArrayType) type).getGenericComponentType();\n        }\n        return null;\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.lang3.reflect;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.lang3.ClassUtils;\n\n\npublic class TypeUtils { public TypeUtils() {\n        super();\n    }\n\n    \n    public static boolean isAssignable(Type type, Type toType) {\n        return isAssignable(type, toType, null);\n    }\n\n    \n    private static boolean isAssignable(Type type, Type toType, Map<TypeVariable<?>, Type> typeVarAssigns) {\n        if (toType == null || toType instanceof Class<?>) {\n            return isAssignable(type, (Class<?>) toType);\n        }\n\n        if (toType instanceof ParameterizedType) {\n            return isAssignable(type, (ParameterizedType) toType, typeVarAssigns);\n        }\n\n        if (toType instanceof GenericArrayType) {\n            return isAssignable(type, (GenericArrayType) toType, typeVarAssigns);\n        }\n\n        if (toType instanceof WildcardType) {\n            return isAssignable(type, (WildcardType) toType, typeVarAssigns);\n        }\n\n        \n        if (toType instanceof TypeVariable<?>) {\n            return isAssignable(type, (TypeVariable<?>) toType, typeVarAssigns);\n        }\n        \n\n        throw new IllegalStateException(\"found an unhandled type: \" + toType);\n    }\n\n    \n    private static boolean isAssignable(Type type, Class<?> toClass) {\n        if (type == null) {\n            \n            return toClass == null || !toClass.isPrimitive();\n        }\n\n        \n        \n        if (toClass == null) {\n            return false;\n        }\n\n        \n        if (toClass.equals(type)) {\n            return true;\n        }\n\n        if (type instanceof Class<?>) {\n            \n            return ClassUtils.isAssignable((Class<?>) type, toClass);\n        }\n\n        if (type instanceof ParameterizedType) {\n            \n            return isAssignable(getRawType((ParameterizedType) type), toClass);\n        }\n\n        \n        if (type instanceof TypeVariable<?>) {\n            \n            \n            for (Type bound : ((TypeVariable<?>) type).getBounds()) {\n                if (isAssignable(bound, toClass)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        \n        \n        if (type instanceof GenericArrayType) {\n            return toClass.equals(Object.class)\n                    || toClass.isArray()\n                    && isAssignable(((GenericArrayType) type).getGenericComponentType(), toClass\n                            .getComponentType());\n        }\n\n        \n        \n        if (type instanceof WildcardType) {\n            return false;\n        }\n\n        throw new IllegalStateException(\"found an unhandled type: \" + type);\n    }\n\n    \n    private static boolean isAssignable(Type type, ParameterizedType toParameterizedType, Map<TypeVariable<?>, Type> typeVarAssigns) {\n        if (type == null) {\n            return true;\n        }\n\n        \n        \n        if (toParameterizedType == null) {\n            return false;\n        }\n\n        \n        if (toParameterizedType.equals(type)) {\n            return true;\n        }\n\n        \n        Class<?> toClass = getRawType(toParameterizedType);\n        \n        \n        Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null);\n\n        \n        if (fromTypeVarAssigns == null) {\n            return false;\n        }\n\n        \n        \n        \n        if (fromTypeVarAssigns.isEmpty()) {\n            return true;\n        }\n\n        \n        Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType,\n                toClass, typeVarAssigns);\n\n        \n        for (TypeVariable<?> var : toTypeVarAssigns.keySet()) {\n            Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns);\n            Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns);\n\n            \n            \n            \n            if (fromTypeArg != null\n                    && !toTypeArg.equals(fromTypeArg)\n                    && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,\n                            typeVarAssigns))) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private static Type unrollVariableAssignments(TypeVariable<?> var, Map<TypeVariable<?>, Type> typeVarAssigns) {\n        Type result;\n        do {\n            result = typeVarAssigns.get(var);\n            if (result instanceof TypeVariable<?> && !result.equals(var)) {\n                var = (TypeVariable<?>) result;\n                continue;\n            }\n            break;\n        } while (true);\n        return result;\n    }\n\n    \n    private static boolean isAssignable(Type type, GenericArrayType toGenericArrayType, Map<TypeVariable<?>, Type> typeVarAssigns) {\n        if (type == null) {\n            return true;\n        }\n\n        \n        \n        if (toGenericArrayType == null) {\n            return false;\n        }\n\n        \n        if (toGenericArrayType.equals(type)) {\n            return true;\n        }\n\n        Type toComponentType = toGenericArrayType.getGenericComponentType();\n\n        if (type instanceof Class<?>) {\n            Class<?> cls = (Class<?>) type;\n\n            \n            return cls.isArray()\n                    && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns);\n        }\n\n        if (type instanceof GenericArrayType) {\n            \n            return isAssignable(((GenericArrayType) type).getGenericComponentType(),\n                    toComponentType, typeVarAssigns);\n        }\n\n        if (type instanceof WildcardType) {\n            \n            for (Type bound : getImplicitUpperBounds((WildcardType) type)) {\n                if (isAssignable(bound, toGenericArrayType)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        if (type instanceof TypeVariable<?>) {\n            \n            \n            for (Type bound : getImplicitBounds((TypeVariable<?>) type)) {\n                if (isAssignable(bound, toGenericArrayType)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        if (type instanceof ParameterizedType) {\n            \n            \n            \n            return false;\n        }\n\n        throw new IllegalStateException(\"found an unhandled type: \" + type);\n    }\n\n    \n    private static boolean isAssignable(Type type, WildcardType toWildcardType, Map<TypeVariable<?>, Type> typeVarAssigns) {\n        if (type == null) {\n            return true;\n        }\n\n        \n        \n        if (toWildcardType == null) {\n            return false;\n        }\n\n        \n        if (toWildcardType.equals(type)) {\n            return true;\n        }\n\n        Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType);\n        Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType);\n\n        if (type instanceof WildcardType) {\n            WildcardType wildcardType = (WildcardType) type;\n            Type[] upperBounds = getImplicitUpperBounds(wildcardType);\n            Type[] lowerBounds = getImplicitLowerBounds(wildcardType);\n\n            for (Type toBound : toUpperBounds) {\n                \n                \n                toBound = substituteTypeVariables(toBound, typeVarAssigns);\n\n                \n                \n                \n                for (Type bound : upperBounds) {\n                    if (!isAssignable(bound, toBound, typeVarAssigns)) {\n                        return false;\n                    }\n                }\n            }\n\n            for (Type toBound : toLowerBounds) {\n                \n                \n                toBound = substituteTypeVariables(toBound, typeVarAssigns);\n\n                \n                \n                \n                for (Type bound : lowerBounds) {\n                    if (!isAssignable(toBound, bound, typeVarAssigns)) {\n                        return false;\n                    }\n                }\n            }\n\n            return true;\n        }\n\n        for (Type toBound : toUpperBounds) {\n            \n            \n            if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns),\n                    typeVarAssigns)) {\n                return false;\n            }\n        }\n\n        for (Type toBound : toLowerBounds) {\n            \n            \n            if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type,\n                    typeVarAssigns)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    \n    private static boolean isAssignable(Type type, TypeVariable<?> toTypeVariable, Map<TypeVariable<?>, Type> typeVarAssigns) {\n        if (type == null) {\n            return true;\n        }\n\n        \n        \n        if (toTypeVariable == null) {\n            return false;\n        }\n\n        \n        if (toTypeVariable.equals(type)) {\n            return true;\n        }\n\n        if (type instanceof TypeVariable<?>) {\n            \n            \n            \n            Type[] bounds = getImplicitBounds((TypeVariable<?>) type);\n\n            for (Type bound : bounds) {\n                if (isAssignable(bound, toTypeVariable, typeVarAssigns)) {\n                    return true;\n                }\n            }\n        }\n\n        if (type instanceof Class<?> || type instanceof ParameterizedType\n                || type instanceof GenericArrayType || type instanceof WildcardType) {\n            return false;\n        }\n\n        throw new IllegalStateException(\"found an unhandled type: \" + type);\n    }\n\n    \n    private static Type substituteTypeVariables(Type type, Map<TypeVariable<?>, Type> typeVarAssigns) {\n        if (type instanceof TypeVariable<?> && typeVarAssigns != null) {\n            Type replacementType = typeVarAssigns.get(type);\n\n            if (replacementType == null) {\n                throw new IllegalArgumentException(\"missing assignment type for type variable \"\n                        + type);\n            }\n\n            return replacementType;\n        }\n\n        return type;\n    }\n\n    \n    public static Map<TypeVariable<?>, Type> getTypeArguments(ParameterizedType type) {\n        return getTypeArguments(type, getRawType(type), null);\n    }\n\n    \n    public static Map<TypeVariable<?>, Type> getTypeArguments(Type type, Class<?> toClass) {\n        return getTypeArguments(type, toClass, null);\n    }\n\n    \n    private static Map<TypeVariable<?>, Type> getTypeArguments(Type type, Class<?> toClass, Map<TypeVariable<?>, Type> subtypeVarAssigns) {\n        if (type instanceof Class<?>) {\n            return getTypeArguments((Class<?>) type, toClass, subtypeVarAssigns);\n        }\n\n        if (type instanceof ParameterizedType) {\n            return getTypeArguments((ParameterizedType) type, toClass, subtypeVarAssigns);\n        }\n\n        if (type instanceof GenericArrayType) {\n            return getTypeArguments(((GenericArrayType) type).getGenericComponentType(), toClass\n                    .isArray() ? toClass.getComponentType() : toClass, subtypeVarAssigns);\n        }\n\n        \n        \n        if (type instanceof WildcardType) {\n            for (Type bound : getImplicitUpperBounds((WildcardType) type)) {\n                \n                if (isAssignable(bound, toClass)) {\n                    return getTypeArguments(bound, toClass, subtypeVarAssigns);\n                }\n            }\n\n            return null;\n        }\n\n        \n        if (type instanceof TypeVariable<?>) {\n            for (Type bound : getImplicitBounds((TypeVariable<?>) type)) {\n                \n                if (isAssignable(bound, toClass)) {\n                    return getTypeArguments(bound, toClass, subtypeVarAssigns);\n                }\n            }\n\n            return null;\n        }\n        \n\n        throw new IllegalStateException(\"found an unhandled type: \" + type);\n    }\n\n    \n    private static Map<TypeVariable<?>, Type> getTypeArguments( ParameterizedType parameterizedType, Class<?> toClass, Map<TypeVariable<?>, Type> subtypeVarAssigns) {\n        Class<?> cls = getRawType(parameterizedType);\n\n        \n        if (!isAssignable(cls, toClass)) {\n            return null;\n        }\n\n        Type ownerType = parameterizedType.getOwnerType();\n        Map<TypeVariable<?>, Type> typeVarAssigns;\n\n        if (ownerType instanceof ParameterizedType) {\n            \n            ParameterizedType parameterizedOwnerType = (ParameterizedType) ownerType;\n            typeVarAssigns = getTypeArguments(parameterizedOwnerType,\n                    getRawType(parameterizedOwnerType), subtypeVarAssigns);\n        } else {\n            \n            typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>()\n                    : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n        }\n\n        \n        Type[] typeArgs = parameterizedType.getActualTypeArguments();\n        \n        TypeVariable<?>[] typeParams = cls.getTypeParameters();\n\n        \n        for (int i = 0; i < typeParams.length; i++) {\n            Type typeArg = typeArgs[i];\n            typeVarAssigns.put(typeParams[i], typeVarAssigns.containsKey(typeArg) ? typeVarAssigns\n                    .get(typeArg) : typeArg);\n        }\n\n        if (toClass.equals(cls)) {\n            \n            return typeVarAssigns;\n        }\n\n        \n        return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);\n    }\n\n    \n    private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, Class<?> toClass, Map<TypeVariable<?>, Type> subtypeVarAssigns) {\n        \n        if (!isAssignable(cls, toClass)) {\n            return null;\n        }\n\n        \n        if (cls.isPrimitive()) {\n            \n            if (toClass.isPrimitive()) {\n                \n                \n                return new HashMap<TypeVariable<?>, Type>();\n            }\n\n            \n            cls = ClassUtils.primitiveToWrapper(cls);\n        }\n\n        \n        HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>()\n                : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n\n        \n        if (toClass.equals(cls)) {\n            return typeVarAssigns;\n        }\n\n        \n        return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);\n    }\n\n    \n    public static Map<TypeVariable<?>, Type> determineTypeArguments(Class<?> cls, ParameterizedType superType) {\n        Class<?> superClass = getRawType(superType);\n\n        \n        if (!isAssignable(cls, superClass)) {\n            return null;\n        }\n\n        if (cls.equals(superClass)) {\n            return getTypeArguments(superType, superClass, null);\n        }\n\n        \n        Type midType = getClosestParentType(cls, superClass);\n\n        \n        if (midType instanceof Class<?>) {\n            return determineTypeArguments((Class<?>) midType, superType);\n        }\n\n        ParameterizedType midParameterizedType = (ParameterizedType) midType;\n        Class<?> midClass = getRawType(midParameterizedType);\n        \n        \n        Map<TypeVariable<?>, Type> typeVarAssigns = determineTypeArguments(midClass, superType);\n        \n        mapTypeVariablesToArguments(cls, midParameterizedType, typeVarAssigns);\n\n        return typeVarAssigns;\n    }\n\n    \n    private static <T> void mapTypeVariablesToArguments(Class<T> cls, ParameterizedType parameterizedType, Map<TypeVariable<?>, Type> typeVarAssigns) {\n        \n        Type ownerType = parameterizedType.getOwnerType();\n\n        if (ownerType instanceof ParameterizedType) {\n            \n            mapTypeVariablesToArguments(cls, (ParameterizedType) ownerType, typeVarAssigns);\n        }\n\n        \n        \n        \n        \n        Type[] typeArgs = parameterizedType.getActualTypeArguments();\n\n        \n        \n        TypeVariable<?>[] typeVars = getRawType(parameterizedType).getTypeParameters();\n\n        \n        List<TypeVariable<Class<T>>> typeVarList = Arrays.asList(cls\n                .getTypeParameters());\n\n        for (int i = 0; i < typeArgs.length; i++) {\n            TypeVariable<?> typeVar = typeVars[i];\n            Type typeArg = typeArgs[i];\n\n            \n            if (typeVarList.contains(typeArg)\n            \n                    \n                    && typeVarAssigns.containsKey(typeVar)) {\n                \n                typeVarAssigns.put((TypeVariable<?>) typeArg, typeVarAssigns.get(typeVar));\n            }\n        }\n    }\n\n    \n    private static Type getClosestParentType(Class<?> cls, Class<?> superClass) {\n        \n        if (superClass.isInterface()) {\n            \n            Type[] interfaceTypes = cls.getGenericInterfaces();\n            \n            Type genericInterface = null;\n\n            \n            for (Type midType : interfaceTypes) {\n                Class<?> midClass = null;\n\n                if (midType instanceof ParameterizedType) {\n                    midClass = getRawType((ParameterizedType) midType);\n                } else if (midType instanceof Class<?>) {\n                    midClass = (Class<?>) midType;\n                } else {\n                    throw new IllegalStateException(\"Unexpected generic\"\n                            + \" interface type found: \" + midType);\n                }\n\n                \n                \n                if (isAssignable(midClass, superClass)\n                        && isAssignable(genericInterface, (Type) midClass)) {\n                    genericInterface = midType;\n                }\n            }\n\n            \n            if (genericInterface != null) {\n                return genericInterface;\n            }\n        }\n\n        \n        \n        return cls.getGenericSuperclass();\n    }\n\n    \n    public static boolean isInstance(Object value, Type type) {\n        if (type == null) {\n            return false;\n        }\n\n        return value == null ? !(type instanceof Class<?>) || !((Class<?>) type).isPrimitive()\n                : isAssignable(value.getClass(), type, null);\n    }\n\n    \n    public static Type[] normalizeUpperBounds(Type[] bounds) {\n        \n        if (bounds.length < 2) {\n            return bounds;\n        }\n\n        Set<Type> types = new HashSet<Type>(bounds.length);\n\n        for (Type type1 : bounds) {\n            boolean subtypeFound = false;\n\n            for (Type type2 : bounds) {\n                if (type1 != type2 && isAssignable(type2, type1, null)) {\n                    subtypeFound = true;\n                    break;\n                }\n            }\n\n            if (!subtypeFound) {\n                types.add(type1);\n            }\n        }\n\n        return types.toArray(new Type[types.size()]);\n    }\n\n    \n    public static Type[] getImplicitBounds(TypeVariable<?> typeVariable) {\n        Type[] bounds = typeVariable.getBounds();\n\n        return bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds);\n    }\n\n    \n    public static Type[] getImplicitUpperBounds(WildcardType wildcardType) {\n        Type[] bounds = wildcardType.getUpperBounds();\n\n        return bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds);\n    }\n\n    \n    public static Type[] getImplicitLowerBounds(WildcardType wildcardType) {\n        Type[] bounds = wildcardType.getLowerBounds();\n\n        return bounds.length == 0 ? new Type[] { null } : bounds;\n    }\n\n    \n    public static boolean typesSatisfyVariables(Map<TypeVariable<?>, Type> typeVarAssigns) {\n        \n        \n        for (Map.Entry<TypeVariable<?>, Type> entry : typeVarAssigns.entrySet()) {\n            TypeVariable<?> typeVar = entry.getKey();\n            Type type = entry.getValue();\n\n            for (Type bound : getImplicitBounds(typeVar)) {\n                if (!isAssignable(type, substituteTypeVariables(bound, typeVarAssigns),\n                        typeVarAssigns)) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    \n    private static Class<?> getRawType(ParameterizedType parameterizedType) {\n        Type rawType = parameterizedType.getRawType();\n\n        \n        \n        \n        \n        \n        if (!(rawType instanceof Class<?>)) {\n            throw new IllegalStateException(\"Wait... What!? Type of rawType: \" + rawType);\n        }\n\n        return (Class<?>) rawType;\n    }\n\n    \n    public static Class<?> getRawType(Type type, Type assigningType) {\n        if (type instanceof Class<?>) {\n            \n            return (Class<?>) type;\n        }\n\n        if (type instanceof ParameterizedType) {\n            \n            return getRawType((ParameterizedType) type);\n        }\n\n        if (type instanceof TypeVariable<?>) {\n            if (assigningType == null) {\n                return null;\n            }\n\n            \n            Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration();\n\n            \n            \n            if (!(genericDeclaration instanceof Class<?>)) {\n                return null;\n            }\n\n            \n            \n            Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType,\n                    (Class<?>) genericDeclaration);\n\n            \n            \n            if (typeVarAssigns == null) {\n                return null;\n            }\n\n            \n            Type typeArgument = typeVarAssigns.get(type);\n\n            if (typeArgument == null) {\n                return null;\n            }\n\n            \n            return getRawType(typeArgument, assigningType);\n        }\n\n        if (type instanceof GenericArrayType) {\n            \n            Class<?> rawComponentType = getRawType(((GenericArrayType) type)\n                    .getGenericComponentType(), assigningType);\n\n            \n            return Array.newInstance(rawComponentType, 0).getClass();\n        }\n\n        \n        if (type instanceof WildcardType) {\n            return null;\n        }\n\n        throw new IllegalArgumentException(\"unknown type: \" + type);\n    }\n\n    \n    public static boolean isArrayType(Type type) {\n        return type instanceof GenericArrayType || type instanceof Class<?> && ((Class<?>) type).isArray();\n    }\n\n    \n    public static Type getArrayComponentType(Type type) {\n        if (type instanceof Class<?>) {\n            Class<?> clazz = (Class<?>) type;\n            return clazz.isArray() ? clazz.getComponentType() : null;\n        }\n        if (type instanceof GenericArrayType) {\n            return ((GenericArrayType) type).getGenericComponentType();\n        }\n        return null;\n    }\n\n}\n",
      "buggy_signatures": [
        "public class TypeUtils { public TypeUtils()",
        "public static boolean isAssignable(Type type, Type toType)",
        "private static boolean isAssignable(Type type, Type toType, Map<TypeVariable<?>, Type> typeVarAssigns)",
        "private static boolean isAssignable(Type type, Class<?> toClass)",
        "private static boolean isAssignable(Type type, ParameterizedType toParameterizedType, Map<TypeVariable<?>, Type> typeVarAssigns)",
        "private static Type unrollVariableAssignments(TypeVariable<?> var, Map<TypeVariable<?>, Type> typeVarAssigns)",
        "private static boolean isAssignable(Type type, GenericArrayType toGenericArrayType, Map<TypeVariable<?>, Type> typeVarAssigns)",
        "private static boolean isAssignable(Type type, WildcardType toWildcardType, Map<TypeVariable<?>, Type> typeVarAssigns)",
        "private static boolean isAssignable(Type type, TypeVariable<?> toTypeVariable, Map<TypeVariable<?>, Type> typeVarAssigns)",
        "private static Type substituteTypeVariables(Type type, Map<TypeVariable<?>, Type> typeVarAssigns)",
        "public static Map<TypeVariable<?>, Type> getTypeArguments(ParameterizedType type)",
        "public static Map<TypeVariable<?>, Type> getTypeArguments(Type type, Class<?> toClass)",
        "private static Map<TypeVariable<?>, Type> getTypeArguments(Type type, Class<?> toClass, Map<TypeVariable<?>, Type> subtypeVarAssigns)",
        "private static Map<TypeVariable<?>, Type> getTypeArguments( ParameterizedType parameterizedType, Class<?> toClass, Map<TypeVariable<?>, Type> subtypeVarAssigns)",
        "private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, Class<?> toClass, Map<TypeVariable<?>, Type> subtypeVarAssigns)",
        "public static Map<TypeVariable<?>, Type> determineTypeArguments(Class<?> cls, ParameterizedType superType)",
        "private static <T> void mapTypeVariablesToArguments(Class<T> cls, ParameterizedType parameterizedType, Map<TypeVariable<?>, Type> typeVarAssigns)",
        "private static Type getClosestParentType(Class<?> cls, Class<?> superClass)",
        "public static boolean isInstance(Object value, Type type)",
        "public static Type[] normalizeUpperBounds(Type[] bounds)",
        "public static Type[] getImplicitBounds(TypeVariable<?> typeVariable)",
        "public static Type[] getImplicitUpperBounds(WildcardType wildcardType)",
        "public static Type[] getImplicitLowerBounds(WildcardType wildcardType)",
        "public static boolean typesSatisfyVariables(Map<TypeVariable<?>, Type> typeVarAssigns)",
        "private static Class<?> getRawType(ParameterizedType parameterizedType)",
        "public static Class<?> getRawType(Type type, Type assigningType)",
        "public static boolean isArrayType(Type type)",
        "public static Type getArrayComponentType(Type type)"
      ],
      "fixed_signatures": [
        "public class TypeUtils { public TypeUtils()",
        "public static boolean isAssignable(Type type, Type toType)",
        "private static boolean isAssignable(Type type, Type toType, Map<TypeVariable<?>, Type> typeVarAssigns)",
        "private static boolean isAssignable(Type type, Class<?> toClass)",
        "private static boolean isAssignable(Type type, ParameterizedType toParameterizedType, Map<TypeVariable<?>, Type> typeVarAssigns)",
        "private static Type unrollVariableAssignments(TypeVariable<?> var, Map<TypeVariable<?>, Type> typeVarAssigns)",
        "private static boolean isAssignable(Type type, GenericArrayType toGenericArrayType, Map<TypeVariable<?>, Type> typeVarAssigns)",
        "private static boolean isAssignable(Type type, WildcardType toWildcardType, Map<TypeVariable<?>, Type> typeVarAssigns)",
        "private static boolean isAssignable(Type type, TypeVariable<?> toTypeVariable, Map<TypeVariable<?>, Type> typeVarAssigns)",
        "private static Type substituteTypeVariables(Type type, Map<TypeVariable<?>, Type> typeVarAssigns)",
        "public static Map<TypeVariable<?>, Type> getTypeArguments(ParameterizedType type)",
        "public static Map<TypeVariable<?>, Type> getTypeArguments(Type type, Class<?> toClass)",
        "private static Map<TypeVariable<?>, Type> getTypeArguments(Type type, Class<?> toClass, Map<TypeVariable<?>, Type> subtypeVarAssigns)",
        "private static Map<TypeVariable<?>, Type> getTypeArguments( ParameterizedType parameterizedType, Class<?> toClass, Map<TypeVariable<?>, Type> subtypeVarAssigns)",
        "private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, Class<?> toClass, Map<TypeVariable<?>, Type> subtypeVarAssigns)",
        "public static Map<TypeVariable<?>, Type> determineTypeArguments(Class<?> cls, ParameterizedType superType)",
        "private static <T> void mapTypeVariablesToArguments(Class<T> cls, ParameterizedType parameterizedType, Map<TypeVariable<?>, Type> typeVarAssigns)",
        "private static Type getClosestParentType(Class<?> cls, Class<?> superClass)",
        "public static boolean isInstance(Object value, Type type)",
        "public static Type[] normalizeUpperBounds(Type[] bounds)",
        "public static Type[] getImplicitBounds(TypeVariable<?> typeVariable)",
        "public static Type[] getImplicitUpperBounds(WildcardType wildcardType)",
        "public static Type[] getImplicitLowerBounds(WildcardType wildcardType)",
        "public static boolean typesSatisfyVariables(Map<TypeVariable<?>, Type> typeVarAssigns)",
        "private static Class<?> getRawType(ParameterizedType parameterizedType)",
        "public static Class<?> getRawType(Type type, Type assigningType)",
        "public static boolean isArrayType(Type type)",
        "public static Type getArrayComponentType(Type type)"
      ],
      "methods": [
        {
          "buggy_method": "  private static boolean isAssignable(Type type, ParameterizedType toParameterizedType, Map<TypeVariable<?>, Type> typeVarAssigns) {\n  if (type == null) {\n  return true;\n  }\n\n  \n  \n  if (toParameterizedType == null) {\n  return false;\n  }\n\n  \n  if (toParameterizedType.equals(type)) {\n  return true;\n  }\n\n  \n  Class<?> toClass = getRawType(toParameterizedType);\n  \n  \n  Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null);\n\n  \n  if (fromTypeVarAssigns == null) {\n  return false;\n  }\n\n  \n  \n  \n  if (fromTypeVarAssigns.isEmpty()) {\n  return true;\n  }\n\n  \n  Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType,\n  toClass, typeVarAssigns);\n\n  \n  for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\n  Type toTypeArg = entry.getValue();\n  Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n\n  \n  \n  \n  if (fromTypeArg != null\n  && !toTypeArg.equals(fromTypeArg)\n  && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,\n  typeVarAssigns))) {\n  return false;\n  }\n  }\n\n  return true;\n  }",
          "fixed_method": "  private static boolean isAssignable(Type type, ParameterizedType toParameterizedType, Map<TypeVariable<?>, Type> typeVarAssigns) {\n  if (type == null) {\n  return true;\n  }\n\n  \n  \n  if (toParameterizedType == null) {\n  return false;\n  }\n\n  \n  if (toParameterizedType.equals(type)) {\n  return true;\n  }\n\n  \n  Class<?> toClass = getRawType(toParameterizedType);\n  \n  \n  Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null);\n\n  \n  if (fromTypeVarAssigns == null) {\n  return false;\n  }\n\n  \n  \n  \n  if (fromTypeVarAssigns.isEmpty()) {\n  return true;\n  }\n\n  \n  Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType,\n  toClass, typeVarAssigns);\n\n  \n  for (TypeVariable<?> var : toTypeVarAssigns.keySet()) {\n  Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns);\n  Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns);\n\n  \n  \n  \n  if (fromTypeArg != null\n  && !toTypeArg.equals(fromTypeArg)\n  && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,\n  typeVarAssigns))) {\n  return false;\n  }\n  }\n\n  return true;\n  }",
          "diff": [
            "@@ -216,9 +216,9 @@",
            "                 toClass, typeVarAssigns);\n",
            " \n",
            "         // now to check each type argument\n",
            "-        for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\n",
            "-            Type toTypeArg = entry.getValue();\n",
            "-            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n",
            "+        for (TypeVariable<?> var : toTypeVarAssigns.keySet()) {\n",
            "+            Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns);\n",
            "+            Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns);\n",
            " \n",
            "             // parameters must either be absent from the subject type, within\n",
            "             // the bounds of the wildcard type, or be an exact match to the\n"
          ],
          "changed_lines": 6
        },
        {
          "buggy_method": "  private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, Class<?> toClass, Map<TypeVariable<?>, Type> subtypeVarAssigns) {\n  \n  if (!isAssignable(cls, toClass)) {\n  return null;\n  }\n\n  \n  if (cls.isPrimitive()) {\n  \n  if (toClass.isPrimitive()) {\n  \n  \n  return new HashMap<TypeVariable<?>, Type>();\n  }\n\n  \n  cls = ClassUtils.primitiveToWrapper(cls);\n  }\n\n  \n  HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>()\n  : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n\n  \n  if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {\n  return typeVarAssigns;\n  }\n\n  \n  return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);\n  }",
          "fixed_method": "  private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, Class<?> toClass, Map<TypeVariable<?>, Type> subtypeVarAssigns) {\n  \n  if (!isAssignable(cls, toClass)) {\n  return null;\n  }\n\n  \n  if (cls.isPrimitive()) {\n  \n  if (toClass.isPrimitive()) {\n  \n  \n  return new HashMap<TypeVariable<?>, Type>();\n  }\n\n  \n  cls = ClassUtils.primitiveToWrapper(cls);\n  }\n\n  \n  HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>()\n  : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n\n  \n  if (toClass.equals(cls)) {\n  return typeVarAssigns;\n  }\n\n  \n  return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);\n  }",
          "diff": [
            "@@ -672,7 +672,7 @@",
            "                 : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n",
            " \n",
            "         // has target class been reached?\n",
            "-        if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {\n",
            "+        if (toClass.equals(cls)) {\n",
            "             return typeVarAssigns;\n",
            "         }\n",
            " \n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
