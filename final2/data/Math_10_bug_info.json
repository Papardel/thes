{
  "bug_id": "10",
  "failed_tests": {
    "org.apache.commons.math3.analysis.differentiation.DerivativeStructureTest": [
      {
        "methodName": "testAtan2SpecialCases",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<0.0> but was:<NaN>",
        "fail_line": "        Assert.assertEquals(0, pp.getValue(), 1.0e-15);",
        "test_source": "  public void testAtan2SpecialCases() {\n\n  DerivativeStructure pp =\n  DerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, +0.0),\n  new DerivativeStructure(2, 2, 1, +0.0));\n  Assert.assertEquals(0, pp.getValue(), 1.0e-15);\n  Assert.assertEquals(+1, FastMath.copySign(1, pp.getValue()), 1.0e-15);\n\n  DerivativeStructure pn =\n  DerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, +0.0),\n  new DerivativeStructure(2, 2, 1, -0.0));\n  Assert.assertEquals(FastMath.PI, pn.getValue(), 1.0e-15);\n\n  DerivativeStructure np =\n  DerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, -0.0),\n  new DerivativeStructure(2, 2, 1, +0.0));\n  Assert.assertEquals(0, np.getValue(), 1.0e-15);\n  Assert.assertEquals(-1, FastMath.copySign(1, np.getValue()), 1.0e-15);\n\n  DerivativeStructure nn =\n  DerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, -0.0),\n  new DerivativeStructure(2, 2, 1, -0.0));\n  Assert.assertEquals(-FastMath.PI, nn.getValue(), 1.0e-15);\n\n  }",
        "stack": [
          "DerivativeStructureTest.testAtan2SpecialCases line 816"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math3/analysis/differentiation/DSCompiler.java",
      "buggy_full_code": "\npackage org.apache.commons.math3.analysis.differentiation;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.math3.exception.DimensionMismatchException;\nimport org.apache.commons.math3.exception.NumberIsTooLargeException;\nimport org.apache.commons.math3.util.ArithmeticUtils;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.util.MathArrays;\n\n\npublic class DSCompiler { private static AtomicReference<DSCompiler[][]> compilers = new AtomicReference<DSCompiler[][]>(null); private final int parameters; private final int order; private final int[][] sizes; private final int[][] derivativesIndirection; private final int[] lowerIndirection; private final int[][][] multIndirection; private final int[][][] compIndirection; private DSCompiler(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler) {\n\n        this.parameters = parameters;\n        this.order      = order;\n        this.sizes      = compileSizes(parameters, order, valueCompiler);\n        this.derivativesIndirection =\n                compileDerivativesIndirection(parameters, order,\n                                              valueCompiler, derivativeCompiler);\n        this.lowerIndirection =\n                compileLowerIndirection(parameters, order,\n                                        valueCompiler, derivativeCompiler);\n        this.multIndirection =\n                compileMultiplicationIndirection(parameters, order,\n                                                 valueCompiler, derivativeCompiler, lowerIndirection);\n        this.compIndirection =\n                compileCompositionIndirection(parameters, order,\n                                              valueCompiler, derivativeCompiler,\n                                              sizes, derivativesIndirection);\n\n    }\n\n    \n    public static DSCompiler getCompiler(int parameters, int order) {\n\n        \n        final DSCompiler[][] cache = compilers.get();\n        if (cache != null && cache.length > parameters && cache[parameters].length > order) {\n            if (cache[parameters][order] != null) {\n                \n                return cache[parameters][order];\n            }\n        }\n\n        \n        final int maxParameters = FastMath.max(parameters, cache == null ? 0 : cache.length);\n        final int maxOrder      = FastMath.max(order,     cache == null ? 0 : cache[0].length);\n        final DSCompiler[][] newCache = new DSCompiler[maxParameters + 1][maxOrder + 1];\n\n        if (cache != null) {\n            \n            for (int i = 0; i < cache.length; ++i) {\n                System.arraycopy(cache[i], 0, newCache[i], 0, cache[i].length);\n            }\n        }\n\n        \n        for (int diag = 0; diag <= parameters + order; ++diag) {\n            for (int o = FastMath.max(0, diag - parameters); o <= FastMath.min(order, diag); ++o) {\n                final int p = diag - o;\n                if (newCache[p][o] == null) {\n                    final DSCompiler valueCompiler      = (p == 0) ? null : newCache[p - 1][o];\n                    final DSCompiler derivativeCompiler = (o == 0) ? null : newCache[p][o - 1];\n                    newCache[p][o] = new DSCompiler(p, o, valueCompiler, derivativeCompiler);\n                }\n            }\n        }\n\n        \n        compilers.compareAndSet(cache, newCache);\n\n        return newCache[parameters][order];\n\n    }\n\n    \n    private static int[][] compileSizes(final int parameters, final int order, final DSCompiler valueCompiler) {\n\n        final int[][] sizes = new int[parameters + 1][order + 1];\n        if (parameters == 0) {\n            Arrays.fill(sizes[0], 1);\n        } else {\n            System.arraycopy(valueCompiler.sizes, 0, sizes, 0, parameters);\n            sizes[parameters][0] = 1;\n            for (int i = 0; i < order; ++i) {\n                sizes[parameters][i + 1] = sizes[parameters][i] + sizes[parameters - 1][i + 1];\n            }\n        }\n\n        return sizes;\n\n    }\n\n    \n    private static int[][] compileDerivativesIndirection(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler) {\n\n        if (parameters == 0 || order == 0) {\n            return new int[1][parameters];\n        }\n\n        final int vSize = valueCompiler.derivativesIndirection.length;\n        final int dSize = derivativeCompiler.derivativesIndirection.length;\n        final int[][] derivativesIndirection = new int[vSize + dSize][parameters];\n\n        \n        for (int i = 0; i < vSize; ++i) {\n            \n            System.arraycopy(valueCompiler.derivativesIndirection[i], 0,\n                             derivativesIndirection[i], 0,\n                             parameters - 1);\n        }\n\n        \n        for (int i = 0; i < dSize; ++i) {\n\n            \n            System.arraycopy(derivativeCompiler.derivativesIndirection[i], 0,\n                             derivativesIndirection[vSize + i], 0,\n                             parameters);\n\n            \n            derivativesIndirection[vSize + i][parameters - 1]++;\n\n        }\n\n        return derivativesIndirection;\n\n    }\n\n    \n    private static int[] compileLowerIndirection(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler) {\n\n        if (parameters == 0 || order <= 1) {\n            return new int[] { 0 };\n        }\n\n        \n        final int vSize = valueCompiler.lowerIndirection.length;\n        final int dSize = derivativeCompiler.lowerIndirection.length;\n        final int[] lowerIndirection = new int[vSize + dSize];\n        System.arraycopy(valueCompiler.lowerIndirection, 0, lowerIndirection, 0, vSize);\n        for (int i = 0; i < dSize; ++i) {\n            lowerIndirection[vSize + i] = valueCompiler.getSize() + derivativeCompiler.lowerIndirection[i];\n        }\n\n        return lowerIndirection;\n\n    }\n\n    \n    private static int[][][] compileMultiplicationIndirection(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler, final int[] lowerIndirection) {\n\n        if ((parameters == 0) || (order == 0)) {\n            return new int[][][] { { { 1, 0, 0 } } };\n        }\n\n        \n        final int vSize = valueCompiler.multIndirection.length;\n        final int dSize = derivativeCompiler.multIndirection.length;\n        final int[][][] multIndirection = new int[vSize + dSize][][];\n\n        System.arraycopy(valueCompiler.multIndirection, 0, multIndirection, 0, vSize);\n\n        for (int i = 0; i < dSize; ++i) {\n            final int[][] dRow = derivativeCompiler.multIndirection[i];\n            List<int[]> row = new ArrayList<int[]>();\n            for (int j = 0; j < dRow.length; ++j) {\n                row.add(new int[] { dRow[j][0], lowerIndirection[dRow[j][1]], vSize + dRow[j][2] });\n                row.add(new int[] { dRow[j][0], vSize + dRow[j][1], lowerIndirection[dRow[j][2]] });\n            }\n\n            \n            final List<int[]> combined = new ArrayList<int[]>(row.size());\n            for (int j = 0; j < row.size(); ++j) {\n                final int[] termJ = row.get(j);\n                if (termJ[0] > 0) {\n                    for (int k = j + 1; k < row.size(); ++k) {\n                        final int[] termK = row.get(k);\n                        if (termJ[1] == termK[1] && termJ[2] == termK[2]) {\n                            \n                            termJ[0] += termK[0];\n                            \n                            termK[0] = 0;\n                        }\n                    }\n                    combined.add(termJ);\n                }\n            }\n\n            multIndirection[vSize + i] = combined.toArray(new int[combined.size()][]);\n\n        }\n\n        return multIndirection;\n\n    }\n\n    \n    private static int[][][] compileCompositionIndirection(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler, final int[][] sizes, final int[][] derivativesIndirection) {\n\n        if ((parameters == 0) || (order == 0)) {\n            return new int[][][] { { { 1, 0 } } };\n        }\n\n        final int vSize = valueCompiler.compIndirection.length;\n        final int dSize = derivativeCompiler.compIndirection.length;\n        final int[][][] compIndirection = new int[vSize + dSize][][];\n\n        \n        System.arraycopy(valueCompiler.compIndirection, 0, compIndirection, 0, vSize);\n\n        \n        \n        \n        \n        for (int i = 0; i < dSize; ++i) {\n            List<int[]> row = new ArrayList<int[]>();\n            for (int[] term : derivativeCompiler.compIndirection[i]) {\n\n                \n\n                \n                int[] derivedTermF = new int[term.length + 1];\n                derivedTermF[0] = term[0];     \n                derivedTermF[1] = term[1] + 1; \n                int[] orders = new int[parameters];\n                orders[parameters - 1] = 1;\n                derivedTermF[term.length] = getPartialDerivativeIndex(parameters, order, sizes, orders);  \n                for (int j = 2; j < term.length; ++j) {\n                    \n                    \n                    derivedTermF[j] = convertIndex(term[j], parameters,\n                                                   derivativeCompiler.derivativesIndirection,\n                                                   parameters, order, sizes);\n                }\n                Arrays.sort(derivedTermF, 2, derivedTermF.length);\n                row.add(derivedTermF);\n\n                \n                for (int l = 2; l < term.length; ++l) {\n                    int[] derivedTermG = new int[term.length];\n                    derivedTermG[0] = term[0];\n                    derivedTermG[1] = term[1];\n                    for (int j = 2; j < term.length; ++j) {\n                        \n                        \n                        derivedTermG[j] = convertIndex(term[j], parameters,\n                                                       derivativeCompiler.derivativesIndirection,\n                                                       parameters, order, sizes);\n                        if (j == l) {\n                            \n                            System.arraycopy(derivativesIndirection[derivedTermG[j]], 0, orders, 0, parameters);\n                            orders[parameters - 1]++;\n                            derivedTermG[j] = getPartialDerivativeIndex(parameters, order, sizes, orders);\n                        }\n                    }\n                    Arrays.sort(derivedTermG, 2, derivedTermG.length);\n                    row.add(derivedTermG);\n                }\n\n            }\n\n            \n            final List<int[]> combined = new ArrayList<int[]>(row.size());\n            for (int j = 0; j < row.size(); ++j) {\n                final int[] termJ = row.get(j);\n                if (termJ[0] > 0) {\n                    for (int k = j + 1; k < row.size(); ++k) {\n                        final int[] termK = row.get(k);\n                        boolean equals = termJ.length == termK.length;\n                        for (int l = 1; equals && l < termJ.length; ++l) {\n                            equals &= termJ[l] == termK[l];\n                        }\n                        if (equals) {\n                            \n                            termJ[0] += termK[0];\n                            \n                            termK[0] = 0;\n                        }\n                    }\n                    combined.add(termJ);\n                }\n            }\n\n            compIndirection[vSize + i] = combined.toArray(new int[combined.size()][]);\n\n        }\n\n        return compIndirection;\n\n    }\n\n    \n    public int getPartialDerivativeIndex(final int ... orders) throws DimensionMismatchException, NumberIsTooLargeException {\n\n        \n        if (orders.length != getFreeParameters()) {\n            throw new DimensionMismatchException(orders.length, getFreeParameters());\n        }\n\n        return getPartialDerivativeIndex(parameters, order, sizes, orders);\n\n    }\n\n    \n    private static int getPartialDerivativeIndex(final int parameters, final int order, final int[][] sizes, final int ... orders) throws NumberIsTooLargeException {\n\n        \n        \n        int index     = 0;\n        int m         = order;\n        int ordersSum = 0;\n        for (int i = parameters - 1; i >= 0; --i) {\n\n            \n            int derivativeOrder = orders[i];\n\n            \n            ordersSum += derivativeOrder;\n            if (ordersSum > order) {\n                throw new NumberIsTooLargeException(ordersSum, order, true);\n            }\n\n            while (derivativeOrder-- > 0) {\n                \n                \n                \n                index += sizes[i][m--];\n            }\n\n        }\n\n        return index;\n\n    }\n\n    \n    private static int convertIndex(final int index, final int srcP, final int[][] srcDerivativesIndirection, final int destP, final int destO, final int[][] destSizes) {\n        int[] orders = new int[destP];\n        System.arraycopy(srcDerivativesIndirection[index], 0, orders, 0, FastMath.min(srcP, destP));\n        return getPartialDerivativeIndex(destP, destO, destSizes, orders);\n    }\n\n    \n    public int[] getPartialDerivativeOrders(final int index) {\n        return derivativesIndirection[index];\n    }\n\n    \n    public int getFreeParameters() {\n        return parameters;\n    }\n\n    \n    public int getOrder() {\n        return order;\n    }\n\n    \n    public int getSize() {\n        return sizes[parameters][order];\n    }\n\n    \n    public void linearCombination(final double a1, final double[] c1, final int offset1, final double a2, final double[] c2, final int offset2, final double[] result, final int resultOffset) {\n        for (int i = 0; i < getSize(); ++i) {\n            result[resultOffset + i] =\n                    MathArrays.linearCombination(a1, c1[offset1 + i], a2, c2[offset2 + i]);\n        }\n    }\n\n    \n    public void linearCombination(final double a1, final double[] c1, final int offset1, final double a2, final double[] c2, final int offset2, final double a3, final double[] c3, final int offset3, final double[] result, final int resultOffset) {\n        for (int i = 0; i < getSize(); ++i) {\n            result[resultOffset + i] =\n                    MathArrays.linearCombination(a1, c1[offset1 + i],\n                                                 a2, c2[offset2 + i],\n                                                 a3, c3[offset3 + i]);\n        }\n    }\n\n    \n    public void linearCombination(final double a1, final double[] c1, final int offset1, final double a2, final double[] c2, final int offset2, final double a3, final double[] c3, final int offset3, final double a4, final double[] c4, final int offset4, final double[] result, final int resultOffset) {\n        for (int i = 0; i < getSize(); ++i) {\n            result[resultOffset + i] =\n                    MathArrays.linearCombination(a1, c1[offset1 + i],\n                                                 a2, c2[offset2 + i],\n                                                 a3, c3[offset3 + i],\n                                                 a4, c4[offset4 + i]);\n        }\n    }\n\n    \n    public void add(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) {\n        for (int i = 0; i < getSize(); ++i) {\n            result[resultOffset + i] = lhs[lhsOffset + i] + rhs[rhsOffset + i];\n        }\n    }\n    \n    public void subtract(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) {\n        for (int i = 0; i < getSize(); ++i) {\n            result[resultOffset + i] = lhs[lhsOffset + i] - rhs[rhsOffset + i];\n        }\n    }\n\n    \n    public void multiply(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) {\n        for (int i = 0; i < multIndirection.length; ++i) {\n            final int[][] mappingI = multIndirection[i];\n            double r = 0;\n            for (int j = 0; j < mappingI.length; ++j) {\n                r += mappingI[j][0] *\n                     lhs[lhsOffset + mappingI[j][1]] *\n                     rhs[rhsOffset + mappingI[j][2]];\n            }\n            result[resultOffset + i] = r;\n        }\n    }\n\n    \n    public void divide(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) {\n        final double[] reciprocal = new double[getSize()];\n        pow(rhs, lhsOffset, -1, reciprocal, 0);\n        multiply(lhs, lhsOffset, reciprocal, 0, result, resultOffset);\n    }\n\n    \n    public void remainder(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) {\n\n        \n        final double rem = lhs[lhsOffset] % rhs[rhsOffset];\n        final double k   = FastMath.rint((lhs[lhsOffset] - rem) / rhs[rhsOffset]);\n\n        \n        result[resultOffset] = rem;\n\n        \n        for (int i = 1; i < getSize(); ++i) {\n            result[resultOffset + i] = lhs[lhsOffset + i] - k * rhs[rhsOffset + i];\n        }\n\n    }\n\n    \n    public void pow(final double[] operand, final int operandOffset, final double p, final double[] result, final int resultOffset) {\n\n        \n        \n        double[] function = new double[1 + order];\n        double xk = FastMath.pow(operand[operandOffset], p - order);\n        for (int i = order; i > 0; --i) {\n            function[i] = xk;\n            xk *= operand[operandOffset];\n        }\n        function[0] = xk;\n        double coefficient = p;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= p - i;\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void pow(final double[] operand, final int operandOffset, final int n, final double[] result, final int resultOffset) {\n\n        if (n == 0) {\n            \n            result[resultOffset] = 1.0;\n            Arrays.fill(result, resultOffset + 1, resultOffset + getSize(), 0);\n            return;\n        }\n\n        \n        \n        double[] function = new double[1 + order];\n\n        if (n > 0) {\n            \n            final int maxOrder = FastMath.min(order, n);\n            double xk = FastMath.pow(operand[operandOffset], n - maxOrder);\n            for (int i = maxOrder; i > 0; --i) {\n                function[i] = xk;\n                xk *= operand[operandOffset];\n            }\n            function[0] = xk;\n        } else {\n            \n            final double inv = 1.0 / operand[operandOffset];\n            double xk = FastMath.pow(inv, -n);\n            for (int i = 0; i <= order; ++i) {\n                function[i] = xk;\n                xk *= inv;\n            }\n        }\n\n        double coefficient = n;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= n - i;\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void pow(final double[] x, final int xOffset, final double[] y, final int yOffset, final double[] result, final int resultOffset) {\n        final double[] logX = new double[getSize()];\n        log(x, xOffset, logX, 0);\n        final double[] yLogX = new double[getSize()];\n        multiply(logX, 0, y, yOffset, yLogX, 0);\n        exp(yLogX, 0, result, resultOffset);\n    }\n\n    \n    public void rootN(final double[] operand, final int operandOffset, final int n, final double[] result, final int resultOffset) {\n\n        \n        \n        double[] function = new double[1 + order];\n        double xk;\n        if (n == 2) {\n            function[0] = FastMath.sqrt(operand[operandOffset]);\n            xk          = 0.5 / function[0];\n        } else if (n == 3) {\n            function[0] = FastMath.cbrt(operand[operandOffset]);\n            xk          = 1.0 / (3.0 * function[0] * function[0]);\n        } else {\n            function[0] = FastMath.pow(operand[operandOffset], 1.0 / n);\n            xk          = 1.0 / (n * FastMath.pow(function[0], n - 1));\n        }\n        final double nReciprocal = 1.0 / n;\n        final double xReciprocal = 1.0 / operand[operandOffset];\n        for (int i = 1; i <= order; ++i) {\n            function[i] = xk;\n            xk *= xReciprocal * (nReciprocal - i);\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void exp(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        Arrays.fill(function, FastMath.exp(operand[operandOffset]));\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void expm1(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        function[0] = FastMath.expm1(operand[operandOffset]);\n        Arrays.fill(function, 1, 1 + order, FastMath.exp(operand[operandOffset]));\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void log(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        function[0] = FastMath.log(operand[operandOffset]);\n        if (order > 0) {\n            double inv = 1.0 / operand[operandOffset];\n            double xk  = inv;\n            for (int i = 1; i <= order; ++i) {\n                function[i] = xk;\n                xk *= -i * inv;\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void log1p(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        function[0] = FastMath.log1p(operand[operandOffset]);\n        if (order > 0) {\n            double inv = 1.0 / (1.0 + operand[operandOffset]);\n            double xk  = inv;\n            for (int i = 1; i <= order; ++i) {\n                function[i] = xk;\n                xk *= -i * inv;\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void log10(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        function[0] = FastMath.log10(operand[operandOffset]);\n        if (order > 0) {\n            double inv = 1.0 / operand[operandOffset];\n            double xk  = inv / FastMath.log(10.0);\n            for (int i = 1; i <= order; ++i) {\n                function[i] = xk;\n                xk *= -i * inv;\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void cos(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        function[0] = FastMath.cos(operand[operandOffset]);\n        if (order > 0) {\n            function[1] = -FastMath.sin(operand[operandOffset]);\n            for (int i = 2; i <= order; ++i) {\n                function[i] = -function[i - 2];\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void sin(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        function[0] = FastMath.sin(operand[operandOffset]);\n        if (order > 0) {\n            function[1] = FastMath.cos(operand[operandOffset]);\n            for (int i = 2; i <= order; ++i) {\n                function[i] = -function[i - 2];\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void tan(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            \n            \n            \n            \n            \n            \n            \n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                \n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void acos(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acos(x);\n        if (order > 0) {\n            \n            \n            \n            \n            \n            \n            \n            final double[] p = new double[order];\n            p[0] = -1;\n            final double x2    = x * x;\n            final double f     = 1.0 / (1 - x2);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                \n                double v = 0;\n                p[n - 1] = (n - 1) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (2 * n - k) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void asin(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.asin(x);\n        if (order > 0) {\n            \n            \n            \n            \n            \n            \n            \n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2    = x * x;\n            final double f     = 1.0 / (1 - x2);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                \n                double v = 0;\n                p[n - 1] = (n - 1) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (2 * n - k) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void atan(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.atan(x);\n        if (order > 0) {\n            \n            \n            \n            \n            \n            \n            \n            final double[] q = new double[order];\n            q[0] = 1;\n            final double x2    = x * x;\n            final double f     = 1.0 / (1 + x2);\n            double coeff = f;\n            function[1] = coeff * q[0];\n            for (int n = 2; n <= order; ++n) {\n\n                \n                double v = 0;\n                q[n - 1] = -n * q[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + q[k];\n                    if (k > 2) {\n                        q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3];\n                    } else if (k == 2) {\n                        q[0] = q[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void atan2(final double[] y, final int yOffset, final double[] x, final int xOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] tmp1 = new double[getSize()];\n        multiply(x, xOffset, x, xOffset, tmp1, 0);      \n        double[] tmp2 = new double[getSize()];\n        multiply(y, yOffset, y, yOffset, tmp2, 0);      \n        add(tmp1, 0, tmp2, 0, tmp2, 0);                 \n        rootN(tmp2, 0, 2, tmp1, 0);                     \n\n        if (x[xOffset] >= 0) {\n\n            \n            add(tmp1, 0, x, xOffset, tmp2, 0);          \n            divide(y, yOffset, tmp2, 0, tmp1, 0);       \n            atan(tmp1, 0, tmp2, 0);                     \n            for (int i = 0; i < tmp2.length; ++i) {\n                result[resultOffset + i] = 2 * tmp2[i]; \n            }\n\n        } else {\n\n            \n            subtract(tmp1, 0, x, xOffset, tmp2, 0);     \n            divide(y, yOffset, tmp2, 0, tmp1, 0);       \n            atan(tmp1, 0, tmp2, 0);                     \n            result[resultOffset] =\n                    ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; \n            for (int i = 1; i < tmp2.length; ++i) {\n                result[resultOffset + i] = -2 * tmp2[i]; \n            }\n\n        }\n\n        \n\n    }\n\n    \n    public void cosh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        function[0] = FastMath.cosh(operand[operandOffset]);\n        if (order > 0) {\n            function[1] = FastMath.sinh(operand[operandOffset]);\n            for (int i = 2; i <= order; ++i) {\n                function[i] = function[i - 2];\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void sinh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        function[0] = FastMath.sinh(operand[operandOffset]);\n        if (order > 0) {\n            function[1] = FastMath.cosh(operand[operandOffset]);\n            for (int i = 2; i <= order; ++i) {\n                function[i] = function[i - 2];\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void tanh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        final double[] function = new double[1 + order];\n        final double t = FastMath.tanh(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            \n            \n            \n            \n            \n            \n            \n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                \n                double v = 0;\n                p[n + 1] = -n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] - (k - 3) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void acosh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            \n            \n            \n            \n            \n            \n            \n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                \n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void asinh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.asinh(x);\n        if (order > 0) {\n            \n            \n            \n            \n            \n            \n            \n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2    = x * x;\n            final double f     = 1.0 / (1 + x2);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                \n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void atanh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.atanh(x);\n        if (order > 0) {\n            \n            \n            \n            \n            \n            \n            \n            final double[] q = new double[order];\n            q[0] = 1;\n            final double x2 = x * x;\n            final double f  = 1.0 / (1 - x2);\n            double coeff = f;\n            function[1] = coeff * q[0];\n            for (int n = 2; n <= order; ++n) {\n\n                \n                double v = 0;\n                q[n - 1] = n * q[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + q[k];\n                    if (k > 2) {\n                        q[k - 2] = (k - 1) * q[k - 1] + (2 * n - k + 1) * q[k - 3];\n                    } else if (k == 2) {\n                        q[0] = q[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void compose(final double[] operand, final int operandOffset, final double[] f, final double[] result, final int resultOffset) {\n        for (int i = 0; i < compIndirection.length; ++i) {\n            final int[][] mappingI = compIndirection[i];\n            double r = 0;\n            for (int j = 0; j < mappingI.length; ++j) {\n                final int[] mappingIJ = mappingI[j];\n                double product = mappingIJ[0] * f[mappingIJ[1]];\n                for (int k = 2; k < mappingIJ.length; ++k) {\n                    product *= operand[operandOffset + mappingIJ[k]];\n                }\n                r += product;\n            }\n            result[resultOffset + i] = r;\n        }\n    }\n\n    \n    public double taylor(final double[] ds, final int dsOffset, final double ... delta) {\n        double value = 0;\n        for (int i = getSize() - 1; i >= 0; --i) {\n            final int[] orders = getPartialDerivativeOrders(i);\n            double term = ds[dsOffset + i];\n            for (int k = 0; k < orders.length; ++k) {\n                if (orders[k] > 0) {\n                    term *= FastMath.pow(delta[k], orders[k]) / ArithmeticUtils.factorial(orders[k]);\n                }\n            }\n            value += term;\n        }\n        return value;\n    }\n\n    \n    public void checkCompatibility(final DSCompiler compiler) throws DimensionMismatchException {\n        if (parameters != compiler.parameters) {\n            throw new DimensionMismatchException(parameters, compiler.parameters);\n        }\n        if (order != compiler.order) {\n            throw new DimensionMismatchException(order, compiler.order);\n        }\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.math3.analysis.differentiation;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.math3.exception.DimensionMismatchException;\nimport org.apache.commons.math3.exception.NumberIsTooLargeException;\nimport org.apache.commons.math3.util.ArithmeticUtils;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.util.MathArrays;\n\n\npublic class DSCompiler { private static AtomicReference<DSCompiler[][]> compilers = new AtomicReference<DSCompiler[][]>(null); private final int parameters; private final int order; private final int[][] sizes; private final int[][] derivativesIndirection; private final int[] lowerIndirection; private final int[][][] multIndirection; private final int[][][] compIndirection; private DSCompiler(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler) {\n\n        this.parameters = parameters;\n        this.order      = order;\n        this.sizes      = compileSizes(parameters, order, valueCompiler);\n        this.derivativesIndirection =\n                compileDerivativesIndirection(parameters, order,\n                                              valueCompiler, derivativeCompiler);\n        this.lowerIndirection =\n                compileLowerIndirection(parameters, order,\n                                        valueCompiler, derivativeCompiler);\n        this.multIndirection =\n                compileMultiplicationIndirection(parameters, order,\n                                                 valueCompiler, derivativeCompiler, lowerIndirection);\n        this.compIndirection =\n                compileCompositionIndirection(parameters, order,\n                                              valueCompiler, derivativeCompiler,\n                                              sizes, derivativesIndirection);\n\n    }\n\n    \n    public static DSCompiler getCompiler(int parameters, int order) {\n\n        \n        final DSCompiler[][] cache = compilers.get();\n        if (cache != null && cache.length > parameters && cache[parameters].length > order) {\n            if (cache[parameters][order] != null) {\n                \n                return cache[parameters][order];\n            }\n        }\n\n        \n        final int maxParameters = FastMath.max(parameters, cache == null ? 0 : cache.length);\n        final int maxOrder      = FastMath.max(order,     cache == null ? 0 : cache[0].length);\n        final DSCompiler[][] newCache = new DSCompiler[maxParameters + 1][maxOrder + 1];\n\n        if (cache != null) {\n            \n            for (int i = 0; i < cache.length; ++i) {\n                System.arraycopy(cache[i], 0, newCache[i], 0, cache[i].length);\n            }\n        }\n\n        \n        for (int diag = 0; diag <= parameters + order; ++diag) {\n            for (int o = FastMath.max(0, diag - parameters); o <= FastMath.min(order, diag); ++o) {\n                final int p = diag - o;\n                if (newCache[p][o] == null) {\n                    final DSCompiler valueCompiler      = (p == 0) ? null : newCache[p - 1][o];\n                    final DSCompiler derivativeCompiler = (o == 0) ? null : newCache[p][o - 1];\n                    newCache[p][o] = new DSCompiler(p, o, valueCompiler, derivativeCompiler);\n                }\n            }\n        }\n\n        \n        compilers.compareAndSet(cache, newCache);\n\n        return newCache[parameters][order];\n\n    }\n\n    \n    private static int[][] compileSizes(final int parameters, final int order, final DSCompiler valueCompiler) {\n\n        final int[][] sizes = new int[parameters + 1][order + 1];\n        if (parameters == 0) {\n            Arrays.fill(sizes[0], 1);\n        } else {\n            System.arraycopy(valueCompiler.sizes, 0, sizes, 0, parameters);\n            sizes[parameters][0] = 1;\n            for (int i = 0; i < order; ++i) {\n                sizes[parameters][i + 1] = sizes[parameters][i] + sizes[parameters - 1][i + 1];\n            }\n        }\n\n        return sizes;\n\n    }\n\n    \n    private static int[][] compileDerivativesIndirection(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler) {\n\n        if (parameters == 0 || order == 0) {\n            return new int[1][parameters];\n        }\n\n        final int vSize = valueCompiler.derivativesIndirection.length;\n        final int dSize = derivativeCompiler.derivativesIndirection.length;\n        final int[][] derivativesIndirection = new int[vSize + dSize][parameters];\n\n        \n        for (int i = 0; i < vSize; ++i) {\n            \n            System.arraycopy(valueCompiler.derivativesIndirection[i], 0,\n                             derivativesIndirection[i], 0,\n                             parameters - 1);\n        }\n\n        \n        for (int i = 0; i < dSize; ++i) {\n\n            \n            System.arraycopy(derivativeCompiler.derivativesIndirection[i], 0,\n                             derivativesIndirection[vSize + i], 0,\n                             parameters);\n\n            \n            derivativesIndirection[vSize + i][parameters - 1]++;\n\n        }\n\n        return derivativesIndirection;\n\n    }\n\n    \n    private static int[] compileLowerIndirection(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler) {\n\n        if (parameters == 0 || order <= 1) {\n            return new int[] { 0 };\n        }\n\n        \n        final int vSize = valueCompiler.lowerIndirection.length;\n        final int dSize = derivativeCompiler.lowerIndirection.length;\n        final int[] lowerIndirection = new int[vSize + dSize];\n        System.arraycopy(valueCompiler.lowerIndirection, 0, lowerIndirection, 0, vSize);\n        for (int i = 0; i < dSize; ++i) {\n            lowerIndirection[vSize + i] = valueCompiler.getSize() + derivativeCompiler.lowerIndirection[i];\n        }\n\n        return lowerIndirection;\n\n    }\n\n    \n    private static int[][][] compileMultiplicationIndirection(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler, final int[] lowerIndirection) {\n\n        if ((parameters == 0) || (order == 0)) {\n            return new int[][][] { { { 1, 0, 0 } } };\n        }\n\n        \n        final int vSize = valueCompiler.multIndirection.length;\n        final int dSize = derivativeCompiler.multIndirection.length;\n        final int[][][] multIndirection = new int[vSize + dSize][][];\n\n        System.arraycopy(valueCompiler.multIndirection, 0, multIndirection, 0, vSize);\n\n        for (int i = 0; i < dSize; ++i) {\n            final int[][] dRow = derivativeCompiler.multIndirection[i];\n            List<int[]> row = new ArrayList<int[]>();\n            for (int j = 0; j < dRow.length; ++j) {\n                row.add(new int[] { dRow[j][0], lowerIndirection[dRow[j][1]], vSize + dRow[j][2] });\n                row.add(new int[] { dRow[j][0], vSize + dRow[j][1], lowerIndirection[dRow[j][2]] });\n            }\n\n            \n            final List<int[]> combined = new ArrayList<int[]>(row.size());\n            for (int j = 0; j < row.size(); ++j) {\n                final int[] termJ = row.get(j);\n                if (termJ[0] > 0) {\n                    for (int k = j + 1; k < row.size(); ++k) {\n                        final int[] termK = row.get(k);\n                        if (termJ[1] == termK[1] && termJ[2] == termK[2]) {\n                            \n                            termJ[0] += termK[0];\n                            \n                            termK[0] = 0;\n                        }\n                    }\n                    combined.add(termJ);\n                }\n            }\n\n            multIndirection[vSize + i] = combined.toArray(new int[combined.size()][]);\n\n        }\n\n        return multIndirection;\n\n    }\n\n    \n    private static int[][][] compileCompositionIndirection(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler, final int[][] sizes, final int[][] derivativesIndirection) {\n\n        if ((parameters == 0) || (order == 0)) {\n            return new int[][][] { { { 1, 0 } } };\n        }\n\n        final int vSize = valueCompiler.compIndirection.length;\n        final int dSize = derivativeCompiler.compIndirection.length;\n        final int[][][] compIndirection = new int[vSize + dSize][][];\n\n        \n        System.arraycopy(valueCompiler.compIndirection, 0, compIndirection, 0, vSize);\n\n        \n        \n        \n        \n        for (int i = 0; i < dSize; ++i) {\n            List<int[]> row = new ArrayList<int[]>();\n            for (int[] term : derivativeCompiler.compIndirection[i]) {\n\n                \n\n                \n                int[] derivedTermF = new int[term.length + 1];\n                derivedTermF[0] = term[0];     \n                derivedTermF[1] = term[1] + 1; \n                int[] orders = new int[parameters];\n                orders[parameters - 1] = 1;\n                derivedTermF[term.length] = getPartialDerivativeIndex(parameters, order, sizes, orders);  \n                for (int j = 2; j < term.length; ++j) {\n                    \n                    \n                    derivedTermF[j] = convertIndex(term[j], parameters,\n                                                   derivativeCompiler.derivativesIndirection,\n                                                   parameters, order, sizes);\n                }\n                Arrays.sort(derivedTermF, 2, derivedTermF.length);\n                row.add(derivedTermF);\n\n                \n                for (int l = 2; l < term.length; ++l) {\n                    int[] derivedTermG = new int[term.length];\n                    derivedTermG[0] = term[0];\n                    derivedTermG[1] = term[1];\n                    for (int j = 2; j < term.length; ++j) {\n                        \n                        \n                        derivedTermG[j] = convertIndex(term[j], parameters,\n                                                       derivativeCompiler.derivativesIndirection,\n                                                       parameters, order, sizes);\n                        if (j == l) {\n                            \n                            System.arraycopy(derivativesIndirection[derivedTermG[j]], 0, orders, 0, parameters);\n                            orders[parameters - 1]++;\n                            derivedTermG[j] = getPartialDerivativeIndex(parameters, order, sizes, orders);\n                        }\n                    }\n                    Arrays.sort(derivedTermG, 2, derivedTermG.length);\n                    row.add(derivedTermG);\n                }\n\n            }\n\n            \n            final List<int[]> combined = new ArrayList<int[]>(row.size());\n            for (int j = 0; j < row.size(); ++j) {\n                final int[] termJ = row.get(j);\n                if (termJ[0] > 0) {\n                    for (int k = j + 1; k < row.size(); ++k) {\n                        final int[] termK = row.get(k);\n                        boolean equals = termJ.length == termK.length;\n                        for (int l = 1; equals && l < termJ.length; ++l) {\n                            equals &= termJ[l] == termK[l];\n                        }\n                        if (equals) {\n                            \n                            termJ[0] += termK[0];\n                            \n                            termK[0] = 0;\n                        }\n                    }\n                    combined.add(termJ);\n                }\n            }\n\n            compIndirection[vSize + i] = combined.toArray(new int[combined.size()][]);\n\n        }\n\n        return compIndirection;\n\n    }\n\n    \n    public int getPartialDerivativeIndex(final int ... orders) throws DimensionMismatchException, NumberIsTooLargeException {\n\n        \n        if (orders.length != getFreeParameters()) {\n            throw new DimensionMismatchException(orders.length, getFreeParameters());\n        }\n\n        return getPartialDerivativeIndex(parameters, order, sizes, orders);\n\n    }\n\n    \n    private static int getPartialDerivativeIndex(final int parameters, final int order, final int[][] sizes, final int ... orders) throws NumberIsTooLargeException {\n\n        \n        \n        int index     = 0;\n        int m         = order;\n        int ordersSum = 0;\n        for (int i = parameters - 1; i >= 0; --i) {\n\n            \n            int derivativeOrder = orders[i];\n\n            \n            ordersSum += derivativeOrder;\n            if (ordersSum > order) {\n                throw new NumberIsTooLargeException(ordersSum, order, true);\n            }\n\n            while (derivativeOrder-- > 0) {\n                \n                \n                \n                index += sizes[i][m--];\n            }\n\n        }\n\n        return index;\n\n    }\n\n    \n    private static int convertIndex(final int index, final int srcP, final int[][] srcDerivativesIndirection, final int destP, final int destO, final int[][] destSizes) {\n        int[] orders = new int[destP];\n        System.arraycopy(srcDerivativesIndirection[index], 0, orders, 0, FastMath.min(srcP, destP));\n        return getPartialDerivativeIndex(destP, destO, destSizes, orders);\n    }\n\n    \n    public int[] getPartialDerivativeOrders(final int index) {\n        return derivativesIndirection[index];\n    }\n\n    \n    public int getFreeParameters() {\n        return parameters;\n    }\n\n    \n    public int getOrder() {\n        return order;\n    }\n\n    \n    public int getSize() {\n        return sizes[parameters][order];\n    }\n\n    \n    public void linearCombination(final double a1, final double[] c1, final int offset1, final double a2, final double[] c2, final int offset2, final double[] result, final int resultOffset) {\n        for (int i = 0; i < getSize(); ++i) {\n            result[resultOffset + i] =\n                    MathArrays.linearCombination(a1, c1[offset1 + i], a2, c2[offset2 + i]);\n        }\n    }\n\n    \n    public void linearCombination(final double a1, final double[] c1, final int offset1, final double a2, final double[] c2, final int offset2, final double a3, final double[] c3, final int offset3, final double[] result, final int resultOffset) {\n        for (int i = 0; i < getSize(); ++i) {\n            result[resultOffset + i] =\n                    MathArrays.linearCombination(a1, c1[offset1 + i],\n                                                 a2, c2[offset2 + i],\n                                                 a3, c3[offset3 + i]);\n        }\n    }\n\n    \n    public void linearCombination(final double a1, final double[] c1, final int offset1, final double a2, final double[] c2, final int offset2, final double a3, final double[] c3, final int offset3, final double a4, final double[] c4, final int offset4, final double[] result, final int resultOffset) {\n        for (int i = 0; i < getSize(); ++i) {\n            result[resultOffset + i] =\n                    MathArrays.linearCombination(a1, c1[offset1 + i],\n                                                 a2, c2[offset2 + i],\n                                                 a3, c3[offset3 + i],\n                                                 a4, c4[offset4 + i]);\n        }\n    }\n\n    \n    public void add(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) {\n        for (int i = 0; i < getSize(); ++i) {\n            result[resultOffset + i] = lhs[lhsOffset + i] + rhs[rhsOffset + i];\n        }\n    }\n    \n    public void subtract(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) {\n        for (int i = 0; i < getSize(); ++i) {\n            result[resultOffset + i] = lhs[lhsOffset + i] - rhs[rhsOffset + i];\n        }\n    }\n\n    \n    public void multiply(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) {\n        for (int i = 0; i < multIndirection.length; ++i) {\n            final int[][] mappingI = multIndirection[i];\n            double r = 0;\n            for (int j = 0; j < mappingI.length; ++j) {\n                r += mappingI[j][0] *\n                     lhs[lhsOffset + mappingI[j][1]] *\n                     rhs[rhsOffset + mappingI[j][2]];\n            }\n            result[resultOffset + i] = r;\n        }\n    }\n\n    \n    public void divide(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) {\n        final double[] reciprocal = new double[getSize()];\n        pow(rhs, lhsOffset, -1, reciprocal, 0);\n        multiply(lhs, lhsOffset, reciprocal, 0, result, resultOffset);\n    }\n\n    \n    public void remainder(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) {\n\n        \n        final double rem = lhs[lhsOffset] % rhs[rhsOffset];\n        final double k   = FastMath.rint((lhs[lhsOffset] - rem) / rhs[rhsOffset]);\n\n        \n        result[resultOffset] = rem;\n\n        \n        for (int i = 1; i < getSize(); ++i) {\n            result[resultOffset + i] = lhs[lhsOffset + i] - k * rhs[rhsOffset + i];\n        }\n\n    }\n\n    \n    public void pow(final double[] operand, final int operandOffset, final double p, final double[] result, final int resultOffset) {\n\n        \n        \n        double[] function = new double[1 + order];\n        double xk = FastMath.pow(operand[operandOffset], p - order);\n        for (int i = order; i > 0; --i) {\n            function[i] = xk;\n            xk *= operand[operandOffset];\n        }\n        function[0] = xk;\n        double coefficient = p;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= p - i;\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void pow(final double[] operand, final int operandOffset, final int n, final double[] result, final int resultOffset) {\n\n        if (n == 0) {\n            \n            result[resultOffset] = 1.0;\n            Arrays.fill(result, resultOffset + 1, resultOffset + getSize(), 0);\n            return;\n        }\n\n        \n        \n        double[] function = new double[1 + order];\n\n        if (n > 0) {\n            \n            final int maxOrder = FastMath.min(order, n);\n            double xk = FastMath.pow(operand[operandOffset], n - maxOrder);\n            for (int i = maxOrder; i > 0; --i) {\n                function[i] = xk;\n                xk *= operand[operandOffset];\n            }\n            function[0] = xk;\n        } else {\n            \n            final double inv = 1.0 / operand[operandOffset];\n            double xk = FastMath.pow(inv, -n);\n            for (int i = 0; i <= order; ++i) {\n                function[i] = xk;\n                xk *= inv;\n            }\n        }\n\n        double coefficient = n;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= n - i;\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void pow(final double[] x, final int xOffset, final double[] y, final int yOffset, final double[] result, final int resultOffset) {\n        final double[] logX = new double[getSize()];\n        log(x, xOffset, logX, 0);\n        final double[] yLogX = new double[getSize()];\n        multiply(logX, 0, y, yOffset, yLogX, 0);\n        exp(yLogX, 0, result, resultOffset);\n    }\n\n    \n    public void rootN(final double[] operand, final int operandOffset, final int n, final double[] result, final int resultOffset) {\n\n        \n        \n        double[] function = new double[1 + order];\n        double xk;\n        if (n == 2) {\n            function[0] = FastMath.sqrt(operand[operandOffset]);\n            xk          = 0.5 / function[0];\n        } else if (n == 3) {\n            function[0] = FastMath.cbrt(operand[operandOffset]);\n            xk          = 1.0 / (3.0 * function[0] * function[0]);\n        } else {\n            function[0] = FastMath.pow(operand[operandOffset], 1.0 / n);\n            xk          = 1.0 / (n * FastMath.pow(function[0], n - 1));\n        }\n        final double nReciprocal = 1.0 / n;\n        final double xReciprocal = 1.0 / operand[operandOffset];\n        for (int i = 1; i <= order; ++i) {\n            function[i] = xk;\n            xk *= xReciprocal * (nReciprocal - i);\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void exp(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        Arrays.fill(function, FastMath.exp(operand[operandOffset]));\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void expm1(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        function[0] = FastMath.expm1(operand[operandOffset]);\n        Arrays.fill(function, 1, 1 + order, FastMath.exp(operand[operandOffset]));\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void log(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        function[0] = FastMath.log(operand[operandOffset]);\n        if (order > 0) {\n            double inv = 1.0 / operand[operandOffset];\n            double xk  = inv;\n            for (int i = 1; i <= order; ++i) {\n                function[i] = xk;\n                xk *= -i * inv;\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void log1p(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        function[0] = FastMath.log1p(operand[operandOffset]);\n        if (order > 0) {\n            double inv = 1.0 / (1.0 + operand[operandOffset]);\n            double xk  = inv;\n            for (int i = 1; i <= order; ++i) {\n                function[i] = xk;\n                xk *= -i * inv;\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void log10(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        function[0] = FastMath.log10(operand[operandOffset]);\n        if (order > 0) {\n            double inv = 1.0 / operand[operandOffset];\n            double xk  = inv / FastMath.log(10.0);\n            for (int i = 1; i <= order; ++i) {\n                function[i] = xk;\n                xk *= -i * inv;\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void cos(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        function[0] = FastMath.cos(operand[operandOffset]);\n        if (order > 0) {\n            function[1] = -FastMath.sin(operand[operandOffset]);\n            for (int i = 2; i <= order; ++i) {\n                function[i] = -function[i - 2];\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void sin(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        function[0] = FastMath.sin(operand[operandOffset]);\n        if (order > 0) {\n            function[1] = FastMath.cos(operand[operandOffset]);\n            for (int i = 2; i <= order; ++i) {\n                function[i] = -function[i - 2];\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void tan(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            \n            \n            \n            \n            \n            \n            \n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                \n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void acos(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acos(x);\n        if (order > 0) {\n            \n            \n            \n            \n            \n            \n            \n            final double[] p = new double[order];\n            p[0] = -1;\n            final double x2    = x * x;\n            final double f     = 1.0 / (1 - x2);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                \n                double v = 0;\n                p[n - 1] = (n - 1) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (2 * n - k) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void asin(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.asin(x);\n        if (order > 0) {\n            \n            \n            \n            \n            \n            \n            \n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2    = x * x;\n            final double f     = 1.0 / (1 - x2);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                \n                double v = 0;\n                p[n - 1] = (n - 1) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (2 * n - k) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void atan(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.atan(x);\n        if (order > 0) {\n            \n            \n            \n            \n            \n            \n            \n            final double[] q = new double[order];\n            q[0] = 1;\n            final double x2    = x * x;\n            final double f     = 1.0 / (1 + x2);\n            double coeff = f;\n            function[1] = coeff * q[0];\n            for (int n = 2; n <= order; ++n) {\n\n                \n                double v = 0;\n                q[n - 1] = -n * q[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + q[k];\n                    if (k > 2) {\n                        q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3];\n                    } else if (k == 2) {\n                        q[0] = q[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void atan2(final double[] y, final int yOffset, final double[] x, final int xOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] tmp1 = new double[getSize()];\n        multiply(x, xOffset, x, xOffset, tmp1, 0);      \n        double[] tmp2 = new double[getSize()];\n        multiply(y, yOffset, y, yOffset, tmp2, 0);      \n        add(tmp1, 0, tmp2, 0, tmp2, 0);                 \n        rootN(tmp2, 0, 2, tmp1, 0);                     \n\n        if (x[xOffset] >= 0) {\n\n            \n            add(tmp1, 0, x, xOffset, tmp2, 0);          \n            divide(y, yOffset, tmp2, 0, tmp1, 0);       \n            atan(tmp1, 0, tmp2, 0);                     \n            for (int i = 0; i < tmp2.length; ++i) {\n                result[resultOffset + i] = 2 * tmp2[i]; \n            }\n\n        } else {\n\n            \n            subtract(tmp1, 0, x, xOffset, tmp2, 0);     \n            divide(y, yOffset, tmp2, 0, tmp1, 0);       \n            atan(tmp1, 0, tmp2, 0);                     \n            result[resultOffset] =\n                    ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; \n            for (int i = 1; i < tmp2.length; ++i) {\n                result[resultOffset + i] = -2 * tmp2[i]; \n            }\n\n        }\n\n        \n        result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);\n\n    }\n\n    \n    public void cosh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        function[0] = FastMath.cosh(operand[operandOffset]);\n        if (order > 0) {\n            function[1] = FastMath.sinh(operand[operandOffset]);\n            for (int i = 2; i <= order; ++i) {\n                function[i] = function[i - 2];\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void sinh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        function[0] = FastMath.sinh(operand[operandOffset]);\n        if (order > 0) {\n            function[1] = FastMath.cosh(operand[operandOffset]);\n            for (int i = 2; i <= order; ++i) {\n                function[i] = function[i - 2];\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void tanh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        final double[] function = new double[1 + order];\n        final double t = FastMath.tanh(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            \n            \n            \n            \n            \n            \n            \n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                \n                double v = 0;\n                p[n + 1] = -n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] - (k - 3) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void acosh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            \n            \n            \n            \n            \n            \n            \n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                \n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void asinh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.asinh(x);\n        if (order > 0) {\n            \n            \n            \n            \n            \n            \n            \n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2    = x * x;\n            final double f     = 1.0 / (1 + x2);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                \n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void atanh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {\n\n        \n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.atanh(x);\n        if (order > 0) {\n            \n            \n            \n            \n            \n            \n            \n            final double[] q = new double[order];\n            q[0] = 1;\n            final double x2 = x * x;\n            final double f  = 1.0 / (1 - x2);\n            double coeff = f;\n            function[1] = coeff * q[0];\n            for (int n = 2; n <= order; ++n) {\n\n                \n                double v = 0;\n                q[n - 1] = n * q[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + q[k];\n                    if (k > 2) {\n                        q[k - 2] = (k - 1) * q[k - 1] + (2 * n - k + 1) * q[k - 3];\n                    } else if (k == 2) {\n                        q[0] = q[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        \n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    \n    public void compose(final double[] operand, final int operandOffset, final double[] f, final double[] result, final int resultOffset) {\n        for (int i = 0; i < compIndirection.length; ++i) {\n            final int[][] mappingI = compIndirection[i];\n            double r = 0;\n            for (int j = 0; j < mappingI.length; ++j) {\n                final int[] mappingIJ = mappingI[j];\n                double product = mappingIJ[0] * f[mappingIJ[1]];\n                for (int k = 2; k < mappingIJ.length; ++k) {\n                    product *= operand[operandOffset + mappingIJ[k]];\n                }\n                r += product;\n            }\n            result[resultOffset + i] = r;\n        }\n    }\n\n    \n    public double taylor(final double[] ds, final int dsOffset, final double ... delta) {\n        double value = 0;\n        for (int i = getSize() - 1; i >= 0; --i) {\n            final int[] orders = getPartialDerivativeOrders(i);\n            double term = ds[dsOffset + i];\n            for (int k = 0; k < orders.length; ++k) {\n                if (orders[k] > 0) {\n                    term *= FastMath.pow(delta[k], orders[k]) / ArithmeticUtils.factorial(orders[k]);\n                }\n            }\n            value += term;\n        }\n        return value;\n    }\n\n    \n    public void checkCompatibility(final DSCompiler compiler) throws DimensionMismatchException {\n        if (parameters != compiler.parameters) {\n            throw new DimensionMismatchException(parameters, compiler.parameters);\n        }\n        if (order != compiler.order) {\n            throw new DimensionMismatchException(order, compiler.order);\n        }\n    }\n\n}\n",
      "buggy_signatures": [
        "public static DSCompiler getCompiler(int parameters, int order)",
        "private static int[][] compileSizes(final int parameters, final int order, final DSCompiler valueCompiler)",
        "private static int[][] compileDerivativesIndirection(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler)",
        "private static int[] compileLowerIndirection(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler)",
        "private static int[][][] compileMultiplicationIndirection(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler, final int[] lowerIndirection)",
        "private static int[][][] compileCompositionIndirection(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler, final int[][] sizes, final int[][] derivativesIndirection)",
        "public int getPartialDerivativeIndex(final int ... orders) throws DimensionMismatchException, NumberIsTooLargeException",
        "private static int getPartialDerivativeIndex(final int parameters, final int order, final int[][] sizes, final int ... orders) throws NumberIsTooLargeException",
        "private static int convertIndex(final int index, final int srcP, final int[][] srcDerivativesIndirection, final int destP, final int destO, final int[][] destSizes)",
        "public int[] getPartialDerivativeOrders(final int index)",
        "public int getFreeParameters()",
        "public int getOrder()",
        "public int getSize()",
        "public void linearCombination(final double a1, final double[] c1, final int offset1, final double a2, final double[] c2, final int offset2, final double[] result, final int resultOffset)",
        "public void linearCombination(final double a1, final double[] c1, final int offset1, final double a2, final double[] c2, final int offset2, final double a3, final double[] c3, final int offset3, final double[] result, final int resultOffset)",
        "public void linearCombination(final double a1, final double[] c1, final int offset1, final double a2, final double[] c2, final int offset2, final double a3, final double[] c3, final int offset3, final double a4, final double[] c4, final int offset4, final double[] result, final int resultOffset)",
        "public void add(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset)",
        "public void subtract(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset)",
        "public void multiply(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset)",
        "public void divide(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset)",
        "public void remainder(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset)",
        "public void pow(final double[] operand, final int operandOffset, final double p, final double[] result, final int resultOffset)",
        "public void pow(final double[] operand, final int operandOffset, final int n, final double[] result, final int resultOffset)",
        "public void pow(final double[] x, final int xOffset, final double[] y, final int yOffset, final double[] result, final int resultOffset)",
        "public void rootN(final double[] operand, final int operandOffset, final int n, final double[] result, final int resultOffset)",
        "public void exp(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void expm1(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void log(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void log1p(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void log10(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void cos(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void sin(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void tan(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void acos(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void asin(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void atan(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void atan2(final double[] y, final int yOffset, final double[] x, final int xOffset, final double[] result, final int resultOffset)",
        "public void cosh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void sinh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void tanh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void acosh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void asinh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void atanh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void compose(final double[] operand, final int operandOffset, final double[] f, final double[] result, final int resultOffset)",
        "public double taylor(final double[] ds, final int dsOffset, final double ... delta)",
        "public void checkCompatibility(final DSCompiler compiler) throws DimensionMismatchException"
      ],
      "fixed_signatures": [
        "public static DSCompiler getCompiler(int parameters, int order)",
        "private static int[][] compileSizes(final int parameters, final int order, final DSCompiler valueCompiler)",
        "private static int[][] compileDerivativesIndirection(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler)",
        "private static int[] compileLowerIndirection(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler)",
        "private static int[][][] compileMultiplicationIndirection(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler, final int[] lowerIndirection)",
        "private static int[][][] compileCompositionIndirection(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler, final int[][] sizes, final int[][] derivativesIndirection)",
        "public int getPartialDerivativeIndex(final int ... orders) throws DimensionMismatchException, NumberIsTooLargeException",
        "private static int getPartialDerivativeIndex(final int parameters, final int order, final int[][] sizes, final int ... orders) throws NumberIsTooLargeException",
        "private static int convertIndex(final int index, final int srcP, final int[][] srcDerivativesIndirection, final int destP, final int destO, final int[][] destSizes)",
        "public int[] getPartialDerivativeOrders(final int index)",
        "public int getFreeParameters()",
        "public int getOrder()",
        "public int getSize()",
        "public void linearCombination(final double a1, final double[] c1, final int offset1, final double a2, final double[] c2, final int offset2, final double[] result, final int resultOffset)",
        "public void linearCombination(final double a1, final double[] c1, final int offset1, final double a2, final double[] c2, final int offset2, final double a3, final double[] c3, final int offset3, final double[] result, final int resultOffset)",
        "public void linearCombination(final double a1, final double[] c1, final int offset1, final double a2, final double[] c2, final int offset2, final double a3, final double[] c3, final int offset3, final double a4, final double[] c4, final int offset4, final double[] result, final int resultOffset)",
        "public void add(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset)",
        "public void subtract(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset)",
        "public void multiply(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset)",
        "public void divide(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset)",
        "public void remainder(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset)",
        "public void pow(final double[] operand, final int operandOffset, final double p, final double[] result, final int resultOffset)",
        "public void pow(final double[] operand, final int operandOffset, final int n, final double[] result, final int resultOffset)",
        "public void pow(final double[] x, final int xOffset, final double[] y, final int yOffset, final double[] result, final int resultOffset)",
        "public void rootN(final double[] operand, final int operandOffset, final int n, final double[] result, final int resultOffset)",
        "public void exp(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void expm1(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void log(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void log1p(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void log10(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void cos(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void sin(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void tan(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void acos(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void asin(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void atan(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void atan2(final double[] y, final int yOffset, final double[] x, final int xOffset, final double[] result, final int resultOffset)",
        "public void cosh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void sinh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void tanh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void acosh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void asinh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void atanh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)",
        "public void compose(final double[] operand, final int operandOffset, final double[] f, final double[] result, final int resultOffset)",
        "public double taylor(final double[] ds, final int dsOffset, final double ... delta)",
        "public void checkCompatibility(final DSCompiler compiler) throws DimensionMismatchException"
      ],
      "methods": [
        {
          "buggy_method": "  public void atan2(final double[] y, final int yOffset, final double[] x, final int xOffset, final double[] result, final int resultOffset) {\n\n  \n  double[] tmp1 = new double[getSize()];\n  multiply(x, xOffset, x, xOffset, tmp1, 0);  \n  double[] tmp2 = new double[getSize()];\n  multiply(y, yOffset, y, yOffset, tmp2, 0);  \n  add(tmp1, 0, tmp2, 0, tmp2, 0);  \n  rootN(tmp2, 0, 2, tmp1, 0);  \n\n  if (x[xOffset] >= 0) {\n\n  \n  add(tmp1, 0, x, xOffset, tmp2, 0);  \n  divide(y, yOffset, tmp2, 0, tmp1, 0);  \n  atan(tmp1, 0, tmp2, 0);  \n  for (int i = 0; i < tmp2.length; ++i) {\n  result[resultOffset + i] = 2 * tmp2[i]; \n  }\n\n  } else {\n\n  \n  subtract(tmp1, 0, x, xOffset, tmp2, 0);  \n  divide(y, yOffset, tmp2, 0, tmp1, 0);  \n  atan(tmp1, 0, tmp2, 0);  \n  result[resultOffset] =\n  ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; \n  for (int i = 1; i < tmp2.length; ++i) {\n  result[resultOffset + i] = -2 * tmp2[i]; \n  }\n\n  }\n\n  \n\n  }",
          "fixed_method": "  public void atan2(final double[] y, final int yOffset, final double[] x, final int xOffset, final double[] result, final int resultOffset) {\n\n  \n  double[] tmp1 = new double[getSize()];\n  multiply(x, xOffset, x, xOffset, tmp1, 0);  \n  double[] tmp2 = new double[getSize()];\n  multiply(y, yOffset, y, yOffset, tmp2, 0);  \n  add(tmp1, 0, tmp2, 0, tmp2, 0);  \n  rootN(tmp2, 0, 2, tmp1, 0);  \n\n  if (x[xOffset] >= 0) {\n\n  \n  add(tmp1, 0, x, xOffset, tmp2, 0);  \n  divide(y, yOffset, tmp2, 0, tmp1, 0);  \n  atan(tmp1, 0, tmp2, 0);  \n  for (int i = 0; i < tmp2.length; ++i) {\n  result[resultOffset + i] = 2 * tmp2[i]; \n  }\n\n  } else {\n\n  \n  subtract(tmp1, 0, x, xOffset, tmp2, 0);  \n  divide(y, yOffset, tmp2, 0, tmp1, 0);  \n  atan(tmp1, 0, tmp2, 0);  \n  result[resultOffset] =\n  ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; \n  for (int i = 1; i < tmp2.length; ++i) {\n  result[resultOffset + i] = -2 * tmp2[i]; \n  }\n\n  }\n\n  \n  result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);\n\n  }",
          "diff": [
            "@@ -1416,6 +1416,7 @@",
            "         }\n",
            " \n",
            "         // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly\n",
            "+        result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);\n",
            " \n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 1
        }
      ]
    }
  ]
}
