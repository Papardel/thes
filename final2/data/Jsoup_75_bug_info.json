{
  "bug_id": "75",
  "failed_tests": {
    "org.jsoup.nodes.ElementTest": [
      {
        "methodName": "booleanAttributeOutput",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<...mg src=\"foo\" noshade[] nohref async autofo...> but was:<...mg src=\"foo\" noshade[=\"\"] nohref async autofo...>",
        "fail_line": "        assertEquals(\"<img src=\\\"foo\\\" noshade nohref async autofocus=\\\"false\\\">\", img.outerHtml());",
        "test_source": "  public void booleanAttributeOutput() {\n  Document doc = Jsoup.parse(\"<img src=foo noshade='' nohref async=async autofocus=false>\");\n  Element img = doc.selectFirst(\"img\");\n\n  assertEquals(\"<img src=\\\"foo\\\" noshade nohref async autofocus=\\\"false\\\">\", img.outerHtml());\n  }",
        "stack": [
          "ElementTest.booleanAttributeOutput line 1318"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/nodes/Attributes.java",
      "buggy_full_code": "package org.jsoup.nodes;\n\nimport org.jsoup.SerializationException;\nimport org.jsoup.helper.Validate;\n\nimport java.io.IOException;\nimport java.util.AbstractMap;\nimport java.util.AbstractSet;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.jsoup.internal.Normalizer.lowerCase; public class Attributes implements Iterable<Attribute>, Cloneable { protected static final String dataPrefix = \"data-\"; private static final int InitialCapacity = 4; private static final int GrowthFactor = 2; private static final String[] Empty = {}; static final int NotFound = -1; private static final String EmptyString = \"\"; private int size = 0; String[] keys = Empty; String[] vals = Empty; private void checkCapacity(int minNewSize) {\n        Validate.isTrue(minNewSize >= size);\n        int curSize = keys.length;\n        if (curSize >= minNewSize)\n            return;\n\n        int newSize = curSize >= InitialCapacity ? size * GrowthFactor : InitialCapacity;\n        if (minNewSize > newSize)\n            newSize = minNewSize;\n\n        keys = copyOf(keys, newSize);\n        vals = copyOf(vals, newSize);\n    }\n\n    \n    private static String[] copyOf(String[] orig, int size) {\n        final String[] copy = new String[size];\n        System.arraycopy(orig, 0, copy, 0,\n                Math.min(orig.length, size));\n        return copy;\n    }\n\n    int indexOfKey(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equals(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }\n\n    private int indexOfKeyIgnoreCase(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equalsIgnoreCase(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }\n\n    \n    static String checkNotNull(String val) {\n        return val == null ? EmptyString : val;\n    }\n\n    \n    public String get(String key) {\n        int i = indexOfKey(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }\n\n    \n    public String getIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }\n\n    \n    private void add(String key, String value) {\n        checkCapacity(size + 1);\n        keys[size] = key;\n        vals[size] = value;\n        size++;\n    }\n\n    \n    public Attributes put(String key, String value) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            vals[i] = value;\n        else\n            add(key, value);\n        return this;\n    }\n\n    void putIgnoreCase(String key, String value) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound) {\n            vals[i] = value;\n            if (!keys[i].equals(key)) \n                keys[i] = key;\n        }\n        else\n            add(key, value);\n    }\n\n    \n    public Attributes put(String key, boolean value) {\n        if (value)\n            putIgnoreCase(key, null);\n        else\n            remove(key);\n        return this;\n    }\n\n    \n    public Attributes put(Attribute attribute) {\n        Validate.notNull(attribute);\n        put(attribute.getKey(), attribute.getValue());\n        attribute.parent = this;\n        return this;\n    }\n\n    \n    private void remove(int index) {\n        Validate.isFalse(index >= size);\n        int shifted = size - index - 1;\n        if (shifted > 0) {\n            System.arraycopy(keys, index + 1, keys, index, shifted);\n            System.arraycopy(vals, index + 1, vals, index, shifted);\n        }\n        size--;\n        keys[size] = null; \n        vals[size] = null;\n    }\n\n    \n    public void remove(String key) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            remove(i);\n    }\n\n    \n    public void removeIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound)\n            remove(i);\n    }\n\n    \n    public boolean hasKey(String key) {\n        return indexOfKey(key) != NotFound;\n    }\n\n    \n    public boolean hasKeyIgnoreCase(String key) {\n        return indexOfKeyIgnoreCase(key) != NotFound;\n    }\n\n    \n    public int size() {\n        return size;\n    }\n\n    \n    public void addAll(Attributes incoming) {\n        if (incoming.size() == 0)\n            return;\n        checkCapacity(size + incoming.size);\n\n        for (Attribute attr : incoming) {\n            \n            put(attr);\n        }\n\n    }\n\n    public Iterator<Attribute> iterator() {\n        return new Iterator<Attribute>() {\n            int i = 0;\n\n            @Override\n            public boolean hasNext() {\n                return i < size;\n            }\n\n            @Override\n            public Attribute next() {\n                final Attribute attr = new Attribute(keys[i], vals[i], Attributes.this);\n                i++;\n                return attr;\n            }\n\n            @Override\n            public void remove() {\n                Attributes.this.remove(--i); \n            }\n        };\n    }\n\n    \n    public List<Attribute> asList() {\n        ArrayList<Attribute> list = new ArrayList<>(size);\n        for (int i = 0; i < size; i++) {\n            Attribute attr = vals[i] == null ?\n                new BooleanAttribute(keys[i]) : \n                new Attribute(keys[i], vals[i], Attributes.this);\n            list.add(attr);\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    \n    public Map<String, String> dataset() {\n        return new Dataset(this);\n    }\n\n    \n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        try {\n            html(accum, (new Document(\"\")).outputSettings()); \n        } catch (IOException e) { \n            throw new SerializationException(e);\n        }\n        return accum.toString();\n    }\n\n    final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n        final int sz = size;\n        for (int i = 0; i < sz; i++) {\n            \n            final String key = keys[i];\n            final String val = vals[i];\n            accum.append(' ').append(key);\n\n            \n            if (!(out.syntax() == Document.OutputSettings.Syntax.html\n                && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {\n                accum.append(\"=\\\"\");\n                Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\n                accum.append('\"');\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return html();\n    }\n\n    \n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Attributes that = (Attributes) o;\n\n        if (size != that.size) return false;\n        if (!Arrays.equals(keys, that.keys)) return false;\n        return Arrays.equals(vals, that.vals);\n    }\n\n    \n    @Override\n    public int hashCode() {\n        int result = size;\n        result = 31 * result + Arrays.hashCode(keys);\n        result = 31 * result + Arrays.hashCode(vals);\n        return result;\n    }\n\n    @Override\n    public Attributes clone() {\n        Attributes clone;\n        try {\n            clone = (Attributes) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n        clone.size = size;\n        keys = copyOf(keys, size);\n        vals = copyOf(vals, size);\n        return clone;\n    }\n\n    \n    public void normalize() {\n        for (int i = 0; i < size; i++) {\n            keys[i] = lowerCase(keys[i]);\n        }\n    }\n\n    private static class Dataset extends AbstractMap<String, String> { private final Attributes attributes; private Dataset(Attributes attributes) {\n            this.attributes = attributes;\n        }\n\n        @Override\n        public Set<Entry<String, String>> entrySet() {\n            return new EntrySet();\n        }\n\n        @Override\n        public String put(String key, String value) {\n            String dataKey = dataKey(key);\n            String oldValue = attributes.hasKey(dataKey) ? attributes.get(dataKey) : null;\n            attributes.put(dataKey, value);\n            return oldValue;\n        }\n\n        private class EntrySet extends AbstractSet<Map.Entry<String, String>> { @Override public Iterator<Map.Entry<String, String>> iterator() {\n                return new DatasetIterator();\n            }\n\n            @Override\n            public int size() {\n                int count = 0;\n                Iterator iter = new DatasetIterator();\n                while (iter.hasNext())\n                    count++;\n                return count;\n            }\n        }\n\n        private class DatasetIterator implements Iterator<Map.Entry<String, String>> { private Iterator<Attribute> attrIter = attributes.iterator(); private Attribute attr; public boolean hasNext() {\n                while (attrIter.hasNext()) {\n                    attr = attrIter.next();\n                    if (attr.isDataAttribute()) return true;\n                }\n                return false;\n            }\n\n            public Entry<String, String> next() {\n                return new Attribute(attr.getKey().substring(dataPrefix.length()), attr.getValue());\n            }\n\n            public void remove() {\n                attributes.remove(attr.getKey());\n            }\n        }\n    }\n\n    private static String dataKey(String key) {\n        return dataPrefix + key;\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.nodes;\n\nimport org.jsoup.SerializationException;\nimport org.jsoup.helper.Validate;\n\nimport java.io.IOException;\nimport java.util.AbstractMap;\nimport java.util.AbstractSet;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.jsoup.internal.Normalizer.lowerCase; public class Attributes implements Iterable<Attribute>, Cloneable { protected static final String dataPrefix = \"data-\"; private static final int InitialCapacity = 4; private static final int GrowthFactor = 2; private static final String[] Empty = {}; static final int NotFound = -1; private static final String EmptyString = \"\"; private int size = 0; String[] keys = Empty; String[] vals = Empty; private void checkCapacity(int minNewSize) {\n        Validate.isTrue(minNewSize >= size);\n        int curSize = keys.length;\n        if (curSize >= minNewSize)\n            return;\n\n        int newSize = curSize >= InitialCapacity ? size * GrowthFactor : InitialCapacity;\n        if (minNewSize > newSize)\n            newSize = minNewSize;\n\n        keys = copyOf(keys, newSize);\n        vals = copyOf(vals, newSize);\n    }\n\n    \n    private static String[] copyOf(String[] orig, int size) {\n        final String[] copy = new String[size];\n        System.arraycopy(orig, 0, copy, 0,\n                Math.min(orig.length, size));\n        return copy;\n    }\n\n    int indexOfKey(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equals(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }\n\n    private int indexOfKeyIgnoreCase(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equalsIgnoreCase(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }\n\n    \n    static String checkNotNull(String val) {\n        return val == null ? EmptyString : val;\n    }\n\n    \n    public String get(String key) {\n        int i = indexOfKey(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }\n\n    \n    public String getIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }\n\n    \n    private void add(String key, String value) {\n        checkCapacity(size + 1);\n        keys[size] = key;\n        vals[size] = value;\n        size++;\n    }\n\n    \n    public Attributes put(String key, String value) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            vals[i] = value;\n        else\n            add(key, value);\n        return this;\n    }\n\n    void putIgnoreCase(String key, String value) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound) {\n            vals[i] = value;\n            if (!keys[i].equals(key)) \n                keys[i] = key;\n        }\n        else\n            add(key, value);\n    }\n\n    \n    public Attributes put(String key, boolean value) {\n        if (value)\n            putIgnoreCase(key, null);\n        else\n            remove(key);\n        return this;\n    }\n\n    \n    public Attributes put(Attribute attribute) {\n        Validate.notNull(attribute);\n        put(attribute.getKey(), attribute.getValue());\n        attribute.parent = this;\n        return this;\n    }\n\n    \n    private void remove(int index) {\n        Validate.isFalse(index >= size);\n        int shifted = size - index - 1;\n        if (shifted > 0) {\n            System.arraycopy(keys, index + 1, keys, index, shifted);\n            System.arraycopy(vals, index + 1, vals, index, shifted);\n        }\n        size--;\n        keys[size] = null; \n        vals[size] = null;\n    }\n\n    \n    public void remove(String key) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            remove(i);\n    }\n\n    \n    public void removeIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound)\n            remove(i);\n    }\n\n    \n    public boolean hasKey(String key) {\n        return indexOfKey(key) != NotFound;\n    }\n\n    \n    public boolean hasKeyIgnoreCase(String key) {\n        return indexOfKeyIgnoreCase(key) != NotFound;\n    }\n\n    \n    public int size() {\n        return size;\n    }\n\n    \n    public void addAll(Attributes incoming) {\n        if (incoming.size() == 0)\n            return;\n        checkCapacity(size + incoming.size);\n\n        for (Attribute attr : incoming) {\n            \n            put(attr);\n        }\n\n    }\n\n    public Iterator<Attribute> iterator() {\n        return new Iterator<Attribute>() {\n            int i = 0;\n\n            @Override\n            public boolean hasNext() {\n                return i < size;\n            }\n\n            @Override\n            public Attribute next() {\n                final Attribute attr = new Attribute(keys[i], vals[i], Attributes.this);\n                i++;\n                return attr;\n            }\n\n            @Override\n            public void remove() {\n                Attributes.this.remove(--i); \n            }\n        };\n    }\n\n    \n    public List<Attribute> asList() {\n        ArrayList<Attribute> list = new ArrayList<>(size);\n        for (int i = 0; i < size; i++) {\n            Attribute attr = vals[i] == null ?\n                new BooleanAttribute(keys[i]) : \n                new Attribute(keys[i], vals[i], Attributes.this);\n            list.add(attr);\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    \n    public Map<String, String> dataset() {\n        return new Dataset(this);\n    }\n\n    \n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        try {\n            html(accum, (new Document(\"\")).outputSettings()); \n        } catch (IOException e) { \n            throw new SerializationException(e);\n        }\n        return accum.toString();\n    }\n\n    final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n        final int sz = size;\n        for (int i = 0; i < sz; i++) {\n            \n            final String key = keys[i];\n            final String val = vals[i];\n            accum.append(' ').append(key);\n\n            \n            if (!Attribute.shouldCollapseAttribute(key, val, out)) {\n                accum.append(\"=\\\"\");\n                Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\n                accum.append('\"');\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return html();\n    }\n\n    \n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Attributes that = (Attributes) o;\n\n        if (size != that.size) return false;\n        if (!Arrays.equals(keys, that.keys)) return false;\n        return Arrays.equals(vals, that.vals);\n    }\n\n    \n    @Override\n    public int hashCode() {\n        int result = size;\n        result = 31 * result + Arrays.hashCode(keys);\n        result = 31 * result + Arrays.hashCode(vals);\n        return result;\n    }\n\n    @Override\n    public Attributes clone() {\n        Attributes clone;\n        try {\n            clone = (Attributes) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n        clone.size = size;\n        keys = copyOf(keys, size);\n        vals = copyOf(vals, size);\n        return clone;\n    }\n\n    \n    public void normalize() {\n        for (int i = 0; i < size; i++) {\n            keys[i] = lowerCase(keys[i]);\n        }\n    }\n\n    private static class Dataset extends AbstractMap<String, String> { private final Attributes attributes; private Dataset(Attributes attributes) {\n            this.attributes = attributes;\n        }\n\n        @Override\n        public Set<Entry<String, String>> entrySet() {\n            return new EntrySet();\n        }\n\n        @Override\n        public String put(String key, String value) {\n            String dataKey = dataKey(key);\n            String oldValue = attributes.hasKey(dataKey) ? attributes.get(dataKey) : null;\n            attributes.put(dataKey, value);\n            return oldValue;\n        }\n\n        private class EntrySet extends AbstractSet<Map.Entry<String, String>> { @Override public Iterator<Map.Entry<String, String>> iterator() {\n                return new DatasetIterator();\n            }\n\n            @Override\n            public int size() {\n                int count = 0;\n                Iterator iter = new DatasetIterator();\n                while (iter.hasNext())\n                    count++;\n                return count;\n            }\n        }\n\n        private class DatasetIterator implements Iterator<Map.Entry<String, String>> { private Iterator<Attribute> attrIter = attributes.iterator(); private Attribute attr; public boolean hasNext() {\n                while (attrIter.hasNext()) {\n                    attr = attrIter.next();\n                    if (attr.isDataAttribute()) return true;\n                }\n                return false;\n            }\n\n            public Entry<String, String> next() {\n                return new Attribute(attr.getKey().substring(dataPrefix.length()), attr.getValue());\n            }\n\n            public void remove() {\n                attributes.remove(attr.getKey());\n            }\n        }\n    }\n\n    private static String dataKey(String key) {\n        return dataPrefix + key;\n    }\n}\n",
      "buggy_signatures": [
        "private static String[] copyOf(String[] orig, int size)",
        "private int indexOfKeyIgnoreCase(String key)",
        "static String checkNotNull(String val)",
        "public String get(String key)",
        "public String getIgnoreCase(String key)",
        "private void add(String key, String value)",
        "public Attributes put(String key, String value)",
        "public Attributes put(String key, boolean value)",
        "public Attributes put(Attribute attribute)",
        "private void remove(int index)",
        "public void remove(String key)",
        "public void removeIgnoreCase(String key)",
        "public boolean hasKey(String key)",
        "public boolean hasKeyIgnoreCase(String key)",
        "public int size()",
        "public void addAll(Attributes incoming)",
        "public Iterator<Attribute> iterator()",
        "public boolean hasNext()",
        "public Attribute next()",
        "public void remove()",
        "public List<Attribute> asList()",
        "public Map<String, String> dataset()",
        "public String html()",
        "public String toString()",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "public Attributes clone()",
        "public void normalize()",
        "private static class Dataset extends AbstractMap<String, String> { private final Attributes attributes; private Dataset(Attributes attributes)",
        "public Set<Entry<String, String>> entrySet()",
        "public String put(String key, String value)",
        "private class EntrySet extends AbstractSet<Map.Entry<String, String>> { @Override public Iterator<Map.Entry<String, String>> iterator()",
        "public int size()",
        "public Entry<String, String> next()",
        "public void remove()",
        "private static String dataKey(String key)"
      ],
      "fixed_signatures": [
        "private static String[] copyOf(String[] orig, int size)",
        "private int indexOfKeyIgnoreCase(String key)",
        "static String checkNotNull(String val)",
        "public String get(String key)",
        "public String getIgnoreCase(String key)",
        "private void add(String key, String value)",
        "public Attributes put(String key, String value)",
        "public Attributes put(String key, boolean value)",
        "public Attributes put(Attribute attribute)",
        "private void remove(int index)",
        "public void remove(String key)",
        "public void removeIgnoreCase(String key)",
        "public boolean hasKey(String key)",
        "public boolean hasKeyIgnoreCase(String key)",
        "public int size()",
        "public void addAll(Attributes incoming)",
        "public Iterator<Attribute> iterator()",
        "public boolean hasNext()",
        "public Attribute next()",
        "public void remove()",
        "public List<Attribute> asList()",
        "public Map<String, String> dataset()",
        "public String html()",
        "public String toString()",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "public Attributes clone()",
        "public void normalize()",
        "private static class Dataset extends AbstractMap<String, String> { private final Attributes attributes; private Dataset(Attributes attributes)",
        "public Set<Entry<String, String>> entrySet()",
        "public String put(String key, String value)",
        "private class EntrySet extends AbstractSet<Map.Entry<String, String>> { @Override public Iterator<Map.Entry<String, String>> iterator()",
        "public int size()",
        "public Entry<String, String> next()",
        "public void remove()",
        "private static String dataKey(String key)"
      ],
      "methods": [
        {
          "buggy_method": "  public String html() {\n  StringBuilder accum = new StringBuilder();\n  try {\n  html(accum, (new Document(\"\")).outputSettings()); \n  } catch (IOException e) { \n  throw new SerializationException(e);\n  }\n  return accum.toString();\n  }",
          "fixed_method": "  public String html() {\n  StringBuilder accum = new StringBuilder();\n  try {\n  html(accum, (new Document(\"\")).outputSettings()); \n  } catch (IOException e) { \n  throw new SerializationException(e);\n  }\n  return accum.toString();\n  }",
          "diff": [
            "@@ -316,8 +316,7 @@",
            "             accum.append(' ').append(key);\n",
            " \n",
            "             // collapse checked=null, checked=\"\", checked=checked; write out others\n",
            "-            if (!(out.syntax() == Document.OutputSettings.Syntax.html\n",
            "-                && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {\n",
            "+            if (!Attribute.shouldCollapseAttribute(key, val, out)) {\n",
            "                 accum.append(\"=\\\"\");\n",
            "                 Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\n",
            "                 accum.append('\"');\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
