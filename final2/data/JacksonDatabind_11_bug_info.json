{
  "bug_id": "11",
  "failed_tests": {
    "com.fasterxml.jackson.databind.type.TestJavaType": [
      {
        "methodName": "testLocalType728",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<interface java.lang.CharSequence> but was:<class java.lang.Object>",
        "fail_line": "        assertEquals(CharSequence.class, t.getRawClass());",
        "test_source": "  public void testLocalType728() throws Exception {\n  TypeFactory tf = TypeFactory.defaultInstance();\n  Method m = Issue728.class.getMethod(\"method\", CharSequence.class);\n  assertNotNull(m);\n\n  // Start with return type\n  // first type-erased\n  JavaType t = tf.constructType(m.getReturnType());\n  assertEquals(CharSequence.class, t.getRawClass());\n  // then generic\n  t = tf.constructType(m.getGenericReturnType());\n  assertEquals(CharSequence.class, t.getRawClass());\n\n  // then parameter type\n  t = tf.constructType(m.getParameterTypes()[0]);\n  assertEquals(CharSequence.class, t.getRawClass());\n  t = tf.constructType(m.getGenericParameterTypes()[0]);\n  assertEquals(CharSequence.class, t.getRawClass());\n  }",
        "stack": [
          "TestJavaType.testLocalType728 line 43"
        ]
      }
    ],
    "com.fasterxml.jackson.databind.type.TestLocalType609": [
      {
        "methodName": "testLocalPartialType609",
        "error": "com.fasterxml.jackson.databind.JsonMappingException",
        "message": "Type variable 'T' can not be resolved (with context of class com.fasterxml.jackson.databind.type.TestLocalType609$EntityContainer)",
        "fail_line": "        EntityContainer output = mapper.readValue(json, EntityContainer.class);",
        "test_source": "  public void testLocalPartialType609() throws Exception {\n  ObjectMapper mapper = new ObjectMapper();\n  \n  EntityContainer input = new EntityContainer(); \n  input.entity = new RuleForm(12);\n  String json = mapper.writeValueAsString(input);\n  \n  EntityContainer output = mapper.readValue(json, EntityContainer.class);\n  assertEquals(12, output.getEntity().value);\n  }",
        "stack": [
          "DeserializerCache._createAndCache2 line 267, DeserializerCache._createAndCacheValueDeserializer line 242, DeserializerCache.findValueDeserializer line 143, DeserializationContext.findRootValueDeserializer line 439, ObjectMapper._findRootDeserializer line 3666, ObjectMapper._readMapAndClose line 3558, ObjectMapper.readValue line 2578, TestLocalType609.testLocalPartialType609 line 32, TypeBindings.findType line 179, TypeBindings.findType line 120, TypeFactory._fromVariable line 902, TypeFactory._constructType line 399, TypeBindings.resolveType line 102, BasicBeanDescription.resolveType line 221, BeanDeserializerFactory.constructSettableProperty line 707, BeanDeserializerFactory.addBeanProps line 498, BeanDeserializerFactory.buildBeanDeserializer line 220, BeanDeserializerFactory.createBeanDeserializer line 143, DeserializerCache._createDeserializer2 line 405, DeserializerCache._createDeserializer line 354, DeserializerCache._createAndCache2 line 262"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/type/TypeFactory.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.type;\n\nimport java.util.*;\nimport java.lang.reflect.*;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.LRUMap;\n\n\n@SuppressWarnings({\"rawtypes\", \"unchecked\"})\npublic final class TypeFactory implements java.io.Serializable { private static final long serialVersionUID = 1L; private final static JavaType[] NO_TYPES = new JavaType[0]; protected final static TypeFactory instance = new TypeFactory(); protected final static SimpleType CORE_TYPE_STRING = new SimpleType(String.class); protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(Boolean.TYPE); protected final static SimpleType CORE_TYPE_INT = new SimpleType(Integer.TYPE); protected final static SimpleType CORE_TYPE_LONG = new SimpleType(Long.TYPE); protected final LRUMap<ClassKey, JavaType> _typeCache = new LRUMap<ClassKey, JavaType>(16, 100); protected transient HierarchicType _cachedHashMapType; protected transient HierarchicType _cachedArrayListType; protected final TypeModifier[] _modifiers; protected final TypeParser _parser; private TypeFactory() {\n        _parser = new TypeParser(this);\n        _modifiers = null;\n    }\n\n    protected TypeFactory(TypeParser p, TypeModifier[] mods) {\n        _parser = p;\n        _modifiers = mods;\n    }\n\n    public TypeFactory withModifier(TypeModifier mod) {\n        if (mod == null) { \n            return new TypeFactory(_parser, _modifiers);\n        }\n        if (_modifiers == null) {\n            return new TypeFactory(_parser, new TypeModifier[] { mod });\n        }\n        return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod));\n    }\n\n    \n    public static TypeFactory defaultInstance() { return instance; }\n\n    \n    public void clearCache() {\n        _typeCache.clear();\n    }\n    \n    \n    \n    \n    public static JavaType unknownType() {\n        return defaultInstance()._unknownType();\n    }\n\n    \n    public static Class<?> rawClass(Type t) {\n        if (t instanceof Class<?>) {\n            return (Class<?>) t;\n        }\n        \n        return defaultInstance().constructType(t).getRawClass();\n    }\n    \n    \n\n    \n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n        \n        if (baseType.getRawClass() == subclass) {\n            return baseType;\n        }\n        \n        if (baseType instanceof SimpleType) {\n            \n            if (subclass.isArray()\n                || Map.class.isAssignableFrom(subclass)\n                || Collection.class.isAssignableFrom(subclass)) {\n                \n                if (!baseType.getRawClass().isAssignableFrom(subclass)) {\n                    throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType);\n                }\n                \n                JavaType subtype = _fromClass(subclass, new TypeBindings(this, baseType.getRawClass()));\n                \n                Object h = baseType.getValueHandler();\n                if (h != null) {\n                    subtype = subtype.withValueHandler(h);\n                }\n                h = baseType.getTypeHandler();\n                if (h != null) {\n                    subtype = subtype.withTypeHandler(h);\n                }\n                return subtype;\n            }\n        }\n        \n        return baseType.narrowBy(subclass);\n    }\n\n    \n    public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException {\n        return _parser.parse(canonical);\n    }\n    \n    \n    public JavaType[] findTypeParameters(JavaType type, Class<?> expType) {\n        \n        if (expType == type.getParameterSource()) {\n            \n            int count = type.containedTypeCount();\n            if (count == 0) return null;\n            JavaType[] result = new JavaType[count];\n            for (int i = 0; i < count; ++i) {\n                result[i] = type.containedType(i);\n            }\n            return result;\n        }\n        \n        Class<?> raw = type.getRawClass();\n        return findTypeParameters(raw, expType, new TypeBindings(this, type));\n    }\n\n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) {\n        return findTypeParameters(clz, expType, new TypeBindings(this, clz));\n    }\n\n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) {\n        \n        HierarchicType subType = _findSuperTypeChain(clz, expType);\n        \n        if (subType == null) {\n            throw new IllegalArgumentException(\"Class \"+clz.getName()+\" is not a subtype of \"+expType.getName());\n        }\n        \n        HierarchicType superType = subType;\n        while (superType.getSuperType() != null) {\n            superType = superType.getSuperType();\n            Class<?> raw = superType.getRawClass();\n            TypeBindings newBindings = new TypeBindings(this, raw);\n            if (superType.isGeneric()) { \n                ParameterizedType pt = superType.asGeneric();\n                Type[] actualTypes = pt.getActualTypeArguments();\n                TypeVariable<?>[] vars = raw.getTypeParameters();\n                int len = actualTypes.length;\n                for (int i = 0; i < len; ++i) {\n                    String name = vars[i].getName();\n                    JavaType type = _constructType(actualTypes[i], bindings);\n                    newBindings.addBinding(name, type);\n                }\n            }\n            bindings = newBindings;\n        }\n\n        \n        if (!superType.isGeneric()) {\n            return null;\n        }\n        return bindings.typesAsArray();\n    }\n\n    \n    public JavaType moreSpecificType(JavaType type1, JavaType type2) {\n        if (type1 == null) {\n            return type2;\n        }\n        if (type2 == null) {\n            return type1;\n        }\n        Class<?> raw1 = type1.getRawClass();\n        Class<?> raw2 = type2.getRawClass();\n        if (raw1 == raw2) {\n            return type1;\n        }\n        \n        if (raw1.isAssignableFrom(raw2)) {\n            return type2;\n        }\n        return type1;\n    }\n    \n    \n\n    public JavaType constructType(Type type) {\n        return _constructType(type, null);\n    }\n\n    public JavaType constructType(Type type, TypeBindings bindings) {\n        return _constructType(type, bindings);\n    }\n    \n    public JavaType constructType(TypeReference<?> typeRef) {\n        return _constructType(typeRef.getType(), null);\n    }\n    \n    public JavaType constructType(Type type, Class<?> context) {\n        TypeBindings b = (context == null) ? null : new TypeBindings(this, context);\n        return _constructType(type, b);\n    }\n\n    public JavaType constructType(Type type, JavaType context) {\n        TypeBindings b = (context == null) ? null : new TypeBindings(this, context);\n        return _constructType(type, b);\n    }\n    \n    \n    protected JavaType _constructType(Type type, TypeBindings context) {\n        JavaType resultType;\n\n        \n        if (type instanceof Class<?>) {\n            resultType = _fromClass((Class<?>) type, context);\n        }\n        \n        else if (type instanceof ParameterizedType) {\n            resultType = _fromParamType((ParameterizedType) type, context);\n        }\n        else if (type instanceof JavaType) { \n            return (JavaType) type;\n        }\n        else if (type instanceof GenericArrayType) {\n            resultType = _fromArrayType((GenericArrayType) type, context);\n        }\n        else if (type instanceof TypeVariable<?>) {\n            resultType = _fromVariable((TypeVariable<?>) type, context);\n        }\n        else if (type instanceof WildcardType) {\n            resultType = _fromWildcard((WildcardType) type, context);\n        } else {\n            \n            throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString()));\n        }\n        \n        if (_modifiers != null && !resultType.isContainerType()) {\n            for (TypeModifier mod : _modifiers) {\n                resultType = mod.modifyType(resultType, type, context, this);\n            }\n        }\n        return resultType;\n    }\n\n    \n\n    \n    public ArrayType constructArrayType(Class<?> elementType) {\n        return ArrayType.construct(_constructType(elementType, null), null, null);\n    }\n    \n    \n    public ArrayType constructArrayType(JavaType elementType) {\n        return ArrayType.construct(elementType, null, null);\n    }\n\n    \n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) {\n        return CollectionType.construct(collectionClass, constructType(elementClass));\n    }\n    \n    \n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) {\n        return CollectionType.construct(collectionClass, elementType);\n    }\n\n    \n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) {\n        return CollectionLikeType.construct(collectionClass, constructType(elementClass));\n    }\n    \n    \n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) {\n        return CollectionLikeType.construct(collectionClass, elementType);\n    }\n    \n    \n    public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) {\n        return MapType.construct(mapClass, keyType, valueType);\n    }\n\n    \n    public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass));\n    }\n\n    \n    public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) {\n        return MapLikeType.construct(mapClass, keyType, valueType);\n    }\n    \n    \n    public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass));\n    }\n    \n    \n    @Deprecated\n    public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) {\n        return constructSimpleType(rawType, rawType, parameterTypes);\n    }\n    \n    public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes) {\n        \n        TypeVariable<?>[] typeVars = parameterTarget.getTypeParameters();\n        if (typeVars.length != parameterTypes.length) {\n            throw new IllegalArgumentException(\"Parameter type mismatch for \"+rawType.getName()\n                    +\" (and target \"+parameterTarget.getName()+\"): expected \"+typeVars.length\n                    +\" parameters, was given \"+parameterTypes.length);\n        }\n        String[] names = new String[typeVars.length];\n        for (int i = 0, len = typeVars.length; i < len; ++i) {\n            names[i] = typeVars[i].getName();\n        }\n        return new SimpleType(rawType, names, parameterTypes, null, null, false, parameterTarget);\n    } \n\n    \n    public JavaType uncheckedSimpleType(Class<?> cls) {\n        return new SimpleType(cls);\n    }\n    \n    \n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses) {\n        int len = parameterClasses.length;\n        JavaType[] pt = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            pt[i] = _fromClass(parameterClasses[i], null);\n        }\n        return constructParametrizedType(parametrized, parametersFor, pt);\n    }\n\n    \n    @Deprecated\n    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n        return constructParametrizedType(parametrized, parametrized, parameterClasses);\n    }\n\n    \n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes) {\n        JavaType resultType;\n        \n        \n        if (parametrized.isArray()) {\n            \n            if (parameterTypes.length != 1) {\n                throw new IllegalArgumentException(\"Need exactly 1 parameter type for arrays (\"+parametrized.getName()+\")\");\n            }\n            resultType = constructArrayType(parameterTypes[0]);\n        }\n        else if (Map.class.isAssignableFrom(parametrized)) {\n            if (parameterTypes.length != 2) {\n                throw new IllegalArgumentException(\"Need exactly 2 parameter types for Map types (\"+parametrized.getName()+\")\");\n            }\n            resultType = constructMapType((Class<Map<?,?>>)parametrized, parameterTypes[0], parameterTypes[1]);\n        }\n        else if (Collection.class.isAssignableFrom(parametrized)) {\n            if (parameterTypes.length != 1) {\n                throw new IllegalArgumentException(\"Need exactly 1 parameter type for Collection types (\"+parametrized.getName()+\")\");\n            }\n            resultType = constructCollectionType((Class<Collection<?>>)parametrized, parameterTypes[0]);\n        } else {\n            resultType = constructSimpleType(parametrized, parametersFor, parameterTypes);\n        }\n        return resultType;\n    }\n\n    \n    @Deprecated\n    public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes) {\n        return constructParametrizedType(parametrized, parametrized, parameterTypes);\n    }\n    \n    \n\n    \n    public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {\n        return CollectionType.construct(collectionClass, unknownType());\n    }\n\n    \n    public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {\n        return CollectionLikeType.construct(collectionClass, unknownType());\n    }\n\n    \n    public MapType constructRawMapType(Class<? extends Map> mapClass) {\n        return MapType.construct(mapClass, unknownType(), unknownType());\n    }\n\n    \n    public MapLikeType constructRawMapLikeType(Class<?> mapClass) {\n        return MapLikeType.construct(mapClass, unknownType(), unknownType());\n    }\n\n    \n\n    \n    protected JavaType _fromClass(Class<?> clz, TypeBindings context) {\n        \n        if (clz == String.class) return CORE_TYPE_STRING;\n        if (clz == Boolean.TYPE) return CORE_TYPE_BOOL;\n        if (clz == Integer.TYPE) return CORE_TYPE_INT;\n        if (clz == Long.TYPE) return CORE_TYPE_LONG;\n        \n        \n        ClassKey key = new ClassKey(clz);\n        JavaType result = _typeCache.get(key); \n        if (result != null) {\n            return result;\n        }\n\n        \n        \n\n        \n        if (clz.isArray()) {\n            result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null);\n            \n        } else if (clz.isEnum()) {\n            result = new SimpleType(clz);\n            \n        } else if (Map.class.isAssignableFrom(clz)) {\n            result = _mapType(clz);\n        } else if (Collection.class.isAssignableFrom(clz)) {\n            result =  _collectionType(clz);\n        } else {\n            \n            if (Map.Entry.class.isAssignableFrom(clz)) {\n                JavaType[] pts = this.findTypeParameters(clz, Map.Entry.class);\n                JavaType kt, vt;\n                if (pts == null || pts.length != 2) {\n                    kt = vt = unknownType();\n                } else {\n                    kt = pts[0];\n                    vt = pts[1];\n                }\n                result = constructSimpleType(clz, Map.Entry.class, new JavaType[] { kt, vt });\n            } else {\n                result = new SimpleType(clz);\n            }\n        }\n        _typeCache.put(key, result); \n        return result;\n    }\n    \n    \n    protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes) {\n        if (clz.isArray()) { \n            return ArrayType.construct(_constructType(clz.getComponentType(), null), null, null);\n        }\n        if (clz.isEnum()) { \n            return new SimpleType(clz);\n        }\n        if (Map.class.isAssignableFrom(clz)) {\n            \n            JavaType keyType, contentType;\n            if (paramTypes.size() > 0) {\n                keyType = paramTypes.get(0);\n                contentType = (paramTypes.size() >= 2) ?\n                        paramTypes.get(1) : _unknownType();\n                return MapType.construct(clz, keyType, contentType);\n            }\n            return _mapType(clz);\n        }\n        if (Collection.class.isAssignableFrom(clz)) {\n            if (paramTypes.size() >= 1) {\n                return CollectionType.construct(clz, paramTypes.get(0));\n            }\n            return _collectionType(clz);\n        }\n        if (paramTypes.size() == 0) {\n            return new SimpleType(clz);\n        }\n        \n        JavaType[] pt = paramTypes.toArray(new JavaType[paramTypes.size()]);\n        return constructSimpleType(clz, clz, pt);\n    }\n    \n    \n    protected JavaType _fromParamType(ParameterizedType type, TypeBindings context) {\n        \n        Class<?> rawType = (Class<?>) type.getRawType();\n        Type[] args = type.getActualTypeArguments();\n        int paramCount = (args == null) ? 0 : args.length;\n\n        JavaType[] pt;\n        \n        if (paramCount == 0) {\n            pt = NO_TYPES;\n        } else {\n            pt = new JavaType[paramCount];\n            for (int i = 0; i < paramCount; ++i) {\n                pt[i] = _constructType(args[i], context);\n            }\n        }\n\n        \n        if (Map.class.isAssignableFrom(rawType)) {\n            JavaType subtype = constructSimpleType(rawType, rawType, pt);\n            JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n            if (mapParams.length != 2) {\n                throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \"+rawType.getName()+\" (found \"+mapParams.length+\")\");\n            }\n            return MapType.construct(rawType, mapParams[0], mapParams[1]);\n        }\n        if (Collection.class.isAssignableFrom(rawType)) {\n            JavaType subtype = constructSimpleType(rawType, rawType, pt);\n            JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n            if (collectionParams.length != 1) {\n                throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \"+rawType.getName()+\" (found \"+collectionParams.length+\")\");\n            }\n            return CollectionType.construct(rawType, collectionParams[0]);\n        }\n        if (paramCount == 0) { \n            return new SimpleType(rawType);\n        }\n        return constructSimpleType(rawType, pt);\n    }\n\n    \n    protected JavaType _fromArrayType(GenericArrayType type, TypeBindings context) {\n        JavaType compType = _constructType(type.getGenericComponentType(), context);\n        return ArrayType.construct(compType, null, null);\n    }\n\n    protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context) {\n        final String name = type.getName();\n        \n        if (context == null) {\n            \n            return _unknownType();\n        } else {\n            \n            \n            JavaType actualType = context.findType(name);\n            if (actualType != null) {\n                return actualType;\n            }\n        }\n\n        \n        Type[] bounds = type.getBounds();\n\n        \n        \n        \n        \n        \n        \n        \n        \n\n        \n        context._addPlaceholder(name);\n        return _constructType(bounds[0], context);\n    }\n\n    protected JavaType _fromWildcard(WildcardType type, TypeBindings context) {\n        \n        return _constructType(type.getUpperBounds()[0], context);\n    }\n\n    private JavaType _mapType(Class<?> rawClass) {\n        JavaType[] typeParams = findTypeParameters(rawClass, Map.class);\n        \n        if (typeParams == null) {\n            return MapType.construct(rawClass, _unknownType(), _unknownType());\n        }\n        \n        if (typeParams.length != 2) {\n            throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return MapType.construct(rawClass, typeParams[0], typeParams[1]);\n    }\n\n    private JavaType _collectionType(Class<?> rawClass) {\n        JavaType[] typeParams = findTypeParameters(rawClass, Collection.class);\n        \n        if (typeParams == null) {\n            return CollectionType.construct(rawClass, _unknownType());\n        }\n        \n        if (typeParams.length != 1) {\n            throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return CollectionType.construct(rawClass, typeParams[0]);\n    }    \n\n    protected JavaType _resolveVariableViaSubTypes(HierarchicType leafType, String variableName, TypeBindings bindings) {\n        \n        if (leafType != null && leafType.isGeneric()) {\n            TypeVariable<?>[] typeVariables = leafType.getRawClass().getTypeParameters();\n            for (int i = 0, len = typeVariables.length; i < len; ++i) {\n                TypeVariable<?> tv = typeVariables[i];\n                if (variableName.equals(tv.getName())) {\n                    \n                    Type type = leafType.asGeneric().getActualTypeArguments()[i];\n                    if (type instanceof TypeVariable<?>) {\n                        return _resolveVariableViaSubTypes(leafType.getSubType(), ((TypeVariable<?>) type).getName(), bindings);\n                    }\n                    \n                    return _constructType(type, bindings);\n                }\n            }\n        }\n        return _unknownType();\n    }\n    \n    protected JavaType _unknownType() {\n        return new SimpleType(Object.class);\n    }\n\n    \n\n    \n    protected HierarchicType _findSuperTypeChain(Class<?> subtype, Class<?> supertype) {\n        \n        if (supertype.isInterface()) {\n            return _findSuperInterfaceChain(subtype, supertype);\n        }\n        return _findSuperClassChain(subtype, supertype);\n    }\n\n    protected HierarchicType _findSuperClassChain(Type currentType, Class<?> target) {\n        HierarchicType current = new HierarchicType(currentType);\n        Class<?> raw = current.getRawClass();\n        if (raw == target) {\n            return current;\n        }\n        \n        Type parent = raw.getGenericSuperclass();\n        if (parent != null) {\n            HierarchicType sup = _findSuperClassChain(parent, target);\n            if (sup != null) {\n                sup.setSubType(current);\n                current.setSuperType(sup);\n                return current;\n            }\n        }\n        return null;\n    }\n\n    protected HierarchicType _findSuperInterfaceChain(Type currentType, Class<?> target) {\n        HierarchicType current = new HierarchicType(currentType);\n        Class<?> raw = current.getRawClass();\n        if (raw == target) {\n            return new HierarchicType(currentType);\n        }\n        \n        \n        if (raw == HashMap.class) {\n            if (target == Map.class) {\n                return _hashMapSuperInterfaceChain(current);\n            }\n        }\n        if (raw == ArrayList.class) {\n            if (target == List.class) {\n                return _arrayListSuperInterfaceChain(current);\n            }\n        }\n        return _doFindSuperInterfaceChain(current, target);\n    }\n    \n    protected HierarchicType _doFindSuperInterfaceChain(HierarchicType current, Class<?> target) {\n        Class<?> raw = current.getRawClass();\n        Type[] parents = raw.getGenericInterfaces();\n        \n        \n        if (parents != null) {\n            for (Type parent : parents) {\n                HierarchicType sup = _findSuperInterfaceChain(parent, target);\n                if (sup != null) {\n                    sup.setSubType(current);\n                    current.setSuperType(sup);\n                    return current;\n                }\n            }\n        }\n        \n        Type parent = raw.getGenericSuperclass();\n        if (parent != null) {\n            HierarchicType sup = _findSuperInterfaceChain(parent, target);\n            if (sup != null) {\n                sup.setSubType(current);\n                current.setSuperType(sup);\n                return current;\n            }\n        }\n        return null;\n    }\n\n    protected synchronized HierarchicType _hashMapSuperInterfaceChain(HierarchicType current) {\n        if (_cachedHashMapType == null) {\n            HierarchicType base = current.deepCloneWithoutSubtype();\n            _doFindSuperInterfaceChain(base, Map.class);\n            _cachedHashMapType = base.getSuperType();\n        }\n        HierarchicType t = _cachedHashMapType.deepCloneWithoutSubtype();\n        current.setSuperType(t);\n        t.setSubType(current);\n        return current;\n    }\n\n    protected synchronized HierarchicType _arrayListSuperInterfaceChain(HierarchicType current) {\n        if (_cachedArrayListType == null) {\n            HierarchicType base = current.deepCloneWithoutSubtype();\n            _doFindSuperInterfaceChain(base, List.class);\n            _cachedArrayListType = base.getSuperType();\n        }\n        HierarchicType t = _cachedArrayListType.deepCloneWithoutSubtype();\n        current.setSuperType(t);\n        t.setSubType(current);\n        return current;\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.type;\n\nimport java.util.*;\nimport java.lang.reflect.*;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.LRUMap;\n\n\n@SuppressWarnings({\"rawtypes\", \"unchecked\"})\npublic final class TypeFactory implements java.io.Serializable { private static final long serialVersionUID = 1L; private final static JavaType[] NO_TYPES = new JavaType[0]; protected final static TypeFactory instance = new TypeFactory(); protected final static SimpleType CORE_TYPE_STRING = new SimpleType(String.class); protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(Boolean.TYPE); protected final static SimpleType CORE_TYPE_INT = new SimpleType(Integer.TYPE); protected final static SimpleType CORE_TYPE_LONG = new SimpleType(Long.TYPE); protected final LRUMap<ClassKey, JavaType> _typeCache = new LRUMap<ClassKey, JavaType>(16, 100); protected transient HierarchicType _cachedHashMapType; protected transient HierarchicType _cachedArrayListType; protected final TypeModifier[] _modifiers; protected final TypeParser _parser; private TypeFactory() {\n        _parser = new TypeParser(this);\n        _modifiers = null;\n    }\n\n    protected TypeFactory(TypeParser p, TypeModifier[] mods) {\n        _parser = p;\n        _modifiers = mods;\n    }\n\n    public TypeFactory withModifier(TypeModifier mod) {\n        if (mod == null) { \n            return new TypeFactory(_parser, _modifiers);\n        }\n        if (_modifiers == null) {\n            return new TypeFactory(_parser, new TypeModifier[] { mod });\n        }\n        return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod));\n    }\n\n    \n    public static TypeFactory defaultInstance() { return instance; }\n\n    \n    public void clearCache() {\n        _typeCache.clear();\n    }\n    \n    \n    \n    \n    public static JavaType unknownType() {\n        return defaultInstance()._unknownType();\n    }\n\n    \n    public static Class<?> rawClass(Type t) {\n        if (t instanceof Class<?>) {\n            return (Class<?>) t;\n        }\n        \n        return defaultInstance().constructType(t).getRawClass();\n    }\n    \n    \n\n    \n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n        \n        if (baseType.getRawClass() == subclass) {\n            return baseType;\n        }\n        \n        if (baseType instanceof SimpleType) {\n            \n            if (subclass.isArray()\n                || Map.class.isAssignableFrom(subclass)\n                || Collection.class.isAssignableFrom(subclass)) {\n                \n                if (!baseType.getRawClass().isAssignableFrom(subclass)) {\n                    throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType);\n                }\n                \n                JavaType subtype = _fromClass(subclass, new TypeBindings(this, baseType.getRawClass()));\n                \n                Object h = baseType.getValueHandler();\n                if (h != null) {\n                    subtype = subtype.withValueHandler(h);\n                }\n                h = baseType.getTypeHandler();\n                if (h != null) {\n                    subtype = subtype.withTypeHandler(h);\n                }\n                return subtype;\n            }\n        }\n        \n        return baseType.narrowBy(subclass);\n    }\n\n    \n    public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException {\n        return _parser.parse(canonical);\n    }\n    \n    \n    public JavaType[] findTypeParameters(JavaType type, Class<?> expType) {\n        \n        if (expType == type.getParameterSource()) {\n            \n            int count = type.containedTypeCount();\n            if (count == 0) return null;\n            JavaType[] result = new JavaType[count];\n            for (int i = 0; i < count; ++i) {\n                result[i] = type.containedType(i);\n            }\n            return result;\n        }\n        \n        Class<?> raw = type.getRawClass();\n        return findTypeParameters(raw, expType, new TypeBindings(this, type));\n    }\n\n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) {\n        return findTypeParameters(clz, expType, new TypeBindings(this, clz));\n    }\n\n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) {\n        \n        HierarchicType subType = _findSuperTypeChain(clz, expType);\n        \n        if (subType == null) {\n            throw new IllegalArgumentException(\"Class \"+clz.getName()+\" is not a subtype of \"+expType.getName());\n        }\n        \n        HierarchicType superType = subType;\n        while (superType.getSuperType() != null) {\n            superType = superType.getSuperType();\n            Class<?> raw = superType.getRawClass();\n            TypeBindings newBindings = new TypeBindings(this, raw);\n            if (superType.isGeneric()) { \n                ParameterizedType pt = superType.asGeneric();\n                Type[] actualTypes = pt.getActualTypeArguments();\n                TypeVariable<?>[] vars = raw.getTypeParameters();\n                int len = actualTypes.length;\n                for (int i = 0; i < len; ++i) {\n                    String name = vars[i].getName();\n                    JavaType type = _constructType(actualTypes[i], bindings);\n                    newBindings.addBinding(name, type);\n                }\n            }\n            bindings = newBindings;\n        }\n\n        \n        if (!superType.isGeneric()) {\n            return null;\n        }\n        return bindings.typesAsArray();\n    }\n\n    \n    public JavaType moreSpecificType(JavaType type1, JavaType type2) {\n        if (type1 == null) {\n            return type2;\n        }\n        if (type2 == null) {\n            return type1;\n        }\n        Class<?> raw1 = type1.getRawClass();\n        Class<?> raw2 = type2.getRawClass();\n        if (raw1 == raw2) {\n            return type1;\n        }\n        \n        if (raw1.isAssignableFrom(raw2)) {\n            return type2;\n        }\n        return type1;\n    }\n    \n    \n\n    public JavaType constructType(Type type) {\n        return _constructType(type, null);\n    }\n\n    public JavaType constructType(Type type, TypeBindings bindings) {\n        return _constructType(type, bindings);\n    }\n    \n    public JavaType constructType(TypeReference<?> typeRef) {\n        return _constructType(typeRef.getType(), null);\n    }\n    \n    public JavaType constructType(Type type, Class<?> context) {\n        TypeBindings b = (context == null) ? null : new TypeBindings(this, context);\n        return _constructType(type, b);\n    }\n\n    public JavaType constructType(Type type, JavaType context) {\n        TypeBindings b = (context == null) ? null : new TypeBindings(this, context);\n        return _constructType(type, b);\n    }\n    \n    \n    protected JavaType _constructType(Type type, TypeBindings context) {\n        JavaType resultType;\n\n        \n        if (type instanceof Class<?>) {\n            resultType = _fromClass((Class<?>) type, context);\n        }\n        \n        else if (type instanceof ParameterizedType) {\n            resultType = _fromParamType((ParameterizedType) type, context);\n        }\n        else if (type instanceof JavaType) { \n            return (JavaType) type;\n        }\n        else if (type instanceof GenericArrayType) {\n            resultType = _fromArrayType((GenericArrayType) type, context);\n        }\n        else if (type instanceof TypeVariable<?>) {\n            resultType = _fromVariable((TypeVariable<?>) type, context);\n        }\n        else if (type instanceof WildcardType) {\n            resultType = _fromWildcard((WildcardType) type, context);\n        } else {\n            \n            throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString()));\n        }\n        \n        if (_modifiers != null && !resultType.isContainerType()) {\n            for (TypeModifier mod : _modifiers) {\n                resultType = mod.modifyType(resultType, type, context, this);\n            }\n        }\n        return resultType;\n    }\n\n    \n\n    \n    public ArrayType constructArrayType(Class<?> elementType) {\n        return ArrayType.construct(_constructType(elementType, null), null, null);\n    }\n    \n    \n    public ArrayType constructArrayType(JavaType elementType) {\n        return ArrayType.construct(elementType, null, null);\n    }\n\n    \n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) {\n        return CollectionType.construct(collectionClass, constructType(elementClass));\n    }\n    \n    \n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) {\n        return CollectionType.construct(collectionClass, elementType);\n    }\n\n    \n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) {\n        return CollectionLikeType.construct(collectionClass, constructType(elementClass));\n    }\n    \n    \n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) {\n        return CollectionLikeType.construct(collectionClass, elementType);\n    }\n    \n    \n    public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) {\n        return MapType.construct(mapClass, keyType, valueType);\n    }\n\n    \n    public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass));\n    }\n\n    \n    public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) {\n        return MapLikeType.construct(mapClass, keyType, valueType);\n    }\n    \n    \n    public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass));\n    }\n    \n    \n    @Deprecated\n    public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) {\n        return constructSimpleType(rawType, rawType, parameterTypes);\n    }\n    \n    public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes) {\n        \n        TypeVariable<?>[] typeVars = parameterTarget.getTypeParameters();\n        if (typeVars.length != parameterTypes.length) {\n            throw new IllegalArgumentException(\"Parameter type mismatch for \"+rawType.getName()\n                    +\" (and target \"+parameterTarget.getName()+\"): expected \"+typeVars.length\n                    +\" parameters, was given \"+parameterTypes.length);\n        }\n        String[] names = new String[typeVars.length];\n        for (int i = 0, len = typeVars.length; i < len; ++i) {\n            names[i] = typeVars[i].getName();\n        }\n        return new SimpleType(rawType, names, parameterTypes, null, null, false, parameterTarget);\n    } \n\n    \n    public JavaType uncheckedSimpleType(Class<?> cls) {\n        return new SimpleType(cls);\n    }\n    \n    \n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses) {\n        int len = parameterClasses.length;\n        JavaType[] pt = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            pt[i] = _fromClass(parameterClasses[i], null);\n        }\n        return constructParametrizedType(parametrized, parametersFor, pt);\n    }\n\n    \n    @Deprecated\n    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n        return constructParametrizedType(parametrized, parametrized, parameterClasses);\n    }\n\n    \n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes) {\n        JavaType resultType;\n        \n        \n        if (parametrized.isArray()) {\n            \n            if (parameterTypes.length != 1) {\n                throw new IllegalArgumentException(\"Need exactly 1 parameter type for arrays (\"+parametrized.getName()+\")\");\n            }\n            resultType = constructArrayType(parameterTypes[0]);\n        }\n        else if (Map.class.isAssignableFrom(parametrized)) {\n            if (parameterTypes.length != 2) {\n                throw new IllegalArgumentException(\"Need exactly 2 parameter types for Map types (\"+parametrized.getName()+\")\");\n            }\n            resultType = constructMapType((Class<Map<?,?>>)parametrized, parameterTypes[0], parameterTypes[1]);\n        }\n        else if (Collection.class.isAssignableFrom(parametrized)) {\n            if (parameterTypes.length != 1) {\n                throw new IllegalArgumentException(\"Need exactly 1 parameter type for Collection types (\"+parametrized.getName()+\")\");\n            }\n            resultType = constructCollectionType((Class<Collection<?>>)parametrized, parameterTypes[0]);\n        } else {\n            resultType = constructSimpleType(parametrized, parametersFor, parameterTypes);\n        }\n        return resultType;\n    }\n\n    \n    @Deprecated\n    public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes) {\n        return constructParametrizedType(parametrized, parametrized, parameterTypes);\n    }\n    \n    \n\n    \n    public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {\n        return CollectionType.construct(collectionClass, unknownType());\n    }\n\n    \n    public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {\n        return CollectionLikeType.construct(collectionClass, unknownType());\n    }\n\n    \n    public MapType constructRawMapType(Class<? extends Map> mapClass) {\n        return MapType.construct(mapClass, unknownType(), unknownType());\n    }\n\n    \n    public MapLikeType constructRawMapLikeType(Class<?> mapClass) {\n        return MapLikeType.construct(mapClass, unknownType(), unknownType());\n    }\n\n    \n\n    \n    protected JavaType _fromClass(Class<?> clz, TypeBindings context) {\n        \n        if (clz == String.class) return CORE_TYPE_STRING;\n        if (clz == Boolean.TYPE) return CORE_TYPE_BOOL;\n        if (clz == Integer.TYPE) return CORE_TYPE_INT;\n        if (clz == Long.TYPE) return CORE_TYPE_LONG;\n        \n        \n        ClassKey key = new ClassKey(clz);\n        JavaType result = _typeCache.get(key); \n        if (result != null) {\n            return result;\n        }\n\n        \n        \n\n        \n        if (clz.isArray()) {\n            result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null);\n            \n        } else if (clz.isEnum()) {\n            result = new SimpleType(clz);\n            \n        } else if (Map.class.isAssignableFrom(clz)) {\n            result = _mapType(clz);\n        } else if (Collection.class.isAssignableFrom(clz)) {\n            result =  _collectionType(clz);\n        } else {\n            \n            if (Map.Entry.class.isAssignableFrom(clz)) {\n                JavaType[] pts = this.findTypeParameters(clz, Map.Entry.class);\n                JavaType kt, vt;\n                if (pts == null || pts.length != 2) {\n                    kt = vt = unknownType();\n                } else {\n                    kt = pts[0];\n                    vt = pts[1];\n                }\n                result = constructSimpleType(clz, Map.Entry.class, new JavaType[] { kt, vt });\n            } else {\n                result = new SimpleType(clz);\n            }\n        }\n        _typeCache.put(key, result); \n        return result;\n    }\n    \n    \n    protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes) {\n        if (clz.isArray()) { \n            return ArrayType.construct(_constructType(clz.getComponentType(), null), null, null);\n        }\n        if (clz.isEnum()) { \n            return new SimpleType(clz);\n        }\n        if (Map.class.isAssignableFrom(clz)) {\n            \n            JavaType keyType, contentType;\n            if (paramTypes.size() > 0) {\n                keyType = paramTypes.get(0);\n                contentType = (paramTypes.size() >= 2) ?\n                        paramTypes.get(1) : _unknownType();\n                return MapType.construct(clz, keyType, contentType);\n            }\n            return _mapType(clz);\n        }\n        if (Collection.class.isAssignableFrom(clz)) {\n            if (paramTypes.size() >= 1) {\n                return CollectionType.construct(clz, paramTypes.get(0));\n            }\n            return _collectionType(clz);\n        }\n        if (paramTypes.size() == 0) {\n            return new SimpleType(clz);\n        }\n        \n        JavaType[] pt = paramTypes.toArray(new JavaType[paramTypes.size()]);\n        return constructSimpleType(clz, clz, pt);\n    }\n    \n    \n    protected JavaType _fromParamType(ParameterizedType type, TypeBindings context) {\n        \n        Class<?> rawType = (Class<?>) type.getRawType();\n        Type[] args = type.getActualTypeArguments();\n        int paramCount = (args == null) ? 0 : args.length;\n\n        JavaType[] pt;\n        \n        if (paramCount == 0) {\n            pt = NO_TYPES;\n        } else {\n            pt = new JavaType[paramCount];\n            for (int i = 0; i < paramCount; ++i) {\n                pt[i] = _constructType(args[i], context);\n            }\n        }\n\n        \n        if (Map.class.isAssignableFrom(rawType)) {\n            JavaType subtype = constructSimpleType(rawType, rawType, pt);\n            JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n            if (mapParams.length != 2) {\n                throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \"+rawType.getName()+\" (found \"+mapParams.length+\")\");\n            }\n            return MapType.construct(rawType, mapParams[0], mapParams[1]);\n        }\n        if (Collection.class.isAssignableFrom(rawType)) {\n            JavaType subtype = constructSimpleType(rawType, rawType, pt);\n            JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n            if (collectionParams.length != 1) {\n                throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \"+rawType.getName()+\" (found \"+collectionParams.length+\")\");\n            }\n            return CollectionType.construct(rawType, collectionParams[0]);\n        }\n        if (paramCount == 0) { \n            return new SimpleType(rawType);\n        }\n        return constructSimpleType(rawType, pt);\n    }\n\n    \n    protected JavaType _fromArrayType(GenericArrayType type, TypeBindings context) {\n        JavaType compType = _constructType(type.getGenericComponentType(), context);\n        return ArrayType.construct(compType, null, null);\n    }\n\n    protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context) {\n        final String name = type.getName();\n        \n        if (context == null) {\n            \n            context = new TypeBindings(this, (Class<?>) null);\n        } else {\n            \n            \n            JavaType actualType = context.findType(name, false);\n            if (actualType != null) {\n                return actualType;\n            }\n        }\n\n        \n        Type[] bounds = type.getBounds();\n\n        \n        \n        \n        \n        \n        \n        \n        \n\n        \n        context._addPlaceholder(name);\n        return _constructType(bounds[0], context);\n    }\n\n    protected JavaType _fromWildcard(WildcardType type, TypeBindings context) {\n        \n        return _constructType(type.getUpperBounds()[0], context);\n    }\n\n    private JavaType _mapType(Class<?> rawClass) {\n        JavaType[] typeParams = findTypeParameters(rawClass, Map.class);\n        \n        if (typeParams == null) {\n            return MapType.construct(rawClass, _unknownType(), _unknownType());\n        }\n        \n        if (typeParams.length != 2) {\n            throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return MapType.construct(rawClass, typeParams[0], typeParams[1]);\n    }\n\n    private JavaType _collectionType(Class<?> rawClass) {\n        JavaType[] typeParams = findTypeParameters(rawClass, Collection.class);\n        \n        if (typeParams == null) {\n            return CollectionType.construct(rawClass, _unknownType());\n        }\n        \n        if (typeParams.length != 1) {\n            throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return CollectionType.construct(rawClass, typeParams[0]);\n    }    \n\n    protected JavaType _resolveVariableViaSubTypes(HierarchicType leafType, String variableName, TypeBindings bindings) {\n        \n        if (leafType != null && leafType.isGeneric()) {\n            TypeVariable<?>[] typeVariables = leafType.getRawClass().getTypeParameters();\n            for (int i = 0, len = typeVariables.length; i < len; ++i) {\n                TypeVariable<?> tv = typeVariables[i];\n                if (variableName.equals(tv.getName())) {\n                    \n                    Type type = leafType.asGeneric().getActualTypeArguments()[i];\n                    if (type instanceof TypeVariable<?>) {\n                        return _resolveVariableViaSubTypes(leafType.getSubType(), ((TypeVariable<?>) type).getName(), bindings);\n                    }\n                    \n                    return _constructType(type, bindings);\n                }\n            }\n        }\n        return _unknownType();\n    }\n    \n    protected JavaType _unknownType() {\n        return new SimpleType(Object.class);\n    }\n\n    \n\n    \n    protected HierarchicType _findSuperTypeChain(Class<?> subtype, Class<?> supertype) {\n        \n        if (supertype.isInterface()) {\n            return _findSuperInterfaceChain(subtype, supertype);\n        }\n        return _findSuperClassChain(subtype, supertype);\n    }\n\n    protected HierarchicType _findSuperClassChain(Type currentType, Class<?> target) {\n        HierarchicType current = new HierarchicType(currentType);\n        Class<?> raw = current.getRawClass();\n        if (raw == target) {\n            return current;\n        }\n        \n        Type parent = raw.getGenericSuperclass();\n        if (parent != null) {\n            HierarchicType sup = _findSuperClassChain(parent, target);\n            if (sup != null) {\n                sup.setSubType(current);\n                current.setSuperType(sup);\n                return current;\n            }\n        }\n        return null;\n    }\n\n    protected HierarchicType _findSuperInterfaceChain(Type currentType, Class<?> target) {\n        HierarchicType current = new HierarchicType(currentType);\n        Class<?> raw = current.getRawClass();\n        if (raw == target) {\n            return new HierarchicType(currentType);\n        }\n        \n        \n        if (raw == HashMap.class) {\n            if (target == Map.class) {\n                return _hashMapSuperInterfaceChain(current);\n            }\n        }\n        if (raw == ArrayList.class) {\n            if (target == List.class) {\n                return _arrayListSuperInterfaceChain(current);\n            }\n        }\n        return _doFindSuperInterfaceChain(current, target);\n    }\n    \n    protected HierarchicType _doFindSuperInterfaceChain(HierarchicType current, Class<?> target) {\n        Class<?> raw = current.getRawClass();\n        Type[] parents = raw.getGenericInterfaces();\n        \n        \n        if (parents != null) {\n            for (Type parent : parents) {\n                HierarchicType sup = _findSuperInterfaceChain(parent, target);\n                if (sup != null) {\n                    sup.setSubType(current);\n                    current.setSuperType(sup);\n                    return current;\n                }\n            }\n        }\n        \n        Type parent = raw.getGenericSuperclass();\n        if (parent != null) {\n            HierarchicType sup = _findSuperInterfaceChain(parent, target);\n            if (sup != null) {\n                sup.setSubType(current);\n                current.setSuperType(sup);\n                return current;\n            }\n        }\n        return null;\n    }\n\n    protected synchronized HierarchicType _hashMapSuperInterfaceChain(HierarchicType current) {\n        if (_cachedHashMapType == null) {\n            HierarchicType base = current.deepCloneWithoutSubtype();\n            _doFindSuperInterfaceChain(base, Map.class);\n            _cachedHashMapType = base.getSuperType();\n        }\n        HierarchicType t = _cachedHashMapType.deepCloneWithoutSubtype();\n        current.setSuperType(t);\n        t.setSubType(current);\n        return current;\n    }\n\n    protected synchronized HierarchicType _arrayListSuperInterfaceChain(HierarchicType current) {\n        if (_cachedArrayListType == null) {\n            HierarchicType base = current.deepCloneWithoutSubtype();\n            _doFindSuperInterfaceChain(base, List.class);\n            _cachedArrayListType = base.getSuperType();\n        }\n        HierarchicType t = _cachedArrayListType.deepCloneWithoutSubtype();\n        current.setSuperType(t);\n        t.setSubType(current);\n        return current;\n    }\n}\n",
      "buggy_signatures": [
        "protected TypeFactory(TypeParser p, TypeModifier[] mods)",
        "public TypeFactory withModifier(TypeModifier mod)",
        "public static TypeFactory defaultInstance()",
        "public void clearCache()",
        "public static JavaType unknownType()",
        "public static Class<?> rawClass(Type t)",
        "public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)",
        "public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException",
        "public JavaType[] findTypeParameters(JavaType type, Class<?> expType)",
        "public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType)",
        "public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings)",
        "public JavaType moreSpecificType(JavaType type1, JavaType type2)",
        "public JavaType constructType(Type type)",
        "public JavaType constructType(Type type, TypeBindings bindings)",
        "public JavaType constructType(TypeReference<?> typeRef)",
        "public JavaType constructType(Type type, Class<?> context)",
        "public JavaType constructType(Type type, JavaType context)",
        "protected JavaType _constructType(Type type, TypeBindings context)",
        "public ArrayType constructArrayType(Class<?> elementType)",
        "public ArrayType constructArrayType(JavaType elementType)",
        "public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass)",
        "public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType)",
        "public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass)",
        "public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType)",
        "public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType)",
        "public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass)",
        "public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType)",
        "public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass)",
        "public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes)",
        "public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes)",
        "public JavaType uncheckedSimpleType(Class<?> cls)",
        "public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses)",
        "public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses)",
        "public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes)",
        "public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes)",
        "public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass)",
        "public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass)",
        "public MapType constructRawMapType(Class<? extends Map> mapClass)",
        "public MapLikeType constructRawMapLikeType(Class<?> mapClass)",
        "protected JavaType _fromClass(Class<?> clz, TypeBindings context)",
        "protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes)",
        "protected JavaType _fromParamType(ParameterizedType type, TypeBindings context)",
        "protected JavaType _fromArrayType(GenericArrayType type, TypeBindings context)",
        "protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)",
        "protected JavaType _fromWildcard(WildcardType type, TypeBindings context)",
        "private JavaType _mapType(Class<?> rawClass)",
        "private JavaType _collectionType(Class<?> rawClass)",
        "protected JavaType _resolveVariableViaSubTypes(HierarchicType leafType, String variableName, TypeBindings bindings)",
        "protected JavaType _unknownType()",
        "protected HierarchicType _findSuperTypeChain(Class<?> subtype, Class<?> supertype)",
        "protected HierarchicType _findSuperClassChain(Type currentType, Class<?> target)",
        "protected HierarchicType _findSuperInterfaceChain(Type currentType, Class<?> target)",
        "protected HierarchicType _doFindSuperInterfaceChain(HierarchicType current, Class<?> target)",
        "protected synchronized HierarchicType _hashMapSuperInterfaceChain(HierarchicType current)",
        "protected synchronized HierarchicType _arrayListSuperInterfaceChain(HierarchicType current)"
      ],
      "fixed_signatures": [
        "protected TypeFactory(TypeParser p, TypeModifier[] mods)",
        "public TypeFactory withModifier(TypeModifier mod)",
        "public static TypeFactory defaultInstance()",
        "public void clearCache()",
        "public static JavaType unknownType()",
        "public static Class<?> rawClass(Type t)",
        "public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)",
        "public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException",
        "public JavaType[] findTypeParameters(JavaType type, Class<?> expType)",
        "public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType)",
        "public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings)",
        "public JavaType moreSpecificType(JavaType type1, JavaType type2)",
        "public JavaType constructType(Type type)",
        "public JavaType constructType(Type type, TypeBindings bindings)",
        "public JavaType constructType(TypeReference<?> typeRef)",
        "public JavaType constructType(Type type, Class<?> context)",
        "public JavaType constructType(Type type, JavaType context)",
        "protected JavaType _constructType(Type type, TypeBindings context)",
        "public ArrayType constructArrayType(Class<?> elementType)",
        "public ArrayType constructArrayType(JavaType elementType)",
        "public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass)",
        "public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType)",
        "public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass)",
        "public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType)",
        "public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType)",
        "public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass)",
        "public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType)",
        "public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass)",
        "public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes)",
        "public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes)",
        "public JavaType uncheckedSimpleType(Class<?> cls)",
        "public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, Class<?>... parameterClasses)",
        "public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses)",
        "public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor, JavaType... parameterTypes)",
        "public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes)",
        "public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass)",
        "public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass)",
        "public MapType constructRawMapType(Class<? extends Map> mapClass)",
        "public MapLikeType constructRawMapLikeType(Class<?> mapClass)",
        "protected JavaType _fromClass(Class<?> clz, TypeBindings context)",
        "protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes)",
        "protected JavaType _fromParamType(ParameterizedType type, TypeBindings context)",
        "protected JavaType _fromArrayType(GenericArrayType type, TypeBindings context)",
        "protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)",
        "protected JavaType _fromWildcard(WildcardType type, TypeBindings context)",
        "private JavaType _mapType(Class<?> rawClass)",
        "private JavaType _collectionType(Class<?> rawClass)",
        "protected JavaType _resolveVariableViaSubTypes(HierarchicType leafType, String variableName, TypeBindings bindings)",
        "protected JavaType _unknownType()",
        "protected HierarchicType _findSuperTypeChain(Class<?> subtype, Class<?> supertype)",
        "protected HierarchicType _findSuperClassChain(Type currentType, Class<?> target)",
        "protected HierarchicType _findSuperInterfaceChain(Type currentType, Class<?> target)",
        "protected HierarchicType _doFindSuperInterfaceChain(HierarchicType current, Class<?> target)",
        "protected synchronized HierarchicType _hashMapSuperInterfaceChain(HierarchicType current)",
        "protected synchronized HierarchicType _arrayListSuperInterfaceChain(HierarchicType current)"
      ],
      "methods": [
        {
          "buggy_method": "  protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context) {\n  final String name = type.getName();\n  \n  if (context == null) {\n  \n  return _unknownType();\n  } else {\n  \n  \n  JavaType actualType = context.findType(name);\n  if (actualType != null) {\n  return actualType;\n  }\n  }\n\n  \n  Type[] bounds = type.getBounds();\n\n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  context._addPlaceholder(name);\n  return _constructType(bounds[0], context);\n  }",
          "fixed_method": "  protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context) {\n  final String name = type.getName();\n  \n  if (context == null) {\n  \n  context = new TypeBindings(this, (Class<?>) null);\n  } else {\n  \n  \n  JavaType actualType = context.findType(name, false);\n  if (actualType != null) {\n  return actualType;\n  }\n  }\n\n  \n  Type[] bounds = type.getBounds();\n\n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  context._addPlaceholder(name);\n  return _constructType(bounds[0], context);\n  }",
          "diff": [
            "@@ -892,14 +892,14 @@",
            "         // 19-Mar-2015: Without context, all we can check are bounds.\n",
            "         if (context == null) {\n",
            "             // And to prevent infinite loops, now need this:\n",
            "-            return _unknownType();\n",
            "+            context = new TypeBindings(this, (Class<?>) null);\n",
            "         } else {\n",
            "             // Ok: here's where context might come in handy!\n",
            "             /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n",
            "              *   unresolved type variables to handle some cases where bounds\n",
            "              *   are enough. Let's hope it does not hide real fail cases.\n",
            "              */\n",
            "-            JavaType actualType = context.findType(name);\n",
            "+            JavaType actualType = context.findType(name, false);\n",
            "             if (actualType != null) {\n",
            "                 return actualType;\n",
            "             }\n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
