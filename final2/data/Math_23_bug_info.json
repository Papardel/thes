{
  "bug_id": "23",
  "failed_tests": {
    "org.apache.commons.math3.optimization.univariate.BrentOptimizerTest": [
      {
        "methodName": "testKeepInitIfBest",
        "error": "junit.framework.AssertionFailedError",
        "message": "Best point not reported",
        "fail_line": "        Assert.assertTrue(\"Best point not reported\", f.value(sol) <= f.value(expected));",
        "test_source": "  public void testKeepInitIfBest() {\n  final double minSin = 3 * Math.PI / 2;\n  final double offset = 1e-8;\n  final double delta = 1e-7;\n  final UnivariateFunction f1 = new Sin();\n  final UnivariateFunction f2 = new StepFunction(new double[] { minSin, minSin + offset, minSin + 2 * offset},\n  new double[] { 0, -1, 0 });\n  final UnivariateFunction f = FunctionUtils.add(f1, f2);\n  // A slightly less stringent tolerance would make the test pass\n  // even with the previous implementation.\n  final double relTol = 1e-8;\n  final UnivariateOptimizer optimizer = new BrentOptimizer(relTol, 1e-100);\n  final double init = minSin + 1.5 * offset;\n  final UnivariatePointValuePair result\n  = optimizer.optimize(200, f, GoalType.MINIMIZE,\n  minSin - 6.789 * delta,\n  minSin + 9.876 * delta,\n  init);\n  final int numEval = optimizer.getEvaluations();\n\n  final double sol = result.getPoint();\n  final double expected = init;\n\n//  System.out.println(\"numEval=\" + numEval);\n//  System.out.println(\"min=\" + init + \" f=\" + f.value(init));\n//  System.out.println(\"sol=\" + sol + \" f=\" + f.value(sol));\n//  System.out.println(\"exp=\" + expected + \" f=\" + f.value(expected));\n\n  Assert.assertTrue(\"Best point not reported\", f.value(sol) <= f.value(expected));\n  }",
        "stack": [
          "BrentOptimizerTest.testKeepInitIfBest line 221"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math3/optimization/univariate/BrentOptimizer.java",
      "buggy_full_code": "\npackage org.apache.commons.math3.optimization.univariate;\n\nimport org.apache.commons.math3.util.Precision;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.exception.NumberIsTooSmallException;\nimport org.apache.commons.math3.exception.NotStrictlyPositiveException;\nimport org.apache.commons.math3.optimization.ConvergenceChecker;\nimport org.apache.commons.math3.optimization.GoalType;\n\n\npublic class BrentOptimizer extends BaseAbstractUnivariateOptimizer { private static final double GOLDEN_SECTION = 0.5 * (3 - FastMath.sqrt(5)); private static final double MIN_RELATIVE_TOLERANCE = 2 * FastMath.ulp(1d); private final double relativeThreshold; private final double absoluteThreshold; public BrentOptimizer(double rel, double abs, ConvergenceChecker<UnivariatePointValuePair> checker) {\n        super(checker);\n\n        if (rel < MIN_RELATIVE_TOLERANCE) {\n            throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);\n        }\n        if (abs <= 0) {\n            throw new NotStrictlyPositiveException(abs);\n        }\n\n        relativeThreshold = rel;\n        absoluteThreshold = abs;\n    }\n\n    \n    public BrentOptimizer(double rel, double abs) {\n        this(rel, abs, null);\n    }\n\n    \n    @Override\n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        \n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n        \n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            \n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (FastMath.abs(e) > tol1) { \n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x) &&\n                        p < q * (b - x) &&\n                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                        \n                        d = p / q;\n                        u = x + d;\n\n                        \n                        if (u - a < tol2 || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        \n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    \n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                \n                if (FastMath.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                double fu = computeObjectiveValue(u);\n                if (!isMinim) {\n                    fu = -fu;\n                }\n\n                \n                previous = current;\n                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n                if (checker != null) {\n                    if (checker.converged(iter, previous, current)) {\n                        return best(current, previous, isMinim);\n                    }\n                }\n\n                \n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw ||\n                        Precision.equals(w, x)) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv ||\n                               Precision.equals(v, x) ||\n                               Precision.equals(v, w)) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { \n                return\n                            best(current,\n                                 previous,\n                            isMinim);\n            }\n            ++iter;\n        }\n    }\n\n    \n    private UnivariatePointValuePair best(UnivariatePointValuePair a, UnivariatePointValuePair b, boolean isMinim) {\n        if (a == null) {\n            return b;\n        }\n        if (b == null) {\n            return a;\n        }\n\n        if (isMinim) {\n            return a.getValue() <= b.getValue() ? a : b;\n        } else {\n            return a.getValue() >= b.getValue() ? a : b;\n        }\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.math3.optimization.univariate;\n\nimport org.apache.commons.math3.util.Precision;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.exception.NumberIsTooSmallException;\nimport org.apache.commons.math3.exception.NotStrictlyPositiveException;\nimport org.apache.commons.math3.optimization.ConvergenceChecker;\nimport org.apache.commons.math3.optimization.GoalType;\n\n\npublic class BrentOptimizer extends BaseAbstractUnivariateOptimizer { private static final double GOLDEN_SECTION = 0.5 * (3 - FastMath.sqrt(5)); private static final double MIN_RELATIVE_TOLERANCE = 2 * FastMath.ulp(1d); private final double relativeThreshold; private final double absoluteThreshold; public BrentOptimizer(double rel, double abs, ConvergenceChecker<UnivariatePointValuePair> checker) {\n        super(checker);\n\n        if (rel < MIN_RELATIVE_TOLERANCE) {\n            throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);\n        }\n        if (abs <= 0) {\n            throw new NotStrictlyPositiveException(abs);\n        }\n\n        relativeThreshold = rel;\n        absoluteThreshold = abs;\n    }\n\n    \n    public BrentOptimizer(double rel, double abs) {\n        this(rel, abs, null);\n    }\n\n    \n    @Override\n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        \n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n        \n        UnivariatePointValuePair best = current;\n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            \n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (FastMath.abs(e) > tol1) { \n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x) &&\n                        p < q * (b - x) &&\n                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                        \n                        d = p / q;\n                        u = x + d;\n\n                        \n                        if (u - a < tol2 || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        \n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    \n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                \n                if (FastMath.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                double fu = computeObjectiveValue(u);\n                if (!isMinim) {\n                    fu = -fu;\n                }\n\n                \n                previous = current;\n                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n                best = best(best,\n                            best(current,\n                                 previous,\n                                 isMinim),\n                            isMinim);\n\n                if (checker != null) {\n                    if (checker.converged(iter, previous, current)) {\n                        return best;\n                    }\n                }\n\n                \n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw ||\n                        Precision.equals(w, x)) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv ||\n                               Precision.equals(v, x) ||\n                               Precision.equals(v, w)) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { \n                return best(best,\n                            best(current,\n                                 previous,\n                                 isMinim),\n                            isMinim);\n            }\n            ++iter;\n        }\n    }\n\n    \n    private UnivariatePointValuePair best(UnivariatePointValuePair a, UnivariatePointValuePair b, boolean isMinim) {\n        if (a == null) {\n            return b;\n        }\n        if (b == null) {\n            return a;\n        }\n\n        if (isMinim) {\n            return a.getValue() <= b.getValue() ? a : b;\n        } else {\n            return a.getValue() >= b.getValue() ? a : b;\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public BrentOptimizer(double rel, double abs)",
        "protected UnivariatePointValuePair doOptimize()",
        "private UnivariatePointValuePair best(UnivariatePointValuePair a, UnivariatePointValuePair b, boolean isMinim)"
      ],
      "fixed_signatures": [
        "public BrentOptimizer(double rel, double abs)",
        "protected UnivariatePointValuePair doOptimize()",
        "private UnivariatePointValuePair best(UnivariatePointValuePair a, UnivariatePointValuePair b, boolean isMinim)"
      ],
      "methods": [
        {
          "buggy_method": "  protected UnivariatePointValuePair doOptimize() {\n  final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n  final double lo = getMin();\n  final double mid = getStartValue();\n  final double hi = getMax();\n\n  \n  final ConvergenceChecker<UnivariatePointValuePair> checker\n  = getConvergenceChecker();\n\n  double a;\n  double b;\n  if (lo < hi) {\n  a = lo;\n  b = hi;\n  } else {\n  a = hi;\n  b = lo;\n  }\n\n  double x = mid;\n  double v = x;\n  double w = x;\n  double d = 0;\n  double e = 0;\n  double fx = computeObjectiveValue(x);\n  if (!isMinim) {\n  fx = -fx;\n  }\n  double fv = fx;\n  double fw = fx;\n\n  UnivariatePointValuePair previous = null;\n  UnivariatePointValuePair current\n  = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n  \n\n  int iter = 0;\n  while (true) {\n  final double m = 0.5 * (a + b);\n  final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n  final double tol2 = 2 * tol1;\n\n  \n  final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n  if (!stop) {\n  double p = 0;\n  double q = 0;\n  double r = 0;\n  double u = 0;\n\n  if (FastMath.abs(e) > tol1) { \n  r = (x - w) * (fx - fv);\n  q = (x - v) * (fx - fw);\n  p = (x - v) * q - (x - w) * r;\n  q = 2 * (q - r);\n\n  if (q > 0) {\n  p = -p;\n  } else {\n  q = -q;\n  }\n\n  r = e;\n  e = d;\n\n  if (p > q * (a - x) &&\n  p < q * (b - x) &&\n  FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n  \n  d = p / q;\n  u = x + d;\n\n  \n  if (u - a < tol2 || b - u < tol2) {\n  if (x <= m) {\n  d = tol1;\n  } else {\n  d = -tol1;\n  }\n  }\n  } else {\n  \n  if (x < m) {\n  e = b - x;\n  } else {\n  e = a - x;\n  }\n  d = GOLDEN_SECTION * e;\n  }\n  } else {\n  \n  if (x < m) {\n  e = b - x;\n  } else {\n  e = a - x;\n  }\n  d = GOLDEN_SECTION * e;\n  }\n\n  \n  if (FastMath.abs(d) < tol1) {\n  if (d >= 0) {\n  u = x + tol1;\n  } else {\n  u = x - tol1;\n  }\n  } else {\n  u = x + d;\n  }\n\n  double fu = computeObjectiveValue(u);\n  if (!isMinim) {\n  fu = -fu;\n  }\n\n  \n  previous = current;\n  current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n  if (checker != null) {\n  if (checker.converged(iter, previous, current)) {\n  return best(current, previous, isMinim);\n  }\n  }\n\n  \n  if (fu <= fx) {\n  if (u < x) {\n  b = x;\n  } else {\n  a = x;\n  }\n  v = w;\n  fv = fw;\n  w = x;\n  fw = fx;\n  x = u;\n  fx = fu;\n  } else {\n  if (u < x) {\n  a = u;\n  } else {\n  b = u;\n  }\n  if (fu <= fw ||\n  Precision.equals(w, x)) {\n  v = w;\n  fv = fw;\n  w = u;\n  fw = fu;\n  } else if (fu <= fv ||\n  Precision.equals(v, x) ||\n  Precision.equals(v, w)) {\n  v = u;\n  fv = fu;\n  }\n  }\n  } else { \n  return\n  best(current,\n  previous,\n  isMinim);\n  }\n  ++iter;\n  }\n  }",
          "fixed_method": "  protected UnivariatePointValuePair doOptimize() {\n  final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n  final double lo = getMin();\n  final double mid = getStartValue();\n  final double hi = getMax();\n\n  \n  final ConvergenceChecker<UnivariatePointValuePair> checker\n  = getConvergenceChecker();\n\n  double a;\n  double b;\n  if (lo < hi) {\n  a = lo;\n  b = hi;\n  } else {\n  a = hi;\n  b = lo;\n  }\n\n  double x = mid;\n  double v = x;\n  double w = x;\n  double d = 0;\n  double e = 0;\n  double fx = computeObjectiveValue(x);\n  if (!isMinim) {\n  fx = -fx;\n  }\n  double fv = fx;\n  double fw = fx;\n\n  UnivariatePointValuePair previous = null;\n  UnivariatePointValuePair current\n  = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n  \n  UnivariatePointValuePair best = current;\n\n  int iter = 0;\n  while (true) {\n  final double m = 0.5 * (a + b);\n  final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n  final double tol2 = 2 * tol1;\n\n  \n  final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n  if (!stop) {\n  double p = 0;\n  double q = 0;\n  double r = 0;\n  double u = 0;\n\n  if (FastMath.abs(e) > tol1) { \n  r = (x - w) * (fx - fv);\n  q = (x - v) * (fx - fw);\n  p = (x - v) * q - (x - w) * r;\n  q = 2 * (q - r);\n\n  if (q > 0) {\n  p = -p;\n  } else {\n  q = -q;\n  }\n\n  r = e;\n  e = d;\n\n  if (p > q * (a - x) &&\n  p < q * (b - x) &&\n  FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n  \n  d = p / q;\n  u = x + d;\n\n  \n  if (u - a < tol2 || b - u < tol2) {\n  if (x <= m) {\n  d = tol1;\n  } else {\n  d = -tol1;\n  }\n  }\n  } else {\n  \n  if (x < m) {\n  e = b - x;\n  } else {\n  e = a - x;\n  }\n  d = GOLDEN_SECTION * e;\n  }\n  } else {\n  \n  if (x < m) {\n  e = b - x;\n  } else {\n  e = a - x;\n  }\n  d = GOLDEN_SECTION * e;\n  }\n\n  \n  if (FastMath.abs(d) < tol1) {\n  if (d >= 0) {\n  u = x + tol1;\n  } else {\n  u = x - tol1;\n  }\n  } else {\n  u = x + d;\n  }\n\n  double fu = computeObjectiveValue(u);\n  if (!isMinim) {\n  fu = -fu;\n  }\n\n  \n  previous = current;\n  current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n  best = best(best,\n  best(current,\n  previous,\n  isMinim),\n  isMinim);\n\n  if (checker != null) {\n  if (checker.converged(iter, previous, current)) {\n  return best;\n  }\n  }\n\n  \n  if (fu <= fx) {\n  if (u < x) {\n  b = x;\n  } else {\n  a = x;\n  }\n  v = w;\n  fv = fw;\n  w = x;\n  fw = fx;\n  x = u;\n  fx = fu;\n  } else {\n  if (u < x) {\n  a = u;\n  } else {\n  b = u;\n  }\n  if (fu <= fw ||\n  Precision.equals(w, x)) {\n  v = w;\n  fv = fw;\n  w = u;\n  fw = fu;\n  } else if (fu <= fv ||\n  Precision.equals(v, x) ||\n  Precision.equals(v, w)) {\n  v = u;\n  fv = fu;\n  }\n  }\n  } else { \n  return best(best,\n  best(current,\n  previous,\n  isMinim),\n  isMinim);\n  }\n  ++iter;\n  }\n  }",
          "diff": [
            "@@ -148,6 +148,7 @@",
            "         UnivariatePointValuePair current\n",
            "             = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n",
            "         // Best point encountered so far (which is the initial guess).\n",
            "+        UnivariatePointValuePair best = current;\n",
            " \n",
            "         int iter = 0;\n",
            "         while (true) {\n",
            "@@ -231,10 +232,15 @@",
            "                 // User-defined convergence checker.\n",
            "                 previous = current;\n",
            "                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n",
            "+                best = best(best,\n",
            "+                            best(current,\n",
            "+                                 previous,\n",
            "+                                 isMinim),\n",
            "+                            isMinim);\n",
            " \n",
            "                 if (checker != null) {\n",
            "                     if (checker.converged(iter, previous, current)) {\n",
            "-                        return best(current, previous, isMinim);\n",
            "+                        return best;\n",
            "                     }\n",
            "                 }\n",
            " \n",
            "@@ -271,9 +277,10 @@",
            "                     }\n",
            "                 }\n",
            "             } else { // Default termination (Brent's criterion).\n",
            "-                return\n",
            "+                return best(best,\n",
            "                             best(current,\n",
            "                                  previous,\n",
            "+                                 isMinim),\n",
            "                             isMinim);\n",
            "             }\n",
            "             ++iter;\n"
          ],
          "changed_lines": 11
        }
      ]
    }
  ]
}
