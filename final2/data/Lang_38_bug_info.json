{
  "bug_id": "38",
  "failed_tests": {
    "org.apache.commons.lang3.time.FastDateFormatTest": [
      {
        "methodName": "testLang538",
        "error": "junit.framework.ComparisonFailure",
        "message": "dateTime expected:<2009-10-16T[16]:42:16.000Z> but was:<2009-10-16T[08]:42:16.000Z>",
        "fail_line": "        assertEquals(\"dateTime\", dateTime, format.format(cal));",
        "test_source": "  public void testLang538() {\n  final String dateTime = \"2009-10-16T16:42:16.000Z\";\n\n  // more commonly constructed with: cal = new GregorianCalendar(2009, 9, 16, 8, 42, 16)\n  // for the unit test to work in any time zone, constructing with GMT-8 rather than default locale time zone\n  GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-8\"));\n  cal.clear();\n  cal.set(2009, 9, 16, 8, 42, 16);\n\n  FastDateFormat format = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\", TimeZone.getTimeZone(\"GMT\"));\n  assertEquals(\"dateTime\", dateTime, format.format(cal));\n  }",
        "stack": [
          "FastDateFormatTest.testLang538 line 349"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/lang3/time/FastDateFormat.java",
      "buggy_full_code": "\npackage org.apache.commons.lang3.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.text.DateFormat;\nimport java.text.DateFormatSymbols;\nimport java.text.FieldPosition;\nimport java.text.Format;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.TimeZone;\n\nimport org.apache.commons.lang3.Validate;\n\n\npublic class FastDateFormat extends Format { private static final long serialVersionUID = 1L; public static final int FULL = DateFormat.FULL; public static final int LONG = DateFormat.LONG; public static final int MEDIUM = DateFormat.MEDIUM; public static final int SHORT = DateFormat.SHORT; private static String cDefaultPattern; private static final Map<FastDateFormat, FastDateFormat> cInstanceCache = new HashMap<FastDateFormat, FastDateFormat>(7); private static final Map<Object, FastDateFormat> cDateInstanceCache = new HashMap<Object, FastDateFormat>(7); private static final Map<Object, FastDateFormat> cTimeInstanceCache = new HashMap<Object, FastDateFormat>(7); private static final Map<Object, FastDateFormat> cDateTimeInstanceCache = new HashMap<Object, FastDateFormat>(7); private static final Map<Object, String> cTimeZoneDisplayCache = new HashMap<Object, String>(7); private final String mPattern; private final TimeZone mTimeZone; private final boolean mTimeZoneForced; private final Locale mLocale; private final boolean mLocaleForced; private transient Rule[] mRules; private transient int mMaxLengthEstimate; public static FastDateFormat getInstance() {\n        return getInstance(getDefaultPattern(), null, null);\n    }\n\n    \n    public static FastDateFormat getInstance(String pattern) {\n        return getInstance(pattern, null, null);\n    }\n\n    \n    public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {\n        return getInstance(pattern, timeZone, null);\n    }\n\n    \n    public static FastDateFormat getInstance(String pattern, Locale locale) {\n        return getInstance(pattern, null, locale);\n    }\n\n    \n    public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {\n        FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);\n        FastDateFormat format = cInstanceCache.get(emptyFormat);\n        if (format == null) {\n            format = emptyFormat;\n            format.init();  \n            cInstanceCache.put(format, format);  \n        }\n        return format;\n    }\n\n    \n    \n    public static FastDateFormat getDateInstance(int style) {\n        return getDateInstance(style, null, null);\n    }\n\n    \n    public static FastDateFormat getDateInstance(int style, Locale locale) {\n        return getDateInstance(style, null, locale);\n    }\n\n    \n    public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {\n        return getDateInstance(style, timeZone, null);\n    }\n    \n    public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {\n        Object key = Integer.valueOf(style);\n        if (timeZone != null) {\n            key = new Pair(key, timeZone);\n        }\n\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n\n        key = new Pair(key, locale);\n\n        FastDateFormat format = cDateInstanceCache.get(key);\n        if (format == null) {\n            try {\n                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);\n                String pattern = formatter.toPattern();\n                format = getInstance(pattern, timeZone, locale);\n                cDateInstanceCache.put(key, format);\n                \n            } catch (ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date pattern for locale: \" + locale);\n            }\n        }\n        return format;\n    }\n\n    \n    \n    public static FastDateFormat getTimeInstance(int style) {\n        return getTimeInstance(style, null, null);\n    }\n\n    \n    public static FastDateFormat getTimeInstance(int style, Locale locale) {\n        return getTimeInstance(style, null, locale);\n    }\n    \n    \n    public static FastDateFormat getTimeInstance(int style, TimeZone timeZone) {\n        return getTimeInstance(style, timeZone, null);\n    }\n    \n    \n    public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {\n        Object key = Integer.valueOf(style);\n        if (timeZone != null) {\n            key = new Pair(key, timeZone);\n        }\n        if (locale != null) {\n            key = new Pair(key, locale);\n        }\n\n        FastDateFormat format = cTimeInstanceCache.get(key);\n        if (format == null) {\n            if (locale == null) {\n                locale = Locale.getDefault();\n            }\n\n            try {\n                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getTimeInstance(style, locale);\n                String pattern = formatter.toPattern();\n                format = getInstance(pattern, timeZone, locale);\n                cTimeInstanceCache.put(key, format);\n            \n            } catch (ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date pattern for locale: \" + locale);\n            }\n        }\n        return format;\n    }\n\n    \n    \n    public static FastDateFormat getDateTimeInstance( int dateStyle, int timeStyle) {\n        return getDateTimeInstance(dateStyle, timeStyle, null, null);\n    }\n    \n    \n    public static FastDateFormat getDateTimeInstance( int dateStyle, int timeStyle, Locale locale) {\n        return getDateTimeInstance(dateStyle, timeStyle, null, locale);\n    }\n    \n    \n    public static FastDateFormat getDateTimeInstance( int dateStyle, int timeStyle, TimeZone timeZone) {\n        return getDateTimeInstance(dateStyle, timeStyle, timeZone, null);\n    }    \n    \n    public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) {\n\n        Object key = new Pair(Integer.valueOf(dateStyle), Integer.valueOf(timeStyle));\n        if (timeZone != null) {\n            key = new Pair(key, timeZone);\n        }\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        key = new Pair(key, locale);\n\n        FastDateFormat format = cDateTimeInstanceCache.get(key);\n        if (format == null) {\n            try {\n                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,\n                        locale);\n                String pattern = formatter.toPattern();\n                format = getInstance(pattern, timeZone, locale);\n                cDateTimeInstanceCache.put(key, format);\n\n            } catch (ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return format;\n    }\n\n    \n    \n    static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {\n        Object key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n        String value = cTimeZoneDisplayCache.get(key);\n        if (value == null) {\n            \n            value = tz.getDisplayName(daylight, style, locale);\n            cTimeZoneDisplayCache.put(key, value);\n        }\n        return value;\n    }\n\n    \n    private static synchronized String getDefaultPattern() {\n        if (cDefaultPattern == null) {\n            cDefaultPattern = new SimpleDateFormat().toPattern();\n        }\n        return cDefaultPattern;\n    }\n\n    \n    \n    \n    protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {\n        super();\n        if (pattern == null) {\n            throw new IllegalArgumentException(\"The pattern must not be null\");\n        }\n        mPattern = pattern;\n        \n        mTimeZoneForced = (timeZone != null);\n        if (timeZone == null) {\n            timeZone = TimeZone.getDefault();\n        }\n        mTimeZone = timeZone;\n        \n        mLocaleForced = (locale != null);\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        mLocale = locale;\n    }\n\n    \n    protected void init() {\n        List<Rule> rulesList = parsePattern();\n        mRules = rulesList.toArray(new Rule[rulesList.size()]);\n\n        int len = 0;\n        for (int i=mRules.length; --i >= 0; ) {\n            len += mRules[i].estimateLength();\n        }\n\n        mMaxLengthEstimate = len;\n    }\n\n    \n    \n    \n    protected List<Rule> parsePattern() {\n        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n        List<Rule> rules = new ArrayList<Rule>();\n\n        String[] ERAs = symbols.getEras();\n        String[] months = symbols.getMonths();\n        String[] shortMonths = symbols.getShortMonths();\n        String[] weekdays = symbols.getWeekdays();\n        String[] shortWeekdays = symbols.getShortWeekdays();\n        String[] AmPmStrings = symbols.getAmPmStrings();\n\n        int length = mPattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i = 0; i < length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(mPattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n\n            Rule rule;\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': \n                rule = new TextField(Calendar.ERA, ERAs);\n                break;\n            case 'y': \n                if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }\n                break;\n            case 'M': \n                if (tokenLen >= 4) {\n                    rule = new TextField(Calendar.MONTH, months);\n                } else if (tokenLen == 3) {\n                    rule = new TextField(Calendar.MONTH, shortMonths);\n                } else if (tokenLen == 2) {\n                    rule = TwoDigitMonthField.INSTANCE;\n                } else {\n                    rule = UnpaddedMonthField.INSTANCE;\n                }\n                break;\n            case 'd': \n                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n                break;\n            case 'h': \n                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n                break;\n            case 'H': \n                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n                break;\n            case 'm': \n                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n                break;\n            case 's': \n                rule = selectNumberRule(Calendar.SECOND, tokenLen);\n                break;\n            case 'S': \n                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n                break;\n            case 'E': \n                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n                break;\n            case 'D': \n                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n                break;\n            case 'F': \n                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n                break;\n            case 'w': \n                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n                break;\n            case 'W': \n                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n                break;\n            case 'a': \n                rule = new TextField(Calendar.AM_PM, AmPmStrings);\n                break;\n            case 'k': \n                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n                break;\n            case 'K': \n                rule = selectNumberRule(Calendar.HOUR, tokenLen);\n                break;\n            case 'z': \n                if (tokenLen >= 4) {\n                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.LONG);\n                } else {\n                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.SHORT);\n                }\n                break;\n            case 'Z': \n                if (tokenLen == 1) {\n                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n                } else {\n                    rule = TimeZoneNumberRule.INSTANCE_COLON;\n                }\n                break;\n            case '\\'': \n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    rule = new CharacterLiteral(sub.charAt(0));\n                } else {\n                    rule = new StringLiteral(sub);\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n            }\n\n            rules.add(rule);\n        }\n\n        return rules;\n    }\n\n    \n    protected String parseToken(String pattern, int[] indexRef) {\n        StringBuilder buf = new StringBuilder();\n\n        int i = indexRef[0];\n        int length = pattern.length();\n\n        char c = pattern.charAt(i);\n        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n            \n            \n            buf.append(c);\n\n            while (i + 1 < length) {\n                char peek = pattern.charAt(i + 1);\n                if (peek == c) {\n                    buf.append(c);\n                    i++;\n                } else {\n                    break;\n                }\n            }\n        } else {\n            \n            buf.append('\\'');\n\n            boolean inLiteral = false;\n\n            for (; i < length; i++) {\n                c = pattern.charAt(i);\n\n                if (c == '\\'') {\n                    if (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n                        \n                        i++;\n                        buf.append(c);\n                    } else {\n                        inLiteral = !inLiteral;\n                    }\n                } else if (!inLiteral &&\n                         (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\n                    i--;\n                    break;\n                } else {\n                    buf.append(c);\n                }\n            }\n        }\n\n        indexRef[0] = i;\n        return buf.toString();\n    }\n\n    \n    protected NumberRule selectNumberRule(int field, int padding) {\n        switch (padding) {\n        case 1:\n            return new UnpaddedNumberField(field);\n        case 2:\n            return new TwoDigitNumberField(field);\n        default:\n            return new PaddedNumberField(field, padding);\n        }\n    }\n\n    \n    \n    \n    @Override\n    public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n        if (obj instanceof Date) {\n            return format((Date) obj, toAppendTo);\n        } else if (obj instanceof Calendar) {\n            return format((Calendar) obj, toAppendTo);\n        } else if (obj instanceof Long) {\n            return format(((Long) obj).longValue(), toAppendTo);\n        } else {\n            throw new IllegalArgumentException(\"Unknown class: \" +\n                (obj == null ? \"<null>\" : obj.getClass().getName()));\n        }\n    }\n\n    \n    public String format(long millis) {\n        return format(new Date(millis));\n    }\n\n    \n    public String format(Date date) {\n        Calendar c = new GregorianCalendar(mTimeZone);\n        c.setTime(date);\n        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n    }\n\n    \n    public String format(Calendar calendar) {\n        return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();\n    }\n\n    \n    public StringBuffer format(long millis, StringBuffer buf) {\n        return format(new Date(millis), buf);\n    }\n\n    \n    public StringBuffer format(Date date, StringBuffer buf) {\n        Calendar c = new GregorianCalendar(mTimeZone);\n        c.setTime(date);\n        return applyRules(c, buf);\n    }\n\n    \n    public StringBuffer format(Calendar calendar, StringBuffer buf) {\n        if (mTimeZoneForced) {\n            calendar = (Calendar) calendar.clone();\n            calendar.setTimeZone(mTimeZone);\n        }\n        return applyRules(calendar, buf);\n    }\n\n    \n    protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\n        Rule[] rules = mRules;\n        int len = mRules.length;\n        for (int i = 0; i < len; i++) {\n            rules[i].appendTo(buf, calendar);\n        }\n        return buf;\n    }\n\n    \n    \n    \n    @Override\n    public Object parseObject(String source, ParsePosition pos) {\n        pos.setIndex(0);\n        pos.setErrorIndex(0);\n        return null;\n    }\n    \n    \n    \n    \n    public String getPattern() {\n        return mPattern;\n    }\n\n    \n    public TimeZone getTimeZone() {\n        return mTimeZone;\n    }\n\n    \n    public boolean getTimeZoneOverridesCalendar() {\n        return mTimeZoneForced;\n    }\n\n    \n    public Locale getLocale() {\n        return mLocale;\n    }\n\n    \n    public int getMaxLengthEstimate() {\n        return mMaxLengthEstimate;\n    }\n\n    \n    \n    \n    @Override\n    public boolean equals(Object obj) {\n        if (obj instanceof FastDateFormat == false) {\n            return false;\n        }\n        FastDateFormat other = (FastDateFormat) obj;\n        if (\n            (mPattern == other.mPattern || mPattern.equals(other.mPattern)) &&\n            (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) &&\n            (mLocale == other.mLocale || mLocale.equals(other.mLocale)) &&\n            (mTimeZoneForced == other.mTimeZoneForced) &&\n            (mLocaleForced == other.mLocaleForced)\n            ) {\n            return true;\n        }\n        return false;\n    }\n\n    \n    @Override\n    public int hashCode() {\n        int total = 0;\n        total += mPattern.hashCode();\n        total += mTimeZone.hashCode();\n        total += (mTimeZoneForced ? 1 : 0);\n        total += mLocale.hashCode();\n        total += (mLocaleForced ? 1 : 0);\n        return total;\n    }\n\n    \n    @Override\n    public String toString() {\n        return \"FastDateFormat[\" + mPattern + \"]\";\n    }\n\n    \n    \n    \n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        init();\n    }\n    \n    \n    \n    \n    private interface Rule { int estimateLength(); void appendTo(StringBuffer buffer, Calendar calendar); } private interface NumberRule extends Rule {\n        \n        void appendTo(StringBuffer buffer, int value);\n    }\n\n    \n    private static class CharacterLiteral implements Rule { private final char mValue; CharacterLiteral(char value) {\n            mValue = value;\n        }\n\n        \n        public int estimateLength() {\n            return 1;\n        }\n\n        \n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            buffer.append(mValue);\n        }\n    }\n\n    \n    private static class StringLiteral implements Rule { private final String mValue; StringLiteral(String value) {\n            mValue = value;\n        }\n\n        \n        public int estimateLength() {\n            return mValue.length();\n        }\n\n        \n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            buffer.append(mValue);\n        }\n    }\n\n    \n    private static class TextField implements Rule { private final int mField; private final String[] mValues; TextField(int field, String[] values) {\n            mField = field;\n            mValues = values;\n        }\n\n        \n        public int estimateLength() {\n            int max = 0;\n            for (int i=mValues.length; --i >= 0; ) {\n                int len = mValues[i].length();\n                if (len > max) {\n                    max = len;\n                }\n            }\n            return max;\n        }\n\n        \n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            buffer.append(mValues[calendar.get(mField)]);\n        }\n    }\n\n    \n    private static class UnpaddedNumberField implements NumberRule { private final int mField; UnpaddedNumberField(int field) {\n            mField = field;\n        }\n\n        \n        public int estimateLength() {\n            return 4;\n        }\n\n        \n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(mField));\n        }\n\n        \n        public final void appendTo(StringBuffer buffer, int value) {\n            if (value < 10) {\n                buffer.append((char)(value + '0'));\n            } else if (value < 100) {\n                buffer.append((char)(value / 10 + '0'));\n                buffer.append((char)(value % 10 + '0'));\n            } else {\n                buffer.append(Integer.toString(value));\n            }\n        }\n    }\n\n    \n    private static class UnpaddedMonthField implements NumberRule { static final UnpaddedMonthField INSTANCE = new UnpaddedMonthField(); UnpaddedMonthField() {\n            super();\n        }\n\n        \n        public int estimateLength() {\n            return 2;\n        }\n\n        \n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n        }\n\n        \n        public final void appendTo(StringBuffer buffer, int value) {\n            if (value < 10) {\n                buffer.append((char)(value + '0'));\n            } else {\n                buffer.append((char)(value / 10 + '0'));\n                buffer.append((char)(value % 10 + '0'));\n            }\n        }\n    }\n\n    \n    private static class PaddedNumberField implements NumberRule { private final int mField; private final int mSize; PaddedNumberField(int field, int size) {\n            if (size < 3) {\n                \n                throw new IllegalArgumentException();\n            }\n            mField = field;\n            mSize = size;\n        }\n\n        \n        public int estimateLength() {\n            return 4;\n        }\n\n        \n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(mField));\n        }\n\n        \n        public final void appendTo(StringBuffer buffer, int value) {\n            if (value < 100) {\n                for (int i = mSize; --i >= 2; ) {\n                    buffer.append('0');\n                }\n                buffer.append((char)(value / 10 + '0'));\n                buffer.append((char)(value % 10 + '0'));\n            } else {\n                int digits;\n                if (value < 1000) {\n                    digits = 3;\n                } else {\n                    Validate.isTrue(value > -1, \"Negative values should not be possible\", value);\n                    digits = Integer.toString(value).length();\n                }\n                for (int i = mSize; --i >= digits; ) {\n                    buffer.append('0');\n                }\n                buffer.append(Integer.toString(value));\n            }\n        }\n    }\n\n    \n    private static class TwoDigitNumberField implements NumberRule { private final int mField; TwoDigitNumberField(int field) {\n            mField = field;\n        }\n\n        \n        public int estimateLength() {\n            return 2;\n        }\n\n        \n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(mField));\n        }\n\n        \n        public final void appendTo(StringBuffer buffer, int value) {\n            if (value < 100) {\n                buffer.append((char)(value / 10 + '0'));\n                buffer.append((char)(value % 10 + '0'));\n            } else {\n                buffer.append(Integer.toString(value));\n            }\n        }\n    }\n\n    \n    private static class TwoDigitYearField implements NumberRule { static final TwoDigitYearField INSTANCE = new TwoDigitYearField(); TwoDigitYearField() {\n            super();\n        }\n\n        \n        public int estimateLength() {\n            return 2;\n        }\n\n        \n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(Calendar.YEAR) % 100);\n        }\n\n        \n        public final void appendTo(StringBuffer buffer, int value) {\n            buffer.append((char)(value / 10 + '0'));\n            buffer.append((char)(value % 10 + '0'));\n        }\n    }\n\n    \n    private static class TwoDigitMonthField implements NumberRule { static final TwoDigitMonthField INSTANCE = new TwoDigitMonthField(); TwoDigitMonthField() {\n            super();\n        }\n\n        \n        public int estimateLength() {\n            return 2;\n        }\n\n        \n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n        }\n\n        \n        public final void appendTo(StringBuffer buffer, int value) {\n            buffer.append((char)(value / 10 + '0'));\n            buffer.append((char)(value % 10 + '0'));\n        }\n    }\n\n    \n    private static class TwelveHourField implements NumberRule { private final NumberRule mRule; TwelveHourField(NumberRule rule) {\n            mRule = rule;\n        }\n\n        \n        public int estimateLength() {\n            return mRule.estimateLength();\n        }\n\n        \n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            int value = calendar.get(Calendar.HOUR);\n            if (value == 0) {\n                value = calendar.getLeastMaximum(Calendar.HOUR) + 1;\n            }\n            mRule.appendTo(buffer, value);\n        }\n\n        \n        public void appendTo(StringBuffer buffer, int value) {\n            mRule.appendTo(buffer, value);\n        }\n    }\n\n    \n    private static class TwentyFourHourField implements NumberRule { private final NumberRule mRule; TwentyFourHourField(NumberRule rule) {\n            mRule = rule;\n        }\n\n        \n        public int estimateLength() {\n            return mRule.estimateLength();\n        }\n\n        \n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            int value = calendar.get(Calendar.HOUR_OF_DAY);\n            if (value == 0) {\n                value = calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1;\n            }\n            mRule.appendTo(buffer, value);\n        }\n\n        \n        public void appendTo(StringBuffer buffer, int value) {\n            mRule.appendTo(buffer, value);\n        }\n    }\n\n    \n    private static class TimeZoneNameRule implements Rule { private final TimeZone mTimeZone; private final boolean mTimeZoneForced; private final Locale mLocale; private final int mStyle; private final String mStandard; private final String mDaylight; TimeZoneNameRule(TimeZone timeZone, boolean timeZoneForced, Locale locale, int style) {\n            mTimeZone = timeZone;\n            mTimeZoneForced = timeZoneForced;\n            mLocale = locale;\n            mStyle = style;\n\n            if (timeZoneForced) {\n                mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n                mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);\n            } else {\n                mStandard = null;\n                mDaylight = null;\n            }\n        }\n\n        \n        public int estimateLength() {\n            if (mTimeZoneForced) {\n                return Math.max(mStandard.length(), mDaylight.length());\n            } else if (mStyle == TimeZone.SHORT) {\n                return 4;\n            } else {\n                return 40;\n            }\n        }\n\n        \n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            if (mTimeZoneForced) {\n                if (mTimeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {\n                    buffer.append(mDaylight);\n                } else {\n                    buffer.append(mStandard);\n                }\n            } else {\n                TimeZone timeZone = calendar.getTimeZone();\n                if (timeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {\n                    buffer.append(getTimeZoneDisplay(timeZone, true, mStyle, mLocale));\n                } else {\n                    buffer.append(getTimeZoneDisplay(timeZone, false, mStyle, mLocale));\n                }\n            }\n        }\n    }\n\n    \n    private static class TimeZoneNumberRule implements Rule { static final TimeZoneNumberRule INSTANCE_COLON = new TimeZoneNumberRule(true); static final TimeZoneNumberRule INSTANCE_NO_COLON = new TimeZoneNumberRule(false); final boolean mColon; TimeZoneNumberRule(boolean colon) {\n            mColon = colon;\n        }\n\n        \n        public int estimateLength() {\n            return 5;\n        }\n\n        \n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);\n            \n            if (offset < 0) {\n                buffer.append('-');\n                offset = -offset;\n            } else {\n                buffer.append('+');\n            }\n            \n            int hours = offset / (60 * 60 * 1000);\n            buffer.append((char)(hours / 10 + '0'));\n            buffer.append((char)(hours % 10 + '0'));\n            \n            if (mColon) {\n                buffer.append(':');\n            }\n            \n            int minutes = offset / (60 * 1000) - 60 * hours;\n            buffer.append((char)(minutes / 10 + '0'));\n            buffer.append((char)(minutes % 10 + '0'));\n        }            \n    }\n\n    \n    \n    private static class TimeZoneDisplayKey { private final TimeZone mTimeZone; private final int mStyle; private final Locale mLocale; TimeZoneDisplayKey(TimeZone timeZone, boolean daylight, int style, Locale locale) {\n            mTimeZone = timeZone;\n            if (daylight) {\n                style |= 0x80000000;\n            }\n            mStyle = style;\n            mLocale = locale;\n        }\n\n        \n        @Override\n        public int hashCode() {\n            return mStyle * 31 + mLocale.hashCode();\n        }\n\n        \n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj instanceof TimeZoneDisplayKey) {\n                TimeZoneDisplayKey other = (TimeZoneDisplayKey)obj;\n                return\n                    mTimeZone.equals(other.mTimeZone) &&\n                    mStyle == other.mStyle &&\n                    mLocale.equals(other.mLocale);\n            }\n            return false;\n        }\n    }\n\n    \n    \n    private static class Pair { private final Object mObj1; private final Object mObj2; public Pair(Object obj1, Object obj2) {\n            mObj1 = obj1;\n            mObj2 = obj2;\n        }\n\n        \n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n\n            if (!(obj instanceof Pair)) {\n                return false;\n            }\n\n            Pair key = (Pair)obj;\n\n            return\n                (mObj1 == null ?\n                 key.mObj1 == null : mObj1.equals(key.mObj1)) &&\n                (mObj2 == null ?\n                 key.mObj2 == null : mObj2.equals(key.mObj2));\n        }\n\n        \n        @Override\n        public int hashCode() {\n            return\n                (mObj1 == null ? 0 : mObj1.hashCode()) +\n                (mObj2 == null ? 0 : mObj2.hashCode());\n        }\n\n        \n        @Override\n        public String toString() {\n            return \"[\" + mObj1 + ':' + mObj2 + ']';\n        }\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.lang3.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.text.DateFormat;\nimport java.text.DateFormatSymbols;\nimport java.text.FieldPosition;\nimport java.text.Format;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.TimeZone;\n\nimport org.apache.commons.lang3.Validate;\n\n\npublic class FastDateFormat extends Format { private static final long serialVersionUID = 1L; public static final int FULL = DateFormat.FULL; public static final int LONG = DateFormat.LONG; public static final int MEDIUM = DateFormat.MEDIUM; public static final int SHORT = DateFormat.SHORT; private static String cDefaultPattern; private static final Map<FastDateFormat, FastDateFormat> cInstanceCache = new HashMap<FastDateFormat, FastDateFormat>(7); private static final Map<Object, FastDateFormat> cDateInstanceCache = new HashMap<Object, FastDateFormat>(7); private static final Map<Object, FastDateFormat> cTimeInstanceCache = new HashMap<Object, FastDateFormat>(7); private static final Map<Object, FastDateFormat> cDateTimeInstanceCache = new HashMap<Object, FastDateFormat>(7); private static final Map<Object, String> cTimeZoneDisplayCache = new HashMap<Object, String>(7); private final String mPattern; private final TimeZone mTimeZone; private final boolean mTimeZoneForced; private final Locale mLocale; private final boolean mLocaleForced; private transient Rule[] mRules; private transient int mMaxLengthEstimate; public static FastDateFormat getInstance() {\n        return getInstance(getDefaultPattern(), null, null);\n    }\n\n    \n    public static FastDateFormat getInstance(String pattern) {\n        return getInstance(pattern, null, null);\n    }\n\n    \n    public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {\n        return getInstance(pattern, timeZone, null);\n    }\n\n    \n    public static FastDateFormat getInstance(String pattern, Locale locale) {\n        return getInstance(pattern, null, locale);\n    }\n\n    \n    public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {\n        FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);\n        FastDateFormat format = cInstanceCache.get(emptyFormat);\n        if (format == null) {\n            format = emptyFormat;\n            format.init();  \n            cInstanceCache.put(format, format);  \n        }\n        return format;\n    }\n\n    \n    \n    public static FastDateFormat getDateInstance(int style) {\n        return getDateInstance(style, null, null);\n    }\n\n    \n    public static FastDateFormat getDateInstance(int style, Locale locale) {\n        return getDateInstance(style, null, locale);\n    }\n\n    \n    public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {\n        return getDateInstance(style, timeZone, null);\n    }\n    \n    public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {\n        Object key = Integer.valueOf(style);\n        if (timeZone != null) {\n            key = new Pair(key, timeZone);\n        }\n\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n\n        key = new Pair(key, locale);\n\n        FastDateFormat format = cDateInstanceCache.get(key);\n        if (format == null) {\n            try {\n                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);\n                String pattern = formatter.toPattern();\n                format = getInstance(pattern, timeZone, locale);\n                cDateInstanceCache.put(key, format);\n                \n            } catch (ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date pattern for locale: \" + locale);\n            }\n        }\n        return format;\n    }\n\n    \n    \n    public static FastDateFormat getTimeInstance(int style) {\n        return getTimeInstance(style, null, null);\n    }\n\n    \n    public static FastDateFormat getTimeInstance(int style, Locale locale) {\n        return getTimeInstance(style, null, locale);\n    }\n    \n    \n    public static FastDateFormat getTimeInstance(int style, TimeZone timeZone) {\n        return getTimeInstance(style, timeZone, null);\n    }\n    \n    \n    public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {\n        Object key = Integer.valueOf(style);\n        if (timeZone != null) {\n            key = new Pair(key, timeZone);\n        }\n        if (locale != null) {\n            key = new Pair(key, locale);\n        }\n\n        FastDateFormat format = cTimeInstanceCache.get(key);\n        if (format == null) {\n            if (locale == null) {\n                locale = Locale.getDefault();\n            }\n\n            try {\n                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getTimeInstance(style, locale);\n                String pattern = formatter.toPattern();\n                format = getInstance(pattern, timeZone, locale);\n                cTimeInstanceCache.put(key, format);\n            \n            } catch (ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date pattern for locale: \" + locale);\n            }\n        }\n        return format;\n    }\n\n    \n    \n    public static FastDateFormat getDateTimeInstance( int dateStyle, int timeStyle) {\n        return getDateTimeInstance(dateStyle, timeStyle, null, null);\n    }\n    \n    \n    public static FastDateFormat getDateTimeInstance( int dateStyle, int timeStyle, Locale locale) {\n        return getDateTimeInstance(dateStyle, timeStyle, null, locale);\n    }\n    \n    \n    public static FastDateFormat getDateTimeInstance( int dateStyle, int timeStyle, TimeZone timeZone) {\n        return getDateTimeInstance(dateStyle, timeStyle, timeZone, null);\n    }    \n    \n    public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) {\n\n        Object key = new Pair(Integer.valueOf(dateStyle), Integer.valueOf(timeStyle));\n        if (timeZone != null) {\n            key = new Pair(key, timeZone);\n        }\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        key = new Pair(key, locale);\n\n        FastDateFormat format = cDateTimeInstanceCache.get(key);\n        if (format == null) {\n            try {\n                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,\n                        locale);\n                String pattern = formatter.toPattern();\n                format = getInstance(pattern, timeZone, locale);\n                cDateTimeInstanceCache.put(key, format);\n\n            } catch (ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return format;\n    }\n\n    \n    \n    static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {\n        Object key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n        String value = cTimeZoneDisplayCache.get(key);\n        if (value == null) {\n            \n            value = tz.getDisplayName(daylight, style, locale);\n            cTimeZoneDisplayCache.put(key, value);\n        }\n        return value;\n    }\n\n    \n    private static synchronized String getDefaultPattern() {\n        if (cDefaultPattern == null) {\n            cDefaultPattern = new SimpleDateFormat().toPattern();\n        }\n        return cDefaultPattern;\n    }\n\n    \n    \n    \n    protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {\n        super();\n        if (pattern == null) {\n            throw new IllegalArgumentException(\"The pattern must not be null\");\n        }\n        mPattern = pattern;\n        \n        mTimeZoneForced = (timeZone != null);\n        if (timeZone == null) {\n            timeZone = TimeZone.getDefault();\n        }\n        mTimeZone = timeZone;\n        \n        mLocaleForced = (locale != null);\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        mLocale = locale;\n    }\n\n    \n    protected void init() {\n        List<Rule> rulesList = parsePattern();\n        mRules = rulesList.toArray(new Rule[rulesList.size()]);\n\n        int len = 0;\n        for (int i=mRules.length; --i >= 0; ) {\n            len += mRules[i].estimateLength();\n        }\n\n        mMaxLengthEstimate = len;\n    }\n\n    \n    \n    \n    protected List<Rule> parsePattern() {\n        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n        List<Rule> rules = new ArrayList<Rule>();\n\n        String[] ERAs = symbols.getEras();\n        String[] months = symbols.getMonths();\n        String[] shortMonths = symbols.getShortMonths();\n        String[] weekdays = symbols.getWeekdays();\n        String[] shortWeekdays = symbols.getShortWeekdays();\n        String[] AmPmStrings = symbols.getAmPmStrings();\n\n        int length = mPattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i = 0; i < length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(mPattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n\n            Rule rule;\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': \n                rule = new TextField(Calendar.ERA, ERAs);\n                break;\n            case 'y': \n                if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }\n                break;\n            case 'M': \n                if (tokenLen >= 4) {\n                    rule = new TextField(Calendar.MONTH, months);\n                } else if (tokenLen == 3) {\n                    rule = new TextField(Calendar.MONTH, shortMonths);\n                } else if (tokenLen == 2) {\n                    rule = TwoDigitMonthField.INSTANCE;\n                } else {\n                    rule = UnpaddedMonthField.INSTANCE;\n                }\n                break;\n            case 'd': \n                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n                break;\n            case 'h': \n                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n                break;\n            case 'H': \n                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n                break;\n            case 'm': \n                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n                break;\n            case 's': \n                rule = selectNumberRule(Calendar.SECOND, tokenLen);\n                break;\n            case 'S': \n                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n                break;\n            case 'E': \n                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n                break;\n            case 'D': \n                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n                break;\n            case 'F': \n                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n                break;\n            case 'w': \n                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n                break;\n            case 'W': \n                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n                break;\n            case 'a': \n                rule = new TextField(Calendar.AM_PM, AmPmStrings);\n                break;\n            case 'k': \n                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n                break;\n            case 'K': \n                rule = selectNumberRule(Calendar.HOUR, tokenLen);\n                break;\n            case 'z': \n                if (tokenLen >= 4) {\n                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.LONG);\n                } else {\n                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.SHORT);\n                }\n                break;\n            case 'Z': \n                if (tokenLen == 1) {\n                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n                } else {\n                    rule = TimeZoneNumberRule.INSTANCE_COLON;\n                }\n                break;\n            case '\\'': \n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    rule = new CharacterLiteral(sub.charAt(0));\n                } else {\n                    rule = new StringLiteral(sub);\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n            }\n\n            rules.add(rule);\n        }\n\n        return rules;\n    }\n\n    \n    protected String parseToken(String pattern, int[] indexRef) {\n        StringBuilder buf = new StringBuilder();\n\n        int i = indexRef[0];\n        int length = pattern.length();\n\n        char c = pattern.charAt(i);\n        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n            \n            \n            buf.append(c);\n\n            while (i + 1 < length) {\n                char peek = pattern.charAt(i + 1);\n                if (peek == c) {\n                    buf.append(c);\n                    i++;\n                } else {\n                    break;\n                }\n            }\n        } else {\n            \n            buf.append('\\'');\n\n            boolean inLiteral = false;\n\n            for (; i < length; i++) {\n                c = pattern.charAt(i);\n\n                if (c == '\\'') {\n                    if (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n                        \n                        i++;\n                        buf.append(c);\n                    } else {\n                        inLiteral = !inLiteral;\n                    }\n                } else if (!inLiteral &&\n                         (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\n                    i--;\n                    break;\n                } else {\n                    buf.append(c);\n                }\n            }\n        }\n\n        indexRef[0] = i;\n        return buf.toString();\n    }\n\n    \n    protected NumberRule selectNumberRule(int field, int padding) {\n        switch (padding) {\n        case 1:\n            return new UnpaddedNumberField(field);\n        case 2:\n            return new TwoDigitNumberField(field);\n        default:\n            return new PaddedNumberField(field, padding);\n        }\n    }\n\n    \n    \n    \n    @Override\n    public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n        if (obj instanceof Date) {\n            return format((Date) obj, toAppendTo);\n        } else if (obj instanceof Calendar) {\n            return format((Calendar) obj, toAppendTo);\n        } else if (obj instanceof Long) {\n            return format(((Long) obj).longValue(), toAppendTo);\n        } else {\n            throw new IllegalArgumentException(\"Unknown class: \" +\n                (obj == null ? \"<null>\" : obj.getClass().getName()));\n        }\n    }\n\n    \n    public String format(long millis) {\n        return format(new Date(millis));\n    }\n\n    \n    public String format(Date date) {\n        Calendar c = new GregorianCalendar(mTimeZone);\n        c.setTime(date);\n        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n    }\n\n    \n    public String format(Calendar calendar) {\n        return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();\n    }\n\n    \n    public StringBuffer format(long millis, StringBuffer buf) {\n        return format(new Date(millis), buf);\n    }\n\n    \n    public StringBuffer format(Date date, StringBuffer buf) {\n        Calendar c = new GregorianCalendar(mTimeZone);\n        c.setTime(date);\n        return applyRules(c, buf);\n    }\n\n    \n    public StringBuffer format(Calendar calendar, StringBuffer buf) {\n        if (mTimeZoneForced) {\n            calendar.getTime(); \n            calendar = (Calendar) calendar.clone();\n            calendar.setTimeZone(mTimeZone);\n        }\n        return applyRules(calendar, buf);\n    }\n\n    \n    protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\n        Rule[] rules = mRules;\n        int len = mRules.length;\n        for (int i = 0; i < len; i++) {\n            rules[i].appendTo(buf, calendar);\n        }\n        return buf;\n    }\n\n    \n    \n    \n    @Override\n    public Object parseObject(String source, ParsePosition pos) {\n        pos.setIndex(0);\n        pos.setErrorIndex(0);\n        return null;\n    }\n    \n    \n    \n    \n    public String getPattern() {\n        return mPattern;\n    }\n\n    \n    public TimeZone getTimeZone() {\n        return mTimeZone;\n    }\n\n    \n    public boolean getTimeZoneOverridesCalendar() {\n        return mTimeZoneForced;\n    }\n\n    \n    public Locale getLocale() {\n        return mLocale;\n    }\n\n    \n    public int getMaxLengthEstimate() {\n        return mMaxLengthEstimate;\n    }\n\n    \n    \n    \n    @Override\n    public boolean equals(Object obj) {\n        if (obj instanceof FastDateFormat == false) {\n            return false;\n        }\n        FastDateFormat other = (FastDateFormat) obj;\n        if (\n            (mPattern == other.mPattern || mPattern.equals(other.mPattern)) &&\n            (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) &&\n            (mLocale == other.mLocale || mLocale.equals(other.mLocale)) &&\n            (mTimeZoneForced == other.mTimeZoneForced) &&\n            (mLocaleForced == other.mLocaleForced)\n            ) {\n            return true;\n        }\n        return false;\n    }\n\n    \n    @Override\n    public int hashCode() {\n        int total = 0;\n        total += mPattern.hashCode();\n        total += mTimeZone.hashCode();\n        total += (mTimeZoneForced ? 1 : 0);\n        total += mLocale.hashCode();\n        total += (mLocaleForced ? 1 : 0);\n        return total;\n    }\n\n    \n    @Override\n    public String toString() {\n        return \"FastDateFormat[\" + mPattern + \"]\";\n    }\n\n    \n    \n    \n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        init();\n    }\n    \n    \n    \n    \n    private interface Rule { int estimateLength(); void appendTo(StringBuffer buffer, Calendar calendar); } private interface NumberRule extends Rule {\n        \n        void appendTo(StringBuffer buffer, int value);\n    }\n\n    \n    private static class CharacterLiteral implements Rule { private final char mValue; CharacterLiteral(char value) {\n            mValue = value;\n        }\n\n        \n        public int estimateLength() {\n            return 1;\n        }\n\n        \n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            buffer.append(mValue);\n        }\n    }\n\n    \n    private static class StringLiteral implements Rule { private final String mValue; StringLiteral(String value) {\n            mValue = value;\n        }\n\n        \n        public int estimateLength() {\n            return mValue.length();\n        }\n\n        \n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            buffer.append(mValue);\n        }\n    }\n\n    \n    private static class TextField implements Rule { private final int mField; private final String[] mValues; TextField(int field, String[] values) {\n            mField = field;\n            mValues = values;\n        }\n\n        \n        public int estimateLength() {\n            int max = 0;\n            for (int i=mValues.length; --i >= 0; ) {\n                int len = mValues[i].length();\n                if (len > max) {\n                    max = len;\n                }\n            }\n            return max;\n        }\n\n        \n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            buffer.append(mValues[calendar.get(mField)]);\n        }\n    }\n\n    \n    private static class UnpaddedNumberField implements NumberRule { private final int mField; UnpaddedNumberField(int field) {\n            mField = field;\n        }\n\n        \n        public int estimateLength() {\n            return 4;\n        }\n\n        \n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(mField));\n        }\n\n        \n        public final void appendTo(StringBuffer buffer, int value) {\n            if (value < 10) {\n                buffer.append((char)(value + '0'));\n            } else if (value < 100) {\n                buffer.append((char)(value / 10 + '0'));\n                buffer.append((char)(value % 10 + '0'));\n            } else {\n                buffer.append(Integer.toString(value));\n            }\n        }\n    }\n\n    \n    private static class UnpaddedMonthField implements NumberRule { static final UnpaddedMonthField INSTANCE = new UnpaddedMonthField(); UnpaddedMonthField() {\n            super();\n        }\n\n        \n        public int estimateLength() {\n            return 2;\n        }\n\n        \n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n        }\n\n        \n        public final void appendTo(StringBuffer buffer, int value) {\n            if (value < 10) {\n                buffer.append((char)(value + '0'));\n            } else {\n                buffer.append((char)(value / 10 + '0'));\n                buffer.append((char)(value % 10 + '0'));\n            }\n        }\n    }\n\n    \n    private static class PaddedNumberField implements NumberRule { private final int mField; private final int mSize; PaddedNumberField(int field, int size) {\n            if (size < 3) {\n                \n                throw new IllegalArgumentException();\n            }\n            mField = field;\n            mSize = size;\n        }\n\n        \n        public int estimateLength() {\n            return 4;\n        }\n\n        \n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(mField));\n        }\n\n        \n        public final void appendTo(StringBuffer buffer, int value) {\n            if (value < 100) {\n                for (int i = mSize; --i >= 2; ) {\n                    buffer.append('0');\n                }\n                buffer.append((char)(value / 10 + '0'));\n                buffer.append((char)(value % 10 + '0'));\n            } else {\n                int digits;\n                if (value < 1000) {\n                    digits = 3;\n                } else {\n                    Validate.isTrue(value > -1, \"Negative values should not be possible\", value);\n                    digits = Integer.toString(value).length();\n                }\n                for (int i = mSize; --i >= digits; ) {\n                    buffer.append('0');\n                }\n                buffer.append(Integer.toString(value));\n            }\n        }\n    }\n\n    \n    private static class TwoDigitNumberField implements NumberRule { private final int mField; TwoDigitNumberField(int field) {\n            mField = field;\n        }\n\n        \n        public int estimateLength() {\n            return 2;\n        }\n\n        \n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(mField));\n        }\n\n        \n        public final void appendTo(StringBuffer buffer, int value) {\n            if (value < 100) {\n                buffer.append((char)(value / 10 + '0'));\n                buffer.append((char)(value % 10 + '0'));\n            } else {\n                buffer.append(Integer.toString(value));\n            }\n        }\n    }\n\n    \n    private static class TwoDigitYearField implements NumberRule { static final TwoDigitYearField INSTANCE = new TwoDigitYearField(); TwoDigitYearField() {\n            super();\n        }\n\n        \n        public int estimateLength() {\n            return 2;\n        }\n\n        \n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(Calendar.YEAR) % 100);\n        }\n\n        \n        public final void appendTo(StringBuffer buffer, int value) {\n            buffer.append((char)(value / 10 + '0'));\n            buffer.append((char)(value % 10 + '0'));\n        }\n    }\n\n    \n    private static class TwoDigitMonthField implements NumberRule { static final TwoDigitMonthField INSTANCE = new TwoDigitMonthField(); TwoDigitMonthField() {\n            super();\n        }\n\n        \n        public int estimateLength() {\n            return 2;\n        }\n\n        \n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n        }\n\n        \n        public final void appendTo(StringBuffer buffer, int value) {\n            buffer.append((char)(value / 10 + '0'));\n            buffer.append((char)(value % 10 + '0'));\n        }\n    }\n\n    \n    private static class TwelveHourField implements NumberRule { private final NumberRule mRule; TwelveHourField(NumberRule rule) {\n            mRule = rule;\n        }\n\n        \n        public int estimateLength() {\n            return mRule.estimateLength();\n        }\n\n        \n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            int value = calendar.get(Calendar.HOUR);\n            if (value == 0) {\n                value = calendar.getLeastMaximum(Calendar.HOUR) + 1;\n            }\n            mRule.appendTo(buffer, value);\n        }\n\n        \n        public void appendTo(StringBuffer buffer, int value) {\n            mRule.appendTo(buffer, value);\n        }\n    }\n\n    \n    private static class TwentyFourHourField implements NumberRule { private final NumberRule mRule; TwentyFourHourField(NumberRule rule) {\n            mRule = rule;\n        }\n\n        \n        public int estimateLength() {\n            return mRule.estimateLength();\n        }\n\n        \n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            int value = calendar.get(Calendar.HOUR_OF_DAY);\n            if (value == 0) {\n                value = calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1;\n            }\n            mRule.appendTo(buffer, value);\n        }\n\n        \n        public void appendTo(StringBuffer buffer, int value) {\n            mRule.appendTo(buffer, value);\n        }\n    }\n\n    \n    private static class TimeZoneNameRule implements Rule { private final TimeZone mTimeZone; private final boolean mTimeZoneForced; private final Locale mLocale; private final int mStyle; private final String mStandard; private final String mDaylight; TimeZoneNameRule(TimeZone timeZone, boolean timeZoneForced, Locale locale, int style) {\n            mTimeZone = timeZone;\n            mTimeZoneForced = timeZoneForced;\n            mLocale = locale;\n            mStyle = style;\n\n            if (timeZoneForced) {\n                mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n                mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);\n            } else {\n                mStandard = null;\n                mDaylight = null;\n            }\n        }\n\n        \n        public int estimateLength() {\n            if (mTimeZoneForced) {\n                return Math.max(mStandard.length(), mDaylight.length());\n            } else if (mStyle == TimeZone.SHORT) {\n                return 4;\n            } else {\n                return 40;\n            }\n        }\n\n        \n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            if (mTimeZoneForced) {\n                if (mTimeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {\n                    buffer.append(mDaylight);\n                } else {\n                    buffer.append(mStandard);\n                }\n            } else {\n                TimeZone timeZone = calendar.getTimeZone();\n                if (timeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {\n                    buffer.append(getTimeZoneDisplay(timeZone, true, mStyle, mLocale));\n                } else {\n                    buffer.append(getTimeZoneDisplay(timeZone, false, mStyle, mLocale));\n                }\n            }\n        }\n    }\n\n    \n    private static class TimeZoneNumberRule implements Rule { static final TimeZoneNumberRule INSTANCE_COLON = new TimeZoneNumberRule(true); static final TimeZoneNumberRule INSTANCE_NO_COLON = new TimeZoneNumberRule(false); final boolean mColon; TimeZoneNumberRule(boolean colon) {\n            mColon = colon;\n        }\n\n        \n        public int estimateLength() {\n            return 5;\n        }\n\n        \n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);\n            \n            if (offset < 0) {\n                buffer.append('-');\n                offset = -offset;\n            } else {\n                buffer.append('+');\n            }\n            \n            int hours = offset / (60 * 60 * 1000);\n            buffer.append((char)(hours / 10 + '0'));\n            buffer.append((char)(hours % 10 + '0'));\n            \n            if (mColon) {\n                buffer.append(':');\n            }\n            \n            int minutes = offset / (60 * 1000) - 60 * hours;\n            buffer.append((char)(minutes / 10 + '0'));\n            buffer.append((char)(minutes % 10 + '0'));\n        }            \n    }\n\n    \n    \n    private static class TimeZoneDisplayKey { private final TimeZone mTimeZone; private final int mStyle; private final Locale mLocale; TimeZoneDisplayKey(TimeZone timeZone, boolean daylight, int style, Locale locale) {\n            mTimeZone = timeZone;\n            if (daylight) {\n                style |= 0x80000000;\n            }\n            mStyle = style;\n            mLocale = locale;\n        }\n\n        \n        @Override\n        public int hashCode() {\n            return mStyle * 31 + mLocale.hashCode();\n        }\n\n        \n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj instanceof TimeZoneDisplayKey) {\n                TimeZoneDisplayKey other = (TimeZoneDisplayKey)obj;\n                return\n                    mTimeZone.equals(other.mTimeZone) &&\n                    mStyle == other.mStyle &&\n                    mLocale.equals(other.mLocale);\n            }\n            return false;\n        }\n    }\n\n    \n    \n    private static class Pair { private final Object mObj1; private final Object mObj2; public Pair(Object obj1, Object obj2) {\n            mObj1 = obj1;\n            mObj2 = obj2;\n        }\n\n        \n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n\n            if (!(obj instanceof Pair)) {\n                return false;\n            }\n\n            Pair key = (Pair)obj;\n\n            return\n                (mObj1 == null ?\n                 key.mObj1 == null : mObj1.equals(key.mObj1)) &&\n                (mObj2 == null ?\n                 key.mObj2 == null : mObj2.equals(key.mObj2));\n        }\n\n        \n        @Override\n        public int hashCode() {\n            return\n                (mObj1 == null ? 0 : mObj1.hashCode()) +\n                (mObj2 == null ? 0 : mObj2.hashCode());\n        }\n\n        \n        @Override\n        public String toString() {\n            return \"[\" + mObj1 + ':' + mObj2 + ']';\n        }\n    }\n\n}\n",
      "buggy_signatures": [
        "public static FastDateFormat getInstance(String pattern)",
        "public static FastDateFormat getInstance(String pattern, TimeZone timeZone)",
        "public static FastDateFormat getInstance(String pattern, Locale locale)",
        "public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale)",
        "public static FastDateFormat getDateInstance(int style)",
        "public static FastDateFormat getDateInstance(int style, Locale locale)",
        "public static FastDateFormat getDateInstance(int style, TimeZone timeZone)",
        "public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale)",
        "public static FastDateFormat getTimeInstance(int style)",
        "public static FastDateFormat getTimeInstance(int style, Locale locale)",
        "public static FastDateFormat getTimeInstance(int style, TimeZone timeZone)",
        "public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale)",
        "public static FastDateFormat getDateTimeInstance( int dateStyle, int timeStyle)",
        "public static FastDateFormat getDateTimeInstance( int dateStyle, int timeStyle, Locale locale)",
        "public static FastDateFormat getDateTimeInstance( int dateStyle, int timeStyle, TimeZone timeZone)",
        "public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone, Locale locale)",
        "static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale)",
        "private static synchronized String getDefaultPattern()",
        "protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale)",
        "protected void init()",
        "protected List<Rule> parsePattern()",
        "protected String parseToken(String pattern, int[] indexRef)",
        "protected NumberRule selectNumberRule(int field, int padding)",
        "public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos)",
        "public String format(long millis)",
        "public String format(Date date)",
        "public String format(Calendar calendar)",
        "public StringBuffer format(long millis, StringBuffer buf)",
        "public StringBuffer format(Date date, StringBuffer buf)",
        "public StringBuffer format(Calendar calendar, StringBuffer buf)",
        "protected StringBuffer applyRules(Calendar calendar, StringBuffer buf)",
        "public Object parseObject(String source, ParsePosition pos)",
        "public String getPattern()",
        "public TimeZone getTimeZone()",
        "public boolean getTimeZoneOverridesCalendar()",
        "public Locale getLocale()",
        "public int getMaxLengthEstimate()",
        "public boolean equals(Object obj)",
        "public int hashCode()",
        "public String toString()",
        "private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException",
        "private interface Rule { int estimateLength(); void appendTo(StringBuffer buffer, Calendar calendar); } private interface NumberRule extends Rule",
        "private static class CharacterLiteral implements Rule { private final char mValue; CharacterLiteral(char value)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "private static class StringLiteral implements Rule { private final String mValue; StringLiteral(String value)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "private static class TextField implements Rule { private final int mField; private final String[] mValues; TextField(int field, String[] values)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "private static class UnpaddedNumberField implements NumberRule { private final int mField; UnpaddedNumberField(int field)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public final void appendTo(StringBuffer buffer, int value)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public final void appendTo(StringBuffer buffer, int value)",
        "private static class PaddedNumberField implements NumberRule { private final int mField; private final int mSize; PaddedNumberField(int field, int size)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public final void appendTo(StringBuffer buffer, int value)",
        "private static class TwoDigitNumberField implements NumberRule { private final int mField; TwoDigitNumberField(int field)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public final void appendTo(StringBuffer buffer, int value)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public final void appendTo(StringBuffer buffer, int value)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public final void appendTo(StringBuffer buffer, int value)",
        "private static class TwelveHourField implements NumberRule { private final NumberRule mRule; TwelveHourField(NumberRule rule)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public void appendTo(StringBuffer buffer, int value)",
        "private static class TwentyFourHourField implements NumberRule { private final NumberRule mRule; TwentyFourHourField(NumberRule rule)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public void appendTo(StringBuffer buffer, int value)",
        "private static class TimeZoneNameRule implements Rule { private final TimeZone mTimeZone; private final boolean mTimeZoneForced; private final Locale mLocale; private final int mStyle; private final String mStandard; private final String mDaylight; TimeZoneNameRule(TimeZone timeZone, boolean timeZoneForced, Locale locale, int style)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "private static class TimeZoneDisplayKey { private final TimeZone mTimeZone; private final int mStyle; private final Locale mLocale; TimeZoneDisplayKey(TimeZone timeZone, boolean daylight, int style, Locale locale)",
        "public int hashCode()",
        "public boolean equals(Object obj)",
        "private static class Pair { private final Object mObj1; private final Object mObj2; public Pair(Object obj1, Object obj2)",
        "public boolean equals(Object obj)",
        "public int hashCode()",
        "public String toString()"
      ],
      "fixed_signatures": [
        "public static FastDateFormat getInstance(String pattern)",
        "public static FastDateFormat getInstance(String pattern, TimeZone timeZone)",
        "public static FastDateFormat getInstance(String pattern, Locale locale)",
        "public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale)",
        "public static FastDateFormat getDateInstance(int style)",
        "public static FastDateFormat getDateInstance(int style, Locale locale)",
        "public static FastDateFormat getDateInstance(int style, TimeZone timeZone)",
        "public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale)",
        "public static FastDateFormat getTimeInstance(int style)",
        "public static FastDateFormat getTimeInstance(int style, Locale locale)",
        "public static FastDateFormat getTimeInstance(int style, TimeZone timeZone)",
        "public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale)",
        "public static FastDateFormat getDateTimeInstance( int dateStyle, int timeStyle)",
        "public static FastDateFormat getDateTimeInstance( int dateStyle, int timeStyle, Locale locale)",
        "public static FastDateFormat getDateTimeInstance( int dateStyle, int timeStyle, TimeZone timeZone)",
        "public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone, Locale locale)",
        "static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale)",
        "private static synchronized String getDefaultPattern()",
        "protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale)",
        "protected void init()",
        "protected List<Rule> parsePattern()",
        "protected String parseToken(String pattern, int[] indexRef)",
        "protected NumberRule selectNumberRule(int field, int padding)",
        "public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos)",
        "public String format(long millis)",
        "public String format(Date date)",
        "public String format(Calendar calendar)",
        "public StringBuffer format(long millis, StringBuffer buf)",
        "public StringBuffer format(Date date, StringBuffer buf)",
        "public StringBuffer format(Calendar calendar, StringBuffer buf)",
        "protected StringBuffer applyRules(Calendar calendar, StringBuffer buf)",
        "public Object parseObject(String source, ParsePosition pos)",
        "public String getPattern()",
        "public TimeZone getTimeZone()",
        "public boolean getTimeZoneOverridesCalendar()",
        "public Locale getLocale()",
        "public int getMaxLengthEstimate()",
        "public boolean equals(Object obj)",
        "public int hashCode()",
        "public String toString()",
        "private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException",
        "private interface Rule { int estimateLength(); void appendTo(StringBuffer buffer, Calendar calendar); } private interface NumberRule extends Rule",
        "private static class CharacterLiteral implements Rule { private final char mValue; CharacterLiteral(char value)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "private static class StringLiteral implements Rule { private final String mValue; StringLiteral(String value)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "private static class TextField implements Rule { private final int mField; private final String[] mValues; TextField(int field, String[] values)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "private static class UnpaddedNumberField implements NumberRule { private final int mField; UnpaddedNumberField(int field)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public final void appendTo(StringBuffer buffer, int value)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public final void appendTo(StringBuffer buffer, int value)",
        "private static class PaddedNumberField implements NumberRule { private final int mField; private final int mSize; PaddedNumberField(int field, int size)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public final void appendTo(StringBuffer buffer, int value)",
        "private static class TwoDigitNumberField implements NumberRule { private final int mField; TwoDigitNumberField(int field)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public final void appendTo(StringBuffer buffer, int value)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public final void appendTo(StringBuffer buffer, int value)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public final void appendTo(StringBuffer buffer, int value)",
        "private static class TwelveHourField implements NumberRule { private final NumberRule mRule; TwelveHourField(NumberRule rule)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public void appendTo(StringBuffer buffer, int value)",
        "private static class TwentyFourHourField implements NumberRule { private final NumberRule mRule; TwentyFourHourField(NumberRule rule)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public void appendTo(StringBuffer buffer, int value)",
        "private static class TimeZoneNameRule implements Rule { private final TimeZone mTimeZone; private final boolean mTimeZoneForced; private final Locale mLocale; private final int mStyle; private final String mStandard; private final String mDaylight; TimeZoneNameRule(TimeZone timeZone, boolean timeZoneForced, Locale locale, int style)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "public int estimateLength()",
        "public void appendTo(StringBuffer buffer, Calendar calendar)",
        "private static class TimeZoneDisplayKey { private final TimeZone mTimeZone; private final int mStyle; private final Locale mLocale; TimeZoneDisplayKey(TimeZone timeZone, boolean daylight, int style, Locale locale)",
        "public int hashCode()",
        "public boolean equals(Object obj)",
        "private static class Pair { private final Object mObj1; private final Object mObj2; public Pair(Object obj1, Object obj2)",
        "public boolean equals(Object obj)",
        "public int hashCode()",
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "  public StringBuffer format(Calendar calendar, StringBuffer buf) {\n  if (mTimeZoneForced) {\n  calendar = (Calendar) calendar.clone();\n  calendar.setTimeZone(mTimeZone);\n  }\n  return applyRules(calendar, buf);\n  }",
          "fixed_method": "  public StringBuffer format(Calendar calendar, StringBuffer buf) {\n  if (mTimeZoneForced) {\n  calendar.getTime(); \n  calendar = (Calendar) calendar.clone();\n  calendar.setTimeZone(mTimeZone);\n  }\n  return applyRules(calendar, buf);\n  }",
          "diff": [
            "@@ -869,6 +869,7 @@",
            "      */\n",
            "     public StringBuffer format(Calendar calendar, StringBuffer buf) {\n",
            "         if (mTimeZoneForced) {\n",
            "+            calendar.getTime(); /// LANG-538\n",
            "             calendar = (Calendar) calendar.clone();\n",
            "             calendar.setTimeZone(mTimeZone);\n",
            "         }\n"
          ],
          "changed_lines": 1
        }
      ]
    }
  ]
}
