{
  "bug_id": "95",
  "failed_tests": {
    "org.apache.commons.math.distribution.FDistributionTest": [
      {
        "methodName": "testSmallDegreesOfFreedom",
        "error": "java.lang.IllegalArgumentException",
        "message": "Invalid endpoint parameters:  lowerBound=0.0 initial=-1.0 upperBound=1.7976931348623157E308",
        "fail_line": "        double x = fd.inverseCumulativeProbability(p);",
        "test_source": "  public void testSmallDegreesOfFreedom() throws Exception {\n  org.apache.commons.math.distribution.FDistributionImpl fd =\n  new org.apache.commons.math.distribution.FDistributionImpl(\n  1.0, 1.0);\n  double p = fd.cumulativeProbability(0.975);\n  double x = fd.inverseCumulativeProbability(p);\n  assertEquals(0.975, x, 1.0e-5);\n\n  fd.setDenominatorDegreesOfFreedom(2.0);\n  p = fd.cumulativeProbability(0.975);\n  x = fd.inverseCumulativeProbability(p);\n  assertEquals(0.975, x, 1.0e-5);\n  }",
        "stack": [
          "UnivariateRealSolverUtils.bracket line 179, UnivariateRealSolverUtils.bracket line 128, AbstractContinuousDistribution.inverseCumulativeProbability line 84, FDistributionImpl.inverseCumulativeProbability line 106, FDistributionTest.testSmallDegreesOfFreedom line 114"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/distribution/FDistributionImpl.java",
      "buggy_full_code": "\npackage org.apache.commons.math.distribution;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math.MathException;\nimport org.apache.commons.math.special.Beta;\n\n\npublic class FDistributionImpl extends AbstractContinuousDistribution implements FDistribution, Serializable { private static final long serialVersionUID = -8516354193418641566L; private double numeratorDegreesOfFreedom; private double denominatorDegreesOfFreedom; public FDistributionImpl(double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom) {\n        super();\n        setNumeratorDegreesOfFreedom(numeratorDegreesOfFreedom);\n        setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);\n    }\n    \n    \n    public double cumulativeProbability(double x) throws MathException {\n        double ret;\n        if (x <= 0.0) {\n            ret = 0.0;\n        } else {\n            double n = getNumeratorDegreesOfFreedom();\n            double m = getDenominatorDegreesOfFreedom();\n            \n            ret = Beta.regularizedBeta((n * x) / (m + n * x),\n                0.5 * n,\n                0.5 * m);\n        }\n        return ret;\n    }\n    \n    \n    public double inverseCumulativeProbability(final double p) throws MathException {\n        if (p == 0) {\n            return 0d;\n        }\n        if (p == 1) {\n            return Double.POSITIVE_INFINITY;\n        }\n        return super.inverseCumulativeProbability(p);\n    }\n        \n    \n    protected double getDomainLowerBound(double p) {\n        return 0.0;\n    }\n\n    \n    protected double getDomainUpperBound(double p) {\n        return Double.MAX_VALUE;\n    }\n\n    \n    protected double getInitialDomain(double p) {\n        double ret;\n        double d = getDenominatorDegreesOfFreedom();\n            \n            ret = d / (d - 2.0);\n        return ret;\n    }\n    \n    \n    public void setNumeratorDegreesOfFreedom(double degreesOfFreedom) {\n        if (degreesOfFreedom <= 0.0) {\n            throw new IllegalArgumentException(\n                \"degrees of freedom must be positive.\");\n        }\n        this.numeratorDegreesOfFreedom = degreesOfFreedom;\n    }\n    \n    \n    public double getNumeratorDegreesOfFreedom() {\n        return numeratorDegreesOfFreedom;\n    }\n    \n    \n    public void setDenominatorDegreesOfFreedom(double degreesOfFreedom) {\n        if (degreesOfFreedom <= 0.0) {\n            throw new IllegalArgumentException(\n                \"degrees of freedom must be positive.\");\n        }\n        this.denominatorDegreesOfFreedom = degreesOfFreedom;\n    }\n    \n    \n    public double getDenominatorDegreesOfFreedom() {\n        return denominatorDegreesOfFreedom;\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.math.distribution;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math.MathException;\nimport org.apache.commons.math.special.Beta;\n\n\npublic class FDistributionImpl extends AbstractContinuousDistribution implements FDistribution, Serializable { private static final long serialVersionUID = -8516354193418641566L; private double numeratorDegreesOfFreedom; private double denominatorDegreesOfFreedom; public FDistributionImpl(double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom) {\n        super();\n        setNumeratorDegreesOfFreedom(numeratorDegreesOfFreedom);\n        setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);\n    }\n    \n    \n    public double cumulativeProbability(double x) throws MathException {\n        double ret;\n        if (x <= 0.0) {\n            ret = 0.0;\n        } else {\n            double n = getNumeratorDegreesOfFreedom();\n            double m = getDenominatorDegreesOfFreedom();\n            \n            ret = Beta.regularizedBeta((n * x) / (m + n * x),\n                0.5 * n,\n                0.5 * m);\n        }\n        return ret;\n    }\n    \n    \n    public double inverseCumulativeProbability(final double p) throws MathException {\n        if (p == 0) {\n            return 0d;\n        }\n        if (p == 1) {\n            return Double.POSITIVE_INFINITY;\n        }\n        return super.inverseCumulativeProbability(p);\n    }\n        \n    \n    protected double getDomainLowerBound(double p) {\n        return 0.0;\n    }\n\n    \n    protected double getDomainUpperBound(double p) {\n        return Double.MAX_VALUE;\n    }\n\n    \n    protected double getInitialDomain(double p) {\n        double ret = 1.0;\n        double d = getDenominatorDegreesOfFreedom();\n        if (d > 2.0) {\n            \n            ret = d / (d - 2.0);\n        }\n        return ret;\n    }\n    \n    \n    public void setNumeratorDegreesOfFreedom(double degreesOfFreedom) {\n        if (degreesOfFreedom <= 0.0) {\n            throw new IllegalArgumentException(\n                \"degrees of freedom must be positive.\");\n        }\n        this.numeratorDegreesOfFreedom = degreesOfFreedom;\n    }\n    \n    \n    public double getNumeratorDegreesOfFreedom() {\n        return numeratorDegreesOfFreedom;\n    }\n    \n    \n    public void setDenominatorDegreesOfFreedom(double degreesOfFreedom) {\n        if (degreesOfFreedom <= 0.0) {\n            throw new IllegalArgumentException(\n                \"degrees of freedom must be positive.\");\n        }\n        this.denominatorDegreesOfFreedom = degreesOfFreedom;\n    }\n    \n    \n    public double getDenominatorDegreesOfFreedom() {\n        return denominatorDegreesOfFreedom;\n    }\n}\n",
      "buggy_signatures": [
        "public double cumulativeProbability(double x) throws MathException",
        "public double inverseCumulativeProbability(final double p) throws MathException",
        "protected double getDomainLowerBound(double p)",
        "protected double getDomainUpperBound(double p)",
        "protected double getInitialDomain(double p)",
        "public void setNumeratorDegreesOfFreedom(double degreesOfFreedom)",
        "public double getNumeratorDegreesOfFreedom()",
        "public void setDenominatorDegreesOfFreedom(double degreesOfFreedom)",
        "public double getDenominatorDegreesOfFreedom()"
      ],
      "fixed_signatures": [
        "public double cumulativeProbability(double x) throws MathException",
        "public double inverseCumulativeProbability(final double p) throws MathException",
        "protected double getDomainLowerBound(double p)",
        "protected double getDomainUpperBound(double p)",
        "protected double getInitialDomain(double p)",
        "public void setNumeratorDegreesOfFreedom(double degreesOfFreedom)",
        "public double getNumeratorDegreesOfFreedom()",
        "public void setDenominatorDegreesOfFreedom(double degreesOfFreedom)",
        "public double getDenominatorDegreesOfFreedom()"
      ],
      "methods": [
        {
          "buggy_method": "  protected double getInitialDomain(double p) {\n  double ret;\n  double d = getDenominatorDegreesOfFreedom();\n  \n  ret = d / (d - 2.0);\n  return ret;\n  }",
          "fixed_method": "  protected double getInitialDomain(double p) {\n  double ret = 1.0;\n  double d = getDenominatorDegreesOfFreedom();\n  if (d > 2.0) {\n  \n  ret = d / (d - 2.0);\n  }\n  return ret;\n  }",
          "diff": [
            "@@ -141,10 +141,12 @@",
            "      * @return initial domain value\n",
            "      */\n",
            "     protected double getInitialDomain(double p) {\n",
            "-        double ret;\n",
            "+        double ret = 1.0;\n",
            "         double d = getDenominatorDegreesOfFreedom();\n",
            "+        if (d > 2.0) {\n",
            "             // use mean\n",
            "             ret = d / (d - 2.0);\n",
            "+        }\n",
            "         return ret;\n",
            "     }\n",
            "     \n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
