{
  "bug_id": "Gson_1_bug_info",
  "results": [
    {
      "prompt_index": 1,
      "prompt": "Bug ID: 1\nTest Class: com.google.gson.functional.TypeVariableTest\nMethod: testSingle\nError: java.lang.UnsupportedOperationException\nMessage: Expecting parameterized type, got class com.google.gson.functional.TypeVariableTest$Bar.\nFailing Line:     String json = gson.toJson(bar1);\nTest Source:\npublic void testSingle() throws Exception {\n  Gson gson = new Gson();\n  Bar bar1 = new Bar(\"someString\", 1);\n  ArrayList<Integer> arrayList = new ArrayList<Integer>();\n  arrayList.add(1);\n  arrayList.add(2);\n  bar1.map.put(\"key1\", arrayList);\n  bar1.map.put(\"key2\", new ArrayList<Integer>());\n  String json = gson.toJson(bar1);\n  System.out.println(json);\n\n  Bar bar2 = gson.fromJson(json, Bar.class);\n  assertEquals(bar1, bar2);\n  }\nStack Trace:\nTypeInfoFactory.getActualType line 97, TypeInfoFactory.getTypeInfoForField line 54, ObjectNavigator.navigateClassFields line 156, ObjectNavigator.accept line 131, JsonSerializationContextDefault.serialize line 56, Gson.toJsonTree line 231, Gson.toJson line 271, Gson.toJson line 251, TypeVariableTest.testSingle line 41\n\nReturn **only** the fully-qualified Java *source* class that contains the bug.\nDo **not** return:\n- the test class itself (e.g. com.fasterxml.jackson.databind.jsontype.ext.ExternalTypeIdWithEnum1328Test),\n- any class whose simple name starts or ends with Test, Tests, TestUtil, TestUtils, or TestHelper,\n- any test-utility class such as org.junit.Assert or org.junit.jupiter.api.Assertions.\nOutput just the class name on a single line - nothing else in this format:\nRESPONSE: <fully-qualified-class-name>\n",
      "response": "A: The error you're seeing is because Gson can't handle the type parameters of a generic class. Your class Bar is using a generic type, but Gson doesn't know how to handle that. \nIf you look at your Gson version, you will see that it has a bug on 2.8.0 and 2.8.2 versions. There's a bug in the TypeInfoFactory class that's causing this issue.\nAs a workaround, you can disable the type information when serializing.\nGson gson = new GsonBuilder().disableComplexTypeHierarchySerialization().create();\n\nThis will prevent Gson from attempting to serialize the type information for classes that are generic.\n\nA: As of Gson 2.8.6, there's a bug in Gson where it does not support type parameters in the JsonAdapter annotation.\nIn this case, you can use a Gson type adapter, which is a way to tell Gson how to serialize/deserialize a particular type.\nHere is an example of how you can create a Gson type adapter for the Bar class:\npublic class BarTypeAdapter implements JsonSerializer<Bar>, JsonDeserializer<Bar> {\n    @Override\n    public JsonElement serialize(Bar src, Type typeOfSrc, JsonSerializationContext context) {\n        JsonObject jsonObject = new JsonObject();\n        jsonObject.addProperty(\"name\", src.getName());\n        jsonObject.addProperty(\"value\", src.getValue());\n        jsonObject.add(\"map\", context.serialize(src.getMap()));\n        return jsonObject;\n    }\n\n    @Override\n    public Bar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\n        JsonObject jsonObject = json.getAsJsonObject();\n        String name = jsonObject.get(\"name\").getAsString();\n        int value = jsonObject.get(\"value\").getAsInt();\n        Map<String, List<Integer>> map = context.deserialize(jsonObject.get(\"map\"), new TypeToken<Map<String, List<Integer>>>(){}.getType());\n        return new Bar(name, value, map);\n    }\n}\n\nYou can then use this type"
    }
  ],
  "classes": [
    "TypeInfoFactory"
  ]
}