{
  "bug_id": "52",
  "failed_tests": {
    "org.apache.commons.math.geometry.euclidean.threed.RotationTest": [
      {
        "methodName": "testIssue639",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<0.6228370359608201> but was:<NaN>",
        "fail_line": "      Assert.assertEquals( 0.6228370359608200639829222, rot.getQ0(), 1.0e-15);",
        "test_source": "  public void testIssue639() {\n  Vector3D u1 = new Vector3D(-1321008684645961.0 /  268435456.0,\n  -5774608829631843.0 /  268435456.0,\n  -3822921525525679.0 / 4294967296.0);\n  Vector3D u2 =new Vector3D( -5712344449280879.0 /  2097152.0,\n  -2275058564560979.0 /  1048576.0,\n  4423475992255071.0 /  65536.0);\n  Rotation rot = new Rotation(u1, u2, Vector3D.PLUS_I,Vector3D.PLUS_K);\n  Assert.assertEquals( 0.6228370359608200639829222, rot.getQ0(), 1.0e-15);\n  Assert.assertEquals( 0.0257707621456498790029987, rot.getQ1(), 1.0e-15);\n  Assert.assertEquals(-0.0000000002503012255839931, rot.getQ2(), 1.0e-15);\n  Assert.assertEquals(-0.7819270390861109450724902, rot.getQ3(), 1.0e-15);\n  }",
        "stack": [
          "RotationTest.testIssue639 line 488"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/geometry/euclidean/threed/Rotation.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.geometry.euclidean.threed;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.util.FastMath;\n\n\n\npublic class Rotation implements Serializable { public static final Rotation IDENTITY = new Rotation(1.0, 0.0, 0.0, 0.0, false); private static final long serialVersionUID = -2153622329907944313L; private final double q0; private final double q1; private final double q2; private final double q3; public Rotation(double q0, double q1, double q2, double q3, boolean needsNormalization) {\n\n    if (needsNormalization) {\n      \n      double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n      q0 *= inv;\n      q1 *= inv;\n      q2 *= inv;\n      q3 *= inv;\n    }\n\n    this.q0 = q0;\n    this.q1 = q1;\n    this.q2 = q2;\n    this.q3 = q3;\n\n  }\n\n  \n  public Rotation(Vector3D axis, double angle) {\n\n    double norm = axis.getNorm();\n    if (norm == 0) {\n      throw MathRuntimeException.createArithmeticException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);\n    }\n\n    double halfAngle = -0.5 * angle;\n    double coeff = FastMath.sin(halfAngle) / norm;\n\n    q0 = FastMath.cos (halfAngle);\n    q1 = coeff * axis.getX();\n    q2 = coeff * axis.getY();\n    q3 = coeff * axis.getZ();\n\n  }\n\n  \n  public Rotation(double[][] m, double threshold) throws NotARotationMatrixException {\n\n    \n    if ((m.length != 3) || (m[0].length != 3) ||\n        (m[1].length != 3) || (m[2].length != 3)) {\n      throw new NotARotationMatrixException(\n              LocalizedFormats.ROTATION_MATRIX_DIMENSIONS,\n              m.length, m[0].length);\n    }\n\n    \n    double[][] ort = orthogonalizeMatrix(m, threshold);\n\n    \n    double det = ort[0][0] * (ort[1][1] * ort[2][2] - ort[2][1] * ort[1][2]) -\n                 ort[1][0] * (ort[0][1] * ort[2][2] - ort[2][1] * ort[0][2]) +\n                 ort[2][0] * (ort[0][1] * ort[1][2] - ort[1][1] * ort[0][2]);\n    if (det < 0.0) {\n      throw new NotARotationMatrixException(\n              LocalizedFormats.CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT,\n              det);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    double s = ort[0][0] + ort[1][1] + ort[2][2];\n    if (s > -0.19) {\n      \n      q0 = 0.5 * FastMath.sqrt(s + 1.0);\n      double inv = 0.25 / q0;\n      q1 = inv * (ort[1][2] - ort[2][1]);\n      q2 = inv * (ort[2][0] - ort[0][2]);\n      q3 = inv * (ort[0][1] - ort[1][0]);\n    } else {\n      s = ort[0][0] - ort[1][1] - ort[2][2];\n      if (s > -0.19) {\n        \n        q1 = 0.5 * FastMath.sqrt(s + 1.0);\n        double inv = 0.25 / q1;\n        q0 = inv * (ort[1][2] - ort[2][1]);\n        q2 = inv * (ort[0][1] + ort[1][0]);\n        q3 = inv * (ort[0][2] + ort[2][0]);\n      } else {\n        s = ort[1][1] - ort[0][0] - ort[2][2];\n        if (s > -0.19) {\n          \n          q2 = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / q2;\n          q0 = inv * (ort[2][0] - ort[0][2]);\n          q1 = inv * (ort[0][1] + ort[1][0]);\n          q3 = inv * (ort[2][1] + ort[1][2]);\n        } else {\n          \n          s = ort[2][2] - ort[0][0] - ort[1][1];\n          q3 = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / q3;\n          q0 = inv * (ort[0][1] - ort[1][0]);\n          q1 = inv * (ort[0][2] + ort[2][0]);\n          q2 = inv * (ort[2][1] + ort[1][2]);\n        }\n      }\n    }\n\n  }\n\n  \n  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n  \n  double u1u1 = u1.getNormSq();\n  double u2u2 = u2.getNormSq();\n  double v1v1 = v1.getNormSq();\n  double v2v2 = v2.getNormSq();\n  if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n    throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n  }\n\n  \n  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n\n  \n  double u1u2   = u1.dotProduct(u2);\n  double v1v2   = v1.dotProduct(v2);\n  double coeffU = u1u2 / u1u1;\n  double coeffV = v1v2 / u1u1;\n  double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n  double alpha  = coeffU - beta * coeffV;\n  v2 = new Vector3D(alpha, v1, beta, v2);\n\n  \n  Vector3D uRef  = u1;\n  Vector3D vRef  = v1;\n  Vector3D v1Su1 = v1.subtract(u1);\n  Vector3D v2Su2 = v2.subtract(u2);\n  Vector3D k     = v1Su1.crossProduct(v2Su2);\n  Vector3D u3    = u1.crossProduct(u2);\n  double c       = k.dotProduct(u3);\n  if (c == 0) {\n    \n    \n    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n    Vector3D v3Su3 = v3.subtract(u3);\n    k = v1Su1.crossProduct(v3Su3);\n    Vector3D u2Prime = u1.crossProduct(u3);\n    c = k.dotProduct(u2Prime);\n\n    if (c == 0) {\n      \n      \n      k = v2Su2.crossProduct(v3Su3);;\n      c = k.dotProduct(u2.crossProduct(u3));;\n\n      if (c == 0) {\n        \n        \n        q0 = 1.0;\n        q1 = 0.0;\n        q2 = 0.0;\n        q3 = 0.0;\n        return;\n      }\n\n      \n      uRef = u2;\n      vRef = v2;\n\n    }\n\n  }\n\n  \n  c = FastMath.sqrt(c);\n  double inv = 1.0 / (c + c);\n  q1 = inv * k.getX();\n  q2 = inv * k.getY();\n  q3 = inv * k.getZ();\n\n  \n   k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,\n                    uRef.getZ() * q1 - uRef.getX() * q3,\n                    uRef.getX() * q2 - uRef.getY() * q1);\n  q0 = vRef.dotProduct(k) / (2 * k.getNormSq());\n\n  }\n\n  \n  public Rotation(Vector3D u, Vector3D v) {\n\n    double normProduct = u.getNorm() * v.getNorm();\n    if (normProduct == 0) {\n        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n    }\n\n    double dot = u.dotProduct(v);\n\n    if (dot < ((2.0e-15 - 1.0) * normProduct)) {\n      \n      \n      Vector3D w = u.orthogonal();\n      q0 = 0.0;\n      q1 = -w.getX();\n      q2 = -w.getY();\n      q3 = -w.getZ();\n    } else {\n      \n      \n      q0 = FastMath.sqrt(0.5 * (1.0 + dot / normProduct));\n      double coeff = 1.0 / (2.0 * q0 * normProduct);\n      Vector3D q = v.crossProduct(u);\n      q1 = coeff * q.getX();\n      q2 = coeff * q.getY();\n      q3 = coeff * q.getZ();\n    }\n\n  }\n\n  \n  public Rotation(RotationOrder order, double alpha1, double alpha2, double alpha3) {\n    Rotation r1 = new Rotation(order.getA1(), alpha1);\n    Rotation r2 = new Rotation(order.getA2(), alpha2);\n    Rotation r3 = new Rotation(order.getA3(), alpha3);\n    Rotation composed = r1.applyTo(r2.applyTo(r3));\n    q0 = composed.q0;\n    q1 = composed.q1;\n    q2 = composed.q2;\n    q3 = composed.q3;\n  }\n\n  \n  public Rotation revert() {\n    return new Rotation(-q0, q1, q2, q3, false);\n  }\n\n  \n  public double getQ0() {\n    return q0;\n  }\n\n  \n  public double getQ1() {\n    return q1;\n  }\n\n  \n  public double getQ2() {\n    return q2;\n  }\n\n  \n  public double getQ3() {\n    return q3;\n  }\n\n  \n  public Vector3D getAxis() {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n      return new Vector3D(1, 0, 0);\n    } else if (q0 < 0) {\n      double inverse = 1 / FastMath.sqrt(squaredSine);\n      return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n    }\n    double inverse = -1 / FastMath.sqrt(squaredSine);\n    return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n  }\n\n  \n  public double getAngle() {\n    if ((q0 < -0.1) || (q0 > 0.1)) {\n      return 2 * FastMath.asin(FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3));\n    } else if (q0 < 0) {\n      return 2 * FastMath.acos(-q0);\n    }\n    return 2 * FastMath.acos(q0);\n  }\n\n  \n  public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      \n      \n      \n      \n      \n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      \n      \n      \n      \n      \n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      \n      \n      \n      \n      \n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      \n      \n      \n      \n      \n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      \n      \n      \n      \n      \n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      \n      \n      \n      \n      \n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n       -FastMath.asin(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      \n      \n      \n      \n      \n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      \n      \n      \n      \n      \n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      \n      \n      \n      \n      \n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      \n      \n      \n      \n      \n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      \n      \n      \n      \n      \n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { \n\n      \n      \n      \n      \n      \n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }\n\n  \n  public double[][] getMatrix() {\n\n    \n    double q0q0  = q0 * q0;\n    double q0q1  = q0 * q1;\n    double q0q2  = q0 * q2;\n    double q0q3  = q0 * q3;\n    double q1q1  = q1 * q1;\n    double q1q2  = q1 * q2;\n    double q1q3  = q1 * q3;\n    double q2q2  = q2 * q2;\n    double q2q3  = q2 * q3;\n    double q3q3  = q3 * q3;\n\n    \n    double[][] m = new double[3][];\n    m[0] = new double[3];\n    m[1] = new double[3];\n    m[2] = new double[3];\n\n    m [0][0] = 2.0 * (q0q0 + q1q1) - 1.0;\n    m [1][0] = 2.0 * (q1q2 - q0q3);\n    m [2][0] = 2.0 * (q1q3 + q0q2);\n\n    m [0][1] = 2.0 * (q1q2 + q0q3);\n    m [1][1] = 2.0 * (q0q0 + q2q2) - 1.0;\n    m [2][1] = 2.0 * (q2q3 - q0q1);\n\n    m [0][2] = 2.0 * (q1q3 - q0q2);\n    m [1][2] = 2.0 * (q2q3 + q0q1);\n    m [2][2] = 2.0 * (q0q0 + q3q3) - 1.0;\n\n    return m;\n\n  }\n\n  \n  public Vector3D applyTo(Vector3D u) {\n\n    double x = u.getX();\n    double y = u.getY();\n    double z = u.getZ();\n\n    double s = q1 * x + q2 * y + q3 * z;\n\n    return new Vector3D(2 * (q0 * (x * q0 - (q2 * z - q3 * y)) + s * q1) - x,\n                        2 * (q0 * (y * q0 - (q3 * x - q1 * z)) + s * q2) - y,\n                        2 * (q0 * (z * q0 - (q1 * y - q2 * x)) + s * q3) - z);\n\n  }\n\n  \n  public Vector3D applyInverseTo(Vector3D u) {\n\n    double x = u.getX();\n    double y = u.getY();\n    double z = u.getZ();\n\n    double s = q1 * x + q2 * y + q3 * z;\n    double m0 = -q0;\n\n    return new Vector3D(2 * (m0 * (x * m0 - (q2 * z - q3 * y)) + s * q1) - x,\n                        2 * (m0 * (y * m0 - (q3 * x - q1 * z)) + s * q2) - y,\n                        2 * (m0 * (z * m0 - (q1 * y - q2 * x)) + s * q3) - z);\n\n  }\n\n  \n  public Rotation applyTo(Rotation r) {\n    return new Rotation(r.q0 * q0 - (r.q1 * q1 + r.q2 * q2 + r.q3 * q3),\n                        r.q1 * q0 + r.q0 * q1 + (r.q2 * q3 - r.q3 * q2),\n                        r.q2 * q0 + r.q0 * q2 + (r.q3 * q1 - r.q1 * q3),\n                        r.q3 * q0 + r.q0 * q3 + (r.q1 * q2 - r.q2 * q1),\n                        false);\n  }\n\n  \n  public Rotation applyInverseTo(Rotation r) {\n    return new Rotation(-r.q0 * q0 - (r.q1 * q1 + r.q2 * q2 + r.q3 * q3),\n                        -r.q1 * q0 + r.q0 * q1 + (r.q2 * q3 - r.q3 * q2),\n                        -r.q2 * q0 + r.q0 * q2 + (r.q3 * q1 - r.q1 * q3),\n                        -r.q3 * q0 + r.q0 * q3 + (r.q1 * q2 - r.q2 * q1),\n                        false);\n  }\n\n  \n  private double[][] orthogonalizeMatrix(double[][] m, double threshold) throws NotARotationMatrixException {\n    double[] m0 = m[0];\n    double[] m1 = m[1];\n    double[] m2 = m[2];\n    double x00 = m0[0];\n    double x01 = m0[1];\n    double x02 = m0[2];\n    double x10 = m1[0];\n    double x11 = m1[1];\n    double x12 = m1[2];\n    double x20 = m2[0];\n    double x21 = m2[1];\n    double x22 = m2[2];\n    double fn = 0;\n    double fn1;\n\n    double[][] o = new double[3][3];\n    double[] o0 = o[0];\n    double[] o1 = o[1];\n    double[] o2 = o[2];\n\n    \n    int i = 0;\n    while (++i < 11) {\n\n      \n      double mx00 = m0[0] * x00 + m1[0] * x10 + m2[0] * x20;\n      double mx10 = m0[1] * x00 + m1[1] * x10 + m2[1] * x20;\n      double mx20 = m0[2] * x00 + m1[2] * x10 + m2[2] * x20;\n      double mx01 = m0[0] * x01 + m1[0] * x11 + m2[0] * x21;\n      double mx11 = m0[1] * x01 + m1[1] * x11 + m2[1] * x21;\n      double mx21 = m0[2] * x01 + m1[2] * x11 + m2[2] * x21;\n      double mx02 = m0[0] * x02 + m1[0] * x12 + m2[0] * x22;\n      double mx12 = m0[1] * x02 + m1[1] * x12 + m2[1] * x22;\n      double mx22 = m0[2] * x02 + m1[2] * x12 + m2[2] * x22;\n\n      \n      o0[0] = x00 - 0.5 * (x00 * mx00 + x01 * mx10 + x02 * mx20 - m0[0]);\n      o0[1] = x01 - 0.5 * (x00 * mx01 + x01 * mx11 + x02 * mx21 - m0[1]);\n      o0[2] = x02 - 0.5 * (x00 * mx02 + x01 * mx12 + x02 * mx22 - m0[2]);\n      o1[0] = x10 - 0.5 * (x10 * mx00 + x11 * mx10 + x12 * mx20 - m1[0]);\n      o1[1] = x11 - 0.5 * (x10 * mx01 + x11 * mx11 + x12 * mx21 - m1[1]);\n      o1[2] = x12 - 0.5 * (x10 * mx02 + x11 * mx12 + x12 * mx22 - m1[2]);\n      o2[0] = x20 - 0.5 * (x20 * mx00 + x21 * mx10 + x22 * mx20 - m2[0]);\n      o2[1] = x21 - 0.5 * (x20 * mx01 + x21 * mx11 + x22 * mx21 - m2[1]);\n      o2[2] = x22 - 0.5 * (x20 * mx02 + x21 * mx12 + x22 * mx22 - m2[2]);\n\n      \n      double corr00 = o0[0] - m0[0];\n      double corr01 = o0[1] - m0[1];\n      double corr02 = o0[2] - m0[2];\n      double corr10 = o1[0] - m1[0];\n      double corr11 = o1[1] - m1[1];\n      double corr12 = o1[2] - m1[2];\n      double corr20 = o2[0] - m2[0];\n      double corr21 = o2[1] - m2[1];\n      double corr22 = o2[2] - m2[2];\n\n      \n      fn1 = corr00 * corr00 + corr01 * corr01 + corr02 * corr02 +\n            corr10 * corr10 + corr11 * corr11 + corr12 * corr12 +\n            corr20 * corr20 + corr21 * corr21 + corr22 * corr22;\n\n      \n      if (FastMath.abs(fn1 - fn) <= threshold) {\n          return o;\n      }\n\n      \n      x00 = o0[0];\n      x01 = o0[1];\n      x02 = o0[2];\n      x10 = o1[0];\n      x11 = o1[1];\n      x12 = o1[2];\n      x20 = o2[0];\n      x21 = o2[1];\n      x22 = o2[2];\n      fn  = fn1;\n\n    }\n\n    \n    throw new NotARotationMatrixException(\n            LocalizedFormats.UNABLE_TO_ORTHOGONOLIZE_MATRIX,\n            i - 1);\n  }\n\n  \n  public static double distance(Rotation r1, Rotation r2) {\n      return r1.applyInverseTo(r2).getAngle();\n  }\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.geometry.euclidean.threed;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.util.FastMath;\n\n\n\npublic class Rotation implements Serializable { public static final Rotation IDENTITY = new Rotation(1.0, 0.0, 0.0, 0.0, false); private static final long serialVersionUID = -2153622329907944313L; private final double q0; private final double q1; private final double q2; private final double q3; public Rotation(double q0, double q1, double q2, double q3, boolean needsNormalization) {\n\n    if (needsNormalization) {\n      \n      double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n      q0 *= inv;\n      q1 *= inv;\n      q2 *= inv;\n      q3 *= inv;\n    }\n\n    this.q0 = q0;\n    this.q1 = q1;\n    this.q2 = q2;\n    this.q3 = q3;\n\n  }\n\n  \n  public Rotation(Vector3D axis, double angle) {\n\n    double norm = axis.getNorm();\n    if (norm == 0) {\n      throw MathRuntimeException.createArithmeticException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);\n    }\n\n    double halfAngle = -0.5 * angle;\n    double coeff = FastMath.sin(halfAngle) / norm;\n\n    q0 = FastMath.cos (halfAngle);\n    q1 = coeff * axis.getX();\n    q2 = coeff * axis.getY();\n    q3 = coeff * axis.getZ();\n\n  }\n\n  \n  public Rotation(double[][] m, double threshold) throws NotARotationMatrixException {\n\n    \n    if ((m.length != 3) || (m[0].length != 3) ||\n        (m[1].length != 3) || (m[2].length != 3)) {\n      throw new NotARotationMatrixException(\n              LocalizedFormats.ROTATION_MATRIX_DIMENSIONS,\n              m.length, m[0].length);\n    }\n\n    \n    double[][] ort = orthogonalizeMatrix(m, threshold);\n\n    \n    double det = ort[0][0] * (ort[1][1] * ort[2][2] - ort[2][1] * ort[1][2]) -\n                 ort[1][0] * (ort[0][1] * ort[2][2] - ort[2][1] * ort[0][2]) +\n                 ort[2][0] * (ort[0][1] * ort[1][2] - ort[1][1] * ort[0][2]);\n    if (det < 0.0) {\n      throw new NotARotationMatrixException(\n              LocalizedFormats.CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT,\n              det);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    double s = ort[0][0] + ort[1][1] + ort[2][2];\n    if (s > -0.19) {\n      \n      q0 = 0.5 * FastMath.sqrt(s + 1.0);\n      double inv = 0.25 / q0;\n      q1 = inv * (ort[1][2] - ort[2][1]);\n      q2 = inv * (ort[2][0] - ort[0][2]);\n      q3 = inv * (ort[0][1] - ort[1][0]);\n    } else {\n      s = ort[0][0] - ort[1][1] - ort[2][2];\n      if (s > -0.19) {\n        \n        q1 = 0.5 * FastMath.sqrt(s + 1.0);\n        double inv = 0.25 / q1;\n        q0 = inv * (ort[1][2] - ort[2][1]);\n        q2 = inv * (ort[0][1] + ort[1][0]);\n        q3 = inv * (ort[0][2] + ort[2][0]);\n      } else {\n        s = ort[1][1] - ort[0][0] - ort[2][2];\n        if (s > -0.19) {\n          \n          q2 = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / q2;\n          q0 = inv * (ort[2][0] - ort[0][2]);\n          q1 = inv * (ort[0][1] + ort[1][0]);\n          q3 = inv * (ort[2][1] + ort[1][2]);\n        } else {\n          \n          s = ort[2][2] - ort[0][0] - ort[1][1];\n          q3 = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / q3;\n          q0 = inv * (ort[0][1] - ort[1][0]);\n          q1 = inv * (ort[0][2] + ort[2][0]);\n          q2 = inv * (ort[2][1] + ort[1][2]);\n        }\n      }\n    }\n\n  }\n\n  \n  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n  \n  double u1u1 = u1.getNormSq();\n  double u2u2 = u2.getNormSq();\n  double v1v1 = v1.getNormSq();\n  double v2v2 = v2.getNormSq();\n  if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n    throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n  }\n\n  \n  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n\n  \n  double u1u2   = u1.dotProduct(u2);\n  double v1v2   = v1.dotProduct(v2);\n  double coeffU = u1u2 / u1u1;\n  double coeffV = v1v2 / u1u1;\n  double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n  double alpha  = coeffU - beta * coeffV;\n  v2 = new Vector3D(alpha, v1, beta, v2);\n\n  \n  Vector3D uRef  = u1;\n  Vector3D vRef  = v1;\n  Vector3D v1Su1 = v1.subtract(u1);\n  Vector3D v2Su2 = v2.subtract(u2);\n  Vector3D k     = v1Su1.crossProduct(v2Su2);\n  Vector3D u3    = u1.crossProduct(u2);\n  double c       = k.dotProduct(u3);\n  final double inPlaneThreshold = 0.001;\n  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {\n    \n    \n    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n    Vector3D v3Su3 = v3.subtract(u3);\n    k = v1Su1.crossProduct(v3Su3);\n    Vector3D u2Prime = u1.crossProduct(u3);\n    c = k.dotProduct(u2Prime);\n\n    if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) {\n      \n      \n      k = v2Su2.crossProduct(v3Su3);;\n      c = k.dotProduct(u2.crossProduct(u3));;\n\n      if (c <= 0) {\n        \n        \n        q0 = 1.0;\n        q1 = 0.0;\n        q2 = 0.0;\n        q3 = 0.0;\n        return;\n      }\n\n      \n      uRef = u2;\n      vRef = v2;\n\n    }\n\n  }\n\n  \n  c = FastMath.sqrt(c);\n  double inv = 1.0 / (c + c);\n  q1 = inv * k.getX();\n  q2 = inv * k.getY();\n  q3 = inv * k.getZ();\n\n  \n   k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,\n                    uRef.getZ() * q1 - uRef.getX() * q3,\n                    uRef.getX() * q2 - uRef.getY() * q1);\n  q0 = vRef.dotProduct(k) / (2 * k.getNormSq());\n\n  }\n\n  \n  public Rotation(Vector3D u, Vector3D v) {\n\n    double normProduct = u.getNorm() * v.getNorm();\n    if (normProduct == 0) {\n        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n    }\n\n    double dot = u.dotProduct(v);\n\n    if (dot < ((2.0e-15 - 1.0) * normProduct)) {\n      \n      \n      Vector3D w = u.orthogonal();\n      q0 = 0.0;\n      q1 = -w.getX();\n      q2 = -w.getY();\n      q3 = -w.getZ();\n    } else {\n      \n      \n      q0 = FastMath.sqrt(0.5 * (1.0 + dot / normProduct));\n      double coeff = 1.0 / (2.0 * q0 * normProduct);\n      Vector3D q = v.crossProduct(u);\n      q1 = coeff * q.getX();\n      q2 = coeff * q.getY();\n      q3 = coeff * q.getZ();\n    }\n\n  }\n\n  \n  public Rotation(RotationOrder order, double alpha1, double alpha2, double alpha3) {\n    Rotation r1 = new Rotation(order.getA1(), alpha1);\n    Rotation r2 = new Rotation(order.getA2(), alpha2);\n    Rotation r3 = new Rotation(order.getA3(), alpha3);\n    Rotation composed = r1.applyTo(r2.applyTo(r3));\n    q0 = composed.q0;\n    q1 = composed.q1;\n    q2 = composed.q2;\n    q3 = composed.q3;\n  }\n\n  \n  public Rotation revert() {\n    return new Rotation(-q0, q1, q2, q3, false);\n  }\n\n  \n  public double getQ0() {\n    return q0;\n  }\n\n  \n  public double getQ1() {\n    return q1;\n  }\n\n  \n  public double getQ2() {\n    return q2;\n  }\n\n  \n  public double getQ3() {\n    return q3;\n  }\n\n  \n  public Vector3D getAxis() {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n      return new Vector3D(1, 0, 0);\n    } else if (q0 < 0) {\n      double inverse = 1 / FastMath.sqrt(squaredSine);\n      return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n    }\n    double inverse = -1 / FastMath.sqrt(squaredSine);\n    return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n  }\n\n  \n  public double getAngle() {\n    if ((q0 < -0.1) || (q0 > 0.1)) {\n      return 2 * FastMath.asin(FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3));\n    } else if (q0 < 0) {\n      return 2 * FastMath.acos(-q0);\n    }\n    return 2 * FastMath.acos(q0);\n  }\n\n  \n  public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      \n      \n      \n      \n      \n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      \n      \n      \n      \n      \n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      \n      \n      \n      \n      \n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      \n      \n      \n      \n      \n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      \n      \n      \n      \n      \n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      \n      \n      \n      \n      \n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n       -FastMath.asin(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      \n      \n      \n      \n      \n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      \n      \n      \n      \n      \n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      \n      \n      \n      \n      \n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      \n      \n      \n      \n      \n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      \n      \n      \n      \n      \n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { \n\n      \n      \n      \n      \n      \n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }\n\n  \n  public double[][] getMatrix() {\n\n    \n    double q0q0  = q0 * q0;\n    double q0q1  = q0 * q1;\n    double q0q2  = q0 * q2;\n    double q0q3  = q0 * q3;\n    double q1q1  = q1 * q1;\n    double q1q2  = q1 * q2;\n    double q1q3  = q1 * q3;\n    double q2q2  = q2 * q2;\n    double q2q3  = q2 * q3;\n    double q3q3  = q3 * q3;\n\n    \n    double[][] m = new double[3][];\n    m[0] = new double[3];\n    m[1] = new double[3];\n    m[2] = new double[3];\n\n    m [0][0] = 2.0 * (q0q0 + q1q1) - 1.0;\n    m [1][0] = 2.0 * (q1q2 - q0q3);\n    m [2][0] = 2.0 * (q1q3 + q0q2);\n\n    m [0][1] = 2.0 * (q1q2 + q0q3);\n    m [1][1] = 2.0 * (q0q0 + q2q2) - 1.0;\n    m [2][1] = 2.0 * (q2q3 - q0q1);\n\n    m [0][2] = 2.0 * (q1q3 - q0q2);\n    m [1][2] = 2.0 * (q2q3 + q0q1);\n    m [2][2] = 2.0 * (q0q0 + q3q3) - 1.0;\n\n    return m;\n\n  }\n\n  \n  public Vector3D applyTo(Vector3D u) {\n\n    double x = u.getX();\n    double y = u.getY();\n    double z = u.getZ();\n\n    double s = q1 * x + q2 * y + q3 * z;\n\n    return new Vector3D(2 * (q0 * (x * q0 - (q2 * z - q3 * y)) + s * q1) - x,\n                        2 * (q0 * (y * q0 - (q3 * x - q1 * z)) + s * q2) - y,\n                        2 * (q0 * (z * q0 - (q1 * y - q2 * x)) + s * q3) - z);\n\n  }\n\n  \n  public Vector3D applyInverseTo(Vector3D u) {\n\n    double x = u.getX();\n    double y = u.getY();\n    double z = u.getZ();\n\n    double s = q1 * x + q2 * y + q3 * z;\n    double m0 = -q0;\n\n    return new Vector3D(2 * (m0 * (x * m0 - (q2 * z - q3 * y)) + s * q1) - x,\n                        2 * (m0 * (y * m0 - (q3 * x - q1 * z)) + s * q2) - y,\n                        2 * (m0 * (z * m0 - (q1 * y - q2 * x)) + s * q3) - z);\n\n  }\n\n  \n  public Rotation applyTo(Rotation r) {\n    return new Rotation(r.q0 * q0 - (r.q1 * q1 + r.q2 * q2 + r.q3 * q3),\n                        r.q1 * q0 + r.q0 * q1 + (r.q2 * q3 - r.q3 * q2),\n                        r.q2 * q0 + r.q0 * q2 + (r.q3 * q1 - r.q1 * q3),\n                        r.q3 * q0 + r.q0 * q3 + (r.q1 * q2 - r.q2 * q1),\n                        false);\n  }\n\n  \n  public Rotation applyInverseTo(Rotation r) {\n    return new Rotation(-r.q0 * q0 - (r.q1 * q1 + r.q2 * q2 + r.q3 * q3),\n                        -r.q1 * q0 + r.q0 * q1 + (r.q2 * q3 - r.q3 * q2),\n                        -r.q2 * q0 + r.q0 * q2 + (r.q3 * q1 - r.q1 * q3),\n                        -r.q3 * q0 + r.q0 * q3 + (r.q1 * q2 - r.q2 * q1),\n                        false);\n  }\n\n  \n  private double[][] orthogonalizeMatrix(double[][] m, double threshold) throws NotARotationMatrixException {\n    double[] m0 = m[0];\n    double[] m1 = m[1];\n    double[] m2 = m[2];\n    double x00 = m0[0];\n    double x01 = m0[1];\n    double x02 = m0[2];\n    double x10 = m1[0];\n    double x11 = m1[1];\n    double x12 = m1[2];\n    double x20 = m2[0];\n    double x21 = m2[1];\n    double x22 = m2[2];\n    double fn = 0;\n    double fn1;\n\n    double[][] o = new double[3][3];\n    double[] o0 = o[0];\n    double[] o1 = o[1];\n    double[] o2 = o[2];\n\n    \n    int i = 0;\n    while (++i < 11) {\n\n      \n      double mx00 = m0[0] * x00 + m1[0] * x10 + m2[0] * x20;\n      double mx10 = m0[1] * x00 + m1[1] * x10 + m2[1] * x20;\n      double mx20 = m0[2] * x00 + m1[2] * x10 + m2[2] * x20;\n      double mx01 = m0[0] * x01 + m1[0] * x11 + m2[0] * x21;\n      double mx11 = m0[1] * x01 + m1[1] * x11 + m2[1] * x21;\n      double mx21 = m0[2] * x01 + m1[2] * x11 + m2[2] * x21;\n      double mx02 = m0[0] * x02 + m1[0] * x12 + m2[0] * x22;\n      double mx12 = m0[1] * x02 + m1[1] * x12 + m2[1] * x22;\n      double mx22 = m0[2] * x02 + m1[2] * x12 + m2[2] * x22;\n\n      \n      o0[0] = x00 - 0.5 * (x00 * mx00 + x01 * mx10 + x02 * mx20 - m0[0]);\n      o0[1] = x01 - 0.5 * (x00 * mx01 + x01 * mx11 + x02 * mx21 - m0[1]);\n      o0[2] = x02 - 0.5 * (x00 * mx02 + x01 * mx12 + x02 * mx22 - m0[2]);\n      o1[0] = x10 - 0.5 * (x10 * mx00 + x11 * mx10 + x12 * mx20 - m1[0]);\n      o1[1] = x11 - 0.5 * (x10 * mx01 + x11 * mx11 + x12 * mx21 - m1[1]);\n      o1[2] = x12 - 0.5 * (x10 * mx02 + x11 * mx12 + x12 * mx22 - m1[2]);\n      o2[0] = x20 - 0.5 * (x20 * mx00 + x21 * mx10 + x22 * mx20 - m2[0]);\n      o2[1] = x21 - 0.5 * (x20 * mx01 + x21 * mx11 + x22 * mx21 - m2[1]);\n      o2[2] = x22 - 0.5 * (x20 * mx02 + x21 * mx12 + x22 * mx22 - m2[2]);\n\n      \n      double corr00 = o0[0] - m0[0];\n      double corr01 = o0[1] - m0[1];\n      double corr02 = o0[2] - m0[2];\n      double corr10 = o1[0] - m1[0];\n      double corr11 = o1[1] - m1[1];\n      double corr12 = o1[2] - m1[2];\n      double corr20 = o2[0] - m2[0];\n      double corr21 = o2[1] - m2[1];\n      double corr22 = o2[2] - m2[2];\n\n      \n      fn1 = corr00 * corr00 + corr01 * corr01 + corr02 * corr02 +\n            corr10 * corr10 + corr11 * corr11 + corr12 * corr12 +\n            corr20 * corr20 + corr21 * corr21 + corr22 * corr22;\n\n      \n      if (FastMath.abs(fn1 - fn) <= threshold) {\n          return o;\n      }\n\n      \n      x00 = o0[0];\n      x01 = o0[1];\n      x02 = o0[2];\n      x10 = o1[0];\n      x11 = o1[1];\n      x12 = o1[2];\n      x20 = o2[0];\n      x21 = o2[1];\n      x22 = o2[2];\n      fn  = fn1;\n\n    }\n\n    \n    throw new NotARotationMatrixException(\n            LocalizedFormats.UNABLE_TO_ORTHOGONOLIZE_MATRIX,\n            i - 1);\n  }\n\n  \n  public static double distance(Rotation r1, Rotation r2) {\n      return r1.applyInverseTo(r2).getAngle();\n  }\n\n}\n",
      "buggy_signatures": [
        "public Rotation(Vector3D axis, double angle)",
        "public Rotation(double[][] m, double threshold) throws NotARotationMatrixException",
        "public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2)",
        "public Rotation(Vector3D u, Vector3D v)",
        "public Rotation(RotationOrder order, double alpha1, double alpha2, double alpha3)",
        "public Rotation revert()",
        "public double getQ0()",
        "public double getQ1()",
        "public double getQ2()",
        "public double getQ3()",
        "public Vector3D getAxis()",
        "public double getAngle()",
        "public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException",
        "public double[][] getMatrix()",
        "public Vector3D applyTo(Vector3D u)",
        "public Vector3D applyInverseTo(Vector3D u)",
        "public Rotation applyTo(Rotation r)",
        "public Rotation applyInverseTo(Rotation r)",
        "private double[][] orthogonalizeMatrix(double[][] m, double threshold) throws NotARotationMatrixException",
        "public static double distance(Rotation r1, Rotation r2)"
      ],
      "fixed_signatures": [
        "public Rotation(Vector3D axis, double angle)",
        "public Rotation(double[][] m, double threshold) throws NotARotationMatrixException",
        "public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2)",
        "public Rotation(Vector3D u, Vector3D v)",
        "public Rotation(RotationOrder order, double alpha1, double alpha2, double alpha3)",
        "public Rotation revert()",
        "public double getQ0()",
        "public double getQ1()",
        "public double getQ2()",
        "public double getQ3()",
        "public Vector3D getAxis()",
        "public double getAngle()",
        "public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException",
        "public double[][] getMatrix()",
        "public Vector3D applyTo(Vector3D u)",
        "public Vector3D applyInverseTo(Vector3D u)",
        "public Rotation applyTo(Rotation r)",
        "public Rotation applyInverseTo(Rotation r)",
        "private double[][] orthogonalizeMatrix(double[][] m, double threshold) throws NotARotationMatrixException",
        "public static double distance(Rotation r1, Rotation r2)"
      ],
      "methods": [
        {
          "buggy_method": "  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n  \n  double u1u1 = u1.getNormSq();\n  double u2u2 = u2.getNormSq();\n  double v1v1 = v1.getNormSq();\n  double v2v2 = v2.getNormSq();\n  if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n  throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n  }\n\n  \n  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n\n  \n  double u1u2  = u1.dotProduct(u2);\n  double v1v2  = v1.dotProduct(v2);\n  double coeffU = u1u2 / u1u1;\n  double coeffV = v1v2 / u1u1;\n  double beta  = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n  double alpha  = coeffU - beta * coeffV;\n  v2 = new Vector3D(alpha, v1, beta, v2);\n\n  \n  Vector3D uRef  = u1;\n  Vector3D vRef  = v1;\n  Vector3D v1Su1 = v1.subtract(u1);\n  Vector3D v2Su2 = v2.subtract(u2);\n  Vector3D k  = v1Su1.crossProduct(v2Su2);\n  Vector3D u3  = u1.crossProduct(u2);\n  double c  = k.dotProduct(u3);\n  if (c == 0) {\n  \n  \n  Vector3D v3 = Vector3D.crossProduct(v1, v2);\n  Vector3D v3Su3 = v3.subtract(u3);\n  k = v1Su1.crossProduct(v3Su3);\n  Vector3D u2Prime = u1.crossProduct(u3);\n  c = k.dotProduct(u2Prime);\n\n  if (c == 0) {\n  \n  \n  k = v2Su2.crossProduct(v3Su3);;\n  c = k.dotProduct(u2.crossProduct(u3));;\n\n  if (c == 0) {\n  \n  \n  q0 = 1.0;\n  q1 = 0.0;\n  q2 = 0.0;\n  q3 = 0.0;\n  return;\n  }\n\n  \n  uRef = u2;\n  vRef = v2;\n\n  }\n\n  }\n\n  \n  c = FastMath.sqrt(c);\n  double inv = 1.0 / (c + c);\n  q1 = inv * k.getX();\n  q2 = inv * k.getY();\n  q3 = inv * k.getZ();\n\n  \n  k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,\n  uRef.getZ() * q1 - uRef.getX() * q3,\n  uRef.getX() * q2 - uRef.getY() * q1);\n  q0 = vRef.dotProduct(k) / (2 * k.getNormSq());\n\n  }",
          "fixed_method": "  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n  \n  double u1u1 = u1.getNormSq();\n  double u2u2 = u2.getNormSq();\n  double v1v1 = v1.getNormSq();\n  double v2v2 = v2.getNormSq();\n  if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n  throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n  }\n\n  \n  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n\n  \n  double u1u2  = u1.dotProduct(u2);\n  double v1v2  = v1.dotProduct(v2);\n  double coeffU = u1u2 / u1u1;\n  double coeffV = v1v2 / u1u1;\n  double beta  = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n  double alpha  = coeffU - beta * coeffV;\n  v2 = new Vector3D(alpha, v1, beta, v2);\n\n  \n  Vector3D uRef  = u1;\n  Vector3D vRef  = v1;\n  Vector3D v1Su1 = v1.subtract(u1);\n  Vector3D v2Su2 = v2.subtract(u2);\n  Vector3D k  = v1Su1.crossProduct(v2Su2);\n  Vector3D u3  = u1.crossProduct(u2);\n  double c  = k.dotProduct(u3);\n  final double inPlaneThreshold = 0.001;\n  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {\n  \n  \n  Vector3D v3 = Vector3D.crossProduct(v1, v2);\n  Vector3D v3Su3 = v3.subtract(u3);\n  k = v1Su1.crossProduct(v3Su3);\n  Vector3D u2Prime = u1.crossProduct(u3);\n  c = k.dotProduct(u2Prime);\n\n  if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) {\n  \n  \n  k = v2Su2.crossProduct(v3Su3);;\n  c = k.dotProduct(u2.crossProduct(u3));;\n\n  if (c <= 0) {\n  \n  \n  q0 = 1.0;\n  q1 = 0.0;\n  q2 = 0.0;\n  q3 = 0.0;\n  return;\n  }\n\n  \n  uRef = u2;\n  vRef = v2;\n\n  }\n\n  }\n\n  \n  c = FastMath.sqrt(c);\n  double inv = 1.0 / (c + c);\n  q1 = inv * k.getX();\n  q2 = inv * k.getY();\n  q3 = inv * k.getZ();\n\n  \n  k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,\n  uRef.getZ() * q1 - uRef.getX() * q3,\n  uRef.getX() * q2 - uRef.getY() * q1);\n  q0 = vRef.dotProduct(k) / (2 * k.getNormSq());\n\n  }",
          "diff": [
            "@@ -341,7 +341,8 @@",
            "   Vector3D k     = v1Su1.crossProduct(v2Su2);\n",
            "   Vector3D u3    = u1.crossProduct(u2);\n",
            "   double c       = k.dotProduct(u3);\n",
            "-  if (c == 0) {\n",
            "+  final double inPlaneThreshold = 0.001;\n",
            "+  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {\n",
            "     // the (q1, q2, q3) vector is close to the (u1, u2) plane\n",
            "     // we try other vectors\n",
            "     Vector3D v3 = Vector3D.crossProduct(v1, v2);\n",
            "@@ -350,13 +351,13 @@",
            "     Vector3D u2Prime = u1.crossProduct(u3);\n",
            "     c = k.dotProduct(u2Prime);\n",
            " \n",
            "-    if (c == 0) {\n",
            "+    if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) {\n",
            "       // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n",
            "       // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n",
            "       k = v2Su2.crossProduct(v3Su3);;\n",
            "       c = k.dotProduct(u2.crossProduct(u3));;\n",
            " \n",
            "-      if (c == 0) {\n",
            "+      if (c <= 0) {\n",
            "         // the (q1, q2, q3) vector is aligned with everything\n",
            "         // this is really the identity rotation\n",
            "         q0 = 1.0;\n"
          ],
          "changed_lines": 7
        }
      ]
    }
  ]
}
