{
  "bug_id": "20",
  "failed_tests": {
    "org.apache.commons.collections.list.TreeListTest": [
      {
        "methodName": "testBugCollections447",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<[A]> but was:<[C]>",
        "fail_line": "        assertEquals(\"A\", li.previous());",
        "test_source": "  public void testBugCollections447() {\n  final List<String> treeList = new TreeList<String>();\n  treeList.add(\"A\");\n  treeList.add(\"B\");\n  treeList.add(\"C\");\n  treeList.add(\"D\");\n  \n  final ListIterator<String> li = treeList.listIterator();\n  assertEquals(\"A\", li.next());\n  assertEquals(\"B\", li.next());\n  \n  assertEquals(\"B\", li.previous());\n  \n  li.remove(); // Deletes \"B\"\n  \n  // previous() after remove() should move to\n  // the element before the one just removed\n  assertEquals(\"A\", li.previous());\n  }  ",
        "stack": [
          "TreeListTest.testBugCollections447 line 268"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/collections/list/TreeList.java",
      "buggy_full_code": "\npackage org.apache.commons.collections.list;\n\nimport java.util.AbstractList;\nimport java.util.Collection;\nimport java.util.ConcurrentModificationException;\nimport java.util.Iterator;\nimport java.util.ListIterator;\nimport java.util.NoSuchElementException;\n\nimport org.apache.commons.collections.OrderedIterator;\n\n\npublic class TreeList<E> extends AbstractList<E> { private AVLNode<E> root; private int size; public TreeList() {\n        super();\n    }\n\n    \n    public TreeList(final Collection<E> coll) {\n        super();\n        addAll(coll);\n    }\n\n    \n    \n    @Override\n    public E get(final int index) {\n        checkInterval(index, 0, size() - 1);\n        return root.get(index).getValue();\n    }\n\n    \n    @Override\n    public int size() {\n        return size;\n    }\n\n    \n    @Override\n    public Iterator<E> iterator() {\n        \n        return listIterator(0);\n    }\n\n    \n    @Override\n    public ListIterator<E> listIterator() {\n        \n        return listIterator(0);\n    }\n\n    \n    @Override\n    public ListIterator<E> listIterator(final int fromIndex) {\n        \n        \n        checkInterval(fromIndex, 0, size());\n        return new TreeListIterator<E>(this, fromIndex);\n    }\n\n    \n    @Override\n    public int indexOf(final Object object) {\n        \n        if (root == null) {\n            return -1;\n        }\n        return root.indexOf(object, root.relativePosition);\n    }\n\n    \n    @Override\n    public boolean contains(final Object object) {\n        return indexOf(object) >= 0;\n    }\n\n    \n    @Override\n    public Object[] toArray() {\n        \n        final Object[] array = new Object[size()];\n        if (root != null) {\n            root.toArray(array, root.relativePosition);\n        }\n        return array;\n    }\n\n    \n    \n    @Override\n    public void add(final int index, final E obj) {\n        modCount++;\n        checkInterval(index, 0, size());\n        if (root == null) {\n            root = new AVLNode<E>(index, obj, null, null);\n        } else {\n            root = root.insert(index, obj);\n        }\n        size++;\n    }\n\n    \n    @Override\n    public E set(final int index, final E obj) {\n        checkInterval(index, 0, size() - 1);\n        final AVLNode<E> node = root.get(index);\n        final E result = node.value;\n        node.setValue(obj);\n        return result;\n    }\n\n    \n    @Override\n    public E remove(final int index) {\n        modCount++;\n        checkInterval(index, 0, size() - 1);\n        final E result = get(index);\n        root = root.remove(index);\n        size--;\n        return result;\n    }\n\n    \n    @Override\n    public void clear() {\n        modCount++;\n        root = null;\n        size = 0;\n    }\n\n    \n    \n    private void checkInterval(final int index, final int startIndex, final int endIndex) {\n        if (index < startIndex || index > endIndex) {\n            throw new IndexOutOfBoundsException(\"Invalid index:\" + index + \", size=\" + size());\n        }\n    }\n\n    \n    \n    static class AVLNode<E> { private AVLNode<E> left; private boolean leftIsPrevious; private AVLNode<E> right; private boolean rightIsNext; private int height; private int relativePosition; private E value; private AVLNode(final int relativePosition, final E obj, final AVLNode<E> rightFollower, final AVLNode<E> leftFollower) {\n            this.relativePosition = relativePosition;\n            value = obj;\n            rightIsNext = true;\n            leftIsPrevious = true;\n            right = rightFollower;\n            left = leftFollower;\n        }\n\n        \n        E getValue() {\n            return value;\n        }\n\n        \n        void setValue(final E obj) {\n            this.value = obj;\n        }\n\n        \n        AVLNode<E> get(final int index) {\n            final int indexRelativeToMe = index - relativePosition;\n\n            if (indexRelativeToMe == 0) {\n                return this;\n            }\n\n            final AVLNode<E> nextNode = indexRelativeToMe < 0 ? getLeftSubTree() : getRightSubTree();\n            if (nextNode == null) {\n                return null;\n            }\n            return nextNode.get(indexRelativeToMe);\n        }\n\n        \n        int indexOf(final Object object, final int index) {\n            if (getLeftSubTree() != null) {\n                final int result = left.indexOf(object, index + left.relativePosition);\n                if (result != -1) {\n                    return result;\n                }\n            }\n            if (value == null ? value == object : value.equals(object)) {\n                return index;\n            }\n            if (getRightSubTree() != null) {\n                return right.indexOf(object, index + right.relativePosition);\n            }\n            return -1;\n        }\n\n        \n        void toArray(final Object[] array, final int index) {\n            array[index] = value;\n            if (getLeftSubTree() != null) {\n                left.toArray(array, index + left.relativePosition);\n            }\n            if (getRightSubTree() != null) {\n                right.toArray(array, index + right.relativePosition);\n            }\n        }\n\n        \n        AVLNode<E> next() {\n            if (rightIsNext || right == null) {\n                return right;\n            }\n            return right.min();\n        }\n\n        \n        AVLNode<E> previous() {\n            if (leftIsPrevious || left == null) {\n                return left;\n            }\n            return left.max();\n        }\n\n        \n        AVLNode<E> insert(final int index, final E obj) {\n            final int indexRelativeToMe = index - relativePosition;\n\n            if (indexRelativeToMe <= 0) {\n                return insertOnLeft(indexRelativeToMe, obj);\n            }\n            return insertOnRight(indexRelativeToMe, obj);\n        }\n\n        private AVLNode<E> insertOnLeft(final int indexRelativeToMe, final E obj) {\n            if (getLeftSubTree() == null) {\n                setLeft(new AVLNode<E>(-1, obj, this, left), null);\n            } else {\n                setLeft(left.insert(indexRelativeToMe, obj), null);\n            }\n\n            if (relativePosition >= 0) {\n                relativePosition++;\n            }\n            AVLNode<E> ret = balance();\n            recalcHeight();\n            return ret;\n        }\n\n        private AVLNode<E> insertOnRight(final int indexRelativeToMe, final E obj) {\n            if (getRightSubTree() == null) {\n                setRight(new AVLNode<E>(+1, obj, right, this), null);\n            } else {\n                setRight(right.insert(indexRelativeToMe, obj), null);\n            }\n            if (relativePosition < 0) {\n                relativePosition--;\n            }\n            AVLNode<E> ret = balance();\n            recalcHeight();\n            return ret;\n        }\n\n        \n        \n        private AVLNode<E> getLeftSubTree() {\n            return leftIsPrevious ? null : left;\n        }\n\n        \n        private AVLNode<E> getRightSubTree() {\n            return rightIsNext ? null : right;\n        }\n\n        \n        private AVLNode<E> max() {\n            return getRightSubTree() == null ? this : right.max();\n        }\n\n        \n        private AVLNode<E> min() {\n            return getLeftSubTree() == null ? this : left.min();\n        }\n\n        \n        AVLNode<E> remove(final int index) {\n            final int indexRelativeToMe = index - relativePosition;\n\n            if (indexRelativeToMe == 0) {\n                return removeSelf();\n            }\n            if (indexRelativeToMe > 0) {\n                setRight(right.remove(indexRelativeToMe), right.right);\n                if (relativePosition < 0) {\n                    relativePosition++;\n                }\n            } else {\n                setLeft(left.remove(indexRelativeToMe), left.left);\n                if (relativePosition > 0) {\n                    relativePosition--;\n                }\n            }\n            recalcHeight();\n            return balance();\n        }\n\n        private AVLNode<E> removeMax() {\n            if (getRightSubTree() == null) {\n                return removeSelf();\n            }\n            setRight(right.removeMax(), right.right);\n            if (relativePosition < 0) {\n                relativePosition++;\n            }\n            recalcHeight();\n            return balance();\n        }\n\n        private AVLNode<E> removeMin() {\n            if (getLeftSubTree() == null) {\n                return removeSelf();\n            }\n            setLeft(left.removeMin(), left.left);\n            if (relativePosition > 0) {\n                relativePosition--;\n            }\n            recalcHeight();\n            return balance();\n        }\n\n        \n        private AVLNode<E> removeSelf() {\n            if (getRightSubTree() == null && getLeftSubTree() == null) {\n                return null;\n            }\n            if (getRightSubTree() == null) {\n                if (relativePosition > 0) {\n                    left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);\n                }\n                left.max().setRight(null, right);\n                return left;\n            }\n            if (getLeftSubTree() == null) {\n                right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);\n                right.min().setLeft(null, left);\n                return right;\n            }\n\n            if (heightRightMinusLeft() > 0) {\n                \n                final AVLNode<E> rightMin = right.min();\n                value = rightMin.value;\n                if (leftIsPrevious) {\n                    left = rightMin.left;\n                }\n                right = right.removeMin();\n                if (relativePosition < 0) {\n                    relativePosition++;\n                }\n            } else {\n                \n                final AVLNode<E> leftMax = left.max();\n                value = leftMax.value;\n                if (rightIsNext) {\n                    right = leftMax.right;\n                }\n                final AVLNode<E> leftPrevious = left.left;\n                left = left.removeMax();\n                if (left == null) {\n                    \n                    \n                    left = leftPrevious;\n                    leftIsPrevious = true;\n                }\n                if (relativePosition > 0) {\n                    relativePosition--;\n                }\n            }\n            recalcHeight();\n            return this;\n        }\n\n        \n        \n        private AVLNode<E> balance() {\n            switch (heightRightMinusLeft()) {\n                case 1 :\n                case 0 :\n                case -1 :\n                    return this;\n                case -2 :\n                    if (left.heightRightMinusLeft() > 0) {\n                        setLeft(left.rotateLeft(), null);\n                    }\n                    return rotateRight();\n                case 2 :\n                    if (right.heightRightMinusLeft() < 0) {\n                        setRight(right.rotateRight(), null);\n                    }\n                    return rotateLeft();\n                default :\n                    throw new RuntimeException(\"tree inconsistent!\");\n            }\n        }\n\n        \n        private int getOffset(final AVLNode<E> node) {\n            if (node == null) {\n                return 0;\n            }\n            return node.relativePosition;\n        }\n\n        \n        private int setOffset(final AVLNode<E> node, final int newOffest) {\n            if (node == null) {\n                return 0;\n            }\n            final int oldOffset = getOffset(node);\n            node.relativePosition = newOffest;\n            return oldOffset;\n        }\n\n        \n        private void recalcHeight() {\n            height = Math.max(\n                getLeftSubTree() == null ? -1 : getLeftSubTree().height,\n                getRightSubTree() == null ? -1 : getRightSubTree().height) + 1;\n        }\n\n        \n        private int getHeight(final AVLNode<E> node) {\n            return node == null ? -1 : node.height;\n        }\n\n        \n        private int heightRightMinusLeft() {\n            return getHeight(getRightSubTree()) - getHeight(getLeftSubTree());\n        }\n\n        private AVLNode<E> rotateLeft() {\n            final AVLNode<E> newTop = right; \n            final AVLNode<E> movedNode = getRightSubTree().getLeftSubTree();\n\n            final int newTopPosition = relativePosition + getOffset(newTop);\n            final int myNewPosition = -newTop.relativePosition;\n            final int movedPosition = getOffset(newTop) + getOffset(movedNode);\n\n            setRight(movedNode, newTop);\n            newTop.setLeft(this, null);\n\n            setOffset(newTop, newTopPosition);\n            setOffset(this, myNewPosition);\n            setOffset(movedNode, movedPosition);\n            return newTop;\n        }\n\n        private AVLNode<E> rotateRight() {\n            final AVLNode<E> newTop = left; \n            final AVLNode<E> movedNode = getLeftSubTree().getRightSubTree();\n\n            final int newTopPosition = relativePosition + getOffset(newTop);\n            final int myNewPosition = -newTop.relativePosition;\n            final int movedPosition = getOffset(newTop) + getOffset(movedNode);\n\n            setLeft(movedNode, newTop);\n            newTop.setRight(this, null);\n\n            setOffset(newTop, newTopPosition);\n            setOffset(this, myNewPosition);\n            setOffset(movedNode, movedPosition);\n            return newTop;\n        }\n\n        \n        private void setLeft(final AVLNode<E> node, final AVLNode<E> previous) {\n            leftIsPrevious = node == null;\n            left = leftIsPrevious ? previous : node;\n            recalcHeight();\n        }\n\n        \n        private void setRight(final AVLNode<E> node, final AVLNode<E> next) {\n            rightIsNext = node == null;\n            right = rightIsNext ? next : node;\n            recalcHeight();\n        }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n        @Override\n        public String toString() {\n            return new StringBuilder()\n                .append(\"AVLNode(\")\n                .append(relativePosition)\n                .append(',')\n                .append(left != null)\n                .append(',')\n                .append(value)\n                .append(',')\n                .append(getRightSubTree() != null)\n                .append(\", faedelung \")\n                .append(rightIsNext)\n                .append(\" )\")\n                .toString();\n        }\n    }\n\n    \n    static class TreeListIterator<E> implements ListIterator<E>, OrderedIterator<E> { protected final TreeList<E> parent; protected AVLNode<E> next; protected int nextIndex; protected AVLNode<E> current; protected int currentIndex; protected int expectedModCount; protected TreeListIterator(final TreeList<E> parent, final int fromIndex) throws IndexOutOfBoundsException {\n            super();\n            this.parent = parent;\n            this.expectedModCount = parent.modCount;\n            this.next = parent.root == null ? null : parent.root.get(fromIndex);\n            this.nextIndex = fromIndex;\n            this.currentIndex = -1;\n        }\n\n        \n        protected void checkModCount() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }\n\n        public boolean hasNext() {\n            return nextIndex < parent.size();\n        }\n\n        public E next() {\n            checkModCount();\n            if (!hasNext()) {\n                throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n            }\n            if (next == null) {\n                next = parent.root.get(nextIndex);\n            }\n            final E value = next.getValue();\n            current = next;\n            currentIndex = nextIndex++;\n            next = next.next();\n            return value;\n        }\n\n        public boolean hasPrevious() {\n            return nextIndex > 0;\n        }\n\n        public E previous() {\n            checkModCount();\n            if (!hasPrevious()) {\n                throw new NoSuchElementException(\"Already at start of list.\");\n            }\n            if (next == null) {\n                next = parent.root.get(nextIndex - 1);\n            } else {\n                next = next.previous();\n            }\n            final E value = next.getValue();\n            current = next;\n            currentIndex = --nextIndex;\n            return value;\n        }\n\n        public int nextIndex() {\n            return nextIndex;\n        }\n\n        public int previousIndex() {\n            return nextIndex() - 1;\n        }\n\n        public void remove() {\n            checkModCount();\n            if (currentIndex == -1) {\n                throw new IllegalStateException();\n            }\n            if (nextIndex == currentIndex) {\n                next = next.next();\n                parent.remove(currentIndex);\n            } else {\n                \n                parent.remove(currentIndex);\n                nextIndex--;\n            }\n            \n            \n            current = null;\n            currentIndex = -1;\n            expectedModCount++;\n        }\n\n        public void set(final E obj) {\n            checkModCount();\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            current.setValue(obj);\n        }\n\n        public void add(final E obj) {\n            checkModCount();\n            parent.add(nextIndex, obj);\n            current = null;\n            currentIndex = -1;\n            nextIndex++;\n            expectedModCount++;\n        }\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.collections.list;\n\nimport java.util.AbstractList;\nimport java.util.Collection;\nimport java.util.ConcurrentModificationException;\nimport java.util.Iterator;\nimport java.util.ListIterator;\nimport java.util.NoSuchElementException;\n\nimport org.apache.commons.collections.OrderedIterator;\n\n\npublic class TreeList<E> extends AbstractList<E> { private AVLNode<E> root; private int size; public TreeList() {\n        super();\n    }\n\n    \n    public TreeList(final Collection<E> coll) {\n        super();\n        addAll(coll);\n    }\n\n    \n    \n    @Override\n    public E get(final int index) {\n        checkInterval(index, 0, size() - 1);\n        return root.get(index).getValue();\n    }\n\n    \n    @Override\n    public int size() {\n        return size;\n    }\n\n    \n    @Override\n    public Iterator<E> iterator() {\n        \n        return listIterator(0);\n    }\n\n    \n    @Override\n    public ListIterator<E> listIterator() {\n        \n        return listIterator(0);\n    }\n\n    \n    @Override\n    public ListIterator<E> listIterator(final int fromIndex) {\n        \n        \n        checkInterval(fromIndex, 0, size());\n        return new TreeListIterator<E>(this, fromIndex);\n    }\n\n    \n    @Override\n    public int indexOf(final Object object) {\n        \n        if (root == null) {\n            return -1;\n        }\n        return root.indexOf(object, root.relativePosition);\n    }\n\n    \n    @Override\n    public boolean contains(final Object object) {\n        return indexOf(object) >= 0;\n    }\n\n    \n    @Override\n    public Object[] toArray() {\n        \n        final Object[] array = new Object[size()];\n        if (root != null) {\n            root.toArray(array, root.relativePosition);\n        }\n        return array;\n    }\n\n    \n    \n    @Override\n    public void add(final int index, final E obj) {\n        modCount++;\n        checkInterval(index, 0, size());\n        if (root == null) {\n            root = new AVLNode<E>(index, obj, null, null);\n        } else {\n            root = root.insert(index, obj);\n        }\n        size++;\n    }\n\n    \n    @Override\n    public E set(final int index, final E obj) {\n        checkInterval(index, 0, size() - 1);\n        final AVLNode<E> node = root.get(index);\n        final E result = node.value;\n        node.setValue(obj);\n        return result;\n    }\n\n    \n    @Override\n    public E remove(final int index) {\n        modCount++;\n        checkInterval(index, 0, size() - 1);\n        final E result = get(index);\n        root = root.remove(index);\n        size--;\n        return result;\n    }\n\n    \n    @Override\n    public void clear() {\n        modCount++;\n        root = null;\n        size = 0;\n    }\n\n    \n    \n    private void checkInterval(final int index, final int startIndex, final int endIndex) {\n        if (index < startIndex || index > endIndex) {\n            throw new IndexOutOfBoundsException(\"Invalid index:\" + index + \", size=\" + size());\n        }\n    }\n\n    \n    \n    static class AVLNode<E> { private AVLNode<E> left; private boolean leftIsPrevious; private AVLNode<E> right; private boolean rightIsNext; private int height; private int relativePosition; private E value; private AVLNode(final int relativePosition, final E obj, final AVLNode<E> rightFollower, final AVLNode<E> leftFollower) {\n            this.relativePosition = relativePosition;\n            value = obj;\n            rightIsNext = true;\n            leftIsPrevious = true;\n            right = rightFollower;\n            left = leftFollower;\n        }\n\n        \n        E getValue() {\n            return value;\n        }\n\n        \n        void setValue(final E obj) {\n            this.value = obj;\n        }\n\n        \n        AVLNode<E> get(final int index) {\n            final int indexRelativeToMe = index - relativePosition;\n\n            if (indexRelativeToMe == 0) {\n                return this;\n            }\n\n            final AVLNode<E> nextNode = indexRelativeToMe < 0 ? getLeftSubTree() : getRightSubTree();\n            if (nextNode == null) {\n                return null;\n            }\n            return nextNode.get(indexRelativeToMe);\n        }\n\n        \n        int indexOf(final Object object, final int index) {\n            if (getLeftSubTree() != null) {\n                final int result = left.indexOf(object, index + left.relativePosition);\n                if (result != -1) {\n                    return result;\n                }\n            }\n            if (value == null ? value == object : value.equals(object)) {\n                return index;\n            }\n            if (getRightSubTree() != null) {\n                return right.indexOf(object, index + right.relativePosition);\n            }\n            return -1;\n        }\n\n        \n        void toArray(final Object[] array, final int index) {\n            array[index] = value;\n            if (getLeftSubTree() != null) {\n                left.toArray(array, index + left.relativePosition);\n            }\n            if (getRightSubTree() != null) {\n                right.toArray(array, index + right.relativePosition);\n            }\n        }\n\n        \n        AVLNode<E> next() {\n            if (rightIsNext || right == null) {\n                return right;\n            }\n            return right.min();\n        }\n\n        \n        AVLNode<E> previous() {\n            if (leftIsPrevious || left == null) {\n                return left;\n            }\n            return left.max();\n        }\n\n        \n        AVLNode<E> insert(final int index, final E obj) {\n            final int indexRelativeToMe = index - relativePosition;\n\n            if (indexRelativeToMe <= 0) {\n                return insertOnLeft(indexRelativeToMe, obj);\n            }\n            return insertOnRight(indexRelativeToMe, obj);\n        }\n\n        private AVLNode<E> insertOnLeft(final int indexRelativeToMe, final E obj) {\n            if (getLeftSubTree() == null) {\n                setLeft(new AVLNode<E>(-1, obj, this, left), null);\n            } else {\n                setLeft(left.insert(indexRelativeToMe, obj), null);\n            }\n\n            if (relativePosition >= 0) {\n                relativePosition++;\n            }\n            AVLNode<E> ret = balance();\n            recalcHeight();\n            return ret;\n        }\n\n        private AVLNode<E> insertOnRight(final int indexRelativeToMe, final E obj) {\n            if (getRightSubTree() == null) {\n                setRight(new AVLNode<E>(+1, obj, right, this), null);\n            } else {\n                setRight(right.insert(indexRelativeToMe, obj), null);\n            }\n            if (relativePosition < 0) {\n                relativePosition--;\n            }\n            AVLNode<E> ret = balance();\n            recalcHeight();\n            return ret;\n        }\n\n        \n        \n        private AVLNode<E> getLeftSubTree() {\n            return leftIsPrevious ? null : left;\n        }\n\n        \n        private AVLNode<E> getRightSubTree() {\n            return rightIsNext ? null : right;\n        }\n\n        \n        private AVLNode<E> max() {\n            return getRightSubTree() == null ? this : right.max();\n        }\n\n        \n        private AVLNode<E> min() {\n            return getLeftSubTree() == null ? this : left.min();\n        }\n\n        \n        AVLNode<E> remove(final int index) {\n            final int indexRelativeToMe = index - relativePosition;\n\n            if (indexRelativeToMe == 0) {\n                return removeSelf();\n            }\n            if (indexRelativeToMe > 0) {\n                setRight(right.remove(indexRelativeToMe), right.right);\n                if (relativePosition < 0) {\n                    relativePosition++;\n                }\n            } else {\n                setLeft(left.remove(indexRelativeToMe), left.left);\n                if (relativePosition > 0) {\n                    relativePosition--;\n                }\n            }\n            recalcHeight();\n            return balance();\n        }\n\n        private AVLNode<E> removeMax() {\n            if (getRightSubTree() == null) {\n                return removeSelf();\n            }\n            setRight(right.removeMax(), right.right);\n            if (relativePosition < 0) {\n                relativePosition++;\n            }\n            recalcHeight();\n            return balance();\n        }\n\n        private AVLNode<E> removeMin() {\n            if (getLeftSubTree() == null) {\n                return removeSelf();\n            }\n            setLeft(left.removeMin(), left.left);\n            if (relativePosition > 0) {\n                relativePosition--;\n            }\n            recalcHeight();\n            return balance();\n        }\n\n        \n        private AVLNode<E> removeSelf() {\n            if (getRightSubTree() == null && getLeftSubTree() == null) {\n                return null;\n            }\n            if (getRightSubTree() == null) {\n                if (relativePosition > 0) {\n                    left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);\n                }\n                left.max().setRight(null, right);\n                return left;\n            }\n            if (getLeftSubTree() == null) {\n                right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);\n                right.min().setLeft(null, left);\n                return right;\n            }\n\n            if (heightRightMinusLeft() > 0) {\n                \n                final AVLNode<E> rightMin = right.min();\n                value = rightMin.value;\n                if (leftIsPrevious) {\n                    left = rightMin.left;\n                }\n                right = right.removeMin();\n                if (relativePosition < 0) {\n                    relativePosition++;\n                }\n            } else {\n                \n                final AVLNode<E> leftMax = left.max();\n                value = leftMax.value;\n                if (rightIsNext) {\n                    right = leftMax.right;\n                }\n                final AVLNode<E> leftPrevious = left.left;\n                left = left.removeMax();\n                if (left == null) {\n                    \n                    \n                    left = leftPrevious;\n                    leftIsPrevious = true;\n                }\n                if (relativePosition > 0) {\n                    relativePosition--;\n                }\n            }\n            recalcHeight();\n            return this;\n        }\n\n        \n        \n        private AVLNode<E> balance() {\n            switch (heightRightMinusLeft()) {\n                case 1 :\n                case 0 :\n                case -1 :\n                    return this;\n                case -2 :\n                    if (left.heightRightMinusLeft() > 0) {\n                        setLeft(left.rotateLeft(), null);\n                    }\n                    return rotateRight();\n                case 2 :\n                    if (right.heightRightMinusLeft() < 0) {\n                        setRight(right.rotateRight(), null);\n                    }\n                    return rotateLeft();\n                default :\n                    throw new RuntimeException(\"tree inconsistent!\");\n            }\n        }\n\n        \n        private int getOffset(final AVLNode<E> node) {\n            if (node == null) {\n                return 0;\n            }\n            return node.relativePosition;\n        }\n\n        \n        private int setOffset(final AVLNode<E> node, final int newOffest) {\n            if (node == null) {\n                return 0;\n            }\n            final int oldOffset = getOffset(node);\n            node.relativePosition = newOffest;\n            return oldOffset;\n        }\n\n        \n        private void recalcHeight() {\n            height = Math.max(\n                getLeftSubTree() == null ? -1 : getLeftSubTree().height,\n                getRightSubTree() == null ? -1 : getRightSubTree().height) + 1;\n        }\n\n        \n        private int getHeight(final AVLNode<E> node) {\n            return node == null ? -1 : node.height;\n        }\n\n        \n        private int heightRightMinusLeft() {\n            return getHeight(getRightSubTree()) - getHeight(getLeftSubTree());\n        }\n\n        private AVLNode<E> rotateLeft() {\n            final AVLNode<E> newTop = right; \n            final AVLNode<E> movedNode = getRightSubTree().getLeftSubTree();\n\n            final int newTopPosition = relativePosition + getOffset(newTop);\n            final int myNewPosition = -newTop.relativePosition;\n            final int movedPosition = getOffset(newTop) + getOffset(movedNode);\n\n            setRight(movedNode, newTop);\n            newTop.setLeft(this, null);\n\n            setOffset(newTop, newTopPosition);\n            setOffset(this, myNewPosition);\n            setOffset(movedNode, movedPosition);\n            return newTop;\n        }\n\n        private AVLNode<E> rotateRight() {\n            final AVLNode<E> newTop = left; \n            final AVLNode<E> movedNode = getLeftSubTree().getRightSubTree();\n\n            final int newTopPosition = relativePosition + getOffset(newTop);\n            final int myNewPosition = -newTop.relativePosition;\n            final int movedPosition = getOffset(newTop) + getOffset(movedNode);\n\n            setLeft(movedNode, newTop);\n            newTop.setRight(this, null);\n\n            setOffset(newTop, newTopPosition);\n            setOffset(this, myNewPosition);\n            setOffset(movedNode, movedPosition);\n            return newTop;\n        }\n\n        \n        private void setLeft(final AVLNode<E> node, final AVLNode<E> previous) {\n            leftIsPrevious = node == null;\n            left = leftIsPrevious ? previous : node;\n            recalcHeight();\n        }\n\n        \n        private void setRight(final AVLNode<E> node, final AVLNode<E> next) {\n            rightIsNext = node == null;\n            right = rightIsNext ? next : node;\n            recalcHeight();\n        }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n        @Override\n        public String toString() {\n            return new StringBuilder()\n                .append(\"AVLNode(\")\n                .append(relativePosition)\n                .append(',')\n                .append(left != null)\n                .append(',')\n                .append(value)\n                .append(',')\n                .append(getRightSubTree() != null)\n                .append(\", faedelung \")\n                .append(rightIsNext)\n                .append(\" )\")\n                .toString();\n        }\n    }\n\n    \n    static class TreeListIterator<E> implements ListIterator<E>, OrderedIterator<E> { protected final TreeList<E> parent; protected AVLNode<E> next; protected int nextIndex; protected AVLNode<E> current; protected int currentIndex; protected int expectedModCount; protected TreeListIterator(final TreeList<E> parent, final int fromIndex) throws IndexOutOfBoundsException {\n            super();\n            this.parent = parent;\n            this.expectedModCount = parent.modCount;\n            this.next = parent.root == null ? null : parent.root.get(fromIndex);\n            this.nextIndex = fromIndex;\n            this.currentIndex = -1;\n        }\n\n        \n        protected void checkModCount() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }\n\n        public boolean hasNext() {\n            return nextIndex < parent.size();\n        }\n\n        public E next() {\n            checkModCount();\n            if (!hasNext()) {\n                throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n            }\n            if (next == null) {\n                next = parent.root.get(nextIndex);\n            }\n            final E value = next.getValue();\n            current = next;\n            currentIndex = nextIndex++;\n            next = next.next();\n            return value;\n        }\n\n        public boolean hasPrevious() {\n            return nextIndex > 0;\n        }\n\n        public E previous() {\n            checkModCount();\n            if (!hasPrevious()) {\n                throw new NoSuchElementException(\"Already at start of list.\");\n            }\n            if (next == null) {\n                next = parent.root.get(nextIndex - 1);\n            } else {\n                next = next.previous();\n            }\n            final E value = next.getValue();\n            current = next;\n            currentIndex = --nextIndex;\n            return value;\n        }\n\n        public int nextIndex() {\n            return nextIndex;\n        }\n\n        public int previousIndex() {\n            return nextIndex() - 1;\n        }\n\n        public void remove() {\n            checkModCount();\n            if (currentIndex == -1) {\n                throw new IllegalStateException();\n            }\n            parent.remove(currentIndex);\n            if (nextIndex != currentIndex) {\n                \n                nextIndex--;\n            }\n            \n            \n            next = null;\n            current = null;\n            currentIndex = -1;\n            expectedModCount++;\n        }\n\n        public void set(final E obj) {\n            checkModCount();\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            current.setValue(obj);\n        }\n\n        public void add(final E obj) {\n            checkModCount();\n            parent.add(nextIndex, obj);\n            current = null;\n            currentIndex = -1;\n            nextIndex++;\n            expectedModCount++;\n        }\n    }\n\n}\n",
      "buggy_signatures": [
        "public class TreeList<E> extends AbstractList<E> { private AVLNode<E> root; private int size; public TreeList()",
        "public TreeList(final Collection<E> coll)",
        "public E get(final int index)",
        "public int size()",
        "public Iterator<E> iterator()",
        "public ListIterator<E> listIterator()",
        "public ListIterator<E> listIterator(final int fromIndex)",
        "public int indexOf(final Object object)",
        "public boolean contains(final Object object)",
        "public Object[] toArray()",
        "public void add(final int index, final E obj)",
        "public E set(final int index, final E obj)",
        "public E remove(final int index)",
        "public void clear()",
        "private void checkInterval(final int index, final int startIndex, final int endIndex)",
        "static class AVLNode<E> { private AVLNode<E> left; private boolean leftIsPrevious; private AVLNode<E> right; private boolean rightIsNext; private int height; private int relativePosition; private E value; private AVLNode(final int relativePosition, final E obj, final AVLNode<E> rightFollower, final AVLNode<E> leftFollower)",
        "private AVLNode<E> insertOnLeft(final int indexRelativeToMe, final E obj)",
        "private AVLNode<E> insertOnRight(final int indexRelativeToMe, final E obj)",
        "private AVLNode<E> getLeftSubTree()",
        "private AVLNode<E> getRightSubTree()",
        "private AVLNode<E> max()",
        "private AVLNode<E> min()",
        "private AVLNode<E> removeMax()",
        "private AVLNode<E> removeMin()",
        "private AVLNode<E> removeSelf()",
        "private AVLNode<E> balance()",
        "private int getOffset(final AVLNode<E> node)",
        "private int setOffset(final AVLNode<E> node, final int newOffest)",
        "private void recalcHeight()",
        "private int getHeight(final AVLNode<E> node)",
        "private int heightRightMinusLeft()",
        "private AVLNode<E> rotateLeft()",
        "private AVLNode<E> rotateRight()",
        "private void setLeft(final AVLNode<E> node, final AVLNode<E> previous)",
        "private void setRight(final AVLNode<E> node, final AVLNode<E> next)",
        "public String toString()",
        "static class TreeListIterator<E> implements ListIterator<E>, OrderedIterator<E> { protected final TreeList<E> parent; protected AVLNode<E> next; protected int nextIndex; protected AVLNode<E> current; protected int currentIndex; protected int expectedModCount; protected TreeListIterator(final TreeList<E> parent, final int fromIndex) throws IndexOutOfBoundsException",
        "protected void checkModCount()",
        "public boolean hasNext()",
        "public E next()",
        "public boolean hasPrevious()",
        "public E previous()",
        "public int nextIndex()",
        "public int previousIndex()",
        "public void remove()",
        "public void set(final E obj)",
        "public void add(final E obj)"
      ],
      "fixed_signatures": [
        "public class TreeList<E> extends AbstractList<E> { private AVLNode<E> root; private int size; public TreeList()",
        "public TreeList(final Collection<E> coll)",
        "public E get(final int index)",
        "public int size()",
        "public Iterator<E> iterator()",
        "public ListIterator<E> listIterator()",
        "public ListIterator<E> listIterator(final int fromIndex)",
        "public int indexOf(final Object object)",
        "public boolean contains(final Object object)",
        "public Object[] toArray()",
        "public void add(final int index, final E obj)",
        "public E set(final int index, final E obj)",
        "public E remove(final int index)",
        "public void clear()",
        "private void checkInterval(final int index, final int startIndex, final int endIndex)",
        "static class AVLNode<E> { private AVLNode<E> left; private boolean leftIsPrevious; private AVLNode<E> right; private boolean rightIsNext; private int height; private int relativePosition; private E value; private AVLNode(final int relativePosition, final E obj, final AVLNode<E> rightFollower, final AVLNode<E> leftFollower)",
        "private AVLNode<E> insertOnLeft(final int indexRelativeToMe, final E obj)",
        "private AVLNode<E> insertOnRight(final int indexRelativeToMe, final E obj)",
        "private AVLNode<E> getLeftSubTree()",
        "private AVLNode<E> getRightSubTree()",
        "private AVLNode<E> max()",
        "private AVLNode<E> min()",
        "private AVLNode<E> removeMax()",
        "private AVLNode<E> removeMin()",
        "private AVLNode<E> removeSelf()",
        "private AVLNode<E> balance()",
        "private int getOffset(final AVLNode<E> node)",
        "private int setOffset(final AVLNode<E> node, final int newOffest)",
        "private void recalcHeight()",
        "private int getHeight(final AVLNode<E> node)",
        "private int heightRightMinusLeft()",
        "private AVLNode<E> rotateLeft()",
        "private AVLNode<E> rotateRight()",
        "private void setLeft(final AVLNode<E> node, final AVLNode<E> previous)",
        "private void setRight(final AVLNode<E> node, final AVLNode<E> next)",
        "public String toString()",
        "static class TreeListIterator<E> implements ListIterator<E>, OrderedIterator<E> { protected final TreeList<E> parent; protected AVLNode<E> next; protected int nextIndex; protected AVLNode<E> current; protected int currentIndex; protected int expectedModCount; protected TreeListIterator(final TreeList<E> parent, final int fromIndex) throws IndexOutOfBoundsException",
        "protected void checkModCount()",
        "public boolean hasNext()",
        "public E next()",
        "public boolean hasPrevious()",
        "public E previous()",
        "public int nextIndex()",
        "public int previousIndex()",
        "public void remove()",
        "public void set(final E obj)",
        "public void add(final E obj)"
      ],
      "methods": [
        {
          "buggy_method": "  public void remove() {\n  checkModCount();\n  if (currentIndex == -1) {\n  throw new IllegalStateException();\n  }\n  if (nextIndex == currentIndex) {\n  next = next.next();\n  parent.remove(currentIndex);\n  } else {\n  \n  parent.remove(currentIndex);\n  nextIndex--;\n  }\n  \n  \n  current = null;\n  currentIndex = -1;\n  expectedModCount++;\n  }",
          "fixed_method": "  public void remove() {\n  checkModCount();\n  if (currentIndex == -1) {\n  throw new IllegalStateException();\n  }\n  parent.remove(currentIndex);\n  if (nextIndex != currentIndex) {\n  \n  nextIndex--;\n  }\n  \n  \n  next = null;\n  current = null;\n  currentIndex = -1;\n  expectedModCount++;\n  }",
          "diff": [
            "@@ -900,16 +900,14 @@",
            "             if (currentIndex == -1) {\n",
            "                 throw new IllegalStateException();\n",
            "             }\n",
            "-            if (nextIndex == currentIndex) {\n",
            "-                next = next.next();\n",
            "-                parent.remove(currentIndex);\n",
            "-            } else {\n",
            "+            parent.remove(currentIndex);\n",
            "+            if (nextIndex != currentIndex) {\n",
            "                 // remove() following next()\n",
            "-                parent.remove(currentIndex);\n",
            "                 nextIndex--;\n",
            "             }\n",
            "             // the AVL node referenced by next may have become stale after a remove\n",
            "             // reset it now: will be retrieved by next call to next()/previous() via nextIndex\n",
            "+            next = null;\n",
            "             current = null;\n",
            "             currentIndex = -1;\n",
            "             expectedModCount++;\n"
          ],
          "changed_lines": 8
        }
      ]
    }
  ]
}
