{
  "bug_id": "19",
  "failed_tests": {
    "org.jfree.chart.plot.junit.CategoryPlotTests": [
      {
        "methodName": "testGetRangeAxisIndex",
        "error": "junit.framework.AssertionFailedError",
        "message": "",
        "fail_line": "        assertTrue(pass);",
        "test_source": "  public void testGetRangeAxisIndex() {\n  CategoryAxis domainAxis1 = new CategoryAxis(\"X1\");\n  NumberAxis rangeAxis1 = new NumberAxis(\"Y1\");\n  NumberAxis rangeAxis2 = new NumberAxis(\"Y2\");\n  CategoryPlot plot = new CategoryPlot(null, domainAxis1, rangeAxis1, \n  null);\n  assertEquals(0, plot.getRangeAxisIndex(rangeAxis1));\n  assertEquals(-1, plot.getRangeAxisIndex(rangeAxis2));\n  plot.setRangeAxis(1, rangeAxis2);\n  assertEquals(1, plot.getRangeAxisIndex(rangeAxis2));\n  assertEquals(-1, plot.getRangeAxisIndex(new NumberAxis(\"Y2\")));\n  boolean pass = false;\n  try {\n  plot.getRangeAxisIndex(null);\n  }\n  catch (IllegalArgumentException e) {\n  pass = true;\n  }\n  assertTrue(pass);\n  }",
        "stack": [
          "CategoryPlotTests.testGetRangeAxisIndex line 761"
        ]
      },
      {
        "methodName": "testGetDomainAxisIndex",
        "error": "junit.framework.AssertionFailedError",
        "message": "",
        "fail_line": "        assertTrue(pass);",
        "test_source": "  public void testGetDomainAxisIndex() {\n  CategoryAxis domainAxis1 = new CategoryAxis(\"X1\");\n  CategoryAxis domainAxis2 = new CategoryAxis(\"X2\");\n  NumberAxis rangeAxis1 = new NumberAxis(\"Y1\");\n  CategoryPlot plot = new CategoryPlot(null, domainAxis1, rangeAxis1, \n  null);\n  assertEquals(0, plot.getDomainAxisIndex(domainAxis1));\n  assertEquals(-1, plot.getDomainAxisIndex(domainAxis2));\n  plot.setDomainAxis(1, domainAxis2);\n  assertEquals(1, plot.getDomainAxisIndex(domainAxis2));\n  assertEquals(-1, plot.getDomainAxisIndex(new CategoryAxis(\"X2\")));\n  boolean pass = false;\n  try {\n  plot.getDomainAxisIndex(null);\n  }\n  catch (IllegalArgumentException e) {\n  pass = true;\n  }\n  assertTrue(pass);\n  }",
        "stack": [
          "CategoryPlotTests.testGetDomainAxisIndex line 737"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jfree/chart/plot/CategoryPlot.java",
      "buggy_full_code": "\n\npackage org.jfree.chart.plot;\n\nimport java.awt.AlphaComposite;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Composite;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ResourceBundle;\nimport java.util.Set;\n\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.annotations.CategoryAnnotation;\nimport org.jfree.chart.axis.Axis;\nimport org.jfree.chart.axis.AxisCollection;\nimport org.jfree.chart.axis.AxisLocation;\nimport org.jfree.chart.axis.AxisSpace;\nimport org.jfree.chart.axis.AxisState;\nimport org.jfree.chart.axis.CategoryAnchor;\nimport org.jfree.chart.axis.CategoryAxis;\nimport org.jfree.chart.axis.ValueAxis;\nimport org.jfree.chart.axis.ValueTick;\nimport org.jfree.chart.event.ChartChangeEventType;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.event.RendererChangeEvent;\nimport org.jfree.chart.event.RendererChangeListener;\nimport org.jfree.chart.renderer.category.CategoryItemRenderer;\nimport org.jfree.chart.renderer.category.CategoryItemRendererState;\nimport org.jfree.chart.util.Layer;\nimport org.jfree.chart.util.ObjectList;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.chart.util.SortOrder;\nimport org.jfree.data.Range;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.general.Dataset;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\n\n\npublic class CategoryPlot extends Plot implements ValueAxisPlot, Zoomable, RendererChangeListener, Cloneable, PublicCloneable, Serializable { private static final long serialVersionUID = -3537691700434728188L; public static final boolean DEFAULT_DOMAIN_GRIDLINES_VISIBLE = false; public static final boolean DEFAULT_RANGE_GRIDLINES_VISIBLE = true; public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke(0.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0.0f, new float[] {2.0f, 2.0f}, 0.0f); public static final Paint DEFAULT_GRIDLINE_PAINT = Color.WHITE; public static final Font DEFAULT_VALUE_LABEL_FONT = new Font(\"SansSerif\", Font.PLAIN, 10); public static final boolean DEFAULT_CROSSHAIR_VISIBLE = false; public static final Stroke DEFAULT_CROSSHAIR_STROKE = DEFAULT_GRIDLINE_STROKE; public static final Paint DEFAULT_CROSSHAIR_PAINT = Color.blue; protected static ResourceBundle localizationResources = ResourceBundle.getBundle( \"org.jfree.chart.plot.LocalizationBundle\"); private PlotOrientation orientation; private RectangleInsets axisOffset; private ObjectList domainAxes; private ObjectList domainAxisLocations; private boolean drawSharedDomainAxis; private ObjectList rangeAxes; private ObjectList rangeAxisLocations; private ObjectList datasets; private ObjectList datasetToDomainAxisMap; private ObjectList datasetToRangeAxisMap; private ObjectList renderers; private DatasetRenderingOrder renderingOrder = DatasetRenderingOrder.REVERSE; private SortOrder columnRenderingOrder = SortOrder.ASCENDING; private SortOrder rowRenderingOrder = SortOrder.ASCENDING; private boolean domainGridlinesVisible; private CategoryAnchor domainGridlinePosition; private transient Stroke domainGridlineStroke; private transient Paint domainGridlinePaint; private boolean rangeGridlinesVisible; private transient Stroke rangeGridlineStroke; private transient Paint rangeGridlinePaint; private double anchorValue; private boolean rangeCrosshairVisible; private double rangeCrosshairValue; private transient Stroke rangeCrosshairStroke; private transient Paint rangeCrosshairPaint; private boolean rangeCrosshairLockedOnData = true; private Map foregroundDomainMarkers; private Map backgroundDomainMarkers; private Map foregroundRangeMarkers; private Map backgroundRangeMarkers; private List annotations; private int weight; private AxisSpace fixedDomainAxisSpace; private AxisSpace fixedRangeAxisSpace; private LegendItemCollection fixedLegendItems; public CategoryPlot() {\n        this(null, null, null, null);\n    }\n\n    \n    public CategoryPlot(CategoryDataset dataset, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryItemRenderer renderer) {\n\n        super();\n\n        this.orientation = PlotOrientation.VERTICAL;\n\n        \n        this.domainAxes = new ObjectList();\n        this.domainAxisLocations = new ObjectList();\n        this.rangeAxes = new ObjectList();\n        this.rangeAxisLocations = new ObjectList();\n        \n        this.datasetToDomainAxisMap = new ObjectList();\n        this.datasetToRangeAxisMap = new ObjectList();\n\n        this.renderers = new ObjectList();\n\n        this.datasets = new ObjectList();\n        this.datasets.set(0, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n\n        this.axisOffset = new RectangleInsets(4.0, 4.0, 4.0, 4.0);\n\n        setDomainAxisLocation(AxisLocation.BOTTOM_OR_LEFT, false);\n        setRangeAxisLocation(AxisLocation.TOP_OR_LEFT, false);\n\n        this.renderers.set(0, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n\n        this.domainAxes.set(0, domainAxis);\n        this.mapDatasetToDomainAxis(0, 0);\n        if (domainAxis != null) {\n            domainAxis.setPlot(this);\n            domainAxis.addChangeListener(this);\n        }\n        this.drawSharedDomainAxis = false;\n\n        this.rangeAxes.set(0, rangeAxis);\n        this.mapDatasetToRangeAxis(0, 0);\n        if (rangeAxis != null) {\n            rangeAxis.setPlot(this);\n            rangeAxis.addChangeListener(this);\n        }\n        \n        configureDomainAxes();\n        configureRangeAxes();\n\n        this.domainGridlinesVisible = DEFAULT_DOMAIN_GRIDLINES_VISIBLE;\n        this.domainGridlinePosition = CategoryAnchor.MIDDLE;\n        this.domainGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.domainGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.rangeGridlinesVisible = DEFAULT_RANGE_GRIDLINES_VISIBLE;\n        this.rangeGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.rangeGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.foregroundDomainMarkers = new HashMap();\n        this.backgroundDomainMarkers = new HashMap();\n        this.foregroundRangeMarkers = new HashMap();\n        this.backgroundRangeMarkers = new HashMap();\n\n        Marker baseline = new ValueMarker(0.0, new Color(0.8f, 0.8f, 0.8f, \n                0.5f), new BasicStroke(1.0f), new Color(0.85f, 0.85f, 0.95f, \n                0.5f), new BasicStroke(1.0f), 0.6f);\n        addRangeMarker(baseline, Layer.BACKGROUND);\n\n        this.anchorValue = 0.0;\n\n        this.rangeCrosshairVisible = DEFAULT_CROSSHAIR_VISIBLE;\n        this.rangeCrosshairValue = 0.0;\n        this.rangeCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\n        this.rangeCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\n        \n        this.annotations = new java.util.ArrayList();\n\n    }\n    \n    \n    public String getPlotType() {\n        return localizationResources.getString(\"Category_Plot\");\n    }\n\n    \n    public PlotOrientation getOrientation() {\n        return this.orientation;\n    }\n\n    \n    public void setOrientation(PlotOrientation orientation) {\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n        this.orientation = orientation;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public RectangleInsets getAxisOffset() {\n        return this.axisOffset;\n    }\n\n    \n    public void setAxisOffset(RectangleInsets offset) {\n        if (offset == null) {\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");   \n        }\n        this.axisOffset = offset;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public CategoryAxis getDomainAxis() {\n        return getDomainAxis(0);\n    }\n\n    \n    public CategoryAxis getDomainAxis(int index) {\n        CategoryAxis result = null;\n        if (index < this.domainAxes.size()) {\n            result = (CategoryAxis) this.domainAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot cp = (CategoryPlot) parent;\n                result = cp.getDomainAxis(index);\n            }\n        }\n        return result;\n    }\n\n    \n    public void setDomainAxis(CategoryAxis axis) {\n        setDomainAxis(0, axis);\n    }\n\n    \n    public void setDomainAxis(int index, CategoryAxis axis) {\n        setDomainAxis(index, axis, true);\n    }\n \n    \n    public void setDomainAxis(int index, CategoryAxis axis, boolean notify) {\n        CategoryAxis existing = (CategoryAxis) this.domainAxes.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.domainAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    \n    public void setDomainAxes(CategoryAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setDomainAxis(i, axes[i], false);   \n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public int getDomainAxisIndex(CategoryAxis axis) {\n        return this.domainAxes.indexOf(axis);\n    }\n    \n    \n    public AxisLocation getDomainAxisLocation() {\n        return getDomainAxisLocation(0);\n    }\n\n    \n    public AxisLocation getDomainAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.domainAxisLocations.size()) {\n            result = (AxisLocation) this.domainAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getDomainAxisLocation(0));\n        }\n        return result;\n    }\n\n    \n    public void setDomainAxisLocation(AxisLocation location) {\n        \n        setDomainAxisLocation(0, location, true);\n    }\n\n    \n    public void setDomainAxisLocation(AxisLocation location, boolean notify) {\n        \n        setDomainAxisLocation(0, location, notify);\n    }\n\n    \n    public void setDomainAxisLocation(int index, AxisLocation location) {\n        \n        setDomainAxisLocation(index, location, true);\n    }\n    \n    \n    public void setDomainAxisLocation(int index, AxisLocation location, boolean notify) {\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.domainAxisLocations.set(index, location);\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    \n    public RectangleEdge getDomainAxisEdge() {\n        return getDomainAxisEdge(0);\n    }\n\n    \n    public RectangleEdge getDomainAxisEdge(int index) {\n        RectangleEdge result = null;\n        AxisLocation location = getDomainAxisLocation(index);\n        if (location != null) {\n            result = Plot.resolveDomainAxisLocation(location, this.orientation);\n        }\n        else {\n            result = RectangleEdge.opposite(getDomainAxisEdge(0));\n        }\n        return result;\n    }\n\n    \n    public int getDomainAxisCount() {\n        return this.domainAxes.size();\n    }\n\n    \n    public void clearDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.domainAxes.clear();\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public void configureDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    \n    public ValueAxis getRangeAxis() {\n        return getRangeAxis(0);\n    }\n\n    \n    public ValueAxis getRangeAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.rangeAxes.size()) {\n            result = (ValueAxis) this.rangeAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot cp = (CategoryPlot) parent;\n                result = cp.getRangeAxis(index);\n            }\n        }\n        return result;\n    }\n\n    \n    public void setRangeAxis(ValueAxis axis) {\n        setRangeAxis(0, axis);\n    }\n\n    \n    public void setRangeAxis(int index, ValueAxis axis) {\n        setRangeAxis(index, axis, true);\n    }\n        \n    \n    public void setRangeAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing = (ValueAxis) this.rangeAxes.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.rangeAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    \n    public void setRangeAxes(ValueAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setRangeAxis(i, axes[i], false);   \n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n\n    \n    public int getRangeAxisIndex(ValueAxis axis) {\n        int result = this.rangeAxes.indexOf(axis);\n        if (result < 0) { \n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot p = (CategoryPlot) parent;\n                result = p.getRangeAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n    \n    \n    public AxisLocation getRangeAxisLocation() {\n        return getRangeAxisLocation(0);\n    }\n\n    \n    public AxisLocation getRangeAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.rangeAxisLocations.size()) {\n            result = (AxisLocation) this.rangeAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getRangeAxisLocation(0));\n        }\n        return result;\n    }\n\n    \n    public void setRangeAxisLocation(AxisLocation location) {\n        \n        setRangeAxisLocation(location, true);\n    }\n\n    \n    public void setRangeAxisLocation(AxisLocation location, boolean notify) {\n        setRangeAxisLocation(0, location, notify);\n    }\n\n    \n    public void setRangeAxisLocation(int index, AxisLocation location) {\n        setRangeAxisLocation(index, location, true);\n    }\n\n    \n    public void setRangeAxisLocation(int index, AxisLocation location, boolean notify) {\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.rangeAxisLocations.set(index, location);\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    \n    public RectangleEdge getRangeAxisEdge() {\n        return getRangeAxisEdge(0);\n    }\n\n    \n    public RectangleEdge getRangeAxisEdge(int index) {\n        AxisLocation location = getRangeAxisLocation(index);\n        RectangleEdge result = Plot.resolveRangeAxisLocation(location, \n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getRangeAxisEdge(0));\n        }\n        return result;\n    }\n\n    \n    public int getRangeAxisCount() {\n        return this.rangeAxes.size();\n    }\n\n    \n    public void clearRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.rangeAxes.clear();\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public void configureRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    \n    public CategoryDataset getDataset() {\n        return getDataset(0);\n    }\n\n    \n    public CategoryDataset getDataset(int index) {\n        CategoryDataset result = null;\n        if (this.datasets.size() > index) {\n            result = (CategoryDataset) this.datasets.get(index);\n        }\n        return result;\n    }\n\n    \n    public void setDataset(CategoryDataset dataset) {\n        setDataset(0, dataset);\n    }\n\n    \n    public void setDataset(int index, CategoryDataset dataset) {\n        \n        CategoryDataset existing = (CategoryDataset) this.datasets.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        this.datasets.set(index, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n        \n        \n        DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n        datasetChanged(event);\n        \n    }\n\n    \n    public int getDatasetCount() {\n        return this.datasets.size();\n    }\n\n    \n    public void mapDatasetToDomainAxis(int index, int axisIndex) {\n        this.datasetToDomainAxisMap.set(index, new Integer(axisIndex));  \n        \n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));  \n    }\n\n    \n    public CategoryAxis getDomainAxisForDataset(int index) {\n        CategoryAxis result = getDomainAxis();\n        Integer axisIndex = (Integer) this.datasetToDomainAxisMap.get(index);\n        if (axisIndex != null) {\n            result = getDomainAxis(axisIndex.intValue());\n        }\n        return result;    \n    }\n    \n    \n    public void mapDatasetToRangeAxis(int index, int axisIndex) {\n        this.datasetToRangeAxisMap.set(index, new Integer(axisIndex));\n        \n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));  \n    }\n\n    \n    public ValueAxis getRangeAxisForDataset(int index) {\n        ValueAxis result = getRangeAxis();\n        Integer axisIndex = (Integer) this.datasetToRangeAxisMap.get(index);\n        if (axisIndex != null) {\n            result = getRangeAxis(axisIndex.intValue());\n        }\n        return result;    \n    }\n    \n    \n    public CategoryItemRenderer getRenderer() {\n        return getRenderer(0);\n    }\n\n    \n    public CategoryItemRenderer getRenderer(int index) {\n        CategoryItemRenderer result = null;\n        if (this.renderers.size() > index) {\n            result = (CategoryItemRenderer) this.renderers.get(index);\n        }\n        return result;\n    }\n    \n    \n    public void setRenderer(CategoryItemRenderer renderer) {\n        setRenderer(0, renderer, true);\n    }\n\n    \n    public void setRenderer(CategoryItemRenderer renderer, boolean notify) {\n        setRenderer(0, renderer, notify);\n    }\n\n    \n    public void setRenderer(int index, CategoryItemRenderer renderer) {\n        setRenderer(index, renderer, true);   \n    }\n\n    \n    public void setRenderer(int index, CategoryItemRenderer renderer, boolean notify) {\n        \n        \n        CategoryItemRenderer existing \n            = (CategoryItemRenderer) this.renderers.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        \n        \n        this.renderers.set(index, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n        \n        configureDomainAxes();\n        configureRangeAxes();\n        \n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    \n    public void setRenderers(CategoryItemRenderer[] renderers) {\n        for (int i = 0; i < renderers.length; i++) {\n            setRenderer(i, renderers[i], false);   \n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public CategoryItemRenderer getRendererForDataset(CategoryDataset dataset) {\n        CategoryItemRenderer result = null;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (this.datasets.get(i) == dataset) {\n                result = (CategoryItemRenderer) this.renderers.get(i);   \n                break;\n            }\n        }\n        return result;\n    }\n    \n    \n    public int getIndexOf(CategoryItemRenderer renderer) {\n        return this.renderers.indexOf(renderer);\n    }\n\n    \n    public DatasetRenderingOrder getDatasetRenderingOrder() {\n        return this.renderingOrder;\n    }\n\n    \n    public void setDatasetRenderingOrder(DatasetRenderingOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");   \n        }\n        this.renderingOrder = order;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n        \n    public SortOrder getColumnRenderingOrder() {\n        return this.columnRenderingOrder;\n    }\n    \n    \n    public void setColumnRenderingOrder(SortOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.columnRenderingOrder = order;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public SortOrder getRowRenderingOrder() {\n        return this.rowRenderingOrder;\n    }\n\n    \n    public void setRowRenderingOrder(SortOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.rowRenderingOrder = order;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public boolean isDomainGridlinesVisible() {\n        return this.domainGridlinesVisible;\n    }\n\n    \n    public void setDomainGridlinesVisible(boolean visible) {\n        if (this.domainGridlinesVisible != visible) {\n            this.domainGridlinesVisible = visible;\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    \n    public CategoryAnchor getDomainGridlinePosition() {\n        return this.domainGridlinePosition;\n    }\n\n    \n    public void setDomainGridlinePosition(CategoryAnchor position) {\n        if (position == null) {\n            throw new IllegalArgumentException(\"Null 'position' argument.\");   \n        }\n        this.domainGridlinePosition = position;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public Stroke getDomainGridlineStroke() {\n        return this.domainGridlineStroke;\n    }\n\n    \n    public void setDomainGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' not permitted.\");   \n        }\n        this.domainGridlineStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public Paint getDomainGridlinePaint() {\n        return this.domainGridlinePaint;\n    }\n\n    \n    public void setDomainGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.domainGridlinePaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public boolean isRangeGridlinesVisible() {\n        return this.rangeGridlinesVisible;\n    }\n\n    \n    public void setRangeGridlinesVisible(boolean visible) {\n        if (this.rangeGridlinesVisible != visible) {\n            this.rangeGridlinesVisible = visible;\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    \n    public Stroke getRangeGridlineStroke() {\n        return this.rangeGridlineStroke;\n    }\n\n    \n    public void setRangeGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");   \n        }\n        this.rangeGridlineStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public Paint getRangeGridlinePaint() {\n        return this.rangeGridlinePaint;\n    }\n\n    \n    public void setRangeGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.rangeGridlinePaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public LegendItemCollection getFixedLegendItems() {\n        return this.fixedLegendItems;   \n    }\n\n    \n    public void setFixedLegendItems(LegendItemCollection items) {\n        this.fixedLegendItems = items;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = this.fixedLegendItems;\n        if (result == null) {\n            result = new LegendItemCollection();\n            \n            int count = this.datasets.size();\n            for (int datasetIndex = 0; datasetIndex < count; datasetIndex++) {\n                CategoryDataset dataset = getDataset(datasetIndex);\n                if (dataset != null) {\n                    CategoryItemRenderer renderer = getRenderer(datasetIndex);\n                    if (renderer != null) {\n                        int seriesCount = dataset.getRowCount();\n                        for (int i = 0; i < seriesCount; i++) {\n                            LegendItem item = renderer.getLegendItem(\n                                    datasetIndex, i);\n                            if (item != null) {\n                                result.add(item);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    \n    public void handleClick(int x, int y, PlotRenderingInfo info) {\n\n        Rectangle2D dataArea = info.getDataArea();\n        if (dataArea.contains(x, y)) {\n            \n            double java2D = 0.0;\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                java2D = x;\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                java2D = y;\n            }\n            RectangleEdge edge = Plot.resolveRangeAxisLocation(\n                    getRangeAxisLocation(), this.orientation);\n            double value = getRangeAxis().java2DToValue(\n                    java2D, info.getDataArea(), edge);\n            setAnchorValue(value);\n            setRangeCrosshairValue(value);\n        }\n\n    }\n\n    \n    public void zoom(double percent) {\n\n        if (percent > 0.0) {\n            double range = getRangeAxis().getRange().getLength();\n            double scaledRange = range * percent;\n            getRangeAxis().setRange(this.anchorValue - scaledRange / 2.0,\n                    this.anchorValue + scaledRange / 2.0);\n        }\n        else {\n            getRangeAxis().setAutoRange(true);\n        }\n\n    }\n\n    \n    public void datasetChanged(DatasetChangeEvent event) {\n\n        int count = this.rangeAxes.size();\n        for (int axisIndex = 0; axisIndex < count; axisIndex++) {\n            ValueAxis yAxis = getRangeAxis(axisIndex);\n            if (yAxis != null) {\n                yAxis.configure();\n            }\n        }\n        if (getParent() != null) {\n            getParent().datasetChanged(event);\n        }\n        else {\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            e.setType(ChartChangeEventType.DATASET_UPDATED);\n            notifyListeners(e);\n        }\n\n    }\n\n    \n    public void rendererChanged(RendererChangeEvent event) {\n        Plot parent = getParent();\n        if (parent != null) {\n            if (parent instanceof RendererChangeListener) {\n                RendererChangeListener rcl = (RendererChangeListener) parent;\n                rcl.rendererChanged(event);\n            }\n            else {\n                \n                \n                throw new RuntimeException(\n                    \"The renderer has changed and I don't know what to do!\");\n            }\n        }\n        else {\n            configureRangeAxes();\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            notifyListeners(e);\n        }\n    }\n    \n    \n    public void addDomainMarker(CategoryMarker marker) {\n        addDomainMarker(marker, Layer.FOREGROUND); \n    }\n        \n    \n    public void addDomainMarker(CategoryMarker marker, Layer layer) {\n        addDomainMarker(0, marker, layer);\n    }\n\n    \n    public void addDomainMarker(int index, CategoryMarker marker, Layer layer) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' not permitted.\");\n        }\n        if (layer == null) {\n            throw new IllegalArgumentException(\"Null 'layer' not permitted.\");\n        }\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);            \n        }\n        marker.addChangeListener(this);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public void clearDomainMarkers() {\n        if (this.backgroundDomainMarkers != null) {\n            Set keys = this.backgroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.backgroundDomainMarkers.clear();\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Set keys = this.foregroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.foregroundDomainMarkers.clear();\n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public Collection getDomainMarkers(Layer layer) {\n        return getDomainMarkers(0, layer);\n    }\n\n    \n    public Collection getDomainMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundDomainMarkers.get(key);\n        }    \n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundDomainMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n    \n    \n    public void clearDomainMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundDomainMarkers != null) {\n            Collection markers \n                = (Collection) this.backgroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Collection markers \n                = (Collection) this.foregroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public void addRangeMarker(Marker marker) {\n        addRangeMarker(marker, Layer.FOREGROUND); \n    }\n        \n    \n    public void addRangeMarker(Marker marker, Layer layer) {\n        addRangeMarker(0, marker, layer);\n    }\n\n    \n    public void addRangeMarker(int index, Marker marker, Layer layer) {\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);            \n        }\n        marker.addChangeListener(this);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public void clearRangeMarkers() {\n        if (this.backgroundRangeMarkers != null) {\n            Set keys = this.backgroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.backgroundRangeMarkers.clear();\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Set keys = this.foregroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.foregroundRangeMarkers.clear();\n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public Collection getRangeMarkers(Layer layer) {\n        return getRangeMarkers(0, layer);\n    }\n\n    \n    public Collection getRangeMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundRangeMarkers.get(key);\n        }    \n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundRangeMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n    \n    \n    public void clearRangeMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundRangeMarkers != null) {\n            Collection markers \n                = (Collection) this.backgroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers \n                = (Collection) this.foregroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public boolean isRangeCrosshairVisible() {\n        return this.rangeCrosshairVisible;\n    }\n\n    \n    public void setRangeCrosshairVisible(boolean flag) {\n        if (this.rangeCrosshairVisible != flag) {\n            this.rangeCrosshairVisible = flag;\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    \n    public boolean isRangeCrosshairLockedOnData() {\n        return this.rangeCrosshairLockedOnData;\n    }\n\n    \n    public void setRangeCrosshairLockedOnData(boolean flag) {\n\n        if (this.rangeCrosshairLockedOnData != flag) {\n            this.rangeCrosshairLockedOnData = flag;\n            notifyListeners(new PlotChangeEvent(this));\n        }\n\n    }\n\n    \n    public double getRangeCrosshairValue() {\n        return this.rangeCrosshairValue;\n    }\n\n    \n    public void setRangeCrosshairValue(double value) {\n        setRangeCrosshairValue(value, true);\n    }\n\n    \n    public void setRangeCrosshairValue(double value, boolean notify) {\n        this.rangeCrosshairValue = value;\n        if (isRangeCrosshairVisible() && notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    \n    public Stroke getRangeCrosshairStroke() {\n        return this.rangeCrosshairStroke;\n    }\n\n    \n    public void setRangeCrosshairStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeCrosshairStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public Paint getRangeCrosshairPaint() {\n        return this.rangeCrosshairPaint;\n    }\n\n    \n    public void setRangeCrosshairPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeCrosshairPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public List getAnnotations() {\n        return this.annotations;\n    }\n\n    \n    public void addAnnotation(CategoryAnnotation annotation) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");   \n        }\n        this.annotations.add(annotation);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public boolean removeAnnotation(CategoryAnnotation annotation) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        boolean removed = this.annotations.remove(annotation);\n        if (removed) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n        return removed;\n    }\n\n    \n    public void clearAnnotations() {\n        this.annotations.clear();\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    protected AxisSpace calculateDomainAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space) {\n                                                     \n        if (space == null) {\n            space = new AxisSpace();\n        }\n        \n        \n        if (this.fixedDomainAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(\n                    this.fixedDomainAxisSpace.getLeft(), RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n        }\n        else {\n            \n            RectangleEdge domainEdge = Plot.resolveDomainAxisLocation(\n                    getDomainAxisLocation(), this.orientation);\n            if (this.drawSharedDomainAxis) {\n                space = getDomainAxis().reserveSpace(g2, this, plotArea, \n                        domainEdge, space);\n            }\n            \n            \n            for (int i = 0; i < this.domainAxes.size(); i++) {\n                Axis xAxis = (Axis) this.domainAxes.get(i);\n                if (xAxis != null) {\n                    RectangleEdge edge = getDomainAxisEdge(i);\n                    space = xAxis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n\n        return space;\n                                                     \n    }\n    \n    \n    protected AxisSpace calculateRangeAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space) {\n                                                  \n        if (space == null) {\n            space = new AxisSpace(); \n        }\n        \n        \n        if (this.fixedRangeAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getLeft(), \n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n        }\n        else {\n            \n            for (int i = 0; i < this.rangeAxes.size(); i++) {\n                Axis yAxis = (Axis) this.rangeAxes.get(i);\n                if (yAxis != null) {\n                    RectangleEdge edge = getRangeAxisEdge(i);\n                    space = yAxis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n        return space;\n                                                    \n    }\n\n    \n    protected AxisSpace calculateAxisSpace(Graphics2D g2, Rectangle2D plotArea) {\n        AxisSpace space = new AxisSpace();\n        space = calculateRangeAxisSpace(g2, plotArea, space);\n        space = calculateDomainAxisSpace(g2, plotArea, space);\n        return space;\n    }\n    \n    \n    public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo state) {\n\n        \n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n        if (b1 || b2) {\n            return;\n        }\n\n        \n        if (state == null) {\n            \n            \n            \n            state = new PlotRenderingInfo(null);\n        }\n        state.setPlotArea(area);\n\n        \n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n\n        \n        AxisSpace space = calculateAxisSpace(g2, area);\n        Rectangle2D dataArea = space.shrink(area, null);\n        this.axisOffset.trim(dataArea);\n\n        state.setDataArea(dataArea);\n\n        \n        \n        if (getRenderer() != null) {\n            getRenderer().drawBackground(g2, this, dataArea);\n        }\n        else {\n            drawBackground(g2, dataArea);\n        }\n       \n        Map axisStateMap = drawAxes(g2, area, dataArea, state);\n\n        \n        Shape savedClip = g2.getClip();\n        g2.clip(dataArea);\n\n        drawDomainGridlines(g2, dataArea);\n\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\n        if (rangeAxisState == null) {\n            if (parentState != null) {\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getRangeAxis());\n            }\n        }\n        if (rangeAxisState != null) {\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\n        }\n        \n        \n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }        \n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n\n        \n        boolean foundData = false;\n\n        \n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(\n                AlphaComposite.SRC_OVER, getForegroundAlpha()));\n\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\n        if (order == DatasetRenderingOrder.FORWARD) {\n\n            \n            int datasetCount = this.datasets.size();\n            for (int i = 0; i < datasetCount; i++) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, state);\n                }\n            }\n\n            for (int i = 0; i < datasetCount; i++) {\n                foundData = render(g2, dataArea, i, state) || foundData;\n            }\n\n            \n            for (int i = 0; i < datasetCount; i++) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, state);\n                }\n            }\n        }\n        else {  \n            \n            \n            int datasetCount = this.datasets.size();\n            for (int i = datasetCount - 1; i >= 0; i--) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, state);\n                }\n            }\n            \n            for (int i = this.datasets.size() - 1; i >= 0; i--) {\n                foundData = render(g2, dataArea, i, state) || foundData;   \n            }\n\n            \n            for (int i = datasetCount - 1; i >= 0; i--) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, state);\n                }\n            }\n        }\n        \n        \n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n\n        \n        drawAnnotations(g2, dataArea, state);\n\n        g2.setClip(savedClip);\n        g2.setComposite(originalComposite);\n\n        if (!foundData) {\n            drawNoDataMessage(g2, dataArea);\n        }\n\n        \n        if (isRangeCrosshairVisible()) {\n            \n            drawRangeCrosshair(g2, dataArea, getOrientation(), \n                    getRangeCrosshairValue(), getRangeAxis(),\n                    getRangeCrosshairStroke(), getRangeCrosshairPaint());\n        }\n\n        \n        if (getRenderer() != null) {\n            getRenderer().drawOutline(g2, this, dataArea);\n        }\n        else {\n            drawOutline(g2, dataArea);\n        }\n\n    }\n\n    \n    public void drawBackground(Graphics2D g2, Rectangle2D area) {\n        fillBackground(g2, area, this.orientation);\n        drawBackgroundImage(g2, area);\n    }\n\n    \n    protected Map drawAxes(Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, PlotRenderingInfo plotState) {\n\n        AxisCollection axisCollection = new AxisCollection();\n\n        \n        for (int index = 0; index < this.domainAxes.size(); index++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(index);\n            if (xAxis != null) {\n                axisCollection.add(xAxis, getDomainAxisEdge(index));\n            }\n        }\n\n        \n        for (int index = 0; index < this.rangeAxes.size(); index++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(index);\n            if (yAxis != null) {\n                axisCollection.add(yAxis, getRangeAxisEdge(index));\n            }\n        }\n\n        Map axisStateMap = new HashMap();\n        \n        \n        double cursor = dataArea.getMinY() - this.axisOffset.calculateTopOutset(\n                dataArea.getHeight());\n        Iterator iterator = axisCollection.getAxesAtTop().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, \n                        RectangleEdge.TOP, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        \n        cursor = dataArea.getMaxY() \n                 + this.axisOffset.calculateBottomOutset(dataArea.getHeight());\n        iterator = axisCollection.getAxesAtBottom().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.BOTTOM, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        \n        cursor = dataArea.getMinX() \n                 - this.axisOffset.calculateLeftOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtLeft().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.LEFT, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        \n        cursor = dataArea.getMaxX() \n                 + this.axisOffset.calculateRightOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtRight().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, \n                        RectangleEdge.RIGHT, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n        \n        return axisStateMap;\n        \n    }\n\n    \n    public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, PlotRenderingInfo info) {\n\n        boolean foundData = false;\n        CategoryDataset currentDataset = getDataset(index);\n        CategoryItemRenderer renderer = getRenderer(index);\n        CategoryAxis domainAxis = getDomainAxisForDataset(index);\n        ValueAxis rangeAxis = getRangeAxisForDataset(index);\n        boolean hasData = !DatasetUtilities.isEmptyOrNull(currentDataset);\n        if (hasData && renderer != null) {\n            \n            foundData = true;\n            CategoryItemRendererState state = renderer.initialise(g2, dataArea,\n                    this, index, info);\n            int columnCount = currentDataset.getColumnCount();\n            int rowCount = currentDataset.getRowCount();\n            int passCount = renderer.getPassCount();\n            for (int pass = 0; pass < passCount; pass++) {            \n                if (this.columnRenderingOrder == SortOrder.ASCENDING) {\n                    for (int column = 0; column < columnCount; column++) {\n                        if (this.rowRenderingOrder == SortOrder.ASCENDING) {\n                            for (int row = 0; row < rowCount; row++) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }\n                        }\n                        else {\n                            for (int row = rowCount - 1; row >= 0; row--) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }                        \n                        }\n                    }\n                }\n                else {\n                    for (int column = columnCount - 1; column >= 0; column--) {\n                        if (this.rowRenderingOrder == SortOrder.ASCENDING) {\n                            for (int row = 0; row < rowCount; row++) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }\n                        }\n                        else {\n                            for (int row = rowCount - 1; row >= 0; row--) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }                        \n                        }\n                    }\n                }\n            }\n        }\n        return foundData;\n        \n    }\n\n    \n    protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea) {\n\n        \n        if (isDomainGridlinesVisible()) {\n            CategoryAnchor anchor = getDomainGridlinePosition();\n            RectangleEdge domainAxisEdge = getDomainAxisEdge();\n            Stroke gridStroke = getDomainGridlineStroke();\n            Paint gridPaint = getDomainGridlinePaint();\n            if ((gridStroke != null) && (gridPaint != null)) {\n                \n                CategoryDataset data = getDataset();\n                if (data != null) {\n                    CategoryAxis axis = getDomainAxis();\n                    if (axis != null) {\n                        int columnCount = data.getColumnCount();\n                        for (int c = 0; c < columnCount; c++) {\n                            double xx = axis.getCategoryJava2DCoordinate(\n                                    anchor, c, columnCount, dataArea, \n                                    domainAxisEdge);\n                            CategoryItemRenderer renderer1 = getRenderer();\n                            if (renderer1 != null) {\n                                renderer1.drawDomainGridline(g2, this, \n                                        dataArea, xx);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n \n    \n    protected void drawRangeGridlines(Graphics2D g2, Rectangle2D dataArea, List ticks) {\n        \n        if (isRangeGridlinesVisible()) {\n            Stroke gridStroke = getRangeGridlineStroke();\n            Paint gridPaint = getRangeGridlinePaint();\n            if ((gridStroke != null) && (gridPaint != null)) {\n                ValueAxis axis = getRangeAxis();\n                if (axis != null) {\n                    Iterator iterator = ticks.iterator();\n                    while (iterator.hasNext()) {\n                        ValueTick tick = (ValueTick) iterator.next();\n                        CategoryItemRenderer renderer1 = getRenderer();\n                        if (renderer1 != null) {\n                            renderer1.drawRangeGridline(g2, this, \n                                    getRangeAxis(), dataArea, tick.getValue());\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    \n    protected void drawAnnotations(Graphics2D g2, Rectangle2D dataArea, PlotRenderingInfo info) {\n\n        Iterator iterator = getAnnotations().iterator();\n        while (iterator.hasNext()) {\n            CategoryAnnotation annotation \n                    = (CategoryAnnotation) iterator.next();\n            annotation.draw(g2, this, dataArea, getDomainAxis(), \n                    getRangeAxis(), 0, info);\n        }\n\n    }\n\n    \n    protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer) {\n                                                 \n        CategoryItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        \n        Collection markers = getDomainMarkers(index, layer);\n        CategoryAxis axis = getDomainAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                CategoryMarker marker = (CategoryMarker) iterator.next();\n                r.drawDomainMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n        \n    }\n\n    \n    protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer) {\n                                                 \n        CategoryItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        \n        Collection markers = getRangeMarkers(index, layer);\n        ValueAxis axis = getRangeAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawRangeMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n        \n    }\n\n    \n    protected void drawRangeLine(Graphics2D g2, Rectangle2D dataArea, double value, Stroke stroke, Paint paint) {\n\n        double java2D = getRangeAxis().valueToJava2D(value, dataArea, \n                getRangeAxisEdge());\n        Line2D line = null;\n        if (this.orientation == PlotOrientation.HORIZONTAL) {\n            line = new Line2D.Double(java2D, dataArea.getMinY(), java2D, \n                    dataArea.getMaxY());\n        }\n        else if (this.orientation == PlotOrientation.VERTICAL) {\n            line = new Line2D.Double(dataArea.getMinX(), java2D, \n                    dataArea.getMaxX(), java2D);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n\n    }\n\n    \n    protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, PlotOrientation orientation, double value, ValueAxis axis, Stroke stroke, Paint paint) {\n        \n        if (!axis.getRange().contains(value)) {\n            return;\n        }\n        Line2D line = null;\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            double xx = axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.BOTTOM);\n            line = new Line2D.Double(xx, dataArea.getMinY(), xx, \n                    dataArea.getMaxY());\n        }\n        else {\n            double yy = axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.LEFT);\n            line = new Line2D.Double(dataArea.getMinX(), yy, \n                    dataArea.getMaxX(), yy);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n       \n    }\n    \n    \n    public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        \n        int rangeIndex = this.rangeAxes.indexOf(axis);\n        if (rangeIndex >= 0) {\n            mappedDatasets.addAll(datasetsMappedToRangeAxis(rangeIndex));\n        }\n        else if (axis == getRangeAxis()) {\n            mappedDatasets.addAll(datasetsMappedToRangeAxis(0));\n        }\n\n        \n        \n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            CategoryDataset d = (CategoryDataset) iterator.next();\n            CategoryItemRenderer r = getRendererForDataset(d);\n            if (r != null) {\n                result = Range.combine(result, r.findRangeBounds(d));\n            }\n        }\n        return result;\n\n    }\n\n    \n    private List datasetsMappedToDomainAxis(int axisIndex) {\n        List result = new ArrayList();\n        for (int datasetIndex = 0; datasetIndex < this.datasets.size(); \n                datasetIndex++) {\n            Object dataset = this.datasets.get(datasetIndex);\n            if (dataset != null) {\n                Integer m = (Integer) this.datasetToDomainAxisMap.get(\n                        datasetIndex);\n                if (m == null) {  \n                                  \n                    if (axisIndex == 0) {\n                        result.add(dataset);\n                    }\n                }\n                else {\n                    if (m.intValue() == axisIndex) {\n                        result.add(dataset);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    \n    \n    private List datasetsMappedToRangeAxis(int index) {\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            Object dataset = this.datasets.get(i);\n            if (dataset != null) {\n                Integer m = (Integer) this.datasetToRangeAxisMap.get(i);\n                if (m == null) {  \n                                  \n                    if (index == 0) { \n                        result.add(dataset);\n                    }\n                }\n                else {\n                    if (m.intValue() == index) {\n                        result.add(dataset);\n                    }\n                }\n            }\n        }\n        return result;    \n    }\n\n    \n    public int getWeight() {\n        return this.weight;\n    }\n\n    \n    public void setWeight(int weight) {\n        this.weight = weight;\n        \n    }\n    \n    \n    public AxisSpace getFixedDomainAxisSpace() {\n        return this.fixedDomainAxisSpace;\n    }\n\n    \n    public void setFixedDomainAxisSpace(AxisSpace space) {\n        this.fixedDomainAxisSpace = space;\n        \n    }\n\n    \n    public AxisSpace getFixedRangeAxisSpace() {\n        return this.fixedRangeAxisSpace;\n    }\n\n    \n    public void setFixedRangeAxisSpace(AxisSpace space) {\n        this.fixedRangeAxisSpace = space;\n        \n    }\n\n    \n    public List getCategories() {\n        List result = null;\n        if (getDataset() != null) {\n            result = Collections.unmodifiableList(getDataset().getColumnKeys());\n        }\n        return result;\n    }\n    \n    \n    public List getCategoriesForAxis(CategoryAxis axis) {\n        List result = new ArrayList();\n        int axisIndex = this.domainAxes.indexOf(axis);\n        List datasets = datasetsMappedToDomainAxis(axisIndex);\n        Iterator iterator = datasets.iterator();\n        while (iterator.hasNext()) {\n            CategoryDataset dataset = (CategoryDataset) iterator.next();\n            \n            for (int i = 0; i < dataset.getColumnCount(); i++) {\n                Comparable category = dataset.getColumnKey(i);\n                if (!result.contains(category)) {\n                    result.add(category);\n                }\n            }\n        }\n        return result;\n    }\n\n    \n    public boolean getDrawSharedDomainAxis() {\n        return this.drawSharedDomainAxis;\n    }\n    \n    \n    public void setDrawSharedDomainAxis(boolean draw) {\n        this.drawSharedDomainAxis = draw;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public boolean isDomainZoomable() {\n        return false;\n    }\n    \n    \n    public boolean isRangeZoomable() {\n        return true;\n    }\n\n    \n    public void zoomDomainAxes(double factor, PlotRenderingInfo state, Point2D source) {\n        \n    }\n\n    \n    public void zoomDomainAxes(double lowerPercent, double upperPercent, PlotRenderingInfo state, Point2D source) {\n        \n    }\n    \n    \n    public void zoomDomainAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor) {\n        \n    }\n\n    \n    public void zoomRangeAxes(double factor, PlotRenderingInfo state, Point2D source) {\n        \n        zoomRangeAxes(factor, state, source, false);    \n    }\n\n    \n    public void zoomRangeAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor) {\n                \n        \n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                if (useAnchor) {\n                    \n                    \n                    double sourceY = source.getY();\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\n                        sourceY = source.getX();\n                    }\n                    double anchorY = rangeAxis.java2DToValue(sourceY, \n                            info.getDataArea(), getRangeAxisEdge());\n                    rangeAxis.resizeRange(factor, anchorY);\n                }\n                else {\n                    rangeAxis.resizeRange(factor);\n                }\n            }\n        }\n    }\n\n    \n    public void zoomRangeAxes(double lowerPercent, double upperPercent, PlotRenderingInfo state, Point2D source) {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                rangeAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n    \n    \n    public double getAnchorValue() {\n        return this.anchorValue;\n    }\n\n    \n    public void setAnchorValue(double value) {\n        setAnchorValue(value, true);\n    }\n\n    \n    public void setAnchorValue(double value, boolean notify) {\n        this.anchorValue = value;\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n    \n    \n    public boolean equals(Object obj) {\n    \n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof CategoryPlot)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n\n        CategoryPlot that = (CategoryPlot) obj;\n            \n        if (this.orientation != that.orientation) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.axisOffset, that.axisOffset)) {\n            return false;\n        }\n        if (!this.domainAxes.equals(that.domainAxes)) {\n            return false;\n        }\n        if (!this.domainAxisLocations.equals(that.domainAxisLocations)) {\n            return false;\n        }\n        if (this.drawSharedDomainAxis != that.drawSharedDomainAxis) {\n            return false;\n        }\n        if (!this.rangeAxes.equals(that.rangeAxes)) {\n            return false;\n        }\n        if (!this.rangeAxisLocations.equals(that.rangeAxisLocations)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToDomainAxisMap, \n                that.datasetToDomainAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToRangeAxisMap, \n                that.datasetToRangeAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.renderers, that.renderers)) {\n            return false;\n        }\n        if (this.renderingOrder != that.renderingOrder) {\n            return false;\n        }\n        if (this.columnRenderingOrder != that.columnRenderingOrder) {\n            return false;\n        }\n        if (this.rowRenderingOrder != that.rowRenderingOrder) {\n            return false;\n        }\n        if (this.domainGridlinesVisible != that.domainGridlinesVisible) {\n            return false;\n        }\n        if (this.domainGridlinePosition != that.domainGridlinePosition) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainGridlineStroke, \n                that.domainGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainGridlinePaint, \n                that.domainGridlinePaint)) {\n            return false;\n        }\n        if (this.rangeGridlinesVisible != that.rangeGridlinesVisible) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeGridlineStroke, \n                that.rangeGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeGridlinePaint, \n                that.rangeGridlinePaint)) {\n            return false;\n        }\n        if (this.anchorValue != that.anchorValue) {\n            return false;\n        }\n        if (this.rangeCrosshairVisible != that.rangeCrosshairVisible) {\n            return false;\n        }\n        if (this.rangeCrosshairValue != that.rangeCrosshairValue) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeCrosshairStroke, \n                that.rangeCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeCrosshairPaint, \n                that.rangeCrosshairPaint)) {\n            return false;\n        }\n        if (this.rangeCrosshairLockedOnData \n                != that.rangeCrosshairLockedOnData) {\n            return false;\n        }      \n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers, \n                that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers, \n                that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.annotations, that.annotations)) {\n            return false;\n        }\n        if (this.weight != that.weight) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.fixedDomainAxisSpace, \n                that.fixedDomainAxisSpace)) {\n            return false;\n        }    \n        if (!ObjectUtilities.equal(this.fixedRangeAxisSpace, \n                that.fixedRangeAxisSpace)) {\n            return false;\n        }    \n        \n        return true;\n        \n    }\n    \n    \n    public Object clone() throws CloneNotSupportedException {\n        \n        CategoryPlot clone = (CategoryPlot) super.clone();\n        \n        clone.domainAxes = new ObjectList();\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i);\n            if (xAxis != null) {\n                CategoryAxis clonedAxis = (CategoryAxis) xAxis.clone();\n                clone.setDomainAxis(i, clonedAxis);\n            }\n        }\n        clone.domainAxisLocations \n            = (ObjectList) this.domainAxisLocations.clone();\n\n        clone.rangeAxes = new ObjectList();\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (yAxis != null) {\n                ValueAxis clonedAxis = (ValueAxis) yAxis.clone();\n                clone.setRangeAxis(i, clonedAxis);\n            }\n        }\n        clone.rangeAxisLocations = (ObjectList) this.rangeAxisLocations.clone();\n\n        clone.datasets = (ObjectList) this.datasets.clone();\n        for (int i = 0; i < clone.datasets.size(); i++) {\n            CategoryDataset dataset = clone.getDataset(i);\n            if (dataset != null) {\n                dataset.addChangeListener(clone);\n            }\n        }\n        clone.datasetToDomainAxisMap \n            = (ObjectList) this.datasetToDomainAxisMap.clone();\n        clone.datasetToRangeAxisMap \n            = (ObjectList) this.datasetToRangeAxisMap.clone();\n        clone.renderers = (ObjectList) this.renderers.clone();\n        if (this.fixedDomainAxisSpace != null) {\n            clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedDomainAxisSpace);\n        }\n        if (this.fixedRangeAxisSpace != null) {\n            clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedRangeAxisSpace);\n        }\n        \n        return clone;\n            \n    }\n    \n    \n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writeStroke(this.domainGridlineStroke, stream);\n        SerialUtilities.writePaint(this.domainGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeGridlineStroke, stream);\n        SerialUtilities.writePaint(this.rangeGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeCrosshairStroke, stream);\n        SerialUtilities.writePaint(this.rangeCrosshairPaint, stream);\n    }\n\n    \n    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {\n\n        stream.defaultReadObject();\n        this.domainGridlineStroke = SerialUtilities.readStroke(stream);\n        this.domainGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeGridlineStroke = SerialUtilities.readStroke(stream);\n        this.rangeGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeCrosshairStroke = SerialUtilities.readStroke(stream);\n        this.rangeCrosshairPaint = SerialUtilities.readPaint(stream);\n\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i);\n            if (xAxis != null) {\n                xAxis.setPlot(this);\n                xAxis.addChangeListener(this);\n            }\n        } \n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (yAxis != null) {\n                yAxis.setPlot(this);   \n                yAxis.addChangeListener(this);\n            }\n        }\n        int datasetCount = this.datasets.size();\n        for (int i = 0; i < datasetCount; i++) {\n            Dataset dataset = (Dataset) this.datasets.get(i);\n            if (dataset != null) {\n                dataset.addChangeListener(this);\n            }\n        }\n        int rendererCount = this.renderers.size();\n        for (int i = 0; i < rendererCount; i++) {\n            CategoryItemRenderer renderer \n                = (CategoryItemRenderer) this.renderers.get(i);\n            if (renderer != null) {\n                renderer.addChangeListener(this);\n            }\n        }\n\n    }\n\n}\n",
      "fixed_full_code": "\n\npackage org.jfree.chart.plot;\n\nimport java.awt.AlphaComposite;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Composite;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ResourceBundle;\nimport java.util.Set;\n\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.annotations.CategoryAnnotation;\nimport org.jfree.chart.axis.Axis;\nimport org.jfree.chart.axis.AxisCollection;\nimport org.jfree.chart.axis.AxisLocation;\nimport org.jfree.chart.axis.AxisSpace;\nimport org.jfree.chart.axis.AxisState;\nimport org.jfree.chart.axis.CategoryAnchor;\nimport org.jfree.chart.axis.CategoryAxis;\nimport org.jfree.chart.axis.ValueAxis;\nimport org.jfree.chart.axis.ValueTick;\nimport org.jfree.chart.event.ChartChangeEventType;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.event.RendererChangeEvent;\nimport org.jfree.chart.event.RendererChangeListener;\nimport org.jfree.chart.renderer.category.CategoryItemRenderer;\nimport org.jfree.chart.renderer.category.CategoryItemRendererState;\nimport org.jfree.chart.util.Layer;\nimport org.jfree.chart.util.ObjectList;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.chart.util.SortOrder;\nimport org.jfree.data.Range;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.general.Dataset;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\n\n\npublic class CategoryPlot extends Plot implements ValueAxisPlot, Zoomable, RendererChangeListener, Cloneable, PublicCloneable, Serializable { private static final long serialVersionUID = -3537691700434728188L; public static final boolean DEFAULT_DOMAIN_GRIDLINES_VISIBLE = false; public static final boolean DEFAULT_RANGE_GRIDLINES_VISIBLE = true; public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke(0.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0.0f, new float[] {2.0f, 2.0f}, 0.0f); public static final Paint DEFAULT_GRIDLINE_PAINT = Color.WHITE; public static final Font DEFAULT_VALUE_LABEL_FONT = new Font(\"SansSerif\", Font.PLAIN, 10); public static final boolean DEFAULT_CROSSHAIR_VISIBLE = false; public static final Stroke DEFAULT_CROSSHAIR_STROKE = DEFAULT_GRIDLINE_STROKE; public static final Paint DEFAULT_CROSSHAIR_PAINT = Color.blue; protected static ResourceBundle localizationResources = ResourceBundle.getBundle( \"org.jfree.chart.plot.LocalizationBundle\"); private PlotOrientation orientation; private RectangleInsets axisOffset; private ObjectList domainAxes; private ObjectList domainAxisLocations; private boolean drawSharedDomainAxis; private ObjectList rangeAxes; private ObjectList rangeAxisLocations; private ObjectList datasets; private ObjectList datasetToDomainAxisMap; private ObjectList datasetToRangeAxisMap; private ObjectList renderers; private DatasetRenderingOrder renderingOrder = DatasetRenderingOrder.REVERSE; private SortOrder columnRenderingOrder = SortOrder.ASCENDING; private SortOrder rowRenderingOrder = SortOrder.ASCENDING; private boolean domainGridlinesVisible; private CategoryAnchor domainGridlinePosition; private transient Stroke domainGridlineStroke; private transient Paint domainGridlinePaint; private boolean rangeGridlinesVisible; private transient Stroke rangeGridlineStroke; private transient Paint rangeGridlinePaint; private double anchorValue; private boolean rangeCrosshairVisible; private double rangeCrosshairValue; private transient Stroke rangeCrosshairStroke; private transient Paint rangeCrosshairPaint; private boolean rangeCrosshairLockedOnData = true; private Map foregroundDomainMarkers; private Map backgroundDomainMarkers; private Map foregroundRangeMarkers; private Map backgroundRangeMarkers; private List annotations; private int weight; private AxisSpace fixedDomainAxisSpace; private AxisSpace fixedRangeAxisSpace; private LegendItemCollection fixedLegendItems; public CategoryPlot() {\n        this(null, null, null, null);\n    }\n\n    \n    public CategoryPlot(CategoryDataset dataset, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryItemRenderer renderer) {\n\n        super();\n\n        this.orientation = PlotOrientation.VERTICAL;\n\n        \n        this.domainAxes = new ObjectList();\n        this.domainAxisLocations = new ObjectList();\n        this.rangeAxes = new ObjectList();\n        this.rangeAxisLocations = new ObjectList();\n        \n        this.datasetToDomainAxisMap = new ObjectList();\n        this.datasetToRangeAxisMap = new ObjectList();\n\n        this.renderers = new ObjectList();\n\n        this.datasets = new ObjectList();\n        this.datasets.set(0, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n\n        this.axisOffset = new RectangleInsets(4.0, 4.0, 4.0, 4.0);\n\n        setDomainAxisLocation(AxisLocation.BOTTOM_OR_LEFT, false);\n        setRangeAxisLocation(AxisLocation.TOP_OR_LEFT, false);\n\n        this.renderers.set(0, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n\n        this.domainAxes.set(0, domainAxis);\n        this.mapDatasetToDomainAxis(0, 0);\n        if (domainAxis != null) {\n            domainAxis.setPlot(this);\n            domainAxis.addChangeListener(this);\n        }\n        this.drawSharedDomainAxis = false;\n\n        this.rangeAxes.set(0, rangeAxis);\n        this.mapDatasetToRangeAxis(0, 0);\n        if (rangeAxis != null) {\n            rangeAxis.setPlot(this);\n            rangeAxis.addChangeListener(this);\n        }\n        \n        configureDomainAxes();\n        configureRangeAxes();\n\n        this.domainGridlinesVisible = DEFAULT_DOMAIN_GRIDLINES_VISIBLE;\n        this.domainGridlinePosition = CategoryAnchor.MIDDLE;\n        this.domainGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.domainGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.rangeGridlinesVisible = DEFAULT_RANGE_GRIDLINES_VISIBLE;\n        this.rangeGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.rangeGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.foregroundDomainMarkers = new HashMap();\n        this.backgroundDomainMarkers = new HashMap();\n        this.foregroundRangeMarkers = new HashMap();\n        this.backgroundRangeMarkers = new HashMap();\n\n        Marker baseline = new ValueMarker(0.0, new Color(0.8f, 0.8f, 0.8f, \n                0.5f), new BasicStroke(1.0f), new Color(0.85f, 0.85f, 0.95f, \n                0.5f), new BasicStroke(1.0f), 0.6f);\n        addRangeMarker(baseline, Layer.BACKGROUND);\n\n        this.anchorValue = 0.0;\n\n        this.rangeCrosshairVisible = DEFAULT_CROSSHAIR_VISIBLE;\n        this.rangeCrosshairValue = 0.0;\n        this.rangeCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\n        this.rangeCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\n        \n        this.annotations = new java.util.ArrayList();\n\n    }\n    \n    \n    public String getPlotType() {\n        return localizationResources.getString(\"Category_Plot\");\n    }\n\n    \n    public PlotOrientation getOrientation() {\n        return this.orientation;\n    }\n\n    \n    public void setOrientation(PlotOrientation orientation) {\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n        this.orientation = orientation;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public RectangleInsets getAxisOffset() {\n        return this.axisOffset;\n    }\n\n    \n    public void setAxisOffset(RectangleInsets offset) {\n        if (offset == null) {\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");   \n        }\n        this.axisOffset = offset;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public CategoryAxis getDomainAxis() {\n        return getDomainAxis(0);\n    }\n\n    \n    public CategoryAxis getDomainAxis(int index) {\n        CategoryAxis result = null;\n        if (index < this.domainAxes.size()) {\n            result = (CategoryAxis) this.domainAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot cp = (CategoryPlot) parent;\n                result = cp.getDomainAxis(index);\n            }\n        }\n        return result;\n    }\n\n    \n    public void setDomainAxis(CategoryAxis axis) {\n        setDomainAxis(0, axis);\n    }\n\n    \n    public void setDomainAxis(int index, CategoryAxis axis) {\n        setDomainAxis(index, axis, true);\n    }\n \n    \n    public void setDomainAxis(int index, CategoryAxis axis, boolean notify) {\n        CategoryAxis existing = (CategoryAxis) this.domainAxes.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.domainAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    \n    public void setDomainAxes(CategoryAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setDomainAxis(i, axes[i], false);   \n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public int getDomainAxisIndex(CategoryAxis axis) {\n        if (axis == null) {\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");\n        }\n        return this.domainAxes.indexOf(axis);\n    }\n    \n    \n    public AxisLocation getDomainAxisLocation() {\n        return getDomainAxisLocation(0);\n    }\n\n    \n    public AxisLocation getDomainAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.domainAxisLocations.size()) {\n            result = (AxisLocation) this.domainAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getDomainAxisLocation(0));\n        }\n        return result;\n    }\n\n    \n    public void setDomainAxisLocation(AxisLocation location) {\n        \n        setDomainAxisLocation(0, location, true);\n    }\n\n    \n    public void setDomainAxisLocation(AxisLocation location, boolean notify) {\n        \n        setDomainAxisLocation(0, location, notify);\n    }\n\n    \n    public void setDomainAxisLocation(int index, AxisLocation location) {\n        \n        setDomainAxisLocation(index, location, true);\n    }\n    \n    \n    public void setDomainAxisLocation(int index, AxisLocation location, boolean notify) {\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.domainAxisLocations.set(index, location);\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    \n    public RectangleEdge getDomainAxisEdge() {\n        return getDomainAxisEdge(0);\n    }\n\n    \n    public RectangleEdge getDomainAxisEdge(int index) {\n        RectangleEdge result = null;\n        AxisLocation location = getDomainAxisLocation(index);\n        if (location != null) {\n            result = Plot.resolveDomainAxisLocation(location, this.orientation);\n        }\n        else {\n            result = RectangleEdge.opposite(getDomainAxisEdge(0));\n        }\n        return result;\n    }\n\n    \n    public int getDomainAxisCount() {\n        return this.domainAxes.size();\n    }\n\n    \n    public void clearDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.domainAxes.clear();\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public void configureDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    \n    public ValueAxis getRangeAxis() {\n        return getRangeAxis(0);\n    }\n\n    \n    public ValueAxis getRangeAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.rangeAxes.size()) {\n            result = (ValueAxis) this.rangeAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot cp = (CategoryPlot) parent;\n                result = cp.getRangeAxis(index);\n            }\n        }\n        return result;\n    }\n\n    \n    public void setRangeAxis(ValueAxis axis) {\n        setRangeAxis(0, axis);\n    }\n\n    \n    public void setRangeAxis(int index, ValueAxis axis) {\n        setRangeAxis(index, axis, true);\n    }\n        \n    \n    public void setRangeAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing = (ValueAxis) this.rangeAxes.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.rangeAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    \n    public void setRangeAxes(ValueAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setRangeAxis(i, axes[i], false);   \n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n\n    \n    public int getRangeAxisIndex(ValueAxis axis) {\n        if (axis == null) {\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");\n        }\n        int result = this.rangeAxes.indexOf(axis);\n        if (result < 0) { \n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot p = (CategoryPlot) parent;\n                result = p.getRangeAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n    \n    \n    public AxisLocation getRangeAxisLocation() {\n        return getRangeAxisLocation(0);\n    }\n\n    \n    public AxisLocation getRangeAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.rangeAxisLocations.size()) {\n            result = (AxisLocation) this.rangeAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getRangeAxisLocation(0));\n        }\n        return result;\n    }\n\n    \n    public void setRangeAxisLocation(AxisLocation location) {\n        \n        setRangeAxisLocation(location, true);\n    }\n\n    \n    public void setRangeAxisLocation(AxisLocation location, boolean notify) {\n        setRangeAxisLocation(0, location, notify);\n    }\n\n    \n    public void setRangeAxisLocation(int index, AxisLocation location) {\n        setRangeAxisLocation(index, location, true);\n    }\n\n    \n    public void setRangeAxisLocation(int index, AxisLocation location, boolean notify) {\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.rangeAxisLocations.set(index, location);\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    \n    public RectangleEdge getRangeAxisEdge() {\n        return getRangeAxisEdge(0);\n    }\n\n    \n    public RectangleEdge getRangeAxisEdge(int index) {\n        AxisLocation location = getRangeAxisLocation(index);\n        RectangleEdge result = Plot.resolveRangeAxisLocation(location, \n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getRangeAxisEdge(0));\n        }\n        return result;\n    }\n\n    \n    public int getRangeAxisCount() {\n        return this.rangeAxes.size();\n    }\n\n    \n    public void clearRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.rangeAxes.clear();\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public void configureRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    \n    public CategoryDataset getDataset() {\n        return getDataset(0);\n    }\n\n    \n    public CategoryDataset getDataset(int index) {\n        CategoryDataset result = null;\n        if (this.datasets.size() > index) {\n            result = (CategoryDataset) this.datasets.get(index);\n        }\n        return result;\n    }\n\n    \n    public void setDataset(CategoryDataset dataset) {\n        setDataset(0, dataset);\n    }\n\n    \n    public void setDataset(int index, CategoryDataset dataset) {\n        \n        CategoryDataset existing = (CategoryDataset) this.datasets.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        this.datasets.set(index, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n        \n        \n        DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n        datasetChanged(event);\n        \n    }\n\n    \n    public int getDatasetCount() {\n        return this.datasets.size();\n    }\n\n    \n    public void mapDatasetToDomainAxis(int index, int axisIndex) {\n        this.datasetToDomainAxisMap.set(index, new Integer(axisIndex));  \n        \n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));  \n    }\n\n    \n    public CategoryAxis getDomainAxisForDataset(int index) {\n        CategoryAxis result = getDomainAxis();\n        Integer axisIndex = (Integer) this.datasetToDomainAxisMap.get(index);\n        if (axisIndex != null) {\n            result = getDomainAxis(axisIndex.intValue());\n        }\n        return result;    \n    }\n    \n    \n    public void mapDatasetToRangeAxis(int index, int axisIndex) {\n        this.datasetToRangeAxisMap.set(index, new Integer(axisIndex));\n        \n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));  \n    }\n\n    \n    public ValueAxis getRangeAxisForDataset(int index) {\n        ValueAxis result = getRangeAxis();\n        Integer axisIndex = (Integer) this.datasetToRangeAxisMap.get(index);\n        if (axisIndex != null) {\n            result = getRangeAxis(axisIndex.intValue());\n        }\n        return result;    \n    }\n    \n    \n    public CategoryItemRenderer getRenderer() {\n        return getRenderer(0);\n    }\n\n    \n    public CategoryItemRenderer getRenderer(int index) {\n        CategoryItemRenderer result = null;\n        if (this.renderers.size() > index) {\n            result = (CategoryItemRenderer) this.renderers.get(index);\n        }\n        return result;\n    }\n    \n    \n    public void setRenderer(CategoryItemRenderer renderer) {\n        setRenderer(0, renderer, true);\n    }\n\n    \n    public void setRenderer(CategoryItemRenderer renderer, boolean notify) {\n        setRenderer(0, renderer, notify);\n    }\n\n    \n    public void setRenderer(int index, CategoryItemRenderer renderer) {\n        setRenderer(index, renderer, true);   \n    }\n\n    \n    public void setRenderer(int index, CategoryItemRenderer renderer, boolean notify) {\n        \n        \n        CategoryItemRenderer existing \n            = (CategoryItemRenderer) this.renderers.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        \n        \n        this.renderers.set(index, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n        \n        configureDomainAxes();\n        configureRangeAxes();\n        \n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    \n    public void setRenderers(CategoryItemRenderer[] renderers) {\n        for (int i = 0; i < renderers.length; i++) {\n            setRenderer(i, renderers[i], false);   \n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public CategoryItemRenderer getRendererForDataset(CategoryDataset dataset) {\n        CategoryItemRenderer result = null;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (this.datasets.get(i) == dataset) {\n                result = (CategoryItemRenderer) this.renderers.get(i);   \n                break;\n            }\n        }\n        return result;\n    }\n    \n    \n    public int getIndexOf(CategoryItemRenderer renderer) {\n        return this.renderers.indexOf(renderer);\n    }\n\n    \n    public DatasetRenderingOrder getDatasetRenderingOrder() {\n        return this.renderingOrder;\n    }\n\n    \n    public void setDatasetRenderingOrder(DatasetRenderingOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");   \n        }\n        this.renderingOrder = order;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n        \n    public SortOrder getColumnRenderingOrder() {\n        return this.columnRenderingOrder;\n    }\n    \n    \n    public void setColumnRenderingOrder(SortOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.columnRenderingOrder = order;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public SortOrder getRowRenderingOrder() {\n        return this.rowRenderingOrder;\n    }\n\n    \n    public void setRowRenderingOrder(SortOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.rowRenderingOrder = order;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public boolean isDomainGridlinesVisible() {\n        return this.domainGridlinesVisible;\n    }\n\n    \n    public void setDomainGridlinesVisible(boolean visible) {\n        if (this.domainGridlinesVisible != visible) {\n            this.domainGridlinesVisible = visible;\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    \n    public CategoryAnchor getDomainGridlinePosition() {\n        return this.domainGridlinePosition;\n    }\n\n    \n    public void setDomainGridlinePosition(CategoryAnchor position) {\n        if (position == null) {\n            throw new IllegalArgumentException(\"Null 'position' argument.\");   \n        }\n        this.domainGridlinePosition = position;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public Stroke getDomainGridlineStroke() {\n        return this.domainGridlineStroke;\n    }\n\n    \n    public void setDomainGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' not permitted.\");   \n        }\n        this.domainGridlineStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public Paint getDomainGridlinePaint() {\n        return this.domainGridlinePaint;\n    }\n\n    \n    public void setDomainGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.domainGridlinePaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public boolean isRangeGridlinesVisible() {\n        return this.rangeGridlinesVisible;\n    }\n\n    \n    public void setRangeGridlinesVisible(boolean visible) {\n        if (this.rangeGridlinesVisible != visible) {\n            this.rangeGridlinesVisible = visible;\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    \n    public Stroke getRangeGridlineStroke() {\n        return this.rangeGridlineStroke;\n    }\n\n    \n    public void setRangeGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");   \n        }\n        this.rangeGridlineStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public Paint getRangeGridlinePaint() {\n        return this.rangeGridlinePaint;\n    }\n\n    \n    public void setRangeGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.rangeGridlinePaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public LegendItemCollection getFixedLegendItems() {\n        return this.fixedLegendItems;   \n    }\n\n    \n    public void setFixedLegendItems(LegendItemCollection items) {\n        this.fixedLegendItems = items;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = this.fixedLegendItems;\n        if (result == null) {\n            result = new LegendItemCollection();\n            \n            int count = this.datasets.size();\n            for (int datasetIndex = 0; datasetIndex < count; datasetIndex++) {\n                CategoryDataset dataset = getDataset(datasetIndex);\n                if (dataset != null) {\n                    CategoryItemRenderer renderer = getRenderer(datasetIndex);\n                    if (renderer != null) {\n                        int seriesCount = dataset.getRowCount();\n                        for (int i = 0; i < seriesCount; i++) {\n                            LegendItem item = renderer.getLegendItem(\n                                    datasetIndex, i);\n                            if (item != null) {\n                                result.add(item);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    \n    public void handleClick(int x, int y, PlotRenderingInfo info) {\n\n        Rectangle2D dataArea = info.getDataArea();\n        if (dataArea.contains(x, y)) {\n            \n            double java2D = 0.0;\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                java2D = x;\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                java2D = y;\n            }\n            RectangleEdge edge = Plot.resolveRangeAxisLocation(\n                    getRangeAxisLocation(), this.orientation);\n            double value = getRangeAxis().java2DToValue(\n                    java2D, info.getDataArea(), edge);\n            setAnchorValue(value);\n            setRangeCrosshairValue(value);\n        }\n\n    }\n\n    \n    public void zoom(double percent) {\n\n        if (percent > 0.0) {\n            double range = getRangeAxis().getRange().getLength();\n            double scaledRange = range * percent;\n            getRangeAxis().setRange(this.anchorValue - scaledRange / 2.0,\n                    this.anchorValue + scaledRange / 2.0);\n        }\n        else {\n            getRangeAxis().setAutoRange(true);\n        }\n\n    }\n\n    \n    public void datasetChanged(DatasetChangeEvent event) {\n\n        int count = this.rangeAxes.size();\n        for (int axisIndex = 0; axisIndex < count; axisIndex++) {\n            ValueAxis yAxis = getRangeAxis(axisIndex);\n            if (yAxis != null) {\n                yAxis.configure();\n            }\n        }\n        if (getParent() != null) {\n            getParent().datasetChanged(event);\n        }\n        else {\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            e.setType(ChartChangeEventType.DATASET_UPDATED);\n            notifyListeners(e);\n        }\n\n    }\n\n    \n    public void rendererChanged(RendererChangeEvent event) {\n        Plot parent = getParent();\n        if (parent != null) {\n            if (parent instanceof RendererChangeListener) {\n                RendererChangeListener rcl = (RendererChangeListener) parent;\n                rcl.rendererChanged(event);\n            }\n            else {\n                \n                \n                throw new RuntimeException(\n                    \"The renderer has changed and I don't know what to do!\");\n            }\n        }\n        else {\n            configureRangeAxes();\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            notifyListeners(e);\n        }\n    }\n    \n    \n    public void addDomainMarker(CategoryMarker marker) {\n        addDomainMarker(marker, Layer.FOREGROUND); \n    }\n        \n    \n    public void addDomainMarker(CategoryMarker marker, Layer layer) {\n        addDomainMarker(0, marker, layer);\n    }\n\n    \n    public void addDomainMarker(int index, CategoryMarker marker, Layer layer) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' not permitted.\");\n        }\n        if (layer == null) {\n            throw new IllegalArgumentException(\"Null 'layer' not permitted.\");\n        }\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);            \n        }\n        marker.addChangeListener(this);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public void clearDomainMarkers() {\n        if (this.backgroundDomainMarkers != null) {\n            Set keys = this.backgroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.backgroundDomainMarkers.clear();\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Set keys = this.foregroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.foregroundDomainMarkers.clear();\n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public Collection getDomainMarkers(Layer layer) {\n        return getDomainMarkers(0, layer);\n    }\n\n    \n    public Collection getDomainMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundDomainMarkers.get(key);\n        }    \n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundDomainMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n    \n    \n    public void clearDomainMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundDomainMarkers != null) {\n            Collection markers \n                = (Collection) this.backgroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Collection markers \n                = (Collection) this.foregroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    \n    public void addRangeMarker(Marker marker) {\n        addRangeMarker(marker, Layer.FOREGROUND); \n    }\n        \n    \n    public void addRangeMarker(Marker marker, Layer layer) {\n        addRangeMarker(0, marker, layer);\n    }\n\n    \n    public void addRangeMarker(int index, Marker marker, Layer layer) {\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);            \n        }\n        marker.addChangeListener(this);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public void clearRangeMarkers() {\n        if (this.backgroundRangeMarkers != null) {\n            Set keys = this.backgroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.backgroundRangeMarkers.clear();\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Set keys = this.foregroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.foregroundRangeMarkers.clear();\n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public Collection getRangeMarkers(Layer layer) {\n        return getRangeMarkers(0, layer);\n    }\n\n    \n    public Collection getRangeMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundRangeMarkers.get(key);\n        }    \n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundRangeMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n    \n    \n    public void clearRangeMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundRangeMarkers != null) {\n            Collection markers \n                = (Collection) this.backgroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers \n                = (Collection) this.foregroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public boolean isRangeCrosshairVisible() {\n        return this.rangeCrosshairVisible;\n    }\n\n    \n    public void setRangeCrosshairVisible(boolean flag) {\n        if (this.rangeCrosshairVisible != flag) {\n            this.rangeCrosshairVisible = flag;\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    \n    public boolean isRangeCrosshairLockedOnData() {\n        return this.rangeCrosshairLockedOnData;\n    }\n\n    \n    public void setRangeCrosshairLockedOnData(boolean flag) {\n\n        if (this.rangeCrosshairLockedOnData != flag) {\n            this.rangeCrosshairLockedOnData = flag;\n            notifyListeners(new PlotChangeEvent(this));\n        }\n\n    }\n\n    \n    public double getRangeCrosshairValue() {\n        return this.rangeCrosshairValue;\n    }\n\n    \n    public void setRangeCrosshairValue(double value) {\n        setRangeCrosshairValue(value, true);\n    }\n\n    \n    public void setRangeCrosshairValue(double value, boolean notify) {\n        this.rangeCrosshairValue = value;\n        if (isRangeCrosshairVisible() && notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    \n    public Stroke getRangeCrosshairStroke() {\n        return this.rangeCrosshairStroke;\n    }\n\n    \n    public void setRangeCrosshairStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeCrosshairStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public Paint getRangeCrosshairPaint() {\n        return this.rangeCrosshairPaint;\n    }\n\n    \n    public void setRangeCrosshairPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeCrosshairPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public List getAnnotations() {\n        return this.annotations;\n    }\n\n    \n    public void addAnnotation(CategoryAnnotation annotation) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");   \n        }\n        this.annotations.add(annotation);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public boolean removeAnnotation(CategoryAnnotation annotation) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        boolean removed = this.annotations.remove(annotation);\n        if (removed) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n        return removed;\n    }\n\n    \n    public void clearAnnotations() {\n        this.annotations.clear();\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    protected AxisSpace calculateDomainAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space) {\n                                                     \n        if (space == null) {\n            space = new AxisSpace();\n        }\n        \n        \n        if (this.fixedDomainAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(\n                    this.fixedDomainAxisSpace.getLeft(), RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n        }\n        else {\n            \n            RectangleEdge domainEdge = Plot.resolveDomainAxisLocation(\n                    getDomainAxisLocation(), this.orientation);\n            if (this.drawSharedDomainAxis) {\n                space = getDomainAxis().reserveSpace(g2, this, plotArea, \n                        domainEdge, space);\n            }\n            \n            \n            for (int i = 0; i < this.domainAxes.size(); i++) {\n                Axis xAxis = (Axis) this.domainAxes.get(i);\n                if (xAxis != null) {\n                    RectangleEdge edge = getDomainAxisEdge(i);\n                    space = xAxis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n\n        return space;\n                                                     \n    }\n    \n    \n    protected AxisSpace calculateRangeAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space) {\n                                                  \n        if (space == null) {\n            space = new AxisSpace(); \n        }\n        \n        \n        if (this.fixedRangeAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getLeft(), \n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n        }\n        else {\n            \n            for (int i = 0; i < this.rangeAxes.size(); i++) {\n                Axis yAxis = (Axis) this.rangeAxes.get(i);\n                if (yAxis != null) {\n                    RectangleEdge edge = getRangeAxisEdge(i);\n                    space = yAxis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n        return space;\n                                                    \n    }\n\n    \n    protected AxisSpace calculateAxisSpace(Graphics2D g2, Rectangle2D plotArea) {\n        AxisSpace space = new AxisSpace();\n        space = calculateRangeAxisSpace(g2, plotArea, space);\n        space = calculateDomainAxisSpace(g2, plotArea, space);\n        return space;\n    }\n    \n    \n    public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo state) {\n\n        \n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n        if (b1 || b2) {\n            return;\n        }\n\n        \n        if (state == null) {\n            \n            \n            \n            state = new PlotRenderingInfo(null);\n        }\n        state.setPlotArea(area);\n\n        \n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n\n        \n        AxisSpace space = calculateAxisSpace(g2, area);\n        Rectangle2D dataArea = space.shrink(area, null);\n        this.axisOffset.trim(dataArea);\n\n        state.setDataArea(dataArea);\n\n        \n        \n        if (getRenderer() != null) {\n            getRenderer().drawBackground(g2, this, dataArea);\n        }\n        else {\n            drawBackground(g2, dataArea);\n        }\n       \n        Map axisStateMap = drawAxes(g2, area, dataArea, state);\n\n        \n        Shape savedClip = g2.getClip();\n        g2.clip(dataArea);\n\n        drawDomainGridlines(g2, dataArea);\n\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\n        if (rangeAxisState == null) {\n            if (parentState != null) {\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getRangeAxis());\n            }\n        }\n        if (rangeAxisState != null) {\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\n        }\n        \n        \n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }        \n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n\n        \n        boolean foundData = false;\n\n        \n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(\n                AlphaComposite.SRC_OVER, getForegroundAlpha()));\n\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\n        if (order == DatasetRenderingOrder.FORWARD) {\n\n            \n            int datasetCount = this.datasets.size();\n            for (int i = 0; i < datasetCount; i++) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, state);\n                }\n            }\n\n            for (int i = 0; i < datasetCount; i++) {\n                foundData = render(g2, dataArea, i, state) || foundData;\n            }\n\n            \n            for (int i = 0; i < datasetCount; i++) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, state);\n                }\n            }\n        }\n        else {  \n            \n            \n            int datasetCount = this.datasets.size();\n            for (int i = datasetCount - 1; i >= 0; i--) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, state);\n                }\n            }\n            \n            for (int i = this.datasets.size() - 1; i >= 0; i--) {\n                foundData = render(g2, dataArea, i, state) || foundData;   \n            }\n\n            \n            for (int i = datasetCount - 1; i >= 0; i--) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, state);\n                }\n            }\n        }\n        \n        \n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n\n        \n        drawAnnotations(g2, dataArea, state);\n\n        g2.setClip(savedClip);\n        g2.setComposite(originalComposite);\n\n        if (!foundData) {\n            drawNoDataMessage(g2, dataArea);\n        }\n\n        \n        if (isRangeCrosshairVisible()) {\n            \n            drawRangeCrosshair(g2, dataArea, getOrientation(), \n                    getRangeCrosshairValue(), getRangeAxis(),\n                    getRangeCrosshairStroke(), getRangeCrosshairPaint());\n        }\n\n        \n        if (getRenderer() != null) {\n            getRenderer().drawOutline(g2, this, dataArea);\n        }\n        else {\n            drawOutline(g2, dataArea);\n        }\n\n    }\n\n    \n    public void drawBackground(Graphics2D g2, Rectangle2D area) {\n        fillBackground(g2, area, this.orientation);\n        drawBackgroundImage(g2, area);\n    }\n\n    \n    protected Map drawAxes(Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, PlotRenderingInfo plotState) {\n\n        AxisCollection axisCollection = new AxisCollection();\n\n        \n        for (int index = 0; index < this.domainAxes.size(); index++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(index);\n            if (xAxis != null) {\n                axisCollection.add(xAxis, getDomainAxisEdge(index));\n            }\n        }\n\n        \n        for (int index = 0; index < this.rangeAxes.size(); index++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(index);\n            if (yAxis != null) {\n                axisCollection.add(yAxis, getRangeAxisEdge(index));\n            }\n        }\n\n        Map axisStateMap = new HashMap();\n        \n        \n        double cursor = dataArea.getMinY() - this.axisOffset.calculateTopOutset(\n                dataArea.getHeight());\n        Iterator iterator = axisCollection.getAxesAtTop().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, \n                        RectangleEdge.TOP, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        \n        cursor = dataArea.getMaxY() \n                 + this.axisOffset.calculateBottomOutset(dataArea.getHeight());\n        iterator = axisCollection.getAxesAtBottom().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.BOTTOM, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        \n        cursor = dataArea.getMinX() \n                 - this.axisOffset.calculateLeftOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtLeft().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.LEFT, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        \n        cursor = dataArea.getMaxX() \n                 + this.axisOffset.calculateRightOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtRight().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, \n                        RectangleEdge.RIGHT, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n        \n        return axisStateMap;\n        \n    }\n\n    \n    public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, PlotRenderingInfo info) {\n\n        boolean foundData = false;\n        CategoryDataset currentDataset = getDataset(index);\n        CategoryItemRenderer renderer = getRenderer(index);\n        CategoryAxis domainAxis = getDomainAxisForDataset(index);\n        ValueAxis rangeAxis = getRangeAxisForDataset(index);\n        boolean hasData = !DatasetUtilities.isEmptyOrNull(currentDataset);\n        if (hasData && renderer != null) {\n            \n            foundData = true;\n            CategoryItemRendererState state = renderer.initialise(g2, dataArea,\n                    this, index, info);\n            int columnCount = currentDataset.getColumnCount();\n            int rowCount = currentDataset.getRowCount();\n            int passCount = renderer.getPassCount();\n            for (int pass = 0; pass < passCount; pass++) {            \n                if (this.columnRenderingOrder == SortOrder.ASCENDING) {\n                    for (int column = 0; column < columnCount; column++) {\n                        if (this.rowRenderingOrder == SortOrder.ASCENDING) {\n                            for (int row = 0; row < rowCount; row++) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }\n                        }\n                        else {\n                            for (int row = rowCount - 1; row >= 0; row--) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }                        \n                        }\n                    }\n                }\n                else {\n                    for (int column = columnCount - 1; column >= 0; column--) {\n                        if (this.rowRenderingOrder == SortOrder.ASCENDING) {\n                            for (int row = 0; row < rowCount; row++) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }\n                        }\n                        else {\n                            for (int row = rowCount - 1; row >= 0; row--) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }                        \n                        }\n                    }\n                }\n            }\n        }\n        return foundData;\n        \n    }\n\n    \n    protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea) {\n\n        \n        if (isDomainGridlinesVisible()) {\n            CategoryAnchor anchor = getDomainGridlinePosition();\n            RectangleEdge domainAxisEdge = getDomainAxisEdge();\n            Stroke gridStroke = getDomainGridlineStroke();\n            Paint gridPaint = getDomainGridlinePaint();\n            if ((gridStroke != null) && (gridPaint != null)) {\n                \n                CategoryDataset data = getDataset();\n                if (data != null) {\n                    CategoryAxis axis = getDomainAxis();\n                    if (axis != null) {\n                        int columnCount = data.getColumnCount();\n                        for (int c = 0; c < columnCount; c++) {\n                            double xx = axis.getCategoryJava2DCoordinate(\n                                    anchor, c, columnCount, dataArea, \n                                    domainAxisEdge);\n                            CategoryItemRenderer renderer1 = getRenderer();\n                            if (renderer1 != null) {\n                                renderer1.drawDomainGridline(g2, this, \n                                        dataArea, xx);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n \n    \n    protected void drawRangeGridlines(Graphics2D g2, Rectangle2D dataArea, List ticks) {\n        \n        if (isRangeGridlinesVisible()) {\n            Stroke gridStroke = getRangeGridlineStroke();\n            Paint gridPaint = getRangeGridlinePaint();\n            if ((gridStroke != null) && (gridPaint != null)) {\n                ValueAxis axis = getRangeAxis();\n                if (axis != null) {\n                    Iterator iterator = ticks.iterator();\n                    while (iterator.hasNext()) {\n                        ValueTick tick = (ValueTick) iterator.next();\n                        CategoryItemRenderer renderer1 = getRenderer();\n                        if (renderer1 != null) {\n                            renderer1.drawRangeGridline(g2, this, \n                                    getRangeAxis(), dataArea, tick.getValue());\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    \n    protected void drawAnnotations(Graphics2D g2, Rectangle2D dataArea, PlotRenderingInfo info) {\n\n        Iterator iterator = getAnnotations().iterator();\n        while (iterator.hasNext()) {\n            CategoryAnnotation annotation \n                    = (CategoryAnnotation) iterator.next();\n            annotation.draw(g2, this, dataArea, getDomainAxis(), \n                    getRangeAxis(), 0, info);\n        }\n\n    }\n\n    \n    protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer) {\n                                                 \n        CategoryItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        \n        Collection markers = getDomainMarkers(index, layer);\n        CategoryAxis axis = getDomainAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                CategoryMarker marker = (CategoryMarker) iterator.next();\n                r.drawDomainMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n        \n    }\n\n    \n    protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer) {\n                                                 \n        CategoryItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        \n        Collection markers = getRangeMarkers(index, layer);\n        ValueAxis axis = getRangeAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawRangeMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n        \n    }\n\n    \n    protected void drawRangeLine(Graphics2D g2, Rectangle2D dataArea, double value, Stroke stroke, Paint paint) {\n\n        double java2D = getRangeAxis().valueToJava2D(value, dataArea, \n                getRangeAxisEdge());\n        Line2D line = null;\n        if (this.orientation == PlotOrientation.HORIZONTAL) {\n            line = new Line2D.Double(java2D, dataArea.getMinY(), java2D, \n                    dataArea.getMaxY());\n        }\n        else if (this.orientation == PlotOrientation.VERTICAL) {\n            line = new Line2D.Double(dataArea.getMinX(), java2D, \n                    dataArea.getMaxX(), java2D);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n\n    }\n\n    \n    protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, PlotOrientation orientation, double value, ValueAxis axis, Stroke stroke, Paint paint) {\n        \n        if (!axis.getRange().contains(value)) {\n            return;\n        }\n        Line2D line = null;\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            double xx = axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.BOTTOM);\n            line = new Line2D.Double(xx, dataArea.getMinY(), xx, \n                    dataArea.getMaxY());\n        }\n        else {\n            double yy = axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.LEFT);\n            line = new Line2D.Double(dataArea.getMinX(), yy, \n                    dataArea.getMaxX(), yy);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n       \n    }\n    \n    \n    public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        \n        int rangeIndex = this.rangeAxes.indexOf(axis);\n        if (rangeIndex >= 0) {\n            mappedDatasets.addAll(datasetsMappedToRangeAxis(rangeIndex));\n        }\n        else if (axis == getRangeAxis()) {\n            mappedDatasets.addAll(datasetsMappedToRangeAxis(0));\n        }\n\n        \n        \n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            CategoryDataset d = (CategoryDataset) iterator.next();\n            CategoryItemRenderer r = getRendererForDataset(d);\n            if (r != null) {\n                result = Range.combine(result, r.findRangeBounds(d));\n            }\n        }\n        return result;\n\n    }\n\n    \n    private List datasetsMappedToDomainAxis(int axisIndex) {\n        List result = new ArrayList();\n        for (int datasetIndex = 0; datasetIndex < this.datasets.size(); \n                datasetIndex++) {\n            Object dataset = this.datasets.get(datasetIndex);\n            if (dataset != null) {\n                Integer m = (Integer) this.datasetToDomainAxisMap.get(\n                        datasetIndex);\n                if (m == null) {  \n                                  \n                    if (axisIndex == 0) {\n                        result.add(dataset);\n                    }\n                }\n                else {\n                    if (m.intValue() == axisIndex) {\n                        result.add(dataset);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    \n    \n    private List datasetsMappedToRangeAxis(int index) {\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            Object dataset = this.datasets.get(i);\n            if (dataset != null) {\n                Integer m = (Integer) this.datasetToRangeAxisMap.get(i);\n                if (m == null) {  \n                                  \n                    if (index == 0) { \n                        result.add(dataset);\n                    }\n                }\n                else {\n                    if (m.intValue() == index) {\n                        result.add(dataset);\n                    }\n                }\n            }\n        }\n        return result;    \n    }\n\n    \n    public int getWeight() {\n        return this.weight;\n    }\n\n    \n    public void setWeight(int weight) {\n        this.weight = weight;\n        \n    }\n    \n    \n    public AxisSpace getFixedDomainAxisSpace() {\n        return this.fixedDomainAxisSpace;\n    }\n\n    \n    public void setFixedDomainAxisSpace(AxisSpace space) {\n        this.fixedDomainAxisSpace = space;\n        \n    }\n\n    \n    public AxisSpace getFixedRangeAxisSpace() {\n        return this.fixedRangeAxisSpace;\n    }\n\n    \n    public void setFixedRangeAxisSpace(AxisSpace space) {\n        this.fixedRangeAxisSpace = space;\n        \n    }\n\n    \n    public List getCategories() {\n        List result = null;\n        if (getDataset() != null) {\n            result = Collections.unmodifiableList(getDataset().getColumnKeys());\n        }\n        return result;\n    }\n    \n    \n    public List getCategoriesForAxis(CategoryAxis axis) {\n        List result = new ArrayList();\n        int axisIndex = this.domainAxes.indexOf(axis);\n        List datasets = datasetsMappedToDomainAxis(axisIndex);\n        Iterator iterator = datasets.iterator();\n        while (iterator.hasNext()) {\n            CategoryDataset dataset = (CategoryDataset) iterator.next();\n            \n            for (int i = 0; i < dataset.getColumnCount(); i++) {\n                Comparable category = dataset.getColumnKey(i);\n                if (!result.contains(category)) {\n                    result.add(category);\n                }\n            }\n        }\n        return result;\n    }\n\n    \n    public boolean getDrawSharedDomainAxis() {\n        return this.drawSharedDomainAxis;\n    }\n    \n    \n    public void setDrawSharedDomainAxis(boolean draw) {\n        this.drawSharedDomainAxis = draw;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    \n    public boolean isDomainZoomable() {\n        return false;\n    }\n    \n    \n    public boolean isRangeZoomable() {\n        return true;\n    }\n\n    \n    public void zoomDomainAxes(double factor, PlotRenderingInfo state, Point2D source) {\n        \n    }\n\n    \n    public void zoomDomainAxes(double lowerPercent, double upperPercent, PlotRenderingInfo state, Point2D source) {\n        \n    }\n    \n    \n    public void zoomDomainAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor) {\n        \n    }\n\n    \n    public void zoomRangeAxes(double factor, PlotRenderingInfo state, Point2D source) {\n        \n        zoomRangeAxes(factor, state, source, false);    \n    }\n\n    \n    public void zoomRangeAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor) {\n                \n        \n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                if (useAnchor) {\n                    \n                    \n                    double sourceY = source.getY();\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\n                        sourceY = source.getX();\n                    }\n                    double anchorY = rangeAxis.java2DToValue(sourceY, \n                            info.getDataArea(), getRangeAxisEdge());\n                    rangeAxis.resizeRange(factor, anchorY);\n                }\n                else {\n                    rangeAxis.resizeRange(factor);\n                }\n            }\n        }\n    }\n\n    \n    public void zoomRangeAxes(double lowerPercent, double upperPercent, PlotRenderingInfo state, Point2D source) {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                rangeAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n    \n    \n    public double getAnchorValue() {\n        return this.anchorValue;\n    }\n\n    \n    public void setAnchorValue(double value) {\n        setAnchorValue(value, true);\n    }\n\n    \n    public void setAnchorValue(double value, boolean notify) {\n        this.anchorValue = value;\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n    \n    \n    public boolean equals(Object obj) {\n    \n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof CategoryPlot)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n\n        CategoryPlot that = (CategoryPlot) obj;\n            \n        if (this.orientation != that.orientation) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.axisOffset, that.axisOffset)) {\n            return false;\n        }\n        if (!this.domainAxes.equals(that.domainAxes)) {\n            return false;\n        }\n        if (!this.domainAxisLocations.equals(that.domainAxisLocations)) {\n            return false;\n        }\n        if (this.drawSharedDomainAxis != that.drawSharedDomainAxis) {\n            return false;\n        }\n        if (!this.rangeAxes.equals(that.rangeAxes)) {\n            return false;\n        }\n        if (!this.rangeAxisLocations.equals(that.rangeAxisLocations)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToDomainAxisMap, \n                that.datasetToDomainAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToRangeAxisMap, \n                that.datasetToRangeAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.renderers, that.renderers)) {\n            return false;\n        }\n        if (this.renderingOrder != that.renderingOrder) {\n            return false;\n        }\n        if (this.columnRenderingOrder != that.columnRenderingOrder) {\n            return false;\n        }\n        if (this.rowRenderingOrder != that.rowRenderingOrder) {\n            return false;\n        }\n        if (this.domainGridlinesVisible != that.domainGridlinesVisible) {\n            return false;\n        }\n        if (this.domainGridlinePosition != that.domainGridlinePosition) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainGridlineStroke, \n                that.domainGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainGridlinePaint, \n                that.domainGridlinePaint)) {\n            return false;\n        }\n        if (this.rangeGridlinesVisible != that.rangeGridlinesVisible) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeGridlineStroke, \n                that.rangeGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeGridlinePaint, \n                that.rangeGridlinePaint)) {\n            return false;\n        }\n        if (this.anchorValue != that.anchorValue) {\n            return false;\n        }\n        if (this.rangeCrosshairVisible != that.rangeCrosshairVisible) {\n            return false;\n        }\n        if (this.rangeCrosshairValue != that.rangeCrosshairValue) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeCrosshairStroke, \n                that.rangeCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeCrosshairPaint, \n                that.rangeCrosshairPaint)) {\n            return false;\n        }\n        if (this.rangeCrosshairLockedOnData \n                != that.rangeCrosshairLockedOnData) {\n            return false;\n        }      \n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers, \n                that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers, \n                that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.annotations, that.annotations)) {\n            return false;\n        }\n        if (this.weight != that.weight) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.fixedDomainAxisSpace, \n                that.fixedDomainAxisSpace)) {\n            return false;\n        }    \n        if (!ObjectUtilities.equal(this.fixedRangeAxisSpace, \n                that.fixedRangeAxisSpace)) {\n            return false;\n        }    \n        \n        return true;\n        \n    }\n    \n    \n    public Object clone() throws CloneNotSupportedException {\n        \n        CategoryPlot clone = (CategoryPlot) super.clone();\n        \n        clone.domainAxes = new ObjectList();\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i);\n            if (xAxis != null) {\n                CategoryAxis clonedAxis = (CategoryAxis) xAxis.clone();\n                clone.setDomainAxis(i, clonedAxis);\n            }\n        }\n        clone.domainAxisLocations \n            = (ObjectList) this.domainAxisLocations.clone();\n\n        clone.rangeAxes = new ObjectList();\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (yAxis != null) {\n                ValueAxis clonedAxis = (ValueAxis) yAxis.clone();\n                clone.setRangeAxis(i, clonedAxis);\n            }\n        }\n        clone.rangeAxisLocations = (ObjectList) this.rangeAxisLocations.clone();\n\n        clone.datasets = (ObjectList) this.datasets.clone();\n        for (int i = 0; i < clone.datasets.size(); i++) {\n            CategoryDataset dataset = clone.getDataset(i);\n            if (dataset != null) {\n                dataset.addChangeListener(clone);\n            }\n        }\n        clone.datasetToDomainAxisMap \n            = (ObjectList) this.datasetToDomainAxisMap.clone();\n        clone.datasetToRangeAxisMap \n            = (ObjectList) this.datasetToRangeAxisMap.clone();\n        clone.renderers = (ObjectList) this.renderers.clone();\n        if (this.fixedDomainAxisSpace != null) {\n            clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedDomainAxisSpace);\n        }\n        if (this.fixedRangeAxisSpace != null) {\n            clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedRangeAxisSpace);\n        }\n        \n        return clone;\n            \n    }\n    \n    \n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writeStroke(this.domainGridlineStroke, stream);\n        SerialUtilities.writePaint(this.domainGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeGridlineStroke, stream);\n        SerialUtilities.writePaint(this.rangeGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeCrosshairStroke, stream);\n        SerialUtilities.writePaint(this.rangeCrosshairPaint, stream);\n    }\n\n    \n    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {\n\n        stream.defaultReadObject();\n        this.domainGridlineStroke = SerialUtilities.readStroke(stream);\n        this.domainGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeGridlineStroke = SerialUtilities.readStroke(stream);\n        this.rangeGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeCrosshairStroke = SerialUtilities.readStroke(stream);\n        this.rangeCrosshairPaint = SerialUtilities.readPaint(stream);\n\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i);\n            if (xAxis != null) {\n                xAxis.setPlot(this);\n                xAxis.addChangeListener(this);\n            }\n        } \n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (yAxis != null) {\n                yAxis.setPlot(this);   \n                yAxis.addChangeListener(this);\n            }\n        }\n        int datasetCount = this.datasets.size();\n        for (int i = 0; i < datasetCount; i++) {\n            Dataset dataset = (Dataset) this.datasets.get(i);\n            if (dataset != null) {\n                dataset.addChangeListener(this);\n            }\n        }\n        int rendererCount = this.renderers.size();\n        for (int i = 0; i < rendererCount; i++) {\n            CategoryItemRenderer renderer \n                = (CategoryItemRenderer) this.renderers.get(i);\n            if (renderer != null) {\n                renderer.addChangeListener(this);\n            }\n        }\n\n    }\n\n}\n",
      "buggy_signatures": [
        "public CategoryPlot(CategoryDataset dataset, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryItemRenderer renderer)",
        "public String getPlotType()",
        "public PlotOrientation getOrientation()",
        "public void setOrientation(PlotOrientation orientation)",
        "public RectangleInsets getAxisOffset()",
        "public void setAxisOffset(RectangleInsets offset)",
        "public CategoryAxis getDomainAxis()",
        "public CategoryAxis getDomainAxis(int index)",
        "public void setDomainAxis(CategoryAxis axis)",
        "public void setDomainAxis(int index, CategoryAxis axis)",
        "public void setDomainAxis(int index, CategoryAxis axis, boolean notify)",
        "public void setDomainAxes(CategoryAxis[] axes)",
        "public int getDomainAxisIndex(CategoryAxis axis)",
        "public AxisLocation getDomainAxisLocation()",
        "public AxisLocation getDomainAxisLocation(int index)",
        "public void setDomainAxisLocation(AxisLocation location)",
        "public void setDomainAxisLocation(AxisLocation location, boolean notify)",
        "public void setDomainAxisLocation(int index, AxisLocation location)",
        "public void setDomainAxisLocation(int index, AxisLocation location, boolean notify)",
        "public RectangleEdge getDomainAxisEdge()",
        "public RectangleEdge getDomainAxisEdge(int index)",
        "public int getDomainAxisCount()",
        "public void clearDomainAxes()",
        "public void configureDomainAxes()",
        "public ValueAxis getRangeAxis()",
        "public ValueAxis getRangeAxis(int index)",
        "public void setRangeAxis(ValueAxis axis)",
        "public void setRangeAxis(int index, ValueAxis axis)",
        "public void setRangeAxis(int index, ValueAxis axis, boolean notify)",
        "public void setRangeAxes(ValueAxis[] axes)",
        "public int getRangeAxisIndex(ValueAxis axis)",
        "public AxisLocation getRangeAxisLocation()",
        "public AxisLocation getRangeAxisLocation(int index)",
        "public void setRangeAxisLocation(AxisLocation location)",
        "public void setRangeAxisLocation(AxisLocation location, boolean notify)",
        "public void setRangeAxisLocation(int index, AxisLocation location)",
        "public void setRangeAxisLocation(int index, AxisLocation location, boolean notify)",
        "public RectangleEdge getRangeAxisEdge()",
        "public RectangleEdge getRangeAxisEdge(int index)",
        "public int getRangeAxisCount()",
        "public void clearRangeAxes()",
        "public void configureRangeAxes()",
        "public CategoryDataset getDataset()",
        "public CategoryDataset getDataset(int index)",
        "public void setDataset(CategoryDataset dataset)",
        "public void setDataset(int index, CategoryDataset dataset)",
        "public int getDatasetCount()",
        "public void mapDatasetToDomainAxis(int index, int axisIndex)",
        "public CategoryAxis getDomainAxisForDataset(int index)",
        "public void mapDatasetToRangeAxis(int index, int axisIndex)",
        "public ValueAxis getRangeAxisForDataset(int index)",
        "public CategoryItemRenderer getRenderer()",
        "public CategoryItemRenderer getRenderer(int index)",
        "public void setRenderer(CategoryItemRenderer renderer)",
        "public void setRenderer(CategoryItemRenderer renderer, boolean notify)",
        "public void setRenderer(int index, CategoryItemRenderer renderer)",
        "public void setRenderer(int index, CategoryItemRenderer renderer, boolean notify)",
        "public void setRenderers(CategoryItemRenderer[] renderers)",
        "public CategoryItemRenderer getRendererForDataset(CategoryDataset dataset)",
        "public int getIndexOf(CategoryItemRenderer renderer)",
        "public DatasetRenderingOrder getDatasetRenderingOrder()",
        "public void setDatasetRenderingOrder(DatasetRenderingOrder order)",
        "public SortOrder getColumnRenderingOrder()",
        "public void setColumnRenderingOrder(SortOrder order)",
        "public SortOrder getRowRenderingOrder()",
        "public void setRowRenderingOrder(SortOrder order)",
        "public boolean isDomainGridlinesVisible()",
        "public void setDomainGridlinesVisible(boolean visible)",
        "public CategoryAnchor getDomainGridlinePosition()",
        "public void setDomainGridlinePosition(CategoryAnchor position)",
        "public Stroke getDomainGridlineStroke()",
        "public void setDomainGridlineStroke(Stroke stroke)",
        "public Paint getDomainGridlinePaint()",
        "public void setDomainGridlinePaint(Paint paint)",
        "public boolean isRangeGridlinesVisible()",
        "public void setRangeGridlinesVisible(boolean visible)",
        "public Stroke getRangeGridlineStroke()",
        "public void setRangeGridlineStroke(Stroke stroke)",
        "public Paint getRangeGridlinePaint()",
        "public void setRangeGridlinePaint(Paint paint)",
        "public LegendItemCollection getFixedLegendItems()",
        "public void setFixedLegendItems(LegendItemCollection items)",
        "public LegendItemCollection getLegendItems()",
        "public void handleClick(int x, int y, PlotRenderingInfo info)",
        "public void zoom(double percent)",
        "public void datasetChanged(DatasetChangeEvent event)",
        "public void rendererChanged(RendererChangeEvent event)",
        "public void addDomainMarker(CategoryMarker marker)",
        "public void addDomainMarker(CategoryMarker marker, Layer layer)",
        "public void addDomainMarker(int index, CategoryMarker marker, Layer layer)",
        "public void clearDomainMarkers()",
        "public Collection getDomainMarkers(Layer layer)",
        "public Collection getDomainMarkers(int index, Layer layer)",
        "public void clearDomainMarkers(int index)",
        "public void addRangeMarker(Marker marker)",
        "public void addRangeMarker(Marker marker, Layer layer)",
        "public void addRangeMarker(int index, Marker marker, Layer layer)",
        "public void clearRangeMarkers()",
        "public Collection getRangeMarkers(Layer layer)",
        "public Collection getRangeMarkers(int index, Layer layer)",
        "public void clearRangeMarkers(int index)",
        "public boolean isRangeCrosshairVisible()",
        "public void setRangeCrosshairVisible(boolean flag)",
        "public boolean isRangeCrosshairLockedOnData()",
        "public void setRangeCrosshairLockedOnData(boolean flag)",
        "public double getRangeCrosshairValue()",
        "public void setRangeCrosshairValue(double value)",
        "public void setRangeCrosshairValue(double value, boolean notify)",
        "public Stroke getRangeCrosshairStroke()",
        "public void setRangeCrosshairStroke(Stroke stroke)",
        "public Paint getRangeCrosshairPaint()",
        "public void setRangeCrosshairPaint(Paint paint)",
        "public List getAnnotations()",
        "public void addAnnotation(CategoryAnnotation annotation)",
        "public boolean removeAnnotation(CategoryAnnotation annotation)",
        "public void clearAnnotations()",
        "protected AxisSpace calculateDomainAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space)",
        "protected AxisSpace calculateRangeAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space)",
        "protected AxisSpace calculateAxisSpace(Graphics2D g2, Rectangle2D plotArea)",
        "public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo state)",
        "public void drawBackground(Graphics2D g2, Rectangle2D area)",
        "protected Map drawAxes(Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, PlotRenderingInfo plotState)",
        "public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, PlotRenderingInfo info)",
        "protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea)",
        "protected void drawRangeGridlines(Graphics2D g2, Rectangle2D dataArea, List ticks)",
        "protected void drawAnnotations(Graphics2D g2, Rectangle2D dataArea, PlotRenderingInfo info)",
        "protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer)",
        "protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer)",
        "protected void drawRangeLine(Graphics2D g2, Rectangle2D dataArea, double value, Stroke stroke, Paint paint)",
        "protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, PlotOrientation orientation, double value, ValueAxis axis, Stroke stroke, Paint paint)",
        "public Range getDataRange(ValueAxis axis)",
        "private List datasetsMappedToDomainAxis(int axisIndex)",
        "private List datasetsMappedToRangeAxis(int index)",
        "public int getWeight()",
        "public void setWeight(int weight)",
        "public AxisSpace getFixedDomainAxisSpace()",
        "public void setFixedDomainAxisSpace(AxisSpace space)",
        "public AxisSpace getFixedRangeAxisSpace()",
        "public void setFixedRangeAxisSpace(AxisSpace space)",
        "public List getCategories()",
        "public List getCategoriesForAxis(CategoryAxis axis)",
        "public boolean getDrawSharedDomainAxis()",
        "public void setDrawSharedDomainAxis(boolean draw)",
        "public boolean isDomainZoomable()",
        "public boolean isRangeZoomable()",
        "public void zoomDomainAxes(double factor, PlotRenderingInfo state, Point2D source)",
        "public void zoomDomainAxes(double lowerPercent, double upperPercent, PlotRenderingInfo state, Point2D source)",
        "public void zoomDomainAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor)",
        "public void zoomRangeAxes(double factor, PlotRenderingInfo state, Point2D source)",
        "public void zoomRangeAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor)",
        "public void zoomRangeAxes(double lowerPercent, double upperPercent, PlotRenderingInfo state, Point2D source)",
        "public double getAnchorValue()",
        "public void setAnchorValue(double value)",
        "public void setAnchorValue(double value, boolean notify)",
        "public boolean equals(Object obj)",
        "public Object clone() throws CloneNotSupportedException",
        "private void writeObject(ObjectOutputStream stream) throws IOException",
        "private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException"
      ],
      "fixed_signatures": [
        "public CategoryPlot(CategoryDataset dataset, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryItemRenderer renderer)",
        "public String getPlotType()",
        "public PlotOrientation getOrientation()",
        "public void setOrientation(PlotOrientation orientation)",
        "public RectangleInsets getAxisOffset()",
        "public void setAxisOffset(RectangleInsets offset)",
        "public CategoryAxis getDomainAxis()",
        "public CategoryAxis getDomainAxis(int index)",
        "public void setDomainAxis(CategoryAxis axis)",
        "public void setDomainAxis(int index, CategoryAxis axis)",
        "public void setDomainAxis(int index, CategoryAxis axis, boolean notify)",
        "public void setDomainAxes(CategoryAxis[] axes)",
        "public int getDomainAxisIndex(CategoryAxis axis)",
        "public AxisLocation getDomainAxisLocation()",
        "public AxisLocation getDomainAxisLocation(int index)",
        "public void setDomainAxisLocation(AxisLocation location)",
        "public void setDomainAxisLocation(AxisLocation location, boolean notify)",
        "public void setDomainAxisLocation(int index, AxisLocation location)",
        "public void setDomainAxisLocation(int index, AxisLocation location, boolean notify)",
        "public RectangleEdge getDomainAxisEdge()",
        "public RectangleEdge getDomainAxisEdge(int index)",
        "public int getDomainAxisCount()",
        "public void clearDomainAxes()",
        "public void configureDomainAxes()",
        "public ValueAxis getRangeAxis()",
        "public ValueAxis getRangeAxis(int index)",
        "public void setRangeAxis(ValueAxis axis)",
        "public void setRangeAxis(int index, ValueAxis axis)",
        "public void setRangeAxis(int index, ValueAxis axis, boolean notify)",
        "public void setRangeAxes(ValueAxis[] axes)",
        "public int getRangeAxisIndex(ValueAxis axis)",
        "public AxisLocation getRangeAxisLocation()",
        "public AxisLocation getRangeAxisLocation(int index)",
        "public void setRangeAxisLocation(AxisLocation location)",
        "public void setRangeAxisLocation(AxisLocation location, boolean notify)",
        "public void setRangeAxisLocation(int index, AxisLocation location)",
        "public void setRangeAxisLocation(int index, AxisLocation location, boolean notify)",
        "public RectangleEdge getRangeAxisEdge()",
        "public RectangleEdge getRangeAxisEdge(int index)",
        "public int getRangeAxisCount()",
        "public void clearRangeAxes()",
        "public void configureRangeAxes()",
        "public CategoryDataset getDataset()",
        "public CategoryDataset getDataset(int index)",
        "public void setDataset(CategoryDataset dataset)",
        "public void setDataset(int index, CategoryDataset dataset)",
        "public int getDatasetCount()",
        "public void mapDatasetToDomainAxis(int index, int axisIndex)",
        "public CategoryAxis getDomainAxisForDataset(int index)",
        "public void mapDatasetToRangeAxis(int index, int axisIndex)",
        "public ValueAxis getRangeAxisForDataset(int index)",
        "public CategoryItemRenderer getRenderer()",
        "public CategoryItemRenderer getRenderer(int index)",
        "public void setRenderer(CategoryItemRenderer renderer)",
        "public void setRenderer(CategoryItemRenderer renderer, boolean notify)",
        "public void setRenderer(int index, CategoryItemRenderer renderer)",
        "public void setRenderer(int index, CategoryItemRenderer renderer, boolean notify)",
        "public void setRenderers(CategoryItemRenderer[] renderers)",
        "public CategoryItemRenderer getRendererForDataset(CategoryDataset dataset)",
        "public int getIndexOf(CategoryItemRenderer renderer)",
        "public DatasetRenderingOrder getDatasetRenderingOrder()",
        "public void setDatasetRenderingOrder(DatasetRenderingOrder order)",
        "public SortOrder getColumnRenderingOrder()",
        "public void setColumnRenderingOrder(SortOrder order)",
        "public SortOrder getRowRenderingOrder()",
        "public void setRowRenderingOrder(SortOrder order)",
        "public boolean isDomainGridlinesVisible()",
        "public void setDomainGridlinesVisible(boolean visible)",
        "public CategoryAnchor getDomainGridlinePosition()",
        "public void setDomainGridlinePosition(CategoryAnchor position)",
        "public Stroke getDomainGridlineStroke()",
        "public void setDomainGridlineStroke(Stroke stroke)",
        "public Paint getDomainGridlinePaint()",
        "public void setDomainGridlinePaint(Paint paint)",
        "public boolean isRangeGridlinesVisible()",
        "public void setRangeGridlinesVisible(boolean visible)",
        "public Stroke getRangeGridlineStroke()",
        "public void setRangeGridlineStroke(Stroke stroke)",
        "public Paint getRangeGridlinePaint()",
        "public void setRangeGridlinePaint(Paint paint)",
        "public LegendItemCollection getFixedLegendItems()",
        "public void setFixedLegendItems(LegendItemCollection items)",
        "public LegendItemCollection getLegendItems()",
        "public void handleClick(int x, int y, PlotRenderingInfo info)",
        "public void zoom(double percent)",
        "public void datasetChanged(DatasetChangeEvent event)",
        "public void rendererChanged(RendererChangeEvent event)",
        "public void addDomainMarker(CategoryMarker marker)",
        "public void addDomainMarker(CategoryMarker marker, Layer layer)",
        "public void addDomainMarker(int index, CategoryMarker marker, Layer layer)",
        "public void clearDomainMarkers()",
        "public Collection getDomainMarkers(Layer layer)",
        "public Collection getDomainMarkers(int index, Layer layer)",
        "public void clearDomainMarkers(int index)",
        "public void addRangeMarker(Marker marker)",
        "public void addRangeMarker(Marker marker, Layer layer)",
        "public void addRangeMarker(int index, Marker marker, Layer layer)",
        "public void clearRangeMarkers()",
        "public Collection getRangeMarkers(Layer layer)",
        "public Collection getRangeMarkers(int index, Layer layer)",
        "public void clearRangeMarkers(int index)",
        "public boolean isRangeCrosshairVisible()",
        "public void setRangeCrosshairVisible(boolean flag)",
        "public boolean isRangeCrosshairLockedOnData()",
        "public void setRangeCrosshairLockedOnData(boolean flag)",
        "public double getRangeCrosshairValue()",
        "public void setRangeCrosshairValue(double value)",
        "public void setRangeCrosshairValue(double value, boolean notify)",
        "public Stroke getRangeCrosshairStroke()",
        "public void setRangeCrosshairStroke(Stroke stroke)",
        "public Paint getRangeCrosshairPaint()",
        "public void setRangeCrosshairPaint(Paint paint)",
        "public List getAnnotations()",
        "public void addAnnotation(CategoryAnnotation annotation)",
        "public boolean removeAnnotation(CategoryAnnotation annotation)",
        "public void clearAnnotations()",
        "protected AxisSpace calculateDomainAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space)",
        "protected AxisSpace calculateRangeAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space)",
        "protected AxisSpace calculateAxisSpace(Graphics2D g2, Rectangle2D plotArea)",
        "public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo state)",
        "public void drawBackground(Graphics2D g2, Rectangle2D area)",
        "protected Map drawAxes(Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, PlotRenderingInfo plotState)",
        "public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, PlotRenderingInfo info)",
        "protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea)",
        "protected void drawRangeGridlines(Graphics2D g2, Rectangle2D dataArea, List ticks)",
        "protected void drawAnnotations(Graphics2D g2, Rectangle2D dataArea, PlotRenderingInfo info)",
        "protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer)",
        "protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer)",
        "protected void drawRangeLine(Graphics2D g2, Rectangle2D dataArea, double value, Stroke stroke, Paint paint)",
        "protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, PlotOrientation orientation, double value, ValueAxis axis, Stroke stroke, Paint paint)",
        "public Range getDataRange(ValueAxis axis)",
        "private List datasetsMappedToDomainAxis(int axisIndex)",
        "private List datasetsMappedToRangeAxis(int index)",
        "public int getWeight()",
        "public void setWeight(int weight)",
        "public AxisSpace getFixedDomainAxisSpace()",
        "public void setFixedDomainAxisSpace(AxisSpace space)",
        "public AxisSpace getFixedRangeAxisSpace()",
        "public void setFixedRangeAxisSpace(AxisSpace space)",
        "public List getCategories()",
        "public List getCategoriesForAxis(CategoryAxis axis)",
        "public boolean getDrawSharedDomainAxis()",
        "public void setDrawSharedDomainAxis(boolean draw)",
        "public boolean isDomainZoomable()",
        "public boolean isRangeZoomable()",
        "public void zoomDomainAxes(double factor, PlotRenderingInfo state, Point2D source)",
        "public void zoomDomainAxes(double lowerPercent, double upperPercent, PlotRenderingInfo state, Point2D source)",
        "public void zoomDomainAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor)",
        "public void zoomRangeAxes(double factor, PlotRenderingInfo state, Point2D source)",
        "public void zoomRangeAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor)",
        "public void zoomRangeAxes(double lowerPercent, double upperPercent, PlotRenderingInfo state, Point2D source)",
        "public double getAnchorValue()",
        "public void setAnchorValue(double value)",
        "public void setAnchorValue(double value, boolean notify)",
        "public boolean equals(Object obj)",
        "public Object clone() throws CloneNotSupportedException",
        "private void writeObject(ObjectOutputStream stream) throws IOException",
        "private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException"
      ],
      "methods": [
        {
          "buggy_method": "  public int getDomainAxisIndex(CategoryAxis axis) {\n  return this.domainAxes.indexOf(axis);\n  }",
          "fixed_method": "  public int getDomainAxisIndex(CategoryAxis axis) {\n  if (axis == null) {\n  throw new IllegalArgumentException(\"Null 'axis' argument.\");\n  }\n  return this.domainAxes.indexOf(axis);\n  }",
          "diff": [
            "@@ -695,6 +695,9 @@",
            "      * @since 1.0.3\n",
            "      */\n",
            "     public int getDomainAxisIndex(CategoryAxis axis) {\n",
            "+        if (axis == null) {\n",
            "+            throw new IllegalArgumentException(\"Null 'axis' argument.\");\n",
            "+        }\n",
            "         return this.domainAxes.indexOf(axis);\n",
            "     }\n",
            "     \n"
          ],
          "changed_lines": 3
        },
        {
          "buggy_method": "  public int getRangeAxisIndex(ValueAxis axis) {\n  int result = this.rangeAxes.indexOf(axis);\n  if (result < 0) { \n  Plot parent = getParent();\n  if (parent instanceof CategoryPlot) {\n  CategoryPlot p = (CategoryPlot) parent;\n  result = p.getRangeAxisIndex(axis);\n  }\n  }\n  return result;\n  }",
          "fixed_method": "  public int getRangeAxisIndex(ValueAxis axis) {\n  if (axis == null) {\n  throw new IllegalArgumentException(\"Null 'axis' argument.\");\n  }\n  int result = this.rangeAxes.indexOf(axis);\n  if (result < 0) { \n  Plot parent = getParent();\n  if (parent instanceof CategoryPlot) {\n  CategoryPlot p = (CategoryPlot) parent;\n  result = p.getRangeAxisIndex(axis);\n  }\n  }\n  return result;\n  }",
          "diff": [
            "@@ -970,6 +973,9 @@",
            "      * @since 1.0.7\n",
            "      */\n",
            "     public int getRangeAxisIndex(ValueAxis axis) {\n",
            "+        if (axis == null) {\n",
            "+            throw new IllegalArgumentException(\"Null 'axis' argument.\");\n",
            "+        }\n",
            "         int result = this.rangeAxes.indexOf(axis);\n",
            "         if (result < 0) { // try the parent plot\n",
            "             Plot parent = getParent();\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
