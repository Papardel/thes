{
  "bug_id": "11",
  "failed_tests": {
    "com.google.gson.functional.PrimitiveTest": [
      {
        "methodName": "testNumberAsStringDeserialization",
        "error": "com.google.gson.JsonSyntaxException",
        "message": "Expecting number, got: STRING",
        "fail_line": "    Number value = gson.fromJson(\"\\\"18\\\"\", Number.class);",
        "test_source": "  public void testNumberAsStringDeserialization() {\n  Number value = gson.fromJson(\"\\\"18\\\"\", Number.class);\n  assertEquals(18, value.intValue());\n  }",
        "stack": [
          "TypeAdapters$14.read line 373, TypeAdapters$14.read line 362, Gson.fromJson line 887, Gson.fromJson line 852, Gson.fromJson line 801, Gson.fromJson line 773, PrimitiveTest.testNumberAsStringDeserialization line 162"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/google/gson/internal/bind/TypeAdapters.java",
      "buggy_full_code": "\n\npackage com.google.gson.internal.bind;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.UUID;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicIntegerArray;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonIOException;\nimport com.google.gson.JsonNull;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonPrimitive;\nimport com.google.gson.JsonSyntaxException;\nimport com.google.gson.TypeAdapter;\nimport com.google.gson.TypeAdapterFactory;\nimport com.google.gson.annotations.SerializedName;\nimport com.google.gson.internal.LazilyParsedNumber;\nimport com.google.gson.reflect.TypeToken;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport com.google.gson.stream.JsonWriter;\n\n\npublic final class TypeAdapters { private TypeAdapters() {\n    throw new UnsupportedOperationException();\n  }\n\n  @SuppressWarnings(\"rawtypes\")\n  public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n    @Override\n    public void write(JsonWriter out, Class value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n      } else {\n        throw new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n            + value.getName() + \". Forgot to register a type adapter?\");\n      }\n    }\n    @Override\n    public Class read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else {\n        throw new UnsupportedOperationException(\n            \"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n      }\n    }\n  };\n  public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS); public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() {\n    @Override public BitSet read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      BitSet bitset = new BitSet();\n      in.beginArray();\n      int i = 0;\n      JsonToken tokenType = in.peek();\n      while (tokenType != JsonToken.END_ARRAY) {\n        boolean set;\n        switch (tokenType) {\n        case NUMBER:\n          set = in.nextInt() != 0;\n          break;\n        case BOOLEAN:\n          set = in.nextBoolean();\n          break;\n        case STRING:\n          String stringValue = in.nextString();\n          try {\n            set = Integer.parseInt(stringValue) != 0;\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(\n                \"Error: Expecting: bitset number value (1, 0), Found: \" + stringValue);\n          }\n          break;\n        default:\n          throw new JsonSyntaxException(\"Invalid bitset value type: \" + tokenType);\n        }\n        if (set) {\n          bitset.set(i);\n        }\n        ++i;\n        tokenType = in.peek();\n      }\n      in.endArray();\n      return bitset;\n    }\n\n    @Override public void write(JsonWriter out, BitSet src) throws IOException {\n      if (src == null) {\n        out.nullValue();\n        return;\n      }\n\n      out.beginArray();\n      for (int i = 0; i < src.length(); i++) {\n        int value = (src.get(i)) ? 1 : 0;\n        out.value(value);\n      }\n      out.endArray();\n    }\n  };\n\n  public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET); public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {\n    @Override\n    public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else if (in.peek() == JsonToken.STRING) {\n        \n        return Boolean.parseBoolean(in.nextString());\n      }\n      return in.nextBoolean();\n    }\n    @Override\n    public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  \n  public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() {\n    @Override public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return Boolean.valueOf(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value == null ? \"null\" : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory BOOLEAN_FACTORY = newFactory(boolean.class, Boolean.class, BOOLEAN); public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        int intValue = in.nextInt();\n        return (byte) intValue;\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory BYTE_FACTORY = newFactory(byte.class, Byte.class, BYTE); public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return (short) in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory SHORT_FACTORY = newFactory(short.class, Short.class, SHORT); public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n  public static final TypeAdapterFactory INTEGER_FACTORY = newFactory(int.class, Integer.class, INTEGER); public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() {\n    @Override public AtomicInteger read(JsonReader in) throws IOException {\n      try {\n        return new AtomicInteger(in.nextInt());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override public void write(JsonWriter out, AtomicInteger value) throws IOException {\n      out.value(value.get());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY = newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER); public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() {\n    @Override public AtomicBoolean read(JsonReader in) throws IOException {\n      return new AtomicBoolean(in.nextBoolean());\n    }\n    @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException {\n      out.value(value.get());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY = newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN); public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() {\n    @Override public AtomicIntegerArray read(JsonReader in) throws IOException {\n        List<Integer> list = new ArrayList<Integer>();\n        in.beginArray();\n        while (in.hasNext()) {\n          try {\n            int integer = in.nextInt();\n            list.add(integer);\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(e);\n          }\n        }\n        in.endArray();\n        int length = list.size();\n        AtomicIntegerArray array = new AtomicIntegerArray(length);\n        for (int i = 0; i < length; ++i) {\n          array.set(i, list.get(i));\n        }\n        return array;\n    }\n    @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException {\n      out.beginArray();\n      for (int i = 0, length = value.length(); i < length; i++) {\n        out.value(value.get(i));\n      }\n      out.endArray();\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY = newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY); public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextLong();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return (float) in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      JsonToken jsonToken = in.peek();\n      switch (jsonToken) {\n      case NULL:\n        in.nextNull();\n        return null;\n      case NUMBER:\n        return new LazilyParsedNumber(in.nextString());\n      default:\n        throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER); public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() {\n    @Override\n    public Character read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String str = in.nextString();\n      if (str.length() != 1) {\n        throw new JsonSyntaxException(\"Expecting character, got: \" + str);\n      }\n      return str.charAt(0);\n    }\n    @Override\n    public void write(JsonWriter out, Character value) throws IOException {\n      out.value(value == null ? null : String.valueOf(value));\n    }\n  };\n\n  public static final TypeAdapterFactory CHARACTER_FACTORY = newFactory(char.class, Character.class, CHARACTER); public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {\n    @Override\n    public String read(JsonReader in) throws IOException {\n      JsonToken peek = in.peek();\n      if (peek == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      \n      if (peek == JsonToken.BOOLEAN) {\n        return Boolean.toString(in.nextBoolean());\n      }\n      return in.nextString();\n    }\n    @Override\n    public void write(JsonWriter out, String value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() {\n    @Override public BigDecimal read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigDecimal(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigDecimal value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() {\n    @Override public BigInteger read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigInteger(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigInteger value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING); public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() {\n    @Override\n    public StringBuilder read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuilder(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuilder value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUILDER_FACTORY = newFactory(StringBuilder.class, STRING_BUILDER); public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() {\n    @Override\n    public StringBuffer read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuffer(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuffer value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUFFER_FACTORY = newFactory(StringBuffer.class, STRING_BUFFER); public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() {\n    @Override\n    public URL read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String nextString = in.nextString();\n      return \"null\".equals(nextString) ? null : new URL(nextString);\n    }\n    @Override\n    public void write(JsonWriter out, URL value) throws IOException {\n      out.value(value == null ? null : value.toExternalForm());\n    }\n  };\n\n  public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL); public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() {\n    @Override\n    public URI read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        String nextString = in.nextString();\n        return \"null\".equals(nextString) ? null : new URI(nextString);\n      } catch (URISyntaxException e) {\n        throw new JsonIOException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, URI value) throws IOException {\n      out.value(value == null ? null : value.toASCIIString());\n    }\n  };\n\n  public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI); public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() {\n    @Override\n    public InetAddress read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      \n      return InetAddress.getByName(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, InetAddress value) throws IOException {\n      out.value(value == null ? null : value.getHostAddress());\n    }\n  };\n\n  public static final TypeAdapterFactory INET_ADDRESS_FACTORY = newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS); public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() {\n    @Override\n    public UUID read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return java.util.UUID.fromString(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, UUID value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID); public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() {\n    @Override\n    public Currency read(JsonReader in) throws IOException {\n      return Currency.getInstance(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, Currency value) throws IOException {\n      out.value(value.getCurrencyCode());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY); public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings(\"unchecked\") \n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      if (typeToken.getRawType() != Timestamp.class) {\n        return null;\n      }\n\n      final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\n      return (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n        @Override public Timestamp read(JsonReader in) throws IOException {\n          Date date = dateTypeAdapter.read(in);\n          return date != null ? new Timestamp(date.getTime()) : null;\n        }\n\n        @Override public void write(JsonWriter out, Timestamp value) throws IOException {\n          dateTypeAdapter.write(out, value);\n        }\n      };\n    }\n  };\n\n  public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() {\n    private static final String YEAR = \"year\"; private static final String MONTH = \"month\"; private static final String DAY_OF_MONTH = \"dayOfMonth\"; private static final String HOUR_OF_DAY = \"hourOfDay\"; private static final String MINUTE = \"minute\"; private static final String SECOND = \"second\"; @Override public Calendar read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return  null;\n      }\n      in.beginObject();\n      int year = 0;\n      int month = 0;\n      int dayOfMonth = 0;\n      int hourOfDay = 0;\n      int minute = 0;\n      int second = 0;\n      while (in.peek() != JsonToken.END_OBJECT) {\n        String name = in.nextName();\n        int value = in.nextInt();\n        if (YEAR.equals(name)) {\n          year = value;\n        } else if (MONTH.equals(name)) {\n          month = value;\n        } else if (DAY_OF_MONTH.equals(name)) {\n          dayOfMonth = value;\n        } else if (HOUR_OF_DAY.equals(name)) {\n          hourOfDay = value;\n        } else if (MINUTE.equals(name)) {\n          minute = value;\n        } else if (SECOND.equals(name)) {\n          second = value;\n        }\n      }\n      in.endObject();\n      return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second);\n    }\n\n    @Override\n    public void write(JsonWriter out, Calendar value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n      out.beginObject();\n      out.name(YEAR);\n      out.value(value.get(Calendar.YEAR));\n      out.name(MONTH);\n      out.value(value.get(Calendar.MONTH));\n      out.name(DAY_OF_MONTH);\n      out.value(value.get(Calendar.DAY_OF_MONTH));\n      out.name(HOUR_OF_DAY);\n      out.value(value.get(Calendar.HOUR_OF_DAY));\n      out.name(MINUTE);\n      out.value(value.get(Calendar.MINUTE));\n      out.name(SECOND);\n      out.value(value.get(Calendar.SECOND));\n      out.endObject();\n    }\n  };\n\n  public static final TypeAdapterFactory CALENDAR_FACTORY = newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR); public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {\n    @Override\n    public Locale read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String locale = in.nextString();\n      StringTokenizer tokenizer = new StringTokenizer(locale, \"_\");\n      String language = null;\n      String country = null;\n      String variant = null;\n      if (tokenizer.hasMoreElements()) {\n        language = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        country = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        variant = tokenizer.nextToken();\n      }\n      if (country == null && variant == null) {\n        return new Locale(language);\n      } else if (variant == null) {\n        return new Locale(language, country);\n      } else {\n        return new Locale(language, country, variant);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Locale value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE); public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() {\n    @Override public JsonElement read(JsonReader in) throws IOException {\n      switch (in.peek()) {\n      case STRING:\n        return new JsonPrimitive(in.nextString());\n      case NUMBER:\n        String number = in.nextString();\n        return new JsonPrimitive(new LazilyParsedNumber(number));\n      case BOOLEAN:\n        return new JsonPrimitive(in.nextBoolean());\n      case NULL:\n        in.nextNull();\n        return JsonNull.INSTANCE;\n      case BEGIN_ARRAY:\n        JsonArray array = new JsonArray();\n        in.beginArray();\n        while (in.hasNext()) {\n          array.add(read(in));\n        }\n        in.endArray();\n        return array;\n      case BEGIN_OBJECT:\n        JsonObject object = new JsonObject();\n        in.beginObject();\n        while (in.hasNext()) {\n          object.add(in.nextName(), read(in));\n        }\n        in.endObject();\n        return object;\n      case END_DOCUMENT:\n      case NAME:\n      case END_OBJECT:\n      case END_ARRAY:\n      default:\n        throw new IllegalArgumentException();\n      }\n    }\n\n    @Override public void write(JsonWriter out, JsonElement value) throws IOException {\n      if (value == null || value.isJsonNull()) {\n        out.nullValue();\n      } else if (value.isJsonPrimitive()) {\n        JsonPrimitive primitive = value.getAsJsonPrimitive();\n        if (primitive.isNumber()) {\n          out.value(primitive.getAsNumber());\n        } else if (primitive.isBoolean()) {\n          out.value(primitive.getAsBoolean());\n        } else {\n          out.value(primitive.getAsString());\n        }\n\n      } else if (value.isJsonArray()) {\n        out.beginArray();\n        for (JsonElement e : value.getAsJsonArray()) {\n          write(out, e);\n        }\n        out.endArray();\n\n      } else if (value.isJsonObject()) {\n        out.beginObject();\n        for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) {\n          out.name(e.getKey());\n          write(out, e.getValue());\n        }\n        out.endObject();\n\n      } else {\n        throw new IllegalArgumentException(\"Couldn't write \" + value.getClass());\n      }\n    }\n  };\n\n  public static final TypeAdapterFactory JSON_ELEMENT_FACTORY = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT); private static final class EnumTypeAdapter<T extends Enum<T>> extends TypeAdapter<T> {\n    private final Map<String, T> nameToConstant = new HashMap<String, T>(); private final Map<T, String> constantToName = new HashMap<T, String>(); public EnumTypeAdapter(Class<T> classOfT) {\n      try {\n        for (T constant : classOfT.getEnumConstants()) {\n          String name = constant.name();\n          SerializedName annotation = classOfT.getField(name).getAnnotation(SerializedName.class);\n          if (annotation != null) {\n            name = annotation.value();\n            for (String alternate : annotation.alternate()) {\n              nameToConstant.put(alternate, constant);\n            }\n          }\n          nameToConstant.put(name, constant);\n          constantToName.put(constant, name);\n        }\n      } catch (NoSuchFieldException e) {\n        throw new AssertionError(e);\n      }\n    }\n    @Override public T read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return nameToConstant.get(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, T value) throws IOException {\n      out.value(value == null ? null : constantToName.get(value));\n    }\n  }\n\n  public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      Class<? super T> rawType = typeToken.getRawType();\n      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {\n        return null;\n      }\n      if (!rawType.isEnum()) {\n        rawType = rawType.getSuperclass(); \n      }\n      return (TypeAdapter<T>) new EnumTypeAdapter(rawType);\n    }\n  };\n\n  public static <TT> TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") \n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") \n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") \n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + boxed.getName()\n            + \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") \n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + base.getName()\n            + \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  \n  public static <T1> TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\")\n      @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n        final Class<? super T2> requestedType = typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n        return (TypeAdapter<T2>) new TypeAdapter<T1>() {\n          @Override public void write(JsonWriter out, T1 value) throws IOException {\n            typeAdapter.write(out, value);\n          }\n\n          @Override public T1 read(JsonReader in) throws IOException {\n            T1 result = typeAdapter.read(in);\n            if (result != null && !requestedType.isInstance(result)) {\n              throw new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n                  + \" but was \" + result.getClass().getName());\n            }\n            return result;\n          }\n        };\n      }\n      @Override public String toString() {\n        return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n}\n",
      "fixed_full_code": "\n\npackage com.google.gson.internal.bind;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.UUID;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicIntegerArray;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonIOException;\nimport com.google.gson.JsonNull;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonPrimitive;\nimport com.google.gson.JsonSyntaxException;\nimport com.google.gson.TypeAdapter;\nimport com.google.gson.TypeAdapterFactory;\nimport com.google.gson.annotations.SerializedName;\nimport com.google.gson.internal.LazilyParsedNumber;\nimport com.google.gson.reflect.TypeToken;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport com.google.gson.stream.JsonWriter;\n\n\npublic final class TypeAdapters { private TypeAdapters() {\n    throw new UnsupportedOperationException();\n  }\n\n  @SuppressWarnings(\"rawtypes\")\n  public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n    @Override\n    public void write(JsonWriter out, Class value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n      } else {\n        throw new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n            + value.getName() + \". Forgot to register a type adapter?\");\n      }\n    }\n    @Override\n    public Class read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else {\n        throw new UnsupportedOperationException(\n            \"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n      }\n    }\n  };\n  public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS); public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() {\n    @Override public BitSet read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      BitSet bitset = new BitSet();\n      in.beginArray();\n      int i = 0;\n      JsonToken tokenType = in.peek();\n      while (tokenType != JsonToken.END_ARRAY) {\n        boolean set;\n        switch (tokenType) {\n        case NUMBER:\n          set = in.nextInt() != 0;\n          break;\n        case BOOLEAN:\n          set = in.nextBoolean();\n          break;\n        case STRING:\n          String stringValue = in.nextString();\n          try {\n            set = Integer.parseInt(stringValue) != 0;\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(\n                \"Error: Expecting: bitset number value (1, 0), Found: \" + stringValue);\n          }\n          break;\n        default:\n          throw new JsonSyntaxException(\"Invalid bitset value type: \" + tokenType);\n        }\n        if (set) {\n          bitset.set(i);\n        }\n        ++i;\n        tokenType = in.peek();\n      }\n      in.endArray();\n      return bitset;\n    }\n\n    @Override public void write(JsonWriter out, BitSet src) throws IOException {\n      if (src == null) {\n        out.nullValue();\n        return;\n      }\n\n      out.beginArray();\n      for (int i = 0; i < src.length(); i++) {\n        int value = (src.get(i)) ? 1 : 0;\n        out.value(value);\n      }\n      out.endArray();\n    }\n  };\n\n  public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET); public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {\n    @Override\n    public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else if (in.peek() == JsonToken.STRING) {\n        \n        return Boolean.parseBoolean(in.nextString());\n      }\n      return in.nextBoolean();\n    }\n    @Override\n    public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  \n  public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() {\n    @Override public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return Boolean.valueOf(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value == null ? \"null\" : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory BOOLEAN_FACTORY = newFactory(boolean.class, Boolean.class, BOOLEAN); public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        int intValue = in.nextInt();\n        return (byte) intValue;\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory BYTE_FACTORY = newFactory(byte.class, Byte.class, BYTE); public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return (short) in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory SHORT_FACTORY = newFactory(short.class, Short.class, SHORT); public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n  public static final TypeAdapterFactory INTEGER_FACTORY = newFactory(int.class, Integer.class, INTEGER); public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() {\n    @Override public AtomicInteger read(JsonReader in) throws IOException {\n      try {\n        return new AtomicInteger(in.nextInt());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override public void write(JsonWriter out, AtomicInteger value) throws IOException {\n      out.value(value.get());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY = newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER); public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() {\n    @Override public AtomicBoolean read(JsonReader in) throws IOException {\n      return new AtomicBoolean(in.nextBoolean());\n    }\n    @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException {\n      out.value(value.get());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY = newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN); public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() {\n    @Override public AtomicIntegerArray read(JsonReader in) throws IOException {\n        List<Integer> list = new ArrayList<Integer>();\n        in.beginArray();\n        while (in.hasNext()) {\n          try {\n            int integer = in.nextInt();\n            list.add(integer);\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(e);\n          }\n        }\n        in.endArray();\n        int length = list.size();\n        AtomicIntegerArray array = new AtomicIntegerArray(length);\n        for (int i = 0; i < length; ++i) {\n          array.set(i, list.get(i));\n        }\n        return array;\n    }\n    @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException {\n      out.beginArray();\n      for (int i = 0, length = value.length(); i < length; i++) {\n        out.value(value.get(i));\n      }\n      out.endArray();\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY = newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY); public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextLong();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return (float) in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      JsonToken jsonToken = in.peek();\n      switch (jsonToken) {\n      case NULL:\n        in.nextNull();\n        return null;\n      case NUMBER:\n      case STRING:\n        return new LazilyParsedNumber(in.nextString());\n      default:\n        throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER); public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() {\n    @Override\n    public Character read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String str = in.nextString();\n      if (str.length() != 1) {\n        throw new JsonSyntaxException(\"Expecting character, got: \" + str);\n      }\n      return str.charAt(0);\n    }\n    @Override\n    public void write(JsonWriter out, Character value) throws IOException {\n      out.value(value == null ? null : String.valueOf(value));\n    }\n  };\n\n  public static final TypeAdapterFactory CHARACTER_FACTORY = newFactory(char.class, Character.class, CHARACTER); public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {\n    @Override\n    public String read(JsonReader in) throws IOException {\n      JsonToken peek = in.peek();\n      if (peek == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      \n      if (peek == JsonToken.BOOLEAN) {\n        return Boolean.toString(in.nextBoolean());\n      }\n      return in.nextString();\n    }\n    @Override\n    public void write(JsonWriter out, String value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() {\n    @Override public BigDecimal read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigDecimal(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigDecimal value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() {\n    @Override public BigInteger read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigInteger(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigInteger value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING); public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() {\n    @Override\n    public StringBuilder read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuilder(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuilder value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUILDER_FACTORY = newFactory(StringBuilder.class, STRING_BUILDER); public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() {\n    @Override\n    public StringBuffer read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuffer(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuffer value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUFFER_FACTORY = newFactory(StringBuffer.class, STRING_BUFFER); public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() {\n    @Override\n    public URL read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String nextString = in.nextString();\n      return \"null\".equals(nextString) ? null : new URL(nextString);\n    }\n    @Override\n    public void write(JsonWriter out, URL value) throws IOException {\n      out.value(value == null ? null : value.toExternalForm());\n    }\n  };\n\n  public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL); public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() {\n    @Override\n    public URI read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        String nextString = in.nextString();\n        return \"null\".equals(nextString) ? null : new URI(nextString);\n      } catch (URISyntaxException e) {\n        throw new JsonIOException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, URI value) throws IOException {\n      out.value(value == null ? null : value.toASCIIString());\n    }\n  };\n\n  public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI); public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() {\n    @Override\n    public InetAddress read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      \n      return InetAddress.getByName(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, InetAddress value) throws IOException {\n      out.value(value == null ? null : value.getHostAddress());\n    }\n  };\n\n  public static final TypeAdapterFactory INET_ADDRESS_FACTORY = newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS); public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() {\n    @Override\n    public UUID read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return java.util.UUID.fromString(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, UUID value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID); public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() {\n    @Override\n    public Currency read(JsonReader in) throws IOException {\n      return Currency.getInstance(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, Currency value) throws IOException {\n      out.value(value.getCurrencyCode());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY); public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings(\"unchecked\") \n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      if (typeToken.getRawType() != Timestamp.class) {\n        return null;\n      }\n\n      final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\n      return (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n        @Override public Timestamp read(JsonReader in) throws IOException {\n          Date date = dateTypeAdapter.read(in);\n          return date != null ? new Timestamp(date.getTime()) : null;\n        }\n\n        @Override public void write(JsonWriter out, Timestamp value) throws IOException {\n          dateTypeAdapter.write(out, value);\n        }\n      };\n    }\n  };\n\n  public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() {\n    private static final String YEAR = \"year\"; private static final String MONTH = \"month\"; private static final String DAY_OF_MONTH = \"dayOfMonth\"; private static final String HOUR_OF_DAY = \"hourOfDay\"; private static final String MINUTE = \"minute\"; private static final String SECOND = \"second\"; @Override public Calendar read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return  null;\n      }\n      in.beginObject();\n      int year = 0;\n      int month = 0;\n      int dayOfMonth = 0;\n      int hourOfDay = 0;\n      int minute = 0;\n      int second = 0;\n      while (in.peek() != JsonToken.END_OBJECT) {\n        String name = in.nextName();\n        int value = in.nextInt();\n        if (YEAR.equals(name)) {\n          year = value;\n        } else if (MONTH.equals(name)) {\n          month = value;\n        } else if (DAY_OF_MONTH.equals(name)) {\n          dayOfMonth = value;\n        } else if (HOUR_OF_DAY.equals(name)) {\n          hourOfDay = value;\n        } else if (MINUTE.equals(name)) {\n          minute = value;\n        } else if (SECOND.equals(name)) {\n          second = value;\n        }\n      }\n      in.endObject();\n      return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second);\n    }\n\n    @Override\n    public void write(JsonWriter out, Calendar value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n      out.beginObject();\n      out.name(YEAR);\n      out.value(value.get(Calendar.YEAR));\n      out.name(MONTH);\n      out.value(value.get(Calendar.MONTH));\n      out.name(DAY_OF_MONTH);\n      out.value(value.get(Calendar.DAY_OF_MONTH));\n      out.name(HOUR_OF_DAY);\n      out.value(value.get(Calendar.HOUR_OF_DAY));\n      out.name(MINUTE);\n      out.value(value.get(Calendar.MINUTE));\n      out.name(SECOND);\n      out.value(value.get(Calendar.SECOND));\n      out.endObject();\n    }\n  };\n\n  public static final TypeAdapterFactory CALENDAR_FACTORY = newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR); public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {\n    @Override\n    public Locale read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String locale = in.nextString();\n      StringTokenizer tokenizer = new StringTokenizer(locale, \"_\");\n      String language = null;\n      String country = null;\n      String variant = null;\n      if (tokenizer.hasMoreElements()) {\n        language = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        country = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        variant = tokenizer.nextToken();\n      }\n      if (country == null && variant == null) {\n        return new Locale(language);\n      } else if (variant == null) {\n        return new Locale(language, country);\n      } else {\n        return new Locale(language, country, variant);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Locale value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE); public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() {\n    @Override public JsonElement read(JsonReader in) throws IOException {\n      switch (in.peek()) {\n      case STRING:\n        return new JsonPrimitive(in.nextString());\n      case NUMBER:\n        String number = in.nextString();\n        return new JsonPrimitive(new LazilyParsedNumber(number));\n      case BOOLEAN:\n        return new JsonPrimitive(in.nextBoolean());\n      case NULL:\n        in.nextNull();\n        return JsonNull.INSTANCE;\n      case BEGIN_ARRAY:\n        JsonArray array = new JsonArray();\n        in.beginArray();\n        while (in.hasNext()) {\n          array.add(read(in));\n        }\n        in.endArray();\n        return array;\n      case BEGIN_OBJECT:\n        JsonObject object = new JsonObject();\n        in.beginObject();\n        while (in.hasNext()) {\n          object.add(in.nextName(), read(in));\n        }\n        in.endObject();\n        return object;\n      case END_DOCUMENT:\n      case NAME:\n      case END_OBJECT:\n      case END_ARRAY:\n      default:\n        throw new IllegalArgumentException();\n      }\n    }\n\n    @Override public void write(JsonWriter out, JsonElement value) throws IOException {\n      if (value == null || value.isJsonNull()) {\n        out.nullValue();\n      } else if (value.isJsonPrimitive()) {\n        JsonPrimitive primitive = value.getAsJsonPrimitive();\n        if (primitive.isNumber()) {\n          out.value(primitive.getAsNumber());\n        } else if (primitive.isBoolean()) {\n          out.value(primitive.getAsBoolean());\n        } else {\n          out.value(primitive.getAsString());\n        }\n\n      } else if (value.isJsonArray()) {\n        out.beginArray();\n        for (JsonElement e : value.getAsJsonArray()) {\n          write(out, e);\n        }\n        out.endArray();\n\n      } else if (value.isJsonObject()) {\n        out.beginObject();\n        for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) {\n          out.name(e.getKey());\n          write(out, e.getValue());\n        }\n        out.endObject();\n\n      } else {\n        throw new IllegalArgumentException(\"Couldn't write \" + value.getClass());\n      }\n    }\n  };\n\n  public static final TypeAdapterFactory JSON_ELEMENT_FACTORY = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT); private static final class EnumTypeAdapter<T extends Enum<T>> extends TypeAdapter<T> {\n    private final Map<String, T> nameToConstant = new HashMap<String, T>(); private final Map<T, String> constantToName = new HashMap<T, String>(); public EnumTypeAdapter(Class<T> classOfT) {\n      try {\n        for (T constant : classOfT.getEnumConstants()) {\n          String name = constant.name();\n          SerializedName annotation = classOfT.getField(name).getAnnotation(SerializedName.class);\n          if (annotation != null) {\n            name = annotation.value();\n            for (String alternate : annotation.alternate()) {\n              nameToConstant.put(alternate, constant);\n            }\n          }\n          nameToConstant.put(name, constant);\n          constantToName.put(constant, name);\n        }\n      } catch (NoSuchFieldException e) {\n        throw new AssertionError(e);\n      }\n    }\n    @Override public T read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return nameToConstant.get(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, T value) throws IOException {\n      out.value(value == null ? null : constantToName.get(value));\n    }\n  }\n\n  public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      Class<? super T> rawType = typeToken.getRawType();\n      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {\n        return null;\n      }\n      if (!rawType.isEnum()) {\n        rawType = rawType.getSuperclass(); \n      }\n      return (TypeAdapter<T>) new EnumTypeAdapter(rawType);\n    }\n  };\n\n  public static <TT> TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") \n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") \n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") \n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + boxed.getName()\n            + \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") \n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + base.getName()\n            + \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  \n  public static <T1> TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\")\n      @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n        final Class<? super T2> requestedType = typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n        return (TypeAdapter<T2>) new TypeAdapter<T1>() {\n          @Override public void write(JsonWriter out, T1 value) throws IOException {\n            typeAdapter.write(out, value);\n          }\n\n          @Override public T1 read(JsonReader in) throws IOException {\n            T1 result = typeAdapter.read(in);\n            if (result != null && !requestedType.isInstance(result)) {\n              throw new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n                  + \" but was \" + result.getClass().getName());\n            }\n            return result;\n          }\n        };\n      }\n      @Override public String toString() {\n        return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n}\n",
      "buggy_signatures": [
        "public final class TypeAdapters { private TypeAdapters()",
        "public void write(JsonWriter out, Class value) throws IOException",
        "public Class read(JsonReader in) throws IOException",
        "public BitSet read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, BitSet src) throws IOException",
        "public Boolean read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, Boolean value) throws IOException",
        "public Boolean read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, Boolean value) throws IOException",
        "public Number read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, Number value) throws IOException",
        "public Number read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, Number value) throws IOException",
        "public Number read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, Number value) throws IOException",
        "public AtomicInteger read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, AtomicInteger value) throws IOException",
        "public AtomicBoolean read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, AtomicBoolean value) throws IOException",
        "public AtomicIntegerArray read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, AtomicIntegerArray value) throws IOException",
        "public Number read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, Number value) throws IOException",
        "public Number read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, Number value) throws IOException",
        "public Number read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, Number value) throws IOException",
        "public Number read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, Number value) throws IOException",
        "public Character read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, Character value) throws IOException",
        "public String read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, String value) throws IOException",
        "public BigDecimal read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, BigDecimal value) throws IOException",
        "public BigInteger read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, BigInteger value) throws IOException",
        "public StringBuilder read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, StringBuilder value) throws IOException",
        "public StringBuffer read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, StringBuffer value) throws IOException",
        "public URL read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, URL value) throws IOException",
        "public URI read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, URI value) throws IOException",
        "public InetAddress read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, InetAddress value) throws IOException",
        "public UUID read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, UUID value) throws IOException",
        "public Currency read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, Currency value) throws IOException",
        "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken)",
        "public Timestamp read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, Timestamp value) throws IOException",
        "public void write(JsonWriter out, Calendar value) throws IOException",
        "public Locale read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, Locale value) throws IOException",
        "public JsonElement read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, JsonElement value) throws IOException",
        "public T read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, T value) throws IOException",
        "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken)",
        "public static <TT> TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter)",
        "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken)",
        "public static <TT> TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter)",
        "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken)",
        "public String toString()",
        "public static <TT> TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter)",
        "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken)",
        "public String toString()",
        "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter)",
        "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken)",
        "public String toString()",
        "public static <T1> TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter)",
        "public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken)",
        "public void write(JsonWriter out, T1 value) throws IOException",
        "public T1 read(JsonReader in) throws IOException",
        "public String toString()"
      ],
      "fixed_signatures": [
        "public final class TypeAdapters { private TypeAdapters()",
        "public void write(JsonWriter out, Class value) throws IOException",
        "public Class read(JsonReader in) throws IOException",
        "public BitSet read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, BitSet src) throws IOException",
        "public Boolean read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, Boolean value) throws IOException",
        "public Boolean read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, Boolean value) throws IOException",
        "public Number read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, Number value) throws IOException",
        "public Number read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, Number value) throws IOException",
        "public Number read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, Number value) throws IOException",
        "public AtomicInteger read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, AtomicInteger value) throws IOException",
        "public AtomicBoolean read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, AtomicBoolean value) throws IOException",
        "public AtomicIntegerArray read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, AtomicIntegerArray value) throws IOException",
        "public Number read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, Number value) throws IOException",
        "public Number read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, Number value) throws IOException",
        "public Number read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, Number value) throws IOException",
        "public Number read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, Number value) throws IOException",
        "public Character read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, Character value) throws IOException",
        "public String read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, String value) throws IOException",
        "public BigDecimal read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, BigDecimal value) throws IOException",
        "public BigInteger read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, BigInteger value) throws IOException",
        "public StringBuilder read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, StringBuilder value) throws IOException",
        "public StringBuffer read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, StringBuffer value) throws IOException",
        "public URL read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, URL value) throws IOException",
        "public URI read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, URI value) throws IOException",
        "public InetAddress read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, InetAddress value) throws IOException",
        "public UUID read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, UUID value) throws IOException",
        "public Currency read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, Currency value) throws IOException",
        "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken)",
        "public Timestamp read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, Timestamp value) throws IOException",
        "public void write(JsonWriter out, Calendar value) throws IOException",
        "public Locale read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, Locale value) throws IOException",
        "public JsonElement read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, JsonElement value) throws IOException",
        "public T read(JsonReader in) throws IOException",
        "public void write(JsonWriter out, T value) throws IOException",
        "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken)",
        "public static <TT> TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter)",
        "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken)",
        "public static <TT> TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter)",
        "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken)",
        "public String toString()",
        "public static <TT> TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter)",
        "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken)",
        "public String toString()",
        "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter)",
        "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken)",
        "public String toString()",
        "public static <T1> TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter)",
        "public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken)",
        "public void write(JsonWriter out, T1 value) throws IOException",
        "public T1 read(JsonReader in) throws IOException",
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "  public Number read(JsonReader in) throws IOException {\n  JsonToken jsonToken = in.peek();\n  switch (jsonToken) {\n  case NULL:\n  in.nextNull();\n  return null;\n  case NUMBER:\n  return new LazilyParsedNumber(in.nextString());\n  default:\n  throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n  }\n  }",
          "fixed_method": "  public Number read(JsonReader in) throws IOException {\n  JsonToken jsonToken = in.peek();\n  switch (jsonToken) {\n  case NULL:\n  in.nextNull();\n  return null;\n  case NUMBER:\n  case STRING:\n  return new LazilyParsedNumber(in.nextString());\n  default:\n  throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n  }\n  }",
          "diff": [
            "@@ -368,6 +368,7 @@",
            "         in.nextNull();\n",
            "         return null;\n",
            "       case NUMBER:\n",
            "+      case STRING:\n",
            "         return new LazilyParsedNumber(in.nextString());\n",
            "       default:\n",
            "         throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n"
          ],
          "changed_lines": 1
        }
      ]
    }
  ]
}
