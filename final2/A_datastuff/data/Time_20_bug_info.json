{
  "bug_id": "20",
  "failed_tests": {
    "org.joda.time.format.TestDateTimeFormatterBuilder": [
      {
        "methodName": "test_printParseZoneDawsonCreek",
        "error": "java.lang.IllegalArgumentException",
        "message": "Invalid format: \"2007-03-04 12:30 America/Dawson_Creek\" is malformed at \"_Creek\"",
        "fail_line": "        assertEquals(dt, f.parseDateTime(\"2007-03-04 12:30 America/Dawson_Creek\"));",
        "test_source": "  public void test_printParseZoneDawsonCreek() {  // clashes with shorter Dawson\n  DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n  .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneId();\n  DateTimeFormatter f = bld.toFormatter();\n  \n  DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forID(\"America/Dawson_Creek\"));\n  assertEquals(\"2007-03-04 12:30 America/Dawson_Creek\", f.print(dt));\n  assertEquals(dt, f.parseDateTime(\"2007-03-04 12:30 America/Dawson_Creek\"));\n  }",
        "stack": [
          "DateTimeFormatter.parseDateTime line 866, TestDateTimeFormatterBuilder.test_printParseZoneDawsonCreek line 262"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/joda/time/format/DateTimeFormatterBuilder.java",
      "buggy_full_code": "\npackage org.joda.time.format;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeConstants;\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeFieldType;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.MutableDateTime;\nimport org.joda.time.ReadablePartial;\nimport org.joda.time.MutableDateTime.Property;\nimport org.joda.time.field.MillisDurationField;\nimport org.joda.time.field.PreciseDateTimeField;\n\n\npublic class DateTimeFormatterBuilder { private ArrayList<Object> iElementPairs; private Object iFormatter; public DateTimeFormatterBuilder() {\n        super();\n        iElementPairs = new ArrayList<Object>();\n    }\n\n    \n    \n    public DateTimeFormatter toFormatter() {\n        Object f = getFormatter();\n        DateTimePrinter printer = null;\n        if (isPrinter(f)) {\n            printer = (DateTimePrinter) f;\n        }\n        DateTimeParser parser = null;\n        if (isParser(f)) {\n            parser = (DateTimeParser) f;\n        }\n        if (printer != null || parser != null) {\n            return new DateTimeFormatter(printer, parser);\n        }\n        throw new UnsupportedOperationException(\"Both printing and parsing not supported\");\n    }\n\n    \n    public DateTimePrinter toPrinter() {\n        Object f = getFormatter();\n        if (isPrinter(f)) {\n            return (DateTimePrinter) f;\n        }\n        throw new UnsupportedOperationException(\"Printing is not supported\");\n    }\n\n    \n    public DateTimeParser toParser() {\n        Object f = getFormatter();\n        if (isParser(f)) {\n            return (DateTimeParser) f;\n        }\n        throw new UnsupportedOperationException(\"Parsing is not supported\");\n    }\n\n    \n    \n    public boolean canBuildFormatter() {\n        return isFormatter(getFormatter());\n    }\n\n    \n    public boolean canBuildPrinter() {\n        return isPrinter(getFormatter());\n    }\n\n    \n    public boolean canBuildParser() {\n        return isParser(getFormatter());\n    }\n\n    \n    \n    public void clear() {\n        iFormatter = null;\n        iElementPairs.clear();\n    }\n\n    \n    \n    public DateTimeFormatterBuilder append(DateTimeFormatter formatter) {\n        if (formatter == null) {\n            throw new IllegalArgumentException(\"No formatter supplied\");\n        }\n        return append0(formatter.getPrinter(), formatter.getParser());\n    }\n\n    \n    public DateTimeFormatterBuilder append(DateTimePrinter printer) {\n        checkPrinter(printer);\n        return append0(printer, null);\n    }\n\n    \n    public DateTimeFormatterBuilder append(DateTimeParser parser) {\n        checkParser(parser);\n        return append0(null, parser);\n    }\n\n    \n    public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser parser) {\n        checkPrinter(printer);\n        checkParser(parser);\n        return append0(printer, parser);\n    }\n\n    \n    public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers) {\n        if (printer != null) {\n            checkPrinter(printer);\n        }\n        if (parsers == null) {\n            throw new IllegalArgumentException(\"No parsers supplied\");\n        }\n        int length = parsers.length;\n        if (length == 1) {\n            if (parsers[0] == null) {\n                throw new IllegalArgumentException(\"No parser supplied\");\n            }\n            return append0(printer, parsers[0]);\n        }\n\n        DateTimeParser[] copyOfParsers = new DateTimeParser[length];\n        int i;\n        for (i = 0; i < length - 1; i++) {\n            if ((copyOfParsers[i] = parsers[i]) == null) {\n                throw new IllegalArgumentException(\"Incomplete parser array\");\n            }\n        }\n        copyOfParsers[i] = parsers[i];\n\n        return append0(printer, new MatchingParser(copyOfParsers));\n    }\n\n    \n    public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) {\n        checkParser(parser);\n        DateTimeParser[] parsers = new DateTimeParser[] {parser, null};\n        return append0(null, new MatchingParser(parsers));\n    }\n\n    \n    \n    private void checkParser(DateTimeParser parser) {\n        if (parser == null) {\n            throw new IllegalArgumentException(\"No parser supplied\");\n        }\n    }\n\n    \n    private void checkPrinter(DateTimePrinter printer) {\n        if (printer == null) {\n            throw new IllegalArgumentException(\"No printer supplied\");\n        }\n    }\n\n    private DateTimeFormatterBuilder append0(Object element) {\n        iFormatter = null;\n        \n        iElementPairs.add(element);\n        iElementPairs.add(element);\n        return this;\n    }\n\n    private DateTimeFormatterBuilder append0( DateTimePrinter printer, DateTimeParser parser) {\n        iFormatter = null;\n        iElementPairs.add(printer);\n        iElementPairs.add(parser);\n        return this;\n    }\n\n    \n    \n    public DateTimeFormatterBuilder appendLiteral(char c) {\n        return append0(new CharacterLiteral(c));\n    }\n\n    \n    public DateTimeFormatterBuilder appendLiteral(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"Literal must not be null\");\n        }\n        switch (text.length()) {\n            case 0:\n                return this;\n            case 1:\n                return append0(new CharacterLiteral(text.charAt(0)));\n            default:\n                return append0(new StringLiteral(text));\n        }\n    }\n\n    \n    public DateTimeFormatterBuilder appendDecimal( DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (maxDigits < minDigits) {\n            maxDigits = minDigits;\n        }\n        if (minDigits < 0 || maxDigits <= 0) {\n            throw new IllegalArgumentException();\n        }\n        if (minDigits <= 1) {\n            return append0(new UnpaddedNumber(fieldType, maxDigits, false));\n        } else {\n            return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n        }\n    }\n\n    \n    public DateTimeFormatterBuilder appendFixedDecimal( DateTimeFieldType fieldType, int numDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (numDigits <= 0) {\n            throw new IllegalArgumentException(\"Illegal number of digits: \" + numDigits);\n        }\n        return append0(new FixedNumber(fieldType, numDigits, false));\n    }\n\n    \n    public DateTimeFormatterBuilder appendSignedDecimal( DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (maxDigits < minDigits) {\n            maxDigits = minDigits;\n        }\n        if (minDigits < 0 || maxDigits <= 0) {\n            throw new IllegalArgumentException();\n        }\n        if (minDigits <= 1) {\n            return append0(new UnpaddedNumber(fieldType, maxDigits, true));\n        } else {\n            return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n        }\n    }\n\n    \n    public DateTimeFormatterBuilder appendFixedSignedDecimal( DateTimeFieldType fieldType, int numDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (numDigits <= 0) {\n            throw new IllegalArgumentException(\"Illegal number of digits: \" + numDigits);\n        }\n        return append0(new FixedNumber(fieldType, numDigits, true));\n    }\n\n    \n    public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        return append0(new TextField(fieldType, false));\n    }\n\n    \n    public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        return append0(new TextField(fieldType, true));\n    }\n\n    \n    public DateTimeFormatterBuilder appendFraction( DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (maxDigits < minDigits) {\n            maxDigits = minDigits;\n        }\n        if (minDigits < 0 || maxDigits <= 0) {\n            throw new IllegalArgumentException();\n        }\n        return append0(new Fraction(fieldType, minDigits, maxDigits));\n    }\n\n    \n    public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);\n    }\n\n    \n    public DateTimeFormatterBuilder appendFractionOfMinute(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.minuteOfDay(), minDigits, maxDigits);\n    }\n\n    \n    public DateTimeFormatterBuilder appendFractionOfHour(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.hourOfDay(), minDigits, maxDigits);\n    }\n\n    \n    public DateTimeFormatterBuilder appendFractionOfDay(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.dayOfYear(), minDigits, maxDigits);\n    }\n\n    \n    public DateTimeFormatterBuilder appendMillisOfSecond(int minDigits) {\n        return appendDecimal(DateTimeFieldType.millisOfSecond(), minDigits, 3);\n    }\n\n    \n    public DateTimeFormatterBuilder appendMillisOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.millisOfDay(), minDigits, 8);\n    }\n\n    \n    public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\n        return appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n    }\n\n    \n    public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.secondOfDay(), minDigits, 5);\n    }\n\n    \n    public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\n        return appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n    }\n\n    \n    public DateTimeFormatterBuilder appendMinuteOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.minuteOfDay(), minDigits, 4);\n    }\n\n    \n    public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n    }\n\n    \n    public DateTimeFormatterBuilder appendClockhourOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.clockhourOfDay(), minDigits, 2);\n    }\n\n    \n    public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits) {\n        return appendDecimal(DateTimeFieldType.hourOfHalfday(), minDigits, 2);\n    }\n\n    \n    public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) {\n        return appendDecimal(DateTimeFieldType.clockhourOfHalfday(), minDigits, 2);\n    }\n\n    \n    public DateTimeFormatterBuilder appendDayOfWeek(int minDigits) {\n        return appendDecimal(DateTimeFieldType.dayOfWeek(), minDigits, 1);\n    }\n\n    \n    public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\n        return appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n    }\n\n    \n    public DateTimeFormatterBuilder appendDayOfYear(int minDigits) {\n        return appendDecimal(DateTimeFieldType.dayOfYear(), minDigits, 3);\n    }\n\n    \n    public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {\n        return appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2);\n    }\n\n    \n    public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) {\n        return appendSignedDecimal(DateTimeFieldType.weekyear(), minDigits, maxDigits);\n    }\n\n    \n    public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\n        return appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n    }\n\n    \n    public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\n        return appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n    }\n\n    \n    public DateTimeFormatterBuilder appendTwoDigitYear(int pivot) {\n        return appendTwoDigitYear(pivot, false);\n    }\n\n    \n    public DateTimeFormatterBuilder appendTwoDigitYear(int pivot, boolean lenientParse) {\n        return append0(new TwoDigitYear(DateTimeFieldType.year(), pivot, lenientParse));\n    }\n\n    \n    public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot) {\n        return appendTwoDigitWeekyear(pivot, false);\n    }\n\n    \n    public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot, boolean lenientParse) {\n        return append0(new TwoDigitYear(DateTimeFieldType.weekyear(), pivot, lenientParse));\n    }\n\n    \n    public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) {\n        return appendDecimal(DateTimeFieldType.yearOfEra(), minDigits, maxDigits);\n    }\n\n    \n    public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits) {\n        return appendDecimal(DateTimeFieldType.yearOfCentury(), minDigits, maxDigits);\n    }\n\n    \n    public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits) {\n        return appendSignedDecimal(DateTimeFieldType.centuryOfEra(), minDigits, maxDigits);\n    }\n\n    \n    public DateTimeFormatterBuilder appendHalfdayOfDayText() {\n        return appendText(DateTimeFieldType.halfdayOfDay());\n    }\n\n    \n    public DateTimeFormatterBuilder appendDayOfWeekText() {\n        return appendText(DateTimeFieldType.dayOfWeek());\n    }\n\n    \n    public DateTimeFormatterBuilder appendDayOfWeekShortText() {\n        return appendShortText(DateTimeFieldType.dayOfWeek());\n    }\n\n    \n    public DateTimeFormatterBuilder appendMonthOfYearText() { \n        return appendText(DateTimeFieldType.monthOfYear());\n    }\n\n    \n    public DateTimeFormatterBuilder appendMonthOfYearShortText() {\n        return appendShortText(DateTimeFieldType.monthOfYear());\n    }\n\n    \n    public DateTimeFormatterBuilder appendEraText() {\n        return appendText(DateTimeFieldType.era());\n    }\n\n    \n    public DateTimeFormatterBuilder appendTimeZoneName() {\n        return append0(new TimeZoneName(TimeZoneName.LONG_NAME, null), null);\n    }\n\n    \n    public DateTimeFormatterBuilder appendTimeZoneName(Map<String, DateTimeZone> parseLookup) {\n        TimeZoneName pp = new TimeZoneName(TimeZoneName.LONG_NAME, parseLookup);\n        return append0(pp, pp);\n    }\n\n    \n    public DateTimeFormatterBuilder appendTimeZoneShortName() {\n        return append0(new TimeZoneName(TimeZoneName.SHORT_NAME, null), null);\n    }\n\n    \n    public DateTimeFormatterBuilder appendTimeZoneShortName(Map<String, DateTimeZone> parseLookup) {\n        TimeZoneName pp = new TimeZoneName(TimeZoneName.SHORT_NAME, parseLookup);\n        return append0(pp, pp);\n    }\n\n    \n    public DateTimeFormatterBuilder appendTimeZoneId() {\n        return append0(TimeZoneId.INSTANCE, TimeZoneId.INSTANCE);\n    }\n\n    \n    public DateTimeFormatterBuilder appendTimeZoneOffset( String zeroOffsetText, boolean showSeparators, int minFields, int maxFields) {\n        return append0(new TimeZoneOffset\n                       (zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields));\n    }\n\n    \n    public DateTimeFormatterBuilder appendTimeZoneOffset( String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators, int minFields, int maxFields) {\n        return append0(new TimeZoneOffset\n                       (zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields));\n    }\n\n    \n    \n    public DateTimeFormatterBuilder appendPattern(String pattern) {\n        DateTimeFormat.appendPatternTo(this, pattern);\n        return this;\n    }\n\n    \n    private Object getFormatter() {\n        Object f = iFormatter;\n\n        if (f == null) {\n            if (iElementPairs.size() == 2) {\n                Object printer = iElementPairs.get(0);\n                Object parser = iElementPairs.get(1);\n\n                if (printer != null) {\n                    if (printer == parser || parser == null) {\n                        f = printer;\n                    }\n                } else {\n                    f = parser;\n                }\n            }\n\n            if (f == null) {\n                f = new Composite(iElementPairs);\n            }\n\n            iFormatter = f;\n        }\n\n        return f;\n    }\n\n    private boolean isPrinter(Object f) {\n        if (f instanceof DateTimePrinter) {\n            if (f instanceof Composite) {\n                return ((Composite)f).isPrinter();\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private boolean isParser(Object f) {\n        if (f instanceof DateTimeParser) {\n            if (f instanceof Composite) {\n                return ((Composite)f).isParser();\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private boolean isFormatter(Object f) {\n        return (isPrinter(f) || isParser(f));\n    }\n\n    static void appendUnknownString(StringBuffer buf, int len) {\n        for (int i = len; --i >= 0;) {\n            buf.append('\\ufffd');\n        }\n    }\n\n    static void printUnknownString(Writer out, int len) throws IOException {\n        for (int i = len; --i >= 0;) {\n            out.write('\\ufffd');\n        }\n    }\n\n    \n    static class CharacterLiteral implements DateTimePrinter, DateTimeParser { private final char iValue; CharacterLiteral(char value) {\n            super();\n            iValue = value;\n        }\n\n        public int estimatePrintedLength() {\n            return 1;\n        }\n\n        public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) {\n            buf.append(iValue);\n        }\n\n        public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            out.write(iValue);\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            buf.append(iValue);\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            out.write(iValue);\n        }\n\n        public int estimateParsedLength() {\n            return 1;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            if (position >= text.length()) {\n                return ~position;\n            }\n\n            char a = text.charAt(position);\n            char b = iValue;\n\n            if (a != b) {\n                a = Character.toUpperCase(a);\n                b = Character.toUpperCase(b);\n                if (a != b) {\n                    a = Character.toLowerCase(a);\n                    b = Character.toLowerCase(b);\n                    if (a != b) {\n                        return ~position;\n                    }\n                }\n            }\n\n            return position + 1;\n        }\n    }\n\n    \n    static class StringLiteral implements DateTimePrinter, DateTimeParser { private final String iValue; StringLiteral(String value) {\n            super();\n            iValue = value;\n        }\n\n        public int estimatePrintedLength() {\n            return iValue.length();\n        }\n\n        public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) {\n            buf.append(iValue);\n        }\n\n        public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            out.write(iValue);\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            buf.append(iValue);\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            out.write(iValue);\n        }\n\n        public int estimateParsedLength() {\n            return iValue.length();\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            if (text.regionMatches(true, position, iValue, 0, iValue.length())) {\n                return position + iValue.length();\n            }\n            return ~position;\n        }\n    }\n\n    \n    static abstract class NumberFormatter implements DateTimePrinter, DateTimeParser { protected final DateTimeFieldType iFieldType; protected final int iMaxParsedDigits; protected final boolean iSigned; NumberFormatter(DateTimeFieldType fieldType, int maxParsedDigits, boolean signed) {\n            super();\n            iFieldType = fieldType;\n            iMaxParsedDigits = maxParsedDigits;\n            iSigned = signed;\n        }\n\n        public int estimateParsedLength() {\n            return iMaxParsedDigits;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = Math.min(iMaxParsedDigits, text.length() - position);\n\n            boolean negative = false;\n            int length = 0;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                if (length == 0 && (c == '-' || c == '+') && iSigned) {\n                    negative = c == '-';\n\n                    \n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        \n                        position++;\n                    }\n                    \n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                if (c < '0' || c > '9') {\n                    break;\n                }\n                length++;\n            }\n\n            if (length == 0) {\n                return ~position;\n            }\n\n            int value;\n            if (length >= 9) {\n                \n                \n                value = Integer.parseInt(text.substring(position, position += length));\n            } else {\n                int i = position;\n                if (negative) {\n                    i++;\n                }\n                try {\n                    value = text.charAt(i++) - '0';\n                } catch (StringIndexOutOfBoundsException e) {\n                    return ~position;\n                }\n                position += length;\n                while (i < position) {\n                    value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                }\n                if (negative) {\n                    value = -value;\n                }\n            }\n\n            bucket.saveField(iFieldType, value);\n            return position;\n        }\n    }\n\n    \n    static class UnpaddedNumber extends NumberFormatter { protected UnpaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits, boolean signed) {\n            super(fieldType, maxParsedDigits, signed);\n        }\n\n        public int estimatePrintedLength() {\n            return iMaxParsedDigits;\n        }\n\n        public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) {\n            try {\n                DateTimeField field = iFieldType.getField(chrono);\n                FormatUtils.appendUnpaddedInteger(buf, field.get(instant));\n            } catch (RuntimeException e) {\n                buf.append('\\ufffd');\n            }\n        }\n\n        public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            try {\n                DateTimeField field = iFieldType.getField(chrono);\n                FormatUtils.writeUnpaddedInteger(out, field.get(instant));\n            } catch (RuntimeException e) {\n                out.write('\\ufffd');\n            }\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            if (partial.isSupported(iFieldType)) {\n                try {\n                    FormatUtils.appendUnpaddedInteger(buf, partial.get(iFieldType));\n                } catch (RuntimeException e) {\n                    buf.append('\\ufffd');\n                }\n            } else {\n                buf.append('\\ufffd');\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            if (partial.isSupported(iFieldType)) {\n                try {\n                    FormatUtils.writeUnpaddedInteger(out, partial.get(iFieldType));\n                } catch (RuntimeException e) {\n                    out.write('\\ufffd');\n                }\n            } else {\n                out.write('\\ufffd');\n            }\n        }\n    }\n\n    \n    static class PaddedNumber extends NumberFormatter { protected final int iMinPrintedDigits; protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits, boolean signed, int minPrintedDigits) {\n            super(fieldType, maxParsedDigits, signed);\n            iMinPrintedDigits = minPrintedDigits;\n        }\n\n        public int estimatePrintedLength() {\n            return iMaxParsedDigits;\n        }\n\n        public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) {\n            try {\n                DateTimeField field = iFieldType.getField(chrono);\n                FormatUtils.appendPaddedInteger(buf, field.get(instant), iMinPrintedDigits);\n            } catch (RuntimeException e) {\n                appendUnknownString(buf, iMinPrintedDigits);\n            }\n        }\n\n        public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            try {\n                DateTimeField field = iFieldType.getField(chrono);\n                FormatUtils.writePaddedInteger(out, field.get(instant), iMinPrintedDigits);\n            } catch (RuntimeException e) {\n                printUnknownString(out, iMinPrintedDigits);\n            }\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            if (partial.isSupported(iFieldType)) {\n                try {\n                    FormatUtils.appendPaddedInteger(buf, partial.get(iFieldType), iMinPrintedDigits);\n                } catch (RuntimeException e) {\n                    appendUnknownString(buf, iMinPrintedDigits);\n                }\n            } else {\n                appendUnknownString(buf, iMinPrintedDigits);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            if (partial.isSupported(iFieldType)) {\n                try {\n                    FormatUtils.writePaddedInteger(out, partial.get(iFieldType), iMinPrintedDigits);\n                } catch (RuntimeException e) {\n                    printUnknownString(out, iMinPrintedDigits);\n                }\n            } else {\n                printUnknownString(out, iMinPrintedDigits);\n            }\n        }\n    }\n\n    \n    static class FixedNumber extends PaddedNumber { protected FixedNumber(DateTimeFieldType fieldType, int numDigits, boolean signed) {\n            super(fieldType, numDigits, signed, numDigits);\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int newPos = super.parseInto(bucket, text, position);\n            if (newPos < 0) {\n                return newPos;\n            }\n            int expectedPos = position + iMaxParsedDigits;\n            if (newPos != expectedPos) {\n                if (iSigned) {\n                    char c = text.charAt(position);\n                    if (c == '-' || c == '+') {\n                        expectedPos++;\n                    }\n                }\n                if (newPos > expectedPos) {\n                    \n                    return ~(expectedPos + 1);\n                } else if (newPos < expectedPos) {\n                    \n                    return ~newPos;\n                }\n            }\n            return newPos;\n        }\n    }\n\n    \n    static class TwoDigitYear implements DateTimePrinter, DateTimeParser { private final DateTimeFieldType iType; private final int iPivot; private final boolean iLenientParse; TwoDigitYear(DateTimeFieldType type, int pivot, boolean lenientParse) {\n            super();\n            iType = type;\n            iPivot = pivot;\n            iLenientParse = lenientParse;\n        }\n\n        public int estimateParsedLength() {\n            return iLenientParse ? 4 : 2;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            \n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        \n                        \n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            \n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }\n        \n        public int estimatePrintedLength() {\n            return 2;\n        }\n\n        public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) {\n            int year = getTwoDigitYear(instant, chrono);\n            if (year < 0) {\n                buf.append('\\ufffd');\n                buf.append('\\ufffd');\n            } else {\n                FormatUtils.appendPaddedInteger(buf, year, 2);\n            }\n        }\n\n        public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            int year = getTwoDigitYear(instant, chrono);\n            if (year < 0) {\n                out.write('\\ufffd');\n                out.write('\\ufffd');\n            } else {\n                FormatUtils.writePaddedInteger(out, year, 2);\n            }\n        }\n\n        private int getTwoDigitYear(long instant, Chronology chrono) {\n            try {\n                int year = iType.getField(chrono).get(instant);\n                if (year < 0) {\n                    year = -year;\n                }\n                return year % 100;\n            } catch (RuntimeException e) {\n                return -1;\n            }\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            int year = getTwoDigitYear(partial);\n            if (year < 0) {\n                buf.append('\\ufffd');\n                buf.append('\\ufffd');\n            } else {\n                FormatUtils.appendPaddedInteger(buf, year, 2);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            int year = getTwoDigitYear(partial);\n            if (year < 0) {\n                out.write('\\ufffd');\n                out.write('\\ufffd');\n            } else {\n                FormatUtils.writePaddedInteger(out, year, 2);\n            }\n        }\n\n        private int getTwoDigitYear(ReadablePartial partial) {\n            if (partial.isSupported(iType)) {\n                try {\n                    int year = partial.get(iType);\n                    if (year < 0) {\n                        year = -year;\n                    }\n                    return year % 100;\n                } catch (RuntimeException e) {}\n            } \n            return -1;\n        }\n    }\n\n    \n    static class TextField implements DateTimePrinter, DateTimeParser { private static Map<Locale, Map<DateTimeFieldType, Object[]>> cParseCache = new HashMap<Locale, Map<DateTimeFieldType, Object[]>>(); private final DateTimeFieldType iFieldType; private final boolean iShort; TextField(DateTimeFieldType fieldType, boolean isShort) {\n            super();\n            iFieldType = fieldType;\n            iShort = isShort;\n        }\n\n        public int estimatePrintedLength() {\n            return iShort ? 6 : 20;\n        }\n\n        public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) {\n            try {\n                buf.append(print(instant, chrono, locale));\n            } catch (RuntimeException e) {\n                buf.append('\\ufffd');\n            }\n        }\n\n        public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            try {\n                out.write(print(instant, chrono, locale));\n            } catch (RuntimeException e) {\n                out.write('\\ufffd');\n            }\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            try {\n                buf.append(print(partial, locale));\n            } catch (RuntimeException e) {\n                buf.append('\\ufffd');\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            try {\n                out.write(print(partial, locale));\n            } catch (RuntimeException e) {\n                out.write('\\ufffd');\n            }\n        }\n\n        private String print(long instant, Chronology chrono, Locale locale) {\n            DateTimeField field = iFieldType.getField(chrono);\n            if (iShort) {\n                return field.getAsShortText(instant, locale);\n            } else {\n                return field.getAsText(instant, locale);\n            }\n        }\n\n        private String print(ReadablePartial partial, Locale locale) {\n            if (partial.isSupported(iFieldType)) {\n                DateTimeField field = iFieldType.getField(partial.getChronology());\n                if (iShort) {\n                    return field.getAsShortText(partial, locale);\n                } else {\n                    return field.getAsText(partial, locale);\n                }\n            } else {\n                return \"\\ufffd\";\n            }\n        }\n\n        public int estimateParsedLength() {\n            return estimatePrintedLength();\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            Locale locale = bucket.getLocale();\n            \n            \n            Set<String> validValues = null;\n            int maxLength = 0;\n            synchronized (cParseCache) {\n                Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale);\n                if (innerMap == null) {\n                    innerMap = new HashMap<DateTimeFieldType, Object[]>();\n                    cParseCache.put(locale, innerMap);\n                }\n                Object[] array = innerMap.get(iFieldType);\n                if (array == null) {\n                    validValues = new HashSet<String>(32);\n                    MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC);\n                    Property property = dt.property(iFieldType);\n                    int min = property.getMinimumValueOverall();\n                    int max = property.getMaximumValueOverall();\n                    if (max - min > 32) {  \n                        return ~position;\n                    }\n                    maxLength = property.getMaximumTextLength(locale);\n                    for (int i = min; i <= max; i++) {\n                        property.set(i);\n                        validValues.add(property.getAsShortText(locale));\n                        validValues.add(property.getAsShortText(locale).toLowerCase(locale));\n                        validValues.add(property.getAsShortText(locale).toUpperCase(locale));\n                        validValues.add(property.getAsText(locale));\n                        validValues.add(property.getAsText(locale).toLowerCase(locale));\n                        validValues.add(property.getAsText(locale).toUpperCase(locale));\n                    }\n                    if (\"en\".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) {\n                        \n                        validValues.add(\"BCE\");\n                        validValues.add(\"bce\");\n                        validValues.add(\"CE\");\n                        validValues.add(\"ce\");\n                        maxLength = 3;\n                    }\n                    array = new Object[] {validValues, Integer.valueOf(maxLength)};\n                    innerMap.put(iFieldType, array);\n                } else {\n                    validValues = (Set<String>) array[0];\n                    maxLength = ((Integer) array[1]).intValue();\n                }\n            }\n            \n            int limit = Math.min(text.length(), position + maxLength);\n            for (int i = limit; i > position; i--) {\n                String match = text.substring(position, i);\n                if (validValues.contains(match)) {\n                    bucket.saveField(iFieldType, match, locale);\n                    return i;\n                }\n            }\n            return ~position;\n        }\n    }\n\n    \n    static class Fraction implements DateTimePrinter, DateTimeParser { private final DateTimeFieldType iFieldType; protected int iMinDigits; protected int iMaxDigits; protected Fraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n            super();\n            iFieldType = fieldType;\n            \n            if (maxDigits > 18) {\n                maxDigits = 18;\n            }\n            iMinDigits = minDigits;\n            iMaxDigits = maxDigits;\n        }\n\n        public int estimatePrintedLength() {\n            return iMaxDigits;\n        }\n\n        public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) {\n            try {\n                printTo(buf, null, instant, chrono);\n            } catch (IOException e) {\n                \n            }\n        }\n\n        public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            printTo(null, out, instant, chrono);\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            \n            \n            long millis = partial.getChronology().set(partial, 0L);\n            try {\n                printTo(buf, null, millis, partial.getChronology());\n            } catch (IOException e) {\n                \n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            \n            \n            long millis = partial.getChronology().set(partial, 0L);\n            printTo(null, out, millis, partial.getChronology());\n        }\n\n        protected void printTo(StringBuffer buf, Writer out, long instant, Chronology chrono) throws IOException {\n            DateTimeField field = iFieldType.getField(chrono);\n            int minDigits = iMinDigits;\n\n            long fraction;\n            try {\n                fraction = field.remainder(instant);\n            } catch (RuntimeException e) {\n                if (buf != null) {\n                    appendUnknownString(buf, minDigits);\n                } else {\n                    printUnknownString(out, minDigits);\n                }\n                return;\n            }\n\n            if (fraction == 0) {\n                if (buf != null) {\n                    while (--minDigits >= 0) {\n                        buf.append('0');\n                    }\n                } else {\n                    while (--minDigits >= 0) {\n                        out.write('0');\n                    }\n                }\n                return;\n            }\n\n            String str;\n            long[] fractionData = getFractionData(fraction, field);\n            long scaled = fractionData[0];\n            int maxDigits = (int) fractionData[1];\n            \n            if ((scaled & 0x7fffffff) == scaled) {\n                str = Integer.toString((int) scaled);\n            } else {\n                str = Long.toString(scaled);\n            }\n\n            int length = str.length();\n            int digits = maxDigits;\n            while (length < digits) {\n                if (buf != null) {\n                    buf.append('0');\n                } else {\n                    out.write('0');\n                }\n                minDigits--;\n                digits--;\n            }\n\n            if (minDigits < digits) {\n                \n                while (minDigits < digits) {\n                    if (length <= 1 || str.charAt(length - 1) != '0') {\n                        break;\n                    }\n                    digits--;\n                    length--;\n                }\n                if (length < str.length()) {\n                    if (buf != null) {\n                        for (int i=0; i<length; i++) {\n                            buf.append(str.charAt(i));\n                        }\n                    } else {\n                        for (int i=0; i<length; i++) {\n                            out.write(str.charAt(i));\n                        }\n                    }\n                    return;\n                }\n            }\n\n            if (buf != null) {\n                buf.append(str);\n            } else {\n                out.write(str);\n            }\n        }\n        \n        private long[] getFractionData(long fraction, DateTimeField field) {\n            long rangeMillis = field.getDurationField().getUnitMillis();\n            long scalar;\n            int maxDigits = iMaxDigits;\n            while (true) {\n                switch (maxDigits) {\n                default: scalar = 1L; break;\n                case 1:  scalar = 10L; break;\n                case 2:  scalar = 100L; break;\n                case 3:  scalar = 1000L; break;\n                case 4:  scalar = 10000L; break;\n                case 5:  scalar = 100000L; break;\n                case 6:  scalar = 1000000L; break;\n                case 7:  scalar = 10000000L; break;\n                case 8:  scalar = 100000000L; break;\n                case 9:  scalar = 1000000000L; break;\n                case 10: scalar = 10000000000L; break;\n                case 11: scalar = 100000000000L; break;\n                case 12: scalar = 1000000000000L; break;\n                case 13: scalar = 10000000000000L; break;\n                case 14: scalar = 100000000000000L; break;\n                case 15: scalar = 1000000000000000L; break;\n                case 16: scalar = 10000000000000000L; break;\n                case 17: scalar = 100000000000000000L; break;\n                case 18: scalar = 1000000000000000000L; break;\n                }\n                if (((rangeMillis * scalar) / scalar) == rangeMillis) {\n                    break;\n                }\n                \n                maxDigits--;\n            }\n            \n            return new long[] {fraction * scalar / rangeMillis, maxDigits};\n        }\n\n        public int estimateParsedLength() {\n            return iMaxDigits;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            DateTimeField field = iFieldType.getField(bucket.getChronology());\n            \n            int limit = Math.min(iMaxDigits, text.length() - position);\n\n            long value = 0;\n            long n = field.getDurationField().getUnitMillis() * 10;\n            int length = 0;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                if (c < '0' || c > '9') {\n                    break;\n                }\n                length++;\n                long nn = n / 10;\n                value += (c - '0') * nn;\n                n = nn;\n            }\n\n            value /= 10;\n\n            if (length == 0) {\n                return ~position;\n            }\n\n            if (value > Integer.MAX_VALUE) {\n                return ~position;\n            }\n\n            DateTimeField parseField = new PreciseDateTimeField(\n                DateTimeFieldType.millisOfSecond(),\n                MillisDurationField.INSTANCE,\n                field.getDurationField());\n\n            bucket.saveField(parseField, (int) value);\n\n            return position + length;\n        }\n    }\n\n    \n    static class TimeZoneOffset implements DateTimePrinter, DateTimeParser { private final String iZeroOffsetPrintText; private final String iZeroOffsetParseText; private final boolean iShowSeparators; private final int iMinFields; private final int iMaxFields; TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators, int minFields, int maxFields) {\n            super();\n            iZeroOffsetPrintText = zeroOffsetPrintText;\n            iZeroOffsetParseText = zeroOffsetParseText;\n            iShowSeparators = showSeparators;\n            if (minFields <= 0 || maxFields < minFields) {\n                throw new IllegalArgumentException();\n            }\n            if (minFields > 4) {\n                minFields = 4;\n                maxFields = 4;\n            }\n            iMinFields = minFields;\n            iMaxFields = maxFields;\n        }\n            \n        public int estimatePrintedLength() {\n            int est = 1 + iMinFields << 1;\n            if (iShowSeparators) {\n                est += iMinFields - 1;\n            }\n            if (iZeroOffsetPrintText != null && iZeroOffsetPrintText.length() > est) {\n                est = iZeroOffsetPrintText.length();\n            }\n            return est;\n        }\n        \n        public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) {\n            if (displayZone == null) {\n                return;  \n            }\n            if (displayOffset == 0 && iZeroOffsetPrintText != null) {\n                buf.append(iZeroOffsetPrintText);\n                return;\n            }\n            if (displayOffset >= 0) {\n                buf.append('+');\n            } else {\n                buf.append('-');\n                displayOffset = -displayOffset;\n            }\n\n            int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;\n            FormatUtils.appendPaddedInteger(buf, hours, 2);\n            if (iMaxFields == 1) {\n                return;\n            }\n            displayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;\n            if (displayOffset == 0 && iMinFields <= 1) {\n                return;\n            }\n\n            int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;\n            if (iShowSeparators) {\n                buf.append(':');\n            }\n            FormatUtils.appendPaddedInteger(buf, minutes, 2);\n            if (iMaxFields == 2) {\n                return;\n            }\n            displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n            if (displayOffset == 0 && iMinFields <= 2) {\n                return;\n            }\n\n            int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND;\n            if (iShowSeparators) {\n                buf.append(':');\n            }\n            FormatUtils.appendPaddedInteger(buf, seconds, 2);\n            if (iMaxFields == 3) {\n                return;\n            }\n            displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n            if (displayOffset == 0 && iMinFields <= 3) {\n                return;\n            }\n\n            if (iShowSeparators) {\n                buf.append('.');\n            }\n            FormatUtils.appendPaddedInteger(buf, displayOffset, 3);\n        }\n        \n        public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            if (displayZone == null) {\n                return;  \n            }\n            if (displayOffset == 0 && iZeroOffsetPrintText != null) {\n                out.write(iZeroOffsetPrintText);\n                return;\n            }\n            if (displayOffset >= 0) {\n                out.write('+');\n            } else {\n                out.write('-');\n                displayOffset = -displayOffset;\n            }\n\n            int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;\n            FormatUtils.writePaddedInteger(out, hours, 2);\n            if (iMaxFields == 1) {\n                return;\n            }\n            displayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;\n            if (displayOffset == 0 && iMinFields == 1) {\n                return;\n            }\n\n            int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;\n            if (iShowSeparators) {\n                out.write(':');\n            }\n            FormatUtils.writePaddedInteger(out, minutes, 2);\n            if (iMaxFields == 2) {\n                return;\n            }\n            displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n            if (displayOffset == 0 && iMinFields == 2) {\n                return;\n            }\n\n            int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND;\n            if (iShowSeparators) {\n                out.write(':');\n            }\n            FormatUtils.writePaddedInteger(out, seconds, 2);\n            if (iMaxFields == 3) {\n                return;\n            }\n            displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n            if (displayOffset == 0 && iMinFields == 3) {\n                return;\n            }\n\n            if (iShowSeparators) {\n                out.write('.');\n            }\n            FormatUtils.writePaddedInteger(out, displayOffset, 3);\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            \n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            \n        }\n\n        public int estimateParsedLength() {\n            return estimatePrintedLength();\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    \n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            \n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            \n            \n            \n            \n            \n            \n            \n            \n            \n\n            \n\n            if (digitCount(text, position, 2) < 2) {\n                \n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                \n                \n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                \n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    \n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                \n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    \n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                \n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    \n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }\n\n        \n        private int digitCount(String text, int position, int amount) {\n            int limit = Math.min(text.length() - position, amount);\n            amount = 0;\n            for (; limit > 0; limit--) {\n                char c = text.charAt(position + amount);\n                if (c < '0' || c > '9') {\n                    break;\n                }\n                amount++;\n            }\n            return amount;\n        }\n    }\n\n    \n    static class TimeZoneName implements DateTimePrinter, DateTimeParser { static final int LONG_NAME = 0; static final int SHORT_NAME = 1; private final Map<String, DateTimeZone> iParseLookup; private final int iType; TimeZoneName(int type, Map<String, DateTimeZone> parseLookup) {\n            super();\n            iType = type;\n            iParseLookup = parseLookup;\n        }\n\n        public int estimatePrintedLength() {\n            return (iType == SHORT_NAME ? 4 : 20);\n        }\n\n        public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) {\n            buf.append(print(instant - displayOffset, displayZone, locale));\n        }\n\n        public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            out.write(print(instant - displayOffset, displayZone, locale));\n        }\n\n        private String print(long instant, DateTimeZone displayZone, Locale locale) {\n            if (displayZone == null) {\n                return \"\";  \n            }\n            switch (iType) {\n                case LONG_NAME:\n                    return displayZone.getName(instant, locale);\n                case SHORT_NAME:\n                    return displayZone.getShortName(instant, locale);\n            }\n            return \"\";\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            \n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            \n        }\n\n        public int estimateParsedLength() {\n            return (iType == SHORT_NAME ? 4 : 20);\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            String str = text.substring(position);\n            for (String name : iParseLookup.keySet()) {\n                if (str.startsWith(name)) {\n                    bucket.setZone(iParseLookup.get(name));\n                    return position + name.length();\n                }\n            }\n            return ~position;\n        }\n    }\n\n    \n    static enum TimeZoneId implements DateTimePrinter, DateTimeParser { INSTANCE; static final Set<String> ALL_IDS = DateTimeZone.getAvailableIDs(); static final int MAX_LENGTH; static {\n            int max = 0;\n            for (String id : ALL_IDS) {\n                max = Math.max(max, id.length());\n            }\n            MAX_LENGTH = max;\n        }\n\n        public int estimatePrintedLength() {\n            return MAX_LENGTH;\n        }\n\n        public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) {\n            buf.append(displayZone != null ? displayZone.getID() : \"\");\n        }\n\n        public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            out.write(displayZone != null ? displayZone.getID() : \"\");\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            \n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            \n        }\n\n        public int estimateParsedLength() {\n            return MAX_LENGTH;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            String str = text.substring(position);\n            for (String id : ALL_IDS) {\n                if (str.startsWith(id)) {\n                    bucket.setZone(DateTimeZone.forID(id));\n                    return position + id.length();\n                }\n            }\n            return ~position;\n        }\n    }\n\n    \n    static class Composite implements DateTimePrinter, DateTimeParser { private final DateTimePrinter[] iPrinters; private final DateTimeParser[] iParsers; private final int iPrintedLengthEstimate; private final int iParsedLengthEstimate; Composite(List<Object> elementPairs) {\n            super();\n\n            List<Object> printerList = new ArrayList<Object>();\n            List<Object> parserList = new ArrayList<Object>();\n\n            decompose(elementPairs, printerList, parserList);\n\n            if (printerList.size() <= 0) {\n                iPrinters = null;\n                iPrintedLengthEstimate = 0;\n            } else {\n                int size = printerList.size();\n                iPrinters = new DateTimePrinter[size];\n                int printEst = 0;\n                for (int i=0; i<size; i++) {\n                    DateTimePrinter printer = (DateTimePrinter) printerList.get(i);\n                    printEst += printer.estimatePrintedLength();\n                    iPrinters[i] = printer;\n                }\n                iPrintedLengthEstimate = printEst;\n            }\n\n            if (parserList.size() <= 0) {\n                iParsers = null;\n                iParsedLengthEstimate = 0;\n            } else {\n                int size = parserList.size();\n                iParsers = new DateTimeParser[size];\n                int parseEst = 0;\n                for (int i=0; i<size; i++) {\n                    DateTimeParser parser = (DateTimeParser) parserList.get(i);\n                    parseEst += parser.estimateParsedLength();\n                    iParsers[i] = parser;\n                }\n                iParsedLengthEstimate = parseEst;\n            }\n        }\n\n        public int estimatePrintedLength() {\n            return iPrintedLengthEstimate;\n        }\n\n        public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) {\n            DateTimePrinter[] elements = iPrinters;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            if (locale == null) {\n                \n                locale = Locale.getDefault();\n            }\n\n            int len = elements.length;\n            for (int i = 0; i < len; i++) {\n                elements[i].printTo(buf, instant, chrono, displayOffset, displayZone, locale);\n            }\n        }\n\n        public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            DateTimePrinter[] elements = iPrinters;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            if (locale == null) {\n                \n                locale = Locale.getDefault();\n            }\n\n            int len = elements.length;\n            for (int i = 0; i < len; i++) {\n                elements[i].printTo(out, instant, chrono, displayOffset, displayZone, locale);\n            }\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            DateTimePrinter[] elements = iPrinters;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            if (locale == null) {\n                \n                locale = Locale.getDefault();\n            }\n\n            int len = elements.length;\n            for (int i=0; i<len; i++) {\n                elements[i].printTo(buf, partial, locale);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            DateTimePrinter[] elements = iPrinters;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            if (locale == null) {\n                \n                locale = Locale.getDefault();\n            }\n\n            int len = elements.length;\n            for (int i=0; i<len; i++) {\n                elements[i].printTo(out, partial, locale);\n            }\n        }\n\n        public int estimateParsedLength() {\n            return iParsedLengthEstimate;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            DateTimeParser[] elements = iParsers;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            int len = elements.length;\n            for (int i=0; i<len && position >= 0; i++) {\n                position = elements[i].parseInto(bucket, text, position);\n            }\n            return position;\n        }\n\n        boolean isPrinter() {\n            return iPrinters != null;\n        }\n\n        boolean isParser() {\n            return iParsers != null;\n        }\n\n        \n        private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\n            int size = elementPairs.size();\n            for (int i=0; i<size; i+=2) {\n                Object element = elementPairs.get(i);\n                if (element instanceof DateTimePrinter) {\n                    if (element instanceof Composite) {\n                        addArrayToList(printerList, ((Composite)element).iPrinters);\n                    } else {\n                        printerList.add(element);\n                    }\n                }\n\n                element = elementPairs.get(i + 1);\n                if (element instanceof DateTimeParser) {\n                    if (element instanceof Composite) {\n                        addArrayToList(parserList, ((Composite)element).iParsers);\n                    } else {\n                        parserList.add(element);\n                    }\n                }\n            }\n        }\n\n        private void addArrayToList(List<Object> list, Object[] array) {\n            if (array != null) {\n                for (int i=0; i<array.length; i++) {\n                    list.add(array[i]);\n                }\n            }\n        }\n    }\n\n    \n    static class MatchingParser implements DateTimeParser { private final DateTimeParser[] iParsers; private final int iParsedLengthEstimate; MatchingParser(DateTimeParser[] parsers) {\n            super();\n            iParsers = parsers;\n            int est = 0;\n            for (int i=parsers.length; --i>=0 ;) {\n                DateTimeParser parser = parsers[i];\n                if (parser != null) {\n                    int len = parser.estimateParsedLength();\n                    if (len > est) {\n                        est = len;\n                    }\n                }\n            }\n            iParsedLengthEstimate = est;\n        }\n\n        public int estimateParsedLength() {\n            return iParsedLengthEstimate;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            DateTimeParser[] parsers = iParsers;\n            int length = parsers.length;\n\n            final Object originalState = bucket.saveState();\n            boolean isOptional = false;\n\n            int bestValidPos = position;\n            Object bestValidState = null;\n\n            int bestInvalidPos = position;\n\n            for (int i=0; i<length; i++) {\n                DateTimeParser parser = parsers[i];\n                if (parser == null) {\n                    \n                    if (bestValidPos <= position) {\n                        return position;\n                    }\n                    isOptional = true;\n                    break;\n                }\n                int parsePos = parser.parseInto(bucket, text, position);\n                if (parsePos >= position) {\n                    if (parsePos > bestValidPos) {\n                        if (parsePos >= text.length() ||\n                            (i + 1) >= length || parsers[i + 1] == null) {\n\n                            \n                            \n                            return parsePos;\n                        }\n                        bestValidPos = parsePos;\n                        bestValidState = bucket.saveState();\n                    }\n                } else {\n                    if (parsePos < 0) {\n                        parsePos = ~parsePos;\n                        if (parsePos > bestInvalidPos) {\n                            bestInvalidPos = parsePos;\n                        }\n                    }\n                }\n                bucket.restoreState(originalState);\n            }\n\n            if (bestValidPos > position || (bestValidPos == position && isOptional)) {\n                \n                if (bestValidState != null) {\n                    bucket.restoreState(bestValidState);\n                }\n                return bestValidPos;\n            }\n\n            return ~bestInvalidPos;\n        }\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.joda.time.format;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeConstants;\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeFieldType;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.MutableDateTime;\nimport org.joda.time.ReadablePartial;\nimport org.joda.time.MutableDateTime.Property;\nimport org.joda.time.field.MillisDurationField;\nimport org.joda.time.field.PreciseDateTimeField;\n\n\npublic class DateTimeFormatterBuilder { private ArrayList<Object> iElementPairs; private Object iFormatter; public DateTimeFormatterBuilder() {\n        super();\n        iElementPairs = new ArrayList<Object>();\n    }\n\n    \n    \n    public DateTimeFormatter toFormatter() {\n        Object f = getFormatter();\n        DateTimePrinter printer = null;\n        if (isPrinter(f)) {\n            printer = (DateTimePrinter) f;\n        }\n        DateTimeParser parser = null;\n        if (isParser(f)) {\n            parser = (DateTimeParser) f;\n        }\n        if (printer != null || parser != null) {\n            return new DateTimeFormatter(printer, parser);\n        }\n        throw new UnsupportedOperationException(\"Both printing and parsing not supported\");\n    }\n\n    \n    public DateTimePrinter toPrinter() {\n        Object f = getFormatter();\n        if (isPrinter(f)) {\n            return (DateTimePrinter) f;\n        }\n        throw new UnsupportedOperationException(\"Printing is not supported\");\n    }\n\n    \n    public DateTimeParser toParser() {\n        Object f = getFormatter();\n        if (isParser(f)) {\n            return (DateTimeParser) f;\n        }\n        throw new UnsupportedOperationException(\"Parsing is not supported\");\n    }\n\n    \n    \n    public boolean canBuildFormatter() {\n        return isFormatter(getFormatter());\n    }\n\n    \n    public boolean canBuildPrinter() {\n        return isPrinter(getFormatter());\n    }\n\n    \n    public boolean canBuildParser() {\n        return isParser(getFormatter());\n    }\n\n    \n    \n    public void clear() {\n        iFormatter = null;\n        iElementPairs.clear();\n    }\n\n    \n    \n    public DateTimeFormatterBuilder append(DateTimeFormatter formatter) {\n        if (formatter == null) {\n            throw new IllegalArgumentException(\"No formatter supplied\");\n        }\n        return append0(formatter.getPrinter(), formatter.getParser());\n    }\n\n    \n    public DateTimeFormatterBuilder append(DateTimePrinter printer) {\n        checkPrinter(printer);\n        return append0(printer, null);\n    }\n\n    \n    public DateTimeFormatterBuilder append(DateTimeParser parser) {\n        checkParser(parser);\n        return append0(null, parser);\n    }\n\n    \n    public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser parser) {\n        checkPrinter(printer);\n        checkParser(parser);\n        return append0(printer, parser);\n    }\n\n    \n    public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers) {\n        if (printer != null) {\n            checkPrinter(printer);\n        }\n        if (parsers == null) {\n            throw new IllegalArgumentException(\"No parsers supplied\");\n        }\n        int length = parsers.length;\n        if (length == 1) {\n            if (parsers[0] == null) {\n                throw new IllegalArgumentException(\"No parser supplied\");\n            }\n            return append0(printer, parsers[0]);\n        }\n\n        DateTimeParser[] copyOfParsers = new DateTimeParser[length];\n        int i;\n        for (i = 0; i < length - 1; i++) {\n            if ((copyOfParsers[i] = parsers[i]) == null) {\n                throw new IllegalArgumentException(\"Incomplete parser array\");\n            }\n        }\n        copyOfParsers[i] = parsers[i];\n\n        return append0(printer, new MatchingParser(copyOfParsers));\n    }\n\n    \n    public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) {\n        checkParser(parser);\n        DateTimeParser[] parsers = new DateTimeParser[] {parser, null};\n        return append0(null, new MatchingParser(parsers));\n    }\n\n    \n    \n    private void checkParser(DateTimeParser parser) {\n        if (parser == null) {\n            throw new IllegalArgumentException(\"No parser supplied\");\n        }\n    }\n\n    \n    private void checkPrinter(DateTimePrinter printer) {\n        if (printer == null) {\n            throw new IllegalArgumentException(\"No printer supplied\");\n        }\n    }\n\n    private DateTimeFormatterBuilder append0(Object element) {\n        iFormatter = null;\n        \n        iElementPairs.add(element);\n        iElementPairs.add(element);\n        return this;\n    }\n\n    private DateTimeFormatterBuilder append0( DateTimePrinter printer, DateTimeParser parser) {\n        iFormatter = null;\n        iElementPairs.add(printer);\n        iElementPairs.add(parser);\n        return this;\n    }\n\n    \n    \n    public DateTimeFormatterBuilder appendLiteral(char c) {\n        return append0(new CharacterLiteral(c));\n    }\n\n    \n    public DateTimeFormatterBuilder appendLiteral(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"Literal must not be null\");\n        }\n        switch (text.length()) {\n            case 0:\n                return this;\n            case 1:\n                return append0(new CharacterLiteral(text.charAt(0)));\n            default:\n                return append0(new StringLiteral(text));\n        }\n    }\n\n    \n    public DateTimeFormatterBuilder appendDecimal( DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (maxDigits < minDigits) {\n            maxDigits = minDigits;\n        }\n        if (minDigits < 0 || maxDigits <= 0) {\n            throw new IllegalArgumentException();\n        }\n        if (minDigits <= 1) {\n            return append0(new UnpaddedNumber(fieldType, maxDigits, false));\n        } else {\n            return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n        }\n    }\n\n    \n    public DateTimeFormatterBuilder appendFixedDecimal( DateTimeFieldType fieldType, int numDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (numDigits <= 0) {\n            throw new IllegalArgumentException(\"Illegal number of digits: \" + numDigits);\n        }\n        return append0(new FixedNumber(fieldType, numDigits, false));\n    }\n\n    \n    public DateTimeFormatterBuilder appendSignedDecimal( DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (maxDigits < minDigits) {\n            maxDigits = minDigits;\n        }\n        if (minDigits < 0 || maxDigits <= 0) {\n            throw new IllegalArgumentException();\n        }\n        if (minDigits <= 1) {\n            return append0(new UnpaddedNumber(fieldType, maxDigits, true));\n        } else {\n            return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n        }\n    }\n\n    \n    public DateTimeFormatterBuilder appendFixedSignedDecimal( DateTimeFieldType fieldType, int numDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (numDigits <= 0) {\n            throw new IllegalArgumentException(\"Illegal number of digits: \" + numDigits);\n        }\n        return append0(new FixedNumber(fieldType, numDigits, true));\n    }\n\n    \n    public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        return append0(new TextField(fieldType, false));\n    }\n\n    \n    public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        return append0(new TextField(fieldType, true));\n    }\n\n    \n    public DateTimeFormatterBuilder appendFraction( DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (maxDigits < minDigits) {\n            maxDigits = minDigits;\n        }\n        if (minDigits < 0 || maxDigits <= 0) {\n            throw new IllegalArgumentException();\n        }\n        return append0(new Fraction(fieldType, minDigits, maxDigits));\n    }\n\n    \n    public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);\n    }\n\n    \n    public DateTimeFormatterBuilder appendFractionOfMinute(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.minuteOfDay(), minDigits, maxDigits);\n    }\n\n    \n    public DateTimeFormatterBuilder appendFractionOfHour(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.hourOfDay(), minDigits, maxDigits);\n    }\n\n    \n    public DateTimeFormatterBuilder appendFractionOfDay(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.dayOfYear(), minDigits, maxDigits);\n    }\n\n    \n    public DateTimeFormatterBuilder appendMillisOfSecond(int minDigits) {\n        return appendDecimal(DateTimeFieldType.millisOfSecond(), minDigits, 3);\n    }\n\n    \n    public DateTimeFormatterBuilder appendMillisOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.millisOfDay(), minDigits, 8);\n    }\n\n    \n    public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\n        return appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n    }\n\n    \n    public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.secondOfDay(), minDigits, 5);\n    }\n\n    \n    public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\n        return appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n    }\n\n    \n    public DateTimeFormatterBuilder appendMinuteOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.minuteOfDay(), minDigits, 4);\n    }\n\n    \n    public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n    }\n\n    \n    public DateTimeFormatterBuilder appendClockhourOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.clockhourOfDay(), minDigits, 2);\n    }\n\n    \n    public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits) {\n        return appendDecimal(DateTimeFieldType.hourOfHalfday(), minDigits, 2);\n    }\n\n    \n    public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) {\n        return appendDecimal(DateTimeFieldType.clockhourOfHalfday(), minDigits, 2);\n    }\n\n    \n    public DateTimeFormatterBuilder appendDayOfWeek(int minDigits) {\n        return appendDecimal(DateTimeFieldType.dayOfWeek(), minDigits, 1);\n    }\n\n    \n    public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\n        return appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n    }\n\n    \n    public DateTimeFormatterBuilder appendDayOfYear(int minDigits) {\n        return appendDecimal(DateTimeFieldType.dayOfYear(), minDigits, 3);\n    }\n\n    \n    public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {\n        return appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2);\n    }\n\n    \n    public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) {\n        return appendSignedDecimal(DateTimeFieldType.weekyear(), minDigits, maxDigits);\n    }\n\n    \n    public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\n        return appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n    }\n\n    \n    public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\n        return appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n    }\n\n    \n    public DateTimeFormatterBuilder appendTwoDigitYear(int pivot) {\n        return appendTwoDigitYear(pivot, false);\n    }\n\n    \n    public DateTimeFormatterBuilder appendTwoDigitYear(int pivot, boolean lenientParse) {\n        return append0(new TwoDigitYear(DateTimeFieldType.year(), pivot, lenientParse));\n    }\n\n    \n    public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot) {\n        return appendTwoDigitWeekyear(pivot, false);\n    }\n\n    \n    public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot, boolean lenientParse) {\n        return append0(new TwoDigitYear(DateTimeFieldType.weekyear(), pivot, lenientParse));\n    }\n\n    \n    public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) {\n        return appendDecimal(DateTimeFieldType.yearOfEra(), minDigits, maxDigits);\n    }\n\n    \n    public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits) {\n        return appendDecimal(DateTimeFieldType.yearOfCentury(), minDigits, maxDigits);\n    }\n\n    \n    public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits) {\n        return appendSignedDecimal(DateTimeFieldType.centuryOfEra(), minDigits, maxDigits);\n    }\n\n    \n    public DateTimeFormatterBuilder appendHalfdayOfDayText() {\n        return appendText(DateTimeFieldType.halfdayOfDay());\n    }\n\n    \n    public DateTimeFormatterBuilder appendDayOfWeekText() {\n        return appendText(DateTimeFieldType.dayOfWeek());\n    }\n\n    \n    public DateTimeFormatterBuilder appendDayOfWeekShortText() {\n        return appendShortText(DateTimeFieldType.dayOfWeek());\n    }\n\n    \n    public DateTimeFormatterBuilder appendMonthOfYearText() { \n        return appendText(DateTimeFieldType.monthOfYear());\n    }\n\n    \n    public DateTimeFormatterBuilder appendMonthOfYearShortText() {\n        return appendShortText(DateTimeFieldType.monthOfYear());\n    }\n\n    \n    public DateTimeFormatterBuilder appendEraText() {\n        return appendText(DateTimeFieldType.era());\n    }\n\n    \n    public DateTimeFormatterBuilder appendTimeZoneName() {\n        return append0(new TimeZoneName(TimeZoneName.LONG_NAME, null), null);\n    }\n\n    \n    public DateTimeFormatterBuilder appendTimeZoneName(Map<String, DateTimeZone> parseLookup) {\n        TimeZoneName pp = new TimeZoneName(TimeZoneName.LONG_NAME, parseLookup);\n        return append0(pp, pp);\n    }\n\n    \n    public DateTimeFormatterBuilder appendTimeZoneShortName() {\n        return append0(new TimeZoneName(TimeZoneName.SHORT_NAME, null), null);\n    }\n\n    \n    public DateTimeFormatterBuilder appendTimeZoneShortName(Map<String, DateTimeZone> parseLookup) {\n        TimeZoneName pp = new TimeZoneName(TimeZoneName.SHORT_NAME, parseLookup);\n        return append0(pp, pp);\n    }\n\n    \n    public DateTimeFormatterBuilder appendTimeZoneId() {\n        return append0(TimeZoneId.INSTANCE, TimeZoneId.INSTANCE);\n    }\n\n    \n    public DateTimeFormatterBuilder appendTimeZoneOffset( String zeroOffsetText, boolean showSeparators, int minFields, int maxFields) {\n        return append0(new TimeZoneOffset\n                       (zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields));\n    }\n\n    \n    public DateTimeFormatterBuilder appendTimeZoneOffset( String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators, int minFields, int maxFields) {\n        return append0(new TimeZoneOffset\n                       (zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields));\n    }\n\n    \n    \n    public DateTimeFormatterBuilder appendPattern(String pattern) {\n        DateTimeFormat.appendPatternTo(this, pattern);\n        return this;\n    }\n\n    \n    private Object getFormatter() {\n        Object f = iFormatter;\n\n        if (f == null) {\n            if (iElementPairs.size() == 2) {\n                Object printer = iElementPairs.get(0);\n                Object parser = iElementPairs.get(1);\n\n                if (printer != null) {\n                    if (printer == parser || parser == null) {\n                        f = printer;\n                    }\n                } else {\n                    f = parser;\n                }\n            }\n\n            if (f == null) {\n                f = new Composite(iElementPairs);\n            }\n\n            iFormatter = f;\n        }\n\n        return f;\n    }\n\n    private boolean isPrinter(Object f) {\n        if (f instanceof DateTimePrinter) {\n            if (f instanceof Composite) {\n                return ((Composite)f).isPrinter();\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private boolean isParser(Object f) {\n        if (f instanceof DateTimeParser) {\n            if (f instanceof Composite) {\n                return ((Composite)f).isParser();\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private boolean isFormatter(Object f) {\n        return (isPrinter(f) || isParser(f));\n    }\n\n    static void appendUnknownString(StringBuffer buf, int len) {\n        for (int i = len; --i >= 0;) {\n            buf.append('\\ufffd');\n        }\n    }\n\n    static void printUnknownString(Writer out, int len) throws IOException {\n        for (int i = len; --i >= 0;) {\n            out.write('\\ufffd');\n        }\n    }\n\n    \n    static class CharacterLiteral implements DateTimePrinter, DateTimeParser { private final char iValue; CharacterLiteral(char value) {\n            super();\n            iValue = value;\n        }\n\n        public int estimatePrintedLength() {\n            return 1;\n        }\n\n        public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) {\n            buf.append(iValue);\n        }\n\n        public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            out.write(iValue);\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            buf.append(iValue);\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            out.write(iValue);\n        }\n\n        public int estimateParsedLength() {\n            return 1;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            if (position >= text.length()) {\n                return ~position;\n            }\n\n            char a = text.charAt(position);\n            char b = iValue;\n\n            if (a != b) {\n                a = Character.toUpperCase(a);\n                b = Character.toUpperCase(b);\n                if (a != b) {\n                    a = Character.toLowerCase(a);\n                    b = Character.toLowerCase(b);\n                    if (a != b) {\n                        return ~position;\n                    }\n                }\n            }\n\n            return position + 1;\n        }\n    }\n\n    \n    static class StringLiteral implements DateTimePrinter, DateTimeParser { private final String iValue; StringLiteral(String value) {\n            super();\n            iValue = value;\n        }\n\n        public int estimatePrintedLength() {\n            return iValue.length();\n        }\n\n        public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) {\n            buf.append(iValue);\n        }\n\n        public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            out.write(iValue);\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            buf.append(iValue);\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            out.write(iValue);\n        }\n\n        public int estimateParsedLength() {\n            return iValue.length();\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            if (text.regionMatches(true, position, iValue, 0, iValue.length())) {\n                return position + iValue.length();\n            }\n            return ~position;\n        }\n    }\n\n    \n    static abstract class NumberFormatter implements DateTimePrinter, DateTimeParser { protected final DateTimeFieldType iFieldType; protected final int iMaxParsedDigits; protected final boolean iSigned; NumberFormatter(DateTimeFieldType fieldType, int maxParsedDigits, boolean signed) {\n            super();\n            iFieldType = fieldType;\n            iMaxParsedDigits = maxParsedDigits;\n            iSigned = signed;\n        }\n\n        public int estimateParsedLength() {\n            return iMaxParsedDigits;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = Math.min(iMaxParsedDigits, text.length() - position);\n\n            boolean negative = false;\n            int length = 0;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                if (length == 0 && (c == '-' || c == '+') && iSigned) {\n                    negative = c == '-';\n\n                    \n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        \n                        position++;\n                    }\n                    \n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                if (c < '0' || c > '9') {\n                    break;\n                }\n                length++;\n            }\n\n            if (length == 0) {\n                return ~position;\n            }\n\n            int value;\n            if (length >= 9) {\n                \n                \n                value = Integer.parseInt(text.substring(position, position += length));\n            } else {\n                int i = position;\n                if (negative) {\n                    i++;\n                }\n                try {\n                    value = text.charAt(i++) - '0';\n                } catch (StringIndexOutOfBoundsException e) {\n                    return ~position;\n                }\n                position += length;\n                while (i < position) {\n                    value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                }\n                if (negative) {\n                    value = -value;\n                }\n            }\n\n            bucket.saveField(iFieldType, value);\n            return position;\n        }\n    }\n\n    \n    static class UnpaddedNumber extends NumberFormatter { protected UnpaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits, boolean signed) {\n            super(fieldType, maxParsedDigits, signed);\n        }\n\n        public int estimatePrintedLength() {\n            return iMaxParsedDigits;\n        }\n\n        public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) {\n            try {\n                DateTimeField field = iFieldType.getField(chrono);\n                FormatUtils.appendUnpaddedInteger(buf, field.get(instant));\n            } catch (RuntimeException e) {\n                buf.append('\\ufffd');\n            }\n        }\n\n        public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            try {\n                DateTimeField field = iFieldType.getField(chrono);\n                FormatUtils.writeUnpaddedInteger(out, field.get(instant));\n            } catch (RuntimeException e) {\n                out.write('\\ufffd');\n            }\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            if (partial.isSupported(iFieldType)) {\n                try {\n                    FormatUtils.appendUnpaddedInteger(buf, partial.get(iFieldType));\n                } catch (RuntimeException e) {\n                    buf.append('\\ufffd');\n                }\n            } else {\n                buf.append('\\ufffd');\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            if (partial.isSupported(iFieldType)) {\n                try {\n                    FormatUtils.writeUnpaddedInteger(out, partial.get(iFieldType));\n                } catch (RuntimeException e) {\n                    out.write('\\ufffd');\n                }\n            } else {\n                out.write('\\ufffd');\n            }\n        }\n    }\n\n    \n    static class PaddedNumber extends NumberFormatter { protected final int iMinPrintedDigits; protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits, boolean signed, int minPrintedDigits) {\n            super(fieldType, maxParsedDigits, signed);\n            iMinPrintedDigits = minPrintedDigits;\n        }\n\n        public int estimatePrintedLength() {\n            return iMaxParsedDigits;\n        }\n\n        public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) {\n            try {\n                DateTimeField field = iFieldType.getField(chrono);\n                FormatUtils.appendPaddedInteger(buf, field.get(instant), iMinPrintedDigits);\n            } catch (RuntimeException e) {\n                appendUnknownString(buf, iMinPrintedDigits);\n            }\n        }\n\n        public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            try {\n                DateTimeField field = iFieldType.getField(chrono);\n                FormatUtils.writePaddedInteger(out, field.get(instant), iMinPrintedDigits);\n            } catch (RuntimeException e) {\n                printUnknownString(out, iMinPrintedDigits);\n            }\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            if (partial.isSupported(iFieldType)) {\n                try {\n                    FormatUtils.appendPaddedInteger(buf, partial.get(iFieldType), iMinPrintedDigits);\n                } catch (RuntimeException e) {\n                    appendUnknownString(buf, iMinPrintedDigits);\n                }\n            } else {\n                appendUnknownString(buf, iMinPrintedDigits);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            if (partial.isSupported(iFieldType)) {\n                try {\n                    FormatUtils.writePaddedInteger(out, partial.get(iFieldType), iMinPrintedDigits);\n                } catch (RuntimeException e) {\n                    printUnknownString(out, iMinPrintedDigits);\n                }\n            } else {\n                printUnknownString(out, iMinPrintedDigits);\n            }\n        }\n    }\n\n    \n    static class FixedNumber extends PaddedNumber { protected FixedNumber(DateTimeFieldType fieldType, int numDigits, boolean signed) {\n            super(fieldType, numDigits, signed, numDigits);\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int newPos = super.parseInto(bucket, text, position);\n            if (newPos < 0) {\n                return newPos;\n            }\n            int expectedPos = position + iMaxParsedDigits;\n            if (newPos != expectedPos) {\n                if (iSigned) {\n                    char c = text.charAt(position);\n                    if (c == '-' || c == '+') {\n                        expectedPos++;\n                    }\n                }\n                if (newPos > expectedPos) {\n                    \n                    return ~(expectedPos + 1);\n                } else if (newPos < expectedPos) {\n                    \n                    return ~newPos;\n                }\n            }\n            return newPos;\n        }\n    }\n\n    \n    static class TwoDigitYear implements DateTimePrinter, DateTimeParser { private final DateTimeFieldType iType; private final int iPivot; private final boolean iLenientParse; TwoDigitYear(DateTimeFieldType type, int pivot, boolean lenientParse) {\n            super();\n            iType = type;\n            iPivot = pivot;\n            iLenientParse = lenientParse;\n        }\n\n        public int estimateParsedLength() {\n            return iLenientParse ? 4 : 2;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            \n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        \n                        \n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            \n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }\n        \n        public int estimatePrintedLength() {\n            return 2;\n        }\n\n        public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) {\n            int year = getTwoDigitYear(instant, chrono);\n            if (year < 0) {\n                buf.append('\\ufffd');\n                buf.append('\\ufffd');\n            } else {\n                FormatUtils.appendPaddedInteger(buf, year, 2);\n            }\n        }\n\n        public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            int year = getTwoDigitYear(instant, chrono);\n            if (year < 0) {\n                out.write('\\ufffd');\n                out.write('\\ufffd');\n            } else {\n                FormatUtils.writePaddedInteger(out, year, 2);\n            }\n        }\n\n        private int getTwoDigitYear(long instant, Chronology chrono) {\n            try {\n                int year = iType.getField(chrono).get(instant);\n                if (year < 0) {\n                    year = -year;\n                }\n                return year % 100;\n            } catch (RuntimeException e) {\n                return -1;\n            }\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            int year = getTwoDigitYear(partial);\n            if (year < 0) {\n                buf.append('\\ufffd');\n                buf.append('\\ufffd');\n            } else {\n                FormatUtils.appendPaddedInteger(buf, year, 2);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            int year = getTwoDigitYear(partial);\n            if (year < 0) {\n                out.write('\\ufffd');\n                out.write('\\ufffd');\n            } else {\n                FormatUtils.writePaddedInteger(out, year, 2);\n            }\n        }\n\n        private int getTwoDigitYear(ReadablePartial partial) {\n            if (partial.isSupported(iType)) {\n                try {\n                    int year = partial.get(iType);\n                    if (year < 0) {\n                        year = -year;\n                    }\n                    return year % 100;\n                } catch (RuntimeException e) {}\n            } \n            return -1;\n        }\n    }\n\n    \n    static class TextField implements DateTimePrinter, DateTimeParser { private static Map<Locale, Map<DateTimeFieldType, Object[]>> cParseCache = new HashMap<Locale, Map<DateTimeFieldType, Object[]>>(); private final DateTimeFieldType iFieldType; private final boolean iShort; TextField(DateTimeFieldType fieldType, boolean isShort) {\n            super();\n            iFieldType = fieldType;\n            iShort = isShort;\n        }\n\n        public int estimatePrintedLength() {\n            return iShort ? 6 : 20;\n        }\n\n        public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) {\n            try {\n                buf.append(print(instant, chrono, locale));\n            } catch (RuntimeException e) {\n                buf.append('\\ufffd');\n            }\n        }\n\n        public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            try {\n                out.write(print(instant, chrono, locale));\n            } catch (RuntimeException e) {\n                out.write('\\ufffd');\n            }\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            try {\n                buf.append(print(partial, locale));\n            } catch (RuntimeException e) {\n                buf.append('\\ufffd');\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            try {\n                out.write(print(partial, locale));\n            } catch (RuntimeException e) {\n                out.write('\\ufffd');\n            }\n        }\n\n        private String print(long instant, Chronology chrono, Locale locale) {\n            DateTimeField field = iFieldType.getField(chrono);\n            if (iShort) {\n                return field.getAsShortText(instant, locale);\n            } else {\n                return field.getAsText(instant, locale);\n            }\n        }\n\n        private String print(ReadablePartial partial, Locale locale) {\n            if (partial.isSupported(iFieldType)) {\n                DateTimeField field = iFieldType.getField(partial.getChronology());\n                if (iShort) {\n                    return field.getAsShortText(partial, locale);\n                } else {\n                    return field.getAsText(partial, locale);\n                }\n            } else {\n                return \"\\ufffd\";\n            }\n        }\n\n        public int estimateParsedLength() {\n            return estimatePrintedLength();\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            Locale locale = bucket.getLocale();\n            \n            \n            Set<String> validValues = null;\n            int maxLength = 0;\n            synchronized (cParseCache) {\n                Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale);\n                if (innerMap == null) {\n                    innerMap = new HashMap<DateTimeFieldType, Object[]>();\n                    cParseCache.put(locale, innerMap);\n                }\n                Object[] array = innerMap.get(iFieldType);\n                if (array == null) {\n                    validValues = new HashSet<String>(32);\n                    MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC);\n                    Property property = dt.property(iFieldType);\n                    int min = property.getMinimumValueOverall();\n                    int max = property.getMaximumValueOverall();\n                    if (max - min > 32) {  \n                        return ~position;\n                    }\n                    maxLength = property.getMaximumTextLength(locale);\n                    for (int i = min; i <= max; i++) {\n                        property.set(i);\n                        validValues.add(property.getAsShortText(locale));\n                        validValues.add(property.getAsShortText(locale).toLowerCase(locale));\n                        validValues.add(property.getAsShortText(locale).toUpperCase(locale));\n                        validValues.add(property.getAsText(locale));\n                        validValues.add(property.getAsText(locale).toLowerCase(locale));\n                        validValues.add(property.getAsText(locale).toUpperCase(locale));\n                    }\n                    if (\"en\".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) {\n                        \n                        validValues.add(\"BCE\");\n                        validValues.add(\"bce\");\n                        validValues.add(\"CE\");\n                        validValues.add(\"ce\");\n                        maxLength = 3;\n                    }\n                    array = new Object[] {validValues, Integer.valueOf(maxLength)};\n                    innerMap.put(iFieldType, array);\n                } else {\n                    validValues = (Set<String>) array[0];\n                    maxLength = ((Integer) array[1]).intValue();\n                }\n            }\n            \n            int limit = Math.min(text.length(), position + maxLength);\n            for (int i = limit; i > position; i--) {\n                String match = text.substring(position, i);\n                if (validValues.contains(match)) {\n                    bucket.saveField(iFieldType, match, locale);\n                    return i;\n                }\n            }\n            return ~position;\n        }\n    }\n\n    \n    static class Fraction implements DateTimePrinter, DateTimeParser { private final DateTimeFieldType iFieldType; protected int iMinDigits; protected int iMaxDigits; protected Fraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n            super();\n            iFieldType = fieldType;\n            \n            if (maxDigits > 18) {\n                maxDigits = 18;\n            }\n            iMinDigits = minDigits;\n            iMaxDigits = maxDigits;\n        }\n\n        public int estimatePrintedLength() {\n            return iMaxDigits;\n        }\n\n        public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) {\n            try {\n                printTo(buf, null, instant, chrono);\n            } catch (IOException e) {\n                \n            }\n        }\n\n        public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            printTo(null, out, instant, chrono);\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            \n            \n            long millis = partial.getChronology().set(partial, 0L);\n            try {\n                printTo(buf, null, millis, partial.getChronology());\n            } catch (IOException e) {\n                \n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            \n            \n            long millis = partial.getChronology().set(partial, 0L);\n            printTo(null, out, millis, partial.getChronology());\n        }\n\n        protected void printTo(StringBuffer buf, Writer out, long instant, Chronology chrono) throws IOException {\n            DateTimeField field = iFieldType.getField(chrono);\n            int minDigits = iMinDigits;\n\n            long fraction;\n            try {\n                fraction = field.remainder(instant);\n            } catch (RuntimeException e) {\n                if (buf != null) {\n                    appendUnknownString(buf, minDigits);\n                } else {\n                    printUnknownString(out, minDigits);\n                }\n                return;\n            }\n\n            if (fraction == 0) {\n                if (buf != null) {\n                    while (--minDigits >= 0) {\n                        buf.append('0');\n                    }\n                } else {\n                    while (--minDigits >= 0) {\n                        out.write('0');\n                    }\n                }\n                return;\n            }\n\n            String str;\n            long[] fractionData = getFractionData(fraction, field);\n            long scaled = fractionData[0];\n            int maxDigits = (int) fractionData[1];\n            \n            if ((scaled & 0x7fffffff) == scaled) {\n                str = Integer.toString((int) scaled);\n            } else {\n                str = Long.toString(scaled);\n            }\n\n            int length = str.length();\n            int digits = maxDigits;\n            while (length < digits) {\n                if (buf != null) {\n                    buf.append('0');\n                } else {\n                    out.write('0');\n                }\n                minDigits--;\n                digits--;\n            }\n\n            if (minDigits < digits) {\n                \n                while (minDigits < digits) {\n                    if (length <= 1 || str.charAt(length - 1) != '0') {\n                        break;\n                    }\n                    digits--;\n                    length--;\n                }\n                if (length < str.length()) {\n                    if (buf != null) {\n                        for (int i=0; i<length; i++) {\n                            buf.append(str.charAt(i));\n                        }\n                    } else {\n                        for (int i=0; i<length; i++) {\n                            out.write(str.charAt(i));\n                        }\n                    }\n                    return;\n                }\n            }\n\n            if (buf != null) {\n                buf.append(str);\n            } else {\n                out.write(str);\n            }\n        }\n        \n        private long[] getFractionData(long fraction, DateTimeField field) {\n            long rangeMillis = field.getDurationField().getUnitMillis();\n            long scalar;\n            int maxDigits = iMaxDigits;\n            while (true) {\n                switch (maxDigits) {\n                default: scalar = 1L; break;\n                case 1:  scalar = 10L; break;\n                case 2:  scalar = 100L; break;\n                case 3:  scalar = 1000L; break;\n                case 4:  scalar = 10000L; break;\n                case 5:  scalar = 100000L; break;\n                case 6:  scalar = 1000000L; break;\n                case 7:  scalar = 10000000L; break;\n                case 8:  scalar = 100000000L; break;\n                case 9:  scalar = 1000000000L; break;\n                case 10: scalar = 10000000000L; break;\n                case 11: scalar = 100000000000L; break;\n                case 12: scalar = 1000000000000L; break;\n                case 13: scalar = 10000000000000L; break;\n                case 14: scalar = 100000000000000L; break;\n                case 15: scalar = 1000000000000000L; break;\n                case 16: scalar = 10000000000000000L; break;\n                case 17: scalar = 100000000000000000L; break;\n                case 18: scalar = 1000000000000000000L; break;\n                }\n                if (((rangeMillis * scalar) / scalar) == rangeMillis) {\n                    break;\n                }\n                \n                maxDigits--;\n            }\n            \n            return new long[] {fraction * scalar / rangeMillis, maxDigits};\n        }\n\n        public int estimateParsedLength() {\n            return iMaxDigits;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            DateTimeField field = iFieldType.getField(bucket.getChronology());\n            \n            int limit = Math.min(iMaxDigits, text.length() - position);\n\n            long value = 0;\n            long n = field.getDurationField().getUnitMillis() * 10;\n            int length = 0;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                if (c < '0' || c > '9') {\n                    break;\n                }\n                length++;\n                long nn = n / 10;\n                value += (c - '0') * nn;\n                n = nn;\n            }\n\n            value /= 10;\n\n            if (length == 0) {\n                return ~position;\n            }\n\n            if (value > Integer.MAX_VALUE) {\n                return ~position;\n            }\n\n            DateTimeField parseField = new PreciseDateTimeField(\n                DateTimeFieldType.millisOfSecond(),\n                MillisDurationField.INSTANCE,\n                field.getDurationField());\n\n            bucket.saveField(parseField, (int) value);\n\n            return position + length;\n        }\n    }\n\n    \n    static class TimeZoneOffset implements DateTimePrinter, DateTimeParser { private final String iZeroOffsetPrintText; private final String iZeroOffsetParseText; private final boolean iShowSeparators; private final int iMinFields; private final int iMaxFields; TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators, int minFields, int maxFields) {\n            super();\n            iZeroOffsetPrintText = zeroOffsetPrintText;\n            iZeroOffsetParseText = zeroOffsetParseText;\n            iShowSeparators = showSeparators;\n            if (minFields <= 0 || maxFields < minFields) {\n                throw new IllegalArgumentException();\n            }\n            if (minFields > 4) {\n                minFields = 4;\n                maxFields = 4;\n            }\n            iMinFields = minFields;\n            iMaxFields = maxFields;\n        }\n            \n        public int estimatePrintedLength() {\n            int est = 1 + iMinFields << 1;\n            if (iShowSeparators) {\n                est += iMinFields - 1;\n            }\n            if (iZeroOffsetPrintText != null && iZeroOffsetPrintText.length() > est) {\n                est = iZeroOffsetPrintText.length();\n            }\n            return est;\n        }\n        \n        public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) {\n            if (displayZone == null) {\n                return;  \n            }\n            if (displayOffset == 0 && iZeroOffsetPrintText != null) {\n                buf.append(iZeroOffsetPrintText);\n                return;\n            }\n            if (displayOffset >= 0) {\n                buf.append('+');\n            } else {\n                buf.append('-');\n                displayOffset = -displayOffset;\n            }\n\n            int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;\n            FormatUtils.appendPaddedInteger(buf, hours, 2);\n            if (iMaxFields == 1) {\n                return;\n            }\n            displayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;\n            if (displayOffset == 0 && iMinFields <= 1) {\n                return;\n            }\n\n            int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;\n            if (iShowSeparators) {\n                buf.append(':');\n            }\n            FormatUtils.appendPaddedInteger(buf, minutes, 2);\n            if (iMaxFields == 2) {\n                return;\n            }\n            displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n            if (displayOffset == 0 && iMinFields <= 2) {\n                return;\n            }\n\n            int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND;\n            if (iShowSeparators) {\n                buf.append(':');\n            }\n            FormatUtils.appendPaddedInteger(buf, seconds, 2);\n            if (iMaxFields == 3) {\n                return;\n            }\n            displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n            if (displayOffset == 0 && iMinFields <= 3) {\n                return;\n            }\n\n            if (iShowSeparators) {\n                buf.append('.');\n            }\n            FormatUtils.appendPaddedInteger(buf, displayOffset, 3);\n        }\n        \n        public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            if (displayZone == null) {\n                return;  \n            }\n            if (displayOffset == 0 && iZeroOffsetPrintText != null) {\n                out.write(iZeroOffsetPrintText);\n                return;\n            }\n            if (displayOffset >= 0) {\n                out.write('+');\n            } else {\n                out.write('-');\n                displayOffset = -displayOffset;\n            }\n\n            int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;\n            FormatUtils.writePaddedInteger(out, hours, 2);\n            if (iMaxFields == 1) {\n                return;\n            }\n            displayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;\n            if (displayOffset == 0 && iMinFields == 1) {\n                return;\n            }\n\n            int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;\n            if (iShowSeparators) {\n                out.write(':');\n            }\n            FormatUtils.writePaddedInteger(out, minutes, 2);\n            if (iMaxFields == 2) {\n                return;\n            }\n            displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n            if (displayOffset == 0 && iMinFields == 2) {\n                return;\n            }\n\n            int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND;\n            if (iShowSeparators) {\n                out.write(':');\n            }\n            FormatUtils.writePaddedInteger(out, seconds, 2);\n            if (iMaxFields == 3) {\n                return;\n            }\n            displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n            if (displayOffset == 0 && iMinFields == 3) {\n                return;\n            }\n\n            if (iShowSeparators) {\n                out.write('.');\n            }\n            FormatUtils.writePaddedInteger(out, displayOffset, 3);\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            \n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            \n        }\n\n        public int estimateParsedLength() {\n            return estimatePrintedLength();\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    \n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            \n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            \n            \n            \n            \n            \n            \n            \n            \n            \n\n            \n\n            if (digitCount(text, position, 2) < 2) {\n                \n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                \n                \n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                \n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    \n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                \n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    \n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                \n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    \n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }\n\n        \n        private int digitCount(String text, int position, int amount) {\n            int limit = Math.min(text.length() - position, amount);\n            amount = 0;\n            for (; limit > 0; limit--) {\n                char c = text.charAt(position + amount);\n                if (c < '0' || c > '9') {\n                    break;\n                }\n                amount++;\n            }\n            return amount;\n        }\n    }\n\n    \n    static class TimeZoneName implements DateTimePrinter, DateTimeParser { static final int LONG_NAME = 0; static final int SHORT_NAME = 1; private final Map<String, DateTimeZone> iParseLookup; private final int iType; TimeZoneName(int type, Map<String, DateTimeZone> parseLookup) {\n            super();\n            iType = type;\n            iParseLookup = parseLookup;\n        }\n\n        public int estimatePrintedLength() {\n            return (iType == SHORT_NAME ? 4 : 20);\n        }\n\n        public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) {\n            buf.append(print(instant - displayOffset, displayZone, locale));\n        }\n\n        public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            out.write(print(instant - displayOffset, displayZone, locale));\n        }\n\n        private String print(long instant, DateTimeZone displayZone, Locale locale) {\n            if (displayZone == null) {\n                return \"\";  \n            }\n            switch (iType) {\n                case LONG_NAME:\n                    return displayZone.getName(instant, locale);\n                case SHORT_NAME:\n                    return displayZone.getShortName(instant, locale);\n            }\n            return \"\";\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            \n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            \n        }\n\n        public int estimateParsedLength() {\n            return (iType == SHORT_NAME ? 4 : 20);\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            String str = text.substring(position);\n            for (String name : iParseLookup.keySet()) {\n                if (str.startsWith(name)) {\n                    bucket.setZone(iParseLookup.get(name));\n                    return position + name.length();\n                }\n            }\n            return ~position;\n        }\n    }\n\n    \n    static enum TimeZoneId implements DateTimePrinter, DateTimeParser { INSTANCE; static final Set<String> ALL_IDS = DateTimeZone.getAvailableIDs(); static final int MAX_LENGTH; static {\n            int max = 0;\n            for (String id : ALL_IDS) {\n                max = Math.max(max, id.length());\n            }\n            MAX_LENGTH = max;\n        }\n\n        public int estimatePrintedLength() {\n            return MAX_LENGTH;\n        }\n\n        public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) {\n            buf.append(displayZone != null ? displayZone.getID() : \"\");\n        }\n\n        public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            out.write(displayZone != null ? displayZone.getID() : \"\");\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            \n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            \n        }\n\n        public int estimateParsedLength() {\n            return MAX_LENGTH;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            String str = text.substring(position);\n            String best = null;\n            for (String id : ALL_IDS) {\n                if (str.startsWith(id)) {\n                \tif (best == null || id.length() > best.length()) {\n                \t\tbest = id;\n                \t}\n                }\n            }\n            if (best != null) {\n                bucket.setZone(DateTimeZone.forID(best));\n                return position + best.length();\n            }\n            return ~position;\n        }\n    }\n\n    \n    static class Composite implements DateTimePrinter, DateTimeParser { private final DateTimePrinter[] iPrinters; private final DateTimeParser[] iParsers; private final int iPrintedLengthEstimate; private final int iParsedLengthEstimate; Composite(List<Object> elementPairs) {\n            super();\n\n            List<Object> printerList = new ArrayList<Object>();\n            List<Object> parserList = new ArrayList<Object>();\n\n            decompose(elementPairs, printerList, parserList);\n\n            if (printerList.size() <= 0) {\n                iPrinters = null;\n                iPrintedLengthEstimate = 0;\n            } else {\n                int size = printerList.size();\n                iPrinters = new DateTimePrinter[size];\n                int printEst = 0;\n                for (int i=0; i<size; i++) {\n                    DateTimePrinter printer = (DateTimePrinter) printerList.get(i);\n                    printEst += printer.estimatePrintedLength();\n                    iPrinters[i] = printer;\n                }\n                iPrintedLengthEstimate = printEst;\n            }\n\n            if (parserList.size() <= 0) {\n                iParsers = null;\n                iParsedLengthEstimate = 0;\n            } else {\n                int size = parserList.size();\n                iParsers = new DateTimeParser[size];\n                int parseEst = 0;\n                for (int i=0; i<size; i++) {\n                    DateTimeParser parser = (DateTimeParser) parserList.get(i);\n                    parseEst += parser.estimateParsedLength();\n                    iParsers[i] = parser;\n                }\n                iParsedLengthEstimate = parseEst;\n            }\n        }\n\n        public int estimatePrintedLength() {\n            return iPrintedLengthEstimate;\n        }\n\n        public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) {\n            DateTimePrinter[] elements = iPrinters;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            if (locale == null) {\n                \n                locale = Locale.getDefault();\n            }\n\n            int len = elements.length;\n            for (int i = 0; i < len; i++) {\n                elements[i].printTo(buf, instant, chrono, displayOffset, displayZone, locale);\n            }\n        }\n\n        public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            DateTimePrinter[] elements = iPrinters;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            if (locale == null) {\n                \n                locale = Locale.getDefault();\n            }\n\n            int len = elements.length;\n            for (int i = 0; i < len; i++) {\n                elements[i].printTo(out, instant, chrono, displayOffset, displayZone, locale);\n            }\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            DateTimePrinter[] elements = iPrinters;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            if (locale == null) {\n                \n                locale = Locale.getDefault();\n            }\n\n            int len = elements.length;\n            for (int i=0; i<len; i++) {\n                elements[i].printTo(buf, partial, locale);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            DateTimePrinter[] elements = iPrinters;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            if (locale == null) {\n                \n                locale = Locale.getDefault();\n            }\n\n            int len = elements.length;\n            for (int i=0; i<len; i++) {\n                elements[i].printTo(out, partial, locale);\n            }\n        }\n\n        public int estimateParsedLength() {\n            return iParsedLengthEstimate;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            DateTimeParser[] elements = iParsers;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            int len = elements.length;\n            for (int i=0; i<len && position >= 0; i++) {\n                position = elements[i].parseInto(bucket, text, position);\n            }\n            return position;\n        }\n\n        boolean isPrinter() {\n            return iPrinters != null;\n        }\n\n        boolean isParser() {\n            return iParsers != null;\n        }\n\n        \n        private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\n            int size = elementPairs.size();\n            for (int i=0; i<size; i+=2) {\n                Object element = elementPairs.get(i);\n                if (element instanceof DateTimePrinter) {\n                    if (element instanceof Composite) {\n                        addArrayToList(printerList, ((Composite)element).iPrinters);\n                    } else {\n                        printerList.add(element);\n                    }\n                }\n\n                element = elementPairs.get(i + 1);\n                if (element instanceof DateTimeParser) {\n                    if (element instanceof Composite) {\n                        addArrayToList(parserList, ((Composite)element).iParsers);\n                    } else {\n                        parserList.add(element);\n                    }\n                }\n            }\n        }\n\n        private void addArrayToList(List<Object> list, Object[] array) {\n            if (array != null) {\n                for (int i=0; i<array.length; i++) {\n                    list.add(array[i]);\n                }\n            }\n        }\n    }\n\n    \n    static class MatchingParser implements DateTimeParser { private final DateTimeParser[] iParsers; private final int iParsedLengthEstimate; MatchingParser(DateTimeParser[] parsers) {\n            super();\n            iParsers = parsers;\n            int est = 0;\n            for (int i=parsers.length; --i>=0 ;) {\n                DateTimeParser parser = parsers[i];\n                if (parser != null) {\n                    int len = parser.estimateParsedLength();\n                    if (len > est) {\n                        est = len;\n                    }\n                }\n            }\n            iParsedLengthEstimate = est;\n        }\n\n        public int estimateParsedLength() {\n            return iParsedLengthEstimate;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            DateTimeParser[] parsers = iParsers;\n            int length = parsers.length;\n\n            final Object originalState = bucket.saveState();\n            boolean isOptional = false;\n\n            int bestValidPos = position;\n            Object bestValidState = null;\n\n            int bestInvalidPos = position;\n\n            for (int i=0; i<length; i++) {\n                DateTimeParser parser = parsers[i];\n                if (parser == null) {\n                    \n                    if (bestValidPos <= position) {\n                        return position;\n                    }\n                    isOptional = true;\n                    break;\n                }\n                int parsePos = parser.parseInto(bucket, text, position);\n                if (parsePos >= position) {\n                    if (parsePos > bestValidPos) {\n                        if (parsePos >= text.length() ||\n                            (i + 1) >= length || parsers[i + 1] == null) {\n\n                            \n                            \n                            return parsePos;\n                        }\n                        bestValidPos = parsePos;\n                        bestValidState = bucket.saveState();\n                    }\n                } else {\n                    if (parsePos < 0) {\n                        parsePos = ~parsePos;\n                        if (parsePos > bestInvalidPos) {\n                            bestInvalidPos = parsePos;\n                        }\n                    }\n                }\n                bucket.restoreState(originalState);\n            }\n\n            if (bestValidPos > position || (bestValidPos == position && isOptional)) {\n                \n                if (bestValidState != null) {\n                    bucket.restoreState(bestValidState);\n                }\n                return bestValidPos;\n            }\n\n            return ~bestInvalidPos;\n        }\n    }\n\n}\n",
      "buggy_signatures": [
        "public class DateTimeFormatterBuilder { private ArrayList<Object> iElementPairs; private Object iFormatter; public DateTimeFormatterBuilder()",
        "public DateTimeFormatter toFormatter()",
        "public DateTimePrinter toPrinter()",
        "public DateTimeParser toParser()",
        "public boolean canBuildFormatter()",
        "public boolean canBuildPrinter()",
        "public boolean canBuildParser()",
        "public void clear()",
        "public DateTimeFormatterBuilder append(DateTimeFormatter formatter)",
        "public DateTimeFormatterBuilder append(DateTimePrinter printer)",
        "public DateTimeFormatterBuilder append(DateTimeParser parser)",
        "public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser parser)",
        "public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers)",
        "public DateTimeFormatterBuilder appendOptional(DateTimeParser parser)",
        "private void checkParser(DateTimeParser parser)",
        "private void checkPrinter(DateTimePrinter printer)",
        "private DateTimeFormatterBuilder append0(Object element)",
        "private DateTimeFormatterBuilder append0( DateTimePrinter printer, DateTimeParser parser)",
        "public DateTimeFormatterBuilder appendLiteral(char c)",
        "public DateTimeFormatterBuilder appendLiteral(String text)",
        "public DateTimeFormatterBuilder appendDecimal( DateTimeFieldType fieldType, int minDigits, int maxDigits)",
        "public DateTimeFormatterBuilder appendFixedDecimal( DateTimeFieldType fieldType, int numDigits)",
        "public DateTimeFormatterBuilder appendSignedDecimal( DateTimeFieldType fieldType, int minDigits, int maxDigits)",
        "public DateTimeFormatterBuilder appendFixedSignedDecimal( DateTimeFieldType fieldType, int numDigits)",
        "public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType)",
        "public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType)",
        "public DateTimeFormatterBuilder appendFraction( DateTimeFieldType fieldType, int minDigits, int maxDigits)",
        "public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits)",
        "public DateTimeFormatterBuilder appendFractionOfMinute(int minDigits, int maxDigits)",
        "public DateTimeFormatterBuilder appendFractionOfHour(int minDigits, int maxDigits)",
        "public DateTimeFormatterBuilder appendFractionOfDay(int minDigits, int maxDigits)",
        "public DateTimeFormatterBuilder appendMillisOfSecond(int minDigits)",
        "public DateTimeFormatterBuilder appendMillisOfDay(int minDigits)",
        "public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits)",
        "public DateTimeFormatterBuilder appendSecondOfDay(int minDigits)",
        "public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits)",
        "public DateTimeFormatterBuilder appendMinuteOfDay(int minDigits)",
        "public DateTimeFormatterBuilder appendHourOfDay(int minDigits)",
        "public DateTimeFormatterBuilder appendClockhourOfDay(int minDigits)",
        "public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits)",
        "public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits)",
        "public DateTimeFormatterBuilder appendDayOfWeek(int minDigits)",
        "public DateTimeFormatterBuilder appendDayOfMonth(int minDigits)",
        "public DateTimeFormatterBuilder appendDayOfYear(int minDigits)",
        "public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits)",
        "public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits)",
        "public DateTimeFormatterBuilder appendMonthOfYear(int minDigits)",
        "public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits)",
        "public DateTimeFormatterBuilder appendTwoDigitYear(int pivot)",
        "public DateTimeFormatterBuilder appendTwoDigitYear(int pivot, boolean lenientParse)",
        "public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot)",
        "public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot, boolean lenientParse)",
        "public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits)",
        "public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits)",
        "public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits)",
        "public DateTimeFormatterBuilder appendHalfdayOfDayText()",
        "public DateTimeFormatterBuilder appendDayOfWeekText()",
        "public DateTimeFormatterBuilder appendDayOfWeekShortText()",
        "public DateTimeFormatterBuilder appendMonthOfYearText()",
        "public DateTimeFormatterBuilder appendMonthOfYearShortText()",
        "public DateTimeFormatterBuilder appendEraText()",
        "public DateTimeFormatterBuilder appendTimeZoneName()",
        "public DateTimeFormatterBuilder appendTimeZoneName(Map<String, DateTimeZone> parseLookup)",
        "public DateTimeFormatterBuilder appendTimeZoneShortName()",
        "public DateTimeFormatterBuilder appendTimeZoneShortName(Map<String, DateTimeZone> parseLookup)",
        "public DateTimeFormatterBuilder appendTimeZoneId()",
        "public DateTimeFormatterBuilder appendTimeZoneOffset( String zeroOffsetText, boolean showSeparators, int minFields, int maxFields)",
        "public DateTimeFormatterBuilder appendTimeZoneOffset( String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators, int minFields, int maxFields)",
        "public DateTimeFormatterBuilder appendPattern(String pattern)",
        "private Object getFormatter()",
        "private boolean isPrinter(Object f)",
        "private boolean isParser(Object f)",
        "private boolean isFormatter(Object f)",
        "static void appendUnknownString(StringBuffer buf, int len)",
        "static void printUnknownString(Writer out, int len) throws IOException",
        "static class CharacterLiteral implements DateTimePrinter, DateTimeParser { private final char iValue; CharacterLiteral(char value)",
        "public int estimatePrintedLength()",
        "public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale)",
        "public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException",
        "public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale)",
        "public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException",
        "public int estimateParsedLength()",
        "public int parseInto(DateTimeParserBucket bucket, String text, int position)",
        "static class StringLiteral implements DateTimePrinter, DateTimeParser { private final String iValue; StringLiteral(String value)",
        "public int estimatePrintedLength()",
        "public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale)",
        "public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException",
        "public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale)",
        "public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException",
        "public int estimateParsedLength()",
        "public int parseInto(DateTimeParserBucket bucket, String text, int position)",
        "static abstract class NumberFormatter implements DateTimePrinter, DateTimeParser { protected final DateTimeFieldType iFieldType; protected final int iMaxParsedDigits; protected final boolean iSigned; NumberFormatter(DateTimeFieldType fieldType, int maxParsedDigits, boolean signed)",
        "public int estimateParsedLength()",
        "public int parseInto(DateTimeParserBucket bucket, String text, int position)",
        "static class UnpaddedNumber extends NumberFormatter { protected UnpaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits, boolean signed)",
        "public int estimatePrintedLength()",
        "public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale)",
        "public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException",
        "public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale)",
        "public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException",
        "static class PaddedNumber extends NumberFormatter { protected final int iMinPrintedDigits; protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits, boolean signed, int minPrintedDigits)",
        "public int estimatePrintedLength()",
        "public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale)",
        "public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException",
        "public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale)",
        "public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException",
        "static class FixedNumber extends PaddedNumber { protected FixedNumber(DateTimeFieldType fieldType, int numDigits, boolean signed)",
        "public int parseInto(DateTimeParserBucket bucket, String text, int position)",
        "static class TwoDigitYear implements DateTimePrinter, DateTimeParser { private final DateTimeFieldType iType; private final int iPivot; private final boolean iLenientParse; TwoDigitYear(DateTimeFieldType type, int pivot, boolean lenientParse)",
        "public int estimateParsedLength()",
        "public int parseInto(DateTimeParserBucket bucket, String text, int position)",
        "public int estimatePrintedLength()",
        "public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale)",
        "public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException",
        "private int getTwoDigitYear(long instant, Chronology chrono)",
        "public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale)",
        "public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException",
        "private int getTwoDigitYear(ReadablePartial partial)",
        "public int estimatePrintedLength()",
        "public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale)",
        "public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException",
        "public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale)",
        "public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException",
        "private String print(long instant, Chronology chrono, Locale locale)",
        "private String print(ReadablePartial partial, Locale locale)",
        "public int estimateParsedLength()",
        "public int parseInto(DateTimeParserBucket bucket, String text, int position)",
        "synchronized (cParseCache)",
        "static class Fraction implements DateTimePrinter, DateTimeParser { private final DateTimeFieldType iFieldType; protected int iMinDigits; protected int iMaxDigits; protected Fraction(DateTimeFieldType fieldType, int minDigits, int maxDigits)",
        "public int estimatePrintedLength()",
        "public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale)",
        "public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException",
        "public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale)",
        "public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException",
        "protected void printTo(StringBuffer buf, Writer out, long instant, Chronology chrono) throws IOException",
        "private long[] getFractionData(long fraction, DateTimeField field)",
        "public int estimateParsedLength()",
        "public int parseInto(DateTimeParserBucket bucket, String text, int position)",
        "static class TimeZoneOffset implements DateTimePrinter, DateTimeParser { private final String iZeroOffsetPrintText; private final String iZeroOffsetParseText; private final boolean iShowSeparators; private final int iMinFields; private final int iMaxFields; TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators, int minFields, int maxFields)",
        "public int estimatePrintedLength()",
        "public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale)",
        "public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException",
        "public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale)",
        "public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException",
        "public int estimateParsedLength()",
        "public int parseInto(DateTimeParserBucket bucket, String text, int position)",
        "private int digitCount(String text, int position, int amount)",
        "public int estimatePrintedLength()",
        "public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale)",
        "public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException",
        "private String print(long instant, DateTimeZone displayZone, Locale locale)",
        "public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale)",
        "public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException",
        "public int estimateParsedLength()",
        "public int parseInto(DateTimeParserBucket bucket, String text, int position)",
        "public int estimatePrintedLength()",
        "public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale)",
        "public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException",
        "public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale)",
        "public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException",
        "public int estimateParsedLength()",
        "public int parseInto(DateTimeParserBucket bucket, String text, int position)",
        "static class Composite implements DateTimePrinter, DateTimeParser { private final DateTimePrinter[] iPrinters; private final DateTimeParser[] iParsers; private final int iPrintedLengthEstimate; private final int iParsedLengthEstimate; Composite(List<Object> elementPairs)",
        "public int estimatePrintedLength()",
        "public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale)",
        "public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException",
        "public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale)",
        "public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException",
        "public int estimateParsedLength()",
        "public int parseInto(DateTimeParserBucket bucket, String text, int position)",
        "private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList)",
        "private void addArrayToList(List<Object> list, Object[] array)",
        "static class MatchingParser implements DateTimeParser { private final DateTimeParser[] iParsers; private final int iParsedLengthEstimate; MatchingParser(DateTimeParser[] parsers)",
        "public int estimateParsedLength()",
        "public int parseInto(DateTimeParserBucket bucket, String text, int position)"
      ],
      "fixed_signatures": [
        "public class DateTimeFormatterBuilder { private ArrayList<Object> iElementPairs; private Object iFormatter; public DateTimeFormatterBuilder()",
        "public DateTimeFormatter toFormatter()",
        "public DateTimePrinter toPrinter()",
        "public DateTimeParser toParser()",
        "public boolean canBuildFormatter()",
        "public boolean canBuildPrinter()",
        "public boolean canBuildParser()",
        "public void clear()",
        "public DateTimeFormatterBuilder append(DateTimeFormatter formatter)",
        "public DateTimeFormatterBuilder append(DateTimePrinter printer)",
        "public DateTimeFormatterBuilder append(DateTimeParser parser)",
        "public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser parser)",
        "public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers)",
        "public DateTimeFormatterBuilder appendOptional(DateTimeParser parser)",
        "private void checkParser(DateTimeParser parser)",
        "private void checkPrinter(DateTimePrinter printer)",
        "private DateTimeFormatterBuilder append0(Object element)",
        "private DateTimeFormatterBuilder append0( DateTimePrinter printer, DateTimeParser parser)",
        "public DateTimeFormatterBuilder appendLiteral(char c)",
        "public DateTimeFormatterBuilder appendLiteral(String text)",
        "public DateTimeFormatterBuilder appendDecimal( DateTimeFieldType fieldType, int minDigits, int maxDigits)",
        "public DateTimeFormatterBuilder appendFixedDecimal( DateTimeFieldType fieldType, int numDigits)",
        "public DateTimeFormatterBuilder appendSignedDecimal( DateTimeFieldType fieldType, int minDigits, int maxDigits)",
        "public DateTimeFormatterBuilder appendFixedSignedDecimal( DateTimeFieldType fieldType, int numDigits)",
        "public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType)",
        "public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType)",
        "public DateTimeFormatterBuilder appendFraction( DateTimeFieldType fieldType, int minDigits, int maxDigits)",
        "public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits)",
        "public DateTimeFormatterBuilder appendFractionOfMinute(int minDigits, int maxDigits)",
        "public DateTimeFormatterBuilder appendFractionOfHour(int minDigits, int maxDigits)",
        "public DateTimeFormatterBuilder appendFractionOfDay(int minDigits, int maxDigits)",
        "public DateTimeFormatterBuilder appendMillisOfSecond(int minDigits)",
        "public DateTimeFormatterBuilder appendMillisOfDay(int minDigits)",
        "public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits)",
        "public DateTimeFormatterBuilder appendSecondOfDay(int minDigits)",
        "public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits)",
        "public DateTimeFormatterBuilder appendMinuteOfDay(int minDigits)",
        "public DateTimeFormatterBuilder appendHourOfDay(int minDigits)",
        "public DateTimeFormatterBuilder appendClockhourOfDay(int minDigits)",
        "public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits)",
        "public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits)",
        "public DateTimeFormatterBuilder appendDayOfWeek(int minDigits)",
        "public DateTimeFormatterBuilder appendDayOfMonth(int minDigits)",
        "public DateTimeFormatterBuilder appendDayOfYear(int minDigits)",
        "public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits)",
        "public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits)",
        "public DateTimeFormatterBuilder appendMonthOfYear(int minDigits)",
        "public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits)",
        "public DateTimeFormatterBuilder appendTwoDigitYear(int pivot)",
        "public DateTimeFormatterBuilder appendTwoDigitYear(int pivot, boolean lenientParse)",
        "public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot)",
        "public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot, boolean lenientParse)",
        "public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits)",
        "public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits)",
        "public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits)",
        "public DateTimeFormatterBuilder appendHalfdayOfDayText()",
        "public DateTimeFormatterBuilder appendDayOfWeekText()",
        "public DateTimeFormatterBuilder appendDayOfWeekShortText()",
        "public DateTimeFormatterBuilder appendMonthOfYearText()",
        "public DateTimeFormatterBuilder appendMonthOfYearShortText()",
        "public DateTimeFormatterBuilder appendEraText()",
        "public DateTimeFormatterBuilder appendTimeZoneName()",
        "public DateTimeFormatterBuilder appendTimeZoneName(Map<String, DateTimeZone> parseLookup)",
        "public DateTimeFormatterBuilder appendTimeZoneShortName()",
        "public DateTimeFormatterBuilder appendTimeZoneShortName(Map<String, DateTimeZone> parseLookup)",
        "public DateTimeFormatterBuilder appendTimeZoneId()",
        "public DateTimeFormatterBuilder appendTimeZoneOffset( String zeroOffsetText, boolean showSeparators, int minFields, int maxFields)",
        "public DateTimeFormatterBuilder appendTimeZoneOffset( String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators, int minFields, int maxFields)",
        "public DateTimeFormatterBuilder appendPattern(String pattern)",
        "private Object getFormatter()",
        "private boolean isPrinter(Object f)",
        "private boolean isParser(Object f)",
        "private boolean isFormatter(Object f)",
        "static void appendUnknownString(StringBuffer buf, int len)",
        "static void printUnknownString(Writer out, int len) throws IOException",
        "static class CharacterLiteral implements DateTimePrinter, DateTimeParser { private final char iValue; CharacterLiteral(char value)",
        "public int estimatePrintedLength()",
        "public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale)",
        "public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException",
        "public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale)",
        "public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException",
        "public int estimateParsedLength()",
        "public int parseInto(DateTimeParserBucket bucket, String text, int position)",
        "static class StringLiteral implements DateTimePrinter, DateTimeParser { private final String iValue; StringLiteral(String value)",
        "public int estimatePrintedLength()",
        "public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale)",
        "public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException",
        "public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale)",
        "public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException",
        "public int estimateParsedLength()",
        "public int parseInto(DateTimeParserBucket bucket, String text, int position)",
        "static abstract class NumberFormatter implements DateTimePrinter, DateTimeParser { protected final DateTimeFieldType iFieldType; protected final int iMaxParsedDigits; protected final boolean iSigned; NumberFormatter(DateTimeFieldType fieldType, int maxParsedDigits, boolean signed)",
        "public int estimateParsedLength()",
        "public int parseInto(DateTimeParserBucket bucket, String text, int position)",
        "static class UnpaddedNumber extends NumberFormatter { protected UnpaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits, boolean signed)",
        "public int estimatePrintedLength()",
        "public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale)",
        "public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException",
        "public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale)",
        "public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException",
        "static class PaddedNumber extends NumberFormatter { protected final int iMinPrintedDigits; protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits, boolean signed, int minPrintedDigits)",
        "public int estimatePrintedLength()",
        "public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale)",
        "public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException",
        "public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale)",
        "public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException",
        "static class FixedNumber extends PaddedNumber { protected FixedNumber(DateTimeFieldType fieldType, int numDigits, boolean signed)",
        "public int parseInto(DateTimeParserBucket bucket, String text, int position)",
        "static class TwoDigitYear implements DateTimePrinter, DateTimeParser { private final DateTimeFieldType iType; private final int iPivot; private final boolean iLenientParse; TwoDigitYear(DateTimeFieldType type, int pivot, boolean lenientParse)",
        "public int estimateParsedLength()",
        "public int parseInto(DateTimeParserBucket bucket, String text, int position)",
        "public int estimatePrintedLength()",
        "public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale)",
        "public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException",
        "private int getTwoDigitYear(long instant, Chronology chrono)",
        "public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale)",
        "public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException",
        "private int getTwoDigitYear(ReadablePartial partial)",
        "public int estimatePrintedLength()",
        "public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale)",
        "public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException",
        "public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale)",
        "public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException",
        "private String print(long instant, Chronology chrono, Locale locale)",
        "private String print(ReadablePartial partial, Locale locale)",
        "public int estimateParsedLength()",
        "public int parseInto(DateTimeParserBucket bucket, String text, int position)",
        "synchronized (cParseCache)",
        "static class Fraction implements DateTimePrinter, DateTimeParser { private final DateTimeFieldType iFieldType; protected int iMinDigits; protected int iMaxDigits; protected Fraction(DateTimeFieldType fieldType, int minDigits, int maxDigits)",
        "public int estimatePrintedLength()",
        "public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale)",
        "public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException",
        "public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale)",
        "public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException",
        "protected void printTo(StringBuffer buf, Writer out, long instant, Chronology chrono) throws IOException",
        "private long[] getFractionData(long fraction, DateTimeField field)",
        "public int estimateParsedLength()",
        "public int parseInto(DateTimeParserBucket bucket, String text, int position)",
        "static class TimeZoneOffset implements DateTimePrinter, DateTimeParser { private final String iZeroOffsetPrintText; private final String iZeroOffsetParseText; private final boolean iShowSeparators; private final int iMinFields; private final int iMaxFields; TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators, int minFields, int maxFields)",
        "public int estimatePrintedLength()",
        "public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale)",
        "public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException",
        "public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale)",
        "public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException",
        "public int estimateParsedLength()",
        "public int parseInto(DateTimeParserBucket bucket, String text, int position)",
        "private int digitCount(String text, int position, int amount)",
        "public int estimatePrintedLength()",
        "public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale)",
        "public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException",
        "private String print(long instant, DateTimeZone displayZone, Locale locale)",
        "public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale)",
        "public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException",
        "public int estimateParsedLength()",
        "public int parseInto(DateTimeParserBucket bucket, String text, int position)",
        "public int estimatePrintedLength()",
        "public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale)",
        "public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException",
        "public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale)",
        "public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException",
        "public int estimateParsedLength()",
        "public int parseInto(DateTimeParserBucket bucket, String text, int position)",
        "static class Composite implements DateTimePrinter, DateTimeParser { private final DateTimePrinter[] iPrinters; private final DateTimeParser[] iParsers; private final int iPrintedLengthEstimate; private final int iParsedLengthEstimate; Composite(List<Object> elementPairs)",
        "public int estimatePrintedLength()",
        "public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale)",
        "public void printTo( Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException",
        "public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale)",
        "public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException",
        "public int estimateParsedLength()",
        "public int parseInto(DateTimeParserBucket bucket, String text, int position)",
        "private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList)",
        "private void addArrayToList(List<Object> list, Object[] array)",
        "static class MatchingParser implements DateTimeParser { private final DateTimeParser[] iParsers; private final int iParsedLengthEstimate; MatchingParser(DateTimeParser[] parsers)",
        "public int estimateParsedLength()",
        "public int parseInto(DateTimeParserBucket bucket, String text, int position)"
      ],
      "methods": [
        {
          "buggy_method": "  public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n  String str = text.substring(position);\n  for (String id : ALL_IDS) {\n  if (str.startsWith(id)) {\n  bucket.setZone(DateTimeZone.forID(id));\n  return position + id.length();\n  }\n  }\n  return ~position;\n  }",
          "fixed_method": "  public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n  String str = text.substring(position);\n  String best = null;\n  for (String id : ALL_IDS) {\n  if (str.startsWith(id)) {\n  \tif (best == null || id.length() > best.length()) {\n  \t\tbest = id;\n  \t}\n  }\n  }\n  if (best != null) {\n  bucket.setZone(DateTimeZone.forID(best));\n  return position + best.length();\n  }\n  return ~position;\n  }",
          "diff": [
            "@@ -2539,11 +2539,17 @@",
            " \n",
            "         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n",
            "             String str = text.substring(position);\n",
            "+            String best = null;\n",
            "             for (String id : ALL_IDS) {\n",
            "                 if (str.startsWith(id)) {\n",
            "-                    bucket.setZone(DateTimeZone.forID(id));\n",
            "-                    return position + id.length();\n",
            "-                }\n",
            "+                \tif (best == null || id.length() > best.length()) {\n",
            "+                \t\tbest = id;\n",
            "+                \t}\n",
            "+                }\n",
            "+            }\n",
            "+            if (best != null) {\n",
            "+                bucket.setZone(DateTimeZone.forID(best));\n",
            "+                return position + best.length();\n",
            "             }\n",
            "             return ~position;\n",
            "         }\n"
          ],
          "changed_lines": 12
        }
      ]
    }
  ]
}
