{
  "bug_id": "10",
  "failed_tests": {
    "org.apache.commons.jxpath.ri.compiler.CoreOperationTest": [
      {
        "methodName": "testEmptyNodeSetOperations",
        "error": "junit.framework.AssertionFailedError",
        "message": "Evaluating </idonotexist >= 0> expected:<false> but was:<true>",
        "fail_line": "        assertXPathValue(context, \"/idonotexist >= 0\", Boolean.FALSE, Boolean.class);",
        "test_source": "  public void testEmptyNodeSetOperations() {\n  assertXPathValue(context, \"/idonotexist = 0\", Boolean.FALSE, Boolean.class);\n  assertXPathValue(context, \"/idonotexist != 0\", Boolean.FALSE, Boolean.class);\n  assertXPathValue(context, \"/idonotexist < 0\", Boolean.FALSE, Boolean.class);\n  assertXPathValue(context, \"/idonotexist > 0\", Boolean.FALSE, Boolean.class);\n  assertXPathValue(context, \"/idonotexist >= 0\", Boolean.FALSE, Boolean.class);\n  assertXPathValue(context, \"/idonotexist <= 0\", Boolean.FALSE, Boolean.class);\n  assertXPathValue(context, \"$array[position() < 1] = 0\", Boolean.FALSE, Boolean.class);\n  assertXPathValue(context, \"$array[position() < 1] != 0\", Boolean.FALSE, Boolean.class);\n  assertXPathValue(context, \"$array[position() < 1] < 0\", Boolean.FALSE, Boolean.class);\n  assertXPathValue(context, \"$array[position() < 1] > 0\", Boolean.FALSE, Boolean.class);\n  assertXPathValue(context, \"$array[position() < 1] >= 0\", Boolean.FALSE, Boolean.class);\n  assertXPathValue(context, \"$array[position() < 1] <= 0\", Boolean.FALSE, Boolean.class);\n  }",
        "stack": [
          "JXPathTestCase.assertXPathValue line 63, CoreOperationTest.testEmptyNodeSetOperations line 120"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java",
      "buggy_full_code": "\npackage org.apache.commons.jxpath.ri.compiler;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\n\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.InfoSetUtil;\nimport org.apache.commons.jxpath.ri.axes.InitialContext;\nimport org.apache.commons.jxpath.ri.axes.SelfContext;\n\n\npublic abstract class CoreOperationRelationalExpression extends CoreOperation { protected CoreOperationRelationalExpression(Expression[] args) {\n        super(args);\n    }\n\n    public final Object computeValue(EvalContext context) {\n        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n                ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected final int getPrecedence() {\n        return 3;\n    }\n\n    protected final boolean isSymmetric() {\n        return false;\n    }\n\n    protected abstract boolean evaluateCompare(int compare); private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n        }\n        if (right instanceof Iterator) {\n            return containsMatch((Iterator) right, left);\n        }\n        double ld = InfoSetUtil.doubleValue(left);\n        if (Double.isNaN(ld)) {\n            return false;\n        }\n        double rd = InfoSetUtil.doubleValue(right);\n        if (Double.isNaN(rd)) {\n            return false;\n        }\n        return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n    }\n\n    private Object reduce(Object o) {\n        if (o instanceof SelfContext) {\n            o = ((EvalContext) o).getSingleNodePointer();\n        }\n        if (o instanceof Collection) {\n            o = ((Collection) o).iterator();\n        }\n        return o;\n    }\n\n    private boolean containsMatch(Iterator it, Object value) {\n        while (it.hasNext()) {\n            Object element = it.next();\n            if (compute(element, value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean findMatch(Iterator lit, Iterator rit) {\n        HashSet left = new HashSet();\n        while (lit.hasNext()) {\n            left.add(lit.next());\n        }\n        while (rit.hasNext()) {\n            if (containsMatch(left.iterator(), rit.next())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.jxpath.ri.compiler;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\n\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.InfoSetUtil;\nimport org.apache.commons.jxpath.ri.axes.InitialContext;\nimport org.apache.commons.jxpath.ri.axes.SelfContext;\n\n\npublic abstract class CoreOperationRelationalExpression extends CoreOperation { protected CoreOperationRelationalExpression(Expression[] args) {\n        super(args);\n    }\n\n    public final Object computeValue(EvalContext context) {\n        return compute(args[0].compute(context), args[1].compute(context))\n                ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected final int getPrecedence() {\n        return 3;\n    }\n\n    protected final boolean isSymmetric() {\n        return false;\n    }\n\n    protected abstract boolean evaluateCompare(int compare); private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n        }\n        if (right instanceof Iterator) {\n            return containsMatch((Iterator) right, left);\n        }\n        double ld = InfoSetUtil.doubleValue(left);\n        if (Double.isNaN(ld)) {\n            return false;\n        }\n        double rd = InfoSetUtil.doubleValue(right);\n        if (Double.isNaN(rd)) {\n            return false;\n        }\n        return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n    }\n\n    private Object reduce(Object o) {\n        if (o instanceof SelfContext) {\n            o = ((EvalContext) o).getSingleNodePointer();\n        }\n        if (o instanceof Collection) {\n            o = ((Collection) o).iterator();\n        }\n        return o;\n    }\n\n    private boolean containsMatch(Iterator it, Object value) {\n        while (it.hasNext()) {\n            Object element = it.next();\n            if (compute(element, value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean findMatch(Iterator lit, Iterator rit) {\n        HashSet left = new HashSet();\n        while (lit.hasNext()) {\n            left.add(lit.next());\n        }\n        while (rit.hasNext()) {\n            if (containsMatch(left.iterator(), rit.next())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n}\n",
      "buggy_signatures": [
        "public abstract class CoreOperationRelationalExpression extends CoreOperation { protected CoreOperationRelationalExpression(Expression[] args)",
        "public final Object computeValue(EvalContext context)",
        "protected final int getPrecedence()",
        "protected final boolean isSymmetric()",
        "protected abstract boolean evaluateCompare(int compare); private boolean compute(Object left, Object right)",
        "private Object reduce(Object o)",
        "private boolean containsMatch(Iterator it, Object value)",
        "private boolean findMatch(Iterator lit, Iterator rit)"
      ],
      "fixed_signatures": [
        "public abstract class CoreOperationRelationalExpression extends CoreOperation { protected CoreOperationRelationalExpression(Expression[] args)",
        "public final Object computeValue(EvalContext context)",
        "protected final int getPrecedence()",
        "protected final boolean isSymmetric()",
        "protected abstract boolean evaluateCompare(int compare); private boolean compute(Object left, Object right)",
        "private Object reduce(Object o)",
        "private boolean containsMatch(Iterator it, Object value)",
        "private boolean findMatch(Iterator lit, Iterator rit)"
      ],
      "methods": [
        {
          "buggy_method": "  public final Object computeValue(EvalContext context) {\n  return compute(args[0].computeValue(context), args[1].computeValue(context)) \n  ? Boolean.TRUE : Boolean.FALSE;\n  }",
          "fixed_method": "  public final Object computeValue(EvalContext context) {\n  return compute(args[0].compute(context), args[1].compute(context))\n  ? Boolean.TRUE : Boolean.FALSE;\n  }",
          "diff": [
            "@@ -39,7 +39,7 @@",
            "     }\n",
            " \n",
            "     public final Object computeValue(EvalContext context) {\n",
            "-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n",
            "+        return compute(args[0].compute(context), args[1].compute(context))\n",
            "                 ? Boolean.TRUE : Boolean.FALSE;\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
