{
  "bug_id": "107",
  "failed_tests": {
    "com.fasterxml.jackson.databind.deser.filter.ProblemHandlerUnknownTypeId2221Test": [
      {
        "methodName": "testWithDeserializationProblemHandler",
        "error": "com.fasterxml.jackson.databind.JsonMappingException",
        "message": "(was java.lang.NullPointerException) (through reference chain: com.fasterxml.jackson.databind.deser.filter.ProblemHandlerUnknownTypeId2221Test$GenericContent[\"innerObjects\"]->java.util.ArrayList[1])",
        "fail_line": "        GenericContent processableContent = mapper.readValue(JSON, GenericContent.class);",
        "test_source": "  public void testWithDeserializationProblemHandler() throws Exception {\n  final ObjectMapper mapper = new ObjectMapper()\n  .enableDefaultTyping();\n  mapper.addHandler(new DeserializationProblemHandler() {\n  @Override\n  public JavaType handleUnknownTypeId(DeserializationContext ctxt, JavaType baseType, String subTypeId, TypeIdResolver idResolver, String failureMsg) throws IOException {\n//  System.out.println(\"Print out a warning here\");\n  return ctxt.constructType(Void.class);\n  }\n  });\n  GenericContent processableContent = mapper.readValue(JSON, GenericContent.class);\n  assertNotNull(processableContent.getInnerObjects());\n  assertEquals(2, processableContent.getInnerObjects().size());\n  }",
        "stack": [
          "JsonMappingException.wrapWithPath line 394, JsonMappingException.wrapWithPath line 365, CollectionDeserializer.deserialize line 302, CollectionDeserializer.deserialize line 245, CollectionDeserializer.deserialize line 27, AsArrayTypeDeserializer._deserialize line 116, AsArrayTypeDeserializer.deserializeTypedFromArray line 53, CollectionDeserializer.deserializeWithType line 314, MethodProperty.deserializeAndSet line 136, BeanDeserializer.vanillaDeserialize line 288, BeanDeserializer._deserializeOther line 189, BeanDeserializer.deserialize line 161, AsPropertyTypeDeserializer._deserializeTypedForId line 130, AsPropertyTypeDeserializer.deserializeTypedFromObject line 97, BeanDeserializerBase.deserializeWithType line 1178, TypeWrappedDeserializer.deserialize line 68, ObjectMapper._readMapAndClose line 4013, ObjectMapper.readValue line 3004, ProblemHandlerUnknownTypeId2221Test.testWithDeserializationProblemHandler line 95, AsArrayTypeDeserializer._deserialize line 116, AsArrayTypeDeserializer.deserializeTypedFromAny line 71, UntypedObjectDeserializer$Vanilla.deserializeWithType line 712, CollectionDeserializer.deserialize line 288"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.BeanProperty;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonDeserializer;\nimport com.fasterxml.jackson.databind.deser.std.NullifyingDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\npublic abstract class TypeDeserializerBase extends TypeDeserializer implements java.io.Serializable { private static final long serialVersionUID = 1; protected final TypeIdResolver _idResolver; protected final JavaType _baseType; protected final BeanProperty _property; protected final JavaType _defaultImpl; protected final String _typePropertyName; protected final boolean _typeIdVisible; protected final Map<String,JsonDeserializer<Object>> _deserializers; protected JsonDeserializer<Object> _defaultImplDeserializer; protected TypeDeserializerBase(JavaType baseType, TypeIdResolver idRes, String typePropertyName, boolean typeIdVisible, JavaType defaultImpl) {\n        _baseType = baseType;\n        _idResolver = idRes;\n        _typePropertyName = ClassUtil.nonNullString(typePropertyName);\n        _typeIdVisible = typeIdVisible;\n        \n        _deserializers = new ConcurrentHashMap<String, JsonDeserializer<Object>>(16, 0.75f, 2);\n        _defaultImpl = defaultImpl;\n        _property = null;\n    }\n\n    protected TypeDeserializerBase(TypeDeserializerBase src, BeanProperty property) {\n        _baseType = src._baseType;\n        _idResolver = src._idResolver;\n        _typePropertyName = src._typePropertyName;\n        _typeIdVisible = src._typeIdVisible;\n        _deserializers = src._deserializers;\n        _defaultImpl = src._defaultImpl;\n        _defaultImplDeserializer = src._defaultImplDeserializer;\n        _property = property;\n    }\n\n    @Override\n    public abstract TypeDeserializer forProperty(BeanProperty prop); @Override public abstract JsonTypeInfo.As getTypeInclusion(); public String baseTypeName() { return _baseType.getRawClass().getName(); }\n\n    @Override\n    public final String getPropertyName() { return _typePropertyName; }\n    \n    @Override    \n    public TypeIdResolver getTypeIdResolver() { return _idResolver; }\n\n    @Override    \n    public Class<?> getDefaultImpl() {\n        return ClassUtil.rawClass(_defaultImpl);\n    }\n\n    \n    public JavaType baseType() {\n        return _baseType;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append('[').append(getClass().getName());\n        sb.append(\"; base-type:\").append(_baseType);\n        sb.append(\"; id-resolver: \").append(_idResolver);\n    \t    sb.append(']');\n    \t    return sb.toString();\n    }\n    \n    \n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n        JsonDeserializer<Object> deser = _deserializers.get(typeId);\n        if (deser == null) {\n            \n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                \n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    \n                    JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                    if (actual == null) { \n                        \n                        return null;\n                    }\n                    \n                    deser = ctxt.findContextualValueDeserializer(actual, _property);\n                }\n            } else {\n                \n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n                    \n                    \n                    \n                    \n                    \n                    if (!type.hasGenericTypes()) {\n                        type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                    }\n                }\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            }\n            _deserializers.put(typeId, deser);\n        }\n        return deser;\n    }\n\n    protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException {\n        \n        if (_defaultImpl == null) {\n            if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) {\n                return NullifyingDeserializer.instance;\n            }\n            return null;\n        }\n        Class<?> raw = _defaultImpl.getRawClass();\n        if (ClassUtil.isBogusClass(raw)) {\n            return NullifyingDeserializer.instance;\n        }\n        \n        synchronized (_defaultImpl) {\n            if (_defaultImplDeserializer == null) {\n                _defaultImplDeserializer = ctxt.findContextualValueDeserializer(\n                        _defaultImpl, _property);\n            }\n            return _defaultImplDeserializer;\n        }\n    }\n\n    \n    @Deprecated\n    protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        return _deserializeWithNativeTypeId(jp, ctxt, jp.getTypeId());\n    }\n\n    \n    protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt, Object typeId) throws IOException {\n        JsonDeserializer<Object> deser;\n        if (typeId == null) {\n            \n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                return ctxt.reportInputMismatch(baseType(),\n                        \"No (native) type id found when one was expected for polymorphic type handling\"); } } else { String typeIdStr = (typeId instanceof String) ? (String) typeId : String.valueOf(typeId); deser = _findDeserializer(ctxt, typeIdStr); } return deser.deserialize(jp, ctxt); } protected JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId) throws IOException { String extraDesc = _idResolver.getDescForKnownTypeIds(); if (extraDesc == null) { extraDesc = \"type ids are not statically known\"; } else { extraDesc = \"known type ids = \" + extraDesc; } if (_property != null) { extraDesc = String.format(\"%s (for POJO property '%s')\", extraDesc, _property.getName()); } return ctxt.handleUnknownTypeId(_baseType, typeId, _idResolver, extraDesc); } protected JavaType _handleMissingTypeId(DeserializationContext ctxt, String extraDesc) throws IOException {\n        return ctxt.handleMissingTypeId(_baseType, _idResolver, extraDesc);\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.BeanProperty;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonDeserializer;\nimport com.fasterxml.jackson.databind.deser.std.NullifyingDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\npublic abstract class TypeDeserializerBase extends TypeDeserializer implements java.io.Serializable { private static final long serialVersionUID = 1; protected final TypeIdResolver _idResolver; protected final JavaType _baseType; protected final BeanProperty _property; protected final JavaType _defaultImpl; protected final String _typePropertyName; protected final boolean _typeIdVisible; protected final Map<String,JsonDeserializer<Object>> _deserializers; protected JsonDeserializer<Object> _defaultImplDeserializer; protected TypeDeserializerBase(JavaType baseType, TypeIdResolver idRes, String typePropertyName, boolean typeIdVisible, JavaType defaultImpl) {\n        _baseType = baseType;\n        _idResolver = idRes;\n        _typePropertyName = ClassUtil.nonNullString(typePropertyName);\n        _typeIdVisible = typeIdVisible;\n        \n        _deserializers = new ConcurrentHashMap<String, JsonDeserializer<Object>>(16, 0.75f, 2);\n        _defaultImpl = defaultImpl;\n        _property = null;\n    }\n\n    protected TypeDeserializerBase(TypeDeserializerBase src, BeanProperty property) {\n        _baseType = src._baseType;\n        _idResolver = src._idResolver;\n        _typePropertyName = src._typePropertyName;\n        _typeIdVisible = src._typeIdVisible;\n        _deserializers = src._deserializers;\n        _defaultImpl = src._defaultImpl;\n        _defaultImplDeserializer = src._defaultImplDeserializer;\n        _property = property;\n    }\n\n    @Override\n    public abstract TypeDeserializer forProperty(BeanProperty prop); @Override public abstract JsonTypeInfo.As getTypeInclusion(); public String baseTypeName() { return _baseType.getRawClass().getName(); }\n\n    @Override\n    public final String getPropertyName() { return _typePropertyName; }\n    \n    @Override    \n    public TypeIdResolver getTypeIdResolver() { return _idResolver; }\n\n    @Override    \n    public Class<?> getDefaultImpl() {\n        return ClassUtil.rawClass(_defaultImpl);\n    }\n\n    \n    public JavaType baseType() {\n        return _baseType;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append('[').append(getClass().getName());\n        sb.append(\"; base-type:\").append(_baseType);\n        sb.append(\"; id-resolver: \").append(_idResolver);\n    \t    sb.append(']');\n    \t    return sb.toString();\n    }\n    \n    \n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n        JsonDeserializer<Object> deser = _deserializers.get(typeId);\n        if (deser == null) {\n            \n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                \n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    \n                    JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                    if (actual == null) { \n                        \n                        return NullifyingDeserializer.instance;\n                    }\n                    \n                    deser = ctxt.findContextualValueDeserializer(actual, _property);\n                }\n            } else {\n                \n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n                    \n                    \n                    \n                    \n                    \n                    if (!type.hasGenericTypes()) {\n                        type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                    }\n                }\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            }\n            _deserializers.put(typeId, deser);\n        }\n        return deser;\n    }\n\n    protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException {\n        \n        if (_defaultImpl == null) {\n            if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) {\n                return NullifyingDeserializer.instance;\n            }\n            return null;\n        }\n        Class<?> raw = _defaultImpl.getRawClass();\n        if (ClassUtil.isBogusClass(raw)) {\n            return NullifyingDeserializer.instance;\n        }\n        \n        synchronized (_defaultImpl) {\n            if (_defaultImplDeserializer == null) {\n                _defaultImplDeserializer = ctxt.findContextualValueDeserializer(\n                        _defaultImpl, _property);\n            }\n            return _defaultImplDeserializer;\n        }\n    }\n\n    \n    @Deprecated\n    protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        return _deserializeWithNativeTypeId(jp, ctxt, jp.getTypeId());\n    }\n\n    \n    protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt, Object typeId) throws IOException {\n        JsonDeserializer<Object> deser;\n        if (typeId == null) {\n            \n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                return ctxt.reportInputMismatch(baseType(),\n                        \"No (native) type id found when one was expected for polymorphic type handling\"); } } else { String typeIdStr = (typeId instanceof String) ? (String) typeId : String.valueOf(typeId); deser = _findDeserializer(ctxt, typeIdStr); } return deser.deserialize(jp, ctxt); } protected JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId) throws IOException { String extraDesc = _idResolver.getDescForKnownTypeIds(); if (extraDesc == null) { extraDesc = \"type ids are not statically known\"; } else { extraDesc = \"known type ids = \" + extraDesc; } if (_property != null) { extraDesc = String.format(\"%s (for POJO property '%s')\", extraDesc, _property.getName()); } return ctxt.handleUnknownTypeId(_baseType, typeId, _idResolver, extraDesc); } protected JavaType _handleMissingTypeId(DeserializationContext ctxt, String extraDesc) throws IOException {\n        return ctxt.handleMissingTypeId(_baseType, _idResolver, extraDesc);\n    }\n}\n",
      "buggy_signatures": [
        "protected TypeDeserializerBase(TypeDeserializerBase src, BeanProperty property)",
        "public abstract TypeDeserializer forProperty(BeanProperty prop); @Override public abstract JsonTypeInfo.As getTypeInclusion(); public String baseTypeName()",
        "public final String getPropertyName()",
        "public TypeIdResolver getTypeIdResolver()",
        "public Class<?> getDefaultImpl()",
        "public JavaType baseType()",
        "public String toString()",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException",
        "protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException",
        "synchronized (_defaultImpl)",
        "protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt, Object typeId) throws IOException"
      ],
      "fixed_signatures": [
        "protected TypeDeserializerBase(TypeDeserializerBase src, BeanProperty property)",
        "public abstract TypeDeserializer forProperty(BeanProperty prop); @Override public abstract JsonTypeInfo.As getTypeInclusion(); public String baseTypeName()",
        "public final String getPropertyName()",
        "public TypeIdResolver getTypeIdResolver()",
        "public Class<?> getDefaultImpl()",
        "public JavaType baseType()",
        "public String toString()",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException",
        "protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException",
        "synchronized (_defaultImpl)",
        "protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException",
        "protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt, Object typeId) throws IOException"
      ],
      "methods": [
        {
          "buggy_method": "  protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n  JsonDeserializer<Object> deser = _deserializers.get(typeId);\n  if (deser == null) {\n  \n  JavaType type = _idResolver.typeFromId(ctxt, typeId);\n  if (type == null) {\n  \n  deser = _findDefaultImplDeserializer(ctxt);\n  if (deser == null) {\n  \n  JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n  if (actual == null) { \n  \n  return null;\n  }\n  \n  deser = ctxt.findContextualValueDeserializer(actual, _property);\n  }\n  } else {\n  \n  if ((_baseType != null)\n  && _baseType.getClass() == type.getClass()) {\n  \n  \n  \n  \n  \n  if (!type.hasGenericTypes()) {\n  type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n  }\n  }\n  deser = ctxt.findContextualValueDeserializer(type, _property);\n  }\n  _deserializers.put(typeId, deser);\n  }\n  return deser;\n  }",
          "fixed_method": "  protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n  JsonDeserializer<Object> deser = _deserializers.get(typeId);\n  if (deser == null) {\n  \n  JavaType type = _idResolver.typeFromId(ctxt, typeId);\n  if (type == null) {\n  \n  deser = _findDefaultImplDeserializer(ctxt);\n  if (deser == null) {\n  \n  JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n  if (actual == null) { \n  \n  return NullifyingDeserializer.instance;\n  }\n  \n  deser = ctxt.findContextualValueDeserializer(actual, _property);\n  }\n  } else {\n  \n  if ((_baseType != null)\n  && _baseType.getClass() == type.getClass()) {\n  \n  \n  \n  \n  \n  if (!type.hasGenericTypes()) {\n  type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n  }\n  }\n  deser = ctxt.findContextualValueDeserializer(type, _property);\n  }\n  _deserializers.put(typeId, deser);\n  }\n  return deser;\n  }",
          "diff": [
            "@@ -162,7 +162,7 @@",
            "                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n",
            "                     if (actual == null) { // what should this be taken to mean?\n",
            "                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n",
            "-                        return null;\n",
            "+                        return NullifyingDeserializer.instance;\n",
            "                     }\n",
            "                     // ... would this actually work?\n",
            "                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
