{
  "bug_id": "81",
  "failed_tests": {
    "com.fasterxml.jackson.databind.introspect.TypeCoercion1592Test": [
      {
        "methodName": "testTypeCoercion1592",
        "error": "com.fasterxml.jackson.databind.exc.InvalidDefinitionException",
        "message": "Invalid definition for property \"i\" (of type com.fasterxml.jackson.databind.introspect.TypeCoercion1592Test$Bean1592): Can not refine serialization type [simple type, class int] into java.lang.Integer; types not related",
        "fail_line": "        MAPPER.writeValueAsString(new Bean1592());",
        "test_source": "  public void testTypeCoercion1592() throws Exception {\n  // first, serialize\n  MAPPER.writeValueAsString(new Bean1592());\n  Bean1592 result = MAPPER.readValue(\"{}\", Bean1592.class);\n  assertNotNull(result);\n  }",
        "stack": [
          "InvalidDefinitionException.from line 72, SerializerProvider.reportBadPropertyDefinition line 1185, PropertyBuilder.buildWriter line 103, BeanSerializerFactory._constructWriter line 881, BeanSerializerFactory.findBeanProperties line 675, BeanSerializerFactory.constructBeanSerializer line 456, BeanSerializerFactory.findBeanSerializer line 284, BeanSerializerFactory._createSerializer2 line 236, BeanSerializerFactory.createSerializer line 170, SerializerProvider._createUntypedSerializer line 1376, SerializerProvider._createAndCacheUntypedSerializer line 1327, SerializerProvider.findValueSerializer line 509, SerializerProvider.findTypedValueSerializer line 712, DefaultSerializerProvider.serializeValue line 308, ObjectMapper._configAndWriteValue line 3881, ObjectMapper.writeValueAsString line 3195, TypeCoercion1592Test.testTypeCoercion1592 line 31"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.introspect;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.*;\nimport com.fasterxml.jackson.core.Version;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.*;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.ext.Java7Support;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\nimport com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\nimport com.fasterxml.jackson.databind.ser.VirtualBeanPropertyWriter;\nimport com.fasterxml.jackson.databind.ser.impl.AttributePropertyWriter;\nimport com.fasterxml.jackson.databind.ser.std.RawSerializer;\nimport com.fasterxml.jackson.databind.type.MapLikeType;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.*;\n\n\npublic class JacksonAnnotationIntrospector extends AnnotationIntrospector implements java.io.Serializable { private static final long serialVersionUID = 1L; @SuppressWarnings(\"unchecked\") private final static Class<? extends Annotation>[] ANNOTATIONS_TO_INFER_SER = (Class<? extends Annotation>[]) new Class<?>[] {\n        JsonSerialize.class,\n        JsonView.class,\n        JsonFormat.class,\n        JsonTypeInfo.class,\n        JsonRawValue.class,\n        JsonUnwrapped.class,\n        JsonBackReference.class,\n        JsonManagedReference.class\n    };\n\n    @SuppressWarnings(\"unchecked\")\n    private final static Class<? extends Annotation>[] ANNOTATIONS_TO_INFER_DESER = (Class<? extends Annotation>[]) new Class<?>[] {\n        JsonDeserialize.class,\n        JsonView.class,\n        JsonFormat.class,\n        JsonTypeInfo.class,\n        JsonUnwrapped.class,\n        JsonBackReference.class,\n        JsonManagedReference.class,\n        JsonMerge.class \n    };\n\n    \n    \n    private static final Java7Support _java7Helper; static { Java7Support x = null; try { x = Java7Support.instance(); } catch (Throwable t) { }\n        _java7Helper = x;\n    }\n    \n    \n    protected transient LRUMap<Class<?>,Boolean> _annotationsInside = new LRUMap<Class<?>,Boolean>(48, 48); protected boolean _cfgConstructorPropertiesImpliesCreator = true; public JacksonAnnotationIntrospector() { }\n\n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    protected Object readResolve() {\n        if (_annotationsInside == null) {\n            _annotationsInside = new LRUMap<Class<?>,Boolean>(48, 48);\n        }\n        return this;\n    }\n\n    \n\n    \n    public JacksonAnnotationIntrospector setConstructorPropertiesImpliesCreator(boolean b) {\n        _cfgConstructorPropertiesImpliesCreator = b;\n        return this;\n    }\n    \n    \n\n    \n    @Override\n    public boolean isAnnotationBundle(Annotation ann) {\n        \n        \n        \n        \n        Class<?> type = ann.annotationType();\n        Boolean b = _annotationsInside.get(type);\n        if (b == null) {\n            b = type.getAnnotation(JacksonAnnotationsInside.class) != null;\n            _annotationsInside.putIfAbsent(type, b);\n        }\n        return b.booleanValue();\n    }\n\n    \n\n    \n    @Override\n    @Deprecated \n    public String findEnumValue(Enum<?> value) {\n        \n        \n        \n        try {\n            \n            Field f = value.getClass().getField(value.name());\n            if (f != null) {\n                JsonProperty prop = f.getAnnotation(JsonProperty.class);\n                if (prop != null) {\n                    String n = prop.value();\n                    if (n != null && !n.isEmpty()) {\n                        return n;\n                    }\n                }\n            }\n        } catch (SecurityException e) {\n            \n        } catch (NoSuchFieldException e) {\n            \n        }\n        return value.name();\n    }\n\n    @Override \n    public String[] findEnumValues(Class<?> enumType, Enum<?>[] enumValues, String[] names) {\n        HashMap<String,String> expl = null;\n        for (Field f : ClassUtil.getDeclaredFields(enumType)) {\n            if (!f.isEnumConstant()) {\n                continue;\n            }\n            JsonProperty prop = f.getAnnotation(JsonProperty.class);\n            if (prop == null) {\n                continue;\n            }\n            String n = prop.value();\n            if (n.isEmpty()) {\n                continue;\n            }\n            if (expl == null) {\n                expl = new HashMap<String,String>();\n            }\n            expl.put(f.getName(), n);\n        }\n        \n        if (expl != null) {\n            for (int i = 0, end = enumValues.length; i < end; ++i) {\n                String defName = enumValues[i].name();\n                String explValue = expl.get(defName);\n                if (explValue != null) {\n                    names[i] = explValue;\n                }\n            }\n        }\n        return names;\n    }\n\n    \n    @Override\n    public Enum<?> findDefaultEnumValue(Class<Enum<?>> enumCls) {\n        return ClassUtil.findFirstAnnotatedEnumValue(enumCls, JsonEnumDefaultValue.class);\n    }\n\n    \n\n    @Override\n    public PropertyName findRootName(AnnotatedClass ac) {\n        JsonRootName ann = _findAnnotation(ac, JsonRootName.class);\n        if (ann == null) {\n            return null;\n        }\n        String ns = ann.namespace();\n        if (ns != null && ns.length() == 0) {\n            ns = null;\n        }\n        return PropertyName.construct(ann.value(), ns);\n    }\n\n    @Override \n    public JsonIgnoreProperties.Value findPropertyIgnorals(Annotated a) {\n        JsonIgnoreProperties v = _findAnnotation(a, JsonIgnoreProperties.class);\n        if (v == null) {\n            return JsonIgnoreProperties.Value.empty();\n        }\n        return JsonIgnoreProperties.Value.from(v);\n    }\n\n    @Override\n    public Boolean isIgnorableType(AnnotatedClass ac) {\n        JsonIgnoreType ignore = _findAnnotation(ac, JsonIgnoreType.class);\n        return (ignore == null) ? null : ignore.value();\n    }\n \n    @Override\n    public Object findFilterId(Annotated a) {\n        JsonFilter ann = _findAnnotation(a, JsonFilter.class);\n        if (ann != null) {\n            String id = ann.value();\n            \n            if (id.length() > 0) {\n                return id;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findNamingStrategy(AnnotatedClass ac) {\n        JsonNaming ann = _findAnnotation(ac, JsonNaming.class);\n        return (ann == null) ? null : ann.value();\n    }\n\n    @Override\n    public String findClassDescription(AnnotatedClass ac) {\n        JsonClassDescription ann = _findAnnotation(ac, JsonClassDescription.class);\n        return (ann == null) ? null : ann.value();\n    }\n\n    \n\n    @Override\n    public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) {\n        JsonAutoDetect ann = _findAnnotation(ac, JsonAutoDetect.class);\n        return (ann == null) ? checker : checker.with(ann);\n    }\n\n    \n\n    @Override\n    public String findImplicitPropertyName(AnnotatedMember m) {\n        PropertyName n = _findConstructorName(m);\n        return (n == null) ? null : n.getSimpleName();\n    }\n\n    @Override\n    public List<PropertyName> findPropertyAliases(Annotated m) {\n        JsonAlias ann = _findAnnotation(m, JsonAlias.class);\n        if (ann == null) {\n            return null;\n        }\n        String[] strs = ann.value();\n        final int len = strs.length;\n        if (len == 0) {\n            return Collections.emptyList();\n        }\n        List<PropertyName> result = new ArrayList<>(len);\n        for (int i = 0; i < len; ++i) {\n            result.add(PropertyName.construct(strs[i]));\n        }\n        return result;\n    }\n\n    @Override\n    public boolean hasIgnoreMarker(AnnotatedMember m) {\n        return _isIgnorable(m);\n    }\n\n    @Override\n    public Boolean hasRequiredMarker(AnnotatedMember m) {\n        JsonProperty ann = _findAnnotation(m, JsonProperty.class);\n        if (ann != null) {\n            return ann.required();\n        }\n        return null;\n    }\n\n    @Override\n    public JsonProperty.Access findPropertyAccess(Annotated m) {\n        JsonProperty ann = _findAnnotation(m, JsonProperty.class);\n        if (ann != null) {\n            return ann.access();\n        }\n        return null;\n    }\n\n    @Override\n    public String findPropertyDescription(Annotated ann) {\n        JsonPropertyDescription desc = _findAnnotation(ann, JsonPropertyDescription.class);\n        return (desc == null) ? null : desc.value();\n    }\n\n    @Override\n    public Integer findPropertyIndex(Annotated ann) {\n        JsonProperty prop = _findAnnotation(ann, JsonProperty.class);\n        if (prop != null) {\n          int ix = prop.index();\n          if (ix != JsonProperty.INDEX_UNKNOWN) {\n               return Integer.valueOf(ix);\n          }\n        }\n        return null;\n    }\n    \n    @Override\n    public String findPropertyDefaultValue(Annotated ann) {\n        JsonProperty prop = _findAnnotation(ann, JsonProperty.class);\n        if (prop == null) {\n            return null;\n        }\n        String str = prop.defaultValue();\n        \n        return str.isEmpty() ? null : str;\n    }\n    \n    @Override\n    public JsonFormat.Value findFormat(Annotated ann) {\n        JsonFormat f = _findAnnotation(ann, JsonFormat.class);\n        return (f == null)  ? null : new JsonFormat.Value(f);\n    }\n\n    @Override        \n    public ReferenceProperty findReferenceType(AnnotatedMember member) {\n        JsonManagedReference ref1 = _findAnnotation(member, JsonManagedReference.class);\n        if (ref1 != null) {\n            return AnnotationIntrospector.ReferenceProperty.managed(ref1.value());\n        }\n        JsonBackReference ref2 = _findAnnotation(member, JsonBackReference.class);\n        if (ref2 != null) {\n            return AnnotationIntrospector.ReferenceProperty.back(ref2.value());\n        }\n        return null;\n    }\n\n    @Override\n    public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member) {\n        JsonUnwrapped ann = _findAnnotation(member, JsonUnwrapped.class);\n        \n        \n        if (ann == null || !ann.enabled()) {\n            return null;\n        }\n        String prefix = ann.prefix();\n        String suffix = ann.suffix();\n        return NameTransformer.simpleTransformer(prefix, suffix);\n    }\n\n    @Override \n    public JacksonInject.Value findInjectableValue(AnnotatedMember m) {\n        JacksonInject ann = _findAnnotation(m, JacksonInject.class);\n        if (ann == null) {\n            return null;\n        }\n        \n        JacksonInject.Value v = JacksonInject.Value.from(ann);\n        if (!v.hasId()) {\n            Object id;\n            \n            if (!(m instanceof AnnotatedMethod)) {\n                id = m.getRawType().getName();\n            } else {\n                AnnotatedMethod am = (AnnotatedMethod) m;\n                if (am.getParameterCount() == 0) { \n                    id = m.getRawType().getName();\n                } else { \n                    id = am.getRawParameterType(0).getName();\n                }\n            }\n            v = v.withId(id);\n        }\n        return v;\n    }\n\n    @Override\n    @Deprecated \n    public Object findInjectableValueId(AnnotatedMember m) {\n        JacksonInject.Value v = findInjectableValue(m);\n        return (v == null) ? null : v.getId();\n    }\n\n    @Override\n    public Class<?>[] findViews(Annotated a) {\n        JsonView ann = _findAnnotation(a, JsonView.class);\n        return (ann == null) ? null : ann.value();\n    }\n\n    @Override \n    public AnnotatedMethod resolveSetterConflict(MapperConfig<?> config, AnnotatedMethod setter1, AnnotatedMethod setter2) {\n        Class<?> cls1 = setter1.getRawParameterType(0);\n        Class<?> cls2 = setter2.getRawParameterType(0);\n        \n        \n        \n        if (cls1.isPrimitive()) {\n            if (!cls2.isPrimitive()) {\n                return setter1;\n            }\n        } else if (cls2.isPrimitive()) {\n            return setter2;\n        }\n        \n        if (cls1 == String.class) {\n            if (cls2 != String.class) {\n                return setter1;\n            }\n        } else if (cls2 == String.class) {\n            return setter2;\n        }\n\n        return null;\n    }\n\n    \n\n    @Override\n    public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config, AnnotatedClass ac, JavaType baseType) {\n        return _findTypeResolver(config, ac, baseType);\n    }\n\n    @Override\n    public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType baseType) {\n        \n        \n        if (baseType.isContainerType() || baseType.isReferenceType()) {\n            return null;\n        }\n        \n        return _findTypeResolver(config, am, baseType);\n    }\n\n    @Override\n    public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType containerType) {\n        \n        if (containerType.getContentType() == null) {\n            throw new IllegalArgumentException(\"Must call method with a container or reference type (got \"+containerType+\")\");\n        }\n        return _findTypeResolver(config, am, containerType);\n    }\n    \n    @Override\n    public List<NamedType> findSubtypes(Annotated a) {\n        JsonSubTypes t = _findAnnotation(a, JsonSubTypes.class);\n        if (t == null) return null;\n        JsonSubTypes.Type[] types = t.value();\n        ArrayList<NamedType> result = new ArrayList<NamedType>(types.length);\n        for (JsonSubTypes.Type type : types) {\n            result.add(new NamedType(type.value(), type.name()));\n        }\n        return result;\n    }\n\n    @Override        \n    public String findTypeName(AnnotatedClass ac) {\n        JsonTypeName tn = _findAnnotation(ac, JsonTypeName.class);\n        return (tn == null) ? null : tn.value();\n    }\n\n    @Override\n    public Boolean isTypeId(AnnotatedMember member) {\n        return _hasAnnotation(member, JsonTypeId.class);\n    }\n\n    \n\n    @Override\n    public ObjectIdInfo findObjectIdInfo(Annotated ann) {\n        JsonIdentityInfo info = _findAnnotation(ann, JsonIdentityInfo.class);\n        if (info == null || info.generator() == ObjectIdGenerators.None.class) {\n            return null;\n        }\n        \n        PropertyName name = PropertyName.construct(info.property());\n        return new ObjectIdInfo(name, info.scope(), info.generator(), info.resolver());\n    }\n\n    @Override\n    public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n        JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class);\n        if (ref == null) {\n            return objectIdInfo;\n        }\n        if (objectIdInfo == null) {\n            objectIdInfo = ObjectIdInfo.empty();\n        }\n        return objectIdInfo.withAlwaysAsId(ref.alwaysAsId());\n    }\n\n    \n\n    @Override\n    public Object findSerializer(Annotated a) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.using();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        \n        \n        JsonRawValue annRaw =  _findAnnotation(a, JsonRawValue.class);\n        if ((annRaw != null) && annRaw.value()) {\n            \n            Class<?> cls = a.getRawType();\n            return new RawSerializer<Object>(cls);\n        }       \n        return null;\n    }\n\n    @Override\n    public Object findKeySerializer(Annotated a) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.keyUsing();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findContentSerializer(Annotated a) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.contentUsing();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findNullSerializer(Annotated a) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.nullsUsing();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public JsonInclude.Value findPropertyInclusion(Annotated a) {\n        JsonInclude inc = _findAnnotation(a, JsonInclude.class);\n        JsonInclude.Value value = (inc == null) ? JsonInclude.Value.empty() : JsonInclude.Value.from(inc);\n\n        \n        if (value.getValueInclusion() == JsonInclude.Include.USE_DEFAULTS) {\n            value = _refinePropertyInclusion(a, value);\n        }\n        return value;\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private JsonInclude.Value _refinePropertyInclusion(Annotated a, JsonInclude.Value value) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            switch (ann.include()) {\n            case ALWAYS:\n                return value.withValueInclusion(JsonInclude.Include.ALWAYS);\n            case NON_NULL:\n                return value.withValueInclusion(JsonInclude.Include.NON_NULL);\n            case NON_DEFAULT:\n                return value.withValueInclusion(JsonInclude.Include.NON_DEFAULT);\n            case NON_EMPTY:\n                return value.withValueInclusion(JsonInclude.Include.NON_EMPTY);\n            case DEFAULT_INCLUSION:\n            default:\n            }\n        }\n        return value;\n    }\n\n    @Override\n    public JsonSerialize.Typing findSerializationTyping(Annotated a) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        return (ann == null) ? null : ann.typing();\n    }\n\n    @Override\n    public Object findSerializationConverter(Annotated a) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.converter(), Converter.None.class);\n    }\n\n    @Override\n    public Object findSerializationContentConverter(AnnotatedMember a) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentConverter(), Converter.None.class);\n    }\n\n    \n    \n    @Override\n    public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n        JavaType type = baseType;\n        final TypeFactory tf = config.getTypeFactory();\n\n        final JsonSerialize jsonSer = _findAnnotation(a, JsonSerialize.class);\n        \n        \n\n        final Class<?> serClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.as());\n        if (serClass != null) {\n            if (type.hasRawClass(serClass)) {\n                \n                \n                type = type.withStaticTyping();\n            } else {\n                Class<?> currRaw = type.getRawClass();\n                try {\n                    \n                    \n                    if (serClass.isAssignableFrom(currRaw)) { \n                        type = tf.constructGeneralizedType(type, serClass);\n                    } else if (currRaw.isAssignableFrom(serClass)) { \n                        type = tf.constructSpecializedType(type, serClass);\n                        \n                    } else {\n                        throw new JsonMappingException(null,\n                                String.format(\"Can not refine serialization type %s into %s; types not related\",\n                                        type, serClass.getName()));\n                    }\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null,\n                            String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\",\n                                    type, serClass.getName(), a.getName(), iae.getMessage()),\n                                    iae);\n                }\n            }\n        }\n        \n\n        \n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            final Class<?> keyClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.keyAs());\n            if (keyClass != null) {\n                if (keyType.hasRawClass(keyClass)) {\n                    keyType = keyType.withStaticTyping();\n                } else {\n                    Class<?> currRaw = keyType.getRawClass();\n                    try {\n                        \n                        \n                        \n                        if (keyClass.isAssignableFrom(currRaw)) { \n                            keyType = tf.constructGeneralizedType(keyType, keyClass);\n                        } else if (currRaw.isAssignableFrom(keyClass)) { \n                            keyType = tf.constructSpecializedType(keyType, keyClass);\n                            \n                        } else {\n                            throw new JsonMappingException(null,\n                                    String.format(\"Can not refine serialization key type %s into %s; types not related\",\n                                            keyType, keyClass.getName()));\n                        }\n                    } catch (IllegalArgumentException iae) {\n                        throw new JsonMappingException(null,\n                                String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                        type, keyClass.getName(), a.getName(), iae.getMessage()),\n                                        iae);\n                    }\n                }\n                type = ((MapLikeType) type).withKeyType(keyType);\n            }\n        }\n\n        JavaType contentType = type.getContentType();\n        if (contentType != null) { \n            \n           final Class<?> contentClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.contentAs());\n           if (contentClass != null) {\n               if (contentType.hasRawClass(contentClass)) {\n                   contentType = contentType.withStaticTyping();\n               } else {\n                   \n                   \n                   \n                   Class<?> currRaw = contentType.getRawClass();\n                   try {\n                       if (contentClass.isAssignableFrom(currRaw)) { \n                           contentType = tf.constructGeneralizedType(contentType, contentClass);\n                       } else if (currRaw.isAssignableFrom(contentClass)) { \n                           contentType = tf.constructSpecializedType(contentType, contentClass);\n                           \n                       } else {\n                           throw new JsonMappingException(null,\n                                   String.format(\"Can not refine serialization content type %s into %s; types not related\",\n                                           contentType, contentClass.getName()));\n                       }\n                   } catch (IllegalArgumentException iae) { \n                       throw new JsonMappingException(null,\n                               String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                       type, contentClass.getName(), a.getName(), iae.getMessage()),\n                                       iae);\n                   }\n               }\n               type = type.withContentType(contentType);\n           }\n        }\n        return type;\n    }\n\n    @Override\n    @Deprecated \n    public Class<?> findSerializationType(Annotated am) {\n        return null;\n    }\n\n    @Override\n    @Deprecated \n    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) {\n        return null;\n    }\n\n    @Override\n    @Deprecated \n    public Class<?> findSerializationContentType(Annotated am, JavaType baseType) {\n        return null;\n    }\n\n    \n\n    @Override\n    public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n        JsonPropertyOrder order = _findAnnotation(ac, JsonPropertyOrder.class);\n        return (order == null) ? null : order.value();\n    }\n\n    @Override\n    public Boolean findSerializationSortAlphabetically(Annotated ann) {\n        return _findSortAlpha(ann);\n    }\n\n    private final Boolean _findSortAlpha(Annotated ann) {\n        JsonPropertyOrder order = _findAnnotation(ann, JsonPropertyOrder.class);\n        \n        \n        if ((order != null) && order.alphabetic()) {\n            return Boolean.TRUE;\n        }\n        return null;\n    }\n\n    @Override\n    public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac, List<BeanPropertyWriter> properties) {\n        JsonAppend ann = _findAnnotation(ac, JsonAppend.class);\n        if (ann == null) {\n            return;\n        }\n        final boolean prepend = ann.prepend();\n        JavaType propType = null;\n\n        \n        JsonAppend.Attr[] attrs = ann.attrs();\n        for (int i = 0, len = attrs.length; i < len; ++i) {\n            if (propType == null) {\n                propType = config.constructType(Object.class);\n            }\n            BeanPropertyWriter bpw = _constructVirtualProperty(attrs[i],\n                    config, ac, propType);\n            if (prepend) {\n                properties.add(i, bpw);\n            } else {\n                properties.add(bpw);\n            }\n        }\n\n        \n        JsonAppend.Prop[] props = ann.props();\n        for (int i = 0, len = props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _constructVirtualProperty(props[i],\n                    config, ac);\n            if (prepend) {\n                properties.add(i, bpw);\n            } else {\n                properties.add(bpw);\n            }\n        }\n    }\n\n    protected BeanPropertyWriter _constructVirtualProperty(JsonAppend.Attr attr, MapperConfig<?> config, AnnotatedClass ac, JavaType type) {\n        PropertyMetadata metadata = attr.required() ?\n                    PropertyMetadata.STD_REQUIRED : PropertyMetadata.STD_OPTIONAL;\n        \n        String attrName = attr.value();\n\n        \n        PropertyName propName = _propertyName(attr.propName(), attr.propNamespace());\n        if (!propName.hasSimpleName()) {\n            propName = PropertyName.construct(attrName);\n        }\n        \n        AnnotatedMember member = new VirtualAnnotatedMember(ac, ac.getRawType(),\n                attrName, type);\n        \n        SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(config,\n                member, propName, metadata, attr.include());\n        \n        return AttributePropertyWriter.construct(attrName, propDef,\n                ac.getAnnotations(), type);\n    }\n\n    protected BeanPropertyWriter _constructVirtualProperty(JsonAppend.Prop prop, MapperConfig<?> config, AnnotatedClass ac) {\n        PropertyMetadata metadata = prop.required() ?\n                    PropertyMetadata.STD_REQUIRED : PropertyMetadata.STD_OPTIONAL;\n        PropertyName propName = _propertyName(prop.name(), prop.namespace());\n        JavaType type = config.constructType(prop.type());\n        \n        AnnotatedMember member = new VirtualAnnotatedMember(ac, ac.getRawType(),\n                propName.getSimpleName(), type);\n        \n        SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(config,\n                member, propName, metadata, prop.include());\n\n        Class<?> implClass = prop.value();\n\n        HandlerInstantiator hi = config.getHandlerInstantiator();\n        VirtualBeanPropertyWriter bpw = (hi == null) ? null\n                : hi.virtualPropertyWriterInstance(config, implClass);\n        if (bpw == null) {\n            bpw = (VirtualBeanPropertyWriter) ClassUtil.createInstance(implClass,\n                    config.canOverrideAccessModifiers());\n        }\n\n        \n        return bpw.withConfig(config, ac, propDef, type);\n    }\n\n    \n\n    @Override\n    public PropertyName findNameForSerialization(Annotated a) {\n        JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n        if (jg != null) {\n            return PropertyName.construct(jg.value());\n        }\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann != null) {\n            return PropertyName.construct(pann.value());\n        }\n        if (_hasOneOf(a, ANNOTATIONS_TO_INFER_SER)) {\n            return PropertyName.USE_DEFAULT;\n        }\n        return null;\n    }\n\n    @Override \n    public Boolean hasAsValue(Annotated a) {\n        JsonValue ann = _findAnnotation(a, JsonValue.class);\n        if (ann == null) {\n            return null;\n        }\n        return ann.value();\n    }\n\n    @Override \n    public Boolean hasAnyGetter(Annotated a) {\n        JsonAnyGetter ann = _findAnnotation(a, JsonAnyGetter.class);\n        if (ann == null) {\n            return null;\n        }\n        return ann.enabled();\n    }\n\n    @Override\n    @Deprecated \n    public boolean hasAnyGetterAnnotation(AnnotatedMethod am) {\n        \n        return _hasAnnotation(am, JsonAnyGetter.class);\n    }\n\n    @Override\n    @Deprecated \n    public boolean hasAsValueAnnotation(AnnotatedMethod am) {\n        JsonValue ann = _findAnnotation(am, JsonValue.class);\n        \n        return (ann != null) && ann.value();\n    }\n\n    \n\n    @Override\n    public Object findDeserializer(Annotated a) {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonDeserializer> deserClass = ann.using();\n            if (deserClass != JsonDeserializer.None.class) {\n                return deserClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findKeyDeserializer(Annotated a) {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        if (ann != null) {\n            Class<? extends KeyDeserializer> deserClass = ann.keyUsing();\n            if (deserClass != KeyDeserializer.None.class) {\n                return deserClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findContentDeserializer(Annotated a) {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonDeserializer> deserClass = ann.contentUsing();\n            if (deserClass != JsonDeserializer.None.class) {\n                return deserClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findDeserializationConverter(Annotated a) {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.converter(), Converter.None.class);\n    }\n\n    @Override\n    public Object findDeserializationContentConverter(AnnotatedMember a) {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentConverter(), Converter.None.class);\n    }\n\n    \n\n    @Override\n    public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n        JavaType type = baseType;\n        final TypeFactory tf = config.getTypeFactory();\n\n        final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n        \n        \n        final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n        if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n            try {\n                type = tf.constructSpecializedType(type, valueClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null,\n                        String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\",\n                                type, valueClass.getName(), a.getName(), iae.getMessage()),\n                                iae);\n            }\n        }\n        \n\n        \n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n            if (keyClass != null) {\n                try {\n                    keyType = tf.constructSpecializedType(keyType, keyClass);\n                    type = ((MapLikeType) type).withKeyType(keyType);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null,\n                            String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                    type, keyClass.getName(), a.getName(), iae.getMessage()),\n                                    iae);\n                }\n            }\n        }\n        JavaType contentType = type.getContentType();\n        if (contentType != null) { \n            \n            final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n            if (contentClass != null) {\n                try {\n                    contentType = tf.constructSpecializedType(contentType, contentClass);\n                    type = type.withContentType(contentType);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null,\n                            String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                    type, contentClass.getName(), a.getName(), iae.getMessage()),\n                            iae);\n                }\n            }\n        }\n        return type;\n    }\n\n    @Override\n    @Deprecated \n    public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType) {\n        return null;\n    }\n\n    @Override\n    @Deprecated \n    public Class<?> findDeserializationType(Annotated am, JavaType baseType) {\n        return null;\n    }\n\n    @Override\n    @Deprecated \n    public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) {\n        return null;\n    }\n\n    \n\n    @Override\n    public Object findValueInstantiator(AnnotatedClass ac) {\n        JsonValueInstantiator ann = _findAnnotation(ac, JsonValueInstantiator.class);\n        \n        return (ann == null) ? null : ann.value();\n    }\n\n    @Override\n    public Class<?> findPOJOBuilder(AnnotatedClass ac) {\n        JsonDeserialize ann = _findAnnotation(ac, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.builder());\n    }\n\n    @Override\n    public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac) {\n        JsonPOJOBuilder ann = _findAnnotation(ac, JsonPOJOBuilder.class);\n        return (ann == null) ? null : new JsonPOJOBuilder.Value(ann);\n    }\n    \n    \n\n    @Override\n    public PropertyName findNameForDeserialization(Annotated a) {\n        \n        \n        JsonSetter js = _findAnnotation(a, JsonSetter.class);\n        if (js != null) {\n            return PropertyName.construct(js.value());\n        }\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann != null) {\n            return PropertyName.construct(pann.value());\n        }\n        if (_hasOneOf(a, ANNOTATIONS_TO_INFER_DESER)) {\n            return PropertyName.USE_DEFAULT;\n        }\n        return null;\n    }\n\n    @Override\n    public Boolean hasAnySetter(Annotated a) {\n        JsonAnySetter ann = _findAnnotation(a, JsonAnySetter.class);\n        return (ann == null) ? null : ann.enabled();\n    }\n\n    @Override\n    public JsonSetter.Value findSetterInfo(Annotated a) {\n        return JsonSetter.Value.from(_findAnnotation(a, JsonSetter.class));\n    }\n\n    @Override \n    public Boolean findMergeInfo(Annotated a) {\n        JsonMerge ann = _findAnnotation(a, JsonMerge.class);\n        return (ann == null) ? null : ann.value().asBoolean();\n    }\n\n    @Override\n    @Deprecated \n    public boolean hasAnySetterAnnotation(AnnotatedMethod am) {\n        return _hasAnnotation(am, JsonAnySetter.class);\n    }\n\n    @Override\n    @Deprecated \n    public boolean hasCreatorAnnotation(Annotated a) {\n        \n         JsonCreator ann = _findAnnotation(a, JsonCreator.class);\n         if (ann != null) {\n             return (ann.mode() != JsonCreator.Mode.DISABLED);\n         }\n         \n         \n         if (_cfgConstructorPropertiesImpliesCreator ) {\n             if (a instanceof AnnotatedConstructor) {\n                 if (_java7Helper != null) {\n                     Boolean b = _java7Helper.hasCreatorAnnotation(a);\n                     if (b != null) {\n                         return b.booleanValue();\n                     }\n                 }\n             }\n         }\n         return false;\n    }\n\n    @Override\n    @Deprecated \n    public JsonCreator.Mode findCreatorBinding(Annotated a) {\n        JsonCreator ann = _findAnnotation(a, JsonCreator.class);\n        return (ann == null) ? null : ann.mode();\n    }\n\n    @Override\n    public JsonCreator.Mode findCreatorAnnotation(MapperConfig<?> config, Annotated a) {\n        JsonCreator ann = _findAnnotation(a, JsonCreator.class);\n        if (ann != null) {\n            return ann.mode();\n        }\n\n        if (_cfgConstructorPropertiesImpliesCreator\n                && config.isEnabled(MapperFeature.INFER_CREATOR_FROM_CONSTRUCTOR_PROPERTIES)\n            ) {\n            if (a instanceof AnnotatedConstructor) {\n                if (_java7Helper != null) {\n                    Boolean b = _java7Helper.hasCreatorAnnotation(a);\n                    if ((b != null) && b.booleanValue()) {\n                        \n                        \n                        return JsonCreator.Mode.PROPERTIES;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    \n\n    protected boolean _isIgnorable(Annotated a) {\n        JsonIgnore ann = _findAnnotation(a, JsonIgnore.class);\n        if (ann != null) {\n            return ann.value();\n        }\n        if (_java7Helper != null) {\n            Boolean b = _java7Helper.findTransient(a);\n            if (b != null) {\n                return b.booleanValue();\n            }\n        }\n        return false;\n    }\n\n    protected Class<?> _classIfExplicit(Class<?> cls) {\n        if (cls == null || ClassUtil.isBogusClass(cls)) {\n            return null;\n        }\n        return cls;\n    }\n\n    protected Class<?> _classIfExplicit(Class<?> cls, Class<?> implicit) {\n        cls = _classIfExplicit(cls);\n        return (cls == null || cls == implicit) ? null : cls;\n    }\n\n    protected PropertyName _propertyName(String localName, String namespace) {\n        if (localName.isEmpty()) {\n            return PropertyName.USE_DEFAULT;\n        }\n        if (namespace == null || namespace.isEmpty()) {\n            return PropertyName.construct(localName);\n        }\n        return PropertyName.construct(localName, namespace);\n    }\n\n    protected PropertyName _findConstructorName(Annotated a) {\n        if (a instanceof AnnotatedParameter) {\n            AnnotatedParameter p = (AnnotatedParameter) a;\n            AnnotatedWithParams ctor = p.getOwner();\n\n            if (ctor != null) {\n                if (_java7Helper != null) {\n                    PropertyName name = _java7Helper.findConstructorName(p);\n                    if (name != null) {\n                        return name;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    \n    @SuppressWarnings(\"deprecation\")\n    protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config, Annotated ann, JavaType baseType) {\n        \n        TypeResolverBuilder<?> b;\n        JsonTypeInfo info = _findAnnotation(ann, JsonTypeInfo.class);\n        JsonTypeResolver resAnn = _findAnnotation(ann, JsonTypeResolver.class);\n        \n        if (resAnn != null) {\n            if (info == null) {\n                return null;\n            }\n            \n            b = config.typeResolverBuilderInstance(ann, resAnn.value());\n        } else { \n            if (info == null) {\n                return null;\n            }\n            \n            if (info.use() == JsonTypeInfo.Id.NONE) {\n                return _constructNoTypeResolverBuilder();\n            }\n            b = _constructStdTypeResolverBuilder();\n        }\n        \n        JsonTypeIdResolver idResInfo = _findAnnotation(ann, JsonTypeIdResolver.class);\n        TypeIdResolver idRes = (idResInfo == null) ? null\n                : config.typeIdResolverInstance(ann, idResInfo.value());\n        if (idRes != null) {\n            idRes.init(baseType);\n        }\n        b = b.init(info.use(), idRes);\n        \n        JsonTypeInfo.As inclusion = info.include();\n        if (inclusion == JsonTypeInfo.As.EXTERNAL_PROPERTY && (ann instanceof AnnotatedClass)) {\n            inclusion = JsonTypeInfo.As.PROPERTY;\n        }\n        b = b.inclusion(inclusion);\n        b = b.typeProperty(info.property());\n        Class<?> defaultImpl = info.defaultImpl();\n\n        \n        \n        \n        \n        if (defaultImpl != JsonTypeInfo.None.class && !defaultImpl.isAnnotation()) {\n            b = b.defaultImpl(defaultImpl);\n        }\n        b = b.typeIdVisibility(info.visible());\n        return b;\n    }\n\n    \n    protected StdTypeResolverBuilder _constructStdTypeResolverBuilder() {\n        return new StdTypeResolverBuilder();\n    }\n\n    \n    protected StdTypeResolverBuilder _constructNoTypeResolverBuilder() {\n        return StdTypeResolverBuilder.noTypeInfoBuilder();\n    }\n\n\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.introspect;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.*;\nimport com.fasterxml.jackson.core.Version;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.*;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.ext.Java7Support;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\nimport com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\nimport com.fasterxml.jackson.databind.ser.VirtualBeanPropertyWriter;\nimport com.fasterxml.jackson.databind.ser.impl.AttributePropertyWriter;\nimport com.fasterxml.jackson.databind.ser.std.RawSerializer;\nimport com.fasterxml.jackson.databind.type.MapLikeType;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.*;\n\n\npublic class JacksonAnnotationIntrospector extends AnnotationIntrospector implements java.io.Serializable { private static final long serialVersionUID = 1L; @SuppressWarnings(\"unchecked\") private final static Class<? extends Annotation>[] ANNOTATIONS_TO_INFER_SER = (Class<? extends Annotation>[]) new Class<?>[] {\n        JsonSerialize.class,\n        JsonView.class,\n        JsonFormat.class,\n        JsonTypeInfo.class,\n        JsonRawValue.class,\n        JsonUnwrapped.class,\n        JsonBackReference.class,\n        JsonManagedReference.class\n    };\n\n    @SuppressWarnings(\"unchecked\")\n    private final static Class<? extends Annotation>[] ANNOTATIONS_TO_INFER_DESER = (Class<? extends Annotation>[]) new Class<?>[] {\n        JsonDeserialize.class,\n        JsonView.class,\n        JsonFormat.class,\n        JsonTypeInfo.class,\n        JsonUnwrapped.class,\n        JsonBackReference.class,\n        JsonManagedReference.class,\n        JsonMerge.class \n    };\n\n    \n    \n    private static final Java7Support _java7Helper; static { Java7Support x = null; try { x = Java7Support.instance(); } catch (Throwable t) { }\n        _java7Helper = x;\n    }\n    \n    \n    protected transient LRUMap<Class<?>,Boolean> _annotationsInside = new LRUMap<Class<?>,Boolean>(48, 48); protected boolean _cfgConstructorPropertiesImpliesCreator = true; public JacksonAnnotationIntrospector() { }\n\n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    protected Object readResolve() {\n        if (_annotationsInside == null) {\n            _annotationsInside = new LRUMap<Class<?>,Boolean>(48, 48);\n        }\n        return this;\n    }\n\n    \n\n    \n    public JacksonAnnotationIntrospector setConstructorPropertiesImpliesCreator(boolean b) {\n        _cfgConstructorPropertiesImpliesCreator = b;\n        return this;\n    }\n    \n    \n\n    \n    @Override\n    public boolean isAnnotationBundle(Annotation ann) {\n        \n        \n        \n        \n        Class<?> type = ann.annotationType();\n        Boolean b = _annotationsInside.get(type);\n        if (b == null) {\n            b = type.getAnnotation(JacksonAnnotationsInside.class) != null;\n            _annotationsInside.putIfAbsent(type, b);\n        }\n        return b.booleanValue();\n    }\n\n    \n\n    \n    @Override\n    @Deprecated \n    public String findEnumValue(Enum<?> value) {\n        \n        \n        \n        try {\n            \n            Field f = value.getClass().getField(value.name());\n            if (f != null) {\n                JsonProperty prop = f.getAnnotation(JsonProperty.class);\n                if (prop != null) {\n                    String n = prop.value();\n                    if (n != null && !n.isEmpty()) {\n                        return n;\n                    }\n                }\n            }\n        } catch (SecurityException e) {\n            \n        } catch (NoSuchFieldException e) {\n            \n        }\n        return value.name();\n    }\n\n    @Override \n    public String[] findEnumValues(Class<?> enumType, Enum<?>[] enumValues, String[] names) {\n        HashMap<String,String> expl = null;\n        for (Field f : ClassUtil.getDeclaredFields(enumType)) {\n            if (!f.isEnumConstant()) {\n                continue;\n            }\n            JsonProperty prop = f.getAnnotation(JsonProperty.class);\n            if (prop == null) {\n                continue;\n            }\n            String n = prop.value();\n            if (n.isEmpty()) {\n                continue;\n            }\n            if (expl == null) {\n                expl = new HashMap<String,String>();\n            }\n            expl.put(f.getName(), n);\n        }\n        \n        if (expl != null) {\n            for (int i = 0, end = enumValues.length; i < end; ++i) {\n                String defName = enumValues[i].name();\n                String explValue = expl.get(defName);\n                if (explValue != null) {\n                    names[i] = explValue;\n                }\n            }\n        }\n        return names;\n    }\n\n    \n    @Override\n    public Enum<?> findDefaultEnumValue(Class<Enum<?>> enumCls) {\n        return ClassUtil.findFirstAnnotatedEnumValue(enumCls, JsonEnumDefaultValue.class);\n    }\n\n    \n\n    @Override\n    public PropertyName findRootName(AnnotatedClass ac) {\n        JsonRootName ann = _findAnnotation(ac, JsonRootName.class);\n        if (ann == null) {\n            return null;\n        }\n        String ns = ann.namespace();\n        if (ns != null && ns.length() == 0) {\n            ns = null;\n        }\n        return PropertyName.construct(ann.value(), ns);\n    }\n\n    @Override \n    public JsonIgnoreProperties.Value findPropertyIgnorals(Annotated a) {\n        JsonIgnoreProperties v = _findAnnotation(a, JsonIgnoreProperties.class);\n        if (v == null) {\n            return JsonIgnoreProperties.Value.empty();\n        }\n        return JsonIgnoreProperties.Value.from(v);\n    }\n\n    @Override\n    public Boolean isIgnorableType(AnnotatedClass ac) {\n        JsonIgnoreType ignore = _findAnnotation(ac, JsonIgnoreType.class);\n        return (ignore == null) ? null : ignore.value();\n    }\n \n    @Override\n    public Object findFilterId(Annotated a) {\n        JsonFilter ann = _findAnnotation(a, JsonFilter.class);\n        if (ann != null) {\n            String id = ann.value();\n            \n            if (id.length() > 0) {\n                return id;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findNamingStrategy(AnnotatedClass ac) {\n        JsonNaming ann = _findAnnotation(ac, JsonNaming.class);\n        return (ann == null) ? null : ann.value();\n    }\n\n    @Override\n    public String findClassDescription(AnnotatedClass ac) {\n        JsonClassDescription ann = _findAnnotation(ac, JsonClassDescription.class);\n        return (ann == null) ? null : ann.value();\n    }\n\n    \n\n    @Override\n    public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) {\n        JsonAutoDetect ann = _findAnnotation(ac, JsonAutoDetect.class);\n        return (ann == null) ? checker : checker.with(ann);\n    }\n\n    \n\n    @Override\n    public String findImplicitPropertyName(AnnotatedMember m) {\n        PropertyName n = _findConstructorName(m);\n        return (n == null) ? null : n.getSimpleName();\n    }\n\n    @Override\n    public List<PropertyName> findPropertyAliases(Annotated m) {\n        JsonAlias ann = _findAnnotation(m, JsonAlias.class);\n        if (ann == null) {\n            return null;\n        }\n        String[] strs = ann.value();\n        final int len = strs.length;\n        if (len == 0) {\n            return Collections.emptyList();\n        }\n        List<PropertyName> result = new ArrayList<>(len);\n        for (int i = 0; i < len; ++i) {\n            result.add(PropertyName.construct(strs[i]));\n        }\n        return result;\n    }\n\n    @Override\n    public boolean hasIgnoreMarker(AnnotatedMember m) {\n        return _isIgnorable(m);\n    }\n\n    @Override\n    public Boolean hasRequiredMarker(AnnotatedMember m) {\n        JsonProperty ann = _findAnnotation(m, JsonProperty.class);\n        if (ann != null) {\n            return ann.required();\n        }\n        return null;\n    }\n\n    @Override\n    public JsonProperty.Access findPropertyAccess(Annotated m) {\n        JsonProperty ann = _findAnnotation(m, JsonProperty.class);\n        if (ann != null) {\n            return ann.access();\n        }\n        return null;\n    }\n\n    @Override\n    public String findPropertyDescription(Annotated ann) {\n        JsonPropertyDescription desc = _findAnnotation(ann, JsonPropertyDescription.class);\n        return (desc == null) ? null : desc.value();\n    }\n\n    @Override\n    public Integer findPropertyIndex(Annotated ann) {\n        JsonProperty prop = _findAnnotation(ann, JsonProperty.class);\n        if (prop != null) {\n          int ix = prop.index();\n          if (ix != JsonProperty.INDEX_UNKNOWN) {\n               return Integer.valueOf(ix);\n          }\n        }\n        return null;\n    }\n    \n    @Override\n    public String findPropertyDefaultValue(Annotated ann) {\n        JsonProperty prop = _findAnnotation(ann, JsonProperty.class);\n        if (prop == null) {\n            return null;\n        }\n        String str = prop.defaultValue();\n        \n        return str.isEmpty() ? null : str;\n    }\n    \n    @Override\n    public JsonFormat.Value findFormat(Annotated ann) {\n        JsonFormat f = _findAnnotation(ann, JsonFormat.class);\n        return (f == null)  ? null : new JsonFormat.Value(f);\n    }\n\n    @Override        \n    public ReferenceProperty findReferenceType(AnnotatedMember member) {\n        JsonManagedReference ref1 = _findAnnotation(member, JsonManagedReference.class);\n        if (ref1 != null) {\n            return AnnotationIntrospector.ReferenceProperty.managed(ref1.value());\n        }\n        JsonBackReference ref2 = _findAnnotation(member, JsonBackReference.class);\n        if (ref2 != null) {\n            return AnnotationIntrospector.ReferenceProperty.back(ref2.value());\n        }\n        return null;\n    }\n\n    @Override\n    public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member) {\n        JsonUnwrapped ann = _findAnnotation(member, JsonUnwrapped.class);\n        \n        \n        if (ann == null || !ann.enabled()) {\n            return null;\n        }\n        String prefix = ann.prefix();\n        String suffix = ann.suffix();\n        return NameTransformer.simpleTransformer(prefix, suffix);\n    }\n\n    @Override \n    public JacksonInject.Value findInjectableValue(AnnotatedMember m) {\n        JacksonInject ann = _findAnnotation(m, JacksonInject.class);\n        if (ann == null) {\n            return null;\n        }\n        \n        JacksonInject.Value v = JacksonInject.Value.from(ann);\n        if (!v.hasId()) {\n            Object id;\n            \n            if (!(m instanceof AnnotatedMethod)) {\n                id = m.getRawType().getName();\n            } else {\n                AnnotatedMethod am = (AnnotatedMethod) m;\n                if (am.getParameterCount() == 0) { \n                    id = m.getRawType().getName();\n                } else { \n                    id = am.getRawParameterType(0).getName();\n                }\n            }\n            v = v.withId(id);\n        }\n        return v;\n    }\n\n    @Override\n    @Deprecated \n    public Object findInjectableValueId(AnnotatedMember m) {\n        JacksonInject.Value v = findInjectableValue(m);\n        return (v == null) ? null : v.getId();\n    }\n\n    @Override\n    public Class<?>[] findViews(Annotated a) {\n        JsonView ann = _findAnnotation(a, JsonView.class);\n        return (ann == null) ? null : ann.value();\n    }\n\n    @Override \n    public AnnotatedMethod resolveSetterConflict(MapperConfig<?> config, AnnotatedMethod setter1, AnnotatedMethod setter2) {\n        Class<?> cls1 = setter1.getRawParameterType(0);\n        Class<?> cls2 = setter2.getRawParameterType(0);\n        \n        \n        \n        if (cls1.isPrimitive()) {\n            if (!cls2.isPrimitive()) {\n                return setter1;\n            }\n        } else if (cls2.isPrimitive()) {\n            return setter2;\n        }\n        \n        if (cls1 == String.class) {\n            if (cls2 != String.class) {\n                return setter1;\n            }\n        } else if (cls2 == String.class) {\n            return setter2;\n        }\n\n        return null;\n    }\n\n    \n\n    @Override\n    public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config, AnnotatedClass ac, JavaType baseType) {\n        return _findTypeResolver(config, ac, baseType);\n    }\n\n    @Override\n    public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType baseType) {\n        \n        \n        if (baseType.isContainerType() || baseType.isReferenceType()) {\n            return null;\n        }\n        \n        return _findTypeResolver(config, am, baseType);\n    }\n\n    @Override\n    public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType containerType) {\n        \n        if (containerType.getContentType() == null) {\n            throw new IllegalArgumentException(\"Must call method with a container or reference type (got \"+containerType+\")\");\n        }\n        return _findTypeResolver(config, am, containerType);\n    }\n    \n    @Override\n    public List<NamedType> findSubtypes(Annotated a) {\n        JsonSubTypes t = _findAnnotation(a, JsonSubTypes.class);\n        if (t == null) return null;\n        JsonSubTypes.Type[] types = t.value();\n        ArrayList<NamedType> result = new ArrayList<NamedType>(types.length);\n        for (JsonSubTypes.Type type : types) {\n            result.add(new NamedType(type.value(), type.name()));\n        }\n        return result;\n    }\n\n    @Override        \n    public String findTypeName(AnnotatedClass ac) {\n        JsonTypeName tn = _findAnnotation(ac, JsonTypeName.class);\n        return (tn == null) ? null : tn.value();\n    }\n\n    @Override\n    public Boolean isTypeId(AnnotatedMember member) {\n        return _hasAnnotation(member, JsonTypeId.class);\n    }\n\n    \n\n    @Override\n    public ObjectIdInfo findObjectIdInfo(Annotated ann) {\n        JsonIdentityInfo info = _findAnnotation(ann, JsonIdentityInfo.class);\n        if (info == null || info.generator() == ObjectIdGenerators.None.class) {\n            return null;\n        }\n        \n        PropertyName name = PropertyName.construct(info.property());\n        return new ObjectIdInfo(name, info.scope(), info.generator(), info.resolver());\n    }\n\n    @Override\n    public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n        JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class);\n        if (ref == null) {\n            return objectIdInfo;\n        }\n        if (objectIdInfo == null) {\n            objectIdInfo = ObjectIdInfo.empty();\n        }\n        return objectIdInfo.withAlwaysAsId(ref.alwaysAsId());\n    }\n\n    \n\n    @Override\n    public Object findSerializer(Annotated a) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.using();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        \n        \n        JsonRawValue annRaw =  _findAnnotation(a, JsonRawValue.class);\n        if ((annRaw != null) && annRaw.value()) {\n            \n            Class<?> cls = a.getRawType();\n            return new RawSerializer<Object>(cls);\n        }       \n        return null;\n    }\n\n    @Override\n    public Object findKeySerializer(Annotated a) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.keyUsing();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findContentSerializer(Annotated a) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.contentUsing();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findNullSerializer(Annotated a) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.nullsUsing();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public JsonInclude.Value findPropertyInclusion(Annotated a) {\n        JsonInclude inc = _findAnnotation(a, JsonInclude.class);\n        JsonInclude.Value value = (inc == null) ? JsonInclude.Value.empty() : JsonInclude.Value.from(inc);\n\n        \n        if (value.getValueInclusion() == JsonInclude.Include.USE_DEFAULTS) {\n            value = _refinePropertyInclusion(a, value);\n        }\n        return value;\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private JsonInclude.Value _refinePropertyInclusion(Annotated a, JsonInclude.Value value) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            switch (ann.include()) {\n            case ALWAYS:\n                return value.withValueInclusion(JsonInclude.Include.ALWAYS);\n            case NON_NULL:\n                return value.withValueInclusion(JsonInclude.Include.NON_NULL);\n            case NON_DEFAULT:\n                return value.withValueInclusion(JsonInclude.Include.NON_DEFAULT);\n            case NON_EMPTY:\n                return value.withValueInclusion(JsonInclude.Include.NON_EMPTY);\n            case DEFAULT_INCLUSION:\n            default:\n            }\n        }\n        return value;\n    }\n\n    @Override\n    public JsonSerialize.Typing findSerializationTyping(Annotated a) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        return (ann == null) ? null : ann.typing();\n    }\n\n    @Override\n    public Object findSerializationConverter(Annotated a) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.converter(), Converter.None.class);\n    }\n\n    @Override\n    public Object findSerializationContentConverter(AnnotatedMember a) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentConverter(), Converter.None.class);\n    }\n\n    \n    \n    @Override\n    public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n        JavaType type = baseType;\n        final TypeFactory tf = config.getTypeFactory();\n\n        final JsonSerialize jsonSer = _findAnnotation(a, JsonSerialize.class);\n        \n        \n\n        final Class<?> serClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.as());\n        if (serClass != null) {\n            if (type.hasRawClass(serClass)) {\n                \n                \n                type = type.withStaticTyping();\n            } else {\n                Class<?> currRaw = type.getRawClass();\n                try {\n                    \n                    \n                    if (serClass.isAssignableFrom(currRaw)) { \n                        type = tf.constructGeneralizedType(type, serClass);\n                    } else if (currRaw.isAssignableFrom(serClass)) { \n                        type = tf.constructSpecializedType(type, serClass);\n                    } else if (_primitiveAndWrapper(currRaw, serClass)) {\n                        \n                        type = type.withStaticTyping();\n                    } else {\n                        throw new JsonMappingException(null,\n                                String.format(\"Can not refine serialization type %s into %s; types not related\",\n                                        type, serClass.getName()));\n                    }\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null,\n                            String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\",\n                                    type, serClass.getName(), a.getName(), iae.getMessage()),\n                                    iae);\n                }\n            }\n        }\n        \n\n        \n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            final Class<?> keyClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.keyAs());\n            if (keyClass != null) {\n                if (keyType.hasRawClass(keyClass)) {\n                    keyType = keyType.withStaticTyping();\n                } else {\n                    Class<?> currRaw = keyType.getRawClass();\n                    try {\n                        \n                        \n                        \n                        if (keyClass.isAssignableFrom(currRaw)) { \n                            keyType = tf.constructGeneralizedType(keyType, keyClass);\n                        } else if (currRaw.isAssignableFrom(keyClass)) { \n                            keyType = tf.constructSpecializedType(keyType, keyClass);\n                        } else if (_primitiveAndWrapper(currRaw, keyClass)) {\n                            \n                            keyType = keyType.withStaticTyping();\n                        } else {\n                            throw new JsonMappingException(null,\n                                    String.format(\"Can not refine serialization key type %s into %s; types not related\",\n                                            keyType, keyClass.getName()));\n                        }\n                    } catch (IllegalArgumentException iae) {\n                        throw new JsonMappingException(null,\n                                String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                        type, keyClass.getName(), a.getName(), iae.getMessage()),\n                                        iae);\n                    }\n                }\n                type = ((MapLikeType) type).withKeyType(keyType);\n            }\n        }\n\n        JavaType contentType = type.getContentType();\n        if (contentType != null) { \n            \n           final Class<?> contentClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.contentAs());\n           if (contentClass != null) {\n               if (contentType.hasRawClass(contentClass)) {\n                   contentType = contentType.withStaticTyping();\n               } else {\n                   \n                   \n                   \n                   Class<?> currRaw = contentType.getRawClass();\n                   try {\n                       if (contentClass.isAssignableFrom(currRaw)) { \n                           contentType = tf.constructGeneralizedType(contentType, contentClass);\n                       } else if (currRaw.isAssignableFrom(contentClass)) { \n                           contentType = tf.constructSpecializedType(contentType, contentClass);\n                       } else if (_primitiveAndWrapper(currRaw, contentClass)) {\n                           \n                           contentType = contentType.withStaticTyping();\n                       } else {\n                           throw new JsonMappingException(null,\n                                   String.format(\"Can not refine serialization content type %s into %s; types not related\",\n                                           contentType, contentClass.getName()));\n                       }\n                   } catch (IllegalArgumentException iae) { \n                       throw new JsonMappingException(null,\n                               String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                       type, contentClass.getName(), a.getName(), iae.getMessage()),\n                                       iae);\n                   }\n               }\n               type = type.withContentType(contentType);\n           }\n        }\n        return type;\n    }\n\n    @Override\n    @Deprecated \n    public Class<?> findSerializationType(Annotated am) {\n        return null;\n    }\n\n    @Override\n    @Deprecated \n    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) {\n        return null;\n    }\n\n    @Override\n    @Deprecated \n    public Class<?> findSerializationContentType(Annotated am, JavaType baseType) {\n        return null;\n    }\n\n    \n\n    @Override\n    public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n        JsonPropertyOrder order = _findAnnotation(ac, JsonPropertyOrder.class);\n        return (order == null) ? null : order.value();\n    }\n\n    @Override\n    public Boolean findSerializationSortAlphabetically(Annotated ann) {\n        return _findSortAlpha(ann);\n    }\n\n    private final Boolean _findSortAlpha(Annotated ann) {\n        JsonPropertyOrder order = _findAnnotation(ann, JsonPropertyOrder.class);\n        \n        \n        if ((order != null) && order.alphabetic()) {\n            return Boolean.TRUE;\n        }\n        return null;\n    }\n\n    @Override\n    public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac, List<BeanPropertyWriter> properties) {\n        JsonAppend ann = _findAnnotation(ac, JsonAppend.class);\n        if (ann == null) {\n            return;\n        }\n        final boolean prepend = ann.prepend();\n        JavaType propType = null;\n\n        \n        JsonAppend.Attr[] attrs = ann.attrs();\n        for (int i = 0, len = attrs.length; i < len; ++i) {\n            if (propType == null) {\n                propType = config.constructType(Object.class);\n            }\n            BeanPropertyWriter bpw = _constructVirtualProperty(attrs[i],\n                    config, ac, propType);\n            if (prepend) {\n                properties.add(i, bpw);\n            } else {\n                properties.add(bpw);\n            }\n        }\n\n        \n        JsonAppend.Prop[] props = ann.props();\n        for (int i = 0, len = props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _constructVirtualProperty(props[i],\n                    config, ac);\n            if (prepend) {\n                properties.add(i, bpw);\n            } else {\n                properties.add(bpw);\n            }\n        }\n    }\n\n    protected BeanPropertyWriter _constructVirtualProperty(JsonAppend.Attr attr, MapperConfig<?> config, AnnotatedClass ac, JavaType type) {\n        PropertyMetadata metadata = attr.required() ?\n                    PropertyMetadata.STD_REQUIRED : PropertyMetadata.STD_OPTIONAL;\n        \n        String attrName = attr.value();\n\n        \n        PropertyName propName = _propertyName(attr.propName(), attr.propNamespace());\n        if (!propName.hasSimpleName()) {\n            propName = PropertyName.construct(attrName);\n        }\n        \n        AnnotatedMember member = new VirtualAnnotatedMember(ac, ac.getRawType(),\n                attrName, type);\n        \n        SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(config,\n                member, propName, metadata, attr.include());\n        \n        return AttributePropertyWriter.construct(attrName, propDef,\n                ac.getAnnotations(), type);\n    }\n\n    protected BeanPropertyWriter _constructVirtualProperty(JsonAppend.Prop prop, MapperConfig<?> config, AnnotatedClass ac) {\n        PropertyMetadata metadata = prop.required() ?\n                    PropertyMetadata.STD_REQUIRED : PropertyMetadata.STD_OPTIONAL;\n        PropertyName propName = _propertyName(prop.name(), prop.namespace());\n        JavaType type = config.constructType(prop.type());\n        \n        AnnotatedMember member = new VirtualAnnotatedMember(ac, ac.getRawType(),\n                propName.getSimpleName(), type);\n        \n        SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(config,\n                member, propName, metadata, prop.include());\n\n        Class<?> implClass = prop.value();\n\n        HandlerInstantiator hi = config.getHandlerInstantiator();\n        VirtualBeanPropertyWriter bpw = (hi == null) ? null\n                : hi.virtualPropertyWriterInstance(config, implClass);\n        if (bpw == null) {\n            bpw = (VirtualBeanPropertyWriter) ClassUtil.createInstance(implClass,\n                    config.canOverrideAccessModifiers());\n        }\n\n        \n        return bpw.withConfig(config, ac, propDef, type);\n    }\n\n    \n\n    @Override\n    public PropertyName findNameForSerialization(Annotated a) {\n        JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n        if (jg != null) {\n            return PropertyName.construct(jg.value());\n        }\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann != null) {\n            return PropertyName.construct(pann.value());\n        }\n        if (_hasOneOf(a, ANNOTATIONS_TO_INFER_SER)) {\n            return PropertyName.USE_DEFAULT;\n        }\n        return null;\n    }\n\n    @Override \n    public Boolean hasAsValue(Annotated a) {\n        JsonValue ann = _findAnnotation(a, JsonValue.class);\n        if (ann == null) {\n            return null;\n        }\n        return ann.value();\n    }\n\n    @Override \n    public Boolean hasAnyGetter(Annotated a) {\n        JsonAnyGetter ann = _findAnnotation(a, JsonAnyGetter.class);\n        if (ann == null) {\n            return null;\n        }\n        return ann.enabled();\n    }\n\n    @Override\n    @Deprecated \n    public boolean hasAnyGetterAnnotation(AnnotatedMethod am) {\n        \n        return _hasAnnotation(am, JsonAnyGetter.class);\n    }\n\n    @Override\n    @Deprecated \n    public boolean hasAsValueAnnotation(AnnotatedMethod am) {\n        JsonValue ann = _findAnnotation(am, JsonValue.class);\n        \n        return (ann != null) && ann.value();\n    }\n\n    \n\n    @Override\n    public Object findDeserializer(Annotated a) {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonDeserializer> deserClass = ann.using();\n            if (deserClass != JsonDeserializer.None.class) {\n                return deserClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findKeyDeserializer(Annotated a) {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        if (ann != null) {\n            Class<? extends KeyDeserializer> deserClass = ann.keyUsing();\n            if (deserClass != KeyDeserializer.None.class) {\n                return deserClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findContentDeserializer(Annotated a) {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonDeserializer> deserClass = ann.contentUsing();\n            if (deserClass != JsonDeserializer.None.class) {\n                return deserClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findDeserializationConverter(Annotated a) {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.converter(), Converter.None.class);\n    }\n\n    @Override\n    public Object findDeserializationContentConverter(AnnotatedMember a) {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentConverter(), Converter.None.class);\n    }\n\n    \n\n    @Override\n    public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n        JavaType type = baseType;\n        final TypeFactory tf = config.getTypeFactory();\n\n        final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n        \n        \n        final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n        if ((valueClass != null) && !type.hasRawClass(valueClass)\n                && !_primitiveAndWrapper(type, valueClass)) {\n            try {\n                type = tf.constructSpecializedType(type, valueClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null,\n                        String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\",\n                                type, valueClass.getName(), a.getName(), iae.getMessage()),\n                                iae);\n            }\n        }\n        \n\n        \n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n            if ((keyClass != null)\n                    && !_primitiveAndWrapper(keyType, keyClass)) {\n                try {\n                    keyType = tf.constructSpecializedType(keyType, keyClass);\n                    type = ((MapLikeType) type).withKeyType(keyType);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null,\n                            String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                    type, keyClass.getName(), a.getName(), iae.getMessage()),\n                                    iae);\n                }\n            }\n        }\n        JavaType contentType = type.getContentType();\n        if (contentType != null) { \n            \n            final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n            if ((contentClass != null)\n                    && !_primitiveAndWrapper(contentType, contentClass)) {\n                try {\n                    contentType = tf.constructSpecializedType(contentType, contentClass);\n                    type = type.withContentType(contentType);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null,\n                            String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                    type, contentClass.getName(), a.getName(), iae.getMessage()),\n                            iae);\n                }\n            }\n        }\n        return type;\n    }\n\n    @Override\n    @Deprecated \n    public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType) {\n        return null;\n    }\n\n    @Override\n    @Deprecated \n    public Class<?> findDeserializationType(Annotated am, JavaType baseType) {\n        return null;\n    }\n\n    @Override\n    @Deprecated \n    public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) {\n        return null;\n    }\n\n    \n\n    @Override\n    public Object findValueInstantiator(AnnotatedClass ac) {\n        JsonValueInstantiator ann = _findAnnotation(ac, JsonValueInstantiator.class);\n        \n        return (ann == null) ? null : ann.value();\n    }\n\n    @Override\n    public Class<?> findPOJOBuilder(AnnotatedClass ac) {\n        JsonDeserialize ann = _findAnnotation(ac, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.builder());\n    }\n\n    @Override\n    public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac) {\n        JsonPOJOBuilder ann = _findAnnotation(ac, JsonPOJOBuilder.class);\n        return (ann == null) ? null : new JsonPOJOBuilder.Value(ann);\n    }\n    \n    \n\n    @Override\n    public PropertyName findNameForDeserialization(Annotated a) {\n        \n        \n        JsonSetter js = _findAnnotation(a, JsonSetter.class);\n        if (js != null) {\n            return PropertyName.construct(js.value());\n        }\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann != null) {\n            return PropertyName.construct(pann.value());\n        }\n        if (_hasOneOf(a, ANNOTATIONS_TO_INFER_DESER)) {\n            return PropertyName.USE_DEFAULT;\n        }\n        return null;\n    }\n\n    @Override\n    public Boolean hasAnySetter(Annotated a) {\n        JsonAnySetter ann = _findAnnotation(a, JsonAnySetter.class);\n        return (ann == null) ? null : ann.enabled();\n    }\n\n    @Override\n    public JsonSetter.Value findSetterInfo(Annotated a) {\n        return JsonSetter.Value.from(_findAnnotation(a, JsonSetter.class));\n    }\n\n    @Override \n    public Boolean findMergeInfo(Annotated a) {\n        JsonMerge ann = _findAnnotation(a, JsonMerge.class);\n        return (ann == null) ? null : ann.value().asBoolean();\n    }\n\n    @Override\n    @Deprecated \n    public boolean hasAnySetterAnnotation(AnnotatedMethod am) {\n        return _hasAnnotation(am, JsonAnySetter.class);\n    }\n\n    @Override\n    @Deprecated \n    public boolean hasCreatorAnnotation(Annotated a) {\n        \n         JsonCreator ann = _findAnnotation(a, JsonCreator.class);\n         if (ann != null) {\n             return (ann.mode() != JsonCreator.Mode.DISABLED);\n         }\n         \n         \n         if (_cfgConstructorPropertiesImpliesCreator ) {\n             if (a instanceof AnnotatedConstructor) {\n                 if (_java7Helper != null) {\n                     Boolean b = _java7Helper.hasCreatorAnnotation(a);\n                     if (b != null) {\n                         return b.booleanValue();\n                     }\n                 }\n             }\n         }\n         return false;\n    }\n\n    @Override\n    @Deprecated \n    public JsonCreator.Mode findCreatorBinding(Annotated a) {\n        JsonCreator ann = _findAnnotation(a, JsonCreator.class);\n        return (ann == null) ? null : ann.mode();\n    }\n\n    @Override\n    public JsonCreator.Mode findCreatorAnnotation(MapperConfig<?> config, Annotated a) {\n        JsonCreator ann = _findAnnotation(a, JsonCreator.class);\n        if (ann != null) {\n            return ann.mode();\n        }\n\n        if (_cfgConstructorPropertiesImpliesCreator\n                && config.isEnabled(MapperFeature.INFER_CREATOR_FROM_CONSTRUCTOR_PROPERTIES)\n            ) {\n            if (a instanceof AnnotatedConstructor) {\n                if (_java7Helper != null) {\n                    Boolean b = _java7Helper.hasCreatorAnnotation(a);\n                    if ((b != null) && b.booleanValue()) {\n                        \n                        \n                        return JsonCreator.Mode.PROPERTIES;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    \n\n    protected boolean _isIgnorable(Annotated a) {\n        JsonIgnore ann = _findAnnotation(a, JsonIgnore.class);\n        if (ann != null) {\n            return ann.value();\n        }\n        if (_java7Helper != null) {\n            Boolean b = _java7Helper.findTransient(a);\n            if (b != null) {\n                return b.booleanValue();\n            }\n        }\n        return false;\n    }\n\n    protected Class<?> _classIfExplicit(Class<?> cls) {\n        if (cls == null || ClassUtil.isBogusClass(cls)) {\n            return null;\n        }\n        return cls;\n    }\n\n    protected Class<?> _classIfExplicit(Class<?> cls, Class<?> implicit) {\n        cls = _classIfExplicit(cls);\n        return (cls == null || cls == implicit) ? null : cls;\n    }\n\n    protected PropertyName _propertyName(String localName, String namespace) {\n        if (localName.isEmpty()) {\n            return PropertyName.USE_DEFAULT;\n        }\n        if (namespace == null || namespace.isEmpty()) {\n            return PropertyName.construct(localName);\n        }\n        return PropertyName.construct(localName, namespace);\n    }\n\n    protected PropertyName _findConstructorName(Annotated a) {\n        if (a instanceof AnnotatedParameter) {\n            AnnotatedParameter p = (AnnotatedParameter) a;\n            AnnotatedWithParams ctor = p.getOwner();\n\n            if (ctor != null) {\n                if (_java7Helper != null) {\n                    PropertyName name = _java7Helper.findConstructorName(p);\n                    if (name != null) {\n                        return name;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    \n    @SuppressWarnings(\"deprecation\")\n    protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config, Annotated ann, JavaType baseType) {\n        \n        TypeResolverBuilder<?> b;\n        JsonTypeInfo info = _findAnnotation(ann, JsonTypeInfo.class);\n        JsonTypeResolver resAnn = _findAnnotation(ann, JsonTypeResolver.class);\n        \n        if (resAnn != null) {\n            if (info == null) {\n                return null;\n            }\n            \n            b = config.typeResolverBuilderInstance(ann, resAnn.value());\n        } else { \n            if (info == null) {\n                return null;\n            }\n            \n            if (info.use() == JsonTypeInfo.Id.NONE) {\n                return _constructNoTypeResolverBuilder();\n            }\n            b = _constructStdTypeResolverBuilder();\n        }\n        \n        JsonTypeIdResolver idResInfo = _findAnnotation(ann, JsonTypeIdResolver.class);\n        TypeIdResolver idRes = (idResInfo == null) ? null\n                : config.typeIdResolverInstance(ann, idResInfo.value());\n        if (idRes != null) {\n            idRes.init(baseType);\n        }\n        b = b.init(info.use(), idRes);\n        \n        JsonTypeInfo.As inclusion = info.include();\n        if (inclusion == JsonTypeInfo.As.EXTERNAL_PROPERTY && (ann instanceof AnnotatedClass)) {\n            inclusion = JsonTypeInfo.As.PROPERTY;\n        }\n        b = b.inclusion(inclusion);\n        b = b.typeProperty(info.property());\n        Class<?> defaultImpl = info.defaultImpl();\n\n        \n        \n        \n        \n        if (defaultImpl != JsonTypeInfo.None.class && !defaultImpl.isAnnotation()) {\n            b = b.defaultImpl(defaultImpl);\n        }\n        b = b.typeIdVisibility(info.visible());\n        return b;\n    }\n\n    \n    protected StdTypeResolverBuilder _constructStdTypeResolverBuilder() {\n        return new StdTypeResolverBuilder();\n    }\n\n    \n    protected StdTypeResolverBuilder _constructNoTypeResolverBuilder() {\n        return StdTypeResolverBuilder.noTypeInfoBuilder();\n    }\n\n    private boolean _primitiveAndWrapper(Class<?> baseType, Class<?> refinement) {\n        if (baseType.isPrimitive()) {\n            return baseType == ClassUtil.primitiveType(refinement);\n        }\n        if (refinement.isPrimitive()) {\n            return refinement == ClassUtil.primitiveType(baseType);\n        }\n        return false;\n    }\n\n    private boolean _primitiveAndWrapper(JavaType baseType, Class<?> refinement) {\n        if (baseType.isPrimitive()) {\n            return baseType.hasRawClass(ClassUtil.primitiveType(refinement));\n        }\n        if (refinement.isPrimitive()) {\n            return refinement == ClassUtil.primitiveType(baseType.getRawClass());\n        }\n        return false;\n    }\n}\n",
      "buggy_signatures": [
        "public Version version()",
        "protected Object readResolve()",
        "public JacksonAnnotationIntrospector setConstructorPropertiesImpliesCreator(boolean b)",
        "public boolean isAnnotationBundle(Annotation ann)",
        "public String findEnumValue(Enum<?> value)",
        "public String[] findEnumValues(Class<?> enumType, Enum<?>[] enumValues, String[] names)",
        "public Enum<?> findDefaultEnumValue(Class<Enum<?>> enumCls)",
        "public PropertyName findRootName(AnnotatedClass ac)",
        "public JsonIgnoreProperties.Value findPropertyIgnorals(Annotated a)",
        "public Boolean isIgnorableType(AnnotatedClass ac)",
        "public Object findFilterId(Annotated a)",
        "public Object findNamingStrategy(AnnotatedClass ac)",
        "public String findClassDescription(AnnotatedClass ac)",
        "public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker)",
        "public String findImplicitPropertyName(AnnotatedMember m)",
        "public List<PropertyName> findPropertyAliases(Annotated m)",
        "public boolean hasIgnoreMarker(AnnotatedMember m)",
        "public Boolean hasRequiredMarker(AnnotatedMember m)",
        "public JsonProperty.Access findPropertyAccess(Annotated m)",
        "public String findPropertyDescription(Annotated ann)",
        "public Integer findPropertyIndex(Annotated ann)",
        "public String findPropertyDefaultValue(Annotated ann)",
        "public JsonFormat.Value findFormat(Annotated ann)",
        "public ReferenceProperty findReferenceType(AnnotatedMember member)",
        "public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member)",
        "public JacksonInject.Value findInjectableValue(AnnotatedMember m)",
        "public Object findInjectableValueId(AnnotatedMember m)",
        "public Class<?>[] findViews(Annotated a)",
        "public AnnotatedMethod resolveSetterConflict(MapperConfig<?> config, AnnotatedMethod setter1, AnnotatedMethod setter2)",
        "public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config, AnnotatedClass ac, JavaType baseType)",
        "public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType baseType)",
        "public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType containerType)",
        "public List<NamedType> findSubtypes(Annotated a)",
        "public String findTypeName(AnnotatedClass ac)",
        "public Boolean isTypeId(AnnotatedMember member)",
        "public ObjectIdInfo findObjectIdInfo(Annotated ann)",
        "public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo)",
        "public Object findSerializer(Annotated a)",
        "public Object findKeySerializer(Annotated a)",
        "public Object findContentSerializer(Annotated a)",
        "public Object findNullSerializer(Annotated a)",
        "public JsonInclude.Value findPropertyInclusion(Annotated a)",
        "private JsonInclude.Value _refinePropertyInclusion(Annotated a, JsonInclude.Value value)",
        "public JsonSerialize.Typing findSerializationTyping(Annotated a)",
        "public Object findSerializationConverter(Annotated a)",
        "public Object findSerializationContentConverter(AnnotatedMember a)",
        "public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException",
        "public Class<?> findSerializationType(Annotated am)",
        "public Class<?> findSerializationKeyType(Annotated am, JavaType baseType)",
        "public Class<?> findSerializationContentType(Annotated am, JavaType baseType)",
        "public String[] findSerializationPropertyOrder(AnnotatedClass ac)",
        "public Boolean findSerializationSortAlphabetically(Annotated ann)",
        "private final Boolean _findSortAlpha(Annotated ann)",
        "public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac, List<BeanPropertyWriter> properties)",
        "protected BeanPropertyWriter _constructVirtualProperty(JsonAppend.Attr attr, MapperConfig<?> config, AnnotatedClass ac, JavaType type)",
        "protected BeanPropertyWriter _constructVirtualProperty(JsonAppend.Prop prop, MapperConfig<?> config, AnnotatedClass ac)",
        "public PropertyName findNameForSerialization(Annotated a)",
        "public Boolean hasAsValue(Annotated a)",
        "public Boolean hasAnyGetter(Annotated a)",
        "public boolean hasAnyGetterAnnotation(AnnotatedMethod am)",
        "public boolean hasAsValueAnnotation(AnnotatedMethod am)",
        "public Object findDeserializer(Annotated a)",
        "public Object findKeyDeserializer(Annotated a)",
        "public Object findContentDeserializer(Annotated a)",
        "public Object findDeserializationConverter(Annotated a)",
        "public Object findDeserializationContentConverter(AnnotatedMember a)",
        "public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException",
        "public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType)",
        "public Class<?> findDeserializationType(Annotated am, JavaType baseType)",
        "public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType)",
        "public Object findValueInstantiator(AnnotatedClass ac)",
        "public Class<?> findPOJOBuilder(AnnotatedClass ac)",
        "public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac)",
        "public PropertyName findNameForDeserialization(Annotated a)",
        "public Boolean hasAnySetter(Annotated a)",
        "public JsonSetter.Value findSetterInfo(Annotated a)",
        "public Boolean findMergeInfo(Annotated a)",
        "public boolean hasAnySetterAnnotation(AnnotatedMethod am)",
        "public boolean hasCreatorAnnotation(Annotated a)",
        "public JsonCreator.Mode findCreatorBinding(Annotated a)",
        "public JsonCreator.Mode findCreatorAnnotation(MapperConfig<?> config, Annotated a)",
        "protected boolean _isIgnorable(Annotated a)",
        "protected Class<?> _classIfExplicit(Class<?> cls)",
        "protected Class<?> _classIfExplicit(Class<?> cls, Class<?> implicit)",
        "protected PropertyName _propertyName(String localName, String namespace)",
        "protected PropertyName _findConstructorName(Annotated a)",
        "protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config, Annotated ann, JavaType baseType)",
        "protected StdTypeResolverBuilder _constructStdTypeResolverBuilder()",
        "protected StdTypeResolverBuilder _constructNoTypeResolverBuilder()"
      ],
      "fixed_signatures": [
        "public Version version()",
        "protected Object readResolve()",
        "public JacksonAnnotationIntrospector setConstructorPropertiesImpliesCreator(boolean b)",
        "public boolean isAnnotationBundle(Annotation ann)",
        "public String findEnumValue(Enum<?> value)",
        "public String[] findEnumValues(Class<?> enumType, Enum<?>[] enumValues, String[] names)",
        "public Enum<?> findDefaultEnumValue(Class<Enum<?>> enumCls)",
        "public PropertyName findRootName(AnnotatedClass ac)",
        "public JsonIgnoreProperties.Value findPropertyIgnorals(Annotated a)",
        "public Boolean isIgnorableType(AnnotatedClass ac)",
        "public Object findFilterId(Annotated a)",
        "public Object findNamingStrategy(AnnotatedClass ac)",
        "public String findClassDescription(AnnotatedClass ac)",
        "public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker)",
        "public String findImplicitPropertyName(AnnotatedMember m)",
        "public List<PropertyName> findPropertyAliases(Annotated m)",
        "public boolean hasIgnoreMarker(AnnotatedMember m)",
        "public Boolean hasRequiredMarker(AnnotatedMember m)",
        "public JsonProperty.Access findPropertyAccess(Annotated m)",
        "public String findPropertyDescription(Annotated ann)",
        "public Integer findPropertyIndex(Annotated ann)",
        "public String findPropertyDefaultValue(Annotated ann)",
        "public JsonFormat.Value findFormat(Annotated ann)",
        "public ReferenceProperty findReferenceType(AnnotatedMember member)",
        "public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member)",
        "public JacksonInject.Value findInjectableValue(AnnotatedMember m)",
        "public Object findInjectableValueId(AnnotatedMember m)",
        "public Class<?>[] findViews(Annotated a)",
        "public AnnotatedMethod resolveSetterConflict(MapperConfig<?> config, AnnotatedMethod setter1, AnnotatedMethod setter2)",
        "public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config, AnnotatedClass ac, JavaType baseType)",
        "public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType baseType)",
        "public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType containerType)",
        "public List<NamedType> findSubtypes(Annotated a)",
        "public String findTypeName(AnnotatedClass ac)",
        "public Boolean isTypeId(AnnotatedMember member)",
        "public ObjectIdInfo findObjectIdInfo(Annotated ann)",
        "public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo)",
        "public Object findSerializer(Annotated a)",
        "public Object findKeySerializer(Annotated a)",
        "public Object findContentSerializer(Annotated a)",
        "public Object findNullSerializer(Annotated a)",
        "public JsonInclude.Value findPropertyInclusion(Annotated a)",
        "private JsonInclude.Value _refinePropertyInclusion(Annotated a, JsonInclude.Value value)",
        "public JsonSerialize.Typing findSerializationTyping(Annotated a)",
        "public Object findSerializationConverter(Annotated a)",
        "public Object findSerializationContentConverter(AnnotatedMember a)",
        "public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException",
        "public Class<?> findSerializationType(Annotated am)",
        "public Class<?> findSerializationKeyType(Annotated am, JavaType baseType)",
        "public Class<?> findSerializationContentType(Annotated am, JavaType baseType)",
        "public String[] findSerializationPropertyOrder(AnnotatedClass ac)",
        "public Boolean findSerializationSortAlphabetically(Annotated ann)",
        "private final Boolean _findSortAlpha(Annotated ann)",
        "public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac, List<BeanPropertyWriter> properties)",
        "protected BeanPropertyWriter _constructVirtualProperty(JsonAppend.Attr attr, MapperConfig<?> config, AnnotatedClass ac, JavaType type)",
        "protected BeanPropertyWriter _constructVirtualProperty(JsonAppend.Prop prop, MapperConfig<?> config, AnnotatedClass ac)",
        "public PropertyName findNameForSerialization(Annotated a)",
        "public Boolean hasAsValue(Annotated a)",
        "public Boolean hasAnyGetter(Annotated a)",
        "public boolean hasAnyGetterAnnotation(AnnotatedMethod am)",
        "public boolean hasAsValueAnnotation(AnnotatedMethod am)",
        "public Object findDeserializer(Annotated a)",
        "public Object findKeyDeserializer(Annotated a)",
        "public Object findContentDeserializer(Annotated a)",
        "public Object findDeserializationConverter(Annotated a)",
        "public Object findDeserializationContentConverter(AnnotatedMember a)",
        "public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException",
        "public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType)",
        "public Class<?> findDeserializationType(Annotated am, JavaType baseType)",
        "public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType)",
        "public Object findValueInstantiator(AnnotatedClass ac)",
        "public Class<?> findPOJOBuilder(AnnotatedClass ac)",
        "public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac)",
        "public PropertyName findNameForDeserialization(Annotated a)",
        "public Boolean hasAnySetter(Annotated a)",
        "public JsonSetter.Value findSetterInfo(Annotated a)",
        "public Boolean findMergeInfo(Annotated a)",
        "public boolean hasAnySetterAnnotation(AnnotatedMethod am)",
        "public boolean hasCreatorAnnotation(Annotated a)",
        "public JsonCreator.Mode findCreatorBinding(Annotated a)",
        "public JsonCreator.Mode findCreatorAnnotation(MapperConfig<?> config, Annotated a)",
        "protected boolean _isIgnorable(Annotated a)",
        "protected Class<?> _classIfExplicit(Class<?> cls)",
        "protected Class<?> _classIfExplicit(Class<?> cls, Class<?> implicit)",
        "protected PropertyName _propertyName(String localName, String namespace)",
        "protected PropertyName _findConstructorName(Annotated a)",
        "protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config, Annotated ann, JavaType baseType)",
        "protected StdTypeResolverBuilder _constructStdTypeResolverBuilder()",
        "protected StdTypeResolverBuilder _constructNoTypeResolverBuilder()",
        "private boolean _primitiveAndWrapper(Class<?> baseType, Class<?> refinement)",
        "private boolean _primitiveAndWrapper(JavaType baseType, Class<?> refinement)"
      ],
      "methods": [
        {
          "buggy_method": "  public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n  JavaType type = baseType;\n  final TypeFactory tf = config.getTypeFactory();\n\n  final JsonSerialize jsonSer = _findAnnotation(a, JsonSerialize.class);\n  \n  \n\n  final Class<?> serClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.as());\n  if (serClass != null) {\n  if (type.hasRawClass(serClass)) {\n  \n  \n  type = type.withStaticTyping();\n  } else {\n  Class<?> currRaw = type.getRawClass();\n  try {\n  \n  \n  if (serClass.isAssignableFrom(currRaw)) { \n  type = tf.constructGeneralizedType(type, serClass);\n  } else if (currRaw.isAssignableFrom(serClass)) { \n  type = tf.constructSpecializedType(type, serClass);\n  \n  } else {\n  throw new JsonMappingException(null,\n  String.format(\"Can not refine serialization type %s into %s; types not related\",\n  type, serClass.getName()));\n  }\n  } catch (IllegalArgumentException iae) {\n  throw new JsonMappingException(null,\n  String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\",\n  type, serClass.getName(), a.getName(), iae.getMessage()),\n  iae);\n  }\n  }\n  }\n  \n\n  \n  if (type.isMapLikeType()) {\n  JavaType keyType = type.getKeyType();\n  final Class<?> keyClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.keyAs());\n  if (keyClass != null) {\n  if (keyType.hasRawClass(keyClass)) {\n  keyType = keyType.withStaticTyping();\n  } else {\n  Class<?> currRaw = keyType.getRawClass();\n  try {\n  \n  \n  \n  if (keyClass.isAssignableFrom(currRaw)) { \n  keyType = tf.constructGeneralizedType(keyType, keyClass);\n  } else if (currRaw.isAssignableFrom(keyClass)) { \n  keyType = tf.constructSpecializedType(keyType, keyClass);\n  \n  } else {\n  throw new JsonMappingException(null,\n  String.format(\"Can not refine serialization key type %s into %s; types not related\",\n  keyType, keyClass.getName()));\n  }\n  } catch (IllegalArgumentException iae) {\n  throw new JsonMappingException(null,\n  String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n  type, keyClass.getName(), a.getName(), iae.getMessage()),\n  iae);\n  }\n  }\n  type = ((MapLikeType) type).withKeyType(keyType);\n  }\n  }\n\n  JavaType contentType = type.getContentType();\n  if (contentType != null) { \n  \n  final Class<?> contentClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.contentAs());\n  if (contentClass != null) {\n  if (contentType.hasRawClass(contentClass)) {\n  contentType = contentType.withStaticTyping();\n  } else {\n  \n  \n  \n  Class<?> currRaw = contentType.getRawClass();\n  try {\n  if (contentClass.isAssignableFrom(currRaw)) { \n  contentType = tf.constructGeneralizedType(contentType, contentClass);\n  } else if (currRaw.isAssignableFrom(contentClass)) { \n  contentType = tf.constructSpecializedType(contentType, contentClass);\n  \n  } else {\n  throw new JsonMappingException(null,\n  String.format(\"Can not refine serialization content type %s into %s; types not related\",\n  contentType, contentClass.getName()));\n  }\n  } catch (IllegalArgumentException iae) { \n  throw new JsonMappingException(null,\n  String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n  type, contentClass.getName(), a.getName(), iae.getMessage()),\n  iae);\n  }\n  }\n  type = type.withContentType(contentType);\n  }\n  }\n  return type;\n  }",
          "fixed_method": "  public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n  JavaType type = baseType;\n  final TypeFactory tf = config.getTypeFactory();\n\n  final JsonSerialize jsonSer = _findAnnotation(a, JsonSerialize.class);\n  \n  \n\n  final Class<?> serClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.as());\n  if (serClass != null) {\n  if (type.hasRawClass(serClass)) {\n  \n  \n  type = type.withStaticTyping();\n  } else {\n  Class<?> currRaw = type.getRawClass();\n  try {\n  \n  \n  if (serClass.isAssignableFrom(currRaw)) { \n  type = tf.constructGeneralizedType(type, serClass);\n  } else if (currRaw.isAssignableFrom(serClass)) { \n  type = tf.constructSpecializedType(type, serClass);\n  } else if (_primitiveAndWrapper(currRaw, serClass)) {\n  \n  type = type.withStaticTyping();\n  } else {\n  throw new JsonMappingException(null,\n  String.format(\"Can not refine serialization type %s into %s; types not related\",\n  type, serClass.getName()));\n  }\n  } catch (IllegalArgumentException iae) {\n  throw new JsonMappingException(null,\n  String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\",\n  type, serClass.getName(), a.getName(), iae.getMessage()),\n  iae);\n  }\n  }\n  }\n  \n\n  \n  if (type.isMapLikeType()) {\n  JavaType keyType = type.getKeyType();\n  final Class<?> keyClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.keyAs());\n  if (keyClass != null) {\n  if (keyType.hasRawClass(keyClass)) {\n  keyType = keyType.withStaticTyping();\n  } else {\n  Class<?> currRaw = keyType.getRawClass();\n  try {\n  \n  \n  \n  if (keyClass.isAssignableFrom(currRaw)) { \n  keyType = tf.constructGeneralizedType(keyType, keyClass);\n  } else if (currRaw.isAssignableFrom(keyClass)) { \n  keyType = tf.constructSpecializedType(keyType, keyClass);\n  } else if (_primitiveAndWrapper(currRaw, keyClass)) {\n  \n  keyType = keyType.withStaticTyping();\n  } else {\n  throw new JsonMappingException(null,\n  String.format(\"Can not refine serialization key type %s into %s; types not related\",\n  keyType, keyClass.getName()));\n  }\n  } catch (IllegalArgumentException iae) {\n  throw new JsonMappingException(null,\n  String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n  type, keyClass.getName(), a.getName(), iae.getMessage()),\n  iae);\n  }\n  }\n  type = ((MapLikeType) type).withKeyType(keyType);\n  }\n  }\n\n  JavaType contentType = type.getContentType();\n  if (contentType != null) { \n  \n  final Class<?> contentClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.contentAs());\n  if (contentClass != null) {\n  if (contentType.hasRawClass(contentClass)) {\n  contentType = contentType.withStaticTyping();\n  } else {\n  \n  \n  \n  Class<?> currRaw = contentType.getRawClass();\n  try {\n  if (contentClass.isAssignableFrom(currRaw)) { \n  contentType = tf.constructGeneralizedType(contentType, contentClass);\n  } else if (currRaw.isAssignableFrom(contentClass)) { \n  contentType = tf.constructSpecializedType(contentType, contentClass);\n  } else if (_primitiveAndWrapper(currRaw, contentClass)) {\n  \n  contentType = contentType.withStaticTyping();\n  } else {\n  throw new JsonMappingException(null,\n  String.format(\"Can not refine serialization content type %s into %s; types not related\",\n  contentType, contentClass.getName()));\n  }\n  } catch (IllegalArgumentException iae) { \n  throw new JsonMappingException(null,\n  String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n  type, contentClass.getName(), a.getName(), iae.getMessage()),\n  iae);\n  }\n  }\n  type = type.withContentType(contentType);\n  }\n  }\n  return type;\n  }",
          "diff": [
            "@@ -761,7 +761,9 @@",
            "                         type = tf.constructGeneralizedType(type, serClass);\n",
            "                     } else if (currRaw.isAssignableFrom(serClass)) { // specialization, ok as well\n",
            "                         type = tf.constructSpecializedType(type, serClass);\n",
            "+                    } else if (_primitiveAndWrapper(currRaw, serClass)) {\n",
            "                         // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n",
            "+                        type = type.withStaticTyping();\n",
            "                     } else {\n",
            "                         throw new JsonMappingException(null,\n",
            "                                 String.format(\"Can not refine serialization type %s into %s; types not related\",\n",
            "@@ -794,7 +796,9 @@",
            "                             keyType = tf.constructGeneralizedType(keyType, keyClass);\n",
            "                         } else if (currRaw.isAssignableFrom(keyClass)) { // specialization, ok as well\n",
            "                             keyType = tf.constructSpecializedType(keyType, keyClass);\n",
            "+                        } else if (_primitiveAndWrapper(currRaw, keyClass)) {\n",
            "                             // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n",
            "+                            keyType = keyType.withStaticTyping();\n",
            "                         } else {\n",
            "                             throw new JsonMappingException(null,\n",
            "                                     String.format(\"Can not refine serialization key type %s into %s; types not related\",\n",
            "@@ -828,7 +832,9 @@",
            "                            contentType = tf.constructGeneralizedType(contentType, contentClass);\n",
            "                        } else if (currRaw.isAssignableFrom(contentClass)) { // specialization, ok as well\n",
            "                            contentType = tf.constructSpecializedType(contentType, contentClass);\n",
            "+                       } else if (_primitiveAndWrapper(currRaw, contentClass)) {\n",
            "                            // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n",
            "+                           contentType = contentType.withStaticTyping();\n",
            "                        } else {\n",
            "                            throw new JsonMappingException(null,\n",
            "                                    String.format(\"Can not refine serialization content type %s into %s; types not related\",\n"
          ],
          "changed_lines": 6
        },
        {
          "buggy_method": "  public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n  JavaType type = baseType;\n  final TypeFactory tf = config.getTypeFactory();\n\n  final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n  \n  \n  final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n  if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n  try {\n  type = tf.constructSpecializedType(type, valueClass);\n  } catch (IllegalArgumentException iae) {\n  throw new JsonMappingException(null,\n  String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\",\n  type, valueClass.getName(), a.getName(), iae.getMessage()),\n  iae);\n  }\n  }\n  \n\n  \n  if (type.isMapLikeType()) {\n  JavaType keyType = type.getKeyType();\n  final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n  if (keyClass != null) {\n  try {\n  keyType = tf.constructSpecializedType(keyType, keyClass);\n  type = ((MapLikeType) type).withKeyType(keyType);\n  } catch (IllegalArgumentException iae) {\n  throw new JsonMappingException(null,\n  String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n  type, keyClass.getName(), a.getName(), iae.getMessage()),\n  iae);\n  }\n  }\n  }\n  JavaType contentType = type.getContentType();\n  if (contentType != null) { \n  \n  final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n  if (contentClass != null) {\n  try {\n  contentType = tf.constructSpecializedType(contentType, contentClass);\n  type = type.withContentType(contentType);\n  } catch (IllegalArgumentException iae) {\n  throw new JsonMappingException(null,\n  String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n  type, contentClass.getName(), a.getName(), iae.getMessage()),\n  iae);\n  }\n  }\n  }\n  return type;\n  }",
          "fixed_method": "  public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n  JavaType type = baseType;\n  final TypeFactory tf = config.getTypeFactory();\n\n  final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n  \n  \n  final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n  if ((valueClass != null) && !type.hasRawClass(valueClass)\n  && !_primitiveAndWrapper(type, valueClass)) {\n  try {\n  type = tf.constructSpecializedType(type, valueClass);\n  } catch (IllegalArgumentException iae) {\n  throw new JsonMappingException(null,\n  String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\",\n  type, valueClass.getName(), a.getName(), iae.getMessage()),\n  iae);\n  }\n  }\n  \n\n  \n  if (type.isMapLikeType()) {\n  JavaType keyType = type.getKeyType();\n  final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n  if ((keyClass != null)\n  && !_primitiveAndWrapper(keyType, keyClass)) {\n  try {\n  keyType = tf.constructSpecializedType(keyType, keyClass);\n  type = ((MapLikeType) type).withKeyType(keyType);\n  } catch (IllegalArgumentException iae) {\n  throw new JsonMappingException(null,\n  String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n  type, keyClass.getName(), a.getName(), iae.getMessage()),\n  iae);\n  }\n  }\n  }\n  JavaType contentType = type.getContentType();\n  if (contentType != null) { \n  \n  final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n  if ((contentClass != null)\n  && !_primitiveAndWrapper(contentType, contentClass)) {\n  try {\n  contentType = tf.constructSpecializedType(contentType, contentClass);\n  type = type.withContentType(contentType);\n  } catch (IllegalArgumentException iae) {\n  throw new JsonMappingException(null,\n  String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n  type, contentClass.getName(), a.getName(), iae.getMessage()),\n  iae);\n  }\n  }\n  }\n  return type;\n  }",
          "diff": [
            "@@ -1116,7 +1122,8 @@",
            "         \n",
            "         // Ok: start by refining the main type itself; common to all types\n",
            "         final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n",
            "-        if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n",
            "+        if ((valueClass != null) && !type.hasRawClass(valueClass)\n",
            "+                && !_primitiveAndWrapper(type, valueClass)) {\n",
            "             try {\n",
            "                 type = tf.constructSpecializedType(type, valueClass);\n",
            "             } catch (IllegalArgumentException iae) {\n",
            "@@ -1132,7 +1139,8 @@",
            "         if (type.isMapLikeType()) {\n",
            "             JavaType keyType = type.getKeyType();\n",
            "             final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n",
            "-            if (keyClass != null) {\n",
            "+            if ((keyClass != null)\n",
            "+                    && !_primitiveAndWrapper(keyType, keyClass)) {\n",
            "                 try {\n",
            "                     keyType = tf.constructSpecializedType(keyType, keyClass);\n",
            "                     type = ((MapLikeType) type).withKeyType(keyType);\n",
            "@@ -1148,7 +1156,8 @@",
            "         if (contentType != null) { // collection[like], map[like], array, reference\n",
            "             // And then value types for all containers:\n",
            "             final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n",
            "-            if (contentClass != null) {\n",
            "+            if ((contentClass != null)\n",
            "+                    && !_primitiveAndWrapper(contentType, contentClass)) {\n",
            "                 try {\n",
            "                     contentType = tf.constructSpecializedType(contentType, contentClass);\n",
            "                     type = type.withContentType(contentType);\n"
          ],
          "changed_lines": 9
        },
        {
          "buggy_method": "  protected StdTypeResolverBuilder _constructNoTypeResolverBuilder() {\n  return StdTypeResolverBuilder.noTypeInfoBuilder();\n  }",
          "fixed_method": "  private boolean _primitiveAndWrapper(Class<?> baseType, Class<?> refinement) {\n  if (baseType.isPrimitive()) {\n  return baseType == ClassUtil.primitiveType(refinement);\n  }\n  if (refinement.isPrimitive()) {\n  return refinement == ClassUtil.primitiveType(baseType);\n  }\n  return false;\n  }",
          "diff": [
            "@@ -1454,5 +1463,25 @@",
            "         return StdTypeResolverBuilder.noTypeInfoBuilder();\n",
            "     }\n",
            " \n",
            "-\n",
            "+    private boolean _primitiveAndWrapper(Class<?> baseType, Class<?> refinement)\n",
            "+    {\n",
            "+        if (baseType.isPrimitive()) {\n",
            "+            return baseType == ClassUtil.primitiveType(refinement);\n",
            "+        }\n",
            "+        if (refinement.isPrimitive()) {\n",
            "+            return refinement == ClassUtil.primitiveType(baseType);\n",
            "+        }\n",
            "+        return false;\n",
            "+    }\n",
            "+\n",
            "+    private boolean _primitiveAndWrapper(JavaType baseType, Class<?> refinement)\n",
            "+    {\n",
            "+        if (baseType.isPrimitive()) {\n",
            "+            return baseType.hasRawClass(ClassUtil.primitiveType(refinement));\n",
            "+        }\n",
            "+        if (refinement.isPrimitive()) {\n",
            "+            return refinement == ClassUtil.primitiveType(baseType.getRawClass());\n",
            "+        }\n",
            "+        return false;\n",
            "+    }\n",
            " }\n"
          ],
          "changed_lines": 22
        }
      ]
    }
  ]
}
