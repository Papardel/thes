{
  "bug_id": "7",
  "failed_tests": {
    "org.joda.time.format.TestDateTimeFormatter": [
      {
        "methodName": "testParseInto_monthDay_feb29_newYork_startOfYear",
        "error": "org.joda.time.IllegalFieldValueException",
        "message": "Cannot parse \"2 29\": Value 29 for dayOfMonth must be in the range [1,28]",
        "fail_line": "        assertEquals(4, f.parseInto(result, \"2 29\", 0));",
        "test_source": "  public void testParseInto_monthDay_feb29_newYork_startOfYear() {\n  DateTimeFormatter f = DateTimeFormat.forPattern(\"M d\").withLocale(Locale.UK);\n  MutableDateTime result = new MutableDateTime(2004, 1, 1, 0, 0, 0, 0, NEWYORK);\n  assertEquals(4, f.parseInto(result, \"2 29\", 0));\n  assertEquals(new MutableDateTime(2004, 2, 29, 0, 0, 0, 0, NEWYORK), result);\n  }",
        "stack": [
          "FieldUtils.verifyValueBounds line 220, PreciseDurationDateTimeField.set line 78, DateTimeParserBucket$SavedField.set line 483, DateTimeParserBucket.computeMillis line 366, DateTimeParserBucket.computeMillis line 359, DateTimeFormatter.parseInto line 715, TestDateTimeFormatter.testParseInto_monthDay_feb29_newYork_startOfYear line 932"
        ]
      },
      {
        "methodName": "testParseInto_monthDay_feb29_tokyo_endOfYear",
        "error": "org.joda.time.IllegalFieldValueException",
        "message": "Cannot parse \"2 29\": Value 29 for dayOfMonth must be in the range [1,28]",
        "fail_line": "        assertEquals(4, f.parseInto(result, \"2 29\", 0));",
        "test_source": "  public void testParseInto_monthDay_feb29_tokyo_endOfYear() {\n  DateTimeFormatter f = DateTimeFormat.forPattern(\"M d\").withLocale(Locale.UK);\n  MutableDateTime result = new MutableDateTime(2004, 12, 31, 23, 59, 59, 999, TOKYO);\n  assertEquals(4, f.parseInto(result, \"2 29\", 0));\n  assertEquals(new MutableDateTime(2004, 2, 29, 23, 59, 59, 999, TOKYO), result);\n  }",
        "stack": [
          "FieldUtils.verifyValueBounds line 220, PreciseDurationDateTimeField.set line 78, DateTimeParserBucket$SavedField.set line 483, DateTimeParserBucket.computeMillis line 366, DateTimeParserBucket.computeMillis line 359, DateTimeFormatter.parseInto line 715, TestDateTimeFormatter.testParseInto_monthDay_feb29_tokyo_endOfYear line 960"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/joda/time/format/DateTimeFormatter.java",
      "buggy_full_code": "\npackage org.joda.time.format;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.Locale;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTime;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.Instant;\nimport org.joda.time.LocalDate;\nimport org.joda.time.LocalDateTime;\nimport org.joda.time.LocalTime;\nimport org.joda.time.MutableDateTime;\nimport org.joda.time.ReadWritableInstant;\nimport org.joda.time.ReadableInstant;\nimport org.joda.time.ReadablePartial;\n\n\npublic class DateTimeFormatter { private final DateTimePrinter iPrinter; private final DateTimeParser iParser; private final Locale iLocale; private final boolean iOffsetParsed; private final Chronology iChrono; private final DateTimeZone iZone; private final Integer iPivotYear; private final int iDefaultYear; public DateTimeFormatter( DateTimePrinter printer, DateTimeParser parser) {\n        super();\n        iPrinter = printer;\n        iParser = parser;\n        iLocale = null;\n        iOffsetParsed = false;\n        iChrono = null;\n        iZone = null;\n        iPivotYear = null;\n        iDefaultYear = 2000;\n    }\n\n    \n    private DateTimeFormatter( DateTimePrinter printer, DateTimeParser parser, Locale locale, boolean offsetParsed, Chronology chrono, DateTimeZone zone, Integer pivotYear, int defaultYear) {\n        super();\n        iPrinter = printer;\n        iParser = parser;\n        iLocale = locale;\n        iOffsetParsed = offsetParsed;\n        iChrono = chrono;\n        iZone = zone;\n        iPivotYear = pivotYear;\n        iDefaultYear = defaultYear;\n    }\n\n    \n    \n    public boolean isPrinter() {\n        return (iPrinter != null);\n    }\n\n    \n    public DateTimePrinter getPrinter() {\n        return iPrinter;\n    }\n\n    \n    public boolean isParser() {\n        return (iParser != null);\n    }\n\n    \n    public DateTimeParser getParser() {\n        return iParser;\n    }\n\n    \n    \n    public DateTimeFormatter withLocale(Locale locale) {\n        if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, locale,\n                iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear);\n    }\n\n    \n    public Locale getLocale() {\n        return iLocale;\n    }\n\n    \n    \n    public DateTimeFormatter withOffsetParsed() {\n        if (iOffsetParsed == true) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                true, iChrono, null, iPivotYear, iDefaultYear);\n    }\n\n    \n    public boolean isOffsetParsed() {\n        return iOffsetParsed;\n    }\n\n    \n    \n    public DateTimeFormatter withChronology(Chronology chrono) {\n        if (iChrono == chrono) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);\n    }\n\n    \n    public Chronology getChronology() {\n        return iChrono;\n    }\n\n    \n    @Deprecated\n    public Chronology getChronolgy() {\n        return iChrono;\n    }\n\n    \n    \n    public DateTimeFormatter withZoneUTC() {\n        return withZone(DateTimeZone.UTC);\n    }\n\n    \n    public DateTimeFormatter withZone(DateTimeZone zone) {\n        if (iZone == zone) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                false, iChrono, zone, iPivotYear, iDefaultYear);\n    }\n\n    \n    public DateTimeZone getZone() {\n        return iZone;\n    }\n\n    \n    \n    public DateTimeFormatter withPivotYear(Integer pivotYear) {\n        if (iPivotYear == pivotYear || (iPivotYear != null && iPivotYear.equals(pivotYear))) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                iOffsetParsed, iChrono, iZone, pivotYear, iDefaultYear);\n    }\n\n    \n    public DateTimeFormatter withPivotYear(int pivotYear) {\n        return withPivotYear(Integer.valueOf(pivotYear));\n    }\n\n    \n    public Integer getPivotYear() {\n      return iPivotYear;\n    }\n\n    \n    \n    public DateTimeFormatter withDefaultYear(int defaultYear) {\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                iOffsetParsed, iChrono, iZone, iPivotYear, defaultYear);\n    }\n\n    \n    public int getDefaultYear() {\n      return iDefaultYear;\n    }\n\n    \n    \n    public void printTo(StringBuffer buf, ReadableInstant instant) {\n        long millis = DateTimeUtils.getInstantMillis(instant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n        printTo(buf, millis, chrono);\n    }\n\n    \n    public void printTo(Writer out, ReadableInstant instant) throws IOException {\n        long millis = DateTimeUtils.getInstantMillis(instant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n        printTo(out, millis, chrono);\n    }\n\n    \n    public void printTo(Appendable appendable, ReadableInstant instant) throws IOException {\n        appendable.append(print(instant));\n    }\n\n    \n    \n    public void printTo(StringBuffer buf, long instant) {\n        printTo(buf, instant, null);\n    }\n\n    \n    public void printTo(Writer out, long instant) throws IOException {\n        printTo(out, instant, null);\n    }\n\n    \n    public void printTo(Appendable appendable, long instant) throws IOException {\n        appendable.append(print(instant));\n    }\n\n    \n    \n    public void printTo(StringBuffer buf, ReadablePartial partial) {\n        DateTimePrinter printer = requirePrinter();\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        printer.printTo(buf, partial, iLocale);\n    }\n\n    \n    public void printTo(Writer out, ReadablePartial partial) throws IOException {\n        DateTimePrinter printer = requirePrinter();\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        printer.printTo(out, partial, iLocale);\n    }\n\n    \n    public void printTo(Appendable appendable, ReadablePartial partial) throws IOException {\n        appendable.append(print(partial));\n    }\n\n    \n    \n    public String print(ReadableInstant instant) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, instant);\n        return buf.toString();\n    }\n\n    \n    public String print(long instant) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, instant);\n        return buf.toString();\n    }\n\n    \n    public String print(ReadablePartial partial) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, partial);\n        return buf.toString();\n    }\n\n    private void printTo(StringBuffer buf, long instant, Chronology chrono) {\n        DateTimePrinter printer = requirePrinter();\n        chrono = selectChronology(chrono);\n        \n        \n        DateTimeZone zone = chrono.getZone();\n        int offset = zone.getOffset(instant);\n        long adjustedInstant = instant + offset;\n        if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\n            \n            zone = DateTimeZone.UTC;\n            offset = 0;\n            adjustedInstant = instant;\n        }\n        printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n    }\n\n    private void printTo(Writer buf, long instant, Chronology chrono) throws IOException {\n        DateTimePrinter printer = requirePrinter();\n        chrono = selectChronology(chrono);\n        \n        \n        DateTimeZone zone = chrono.getZone();\n        int offset = zone.getOffset(instant);\n        long adjustedInstant = instant + offset;\n        if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\n            \n            zone = DateTimeZone.UTC;\n            offset = 0;\n            adjustedInstant = instant;\n        }\n        printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n    }\n\n    \n    private DateTimePrinter requirePrinter() {\n        DateTimePrinter printer = iPrinter;\n        if (printer == null) {\n            throw new UnsupportedOperationException(\"Printing not supported\");\n        }\n        return printer;\n    }\n\n    \n    \n    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        int defaultYear = chrono.year().get(instantLocal);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }\n\n    \n    public long parseMillis(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(iChrono);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                return bucket.computeMillis(true, text);\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    \n    public LocalDate parseLocalDate(String text) {\n        return parseLocalDateTime(text).toLocalDate();\n    }\n\n    \n    public LocalTime parseLocalTime(String text) {\n        return parseLocalDateTime(text).toLocalTime();\n    }\n\n    \n    public LocalDateTime parseLocalDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null).withUTC();  \n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (bucket.getOffsetInteger() != null) {  \n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                return new LocalDateTime(millis, chrono);\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    \n    public DateTime parseDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                DateTime dt = new DateTime(millis, chrono);\n                if (iZone != null) {\n                    dt = dt.withZone(iZone);\n                }\n                return dt;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    \n    public MutableDateTime parseMutableDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                MutableDateTime dt = new MutableDateTime(millis, chrono);\n                if (iZone != null) {\n                    dt.setZone(iZone);\n                }\n                return dt;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    \n    private DateTimeParser requireParser() {\n        DateTimeParser parser = iParser;\n        if (parser == null) {\n            throw new UnsupportedOperationException(\"Parsing not supported\");\n        }\n        return parser;\n    }\n\n    \n    \n    private Chronology selectChronology(Chronology chrono) {\n        chrono = DateTimeUtils.getChronology(chrono);\n        if (iChrono != null) {\n            chrono = iChrono;\n        }\n        if (iZone != null) {\n            chrono = chrono.withZone(iZone);\n        }\n        return chrono;\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.joda.time.format;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.Locale;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTime;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.Instant;\nimport org.joda.time.LocalDate;\nimport org.joda.time.LocalDateTime;\nimport org.joda.time.LocalTime;\nimport org.joda.time.MutableDateTime;\nimport org.joda.time.ReadWritableInstant;\nimport org.joda.time.ReadableInstant;\nimport org.joda.time.ReadablePartial;\n\n\npublic class DateTimeFormatter { private final DateTimePrinter iPrinter; private final DateTimeParser iParser; private final Locale iLocale; private final boolean iOffsetParsed; private final Chronology iChrono; private final DateTimeZone iZone; private final Integer iPivotYear; private final int iDefaultYear; public DateTimeFormatter( DateTimePrinter printer, DateTimeParser parser) {\n        super();\n        iPrinter = printer;\n        iParser = parser;\n        iLocale = null;\n        iOffsetParsed = false;\n        iChrono = null;\n        iZone = null;\n        iPivotYear = null;\n        iDefaultYear = 2000;\n    }\n\n    \n    private DateTimeFormatter( DateTimePrinter printer, DateTimeParser parser, Locale locale, boolean offsetParsed, Chronology chrono, DateTimeZone zone, Integer pivotYear, int defaultYear) {\n        super();\n        iPrinter = printer;\n        iParser = parser;\n        iLocale = locale;\n        iOffsetParsed = offsetParsed;\n        iChrono = chrono;\n        iZone = zone;\n        iPivotYear = pivotYear;\n        iDefaultYear = defaultYear;\n    }\n\n    \n    \n    public boolean isPrinter() {\n        return (iPrinter != null);\n    }\n\n    \n    public DateTimePrinter getPrinter() {\n        return iPrinter;\n    }\n\n    \n    public boolean isParser() {\n        return (iParser != null);\n    }\n\n    \n    public DateTimeParser getParser() {\n        return iParser;\n    }\n\n    \n    \n    public DateTimeFormatter withLocale(Locale locale) {\n        if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, locale,\n                iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear);\n    }\n\n    \n    public Locale getLocale() {\n        return iLocale;\n    }\n\n    \n    \n    public DateTimeFormatter withOffsetParsed() {\n        if (iOffsetParsed == true) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                true, iChrono, null, iPivotYear, iDefaultYear);\n    }\n\n    \n    public boolean isOffsetParsed() {\n        return iOffsetParsed;\n    }\n\n    \n    \n    public DateTimeFormatter withChronology(Chronology chrono) {\n        if (iChrono == chrono) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);\n    }\n\n    \n    public Chronology getChronology() {\n        return iChrono;\n    }\n\n    \n    @Deprecated\n    public Chronology getChronolgy() {\n        return iChrono;\n    }\n\n    \n    \n    public DateTimeFormatter withZoneUTC() {\n        return withZone(DateTimeZone.UTC);\n    }\n\n    \n    public DateTimeFormatter withZone(DateTimeZone zone) {\n        if (iZone == zone) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                false, iChrono, zone, iPivotYear, iDefaultYear);\n    }\n\n    \n    public DateTimeZone getZone() {\n        return iZone;\n    }\n\n    \n    \n    public DateTimeFormatter withPivotYear(Integer pivotYear) {\n        if (iPivotYear == pivotYear || (iPivotYear != null && iPivotYear.equals(pivotYear))) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                iOffsetParsed, iChrono, iZone, pivotYear, iDefaultYear);\n    }\n\n    \n    public DateTimeFormatter withPivotYear(int pivotYear) {\n        return withPivotYear(Integer.valueOf(pivotYear));\n    }\n\n    \n    public Integer getPivotYear() {\n      return iPivotYear;\n    }\n\n    \n    \n    public DateTimeFormatter withDefaultYear(int defaultYear) {\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                iOffsetParsed, iChrono, iZone, iPivotYear, defaultYear);\n    }\n\n    \n    public int getDefaultYear() {\n      return iDefaultYear;\n    }\n\n    \n    \n    public void printTo(StringBuffer buf, ReadableInstant instant) {\n        long millis = DateTimeUtils.getInstantMillis(instant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n        printTo(buf, millis, chrono);\n    }\n\n    \n    public void printTo(Writer out, ReadableInstant instant) throws IOException {\n        long millis = DateTimeUtils.getInstantMillis(instant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n        printTo(out, millis, chrono);\n    }\n\n    \n    public void printTo(Appendable appendable, ReadableInstant instant) throws IOException {\n        appendable.append(print(instant));\n    }\n\n    \n    \n    public void printTo(StringBuffer buf, long instant) {\n        printTo(buf, instant, null);\n    }\n\n    \n    public void printTo(Writer out, long instant) throws IOException {\n        printTo(out, instant, null);\n    }\n\n    \n    public void printTo(Appendable appendable, long instant) throws IOException {\n        appendable.append(print(instant));\n    }\n\n    \n    \n    public void printTo(StringBuffer buf, ReadablePartial partial) {\n        DateTimePrinter printer = requirePrinter();\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        printer.printTo(buf, partial, iLocale);\n    }\n\n    \n    public void printTo(Writer out, ReadablePartial partial) throws IOException {\n        DateTimePrinter printer = requirePrinter();\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        printer.printTo(out, partial, iLocale);\n    }\n\n    \n    public void printTo(Appendable appendable, ReadablePartial partial) throws IOException {\n        appendable.append(print(partial));\n    }\n\n    \n    \n    public String print(ReadableInstant instant) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, instant);\n        return buf.toString();\n    }\n\n    \n    public String print(long instant) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, instant);\n        return buf.toString();\n    }\n\n    \n    public String print(ReadablePartial partial) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, partial);\n        return buf.toString();\n    }\n\n    private void printTo(StringBuffer buf, long instant, Chronology chrono) {\n        DateTimePrinter printer = requirePrinter();\n        chrono = selectChronology(chrono);\n        \n        \n        DateTimeZone zone = chrono.getZone();\n        int offset = zone.getOffset(instant);\n        long adjustedInstant = instant + offset;\n        if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\n            \n            zone = DateTimeZone.UTC;\n            offset = 0;\n            adjustedInstant = instant;\n        }\n        printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n    }\n\n    private void printTo(Writer buf, long instant, Chronology chrono) throws IOException {\n        DateTimePrinter printer = requirePrinter();\n        chrono = selectChronology(chrono);\n        \n        \n        DateTimeZone zone = chrono.getZone();\n        int offset = zone.getOffset(instant);\n        long adjustedInstant = instant + offset;\n        if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\n            \n            zone = DateTimeZone.UTC;\n            offset = 0;\n            adjustedInstant = instant;\n        }\n        printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n    }\n\n    \n    private DateTimePrinter requirePrinter() {\n        DateTimePrinter printer = iPrinter;\n        if (printer == null) {\n            throw new UnsupportedOperationException(\"Printing not supported\");\n        }\n        return printer;\n    }\n\n    \n    \n    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }\n\n    \n    public long parseMillis(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(iChrono);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                return bucket.computeMillis(true, text);\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    \n    public LocalDate parseLocalDate(String text) {\n        return parseLocalDateTime(text).toLocalDate();\n    }\n\n    \n    public LocalTime parseLocalTime(String text) {\n        return parseLocalDateTime(text).toLocalTime();\n    }\n\n    \n    public LocalDateTime parseLocalDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null).withUTC();  \n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (bucket.getOffsetInteger() != null) {  \n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                return new LocalDateTime(millis, chrono);\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    \n    public DateTime parseDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                DateTime dt = new DateTime(millis, chrono);\n                if (iZone != null) {\n                    dt = dt.withZone(iZone);\n                }\n                return dt;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    \n    public MutableDateTime parseMutableDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                MutableDateTime dt = new MutableDateTime(millis, chrono);\n                if (iZone != null) {\n                    dt.setZone(iZone);\n                }\n                return dt;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    \n    private DateTimeParser requireParser() {\n        DateTimeParser parser = iParser;\n        if (parser == null) {\n            throw new UnsupportedOperationException(\"Parsing not supported\");\n        }\n        return parser;\n    }\n\n    \n    \n    private Chronology selectChronology(Chronology chrono) {\n        chrono = DateTimeUtils.getChronology(chrono);\n        if (iChrono != null) {\n            chrono = iChrono;\n        }\n        if (iZone != null) {\n            chrono = chrono.withZone(iZone);\n        }\n        return chrono;\n    }\n\n}\n",
      "buggy_signatures": [
        "public class DateTimeFormatter { private final DateTimePrinter iPrinter; private final DateTimeParser iParser; private final Locale iLocale; private final boolean iOffsetParsed; private final Chronology iChrono; private final DateTimeZone iZone; private final Integer iPivotYear; private final int iDefaultYear; public DateTimeFormatter( DateTimePrinter printer, DateTimeParser parser)",
        "private DateTimeFormatter( DateTimePrinter printer, DateTimeParser parser, Locale locale, boolean offsetParsed, Chronology chrono, DateTimeZone zone, Integer pivotYear, int defaultYear)",
        "public boolean isPrinter()",
        "public DateTimePrinter getPrinter()",
        "public boolean isParser()",
        "public DateTimeParser getParser()",
        "public DateTimeFormatter withLocale(Locale locale)",
        "public Locale getLocale()",
        "public DateTimeFormatter withOffsetParsed()",
        "public boolean isOffsetParsed()",
        "public DateTimeFormatter withChronology(Chronology chrono)",
        "public Chronology getChronology()",
        "public Chronology getChronolgy()",
        "public DateTimeFormatter withZoneUTC()",
        "public DateTimeFormatter withZone(DateTimeZone zone)",
        "public DateTimeZone getZone()",
        "public DateTimeFormatter withPivotYear(Integer pivotYear)",
        "public DateTimeFormatter withPivotYear(int pivotYear)",
        "public Integer getPivotYear()",
        "public DateTimeFormatter withDefaultYear(int defaultYear)",
        "public int getDefaultYear()",
        "public void printTo(StringBuffer buf, ReadableInstant instant)",
        "public void printTo(Writer out, ReadableInstant instant) throws IOException",
        "public void printTo(Appendable appendable, ReadableInstant instant) throws IOException",
        "public void printTo(StringBuffer buf, long instant)",
        "public void printTo(Writer out, long instant) throws IOException",
        "public void printTo(Appendable appendable, long instant) throws IOException",
        "public void printTo(StringBuffer buf, ReadablePartial partial)",
        "public void printTo(Writer out, ReadablePartial partial) throws IOException",
        "public void printTo(Appendable appendable, ReadablePartial partial) throws IOException",
        "public String print(ReadableInstant instant)",
        "public String print(long instant)",
        "public String print(ReadablePartial partial)",
        "private void printTo(StringBuffer buf, long instant, Chronology chrono)",
        "private void printTo(Writer buf, long instant, Chronology chrono) throws IOException",
        "private DateTimePrinter requirePrinter()",
        "public int parseInto(ReadWritableInstant instant, String text, int position)",
        "public long parseMillis(String text)",
        "public LocalDate parseLocalDate(String text)",
        "public LocalTime parseLocalTime(String text)",
        "public LocalDateTime parseLocalDateTime(String text)",
        "public DateTime parseDateTime(String text)",
        "public MutableDateTime parseMutableDateTime(String text)",
        "private DateTimeParser requireParser()",
        "private Chronology selectChronology(Chronology chrono)"
      ],
      "fixed_signatures": [
        "public class DateTimeFormatter { private final DateTimePrinter iPrinter; private final DateTimeParser iParser; private final Locale iLocale; private final boolean iOffsetParsed; private final Chronology iChrono; private final DateTimeZone iZone; private final Integer iPivotYear; private final int iDefaultYear; public DateTimeFormatter( DateTimePrinter printer, DateTimeParser parser)",
        "private DateTimeFormatter( DateTimePrinter printer, DateTimeParser parser, Locale locale, boolean offsetParsed, Chronology chrono, DateTimeZone zone, Integer pivotYear, int defaultYear)",
        "public boolean isPrinter()",
        "public DateTimePrinter getPrinter()",
        "public boolean isParser()",
        "public DateTimeParser getParser()",
        "public DateTimeFormatter withLocale(Locale locale)",
        "public Locale getLocale()",
        "public DateTimeFormatter withOffsetParsed()",
        "public boolean isOffsetParsed()",
        "public DateTimeFormatter withChronology(Chronology chrono)",
        "public Chronology getChronology()",
        "public Chronology getChronolgy()",
        "public DateTimeFormatter withZoneUTC()",
        "public DateTimeFormatter withZone(DateTimeZone zone)",
        "public DateTimeZone getZone()",
        "public DateTimeFormatter withPivotYear(Integer pivotYear)",
        "public DateTimeFormatter withPivotYear(int pivotYear)",
        "public Integer getPivotYear()",
        "public DateTimeFormatter withDefaultYear(int defaultYear)",
        "public int getDefaultYear()",
        "public void printTo(StringBuffer buf, ReadableInstant instant)",
        "public void printTo(Writer out, ReadableInstant instant) throws IOException",
        "public void printTo(Appendable appendable, ReadableInstant instant) throws IOException",
        "public void printTo(StringBuffer buf, long instant)",
        "public void printTo(Writer out, long instant) throws IOException",
        "public void printTo(Appendable appendable, long instant) throws IOException",
        "public void printTo(StringBuffer buf, ReadablePartial partial)",
        "public void printTo(Writer out, ReadablePartial partial) throws IOException",
        "public void printTo(Appendable appendable, ReadablePartial partial) throws IOException",
        "public String print(ReadableInstant instant)",
        "public String print(long instant)",
        "public String print(ReadablePartial partial)",
        "private void printTo(StringBuffer buf, long instant, Chronology chrono)",
        "private void printTo(Writer buf, long instant, Chronology chrono) throws IOException",
        "private DateTimePrinter requirePrinter()",
        "public int parseInto(ReadWritableInstant instant, String text, int position)",
        "public long parseMillis(String text)",
        "public LocalDate parseLocalDate(String text)",
        "public LocalTime parseLocalTime(String text)",
        "public LocalDateTime parseLocalDateTime(String text)",
        "public DateTime parseDateTime(String text)",
        "public MutableDateTime parseMutableDateTime(String text)",
        "private DateTimeParser requireParser()",
        "private Chronology selectChronology(Chronology chrono)"
      ],
      "methods": [
        {
          "buggy_method": "  public int parseInto(ReadWritableInstant instant, String text, int position) {\n  DateTimeParser parser = requireParser();\n  if (instant == null) {\n  throw new IllegalArgumentException(\"Instant must not be null\");\n  }\n  \n  long instantMillis = instant.getMillis();\n  Chronology chrono = instant.getChronology();\n  long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n  chrono = selectChronology(chrono);\n  int defaultYear = chrono.year().get(instantLocal);\n  \n  DateTimeParserBucket bucket = new DateTimeParserBucket(\n  instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n  int newPos = parser.parseInto(bucket, text, position);\n  instant.setMillis(bucket.computeMillis(false, text));\n  if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n  int parsedOffset = bucket.getOffsetInteger();\n  DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n  chrono = chrono.withZone(parsedZone);\n  } else if (bucket.getZone() != null) {\n  chrono = chrono.withZone(bucket.getZone());\n  }\n  instant.setChronology(chrono);\n  if (iZone != null) {\n  instant.setZone(iZone);\n  }\n  return newPos;\n  }",
          "fixed_method": "  public int parseInto(ReadWritableInstant instant, String text, int position) {\n  DateTimeParser parser = requireParser();\n  if (instant == null) {\n  throw new IllegalArgumentException(\"Instant must not be null\");\n  }\n  \n  long instantMillis = instant.getMillis();\n  Chronology chrono = instant.getChronology();\n  int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);\n  long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n  chrono = selectChronology(chrono);\n  \n  DateTimeParserBucket bucket = new DateTimeParserBucket(\n  instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n  int newPos = parser.parseInto(bucket, text, position);\n  instant.setMillis(bucket.computeMillis(false, text));\n  if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n  int parsedOffset = bucket.getOffsetInteger();\n  DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n  chrono = chrono.withZone(parsedZone);\n  } else if (bucket.getZone() != null) {\n  chrono = chrono.withZone(bucket.getZone());\n  }\n  instant.setChronology(chrono);\n  if (iZone != null) {\n  instant.setZone(iZone);\n  }\n  return newPos;\n  }",
          "diff": [
            "@@ -705,9 +705,9 @@",
            "         \n",
            "         long instantMillis = instant.getMillis();\n",
            "         Chronology chrono = instant.getChronology();\n",
            "+        int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);\n",
            "         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n",
            "         chrono = selectChronology(chrono);\n",
            "-        int defaultYear = chrono.year().get(instantLocal);\n",
            "         \n",
            "         DateTimeParserBucket bucket = new DateTimeParserBucket(\n",
            "             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
