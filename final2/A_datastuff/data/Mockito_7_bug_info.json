{
  "bug_id": "7",
  "failed_tests": {
    "org.mockitousage.bugs.deepstubs.DeepStubFailingWhenGenricNestedAsRawTypeTest": [
      {
        "methodName": "discoverDeepMockingOfGenerics",
        "error": "org.mockito.exceptions.base.MockitoException",
        "message": "Raw extraction not supported for : 'null'",
        "fail_line": "    when(myMock1.getNested().getNested().returnSomething()).thenReturn(\"Hello World.\");",
        "test_source": "  public void discoverDeepMockingOfGenerics() {\n  MyClass1 myMock1 = mock(MyClass1.class, RETURNS_DEEP_STUBS);\n  when(myMock1.getNested().getNested().returnSomething()).thenReturn(\"Hello World.\");\n  }",
        "stack": [
          "GenericMetadataSupport$TypeVariableReturnType.extractRawTypeOf line 407, GenericMetadataSupport$TypeVariableReturnType.extractRawTypeOf line 405, GenericMetadataSupport$TypeVariableReturnType.rawType line 385, ReturnsDeepStubs.answer line 51, MockHandlerImpl.handle line 93, NullResultGuardian.handle line 29, InvocationNotifierHandler.handle line 38, MethodInterceptorFilter.intercept line 59, DeepStubFailingWhenGenricNestedAsRawTypeTest.discoverDeepMockingOfGenerics line 26"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/mockito/internal/util/reflection/GenericMetadataSupport.java",
      "buggy_full_code": "\npackage org.mockito.internal.util.reflection;\n\n\nimport org.mockito.exceptions.base.MockitoException;\nimport org.mockito.internal.util.Checks;\n\nimport java.lang.reflect.*;\nimport java.util.*;\n\n\n\npublic abstract class GenericMetadataSupport { protected Map<TypeVariable, Type> contextualActualTypeParameters = new HashMap<TypeVariable, Type>(); protected void registerTypeVariablesOn(Type classType) {\n        if (!(classType instanceof ParameterizedType)) {\n            return;\n        }\n        ParameterizedType parameterizedType = (ParameterizedType) classType;\n        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n        for (int i = 0; i < actualTypeArguments.length; i++) {\n            TypeVariable typeParameter = typeParameters[i];\n            Type actualTypeArgument = actualTypeArguments[i];\n\n            if (actualTypeArgument instanceof WildcardType) {\n                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n            } else if (typeParameter != actualTypeArgument) {\n                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n            }\n            \n        }\n    }\n\n    protected void registerTypeParametersOn(TypeVariable[] typeParameters) {\n        for (TypeVariable type : typeParameters) {\n            registerTypeVariableIfNotPresent(type);\n        }\n    }\n\n    private void registerTypeVariableIfNotPresent(TypeVariable typeVariable) {\n        if (!contextualActualTypeParameters.containsKey(typeVariable)) {\n            contextualActualTypeParameters.put(typeVariable, boundsOf(typeVariable));\n            \n        }\n    }\n\n    \n    private BoundedType boundsOf(TypeVariable typeParameter) {\n        if (typeParameter.getBounds()[0] instanceof TypeVariable) {\n            return boundsOf((TypeVariable) typeParameter.getBounds()[0]);\n        }\n        return new TypeVarBoundedType(typeParameter);\n    }\n\n    \n    private BoundedType boundsOf(WildcardType wildCard) {\n        \n\n        WildCardBoundedType wildCardBoundedType = new WildCardBoundedType(wildCard);\n        if (wildCardBoundedType.firstBound() instanceof TypeVariable) {\n            return boundsOf((TypeVariable) wildCardBoundedType.firstBound());\n        }\n\n        return wildCardBoundedType;\n    }\n\n\n\n    \n    public abstract Class<?> rawType(); public List<Type> extraInterfaces() {\n        return Collections.emptyList();\n    }\n\n    \n    public Class<?>[] rawExtraInterfaces() {\n        return new Class[0];\n    }\n\n    \n    public boolean hasRawExtraInterfaces() {\n        return rawExtraInterfaces().length > 0;\n    }\n\n\n\n    \n    public Map<TypeVariable, Type> actualTypeArguments() {\n        TypeVariable[] typeParameters = rawType().getTypeParameters();\n        LinkedHashMap<TypeVariable, Type> actualTypeArguments = new LinkedHashMap<TypeVariable, Type>();\n\n        for (TypeVariable typeParameter : typeParameters) {\n\n            Type actualType = getActualTypeArgumentFor(typeParameter);\n\n            actualTypeArguments.put(typeParameter, actualType);\n            \n        }\n\n        return actualTypeArguments;\n    }\n\n    protected Type getActualTypeArgumentFor(TypeVariable typeParameter) {\n        Type type = this.contextualActualTypeParameters.get(typeParameter);\n        if (type instanceof TypeVariable) {\n            TypeVariable typeVariable = (TypeVariable) type;\n            return getActualTypeArgumentFor(typeVariable);\n        }\n\n        return type;\n    }\n\n\n\n    \n    public GenericMetadataSupport resolveGenericReturnType(Method method) {\n        Type genericReturnType = method.getGenericReturnType();\n        \n\n        if (genericReturnType instanceof Class) {\n            return new NotGenericReturnTypeSupport(genericReturnType);\n        }\n        if (genericReturnType instanceof ParameterizedType) {\n            return new ParameterizedReturnType(this, method.getTypeParameters(), (ParameterizedType) method.getGenericReturnType());\n        }\n        if (genericReturnType instanceof TypeVariable) {\n            return new TypeVariableReturnType(this, method.getTypeParameters(), (TypeVariable) genericReturnType);\n        }\n\n        throw new MockitoException(\"Ouch, it shouldn't happen, type '\" + genericReturnType.getClass().getCanonicalName() + \"' on method : '\" + method.toGenericString() + \"' is not supported : \" + genericReturnType);\n    }\n\n    \n    public static GenericMetadataSupport inferFrom(Type type) {\n        Checks.checkNotNull(type, \"type\");\n        if (type instanceof Class) {\n            return new FromClassGenericMetadataSupport((Class<?>) type);\n        }\n        if (type instanceof ParameterizedType) {\n            return new FromParameterizedTypeGenericMetadataSupport((ParameterizedType) type);\n        }\n\n        throw new MockitoException(\"Type meta-data for this Type (\" + type.getClass().getCanonicalName() + \") is not supported : \" + type);\n    }\n\n\n    \n    \n    \n\n    \n    private static class FromClassGenericMetadataSupport extends GenericMetadataSupport { private final Class<?> clazz; public FromClassGenericMetadataSupport(Class<?> clazz) {\n            this.clazz = clazz;\n\n            for (Class currentExploredClass = clazz;\n                 currentExploredClass != null && currentExploredClass != Object.class;\n                 currentExploredClass = superClassOf(currentExploredClass)\n                ) {\n                readActualTypeParametersOnDeclaringClass(currentExploredClass);\n            }\n        }\n\n        private Class superClassOf(Class currentExploredClass) {\n            Type genericSuperclass = currentExploredClass.getGenericSuperclass();\n            if (genericSuperclass instanceof ParameterizedType) {\n                Type rawType = ((ParameterizedType) genericSuperclass).getRawType();\n                return (Class) rawType;\n            }\n            return (Class) genericSuperclass;\n        }\n\n        private void readActualTypeParametersOnDeclaringClass(Class<?> clazz) {\n            registerTypeParametersOn(clazz.getTypeParameters());\n            registerTypeVariablesOn(clazz.getGenericSuperclass());\n            for (Type genericInterface : clazz.getGenericInterfaces()) {\n                registerTypeVariablesOn(genericInterface);\n            }\n        }\n\n        @Override\n        public Class<?> rawType() {\n            return clazz;\n        }\n    }\n\n\n    \n    private static class FromParameterizedTypeGenericMetadataSupport extends GenericMetadataSupport { private final ParameterizedType parameterizedType; public FromParameterizedTypeGenericMetadataSupport(ParameterizedType parameterizedType) {\n            this.parameterizedType = parameterizedType;\n            readActualTypeParameters();\n        }\n\n        private void readActualTypeParameters() {\n            registerTypeVariablesOn(parameterizedType.getRawType());\n            registerTypeVariablesOn(parameterizedType);\n        }\n\n        @Override\n        public Class<?> rawType() {\n            return (Class<?>) parameterizedType.getRawType();\n        }\n    }\n\n\n    \n    private static class ParameterizedReturnType extends GenericMetadataSupport { private final ParameterizedType parameterizedType; private final TypeVariable[] typeParameters; public ParameterizedReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, ParameterizedType parameterizedType) {\n            this.parameterizedType = parameterizedType;\n            this.typeParameters = typeParameters;\n            this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n\n            readTypeParameters();\n            readTypeVariables();\n        }\n\n        private void readTypeParameters() {\n            registerTypeParametersOn(typeParameters);\n        }\n\n        private void readTypeVariables() {\n            registerTypeVariablesOn(parameterizedType);\n        }\n\n        @Override\n        public Class<?> rawType() {\n            return (Class<?>) parameterizedType.getRawType();\n        }\n\n    }\n\n\n    \n    private static class TypeVariableReturnType extends GenericMetadataSupport { private final TypeVariable typeVariable; private final TypeVariable[] typeParameters; private Class<?> rawType; public TypeVariableReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, TypeVariable typeVariable) {\n            this.typeParameters = typeParameters;\n            this.typeVariable = typeVariable;\n            this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n\n            readTypeParameters();\n            readTypeVariables();\n        }\n\n        private void readTypeParameters() {\n            registerTypeParametersOn(typeParameters);\n        }\n\n        private void readTypeVariables() {\n            for (Type type : typeVariable.getBounds()) {\n                registerTypeVariablesOn(type);\n            }\n            registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n        }\n\n        @Override\n        public Class<?> rawType() {\n            if (rawType == null) {\n                rawType = extractRawTypeOf(typeVariable);\n            }\n            return rawType;\n        }\n\n        private Class<?> extractRawTypeOf(Type type) {\n            if (type instanceof Class) {\n                return (Class<?>) type;\n            }\n            if (type instanceof ParameterizedType) {\n                return (Class<?>) ((ParameterizedType) type).getRawType();\n            }\n            if (type instanceof BoundedType) {\n                return extractRawTypeOf(((BoundedType) type).firstBound());\n            }\n            if (type instanceof TypeVariable) {\n                \n                return extractRawTypeOf(contextualActualTypeParameters.get(type));\n            }\n            throw new MockitoException(\"Raw extraction not supported for : '\" + type + \"'\");\n        }\n\n        @Override\n        public List<Type> extraInterfaces() {\n            Type type = extractActualBoundedTypeOf(typeVariable);\n            if (type instanceof BoundedType) {\n                return Arrays.asList(((BoundedType) type).interfaceBounds());\n            }\n            if (type instanceof ParameterizedType) {\n                return Collections.singletonList(type);\n            }\n            if (type instanceof Class) {\n                return Collections.emptyList();\n            }\n            throw new MockitoException(\"Cannot extract extra-interfaces from '\" + typeVariable + \"' : '\" + type + \"'\");\n        }\n\n        \n        public Class<?>[] rawExtraInterfaces() {\n            List<Type> extraInterfaces = extraInterfaces();\n            List<Class<?>> rawExtraInterfaces = new ArrayList<Class<?>>();\n            for (Type extraInterface : extraInterfaces) {\n                Class<?> rawInterface = extractRawTypeOf(extraInterface);\n                \n                if(!rawType().equals(rawInterface)) {\n                    rawExtraInterfaces.add(rawInterface);\n                }\n            }\n            return rawExtraInterfaces.toArray(new Class[rawExtraInterfaces.size()]);\n        }\n\n        private Type extractActualBoundedTypeOf(Type type) {\n            if (type instanceof TypeVariable) {\n                \n                return extractActualBoundedTypeOf(contextualActualTypeParameters.get(type));\n            }\n            if (type instanceof BoundedType) {\n                Type actualFirstBound = extractActualBoundedTypeOf(((BoundedType) type).firstBound());\n                if (!(actualFirstBound instanceof BoundedType)) {\n                    return type; \n                }\n                return actualFirstBound;\n            }\n            return type; \n        }\n    }\n\n\n\n    \n    private static class NotGenericReturnTypeSupport extends GenericMetadataSupport { private final Class<?> returnType; public NotGenericReturnTypeSupport(Type genericReturnType) {\n            returnType = (Class<?>) genericReturnType;\n        }\n\n        @Override\n        public Class<?> rawType() {\n            return returnType;\n        }\n    }\n\n\n\n    \n    public interface BoundedType extends Type { Type firstBound(); Type[] interfaceBounds(); } public static class TypeVarBoundedType implements BoundedType {\n        private final TypeVariable typeVariable; public TypeVarBoundedType(TypeVariable typeVariable) {\n            this.typeVariable = typeVariable;\n        }\n\n        \n        public Type firstBound() {\n            return typeVariable.getBounds()[0]; \n        }\n\n        \n        public Type[] interfaceBounds() {\n            Type[] interfaceBounds = new Type[typeVariable.getBounds().length - 1];\n            System.arraycopy(typeVariable.getBounds(), 1, interfaceBounds, 0, typeVariable.getBounds().length - 1);\n            return interfaceBounds;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            return typeVariable.equals(((TypeVarBoundedType) o).typeVariable);\n\n        }\n\n        @Override\n        public int hashCode() {\n            return typeVariable.hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return \"{firstBound=\" + firstBound() + \", interfaceBounds=\" + Arrays.deepToString(interfaceBounds()) + '}';\n        }\n\n        public TypeVariable typeVariable() {\n            return typeVariable;\n        }\n    }\n\n    \n    public static class WildCardBoundedType implements BoundedType { private final WildcardType wildcard; public WildCardBoundedType(WildcardType wildcard) {\n            this.wildcard = wildcard;\n        }\n\n        \n        public Type firstBound() {\n            Type[] lowerBounds = wildcard.getLowerBounds();\n            Type[] upperBounds = wildcard.getUpperBounds();\n\n            return lowerBounds.length != 0 ? lowerBounds[0] : upperBounds[0];\n        }\n\n        \n        public Type[] interfaceBounds() {\n            return new Type[0];\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            return wildcard.equals(((TypeVarBoundedType) o).typeVariable);\n\n        }\n\n        @Override\n        public int hashCode() {\n            return wildcard.hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return \"{firstBound=\" + firstBound() + \", interfaceBounds=[]}\";\n        }\n\n        public WildcardType wildCard() {\n            return wildcard;\n        }\n    }\n\n}\n\n\n",
      "fixed_full_code": "\npackage org.mockito.internal.util.reflection;\n\n\nimport org.mockito.exceptions.base.MockitoException;\nimport org.mockito.internal.util.Checks;\n\nimport java.lang.reflect.*;\nimport java.util.*;\n\n\n\npublic abstract class GenericMetadataSupport { protected Map<TypeVariable, Type> contextualActualTypeParameters = new HashMap<TypeVariable, Type>(); protected void registerTypeVariablesOn(Type classType) {\n        if (!(classType instanceof ParameterizedType)) {\n            return;\n        }\n        ParameterizedType parameterizedType = (ParameterizedType) classType;\n        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n        for (int i = 0; i < actualTypeArguments.length; i++) {\n            TypeVariable typeParameter = typeParameters[i];\n            Type actualTypeArgument = actualTypeArguments[i];\n\n            if (actualTypeArgument instanceof WildcardType) {\n                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n            } else if (typeParameter != actualTypeArgument) {\n                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n            }\n            \n        }\n    }\n\n    protected void registerTypeParametersOn(TypeVariable[] typeParameters) {\n        for (TypeVariable type : typeParameters) {\n            registerTypeVariableIfNotPresent(type);\n        }\n    }\n\n    private void registerTypeVariableIfNotPresent(TypeVariable typeVariable) {\n        if (!contextualActualTypeParameters.containsKey(typeVariable)) {\n            contextualActualTypeParameters.put(typeVariable, boundsOf(typeVariable));\n            \n        }\n    }\n\n    \n    private BoundedType boundsOf(TypeVariable typeParameter) {\n        if (typeParameter.getBounds()[0] instanceof TypeVariable) {\n            return boundsOf((TypeVariable) typeParameter.getBounds()[0]);\n        }\n        return new TypeVarBoundedType(typeParameter);\n    }\n\n    \n    private BoundedType boundsOf(WildcardType wildCard) {\n        \n\n        WildCardBoundedType wildCardBoundedType = new WildCardBoundedType(wildCard);\n        if (wildCardBoundedType.firstBound() instanceof TypeVariable) {\n            return boundsOf((TypeVariable) wildCardBoundedType.firstBound());\n        }\n\n        return wildCardBoundedType;\n    }\n\n\n\n    \n    public abstract Class<?> rawType(); public List<Type> extraInterfaces() {\n        return Collections.emptyList();\n    }\n\n    \n    public Class<?>[] rawExtraInterfaces() {\n        return new Class[0];\n    }\n\n    \n    public boolean hasRawExtraInterfaces() {\n        return rawExtraInterfaces().length > 0;\n    }\n\n\n\n    \n    public Map<TypeVariable, Type> actualTypeArguments() {\n        TypeVariable[] typeParameters = rawType().getTypeParameters();\n        LinkedHashMap<TypeVariable, Type> actualTypeArguments = new LinkedHashMap<TypeVariable, Type>();\n\n        for (TypeVariable typeParameter : typeParameters) {\n\n            Type actualType = getActualTypeArgumentFor(typeParameter);\n\n            actualTypeArguments.put(typeParameter, actualType);\n            \n        }\n\n        return actualTypeArguments;\n    }\n\n    protected Type getActualTypeArgumentFor(TypeVariable typeParameter) {\n        Type type = this.contextualActualTypeParameters.get(typeParameter);\n        if (type instanceof TypeVariable) {\n            TypeVariable typeVariable = (TypeVariable) type;\n            return getActualTypeArgumentFor(typeVariable);\n        }\n\n        return type;\n    }\n\n\n\n    \n    public GenericMetadataSupport resolveGenericReturnType(Method method) {\n        Type genericReturnType = method.getGenericReturnType();\n        \n\n        if (genericReturnType instanceof Class) {\n            return new NotGenericReturnTypeSupport(genericReturnType);\n        }\n        if (genericReturnType instanceof ParameterizedType) {\n            return new ParameterizedReturnType(this, method.getTypeParameters(), (ParameterizedType) method.getGenericReturnType());\n        }\n        if (genericReturnType instanceof TypeVariable) {\n            return new TypeVariableReturnType(this, method.getTypeParameters(), (TypeVariable) genericReturnType);\n        }\n\n        throw new MockitoException(\"Ouch, it shouldn't happen, type '\" + genericReturnType.getClass().getCanonicalName() + \"' on method : '\" + method.toGenericString() + \"' is not supported : \" + genericReturnType);\n    }\n\n    \n    public static GenericMetadataSupport inferFrom(Type type) {\n        Checks.checkNotNull(type, \"type\");\n        if (type instanceof Class) {\n            return new FromClassGenericMetadataSupport((Class<?>) type);\n        }\n        if (type instanceof ParameterizedType) {\n            return new FromParameterizedTypeGenericMetadataSupport((ParameterizedType) type);\n        }\n\n        throw new MockitoException(\"Type meta-data for this Type (\" + type.getClass().getCanonicalName() + \") is not supported : \" + type);\n    }\n\n\n    \n    \n    \n\n    \n    private static class FromClassGenericMetadataSupport extends GenericMetadataSupport { private final Class<?> clazz; public FromClassGenericMetadataSupport(Class<?> clazz) {\n            this.clazz = clazz;\n\n            for (Class currentExploredClass = clazz;\n                 currentExploredClass != null && currentExploredClass != Object.class;\n                 currentExploredClass = superClassOf(currentExploredClass)\n                ) {\n                readActualTypeParametersOnDeclaringClass(currentExploredClass);\n            }\n        }\n\n        private Class superClassOf(Class currentExploredClass) {\n            Type genericSuperclass = currentExploredClass.getGenericSuperclass();\n            if (genericSuperclass instanceof ParameterizedType) {\n                Type rawType = ((ParameterizedType) genericSuperclass).getRawType();\n                return (Class) rawType;\n            }\n            return (Class) genericSuperclass;\n        }\n\n        private void readActualTypeParametersOnDeclaringClass(Class<?> clazz) {\n            registerTypeParametersOn(clazz.getTypeParameters());\n            registerTypeVariablesOn(clazz.getGenericSuperclass());\n            for (Type genericInterface : clazz.getGenericInterfaces()) {\n                registerTypeVariablesOn(genericInterface);\n            }\n        }\n\n        @Override\n        public Class<?> rawType() {\n            return clazz;\n        }\n    }\n\n\n    \n    private static class FromParameterizedTypeGenericMetadataSupport extends GenericMetadataSupport { private final ParameterizedType parameterizedType; public FromParameterizedTypeGenericMetadataSupport(ParameterizedType parameterizedType) {\n            this.parameterizedType = parameterizedType;\n            readActualTypeParameters();\n        }\n\n        private void readActualTypeParameters() {\n            registerTypeVariablesOn(parameterizedType.getRawType());\n            registerTypeVariablesOn(parameterizedType);\n        }\n\n        @Override\n        public Class<?> rawType() {\n            return (Class<?>) parameterizedType.getRawType();\n        }\n    }\n\n\n    \n    private static class ParameterizedReturnType extends GenericMetadataSupport { private final ParameterizedType parameterizedType; private final TypeVariable[] typeParameters; public ParameterizedReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, ParameterizedType parameterizedType) {\n            this.parameterizedType = parameterizedType;\n            this.typeParameters = typeParameters;\n            this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n\n            readTypeParameters();\n            readTypeVariables();\n        }\n\n        private void readTypeParameters() {\n            registerTypeParametersOn(typeParameters);\n        }\n\n        private void readTypeVariables() {\n            registerTypeVariablesOn(parameterizedType);\n        }\n\n        @Override\n        public Class<?> rawType() {\n            return (Class<?>) parameterizedType.getRawType();\n        }\n\n    }\n\n\n    \n    private static class TypeVariableReturnType extends GenericMetadataSupport { private final TypeVariable typeVariable; private final TypeVariable[] typeParameters; private Class<?> rawType; public TypeVariableReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, TypeVariable typeVariable) {\n            this.typeParameters = typeParameters;\n            this.typeVariable = typeVariable;\n            this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n\n            readTypeParameters();\n            readTypeVariables();\n        }\n\n        private void readTypeParameters() {\n            registerTypeParametersOn(typeParameters);\n        }\n\n        private void readTypeVariables() {\n            for (Type type : typeVariable.getBounds()) {\n                registerTypeVariablesOn(type);\n            }\n            registerTypeParametersOn(new TypeVariable[] { typeVariable });\n            registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n        }\n\n        @Override\n        public Class<?> rawType() {\n            if (rawType == null) {\n                rawType = extractRawTypeOf(typeVariable);\n            }\n            return rawType;\n        }\n\n        private Class<?> extractRawTypeOf(Type type) {\n            if (type instanceof Class) {\n                return (Class<?>) type;\n            }\n            if (type instanceof ParameterizedType) {\n                return (Class<?>) ((ParameterizedType) type).getRawType();\n            }\n            if (type instanceof BoundedType) {\n                return extractRawTypeOf(((BoundedType) type).firstBound());\n            }\n            if (type instanceof TypeVariable) {\n                \n                return extractRawTypeOf(contextualActualTypeParameters.get(type));\n            }\n            throw new MockitoException(\"Raw extraction not supported for : '\" + type + \"'\");\n        }\n\n        @Override\n        public List<Type> extraInterfaces() {\n            Type type = extractActualBoundedTypeOf(typeVariable);\n            if (type instanceof BoundedType) {\n                return Arrays.asList(((BoundedType) type).interfaceBounds());\n            }\n            if (type instanceof ParameterizedType) {\n                return Collections.singletonList(type);\n            }\n            if (type instanceof Class) {\n                return Collections.emptyList();\n            }\n            throw new MockitoException(\"Cannot extract extra-interfaces from '\" + typeVariable + \"' : '\" + type + \"'\");\n        }\n\n        \n        public Class<?>[] rawExtraInterfaces() {\n            List<Type> extraInterfaces = extraInterfaces();\n            List<Class<?>> rawExtraInterfaces = new ArrayList<Class<?>>();\n            for (Type extraInterface : extraInterfaces) {\n                Class<?> rawInterface = extractRawTypeOf(extraInterface);\n                \n                if(!rawType().equals(rawInterface)) {\n                    rawExtraInterfaces.add(rawInterface);\n                }\n            }\n            return rawExtraInterfaces.toArray(new Class[rawExtraInterfaces.size()]);\n        }\n\n        private Type extractActualBoundedTypeOf(Type type) {\n            if (type instanceof TypeVariable) {\n                \n                return extractActualBoundedTypeOf(contextualActualTypeParameters.get(type));\n            }\n            if (type instanceof BoundedType) {\n                Type actualFirstBound = extractActualBoundedTypeOf(((BoundedType) type).firstBound());\n                if (!(actualFirstBound instanceof BoundedType)) {\n                    return type; \n                }\n                return actualFirstBound;\n            }\n            return type; \n        }\n    }\n\n\n\n    \n    private static class NotGenericReturnTypeSupport extends GenericMetadataSupport { private final Class<?> returnType; public NotGenericReturnTypeSupport(Type genericReturnType) {\n            returnType = (Class<?>) genericReturnType;\n        }\n\n        @Override\n        public Class<?> rawType() {\n            return returnType;\n        }\n    }\n\n\n\n    \n    public interface BoundedType extends Type { Type firstBound(); Type[] interfaceBounds(); } public static class TypeVarBoundedType implements BoundedType {\n        private final TypeVariable typeVariable; public TypeVarBoundedType(TypeVariable typeVariable) {\n            this.typeVariable = typeVariable;\n        }\n\n        \n        public Type firstBound() {\n            return typeVariable.getBounds()[0]; \n        }\n\n        \n        public Type[] interfaceBounds() {\n            Type[] interfaceBounds = new Type[typeVariable.getBounds().length - 1];\n            System.arraycopy(typeVariable.getBounds(), 1, interfaceBounds, 0, typeVariable.getBounds().length - 1);\n            return interfaceBounds;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            return typeVariable.equals(((TypeVarBoundedType) o).typeVariable);\n\n        }\n\n        @Override\n        public int hashCode() {\n            return typeVariable.hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return \"{firstBound=\" + firstBound() + \", interfaceBounds=\" + Arrays.deepToString(interfaceBounds()) + '}';\n        }\n\n        public TypeVariable typeVariable() {\n            return typeVariable;\n        }\n    }\n\n    \n    public static class WildCardBoundedType implements BoundedType { private final WildcardType wildcard; public WildCardBoundedType(WildcardType wildcard) {\n            this.wildcard = wildcard;\n        }\n\n        \n        public Type firstBound() {\n            Type[] lowerBounds = wildcard.getLowerBounds();\n            Type[] upperBounds = wildcard.getUpperBounds();\n\n            return lowerBounds.length != 0 ? lowerBounds[0] : upperBounds[0];\n        }\n\n        \n        public Type[] interfaceBounds() {\n            return new Type[0];\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            return wildcard.equals(((TypeVarBoundedType) o).typeVariable);\n\n        }\n\n        @Override\n        public int hashCode() {\n            return wildcard.hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return \"{firstBound=\" + firstBound() + \", interfaceBounds=[]}\";\n        }\n\n        public WildcardType wildCard() {\n            return wildcard;\n        }\n    }\n\n}\n\n\n",
      "buggy_signatures": [
        "protected void registerTypeParametersOn(TypeVariable[] typeParameters)",
        "private void registerTypeVariableIfNotPresent(TypeVariable typeVariable)",
        "private BoundedType boundsOf(TypeVariable typeParameter)",
        "private BoundedType boundsOf(WildcardType wildCard)",
        "public abstract Class<?> rawType(); public List<Type> extraInterfaces()",
        "public Class<?>[] rawExtraInterfaces()",
        "public boolean hasRawExtraInterfaces()",
        "public Map<TypeVariable, Type> actualTypeArguments()",
        "protected Type getActualTypeArgumentFor(TypeVariable typeParameter)",
        "public GenericMetadataSupport resolveGenericReturnType(Method method)",
        "public static GenericMetadataSupport inferFrom(Type type)",
        "private static class FromClassGenericMetadataSupport extends GenericMetadataSupport { private final Class<?> clazz; public FromClassGenericMetadataSupport(Class<?> clazz)",
        "private Class superClassOf(Class currentExploredClass)",
        "private void readActualTypeParametersOnDeclaringClass(Class<?> clazz)",
        "public Class<?> rawType()",
        "private static class FromParameterizedTypeGenericMetadataSupport extends GenericMetadataSupport { private final ParameterizedType parameterizedType; public FromParameterizedTypeGenericMetadataSupport(ParameterizedType parameterizedType)",
        "private void readActualTypeParameters()",
        "public Class<?> rawType()",
        "private static class ParameterizedReturnType extends GenericMetadataSupport { private final ParameterizedType parameterizedType; private final TypeVariable[] typeParameters; public ParameterizedReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, ParameterizedType parameterizedType)",
        "private void readTypeParameters()",
        "private void readTypeVariables()",
        "public Class<?> rawType()",
        "private static class TypeVariableReturnType extends GenericMetadataSupport { private final TypeVariable typeVariable; private final TypeVariable[] typeParameters; private Class<?> rawType; public TypeVariableReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, TypeVariable typeVariable)",
        "private void readTypeParameters()",
        "private void readTypeVariables()",
        "public Class<?> rawType()",
        "private Class<?> extractRawTypeOf(Type type)",
        "public List<Type> extraInterfaces()",
        "public Class<?>[] rawExtraInterfaces()",
        "private Type extractActualBoundedTypeOf(Type type)",
        "private static class NotGenericReturnTypeSupport extends GenericMetadataSupport { private final Class<?> returnType; public NotGenericReturnTypeSupport(Type genericReturnType)",
        "public Class<?> rawType()",
        "public interface BoundedType extends Type { Type firstBound(); Type[] interfaceBounds(); } public static class TypeVarBoundedType implements BoundedType",
        "private final TypeVariable typeVariable; public TypeVarBoundedType(TypeVariable typeVariable)",
        "public Type firstBound()",
        "public Type[] interfaceBounds()",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "public String toString()",
        "public TypeVariable typeVariable()",
        "public static class WildCardBoundedType implements BoundedType { private final WildcardType wildcard; public WildCardBoundedType(WildcardType wildcard)",
        "public Type firstBound()",
        "public Type[] interfaceBounds()",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "public String toString()",
        "public WildcardType wildCard()"
      ],
      "fixed_signatures": [
        "protected void registerTypeParametersOn(TypeVariable[] typeParameters)",
        "private void registerTypeVariableIfNotPresent(TypeVariable typeVariable)",
        "private BoundedType boundsOf(TypeVariable typeParameter)",
        "private BoundedType boundsOf(WildcardType wildCard)",
        "public abstract Class<?> rawType(); public List<Type> extraInterfaces()",
        "public Class<?>[] rawExtraInterfaces()",
        "public boolean hasRawExtraInterfaces()",
        "public Map<TypeVariable, Type> actualTypeArguments()",
        "protected Type getActualTypeArgumentFor(TypeVariable typeParameter)",
        "public GenericMetadataSupport resolveGenericReturnType(Method method)",
        "public static GenericMetadataSupport inferFrom(Type type)",
        "private static class FromClassGenericMetadataSupport extends GenericMetadataSupport { private final Class<?> clazz; public FromClassGenericMetadataSupport(Class<?> clazz)",
        "private Class superClassOf(Class currentExploredClass)",
        "private void readActualTypeParametersOnDeclaringClass(Class<?> clazz)",
        "public Class<?> rawType()",
        "private static class FromParameterizedTypeGenericMetadataSupport extends GenericMetadataSupport { private final ParameterizedType parameterizedType; public FromParameterizedTypeGenericMetadataSupport(ParameterizedType parameterizedType)",
        "private void readActualTypeParameters()",
        "public Class<?> rawType()",
        "private static class ParameterizedReturnType extends GenericMetadataSupport { private final ParameterizedType parameterizedType; private final TypeVariable[] typeParameters; public ParameterizedReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, ParameterizedType parameterizedType)",
        "private void readTypeParameters()",
        "private void readTypeVariables()",
        "public Class<?> rawType()",
        "private static class TypeVariableReturnType extends GenericMetadataSupport { private final TypeVariable typeVariable; private final TypeVariable[] typeParameters; private Class<?> rawType; public TypeVariableReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, TypeVariable typeVariable)",
        "private void readTypeParameters()",
        "private void readTypeVariables()",
        "public Class<?> rawType()",
        "private Class<?> extractRawTypeOf(Type type)",
        "public List<Type> extraInterfaces()",
        "public Class<?>[] rawExtraInterfaces()",
        "private Type extractActualBoundedTypeOf(Type type)",
        "private static class NotGenericReturnTypeSupport extends GenericMetadataSupport { private final Class<?> returnType; public NotGenericReturnTypeSupport(Type genericReturnType)",
        "public Class<?> rawType()",
        "public interface BoundedType extends Type { Type firstBound(); Type[] interfaceBounds(); } public static class TypeVarBoundedType implements BoundedType",
        "private final TypeVariable typeVariable; public TypeVarBoundedType(TypeVariable typeVariable)",
        "public Type firstBound()",
        "public Type[] interfaceBounds()",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "public String toString()",
        "public TypeVariable typeVariable()",
        "public static class WildCardBoundedType implements BoundedType { private final WildcardType wildcard; public WildCardBoundedType(WildcardType wildcard)",
        "public Type firstBound()",
        "public Type[] interfaceBounds()",
        "public boolean equals(Object o)",
        "public int hashCode()",
        "public String toString()",
        "public WildcardType wildCard()"
      ],
      "methods": [
        {
          "buggy_method": "  private void readTypeVariables() {\n  for (Type type : typeVariable.getBounds()) {\n  registerTypeVariablesOn(type);\n  }\n  registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n  }",
          "fixed_method": "  private void readTypeVariables() {\n  for (Type type : typeVariable.getBounds()) {\n  registerTypeVariablesOn(type);\n  }\n  registerTypeParametersOn(new TypeVariable[] { typeVariable });\n  registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n  }",
          "diff": [
            "@@ -376,6 +376,7 @@",
            "             for (Type type : typeVariable.getBounds()) {\n",
            "                 registerTypeVariablesOn(type);\n",
            "             }\n",
            "+            registerTypeParametersOn(new TypeVariable[] { typeVariable });\n",
            "             registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n",
            "         }\n",
            " \n"
          ],
          "changed_lines": 1
        }
      ]
    }
  ]
}
