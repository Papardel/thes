{
  "bug_id": "6",
  "failed_tests": {
    "com.fasterxml.jackson.databind.deser.TestDateDeserialization": [
      {
        "methodName": "testISO8601MissingSeconds",
        "error": "com.fasterxml.jackson.databind.exc.InvalidFormatException",
        "message": "Can not construct instance of java.util.Date from String value '1997-07-16T19:20+01:00': not a valid representation (error: Failed to parse Date value '1997-07-16T19:20+01:00': Can not parse date \"1997-07-16T19:20+01:00\": not compatible with any of standard forms (\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\", \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\", \"EEE, dd MMM yyyy HH:mm:ss zzz\", \"yyyy-MM-dd\"))",
        "fail_line": "        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);",
        "test_source": "  public void testISO8601MissingSeconds() throws Exception {\n  String inputStr;\n  Date inputDate;\n  Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n  \n  inputStr = \"1997-07-16T19:20+01:00\";\n  inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);\n  c.setTime(inputDate);\n  assertEquals(1997, c.get(Calendar.YEAR));\n  assertEquals(Calendar.JULY, c.get(Calendar.MONTH));\n  assertEquals(16, c.get(Calendar.DAY_OF_MONTH));\n  assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));\n  assertEquals(0, c.get(Calendar.SECOND));\n  assertEquals(0, c.get(Calendar.MILLISECOND));\n}",
        "stack": [
          "InvalidFormatException.from line 55, DeserializationContext.weirdStringException line 797, StdDeserializer._parseDate line 740, DateDeserializers$DateBasedDeserializer._parseDate line 176, DateDeserializers$DateDeserializer.deserialize line 262, DateDeserializers$DateDeserializer.deserialize line 246, ObjectMapper._readMapAndClose line 3051, ObjectMapper.readValue line 2146, TestDateDeserialization.testISO8601MissingSeconds line 193"
        ]
      },
      {
        "methodName": "testISO8601PartialMilliseconds",
        "error": "com.fasterxml.jackson.databind.exc.InvalidFormatException",
        "message": "Can not construct instance of java.util.Date from String value '2014-10-03T18:00:00.6-05:00': not a valid representation (error: Failed to parse Date value '2014-10-03T18:00:00.6-05:00': Can not parse date \"2014-10-03T18:00:00.6-05:00\": not compatible with any of standard forms (\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\", \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\", \"EEE, dd MMM yyyy HH:mm:ss zzz\", \"yyyy-MM-dd\"))",
        "fail_line": "        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);",
        "test_source": "  public void testISO8601PartialMilliseconds() throws Exception {\n  String inputStr;\n  Date inputDate;\n  Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n  \n  inputStr = \"2014-10-03T18:00:00.6-05:00\";\n  inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);\n  c.setTime(inputDate);\n  assertEquals(2014, c.get(Calendar.YEAR));\n  assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));\n  assertEquals(3, c.get(Calendar.DAY_OF_MONTH));\n  assertEquals(600, c.get(Calendar.MILLISECOND));\n\n  inputStr = \"2014-10-03T18:00:00.61-05:00\";\n  inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);\n  c.setTime(inputDate);\n  assertEquals(2014, c.get(Calendar.YEAR));\n  assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));\n  assertEquals(3, c.get(Calendar.DAY_OF_MONTH));\n  assertEquals(18 + 5, c.get(Calendar.HOUR_OF_DAY));\n  assertEquals(0, c.get(Calendar.MINUTE));\n  assertEquals(0, c.get(Calendar.SECOND));\n  assertEquals(610, c.get(Calendar.MILLISECOND));\n\n  inputStr = \"1997-07-16T19:20:30.45+01:00\";\n  inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);\n  c.setTime(inputDate);\n  assertEquals(1997, c.get(Calendar.YEAR));\n  assertEquals(Calendar.JULY, c.get(Calendar.MONTH));\n  assertEquals(16, c.get(Calendar.DAY_OF_MONTH));\n  assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));\n  assertEquals(20, c.get(Calendar.MINUTE));\n  assertEquals(30, c.get(Calendar.SECOND));\n  assertEquals(450, c.get(Calendar.MILLISECOND));\n  }",
        "stack": [
          "InvalidFormatException.from line 55, DeserializationContext.weirdStringException line 797, StdDeserializer._parseDate line 740, DateDeserializers$DateBasedDeserializer._parseDate line 176, DateDeserializers$DateDeserializer.deserialize line 262, DateDeserializers$DateDeserializer.deserialize line 246, ObjectMapper._readMapAndClose line 3051, ObjectMapper.readValue line 2146, TestDateDeserialization.testISO8601PartialMilliseconds line 156"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/util/StdDateFormat.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.util;\n\nimport java.text.DateFormat;\nimport java.text.FieldPosition;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n\n@SuppressWarnings(\"serial\")\npublic class StdDateFormat extends DateFormat { protected final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"; protected final static String DATE_FORMAT_STR_ISO8601_Z = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"; protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\"; protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }; private final static TimeZone DEFAULT_TIMEZONE; static { DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"GMT\"); } private final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123; protected final static DateFormat DATE_FORMAT_ISO8601; protected final static DateFormat DATE_FORMAT_ISO8601_Z; protected final static DateFormat DATE_FORMAT_PLAIN; static {\n        \n\n        DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE);\n        DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE);\n        DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE);\n    }\n    \n    \n    public final static StdDateFormat instance = new StdDateFormat(); protected transient TimeZone _timezone; protected final Locale _locale; protected transient DateFormat _formatRFC1123; protected transient DateFormat _formatISO8601; protected transient DateFormat _formatISO8601_z; protected transient DateFormat _formatPlain; public StdDateFormat() {\n        _locale = DEFAULT_LOCALE;\n    }\n\n    \n    @Deprecated \n    public StdDateFormat(TimeZone tz) {\n        this(tz, DEFAULT_LOCALE);\n    }\n    \n    public StdDateFormat(TimeZone tz, Locale loc) {\n        _timezone = tz;\n        _locale = loc;\n    }\n\n    public static TimeZone getDefaultTimeZone() {\n        return DEFAULT_TIMEZONE;\n    }\n    \n    \n    public StdDateFormat withTimeZone(TimeZone tz) {\n        if (tz == null) {\n            tz = DEFAULT_TIMEZONE;\n        }\n        if (tz.equals(_timezone)) {\n            return this;\n        }\n        return new StdDateFormat(tz, _locale);\n    }\n\n    public StdDateFormat withLocale(Locale loc) {\n        if (loc.equals(_locale)) {\n            return this;\n        }\n        return new StdDateFormat(_timezone, loc);\n    }\n    \n    @Override\n    public StdDateFormat clone() {\n        \n        return new StdDateFormat(_timezone, _locale);\n    }\n\n    \n    @Deprecated\n    public static DateFormat getBlueprintISO8601Format() {\n        return DATE_FORMAT_ISO8601;\n    }\n\n    \n    @Deprecated\n    public static DateFormat getISO8601Format(TimeZone tz) {\n        return getISO8601Format(tz, DEFAULT_LOCALE);\n    }\n\n    \n    public static DateFormat getISO8601Format(TimeZone tz, Locale loc) {\n        return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc);\n    }\n    \n    \n    @Deprecated\n    public static DateFormat getBlueprintRFC1123Format() {\n        return DATE_FORMAT_RFC1123;\n    }\n\n    \n    public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) {\n        return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, tz, loc);\n    }\n\n    \n    @Deprecated\n    public static DateFormat getRFC1123Format(TimeZone tz) {\n        return getRFC1123Format(tz, DEFAULT_LOCALE);\n    }\n    \n    \n\n    @Override\n    public void setTimeZone(TimeZone tz) {\n        \n        if (!tz.equals(_timezone)) {\n            _formatRFC1123 = null;\n            _formatISO8601 = null;\n            _formatISO8601_z = null;\n            _formatPlain = null;\n            _timezone = tz;\n        }\n    }\n    \n    @Override\n    public Date parse(String dateStr) throws ParseException {\n        dateStr = dateStr.trim();\n        ParsePosition pos = new ParsePosition(0);\n        Date result = parse(dateStr, pos);\n        if (result != null) {\n            return result;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (String f : ALL_FORMATS) {\n            if (sb.length() > 0) {\n                sb.append(\"\\\", \\\"\");\n            } else {\n                sb.append('\"');\n            }\n            sb.append(f);\n        }\n        sb.append('\"');\n        throw new ParseException\n            (String.format(\"Can not parse date \\\"%s\\\": not compatible with any of standard forms (%s)\",\n                           dateStr, sb.toString()), pos.getErrorIndex());\n    }\n\n    @Override\n    public Date parse(String dateStr, ParsePosition pos) {\n        if (looksLikeISO8601(dateStr)) { \n            return parseAsISO8601(dateStr, pos);\n        }\n        \n        int i = dateStr.length();\n        while (--i >= 0) {\n            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') {\n                \n                if (i > 0 || ch != '-') {\n                    break;\n                }\n            }\n        }\n        if (i < 0) { \n            \n            if (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        \n        return parseAsRFC1123(dateStr, pos);\n    }\n\n    @Override\n    public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) {\n        if (_formatISO8601 == null) {\n            _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n        }\n        return _formatISO8601.format(date, toAppendTo, fieldPosition);\n    }\n\n    \n    \n    @Override\n    public String toString() {\n        String str = \"DateFormat \"+getClass().getName();\n        TimeZone tz = _timezone;\n        if (tz != null) {\n            str += \" (timezone: \"+tz+\")\";\n        }\n        str += \"(locale: \"+_locale+\")\";\n        return str;\n    }\n    \n    \n\n    \n    protected boolean looksLikeISO8601(String dateStr) {\n        if (dateStr.length() >= 5\n            && Character.isDigit(dateStr.charAt(0))\n            && Character.isDigit(dateStr.charAt(3))\n            && dateStr.charAt(4) == '-'\n            ) {\n            return true;\n        }\n        return false;\n    }\n\n    protected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n        \n\n        \n        int len = dateStr.length();\n        char c = dateStr.charAt(len-1);\n        DateFormat df;\n\n        \n        if (len <= 10 && Character.isDigit(c)) {\n            df = _formatPlain;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n            }\n        } else if (c == 'Z') {\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n            \n            if (dateStr.charAt(len-4) == ':') {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len-1, \".000\");\n                dateStr = sb.toString();\n            }\n        } else {\n            \n            if (hasTimeZone(dateStr)) {\n                c = dateStr.charAt(len-3);\n                if (c == ':') { \n                    \n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.delete(len-3, len-2);\n                    dateStr = sb.toString();\n                } else if (c == '+' || c == '-') { \n                    \n                    dateStr += \"00\";\n                }\n                \n                len = dateStr.length();\n                \n                c = dateStr.charAt(len-9);\n                if (Character.isDigit(c)) {\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.insert(len-5, \".000\");\n                    dateStr = sb.toString();\n                }\n                df = _formatISO8601;\n                if (_formatISO8601 == null) {\n                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n                }\n            } else {\n                \n                StringBuilder sb = new StringBuilder(dateStr);\n                \n                int timeLen = len - dateStr.lastIndexOf('T') - 1;\n                if (timeLen <= 8) {\n                        sb.append(\".000\");\n                }\n                sb.append('Z');\n                dateStr = sb.toString();\n                df = _formatISO8601_z;\n                if (df == null) {\n                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n                            _timezone, _locale);\n                }\n            }\n        }\n        return df.parse(dateStr, pos);\n    }\n\n    protected Date parseAsRFC1123(String dateStr, ParsePosition pos) {\n        if (_formatRFC1123 == null) {\n            _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale);\n        }\n        return _formatRFC1123.parse(dateStr, pos);\n    }\n\n    private final static boolean hasTimeZone(String str) {\n        \n        int len = str.length();\n        if (len >= 6) {\n            char c = str.charAt(len-6);\n            if (c == '+' || c == '-') return true;\n            c = str.charAt(len-5);\n            if (c == '+' || c == '-') return true;\n            c = str.charAt(len-3);\n            if (c == '+' || c == '-') return true;\n        }\n        return false;\n    }\n\n    private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc) {\n        if (!loc.equals(DEFAULT_LOCALE)) {\n            df = new SimpleDateFormat(format, loc);\n            df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n        } else {\n            df = (DateFormat) df.clone();\n            if (tz != null) {\n                df.setTimeZone(tz);\n            }\n        }\n        return df;\n    }\n}\n\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.util;\n\nimport java.text.DateFormat;\nimport java.text.FieldPosition;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n\n@SuppressWarnings(\"serial\")\npublic class StdDateFormat extends DateFormat { protected final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"; protected final static String DATE_FORMAT_STR_ISO8601_Z = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"; protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\"; protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\"; protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }; private final static TimeZone DEFAULT_TIMEZONE; static { DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"GMT\"); } private final static Locale DEFAULT_LOCALE = Locale.US; protected final static DateFormat DATE_FORMAT_RFC1123; protected final static DateFormat DATE_FORMAT_ISO8601; protected final static DateFormat DATE_FORMAT_ISO8601_Z; protected final static DateFormat DATE_FORMAT_PLAIN; static {\n        \n\n        DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE);\n        DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE);\n        DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE);\n    }\n    \n    \n    public final static StdDateFormat instance = new StdDateFormat(); protected transient TimeZone _timezone; protected final Locale _locale; protected transient DateFormat _formatRFC1123; protected transient DateFormat _formatISO8601; protected transient DateFormat _formatISO8601_z; protected transient DateFormat _formatPlain; public StdDateFormat() {\n        _locale = DEFAULT_LOCALE;\n    }\n\n    \n    @Deprecated \n    public StdDateFormat(TimeZone tz) {\n        this(tz, DEFAULT_LOCALE);\n    }\n    \n    public StdDateFormat(TimeZone tz, Locale loc) {\n        _timezone = tz;\n        _locale = loc;\n    }\n\n    public static TimeZone getDefaultTimeZone() {\n        return DEFAULT_TIMEZONE;\n    }\n    \n    \n    public StdDateFormat withTimeZone(TimeZone tz) {\n        if (tz == null) {\n            tz = DEFAULT_TIMEZONE;\n        }\n        if (tz.equals(_timezone)) {\n            return this;\n        }\n        return new StdDateFormat(tz, _locale);\n    }\n\n    public StdDateFormat withLocale(Locale loc) {\n        if (loc.equals(_locale)) {\n            return this;\n        }\n        return new StdDateFormat(_timezone, loc);\n    }\n    \n    @Override\n    public StdDateFormat clone() {\n        \n        return new StdDateFormat(_timezone, _locale);\n    }\n\n    \n    @Deprecated\n    public static DateFormat getBlueprintISO8601Format() {\n        return DATE_FORMAT_ISO8601;\n    }\n\n    \n    @Deprecated\n    public static DateFormat getISO8601Format(TimeZone tz) {\n        return getISO8601Format(tz, DEFAULT_LOCALE);\n    }\n\n    \n    public static DateFormat getISO8601Format(TimeZone tz, Locale loc) {\n        return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc);\n    }\n    \n    \n    @Deprecated\n    public static DateFormat getBlueprintRFC1123Format() {\n        return DATE_FORMAT_RFC1123;\n    }\n\n    \n    public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) {\n        return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, tz, loc);\n    }\n\n    \n    @Deprecated\n    public static DateFormat getRFC1123Format(TimeZone tz) {\n        return getRFC1123Format(tz, DEFAULT_LOCALE);\n    }\n    \n    \n\n    @Override\n    public void setTimeZone(TimeZone tz) {\n        \n        if (!tz.equals(_timezone)) {\n            _formatRFC1123 = null;\n            _formatISO8601 = null;\n            _formatISO8601_z = null;\n            _formatPlain = null;\n            _timezone = tz;\n        }\n    }\n    \n    @Override\n    public Date parse(String dateStr) throws ParseException {\n        dateStr = dateStr.trim();\n        ParsePosition pos = new ParsePosition(0);\n        Date result = parse(dateStr, pos);\n        if (result != null) {\n            return result;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (String f : ALL_FORMATS) {\n            if (sb.length() > 0) {\n                sb.append(\"\\\", \\\"\");\n            } else {\n                sb.append('\"');\n            }\n            sb.append(f);\n        }\n        sb.append('\"');\n        throw new ParseException\n            (String.format(\"Can not parse date \\\"%s\\\": not compatible with any of standard forms (%s)\",\n                           dateStr, sb.toString()), pos.getErrorIndex());\n    }\n\n    @Override\n    public Date parse(String dateStr, ParsePosition pos) {\n        if (looksLikeISO8601(dateStr)) { \n            return parseAsISO8601(dateStr, pos);\n        }\n        \n        int i = dateStr.length();\n        while (--i >= 0) {\n            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') {\n                \n                if (i > 0 || ch != '-') {\n                    break;\n                }\n            }\n        }\n        if (i < 0) { \n            \n            if (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        \n        return parseAsRFC1123(dateStr, pos);\n    }\n\n    @Override\n    public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) {\n        if (_formatISO8601 == null) {\n            _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n        }\n        return _formatISO8601.format(date, toAppendTo, fieldPosition);\n    }\n\n    \n    \n    @Override\n    public String toString() {\n        String str = \"DateFormat \"+getClass().getName();\n        TimeZone tz = _timezone;\n        if (tz != null) {\n            str += \" (timezone: \"+tz+\")\";\n        }\n        str += \"(locale: \"+_locale+\")\";\n        return str;\n    }\n    \n    \n\n    \n    protected boolean looksLikeISO8601(String dateStr) {\n        if (dateStr.length() >= 5\n            && Character.isDigit(dateStr.charAt(0))\n            && Character.isDigit(dateStr.charAt(3))\n            && dateStr.charAt(4) == '-'\n            ) {\n            return true;\n        }\n        return false;\n    }\n\n    protected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n        \n\n        \n        int len = dateStr.length();\n        char c = dateStr.charAt(len-1);\n        DateFormat df;\n\n        \n        if (len <= 10 && Character.isDigit(c)) {\n            df = _formatPlain;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n            }\n        } else if (c == 'Z') {\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n            \n            if (dateStr.charAt(len-4) == ':') {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len-1, \".000\");\n                dateStr = sb.toString();\n            }\n        } else {\n            \n            if (hasTimeZone(dateStr)) {\n                c = dateStr.charAt(len-3);\n                if (c == ':') { \n                    \n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.delete(len-3, len-2);\n                    dateStr = sb.toString();\n                } else if (c == '+' || c == '-') { \n                    \n                    dateStr += \"00\";\n                }\n                \n                len = dateStr.length();\n                \n                int timeLen = len - dateStr.lastIndexOf('T') - 6;\n                if (timeLen < 12) { \n                    int offset = len - 5; \n                    StringBuilder sb = new StringBuilder(dateStr);\n                    switch (timeLen) {\n                    case 11:\n                        sb.insert(offset, '0'); break;\n                    case 10:\n                        sb.insert(offset, \"00\"); break;\n                    case 9: \n                        sb.insert(offset, \"000\"); break;\n                    case 8:\n                        sb.insert(offset, \".000\"); break;\n                    case 7: \n                        break;\n                    case 6: \n                        sb.insert(offset, \"00.000\");\n                    case 5: \n                        sb.insert(offset, \":00.000\");\n                    }\n                    dateStr = sb.toString();\n                }\n                df = _formatISO8601;\n                if (_formatISO8601 == null) {\n                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n                }\n            } else {\n                \n                StringBuilder sb = new StringBuilder(dateStr);\n                \n                int timeLen = len - dateStr.lastIndexOf('T') - 1;\n                if (timeLen < 12) { \n                    switch (timeLen) {\n                    case 11: sb.append('0');\n                    case 10: sb.append('0');\n                    case 9: sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                    }\n                }\n                sb.append('Z');\n                dateStr = sb.toString();\n                df = _formatISO8601_z;\n                if (df == null) {\n                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n                            _timezone, _locale);\n                }\n            }\n        }\n        return df.parse(dateStr, pos);\n    }\n\n    protected Date parseAsRFC1123(String dateStr, ParsePosition pos) {\n        if (_formatRFC1123 == null) {\n            _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale);\n        }\n        return _formatRFC1123.parse(dateStr, pos);\n    }\n\n    private final static boolean hasTimeZone(String str) {\n        \n        int len = str.length();\n        if (len >= 6) {\n            char c = str.charAt(len-6);\n            if (c == '+' || c == '-') return true;\n            c = str.charAt(len-5);\n            if (c == '+' || c == '-') return true;\n            c = str.charAt(len-3);\n            if (c == '+' || c == '-') return true;\n        }\n        return false;\n    }\n\n    private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc) {\n        if (!loc.equals(DEFAULT_LOCALE)) {\n            df = new SimpleDateFormat(format, loc);\n            df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n        } else {\n            df = (DateFormat) df.clone();\n            if (tz != null) {\n                df.setTimeZone(tz);\n            }\n        }\n        return df;\n    }\n}\n\n",
      "buggy_signatures": [
        "public StdDateFormat(TimeZone tz)",
        "public StdDateFormat(TimeZone tz, Locale loc)",
        "public static TimeZone getDefaultTimeZone()",
        "public StdDateFormat withTimeZone(TimeZone tz)",
        "public StdDateFormat withLocale(Locale loc)",
        "public StdDateFormat clone()",
        "public static DateFormat getBlueprintISO8601Format()",
        "public static DateFormat getISO8601Format(TimeZone tz)",
        "public static DateFormat getISO8601Format(TimeZone tz, Locale loc)",
        "public static DateFormat getBlueprintRFC1123Format()",
        "public static DateFormat getRFC1123Format(TimeZone tz, Locale loc)",
        "public static DateFormat getRFC1123Format(TimeZone tz)",
        "public void setTimeZone(TimeZone tz)",
        "public Date parse(String dateStr) throws ParseException",
        "public Date parse(String dateStr, ParsePosition pos)",
        "public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition)",
        "public String toString()",
        "protected boolean looksLikeISO8601(String dateStr)",
        "protected Date parseAsISO8601(String dateStr, ParsePosition pos)",
        "protected Date parseAsRFC1123(String dateStr, ParsePosition pos)",
        "private final static boolean hasTimeZone(String str)",
        "private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc)"
      ],
      "fixed_signatures": [
        "public StdDateFormat(TimeZone tz)",
        "public StdDateFormat(TimeZone tz, Locale loc)",
        "public static TimeZone getDefaultTimeZone()",
        "public StdDateFormat withTimeZone(TimeZone tz)",
        "public StdDateFormat withLocale(Locale loc)",
        "public StdDateFormat clone()",
        "public static DateFormat getBlueprintISO8601Format()",
        "public static DateFormat getISO8601Format(TimeZone tz)",
        "public static DateFormat getISO8601Format(TimeZone tz, Locale loc)",
        "public static DateFormat getBlueprintRFC1123Format()",
        "public static DateFormat getRFC1123Format(TimeZone tz, Locale loc)",
        "public static DateFormat getRFC1123Format(TimeZone tz)",
        "public void setTimeZone(TimeZone tz)",
        "public Date parse(String dateStr) throws ParseException",
        "public Date parse(String dateStr, ParsePosition pos)",
        "public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition)",
        "public String toString()",
        "protected boolean looksLikeISO8601(String dateStr)",
        "protected Date parseAsISO8601(String dateStr, ParsePosition pos)",
        "protected Date parseAsRFC1123(String dateStr, ParsePosition pos)",
        "private final static boolean hasTimeZone(String str)",
        "private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc)"
      ],
      "methods": [
        {
          "buggy_method": "  protected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n  \n\n  \n  int len = dateStr.length();\n  char c = dateStr.charAt(len-1);\n  DateFormat df;\n\n  \n  if (len <= 10 && Character.isDigit(c)) {\n  df = _formatPlain;\n  if (df == null) {\n  df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n  }\n  } else if (c == 'Z') {\n  df = _formatISO8601_z;\n  if (df == null) {\n  df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n  }\n  \n  if (dateStr.charAt(len-4) == ':') {\n  StringBuilder sb = new StringBuilder(dateStr);\n  sb.insert(len-1, \".000\");\n  dateStr = sb.toString();\n  }\n  } else {\n  \n  if (hasTimeZone(dateStr)) {\n  c = dateStr.charAt(len-3);\n  if (c == ':') { \n  \n  StringBuilder sb = new StringBuilder(dateStr);\n  sb.delete(len-3, len-2);\n  dateStr = sb.toString();\n  } else if (c == '+' || c == '-') { \n  \n  dateStr += \"00\";\n  }\n  \n  len = dateStr.length();\n  \n  c = dateStr.charAt(len-9);\n  if (Character.isDigit(c)) {\n  StringBuilder sb = new StringBuilder(dateStr);\n  sb.insert(len-5, \".000\");\n  dateStr = sb.toString();\n  }\n  df = _formatISO8601;\n  if (_formatISO8601 == null) {\n  df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n  }\n  } else {\n  \n  StringBuilder sb = new StringBuilder(dateStr);\n  \n  int timeLen = len - dateStr.lastIndexOf('T') - 1;\n  if (timeLen <= 8) {\n  sb.append(\".000\");\n  }\n  sb.append('Z');\n  dateStr = sb.toString();\n  df = _formatISO8601_z;\n  if (df == null) {\n  df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n  _timezone, _locale);\n  }\n  }\n  }\n  return df.parse(dateStr, pos);\n  }",
          "fixed_method": "  protected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n  \n\n  \n  int len = dateStr.length();\n  char c = dateStr.charAt(len-1);\n  DateFormat df;\n\n  \n  if (len <= 10 && Character.isDigit(c)) {\n  df = _formatPlain;\n  if (df == null) {\n  df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n  }\n  } else if (c == 'Z') {\n  df = _formatISO8601_z;\n  if (df == null) {\n  df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n  }\n  \n  if (dateStr.charAt(len-4) == ':') {\n  StringBuilder sb = new StringBuilder(dateStr);\n  sb.insert(len-1, \".000\");\n  dateStr = sb.toString();\n  }\n  } else {\n  \n  if (hasTimeZone(dateStr)) {\n  c = dateStr.charAt(len-3);\n  if (c == ':') { \n  \n  StringBuilder sb = new StringBuilder(dateStr);\n  sb.delete(len-3, len-2);\n  dateStr = sb.toString();\n  } else if (c == '+' || c == '-') { \n  \n  dateStr += \"00\";\n  }\n  \n  len = dateStr.length();\n  \n  int timeLen = len - dateStr.lastIndexOf('T') - 6;\n  if (timeLen < 12) { \n  int offset = len - 5; \n  StringBuilder sb = new StringBuilder(dateStr);\n  switch (timeLen) {\n  case 11:\n  sb.insert(offset, '0'); break;\n  case 10:\n  sb.insert(offset, \"00\"); break;\n  case 9: \n  sb.insert(offset, \"000\"); break;\n  case 8:\n  sb.insert(offset, \".000\"); break;\n  case 7: \n  break;\n  case 6: \n  sb.insert(offset, \"00.000\");\n  case 5: \n  sb.insert(offset, \":00.000\");\n  }\n  dateStr = sb.toString();\n  }\n  df = _formatISO8601;\n  if (_formatISO8601 == null) {\n  df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n  }\n  } else {\n  \n  StringBuilder sb = new StringBuilder(dateStr);\n  \n  int timeLen = len - dateStr.lastIndexOf('T') - 1;\n  if (timeLen < 12) { \n  switch (timeLen) {\n  case 11: sb.append('0');\n  case 10: sb.append('0');\n  case 9: sb.append('0');\n  break;\n  default:\n  sb.append(\".000\");\n  }\n  }\n  sb.append('Z');\n  dateStr = sb.toString();\n  df = _formatISO8601_z;\n  if (df == null) {\n  df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n  _timezone, _locale);\n  }\n  }\n  }\n  return df.parse(dateStr, pos);\n  }",
          "diff": [
            "@@ -403,10 +403,26 @@",
            "                 // Milliseconds partial or missing; and even seconds are optional\n",
            "                 len = dateStr.length();\n",
            "                 // remove 'T', '+'/'-' and 4-digit timezone-offset\n",
            "-                c = dateStr.charAt(len-9);\n",
            "-                if (Character.isDigit(c)) {\n",
            "+                int timeLen = len - dateStr.lastIndexOf('T') - 6;\n",
            "+                if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss\n",
            "+                    int offset = len - 5; // insertion offset, before tz-offset\n",
            "                     StringBuilder sb = new StringBuilder(dateStr);\n",
            "-                    sb.insert(len-5, \".000\");\n",
            "+                    switch (timeLen) {\n",
            "+                    case 11:\n",
            "+                        sb.insert(offset, '0'); break;\n",
            "+                    case 10:\n",
            "+                        sb.insert(offset, \"00\"); break;\n",
            "+                    case 9: // is this legal? (just second fraction marker)\n",
            "+                        sb.insert(offset, \"000\"); break;\n",
            "+                    case 8:\n",
            "+                        sb.insert(offset, \".000\"); break;\n",
            "+                    case 7: // not legal to have single-digit second\n",
            "+                        break;\n",
            "+                    case 6: // probably not legal, but let's allow\n",
            "+                        sb.insert(offset, \"00.000\");\n",
            "+                    case 5: // is legal to omit seconds\n",
            "+                        sb.insert(offset, \":00.000\");\n",
            "+                    }\n",
            "                     dateStr = sb.toString();\n",
            "                 }\n",
            "                 df = _formatISO8601;\n",
            "@@ -418,8 +434,15 @@",
            "                 StringBuilder sb = new StringBuilder(dateStr);\n",
            "                 // And possible also millisecond part if missing\n",
            "                 int timeLen = len - dateStr.lastIndexOf('T') - 1;\n",
            "-                if (timeLen <= 8) {\n",
            "+                if (timeLen < 12) { // missing, or partial\n",
            "+                    switch (timeLen) {\n",
            "+                    case 11: sb.append('0');\n",
            "+                    case 10: sb.append('0');\n",
            "+                    case 9: sb.append('0');\n",
            "+                        break;\n",
            "+                    default:\n",
            "                         sb.append(\".000\");\n",
            "+                    }\n",
            "                 }\n",
            "                 sb.append('Z');\n",
            "                 dateStr = sb.toString();\n"
          ],
          "changed_lines": 31
        }
      ]
    }
  ]
}
