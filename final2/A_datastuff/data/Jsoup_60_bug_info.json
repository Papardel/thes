{
  "bug_id": "60",
  "failed_tests": {
    "org.jsoup.select.QueryParserTest": [
      {
        "methodName": "testParsesSingleQuoteInContains",
        "error": "junit.framework.AssertionFailedError",
        "message": "Expected exception: org.jsoup.select.Selector$SelectorParseException",
        "fail_line": "",
        "test_source": "",
        "stack": [
          ""
        ]
      },
      {
        "methodName": "exceptionOnUncloseAttribute",
        "error": "java.lang.Exception",
        "message": "Unexpected exception, expected<org.jsoup.select.Selector$SelectorParseException> but was<java.lang.IllegalArgumentException>",
        "fail_line": "        Evaluator parse = QueryParser.parse(\"section > a[href=\\\"]\");",
        "test_source": "",
        "stack": [
          "Validate.notEmpty line 92, Evaluator$AttributeKeyPair.<init> line 303, Evaluator$AttributeWithValue.<init> line 175, QueryParser.byAttribute line 244, QueryParser.findElements line 150, QueryParser.parse line 65, QueryParser.parse line 39, QueryParser.combinator line 81, QueryParser.parse line 61, QueryParser.parse line 39, QueryParserTest.exceptionOnUncloseAttribute line 44"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/parser/TokenQueue.java",
      "buggy_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\n\n\npublic class TokenQueue { private String queue; private int pos = 0; private static final char ESC = '\\\\'; public TokenQueue(String data) {\n        Validate.notNull(data);\n        queue = data;\n    }\n\n    \n    public boolean isEmpty() {\n        return remainingLength() == 0;\n    }\n    \n    private int remainingLength() {\n        return queue.length() - pos;\n    }\n\n    \n    public char peek() {\n        return isEmpty() ? 0 : queue.charAt(pos);\n    }\n\n    \n    public void addFirst(Character c) {\n        addFirst(c.toString());\n    }\n\n    \n    public void addFirst(String seq) {\n        \n        queue = seq + queue.substring(pos);\n        pos = 0;\n    }\n\n    \n    public boolean matches(String seq) {\n        return queue.regionMatches(true, pos, seq, 0, seq.length());\n    }\n\n    \n    public boolean matchesCS(String seq) {\n        return queue.startsWith(seq, pos);\n    }\n    \n\n    \n    public boolean matchesAny(String... seq) {\n        for (String s : seq) {\n            if (matches(s))\n                return true;\n        }\n        return false;\n    }\n\n    public boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        for (char c: seq) {\n            if (queue.charAt(pos) == c)\n                return true;\n        }\n        return false;\n    }\n\n    public boolean matchesStartTag() {\n        \n        return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos+1)));\n    }\n\n    \n    public boolean matchChomp(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \n    public boolean matchesWhitespace() {\n        return !isEmpty() && StringUtil.isWhitespace(queue.charAt(pos));\n    }\n\n    \n    public boolean matchesWord() {\n        return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));\n    }\n\n    \n    public void advance() {\n        if (!isEmpty()) pos++;\n    }\n\n    \n    public char consume() {\n        return queue.charAt(pos++);\n    }\n\n    \n    public void consume(String seq) {\n        if (!matches(seq))\n            throw new IllegalStateException(\"Queue did not match expected sequence\");\n        int len = seq.length();\n        if (len > remainingLength())\n            throw new IllegalStateException(\"Queue not long enough to consume sequence\");\n        \n        pos += len;\n    }\n\n    \n    public String consumeTo(String seq) {\n        int offset = queue.indexOf(seq, pos);\n        if (offset != -1) {\n            String consumed = queue.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return remainder();\n        }\n    }\n    \n    public String consumeToIgnoreCase(String seq) {\n        int start = pos;\n        String first = seq.substring(0, 1);\n        boolean canScan = first.toLowerCase().equals(first.toUpperCase()); \n        while (!isEmpty()) {\n            if (matches(seq))\n                break;\n            \n            if (canScan) {\n                int skip = queue.indexOf(first, pos) - pos;\n                if (skip == 0) \n                    pos++;\n                else if (skip < 0) \n                    pos = queue.length();\n                else\n                    pos += skip;\n            }\n            else\n                pos++;\n        }\n\n        return queue.substring(start, pos);\n    }\n\n    \n    \n    \n    public String consumeToAny(String... seq) {\n        int start = pos;\n        while (!isEmpty() && !matchesAny(seq)) {\n            pos++;\n        }\n\n        return queue.substring(start, pos);\n    }\n\n    \n    public String chompTo(String seq) {\n        String data = consumeTo(seq);\n        matchChomp(seq);\n        return data;\n    }\n    \n    public String chompToIgnoreCase(String seq) {\n        String data = consumeToIgnoreCase(seq); \n        matchChomp(seq);\n        return data;\n    }\n\n    \n    public String chompBalanced(char open, char close) {\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        char last = 0;\n        boolean inQuote = false;\n\n        do {\n            if (isEmpty()) break;\n            Character c = consume();\n            if (last == 0 || last != ESC) {\n                if ((c.equals('\\'') || c.equals('\"')) && c != open)\n                    inQuote = !inQuote;\n                if (inQuote)\n                    continue;\n                if (c.equals(open)) {\n                    depth++;\n                    if (start == -1)\n                        start = pos;\n                }\n                else if (c.equals(close))\n                    depth--;\n            }\n\n            if (depth > 0 && last != 0)\n                end = pos; \n            last = c;\n        } while (depth > 0);\n        final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n        return out;\n    }\n    \n    \n    public static String unescape(String in) {\n        StringBuilder out = new StringBuilder();\n        char last = 0;\n        for (char c : in.toCharArray()) {\n            if (c == ESC) {\n                if (last != 0 && last == ESC)\n                    out.append(c);\n            }\n            else \n                out.append(c);\n            last = c;\n        }\n        return out.toString();\n    }\n\n    \n    public boolean consumeWhitespace() {\n        boolean seen = false;\n        while (matchesWhitespace()) {\n            pos++;\n            seen = true;\n        }\n        return seen;\n    }\n\n    \n    public String consumeWord() {\n        int start = pos;\n        while (matchesWord())\n            pos++;\n        return queue.substring(start, pos);\n    }\n    \n    \n    public String consumeTagName() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny(':', '_', '-')))\n            pos++;\n        \n        return queue.substring(start, pos);\n    }\n    \n    \n    public String consumeElementSelector() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny(\"*|\",\"|\", \"_\", \"-\")))\n            pos++;\n        \n        return queue.substring(start, pos);\n    }\n\n    \n    public String consumeCssIdentifier() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny('-', '_')))\n            pos++;\n\n        return queue.substring(start, pos);\n    }\n\n    \n    public String consumeAttributeKey() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny('-', '_', ':')))\n            pos++;\n        \n        return queue.substring(start, pos);\n    }\n\n    \n    public String remainder() {\n        final String remainder = queue.substring(pos, queue.length());\n        pos = queue.length();\n        return remainder;\n    }\n    \n    @Override\n    public String toString() {\n        return queue.substring(pos);\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\n\n\npublic class TokenQueue { private String queue; private int pos = 0; private static final char ESC = '\\\\'; public TokenQueue(String data) {\n        Validate.notNull(data);\n        queue = data;\n    }\n\n    \n    public boolean isEmpty() {\n        return remainingLength() == 0;\n    }\n    \n    private int remainingLength() {\n        return queue.length() - pos;\n    }\n\n    \n    public char peek() {\n        return isEmpty() ? 0 : queue.charAt(pos);\n    }\n\n    \n    public void addFirst(Character c) {\n        addFirst(c.toString());\n    }\n\n    \n    public void addFirst(String seq) {\n        \n        queue = seq + queue.substring(pos);\n        pos = 0;\n    }\n\n    \n    public boolean matches(String seq) {\n        return queue.regionMatches(true, pos, seq, 0, seq.length());\n    }\n\n    \n    public boolean matchesCS(String seq) {\n        return queue.startsWith(seq, pos);\n    }\n    \n\n    \n    public boolean matchesAny(String... seq) {\n        for (String s : seq) {\n            if (matches(s))\n                return true;\n        }\n        return false;\n    }\n\n    public boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        for (char c: seq) {\n            if (queue.charAt(pos) == c)\n                return true;\n        }\n        return false;\n    }\n\n    public boolean matchesStartTag() {\n        \n        return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos+1)));\n    }\n\n    \n    public boolean matchChomp(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \n    public boolean matchesWhitespace() {\n        return !isEmpty() && StringUtil.isWhitespace(queue.charAt(pos));\n    }\n\n    \n    public boolean matchesWord() {\n        return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));\n    }\n\n    \n    public void advance() {\n        if (!isEmpty()) pos++;\n    }\n\n    \n    public char consume() {\n        return queue.charAt(pos++);\n    }\n\n    \n    public void consume(String seq) {\n        if (!matches(seq))\n            throw new IllegalStateException(\"Queue did not match expected sequence\");\n        int len = seq.length();\n        if (len > remainingLength())\n            throw new IllegalStateException(\"Queue not long enough to consume sequence\");\n        \n        pos += len;\n    }\n\n    \n    public String consumeTo(String seq) {\n        int offset = queue.indexOf(seq, pos);\n        if (offset != -1) {\n            String consumed = queue.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return remainder();\n        }\n    }\n    \n    public String consumeToIgnoreCase(String seq) {\n        int start = pos;\n        String first = seq.substring(0, 1);\n        boolean canScan = first.toLowerCase().equals(first.toUpperCase()); \n        while (!isEmpty()) {\n            if (matches(seq))\n                break;\n            \n            if (canScan) {\n                int skip = queue.indexOf(first, pos) - pos;\n                if (skip == 0) \n                    pos++;\n                else if (skip < 0) \n                    pos = queue.length();\n                else\n                    pos += skip;\n            }\n            else\n                pos++;\n        }\n\n        return queue.substring(start, pos);\n    }\n\n    \n    \n    \n    public String consumeToAny(String... seq) {\n        int start = pos;\n        while (!isEmpty() && !matchesAny(seq)) {\n            pos++;\n        }\n\n        return queue.substring(start, pos);\n    }\n\n    \n    public String chompTo(String seq) {\n        String data = consumeTo(seq);\n        matchChomp(seq);\n        return data;\n    }\n    \n    public String chompToIgnoreCase(String seq) {\n        String data = consumeToIgnoreCase(seq); \n        matchChomp(seq);\n        return data;\n    }\n\n    \n    public String chompBalanced(char open, char close) {\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        char last = 0;\n        boolean inQuote = false;\n\n        do {\n            if (isEmpty()) break;\n            Character c = consume();\n            if (last == 0 || last != ESC) {\n                if ((c.equals('\\'') || c.equals('\"')) && c != open)\n                    inQuote = !inQuote;\n                if (inQuote)\n                    continue;\n                if (c.equals(open)) {\n                    depth++;\n                    if (start == -1)\n                        start = pos;\n                }\n                else if (c.equals(close))\n                    depth--;\n            }\n\n            if (depth > 0 && last != 0)\n                end = pos; \n            last = c;\n        } while (depth > 0);\n        final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n        if (depth > 0) {\n            Validate.fail(\"Did not find balanced maker at \" + out);\n        }\n        return out;\n    }\n    \n    \n    public static String unescape(String in) {\n        StringBuilder out = new StringBuilder();\n        char last = 0;\n        for (char c : in.toCharArray()) {\n            if (c == ESC) {\n                if (last != 0 && last == ESC)\n                    out.append(c);\n            }\n            else \n                out.append(c);\n            last = c;\n        }\n        return out.toString();\n    }\n\n    \n    public boolean consumeWhitespace() {\n        boolean seen = false;\n        while (matchesWhitespace()) {\n            pos++;\n            seen = true;\n        }\n        return seen;\n    }\n\n    \n    public String consumeWord() {\n        int start = pos;\n        while (matchesWord())\n            pos++;\n        return queue.substring(start, pos);\n    }\n    \n    \n    public String consumeTagName() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny(':', '_', '-')))\n            pos++;\n        \n        return queue.substring(start, pos);\n    }\n    \n    \n    public String consumeElementSelector() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny(\"*|\",\"|\", \"_\", \"-\")))\n            pos++;\n        \n        return queue.substring(start, pos);\n    }\n\n    \n    public String consumeCssIdentifier() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny('-', '_')))\n            pos++;\n\n        return queue.substring(start, pos);\n    }\n\n    \n    public String consumeAttributeKey() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny('-', '_', ':')))\n            pos++;\n        \n        return queue.substring(start, pos);\n    }\n\n    \n    public String remainder() {\n        final String remainder = queue.substring(pos, queue.length());\n        pos = queue.length();\n        return remainder;\n    }\n    \n    @Override\n    public String toString() {\n        return queue.substring(pos);\n    }\n}\n",
      "buggy_signatures": [
        "public boolean isEmpty()",
        "private int remainingLength()",
        "public char peek()",
        "public void addFirst(Character c)",
        "public void addFirst(String seq)",
        "public boolean matches(String seq)",
        "public boolean matchesCS(String seq)",
        "public boolean matchesAny(String... seq)",
        "public boolean matchesAny(char... seq)",
        "public boolean matchesStartTag()",
        "public boolean matchChomp(String seq)",
        "public boolean matchesWhitespace()",
        "public boolean matchesWord()",
        "public void advance()",
        "public char consume()",
        "public void consume(String seq)",
        "public String consumeTo(String seq)",
        "public String consumeToIgnoreCase(String seq)",
        "public String consumeToAny(String... seq)",
        "public String chompTo(String seq)",
        "public String chompToIgnoreCase(String seq)",
        "public String chompBalanced(char open, char close)",
        "public static String unescape(String in)",
        "public boolean consumeWhitespace()",
        "public String consumeWord()",
        "public String consumeTagName()",
        "public String consumeElementSelector()",
        "public String consumeCssIdentifier()",
        "public String consumeAttributeKey()",
        "public String remainder()",
        "public String toString()"
      ],
      "fixed_signatures": [
        "public boolean isEmpty()",
        "private int remainingLength()",
        "public char peek()",
        "public void addFirst(Character c)",
        "public void addFirst(String seq)",
        "public boolean matches(String seq)",
        "public boolean matchesCS(String seq)",
        "public boolean matchesAny(String... seq)",
        "public boolean matchesAny(char... seq)",
        "public boolean matchesStartTag()",
        "public boolean matchChomp(String seq)",
        "public boolean matchesWhitespace()",
        "public boolean matchesWord()",
        "public void advance()",
        "public char consume()",
        "public void consume(String seq)",
        "public String consumeTo(String seq)",
        "public String consumeToIgnoreCase(String seq)",
        "public String consumeToAny(String... seq)",
        "public String chompTo(String seq)",
        "public String chompToIgnoreCase(String seq)",
        "public String chompBalanced(char open, char close)",
        "public static String unescape(String in)",
        "public boolean consumeWhitespace()",
        "public String consumeWord()",
        "public String consumeTagName()",
        "public String consumeElementSelector()",
        "public String consumeCssIdentifier()",
        "public String consumeAttributeKey()",
        "public String remainder()",
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "  public String chompBalanced(char open, char close) {\n  int start = -1;\n  int end = -1;\n  int depth = 0;\n  char last = 0;\n  boolean inQuote = false;\n\n  do {\n  if (isEmpty()) break;\n  Character c = consume();\n  if (last == 0 || last != ESC) {\n  if ((c.equals('\\'') || c.equals('\"')) && c != open)\n  inQuote = !inQuote;\n  if (inQuote)\n  continue;\n  if (c.equals(open)) {\n  depth++;\n  if (start == -1)\n  start = pos;\n  }\n  else if (c.equals(close))\n  depth--;\n  }\n\n  if (depth > 0 && last != 0)\n  end = pos; \n  last = c;\n  } while (depth > 0);\n  final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n  return out;\n  }",
          "fixed_method": "  public String chompBalanced(char open, char close) {\n  int start = -1;\n  int end = -1;\n  int depth = 0;\n  char last = 0;\n  boolean inQuote = false;\n\n  do {\n  if (isEmpty()) break;\n  Character c = consume();\n  if (last == 0 || last != ESC) {\n  if ((c.equals('\\'') || c.equals('\"')) && c != open)\n  inQuote = !inQuote;\n  if (inQuote)\n  continue;\n  if (c.equals(open)) {\n  depth++;\n  if (start == -1)\n  start = pos;\n  }\n  else if (c.equals(close))\n  depth--;\n  }\n\n  if (depth > 0 && last != 0)\n  end = pos; \n  last = c;\n  } while (depth > 0);\n  final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n  if (depth > 0) {\n  Validate.fail(\"Did not find balanced maker at \" + out);\n  }\n  return out;\n  }",
          "diff": [
            "@@ -286,6 +286,9 @@",
            "             last = c;\n",
            "         } while (depth > 0);\n",
            "         final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n",
            "+        if (depth > 0) {// ran out of queue before seeing enough )\n",
            "+            Validate.fail(\"Did not find balanced maker at \" + out);\n",
            "+        }\n",
            "         return out;\n",
            "     }\n",
            "     \n"
          ],
          "changed_lines": 3
        }
      ]
    },
    {
      "name": "org/jsoup/select/QueryParser.java",
      "buggy_full_code": "package org.jsoup.select;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.parser.TokenQueue;\n\n\npublic class QueryParser { private final static String[] combinators = {\",\", \">\", \"+\", \"~\", \" \"}; private static final String[] AttributeEvals = new String[]{\"=\", \"!=\", \"^=\", \"$=\", \"*=\", \"~=\"}; private TokenQueue tq; private String query; private List<Evaluator> evals = new ArrayList<Evaluator>(); private QueryParser(String query) {\n        this.query = query;\n        this.tq = new TokenQueue(query);\n    }\n\n    \n    public static Evaluator parse(String query) {\n            QueryParser p = new QueryParser(query);\n            return p.parse();\n    }\n\n    \n    Evaluator parse() {\n        tq.consumeWhitespace();\n\n        if (tq.matchesAny(combinators)) { \n            evals.add(new StructuralEvaluator.Root());\n            combinator(tq.consume());\n        } else {\n            findElements();\n        }\n\n        while (!tq.isEmpty()) {\n            \n            boolean seenWhite = tq.consumeWhitespace();\n\n            if (tq.matchesAny(combinators)) {\n                combinator(tq.consume());\n            } else if (seenWhite) {\n                combinator(' ');\n            } else { \n                findElements(); \n            }\n        }\n\n        if (evals.size() == 1)\n            return evals.get(0);\n\n        return new CombiningEvaluator.And(evals);\n    }\n\n    private void combinator(char combinator) {\n        tq.consumeWhitespace();\n        String subQuery = consumeSubQuery(); \n\n        Evaluator rootEval; \n        Evaluator currentEval; \n        Evaluator newEval = parse(subQuery); \n        boolean replaceRightMost = false;\n\n        if (evals.size() == 1) {\n            rootEval = currentEval = evals.get(0);\n            \n            if (rootEval instanceof CombiningEvaluator.Or && combinator != ',') {\n                currentEval = ((CombiningEvaluator.Or) currentEval).rightMostEvaluator();\n                replaceRightMost = true;\n            }\n        }\n        else {\n            rootEval = currentEval = new CombiningEvaluator.And(evals);\n        }\n        evals.clear();\n\n        \n        if (combinator == '>')\n            currentEval = new CombiningEvaluator.And(newEval, new StructuralEvaluator.ImmediateParent(currentEval));\n        else if (combinator == ' ')\n            currentEval = new CombiningEvaluator.And(newEval, new StructuralEvaluator.Parent(currentEval));\n        else if (combinator == '+')\n            currentEval = new CombiningEvaluator.And(newEval, new StructuralEvaluator.ImmediatePreviousSibling(currentEval));\n        else if (combinator == '~')\n            currentEval = new CombiningEvaluator.And(newEval, new StructuralEvaluator.PreviousSibling(currentEval));\n        else if (combinator == ',') { \n            CombiningEvaluator.Or or;\n            if (currentEval instanceof CombiningEvaluator.Or) {\n                or = (CombiningEvaluator.Or) currentEval;\n                or.add(newEval);\n            } else {\n                or = new CombiningEvaluator.Or();\n                or.add(currentEval);\n                or.add(newEval);\n            }\n            currentEval = or;\n        }\n        else\n            throw new Selector.SelectorParseException(\"Unknown combinator: \" + combinator);\n\n        if (replaceRightMost)\n            ((CombiningEvaluator.Or) rootEval).replaceRightMostEvaluator(currentEval);\n        else rootEval = currentEval;\n        evals.add(rootEval);\n    }\n\n    private String consumeSubQuery() {\n        StringBuilder sq = new StringBuilder();\n        while (!tq.isEmpty()) {\n            if (tq.matches(\"(\"))\n                sq.append(\"(\").append(tq.chompBalanced('(', ')')).append(\")\");\n            else if (tq.matches(\"[\"))\n                sq.append(\"[\").append(tq.chompBalanced('[', ']')).append(\"]\");\n            else if (tq.matchesAny(combinators))\n                break;\n            else\n                sq.append(tq.consume());\n        }\n        return sq.toString();\n    }\n\n    private void findElements() {\n        if (tq.matchChomp(\"#\"))\n            byId();\n        else if (tq.matchChomp(\".\"))\n            byClass();\n        else if (tq.matchesWord() || tq.matches(\"*|\"))\n            byTag();\n        else if (tq.matches(\"[\"))\n            byAttribute();\n        else if (tq.matchChomp(\"*\"))\n            allElements();\n        else if (tq.matchChomp(\":lt(\"))\n            indexLessThan();\n        else if (tq.matchChomp(\":gt(\"))\n            indexGreaterThan();\n        else if (tq.matchChomp(\":eq(\"))\n            indexEquals();\n        else if (tq.matches(\":has(\"))\n            has();\n        else if (tq.matches(\":contains(\"))\n            contains(false);\n        else if (tq.matches(\":containsOwn(\"))\n            contains(true);\n        else if (tq.matches(\":containsData(\"))\n            containsData();\n        else if (tq.matches(\":matches(\"))\n            matches(false);\n        else if (tq.matches(\":matchesOwn(\"))\n            matches(true);\n        else if (tq.matches(\":not(\"))\n            not();\n\t\telse if (tq.matchChomp(\":nth-child(\"))\n        \tcssNthChild(false, false);\n        else if (tq.matchChomp(\":nth-last-child(\"))\n        \tcssNthChild(true, false);\n        else if (tq.matchChomp(\":nth-of-type(\"))\n        \tcssNthChild(false, true);\n        else if (tq.matchChomp(\":nth-last-of-type(\"))\n        \tcssNthChild(true, true);\n        else if (tq.matchChomp(\":first-child\"))\n        \tevals.add(new Evaluator.IsFirstChild());\n        else if (tq.matchChomp(\":last-child\"))\n        \tevals.add(new Evaluator.IsLastChild());\n        else if (tq.matchChomp(\":first-of-type\"))\n        \tevals.add(new Evaluator.IsFirstOfType());\n        else if (tq.matchChomp(\":last-of-type\"))\n        \tevals.add(new Evaluator.IsLastOfType());\n        else if (tq.matchChomp(\":only-child\"))\n        \tevals.add(new Evaluator.IsOnlyChild());\n        else if (tq.matchChomp(\":only-of-type\"))\n        \tevals.add(new Evaluator.IsOnlyOfType());\n        else if (tq.matchChomp(\":empty\"))\n        \tevals.add(new Evaluator.IsEmpty());\n        else if (tq.matchChomp(\":root\"))\n        \tevals.add(new Evaluator.IsRoot());\n\t\telse \n            throw new Selector.SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n\n    }\n\n    private void byId() {\n        String id = tq.consumeCssIdentifier();\n        Validate.notEmpty(id);\n        evals.add(new Evaluator.Id(id));\n    }\n\n    private void byClass() {\n        String className = tq.consumeCssIdentifier();\n        Validate.notEmpty(className);\n        evals.add(new Evaluator.Class(className.trim()));\n    }\n\n    private void byTag() {\n        String tagName = tq.consumeElementSelector();\n\n        Validate.notEmpty(tagName);\n\n        \n        if (tagName.startsWith(\"*|\")) {\n            evals.add(new CombiningEvaluator.Or(new Evaluator.Tag(tagName.trim().toLowerCase()), new Evaluator.TagEndsWith(tagName.replace(\"*|\", \":\").trim().toLowerCase())));\n        } else {\n            \n            if (tagName.contains(\"|\"))\n                tagName = tagName.replace(\"|\", \":\");\n\n            evals.add(new Evaluator.Tag(tagName.trim()));\n        }\n    }\n\n    private void byAttribute() {\n        TokenQueue cq = new TokenQueue(tq.chompBalanced('[', ']')); \n        String key = cq.consumeToAny(AttributeEvals); \n        Validate.notEmpty(key);\n        cq.consumeWhitespace();\n\n        if (cq.isEmpty()) {\n            if (key.startsWith(\"^\"))\n                evals.add(new Evaluator.AttributeStarting(key.substring(1)));\n            else\n                evals.add(new Evaluator.Attribute(key));\n        } else {\n            if (cq.matchChomp(\"=\"))\n                evals.add(new Evaluator.AttributeWithValue(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"!=\"))\n                evals.add(new Evaluator.AttributeWithValueNot(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"^=\"))\n                evals.add(new Evaluator.AttributeWithValueStarting(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"$=\"))\n                evals.add(new Evaluator.AttributeWithValueEnding(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"*=\"))\n                evals.add(new Evaluator.AttributeWithValueContaining(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"~=\"))\n                evals.add(new Evaluator.AttributeWithValueMatching(key, Pattern.compile(cq.remainder())));\n            else\n                throw new Selector.SelectorParseException(\"Could not parse attribute query '%s': unexpected token at '%s'\", query, cq.remainder());\n        }\n    }\n\n    private void allElements() {\n        evals.add(new Evaluator.AllElements());\n    }\n\n    \n    private void indexLessThan() {\n        evals.add(new Evaluator.IndexLessThan(consumeIndex()));\n    }\n\n    private void indexGreaterThan() {\n        evals.add(new Evaluator.IndexGreaterThan(consumeIndex()));\n    }\n\n    private void indexEquals() {\n        evals.add(new Evaluator.IndexEquals(consumeIndex()));\n    }\n    \n    \n    private static final Pattern NTH_AB = Pattern.compile(\"((\\\\+|-)?(\\\\d+)?)n(\\\\s*(\\\\+|-)?\\\\s*\\\\d+)?\", Pattern.CASE_INSENSITIVE); private static final Pattern NTH_B = Pattern.compile(\"(\\\\+|-)?(\\\\d+)\"); private void cssNthChild(boolean backwards, boolean ofType) {\n\t\tString argS = tq.chompTo(\")\").trim().toLowerCase();\n\t\tMatcher mAB = NTH_AB.matcher(argS);\n\t\tMatcher mB = NTH_B.matcher(argS);\n\t\tfinal int a, b;\n\t\tif (\"odd\".equals(argS)) {\n\t\t\ta = 2;\n\t\t\tb = 1;\n\t\t} else if (\"even\".equals(argS)) {\n\t\t\ta = 2;\n\t\t\tb = 0;\n\t\t} else if (mAB.matches()) {\n\t\t\ta = mAB.group(3) != null ? Integer.parseInt(mAB.group(1).replaceFirst(\"^\\\\+\", \"\")) : 1;\n\t\t\tb = mAB.group(4) != null ? Integer.parseInt(mAB.group(4).replaceFirst(\"^\\\\+\", \"\")) : 0;\n\t\t} else if (mB.matches()) {\n\t\t\ta = 0;\n\t\t\tb = Integer.parseInt(mB.group().replaceFirst(\"^\\\\+\", \"\"));\n\t\t} else {\n\t\t\tthrow new Selector.SelectorParseException(\"Could not parse nth-index '%s': unexpected format\", argS);\n\t\t}\n\t\tif (ofType)\n\t\t\tif (backwards)\n\t\t\t\tevals.add(new Evaluator.IsNthLastOfType(a, b));\n\t\t\telse\n\t\t\t\tevals.add(new Evaluator.IsNthOfType(a, b));\n\t\telse {\n\t\t\tif (backwards)\n\t\t\t\tevals.add(new Evaluator.IsNthLastChild(a, b));\n\t\t\telse\n\t\t\t\tevals.add(new Evaluator.IsNthChild(a, b));\n\t\t}\n\t}\n\n    private int consumeIndex() {\n        String indexS = tq.chompTo(\")\").trim();\n        Validate.isTrue(StringUtil.isNumeric(indexS), \"Index must be numeric\");\n        return Integer.parseInt(indexS);\n    }\n\n    \n    private void has() {\n        tq.consume(\":has\");\n        String subQuery = tq.chompBalanced('(', ')');\n        Validate.notEmpty(subQuery, \":has(el) subselect must not be empty\");\n        evals.add(new StructuralEvaluator.Has(parse(subQuery)));\n    }\n\n    \n    private void contains(boolean own) {\n        tq.consume(own ? \":containsOwn\" : \":contains\");\n        String searchText = TokenQueue.unescape(tq.chompBalanced('(', ')'));\n        Validate.notEmpty(searchText, \":contains(text) query must not be empty\");\n        if (own)\n            evals.add(new Evaluator.ContainsOwnText(searchText));\n        else\n            evals.add(new Evaluator.ContainsText(searchText));\n    }\n\n    \n    private void containsData() {\n        tq.consume(\":containsData\");\n        String searchText = TokenQueue.unescape(tq.chompBalanced('(', ')'));\n        Validate.notEmpty(searchText, \":containsData(text) query must not be empty\");\n        evals.add(new Evaluator.ContainsData(searchText));\n    }\n\n    \n    private void matches(boolean own) {\n        tq.consume(own ? \":matchesOwn\" : \":matches\");\n        String regex = tq.chompBalanced('(', ')'); \n        Validate.notEmpty(regex, \":matches(regex) query must not be empty\");\n\n        if (own)\n            evals.add(new Evaluator.MatchesOwn(Pattern.compile(regex)));\n        else\n            evals.add(new Evaluator.Matches(Pattern.compile(regex)));\n    }\n\n    \n    private void not() {\n        tq.consume(\":not\");\n        String subQuery = tq.chompBalanced('(', ')');\n        Validate.notEmpty(subQuery, \":not(selector) subselect must not be empty\");\n\n        evals.add(new StructuralEvaluator.Not(parse(subQuery)));\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.select;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.parser.TokenQueue;\n\n\npublic class QueryParser { private final static String[] combinators = {\",\", \">\", \"+\", \"~\", \" \"}; private static final String[] AttributeEvals = new String[]{\"=\", \"!=\", \"^=\", \"$=\", \"*=\", \"~=\"}; private TokenQueue tq; private String query; private List<Evaluator> evals = new ArrayList<Evaluator>(); private QueryParser(String query) {\n        this.query = query;\n        this.tq = new TokenQueue(query);\n    }\n\n    \n    public static Evaluator parse(String query) {\n        try {\n            QueryParser p = new QueryParser(query);\n            return p.parse();\n        } catch (IllegalArgumentException e) {\n            throw new Selector.SelectorParseException(e.getMessage());\n        }\n    }\n\n    \n    Evaluator parse() {\n        tq.consumeWhitespace();\n\n        if (tq.matchesAny(combinators)) { \n            evals.add(new StructuralEvaluator.Root());\n            combinator(tq.consume());\n        } else {\n            findElements();\n        }\n\n        while (!tq.isEmpty()) {\n            \n            boolean seenWhite = tq.consumeWhitespace();\n\n            if (tq.matchesAny(combinators)) {\n                combinator(tq.consume());\n            } else if (seenWhite) {\n                combinator(' ');\n            } else { \n                findElements(); \n            }\n        }\n\n        if (evals.size() == 1)\n            return evals.get(0);\n\n        return new CombiningEvaluator.And(evals);\n    }\n\n    private void combinator(char combinator) {\n        tq.consumeWhitespace();\n        String subQuery = consumeSubQuery(); \n\n        Evaluator rootEval; \n        Evaluator currentEval; \n        Evaluator newEval = parse(subQuery); \n        boolean replaceRightMost = false;\n\n        if (evals.size() == 1) {\n            rootEval = currentEval = evals.get(0);\n            \n            if (rootEval instanceof CombiningEvaluator.Or && combinator != ',') {\n                currentEval = ((CombiningEvaluator.Or) currentEval).rightMostEvaluator();\n                replaceRightMost = true;\n            }\n        }\n        else {\n            rootEval = currentEval = new CombiningEvaluator.And(evals);\n        }\n        evals.clear();\n\n        \n        if (combinator == '>')\n            currentEval = new CombiningEvaluator.And(newEval, new StructuralEvaluator.ImmediateParent(currentEval));\n        else if (combinator == ' ')\n            currentEval = new CombiningEvaluator.And(newEval, new StructuralEvaluator.Parent(currentEval));\n        else if (combinator == '+')\n            currentEval = new CombiningEvaluator.And(newEval, new StructuralEvaluator.ImmediatePreviousSibling(currentEval));\n        else if (combinator == '~')\n            currentEval = new CombiningEvaluator.And(newEval, new StructuralEvaluator.PreviousSibling(currentEval));\n        else if (combinator == ',') { \n            CombiningEvaluator.Or or;\n            if (currentEval instanceof CombiningEvaluator.Or) {\n                or = (CombiningEvaluator.Or) currentEval;\n                or.add(newEval);\n            } else {\n                or = new CombiningEvaluator.Or();\n                or.add(currentEval);\n                or.add(newEval);\n            }\n            currentEval = or;\n        }\n        else\n            throw new Selector.SelectorParseException(\"Unknown combinator: \" + combinator);\n\n        if (replaceRightMost)\n            ((CombiningEvaluator.Or) rootEval).replaceRightMostEvaluator(currentEval);\n        else rootEval = currentEval;\n        evals.add(rootEval);\n    }\n\n    private String consumeSubQuery() {\n        StringBuilder sq = new StringBuilder();\n        while (!tq.isEmpty()) {\n            if (tq.matches(\"(\"))\n                sq.append(\"(\").append(tq.chompBalanced('(', ')')).append(\")\");\n            else if (tq.matches(\"[\"))\n                sq.append(\"[\").append(tq.chompBalanced('[', ']')).append(\"]\");\n            else if (tq.matchesAny(combinators))\n                break;\n            else\n                sq.append(tq.consume());\n        }\n        return sq.toString();\n    }\n\n    private void findElements() {\n        if (tq.matchChomp(\"#\"))\n            byId();\n        else if (tq.matchChomp(\".\"))\n            byClass();\n        else if (tq.matchesWord() || tq.matches(\"*|\"))\n            byTag();\n        else if (tq.matches(\"[\"))\n            byAttribute();\n        else if (tq.matchChomp(\"*\"))\n            allElements();\n        else if (tq.matchChomp(\":lt(\"))\n            indexLessThan();\n        else if (tq.matchChomp(\":gt(\"))\n            indexGreaterThan();\n        else if (tq.matchChomp(\":eq(\"))\n            indexEquals();\n        else if (tq.matches(\":has(\"))\n            has();\n        else if (tq.matches(\":contains(\"))\n            contains(false);\n        else if (tq.matches(\":containsOwn(\"))\n            contains(true);\n        else if (tq.matches(\":containsData(\"))\n            containsData();\n        else if (tq.matches(\":matches(\"))\n            matches(false);\n        else if (tq.matches(\":matchesOwn(\"))\n            matches(true);\n        else if (tq.matches(\":not(\"))\n            not();\n\t\telse if (tq.matchChomp(\":nth-child(\"))\n        \tcssNthChild(false, false);\n        else if (tq.matchChomp(\":nth-last-child(\"))\n        \tcssNthChild(true, false);\n        else if (tq.matchChomp(\":nth-of-type(\"))\n        \tcssNthChild(false, true);\n        else if (tq.matchChomp(\":nth-last-of-type(\"))\n        \tcssNthChild(true, true);\n        else if (tq.matchChomp(\":first-child\"))\n        \tevals.add(new Evaluator.IsFirstChild());\n        else if (tq.matchChomp(\":last-child\"))\n        \tevals.add(new Evaluator.IsLastChild());\n        else if (tq.matchChomp(\":first-of-type\"))\n        \tevals.add(new Evaluator.IsFirstOfType());\n        else if (tq.matchChomp(\":last-of-type\"))\n        \tevals.add(new Evaluator.IsLastOfType());\n        else if (tq.matchChomp(\":only-child\"))\n        \tevals.add(new Evaluator.IsOnlyChild());\n        else if (tq.matchChomp(\":only-of-type\"))\n        \tevals.add(new Evaluator.IsOnlyOfType());\n        else if (tq.matchChomp(\":empty\"))\n        \tevals.add(new Evaluator.IsEmpty());\n        else if (tq.matchChomp(\":root\"))\n        \tevals.add(new Evaluator.IsRoot());\n\t\telse \n            throw new Selector.SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n\n    }\n\n    private void byId() {\n        String id = tq.consumeCssIdentifier();\n        Validate.notEmpty(id);\n        evals.add(new Evaluator.Id(id));\n    }\n\n    private void byClass() {\n        String className = tq.consumeCssIdentifier();\n        Validate.notEmpty(className);\n        evals.add(new Evaluator.Class(className.trim()));\n    }\n\n    private void byTag() {\n        String tagName = tq.consumeElementSelector();\n\n        Validate.notEmpty(tagName);\n\n        \n        if (tagName.startsWith(\"*|\")) {\n            evals.add(new CombiningEvaluator.Or(new Evaluator.Tag(tagName.trim().toLowerCase()), new Evaluator.TagEndsWith(tagName.replace(\"*|\", \":\").trim().toLowerCase())));\n        } else {\n            \n            if (tagName.contains(\"|\"))\n                tagName = tagName.replace(\"|\", \":\");\n\n            evals.add(new Evaluator.Tag(tagName.trim()));\n        }\n    }\n\n    private void byAttribute() {\n        TokenQueue cq = new TokenQueue(tq.chompBalanced('[', ']')); \n        String key = cq.consumeToAny(AttributeEvals); \n        Validate.notEmpty(key);\n        cq.consumeWhitespace();\n\n        if (cq.isEmpty()) {\n            if (key.startsWith(\"^\"))\n                evals.add(new Evaluator.AttributeStarting(key.substring(1)));\n            else\n                evals.add(new Evaluator.Attribute(key));\n        } else {\n            if (cq.matchChomp(\"=\"))\n                evals.add(new Evaluator.AttributeWithValue(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"!=\"))\n                evals.add(new Evaluator.AttributeWithValueNot(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"^=\"))\n                evals.add(new Evaluator.AttributeWithValueStarting(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"$=\"))\n                evals.add(new Evaluator.AttributeWithValueEnding(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"*=\"))\n                evals.add(new Evaluator.AttributeWithValueContaining(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"~=\"))\n                evals.add(new Evaluator.AttributeWithValueMatching(key, Pattern.compile(cq.remainder())));\n            else\n                throw new Selector.SelectorParseException(\"Could not parse attribute query '%s': unexpected token at '%s'\", query, cq.remainder());\n        }\n    }\n\n    private void allElements() {\n        evals.add(new Evaluator.AllElements());\n    }\n\n    \n    private void indexLessThan() {\n        evals.add(new Evaluator.IndexLessThan(consumeIndex()));\n    }\n\n    private void indexGreaterThan() {\n        evals.add(new Evaluator.IndexGreaterThan(consumeIndex()));\n    }\n\n    private void indexEquals() {\n        evals.add(new Evaluator.IndexEquals(consumeIndex()));\n    }\n    \n    \n    private static final Pattern NTH_AB = Pattern.compile(\"((\\\\+|-)?(\\\\d+)?)n(\\\\s*(\\\\+|-)?\\\\s*\\\\d+)?\", Pattern.CASE_INSENSITIVE); private static final Pattern NTH_B = Pattern.compile(\"(\\\\+|-)?(\\\\d+)\"); private void cssNthChild(boolean backwards, boolean ofType) {\n\t\tString argS = tq.chompTo(\")\").trim().toLowerCase();\n\t\tMatcher mAB = NTH_AB.matcher(argS);\n\t\tMatcher mB = NTH_B.matcher(argS);\n\t\tfinal int a, b;\n\t\tif (\"odd\".equals(argS)) {\n\t\t\ta = 2;\n\t\t\tb = 1;\n\t\t} else if (\"even\".equals(argS)) {\n\t\t\ta = 2;\n\t\t\tb = 0;\n\t\t} else if (mAB.matches()) {\n\t\t\ta = mAB.group(3) != null ? Integer.parseInt(mAB.group(1).replaceFirst(\"^\\\\+\", \"\")) : 1;\n\t\t\tb = mAB.group(4) != null ? Integer.parseInt(mAB.group(4).replaceFirst(\"^\\\\+\", \"\")) : 0;\n\t\t} else if (mB.matches()) {\n\t\t\ta = 0;\n\t\t\tb = Integer.parseInt(mB.group().replaceFirst(\"^\\\\+\", \"\"));\n\t\t} else {\n\t\t\tthrow new Selector.SelectorParseException(\"Could not parse nth-index '%s': unexpected format\", argS);\n\t\t}\n\t\tif (ofType)\n\t\t\tif (backwards)\n\t\t\t\tevals.add(new Evaluator.IsNthLastOfType(a, b));\n\t\t\telse\n\t\t\t\tevals.add(new Evaluator.IsNthOfType(a, b));\n\t\telse {\n\t\t\tif (backwards)\n\t\t\t\tevals.add(new Evaluator.IsNthLastChild(a, b));\n\t\t\telse\n\t\t\t\tevals.add(new Evaluator.IsNthChild(a, b));\n\t\t}\n\t}\n\n    private int consumeIndex() {\n        String indexS = tq.chompTo(\")\").trim();\n        Validate.isTrue(StringUtil.isNumeric(indexS), \"Index must be numeric\");\n        return Integer.parseInt(indexS);\n    }\n\n    \n    private void has() {\n        tq.consume(\":has\");\n        String subQuery = tq.chompBalanced('(', ')');\n        Validate.notEmpty(subQuery, \":has(el) subselect must not be empty\");\n        evals.add(new StructuralEvaluator.Has(parse(subQuery)));\n    }\n\n    \n    private void contains(boolean own) {\n        tq.consume(own ? \":containsOwn\" : \":contains\");\n        String searchText = TokenQueue.unescape(tq.chompBalanced('(', ')'));\n        Validate.notEmpty(searchText, \":contains(text) query must not be empty\");\n        if (own)\n            evals.add(new Evaluator.ContainsOwnText(searchText));\n        else\n            evals.add(new Evaluator.ContainsText(searchText));\n    }\n\n    \n    private void containsData() {\n        tq.consume(\":containsData\");\n        String searchText = TokenQueue.unescape(tq.chompBalanced('(', ')'));\n        Validate.notEmpty(searchText, \":containsData(text) query must not be empty\");\n        evals.add(new Evaluator.ContainsData(searchText));\n    }\n\n    \n    private void matches(boolean own) {\n        tq.consume(own ? \":matchesOwn\" : \":matches\");\n        String regex = tq.chompBalanced('(', ')'); \n        Validate.notEmpty(regex, \":matches(regex) query must not be empty\");\n\n        if (own)\n            evals.add(new Evaluator.MatchesOwn(Pattern.compile(regex)));\n        else\n            evals.add(new Evaluator.Matches(Pattern.compile(regex)));\n    }\n\n    \n    private void not() {\n        tq.consume(\":not\");\n        String subQuery = tq.chompBalanced('(', ')');\n        Validate.notEmpty(subQuery, \":not(selector) subselect must not be empty\");\n\n        evals.add(new StructuralEvaluator.Not(parse(subQuery)));\n    }\n}\n",
      "buggy_signatures": [
        "public static Evaluator parse(String query)",
        "private void combinator(char combinator)",
        "private String consumeSubQuery()",
        "private void findElements()",
        "private void byId()",
        "private void byClass()",
        "private void byTag()",
        "private void byAttribute()",
        "private void allElements()",
        "private void indexLessThan()",
        "private void indexGreaterThan()",
        "private void indexEquals()",
        "private int consumeIndex()",
        "private void has()",
        "private void contains(boolean own)",
        "private void containsData()",
        "private void matches(boolean own)",
        "private void not()"
      ],
      "fixed_signatures": [
        "public static Evaluator parse(String query)",
        "private void combinator(char combinator)",
        "private String consumeSubQuery()",
        "private void findElements()",
        "private void byId()",
        "private void byClass()",
        "private void byTag()",
        "private void byAttribute()",
        "private void allElements()",
        "private void indexLessThan()",
        "private void indexGreaterThan()",
        "private void indexEquals()",
        "private int consumeIndex()",
        "private void has()",
        "private void contains(boolean own)",
        "private void containsData()",
        "private void matches(boolean own)",
        "private void not()"
      ],
      "methods": [
        {
          "buggy_method": "  public static Evaluator parse(String query) {\n  QueryParser p = new QueryParser(query);\n  return p.parse();\n  }",
          "fixed_method": "  public static Evaluator parse(String query) {\n  try {\n  QueryParser p = new QueryParser(query);\n  return p.parse();\n  } catch (IllegalArgumentException e) {\n  throw new Selector.SelectorParseException(e.getMessage());\n  }\n  }",
          "diff": [
            "@@ -35,8 +35,12 @@",
            "      * @return Evaluator\n",
            "      */\n",
            "     public static Evaluator parse(String query) {\n",
            "+        try {\n",
            "             QueryParser p = new QueryParser(query);\n",
            "             return p.parse();\n",
            "+        } catch (IllegalArgumentException e) {\n",
            "+            throw new Selector.SelectorParseException(e.getMessage());\n",
            "+        }\n",
            "     }\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
