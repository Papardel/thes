{
  "bug_id": "79",
  "failed_tests": {
    "org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest": [
      {
        "methodName": "testPerformClusterAnalysisDegenerate",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "        List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 1, 1);",
        "test_source": "  public void testPerformClusterAnalysisDegenerate() {\n  KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(\n  new Random(1746432956321l));\n  EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {\n  new EuclideanIntegerPoint(new int[] { 1959, 325100 }),\n  new EuclideanIntegerPoint(new int[] { 1960, 373200 }), };\n  List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 1, 1);\n  assertEquals(1, clusters.size());\n  assertEquals(2, (clusters.get(0).getPoints().size()));\n  EuclideanIntegerPoint pt1 = new EuclideanIntegerPoint(new int[] { 1959, 325100 });\n  EuclideanIntegerPoint pt2 = new EuclideanIntegerPoint(new int[] { 1960, 373200 });\n  assertTrue(clusters.get(0).getPoints().contains(pt1));\n  assertTrue(clusters.get(0).getPoints().contains(pt2));\n\n  } ",
        "stack": [
          "KMeansPlusPlusClusterer.assignPointsToClusters line 91, KMeansPlusPlusClusterer.cluster line 57, KMeansPlusPlusClustererTest.testPerformClusterAnalysisDegenerate line 109"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/util/MathUtils.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.util;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Arrays;\n\nimport org.apache.commons.math.MathRuntimeException;\n\n\npublic final class MathUtils { public static final double EPSILON = 0x1.0p-53; public static final double SAFE_MIN = 0x1.0p-1022; public static final double TWO_PI = 2 * Math.PI; private static final byte NB = (byte)-1; private static final short NS = (short)-1; private static final byte PB = (byte)1; private static final short PS = (short)1; private static final byte ZB = (byte)0; private static final short ZS = (short)0; private static final int NAN_GAP = 4 * 1024 * 1024; private static final long SGN_MASK = 0x8000000000000000L; private static final long[] FACTORIALS = new long[] {\n                       1l,                  1l,                   2l,\n                       6l,                 24l,                 120l,\n                     720l,               5040l,               40320l,\n                  362880l,            3628800l,            39916800l,\n               479001600l,         6227020800l,         87178291200l,\n           1307674368000l,     20922789888000l,     355687428096000l,\n        6402373705728000l, 121645100408832000l, 2432902008176640000l };\n\n    \n    private MathUtils() {\n        super();\n    }\n\n    \n    public static int addAndCheck(int x, int y) {\n        long s = (long)x + (long)y;\n        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: add\");\n        }\n        return (int)s;\n    }\n\n    \n    public static long addAndCheck(long a, long b) {\n        return addAndCheck(a, b, \"overflow: add\");\n    }\n\n    \n    private static long addAndCheck(long a, long b, String msg) {\n        long ret;\n        if (a > b) {\n            \n            ret = addAndCheck(b, a, msg);\n        } else {\n            \n\n            if (a < 0) {\n                if (b < 0) {\n                    \n                    if (Long.MIN_VALUE - b <= a) {\n                        ret = a + b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                    }\n                } else {\n                    \n                    ret = a + b;\n                }\n            } else {\n                \n                \n\n                \n                if (a <= Long.MAX_VALUE - b) {\n                    ret = a + b;\n                } else {\n                    throw new ArithmeticException(msg);\n                }\n            }\n        }\n        return ret;\n    }\n\n    \n    public static long binomialCoefficient(final int n, final int k) {\n        checkBinomial(n, k);\n        if ((n == k) || (k == 0)) {\n            return 1;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return n;\n        }\n        \n        if (k > n / 2)\n            return binomialCoefficient(n, n - k);\n\n        \n        \n        \n        \n        \n        long result = 1;\n        if (n <= 61) {\n            \n            int i = n - k + 1;\n            for (int j = 1; j <= k; j++) {\n                result = result * i / j;\n                i++;\n            }\n        } else if (n <= 66) {\n            \n            \n            int i = n - k + 1;\n            for (int j = 1; j <= k; j++) {\n                \n                \n                \n                \n                \n                \n                final long d = gcd(i, j);\n                result = (result / (j / d)) * (i / d);\n                i++;\n            }\n        } else {\n            \n            \n            \n            int i = n - k + 1;\n            for (int j = 1; j <= k; j++) {\n                final long d = gcd(i, j);\n                result = mulAndCheck(result / (j / d), i / d);\n                i++;\n            }\n        }\n        return result;\n    }\n\n    \n    public static double binomialCoefficientDouble(final int n, final int k) {\n        checkBinomial(n, k);\n        if ((n == k) || (k == 0)) {\n            return 1d;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return n;\n        }\n        if (k > n/2) {\n            return binomialCoefficientDouble(n, n - k);\n        }\n        if (n < 67) {\n            return binomialCoefficient(n,k);\n        }\n\n        double result = 1d;\n        for (int i = 1; i <= k; i++) {\n             result *= (double)(n - k + i) / (double)i;\n        }\n\n        return Math.floor(result + 0.5);\n    }\n\n    \n    public static double binomialCoefficientLog(final int n, final int k) {\n        checkBinomial(n, k);\n        if ((n == k) || (k == 0)) {\n            return 0;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return Math.log(n);\n        }\n\n        \n        if (n < 67) {\n            return Math.log(binomialCoefficient(n,k));\n        }\n\n        \n        if (n < 1030) {\n            return Math.log(binomialCoefficientDouble(n, k));\n        }\n\n        if (k > n / 2) {\n            return binomialCoefficientLog(n, n - k);\n        }\n\n        \n        double logSum = 0;\n\n        \n        for (int i = n - k + 1; i <= n; i++) {\n            logSum += Math.log(i);\n        }\n\n        \n        for (int i = 2; i <= k; i++) {\n            logSum -= Math.log(i);\n        }\n\n        return logSum;\n    }\n\n    \n    private static void checkBinomial(final int n, final int k) throws IllegalArgumentException {\n        if (n < k) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                \"must have n >= k for binomial coefficient (n,k), got n = {0}, k = {1}\",\n                n, k);\n        }\n        if (n < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"must have n >= 0 for binomial coefficient (n,k), got n = {0}\",\n                  n);\n        }\n    }\n\n    \n    public static int compareTo(double x, double y, double eps) {\n        if (equals(x, y, eps)) {\n            return 0;\n        } else if (x < y) {\n          return -1;\n        }\n        return 1;\n    }\n\n    \n    public static double cosh(double x) {\n        return (Math.exp(x) + Math.exp(-x)) / 2.0;\n    }\n\n    \n    public static boolean equals(double x, double y) {\n        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n    }\n\n    \n    public static boolean equals(double x, double y, double eps) {\n      return equals(x, y) || (Math.abs(y - x) <= eps);\n    }\n\n    \n    public static boolean equals(double x, double y, int maxUlps) {\n        \n        \n        assert maxUlps > 0 && maxUlps < NAN_GAP;\n\n        long xInt = Double.doubleToLongBits(x);\n        long yInt = Double.doubleToLongBits(y);\n\n        \n        if (xInt < 0) {\n            xInt = SGN_MASK - xInt;\n        }\n        if (yInt < 0) {\n            yInt = SGN_MASK - yInt;\n        }\n\n        return Math.abs(xInt - yInt) <= maxUlps;\n    }\n\n    \n    public static boolean equals(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static long factorial(final int n) {\n        if (n < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"must have n >= 0 for n!, got n = {0}\",\n                  n);\n        }\n        if (n > 20) {\n            throw new ArithmeticException(\n                    \"factorial value is too large to fit in a long\");\n        }\n        return FACTORIALS[n];\n    }\n\n    \n    public static double factorialDouble(final int n) {\n        if (n < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"must have n >= 0 for n!, got n = {0}\",\n                  n);\n        }\n        if (n < 21) {\n            return factorial(n);\n        }\n        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n    }\n\n    \n    public static double factorialLog(final int n) {\n        if (n < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"must have n >= 0 for n!, got n = {0}\",\n                  n);\n        }\n        if (n < 21) {\n            return Math.log(factorial(n));\n        }\n        double logSum = 0;\n        for (int i = 2; i <= n; i++) {\n            logSum += Math.log(i);\n        }\n        return logSum;\n    }\n\n    \n    public static int gcd(final int p, final int q) {\n        int u = p;\n        int v = q;\n        if ((u == 0) || (v == 0)) {\n            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n                throw MathRuntimeException.createArithmeticException(\n                        \"overflow: gcd({0}, {1}) is 2^31\",\n                        p, q);\n            }\n            return Math.abs(u) + Math.abs(v);\n        }\n        \n        \n        \n        \n        \n        if (u > 0) {\n            u = -u;\n        } \n        if (v > 0) {\n            v = -v;\n        } \n        \n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { \n                                                            \n            u /= 2;\n            v /= 2;\n            k++; \n        }\n        if (k == 31) {\n            throw MathRuntimeException.createArithmeticException(\n                    \"overflow: gcd({0}, {1}) is 2^31\",\n                    p, q);\n        }\n        \n        \n        int t = ((u & 1) == 1) ? v : -(u / 2);\n        \n        \n        do {\n            \n            \n            while ((t & 1) == 0) { \n                t /= 2; \n            }\n            \n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            \n            t = (v - u) / 2;\n            \n            \n        } while (t != 0);\n        return -u * (1 << k); \n    }\n\n    \n    public static int hash(double value) {\n        return new Double(value).hashCode();\n    }\n\n    \n    public static int hash(double[] value) {\n        return Arrays.hashCode(value);\n    }\n\n    \n    public static byte indicator(final byte x) {\n        return (x >= ZB) ? PB : NB;\n    }\n\n    \n    public static double indicator(final double x) {\n        if (Double.isNaN(x)) {\n            return Double.NaN;\n        }\n        return (x >= 0.0) ? 1.0 : -1.0;\n    }\n\n    \n    public static float indicator(final float x) {\n        if (Float.isNaN(x)) {\n            return Float.NaN;\n        }\n        return (x >= 0.0F) ? 1.0F : -1.0F;\n    }\n\n    \n    public static int indicator(final int x) {\n        return (x >= 0) ? 1 : -1;\n    }\n\n    \n    public static long indicator(final long x) {\n        return (x >= 0L) ? 1L : -1L;\n    }\n\n    \n    public static short indicator(final short x) {\n        return (x >= ZS) ? PS : NS;\n    }\n\n    \n    public static int lcm(int a, int b) {\n        if (a==0 || b==0){\n            return 0;\n        }\n        int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n        if (lcm == Integer.MIN_VALUE){\n            throw new ArithmeticException(\"overflow: lcm is 2^31\");\n        }\n        return lcm;\n    }\n\n    \n    public static double log(double base, double x) {\n        return Math.log(x)/Math.log(base);\n    }\n\n    \n    public static int mulAndCheck(int x, int y) {\n        long m = ((long)x) * ((long)y);\n        if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: mul\");\n        }\n        return (int)m;\n    }\n\n    \n    public static long mulAndCheck(long a, long b) {\n        long ret;\n        String msg = \"overflow: multiply\";\n        if (a > b) {\n            \n            ret = mulAndCheck(b, a);\n        } else {\n            if (a < 0) {\n                if (b < 0) {\n                    \n                    if (a >= Long.MAX_VALUE / b) {\n                        ret = a * b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                    }\n                } else if (b > 0) {\n                    \n                    if (Long.MIN_VALUE / b <= a) {\n                        ret = a * b;\n                    } else {\n                        throw new ArithmeticException(msg);\n\n                    }\n                } else {\n                    \n                    ret = 0;\n                }\n            } else if (a > 0) {\n                \n                \n\n                \n                if (a <= Long.MAX_VALUE / b) {\n                    ret = a * b;\n                } else {\n                    throw new ArithmeticException(msg);\n                }\n            } else {\n                \n                ret = 0;\n            }\n        }\n        return ret;\n    }\n\n    \n    public static double nextAfter(double d, double direction) {\n\n        \n        if (Double.isNaN(d) || Double.isInfinite(d)) {\n                return d;\n        } else if (d == 0) {\n                return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n        }\n        \n        \n\n        \n        long bits     = Double.doubleToLongBits(d);\n        long sign     = bits & 0x8000000000000000L;\n        long exponent = bits & 0x7ff0000000000000L;\n        long mantissa = bits & 0x000fffffffffffffL;\n\n        if (d * (direction - d) >= 0) {\n                \n                if (mantissa == 0x000fffffffffffffL) {\n                        return Double.longBitsToDouble(sign |\n                                        (exponent + 0x0010000000000000L));\n                } else {\n                        return Double.longBitsToDouble(sign |\n                                        exponent | (mantissa + 1));\n                }\n        } else {\n                \n                if (mantissa == 0L) {\n                        return Double.longBitsToDouble(sign |\n                                        (exponent - 0x0010000000000000L) |\n                                        0x000fffffffffffffL);\n                } else {\n                        return Double.longBitsToDouble(sign |\n                                        exponent | (mantissa - 1));\n                }\n        }\n\n    }\n\n    \n    public static double scalb(final double d, final int scaleFactor) {\n\n        \n        if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {\n            return d;\n        }\n\n        \n        final long bits     = Double.doubleToLongBits(d);\n        final long exponent = bits & 0x7ff0000000000000L;\n        final long rest     = bits & 0x800fffffffffffffL;\n\n        \n        final long newBits = rest | (exponent + (((long) scaleFactor) << 52));\n        return Double.longBitsToDouble(newBits);\n\n    }\n\n    \n     public static double normalizeAngle(double a, double center) {\n         return a - TWO_PI * Math.floor((a + Math.PI - center) / TWO_PI);\n     }\n\n     \n     public static double[] normalizeArray(double[] values, double normalizedSum) throws ArithmeticException, IllegalArgumentException {\n         if (Double.isInfinite(normalizedSum)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"Cannot normalize to an infinite value\");\n         }\n         if (Double.isNaN(normalizedSum)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"Cannot normalize to NaN\");\n         }\n         double sum = 0d;\n         final int len = values.length;\n         double[] out = new double[len];\n         for (int i = 0; i < len; i++) {\n             if (Double.isInfinite(values[i])) {\n                 throw MathRuntimeException.createArithmeticException(\n                         \"Array contains an infinite element, {0} at index {1}\", values[i], i);\n             }\n             if (!Double.isNaN(values[i])) {\n                 sum += values[i];\n             }\n         }\n         if (sum == 0) {\n             throw MathRuntimeException.createArithmeticException(\n                     \"Array sums to zero\");\n         }\n         for (int i = 0; i < len; i++) {\n             if (Double.isNaN(values[i])) {\n                 out[i] = Double.NaN;\n             } else {\n                 out[i] = values[i] * normalizedSum / sum;\n             }\n         }\n         return out;\n     }\n\n    \n    public static double round(double x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }\n\n    \n    public static double round(double x, int scale, int roundingMethod) {\n        try {\n            return (new BigDecimal\n                   (Double.toString(x))\n                   .setScale(scale, roundingMethod))\n                   .doubleValue();\n        } catch (NumberFormatException ex) {\n            if (Double.isInfinite(x)) {\n                return x;\n            } else {\n                return Double.NaN;\n            }\n        }\n    }\n\n    \n    public static float round(float x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }\n\n    \n    public static float round(float x, int scale, int roundingMethod) {\n        float sign = indicator(x);\n        float factor = (float)Math.pow(10.0f, scale) * sign;\n        return (float)roundUnscaled(x * factor, sign, roundingMethod) / factor;\n    }\n\n    \n    private static double roundUnscaled(double unscaled, double sign, int roundingMethod) {\n        switch (roundingMethod) {\n        case BigDecimal.ROUND_CEILING :\n            if (sign == -1) {\n                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            } else {\n                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_DOWN :\n            unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            break;\n        case BigDecimal.ROUND_FLOOR :\n            if (sign == -1) {\n                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            } else {\n                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_HALF_DOWN : {\n            unscaled = nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction > 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else {\n                unscaled = Math.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_EVEN : {\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction > 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else if (fraction < 0.5) {\n                unscaled = Math.floor(unscaled);\n            } else {\n                \n                if (Math.floor(unscaled) / 2.0 == Math.floor(Math\n                    .floor(unscaled) / 2.0)) { \n                    unscaled = Math.floor(unscaled);\n                } else { \n                    unscaled = Math.ceil(unscaled);\n                }\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_UP : {\n            unscaled = nextAfter(unscaled, Double.POSITIVE_INFINITY);\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction >= 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else {\n                unscaled = Math.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_UNNECESSARY :\n            if (unscaled != Math.floor(unscaled)) {\n                throw new ArithmeticException(\"Inexact result from rounding\");\n            }\n            break;\n        case BigDecimal.ROUND_UP :\n            unscaled = Math.ceil(nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n            break;\n        default :\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid rounding method {0}, valid methods: {1} ({2}), {3} ({4}),\" +\n                  \" {5} ({6}), {7} ({8}), {9} ({10}), {11} ({12}), {13} ({14}), {15} ({16})\",\n                  roundingMethod,\n                  \"ROUND_CEILING\",     BigDecimal.ROUND_CEILING,\n                  \"ROUND_DOWN\",        BigDecimal.ROUND_DOWN,\n                  \"ROUND_FLOOR\",       BigDecimal.ROUND_FLOOR,\n                  \"ROUND_HALF_DOWN\",   BigDecimal.ROUND_HALF_DOWN,\n                  \"ROUND_HALF_EVEN\",   BigDecimal.ROUND_HALF_EVEN,\n                  \"ROUND_HALF_UP\",     BigDecimal.ROUND_HALF_UP,\n                  \"ROUND_UNNECESSARY\", BigDecimal.ROUND_UNNECESSARY,\n                  \"ROUND_UP\",          BigDecimal.ROUND_UP);\n        }\n        return unscaled;\n    }\n\n    \n    public static byte sign(final byte x) {\n        return (x == ZB) ? ZB : (x > ZB) ? PB : NB;\n    }\n\n    \n    public static double sign(final double x) {\n        if (Double.isNaN(x)) {\n            return Double.NaN;\n        }\n        return (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;\n    }\n\n    \n    public static float sign(final float x) {\n        if (Float.isNaN(x)) {\n            return Float.NaN;\n        }\n        return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;\n    }\n\n    \n    public static int sign(final int x) {\n        return (x == 0) ? 0 : (x > 0) ? 1 : -1;\n    }\n\n    \n    public static long sign(final long x) {\n        return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;\n    }\n\n    \n    public static short sign(final short x) {\n        return (x == ZS) ? ZS : (x > ZS) ? PS : NS;\n    }\n\n    \n    public static double sinh(double x) {\n        return (Math.exp(x) - Math.exp(-x)) / 2.0;\n    }\n\n    \n    public static int subAndCheck(int x, int y) {\n        long s = (long)x - (long)y;\n        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: subtract\");\n        }\n        return (int)s;\n    }\n\n    \n    public static long subAndCheck(long a, long b) {\n        long ret;\n        String msg = \"overflow: subtract\";\n        if (b == Long.MIN_VALUE) {\n            if (a < 0) {\n                ret = a - b;\n            } else {\n                throw new ArithmeticException(msg);\n            }\n        } else {\n            \n            ret = addAndCheck(a, -b, msg);\n        }\n        return ret;\n    }\n\n    \n    public static int pow(final int k, int e) throws IllegalArgumentException {\n\n        if (e < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                \"cannot raise an integral value to a negative power ({0}^{1})\",\n                k, e);\n        }\n\n        int result = 1;\n        int k2p    = k;\n        while (e != 0) {\n            if ((e & 0x1) != 0) {\n                result *= k2p;\n            }\n            k2p *= k2p;\n            e = e >> 1;\n        }\n\n        return result;\n\n    }\n\n    \n    public static int pow(final int k, long e) throws IllegalArgumentException {\n\n        if (e < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                \"cannot raise an integral value to a negative power ({0}^{1})\",\n                k, e);\n        }\n\n        int result = 1;\n        int k2p    = k;\n        while (e != 0) {\n            if ((e & 0x1) != 0) {\n                result *= k2p;\n            }\n            k2p *= k2p;\n            e = e >> 1;\n        }\n\n        return result;\n\n    }\n\n    \n    public static long pow(final long k, int e) throws IllegalArgumentException {\n\n        if (e < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                \"cannot raise an integral value to a negative power ({0}^{1})\",\n                k, e);\n        }\n\n        long result = 1l;\n        long k2p    = k;\n        while (e != 0) {\n            if ((e & 0x1) != 0) {\n                result *= k2p;\n            }\n            k2p *= k2p;\n            e = e >> 1;\n        }\n\n        return result;\n\n    }\n\n    \n    public static long pow(final long k, long e) throws IllegalArgumentException {\n\n        if (e < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                \"cannot raise an integral value to a negative power ({0}^{1})\",\n                k, e);\n        }\n\n        long result = 1l;\n        long k2p    = k;\n        while (e != 0) {\n            if ((e & 0x1) != 0) {\n                result *= k2p;\n            }\n            k2p *= k2p;\n            e = e >> 1;\n        }\n\n        return result;\n\n    }\n\n    \n    public static BigInteger pow(final BigInteger k, int e) throws IllegalArgumentException {\n\n        if (e < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                \"cannot raise an integral value to a negative power ({0}^{1})\",\n                k, e);\n        }\n\n        return k.pow(e);\n\n    }\n\n    \n    public static BigInteger pow(final BigInteger k, long e) throws IllegalArgumentException {\n\n        if (e < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                \"cannot raise an integral value to a negative power ({0}^{1})\",\n                k, e);\n        }\n\n        BigInteger result = BigInteger.ONE;\n        BigInteger k2p    = k;\n        while (e != 0) {\n            if ((e & 0x1) != 0) {\n                result = result.multiply(k2p);\n            }\n            k2p = k2p.multiply(k2p);\n            e = e >> 1;\n        }\n\n        return result;\n\n    }\n\n    \n    public static BigInteger pow(final BigInteger k, BigInteger e) throws IllegalArgumentException {\n\n        if (e.compareTo(BigInteger.ZERO) < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                \"cannot raise an integral value to a negative power ({0}^{1})\",\n                k, e);\n        }\n\n        BigInteger result = BigInteger.ONE;\n        BigInteger k2p    = k;\n        while (!BigInteger.ZERO.equals(e)) {\n            if (e.testBit(0)) {\n                result = result.multiply(k2p);\n            }\n            k2p = k2p.multiply(k2p);\n            e = e.shiftRight(1);\n        }\n\n        return result;\n\n    }\n\n    \n    public static double distance1(double[] p1, double[] p2) {\n        double sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += Math.abs(p1[i] - p2[i]);\n        }\n        return sum;\n    }\n\n    \n    public static int distance1(int[] p1, int[] p2) {\n      int sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          sum += Math.abs(p1[i] - p2[i]);\n      }\n      return sum;\n    }\n\n    \n    public static double distance(double[] p1, double[] p2) {\n        double sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            final double dp = p1[i] - p2[i];\n            sum += dp * dp;\n        }\n        return Math.sqrt(sum);\n    }\n\n    \n    public static double distance(int[] p1, int[] p2) {\n      int sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final int dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }\n      return Math.sqrt(sum);\n    }\n\n    \n    public static double distanceInf(double[] p1, double[] p2) {\n        double max = 0;\n        for (int i = 0; i < p1.length; i++) {\n            max = Math.max(max, Math.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }\n\n    \n    public static int distanceInf(int[] p1, int[] p2) {\n        int max = 0;\n        for (int i = 0; i < p1.length; i++) {\n            max = Math.max(max, Math.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }\n\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.util;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Arrays;\n\nimport org.apache.commons.math.MathRuntimeException;\n\n\npublic final class MathUtils { public static final double EPSILON = 0x1.0p-53; public static final double SAFE_MIN = 0x1.0p-1022; public static final double TWO_PI = 2 * Math.PI; private static final byte NB = (byte)-1; private static final short NS = (short)-1; private static final byte PB = (byte)1; private static final short PS = (short)1; private static final byte ZB = (byte)0; private static final short ZS = (short)0; private static final int NAN_GAP = 4 * 1024 * 1024; private static final long SGN_MASK = 0x8000000000000000L; private static final long[] FACTORIALS = new long[] {\n                       1l,                  1l,                   2l,\n                       6l,                 24l,                 120l,\n                     720l,               5040l,               40320l,\n                  362880l,            3628800l,            39916800l,\n               479001600l,         6227020800l,         87178291200l,\n           1307674368000l,     20922789888000l,     355687428096000l,\n        6402373705728000l, 121645100408832000l, 2432902008176640000l };\n\n    \n    private MathUtils() {\n        super();\n    }\n\n    \n    public static int addAndCheck(int x, int y) {\n        long s = (long)x + (long)y;\n        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: add\");\n        }\n        return (int)s;\n    }\n\n    \n    public static long addAndCheck(long a, long b) {\n        return addAndCheck(a, b, \"overflow: add\");\n    }\n\n    \n    private static long addAndCheck(long a, long b, String msg) {\n        long ret;\n        if (a > b) {\n            \n            ret = addAndCheck(b, a, msg);\n        } else {\n            \n\n            if (a < 0) {\n                if (b < 0) {\n                    \n                    if (Long.MIN_VALUE - b <= a) {\n                        ret = a + b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                    }\n                } else {\n                    \n                    ret = a + b;\n                }\n            } else {\n                \n                \n\n                \n                if (a <= Long.MAX_VALUE - b) {\n                    ret = a + b;\n                } else {\n                    throw new ArithmeticException(msg);\n                }\n            }\n        }\n        return ret;\n    }\n\n    \n    public static long binomialCoefficient(final int n, final int k) {\n        checkBinomial(n, k);\n        if ((n == k) || (k == 0)) {\n            return 1;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return n;\n        }\n        \n        if (k > n / 2)\n            return binomialCoefficient(n, n - k);\n\n        \n        \n        \n        \n        \n        long result = 1;\n        if (n <= 61) {\n            \n            int i = n - k + 1;\n            for (int j = 1; j <= k; j++) {\n                result = result * i / j;\n                i++;\n            }\n        } else if (n <= 66) {\n            \n            \n            int i = n - k + 1;\n            for (int j = 1; j <= k; j++) {\n                \n                \n                \n                \n                \n                \n                final long d = gcd(i, j);\n                result = (result / (j / d)) * (i / d);\n                i++;\n            }\n        } else {\n            \n            \n            \n            int i = n - k + 1;\n            for (int j = 1; j <= k; j++) {\n                final long d = gcd(i, j);\n                result = mulAndCheck(result / (j / d), i / d);\n                i++;\n            }\n        }\n        return result;\n    }\n\n    \n    public static double binomialCoefficientDouble(final int n, final int k) {\n        checkBinomial(n, k);\n        if ((n == k) || (k == 0)) {\n            return 1d;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return n;\n        }\n        if (k > n/2) {\n            return binomialCoefficientDouble(n, n - k);\n        }\n        if (n < 67) {\n            return binomialCoefficient(n,k);\n        }\n\n        double result = 1d;\n        for (int i = 1; i <= k; i++) {\n             result *= (double)(n - k + i) / (double)i;\n        }\n\n        return Math.floor(result + 0.5);\n    }\n\n    \n    public static double binomialCoefficientLog(final int n, final int k) {\n        checkBinomial(n, k);\n        if ((n == k) || (k == 0)) {\n            return 0;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return Math.log(n);\n        }\n\n        \n        if (n < 67) {\n            return Math.log(binomialCoefficient(n,k));\n        }\n\n        \n        if (n < 1030) {\n            return Math.log(binomialCoefficientDouble(n, k));\n        }\n\n        if (k > n / 2) {\n            return binomialCoefficientLog(n, n - k);\n        }\n\n        \n        double logSum = 0;\n\n        \n        for (int i = n - k + 1; i <= n; i++) {\n            logSum += Math.log(i);\n        }\n\n        \n        for (int i = 2; i <= k; i++) {\n            logSum -= Math.log(i);\n        }\n\n        return logSum;\n    }\n\n    \n    private static void checkBinomial(final int n, final int k) throws IllegalArgumentException {\n        if (n < k) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                \"must have n >= k for binomial coefficient (n,k), got n = {0}, k = {1}\",\n                n, k);\n        }\n        if (n < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"must have n >= 0 for binomial coefficient (n,k), got n = {0}\",\n                  n);\n        }\n    }\n\n    \n    public static int compareTo(double x, double y, double eps) {\n        if (equals(x, y, eps)) {\n            return 0;\n        } else if (x < y) {\n          return -1;\n        }\n        return 1;\n    }\n\n    \n    public static double cosh(double x) {\n        return (Math.exp(x) + Math.exp(-x)) / 2.0;\n    }\n\n    \n    public static boolean equals(double x, double y) {\n        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n    }\n\n    \n    public static boolean equals(double x, double y, double eps) {\n      return equals(x, y) || (Math.abs(y - x) <= eps);\n    }\n\n    \n    public static boolean equals(double x, double y, int maxUlps) {\n        \n        \n        assert maxUlps > 0 && maxUlps < NAN_GAP;\n\n        long xInt = Double.doubleToLongBits(x);\n        long yInt = Double.doubleToLongBits(y);\n\n        \n        if (xInt < 0) {\n            xInt = SGN_MASK - xInt;\n        }\n        if (yInt < 0) {\n            yInt = SGN_MASK - yInt;\n        }\n\n        return Math.abs(xInt - yInt) <= maxUlps;\n    }\n\n    \n    public static boolean equals(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public static long factorial(final int n) {\n        if (n < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"must have n >= 0 for n!, got n = {0}\",\n                  n);\n        }\n        if (n > 20) {\n            throw new ArithmeticException(\n                    \"factorial value is too large to fit in a long\");\n        }\n        return FACTORIALS[n];\n    }\n\n    \n    public static double factorialDouble(final int n) {\n        if (n < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"must have n >= 0 for n!, got n = {0}\",\n                  n);\n        }\n        if (n < 21) {\n            return factorial(n);\n        }\n        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n    }\n\n    \n    public static double factorialLog(final int n) {\n        if (n < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"must have n >= 0 for n!, got n = {0}\",\n                  n);\n        }\n        if (n < 21) {\n            return Math.log(factorial(n));\n        }\n        double logSum = 0;\n        for (int i = 2; i <= n; i++) {\n            logSum += Math.log(i);\n        }\n        return logSum;\n    }\n\n    \n    public static int gcd(final int p, final int q) {\n        int u = p;\n        int v = q;\n        if ((u == 0) || (v == 0)) {\n            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n                throw MathRuntimeException.createArithmeticException(\n                        \"overflow: gcd({0}, {1}) is 2^31\",\n                        p, q);\n            }\n            return Math.abs(u) + Math.abs(v);\n        }\n        \n        \n        \n        \n        \n        if (u > 0) {\n            u = -u;\n        } \n        if (v > 0) {\n            v = -v;\n        } \n        \n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { \n                                                            \n            u /= 2;\n            v /= 2;\n            k++; \n        }\n        if (k == 31) {\n            throw MathRuntimeException.createArithmeticException(\n                    \"overflow: gcd({0}, {1}) is 2^31\",\n                    p, q);\n        }\n        \n        \n        int t = ((u & 1) == 1) ? v : -(u / 2);\n        \n        \n        do {\n            \n            \n            while ((t & 1) == 0) { \n                t /= 2; \n            }\n            \n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            \n            t = (v - u) / 2;\n            \n            \n        } while (t != 0);\n        return -u * (1 << k); \n    }\n\n    \n    public static int hash(double value) {\n        return new Double(value).hashCode();\n    }\n\n    \n    public static int hash(double[] value) {\n        return Arrays.hashCode(value);\n    }\n\n    \n    public static byte indicator(final byte x) {\n        return (x >= ZB) ? PB : NB;\n    }\n\n    \n    public static double indicator(final double x) {\n        if (Double.isNaN(x)) {\n            return Double.NaN;\n        }\n        return (x >= 0.0) ? 1.0 : -1.0;\n    }\n\n    \n    public static float indicator(final float x) {\n        if (Float.isNaN(x)) {\n            return Float.NaN;\n        }\n        return (x >= 0.0F) ? 1.0F : -1.0F;\n    }\n\n    \n    public static int indicator(final int x) {\n        return (x >= 0) ? 1 : -1;\n    }\n\n    \n    public static long indicator(final long x) {\n        return (x >= 0L) ? 1L : -1L;\n    }\n\n    \n    public static short indicator(final short x) {\n        return (x >= ZS) ? PS : NS;\n    }\n\n    \n    public static int lcm(int a, int b) {\n        if (a==0 || b==0){\n            return 0;\n        }\n        int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n        if (lcm == Integer.MIN_VALUE){\n            throw new ArithmeticException(\"overflow: lcm is 2^31\");\n        }\n        return lcm;\n    }\n\n    \n    public static double log(double base, double x) {\n        return Math.log(x)/Math.log(base);\n    }\n\n    \n    public static int mulAndCheck(int x, int y) {\n        long m = ((long)x) * ((long)y);\n        if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: mul\");\n        }\n        return (int)m;\n    }\n\n    \n    public static long mulAndCheck(long a, long b) {\n        long ret;\n        String msg = \"overflow: multiply\";\n        if (a > b) {\n            \n            ret = mulAndCheck(b, a);\n        } else {\n            if (a < 0) {\n                if (b < 0) {\n                    \n                    if (a >= Long.MAX_VALUE / b) {\n                        ret = a * b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                    }\n                } else if (b > 0) {\n                    \n                    if (Long.MIN_VALUE / b <= a) {\n                        ret = a * b;\n                    } else {\n                        throw new ArithmeticException(msg);\n\n                    }\n                } else {\n                    \n                    ret = 0;\n                }\n            } else if (a > 0) {\n                \n                \n\n                \n                if (a <= Long.MAX_VALUE / b) {\n                    ret = a * b;\n                } else {\n                    throw new ArithmeticException(msg);\n                }\n            } else {\n                \n                ret = 0;\n            }\n        }\n        return ret;\n    }\n\n    \n    public static double nextAfter(double d, double direction) {\n\n        \n        if (Double.isNaN(d) || Double.isInfinite(d)) {\n                return d;\n        } else if (d == 0) {\n                return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n        }\n        \n        \n\n        \n        long bits     = Double.doubleToLongBits(d);\n        long sign     = bits & 0x8000000000000000L;\n        long exponent = bits & 0x7ff0000000000000L;\n        long mantissa = bits & 0x000fffffffffffffL;\n\n        if (d * (direction - d) >= 0) {\n                \n                if (mantissa == 0x000fffffffffffffL) {\n                        return Double.longBitsToDouble(sign |\n                                        (exponent + 0x0010000000000000L));\n                } else {\n                        return Double.longBitsToDouble(sign |\n                                        exponent | (mantissa + 1));\n                }\n        } else {\n                \n                if (mantissa == 0L) {\n                        return Double.longBitsToDouble(sign |\n                                        (exponent - 0x0010000000000000L) |\n                                        0x000fffffffffffffL);\n                } else {\n                        return Double.longBitsToDouble(sign |\n                                        exponent | (mantissa - 1));\n                }\n        }\n\n    }\n\n    \n    public static double scalb(final double d, final int scaleFactor) {\n\n        \n        if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {\n            return d;\n        }\n\n        \n        final long bits     = Double.doubleToLongBits(d);\n        final long exponent = bits & 0x7ff0000000000000L;\n        final long rest     = bits & 0x800fffffffffffffL;\n\n        \n        final long newBits = rest | (exponent + (((long) scaleFactor) << 52));\n        return Double.longBitsToDouble(newBits);\n\n    }\n\n    \n     public static double normalizeAngle(double a, double center) {\n         return a - TWO_PI * Math.floor((a + Math.PI - center) / TWO_PI);\n     }\n\n     \n     public static double[] normalizeArray(double[] values, double normalizedSum) throws ArithmeticException, IllegalArgumentException {\n         if (Double.isInfinite(normalizedSum)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"Cannot normalize to an infinite value\");\n         }\n         if (Double.isNaN(normalizedSum)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"Cannot normalize to NaN\");\n         }\n         double sum = 0d;\n         final int len = values.length;\n         double[] out = new double[len];\n         for (int i = 0; i < len; i++) {\n             if (Double.isInfinite(values[i])) {\n                 throw MathRuntimeException.createArithmeticException(\n                         \"Array contains an infinite element, {0} at index {1}\", values[i], i);\n             }\n             if (!Double.isNaN(values[i])) {\n                 sum += values[i];\n             }\n         }\n         if (sum == 0) {\n             throw MathRuntimeException.createArithmeticException(\n                     \"Array sums to zero\");\n         }\n         for (int i = 0; i < len; i++) {\n             if (Double.isNaN(values[i])) {\n                 out[i] = Double.NaN;\n             } else {\n                 out[i] = values[i] * normalizedSum / sum;\n             }\n         }\n         return out;\n     }\n\n    \n    public static double round(double x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }\n\n    \n    public static double round(double x, int scale, int roundingMethod) {\n        try {\n            return (new BigDecimal\n                   (Double.toString(x))\n                   .setScale(scale, roundingMethod))\n                   .doubleValue();\n        } catch (NumberFormatException ex) {\n            if (Double.isInfinite(x)) {\n                return x;\n            } else {\n                return Double.NaN;\n            }\n        }\n    }\n\n    \n    public static float round(float x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }\n\n    \n    public static float round(float x, int scale, int roundingMethod) {\n        float sign = indicator(x);\n        float factor = (float)Math.pow(10.0f, scale) * sign;\n        return (float)roundUnscaled(x * factor, sign, roundingMethod) / factor;\n    }\n\n    \n    private static double roundUnscaled(double unscaled, double sign, int roundingMethod) {\n        switch (roundingMethod) {\n        case BigDecimal.ROUND_CEILING :\n            if (sign == -1) {\n                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            } else {\n                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_DOWN :\n            unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            break;\n        case BigDecimal.ROUND_FLOOR :\n            if (sign == -1) {\n                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            } else {\n                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_HALF_DOWN : {\n            unscaled = nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction > 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else {\n                unscaled = Math.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_EVEN : {\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction > 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else if (fraction < 0.5) {\n                unscaled = Math.floor(unscaled);\n            } else {\n                \n                if (Math.floor(unscaled) / 2.0 == Math.floor(Math\n                    .floor(unscaled) / 2.0)) { \n                    unscaled = Math.floor(unscaled);\n                } else { \n                    unscaled = Math.ceil(unscaled);\n                }\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_UP : {\n            unscaled = nextAfter(unscaled, Double.POSITIVE_INFINITY);\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction >= 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else {\n                unscaled = Math.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_UNNECESSARY :\n            if (unscaled != Math.floor(unscaled)) {\n                throw new ArithmeticException(\"Inexact result from rounding\");\n            }\n            break;\n        case BigDecimal.ROUND_UP :\n            unscaled = Math.ceil(nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n            break;\n        default :\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid rounding method {0}, valid methods: {1} ({2}), {3} ({4}),\" +\n                  \" {5} ({6}), {7} ({8}), {9} ({10}), {11} ({12}), {13} ({14}), {15} ({16})\",\n                  roundingMethod,\n                  \"ROUND_CEILING\",     BigDecimal.ROUND_CEILING,\n                  \"ROUND_DOWN\",        BigDecimal.ROUND_DOWN,\n                  \"ROUND_FLOOR\",       BigDecimal.ROUND_FLOOR,\n                  \"ROUND_HALF_DOWN\",   BigDecimal.ROUND_HALF_DOWN,\n                  \"ROUND_HALF_EVEN\",   BigDecimal.ROUND_HALF_EVEN,\n                  \"ROUND_HALF_UP\",     BigDecimal.ROUND_HALF_UP,\n                  \"ROUND_UNNECESSARY\", BigDecimal.ROUND_UNNECESSARY,\n                  \"ROUND_UP\",          BigDecimal.ROUND_UP);\n        }\n        return unscaled;\n    }\n\n    \n    public static byte sign(final byte x) {\n        return (x == ZB) ? ZB : (x > ZB) ? PB : NB;\n    }\n\n    \n    public static double sign(final double x) {\n        if (Double.isNaN(x)) {\n            return Double.NaN;\n        }\n        return (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;\n    }\n\n    \n    public static float sign(final float x) {\n        if (Float.isNaN(x)) {\n            return Float.NaN;\n        }\n        return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;\n    }\n\n    \n    public static int sign(final int x) {\n        return (x == 0) ? 0 : (x > 0) ? 1 : -1;\n    }\n\n    \n    public static long sign(final long x) {\n        return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;\n    }\n\n    \n    public static short sign(final short x) {\n        return (x == ZS) ? ZS : (x > ZS) ? PS : NS;\n    }\n\n    \n    public static double sinh(double x) {\n        return (Math.exp(x) - Math.exp(-x)) / 2.0;\n    }\n\n    \n    public static int subAndCheck(int x, int y) {\n        long s = (long)x - (long)y;\n        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: subtract\");\n        }\n        return (int)s;\n    }\n\n    \n    public static long subAndCheck(long a, long b) {\n        long ret;\n        String msg = \"overflow: subtract\";\n        if (b == Long.MIN_VALUE) {\n            if (a < 0) {\n                ret = a - b;\n            } else {\n                throw new ArithmeticException(msg);\n            }\n        } else {\n            \n            ret = addAndCheck(a, -b, msg);\n        }\n        return ret;\n    }\n\n    \n    public static int pow(final int k, int e) throws IllegalArgumentException {\n\n        if (e < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                \"cannot raise an integral value to a negative power ({0}^{1})\",\n                k, e);\n        }\n\n        int result = 1;\n        int k2p    = k;\n        while (e != 0) {\n            if ((e & 0x1) != 0) {\n                result *= k2p;\n            }\n            k2p *= k2p;\n            e = e >> 1;\n        }\n\n        return result;\n\n    }\n\n    \n    public static int pow(final int k, long e) throws IllegalArgumentException {\n\n        if (e < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                \"cannot raise an integral value to a negative power ({0}^{1})\",\n                k, e);\n        }\n\n        int result = 1;\n        int k2p    = k;\n        while (e != 0) {\n            if ((e & 0x1) != 0) {\n                result *= k2p;\n            }\n            k2p *= k2p;\n            e = e >> 1;\n        }\n\n        return result;\n\n    }\n\n    \n    public static long pow(final long k, int e) throws IllegalArgumentException {\n\n        if (e < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                \"cannot raise an integral value to a negative power ({0}^{1})\",\n                k, e);\n        }\n\n        long result = 1l;\n        long k2p    = k;\n        while (e != 0) {\n            if ((e & 0x1) != 0) {\n                result *= k2p;\n            }\n            k2p *= k2p;\n            e = e >> 1;\n        }\n\n        return result;\n\n    }\n\n    \n    public static long pow(final long k, long e) throws IllegalArgumentException {\n\n        if (e < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                \"cannot raise an integral value to a negative power ({0}^{1})\",\n                k, e);\n        }\n\n        long result = 1l;\n        long k2p    = k;\n        while (e != 0) {\n            if ((e & 0x1) != 0) {\n                result *= k2p;\n            }\n            k2p *= k2p;\n            e = e >> 1;\n        }\n\n        return result;\n\n    }\n\n    \n    public static BigInteger pow(final BigInteger k, int e) throws IllegalArgumentException {\n\n        if (e < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                \"cannot raise an integral value to a negative power ({0}^{1})\",\n                k, e);\n        }\n\n        return k.pow(e);\n\n    }\n\n    \n    public static BigInteger pow(final BigInteger k, long e) throws IllegalArgumentException {\n\n        if (e < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                \"cannot raise an integral value to a negative power ({0}^{1})\",\n                k, e);\n        }\n\n        BigInteger result = BigInteger.ONE;\n        BigInteger k2p    = k;\n        while (e != 0) {\n            if ((e & 0x1) != 0) {\n                result = result.multiply(k2p);\n            }\n            k2p = k2p.multiply(k2p);\n            e = e >> 1;\n        }\n\n        return result;\n\n    }\n\n    \n    public static BigInteger pow(final BigInteger k, BigInteger e) throws IllegalArgumentException {\n\n        if (e.compareTo(BigInteger.ZERO) < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                \"cannot raise an integral value to a negative power ({0}^{1})\",\n                k, e);\n        }\n\n        BigInteger result = BigInteger.ONE;\n        BigInteger k2p    = k;\n        while (!BigInteger.ZERO.equals(e)) {\n            if (e.testBit(0)) {\n                result = result.multiply(k2p);\n            }\n            k2p = k2p.multiply(k2p);\n            e = e.shiftRight(1);\n        }\n\n        return result;\n\n    }\n\n    \n    public static double distance1(double[] p1, double[] p2) {\n        double sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += Math.abs(p1[i] - p2[i]);\n        }\n        return sum;\n    }\n\n    \n    public static int distance1(int[] p1, int[] p2) {\n      int sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          sum += Math.abs(p1[i] - p2[i]);\n      }\n      return sum;\n    }\n\n    \n    public static double distance(double[] p1, double[] p2) {\n        double sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            final double dp = p1[i] - p2[i];\n            sum += dp * dp;\n        }\n        return Math.sqrt(sum);\n    }\n\n    \n    public static double distance(int[] p1, int[] p2) {\n      double sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final double dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }\n      return Math.sqrt(sum);\n    }\n\n    \n    public static double distanceInf(double[] p1, double[] p2) {\n        double max = 0;\n        for (int i = 0; i < p1.length; i++) {\n            max = Math.max(max, Math.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }\n\n    \n    public static int distanceInf(int[] p1, int[] p2) {\n        int max = 0;\n        for (int i = 0; i < p1.length; i++) {\n            max = Math.max(max, Math.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }\n\n\n}\n",
      "buggy_signatures": [
        "private MathUtils()",
        "public static int addAndCheck(int x, int y)",
        "public static long addAndCheck(long a, long b)",
        "private static long addAndCheck(long a, long b, String msg)",
        "public static long binomialCoefficient(final int n, final int k)",
        "public static double binomialCoefficientDouble(final int n, final int k)",
        "public static double binomialCoefficientLog(final int n, final int k)",
        "private static void checkBinomial(final int n, final int k) throws IllegalArgumentException",
        "public static int compareTo(double x, double y, double eps)",
        "public static double cosh(double x)",
        "public static boolean equals(double x, double y)",
        "public static boolean equals(double x, double y, double eps)",
        "public static boolean equals(double x, double y, int maxUlps)",
        "public static boolean equals(double[] x, double[] y)",
        "public static long factorial(final int n)",
        "public static double factorialDouble(final int n)",
        "public static double factorialLog(final int n)",
        "public static int gcd(final int p, final int q)",
        "public static int hash(double value)",
        "public static int hash(double[] value)",
        "public static byte indicator(final byte x)",
        "public static double indicator(final double x)",
        "public static float indicator(final float x)",
        "public static int indicator(final int x)",
        "public static long indicator(final long x)",
        "public static short indicator(final short x)",
        "public static int lcm(int a, int b)",
        "public static double log(double base, double x)",
        "public static int mulAndCheck(int x, int y)",
        "public static long mulAndCheck(long a, long b)",
        "public static double nextAfter(double d, double direction)",
        "public static double scalb(final double d, final int scaleFactor)",
        "public static double normalizeAngle(double a, double center)",
        "public static double[] normalizeArray(double[] values, double normalizedSum) throws ArithmeticException, IllegalArgumentException",
        "public static double round(double x, int scale)",
        "public static double round(double x, int scale, int roundingMethod)",
        "public static float round(float x, int scale)",
        "public static float round(float x, int scale, int roundingMethod)",
        "private static double roundUnscaled(double unscaled, double sign, int roundingMethod)",
        "public static byte sign(final byte x)",
        "public static double sign(final double x)",
        "public static float sign(final float x)",
        "public static int sign(final int x)",
        "public static long sign(final long x)",
        "public static short sign(final short x)",
        "public static double sinh(double x)",
        "public static int subAndCheck(int x, int y)",
        "public static long subAndCheck(long a, long b)",
        "public static int pow(final int k, int e) throws IllegalArgumentException",
        "public static int pow(final int k, long e) throws IllegalArgumentException",
        "public static long pow(final long k, int e) throws IllegalArgumentException",
        "public static long pow(final long k, long e) throws IllegalArgumentException",
        "public static BigInteger pow(final BigInteger k, int e) throws IllegalArgumentException",
        "public static BigInteger pow(final BigInteger k, long e) throws IllegalArgumentException",
        "public static BigInteger pow(final BigInteger k, BigInteger e) throws IllegalArgumentException",
        "public static double distance1(double[] p1, double[] p2)",
        "public static int distance1(int[] p1, int[] p2)",
        "public static double distance(double[] p1, double[] p2)",
        "public static double distance(int[] p1, int[] p2)",
        "public static double distanceInf(double[] p1, double[] p2)",
        "public static int distanceInf(int[] p1, int[] p2)"
      ],
      "fixed_signatures": [
        "private MathUtils()",
        "public static int addAndCheck(int x, int y)",
        "public static long addAndCheck(long a, long b)",
        "private static long addAndCheck(long a, long b, String msg)",
        "public static long binomialCoefficient(final int n, final int k)",
        "public static double binomialCoefficientDouble(final int n, final int k)",
        "public static double binomialCoefficientLog(final int n, final int k)",
        "private static void checkBinomial(final int n, final int k) throws IllegalArgumentException",
        "public static int compareTo(double x, double y, double eps)",
        "public static double cosh(double x)",
        "public static boolean equals(double x, double y)",
        "public static boolean equals(double x, double y, double eps)",
        "public static boolean equals(double x, double y, int maxUlps)",
        "public static boolean equals(double[] x, double[] y)",
        "public static long factorial(final int n)",
        "public static double factorialDouble(final int n)",
        "public static double factorialLog(final int n)",
        "public static int gcd(final int p, final int q)",
        "public static int hash(double value)",
        "public static int hash(double[] value)",
        "public static byte indicator(final byte x)",
        "public static double indicator(final double x)",
        "public static float indicator(final float x)",
        "public static int indicator(final int x)",
        "public static long indicator(final long x)",
        "public static short indicator(final short x)",
        "public static int lcm(int a, int b)",
        "public static double log(double base, double x)",
        "public static int mulAndCheck(int x, int y)",
        "public static long mulAndCheck(long a, long b)",
        "public static double nextAfter(double d, double direction)",
        "public static double scalb(final double d, final int scaleFactor)",
        "public static double normalizeAngle(double a, double center)",
        "public static double[] normalizeArray(double[] values, double normalizedSum) throws ArithmeticException, IllegalArgumentException",
        "public static double round(double x, int scale)",
        "public static double round(double x, int scale, int roundingMethod)",
        "public static float round(float x, int scale)",
        "public static float round(float x, int scale, int roundingMethod)",
        "private static double roundUnscaled(double unscaled, double sign, int roundingMethod)",
        "public static byte sign(final byte x)",
        "public static double sign(final double x)",
        "public static float sign(final float x)",
        "public static int sign(final int x)",
        "public static long sign(final long x)",
        "public static short sign(final short x)",
        "public static double sinh(double x)",
        "public static int subAndCheck(int x, int y)",
        "public static long subAndCheck(long a, long b)",
        "public static int pow(final int k, int e) throws IllegalArgumentException",
        "public static int pow(final int k, long e) throws IllegalArgumentException",
        "public static long pow(final long k, int e) throws IllegalArgumentException",
        "public static long pow(final long k, long e) throws IllegalArgumentException",
        "public static BigInteger pow(final BigInteger k, int e) throws IllegalArgumentException",
        "public static BigInteger pow(final BigInteger k, long e) throws IllegalArgumentException",
        "public static BigInteger pow(final BigInteger k, BigInteger e) throws IllegalArgumentException",
        "public static double distance1(double[] p1, double[] p2)",
        "public static int distance1(int[] p1, int[] p2)",
        "public static double distance(double[] p1, double[] p2)",
        "public static double distance(int[] p1, int[] p2)",
        "public static double distanceInf(double[] p1, double[] p2)",
        "public static int distanceInf(int[] p1, int[] p2)"
      ],
      "methods": [
        {
          "buggy_method": "  public static double distance(int[] p1, int[] p2) {\n  int sum = 0;\n  for (int i = 0; i < p1.length; i++) {\n  final int dp = p1[i] - p2[i];\n  sum += dp * dp;\n  }\n  return Math.sqrt(sum);\n  }",
          "fixed_method": "  public static double distance(int[] p1, int[] p2) {\n  double sum = 0;\n  for (int i = 0; i < p1.length; i++) {\n  final double dp = p1[i] - p2[i];\n  sum += dp * dp;\n  }\n  return Math.sqrt(sum);\n  }",
          "diff": [
            "@@ -1621,9 +1621,9 @@",
            "      * @return the L<sub>2</sub> distance between the two points\n",
            "      */\n",
            "     public static double distance(int[] p1, int[] p2) {\n",
            "-      int sum = 0;\n",
            "+      double sum = 0;\n",
            "       for (int i = 0; i < p1.length; i++) {\n",
            "-          final int dp = p1[i] - p2[i];\n",
            "+          final double dp = p1[i] - p2[i];\n",
            "           sum += dp * dp;\n",
            "       }\n",
            "       return Math.sqrt(sum);\n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
