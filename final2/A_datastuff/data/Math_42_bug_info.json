{
  "bug_id": "42",
  "failed_tests": {
    "org.apache.commons.math.optimization.linear.SimplexSolverTest": [
      {
        "methodName": "testMath713NegativeVariable",
        "error": "junit.framework.AssertionFailedError",
        "message": "",
        "fail_line": "        Assert.assertTrue(Precision.compareTo(solution.getPoint()[1], 0.0d, epsilon) >= 0);",
        "test_source": "  public void testMath713NegativeVariable() {\n  LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {1.0, 1.0}, 0.0d);\n  ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n  constraints.add(new LinearConstraint(new double[] {1, 0}, Relationship.EQ, 1));\n\n  double epsilon = 1e-6;\n  SimplexSolver solver = new SimplexSolver();\n  RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);\n\n  Assert.assertTrue(Precision.compareTo(solution.getPoint()[0], 0.0d, epsilon) >= 0);\n  Assert.assertTrue(Precision.compareTo(solution.getPoint()[1], 0.0d, epsilon) >= 0);\n  }",
        "stack": [
          "SimplexSolverTest.testMath713NegativeVariable line 43"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/optimization/linear/SimplexTableau.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.optimization.linear;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.commons.math.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math.linear.MatrixUtils;\nimport org.apache.commons.math.linear.RealMatrix;\nimport org.apache.commons.math.linear.RealVector;\nimport org.apache.commons.math.optimization.GoalType;\nimport org.apache.commons.math.optimization.RealPointValuePair;\nimport org.apache.commons.math.util.Precision;\n\n\nclass SimplexTableau implements Serializable {\n\n    \n    private static final String NEGATIVE_VAR_COLUMN_LABEL = \"x-\"; private static final int DEFAULT_ULPS = 10; private static final long serialVersionUID = -1369660067587938365L; private final LinearObjectiveFunction f; private final List<LinearConstraint> constraints; private final boolean restrictToNonNegative; private final List<String> columnLabels = new ArrayList<String>(); private transient RealMatrix tableau; private final int numDecisionVariables; private final int numSlackVariables; private int numArtificialVariables; private final double epsilon; private final int maxUlps; SimplexTableau(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative, final double epsilon) {\n        this(f, constraints, goalType, restrictToNonNegative, epsilon, DEFAULT_ULPS);\n    }\n\n    \n    SimplexTableau(final LinearObjectiveFunction f,\n                   final Collection<LinearConstraint> constraints,\n                   final GoalType goalType, final boolean restrictToNonNegative,\n                   final double epsilon,\n                   final int maxUlps) {\n        this.f                      = f;\n        this.constraints            = normalizeConstraints(constraints);\n        this.restrictToNonNegative  = restrictToNonNegative;\n        this.epsilon                = epsilon;\n        this.maxUlps                = maxUlps;\n        this.numDecisionVariables   = f.getCoefficients().getDimension() +\n                                      (restrictToNonNegative ? 0 : 1);\n        this.numSlackVariables      = getConstraintTypeCounts(Relationship.LEQ) +\n                                      getConstraintTypeCounts(Relationship.GEQ);\n        this.numArtificialVariables = getConstraintTypeCounts(Relationship.EQ) +\n                                      getConstraintTypeCounts(Relationship.GEQ);\n        this.tableau = createTableau(goalType == GoalType.MAXIMIZE);\n        initializeColumnLabels();\n    }\n\n    \n    protected void initializeColumnLabels() {\n      if (getNumObjectiveFunctions() == 2) {\n        columnLabels.add(\"W\");\n      }\n      columnLabels.add(\"Z\");\n      for (int i = 0; i < getOriginalNumDecisionVariables(); i++) {\n        columnLabels.add(\"x\" + i);\n      }\n      if (!restrictToNonNegative) {\n        columnLabels.add(NEGATIVE_VAR_COLUMN_LABEL);\n      }\n      for (int i = 0; i < getNumSlackVariables(); i++) {\n        columnLabels.add(\"s\" + i);\n      }\n      for (int i = 0; i < getNumArtificialVariables(); i++) {\n        columnLabels.add(\"a\" + i);\n      }\n      columnLabels.add(\"RHS\");\n    }\n\n    \n    protected RealMatrix createTableau(final boolean maximize) {\n\n        \n        int width = numDecisionVariables + numSlackVariables +\n        numArtificialVariables + getNumObjectiveFunctions() + 1; \n        int height = constraints.size() + getNumObjectiveFunctions();\n        Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width);\n\n        \n        if (getNumObjectiveFunctions() == 2) {\n            matrix.setEntry(0, 0, -1);\n        }\n        int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;\n        matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1);\n        RealVector objectiveCoefficients =\n            maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();\n        copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]);\n        matrix.setEntry(zIndex, width - 1,\n            maximize ? f.getConstantTerm() : -1 * f.getConstantTerm());\n\n        if (!restrictToNonNegative) {\n            matrix.setEntry(zIndex, getSlackVariableOffset() - 1,\n                getInvertedCoefficientSum(objectiveCoefficients));\n        }\n\n        \n        int slackVar = 0;\n        int artificialVar = 0;\n        for (int i = 0; i < constraints.size(); i++) {\n            LinearConstraint constraint = constraints.get(i);\n            int row = getNumObjectiveFunctions() + i;\n\n            \n            copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]);\n\n            \n            if (!restrictToNonNegative) {\n                matrix.setEntry(row, getSlackVariableOffset() - 1,\n                    getInvertedCoefficientSum(constraint.getCoefficients()));\n            }\n\n            \n            matrix.setEntry(row, width - 1, constraint.getValue());\n\n            \n            if (constraint.getRelationship() == Relationship.LEQ) {\n                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1);  \n            } else if (constraint.getRelationship() == Relationship.GEQ) {\n                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); \n            }\n\n            \n            if ((constraint.getRelationship() == Relationship.EQ) ||\n                    (constraint.getRelationship() == Relationship.GEQ)) {\n                matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);\n                matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1);\n                matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row)));\n            }\n        }\n\n        return matrix;\n    }\n\n    \n    public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints) {\n        List<LinearConstraint> normalized = new ArrayList<LinearConstraint>();\n        for (LinearConstraint constraint : originalConstraints) {\n            normalized.add(normalize(constraint));\n        }\n        return normalized;\n    }\n\n    \n    private LinearConstraint normalize(final LinearConstraint constraint) {\n        if (constraint.getValue() < 0) {\n            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                                        constraint.getRelationship().oppositeRelationship(),\n                                        -1 * constraint.getValue());\n        }\n        return new LinearConstraint(constraint.getCoefficients(),\n                                    constraint.getRelationship(), constraint.getValue());\n    }\n\n    \n    protected final int getNumObjectiveFunctions() {\n        return this.numArtificialVariables > 0 ? 2 : 1;\n    }\n\n    \n    private int getConstraintTypeCounts(final Relationship relationship) {\n        int count = 0;\n        for (final LinearConstraint constraint : constraints) {\n            if (constraint.getRelationship() == relationship) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    \n    protected static double getInvertedCoefficientSum(final RealVector coefficients) {\n        double sum = 0;\n        for (double coefficient : coefficients.toArray()) {\n            sum -= coefficient;\n        }\n        return sum;\n    }\n\n    \n    protected Integer getBasicRow(final int col) {\n        Integer row = null;\n        for (int i = 0; i < getHeight(); i++) {\n            final double entry = getEntry(i, col);\n            if (Precision.equals(entry, 1d, maxUlps) && (row == null)) {\n                row = i;\n            } else if (!Precision.equals(entry, 0d, maxUlps)) {\n                return null;\n            }\n        }\n        return row;\n    }\n\n    \n    protected void dropPhase1Objective() {\n        if (getNumObjectiveFunctions() == 1) {\n            return;\n        }\n\n        List<Integer> columnsToDrop = new ArrayList<Integer>();\n        columnsToDrop.add(0);\n\n        \n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n            final double entry = tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }\n        }\n\n        \n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n          int col = i + getArtificialVariableOffset();\n          if (getBasicRow(col) == null) {\n            columnsToDrop.add(col);\n          }\n        }\n\n        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n        for (int i = 1; i < getHeight(); i++) {\n          int col = 0;\n          for (int j = 0; j < getWidth(); j++) {\n            if (!columnsToDrop.contains(j)) {\n              matrix[i - 1][col++] = tableau.getEntry(i, j);\n            }\n          }\n        }\n\n        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n          columnLabels.remove((int) columnsToDrop.get(i));\n        }\n\n        this.tableau = new Array2DRowRealMatrix(matrix);\n        this.numArtificialVariables = 0;\n    }\n\n    \n    private void copyArray(final double[] src, final double[] dest) {\n        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length);\n    }\n\n    \n    boolean isOptimal() {\n        for (int i = getNumObjectiveFunctions(); i < getWidth() - 1; i++) {\n            final double entry = tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, 0d, epsilon) < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    protected RealPointValuePair getSolution() {\n      int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n\n      Set<Integer> basicRows = new HashSet<Integer>();\n      double[] coefficients = new double[getOriginalNumDecisionVariables()];\n      for (int i = 0; i < coefficients.length; i++) {\n          int colIndex = columnLabels.indexOf(\"x\" + i);\n          if (colIndex < 0) {\n            coefficients[i] = 0;\n            continue;\n          }\n          Integer basicRow = getBasicRow(colIndex);\n              \n              \n              \n          if (basicRows.contains(basicRow)) {\n              \n              \n              coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n          } else {\n              basicRows.add(basicRow);\n              coefficients[i] =\n                  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                  (restrictToNonNegative ? 0 : mostNegative);\n          }\n      }\n      return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }\n\n    \n    protected void divideRow(final int dividendRow, final double divisor) {\n        for (int j = 0; j < getWidth(); j++) {\n            tableau.setEntry(dividendRow, j, tableau.getEntry(dividendRow, j) / divisor);\n        }\n    }\n\n    \n    protected void subtractRow(final int minuendRow, final int subtrahendRow, final double multiple) {\n        tableau.setRowVector(minuendRow, tableau.getRowVector(minuendRow)\n            .subtract(tableau.getRowVector(subtrahendRow).mapMultiply(multiple)));\n    }\n\n    \n    protected final int getWidth() {\n        return tableau.getColumnDimension();\n    }\n\n    \n    protected final int getHeight() {\n        return tableau.getRowDimension();\n    }\n\n    \n    protected final double getEntry(final int row, final int column) {\n        return tableau.getEntry(row, column);\n    }\n\n    \n    protected final void setEntry(final int row, final int column, final double value) {\n        tableau.setEntry(row, column, value);\n    }\n\n    \n    protected final int getSlackVariableOffset() {\n        return getNumObjectiveFunctions() + numDecisionVariables;\n    }\n\n    \n    protected final int getArtificialVariableOffset() {\n        return getNumObjectiveFunctions() + numDecisionVariables + numSlackVariables;\n    }\n\n    \n    protected final int getRhsOffset() {\n        return getWidth() - 1;\n    }\n\n    \n    protected final int getNumDecisionVariables() {\n        return numDecisionVariables;\n    }\n\n    \n    protected final int getOriginalNumDecisionVariables() {\n        return f.getCoefficients().getDimension();\n    }\n\n    \n    protected final int getNumSlackVariables() {\n        return numSlackVariables;\n    }\n\n    \n    protected final int getNumArtificialVariables() {\n        return numArtificialVariables;\n    }\n\n    \n    protected final double[][] getData() {\n        return tableau.getData();\n    }\n\n    \n    @Override\n    public boolean equals(Object other) {\n\n      if (this == other) {\n        return true;\n      }\n\n      if (other instanceof SimplexTableau) {\n          SimplexTableau rhs = (SimplexTableau) other;\n          return (restrictToNonNegative  == rhs.restrictToNonNegative) &&\n                 (numDecisionVariables   == rhs.numDecisionVariables) &&\n                 (numSlackVariables      == rhs.numSlackVariables) &&\n                 (numArtificialVariables == rhs.numArtificialVariables) &&\n                 (epsilon                == rhs.epsilon) &&\n                 (maxUlps                == rhs.maxUlps) &&\n                 f.equals(rhs.f) &&\n                 constraints.equals(rhs.constraints) &&\n                 tableau.equals(rhs.tableau);\n      }\n      return false;\n    }\n\n    \n    @Override\n    public int hashCode() {\n        return Boolean.valueOf(restrictToNonNegative).hashCode() ^\n               numDecisionVariables ^\n               numSlackVariables ^\n               numArtificialVariables ^\n               Double.valueOf(epsilon).hashCode() ^\n               maxUlps ^\n               f.hashCode() ^\n               constraints.hashCode() ^\n               tableau.hashCode();\n    }\n\n    \n    private void writeObject(ObjectOutputStream oos) throws IOException {\n        oos.defaultWriteObject();\n        MatrixUtils.serializeRealMatrix(tableau, oos);\n    }\n\n    \n    private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException {\n        ois.defaultReadObject();\n        MatrixUtils.deserializeRealMatrix(this, \"tableau\", ois);\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.optimization.linear;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.commons.math.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math.linear.MatrixUtils;\nimport org.apache.commons.math.linear.RealMatrix;\nimport org.apache.commons.math.linear.RealVector;\nimport org.apache.commons.math.optimization.GoalType;\nimport org.apache.commons.math.optimization.RealPointValuePair;\nimport org.apache.commons.math.util.Precision;\n\n\nclass SimplexTableau implements Serializable {\n\n    \n    private static final String NEGATIVE_VAR_COLUMN_LABEL = \"x-\"; private static final int DEFAULT_ULPS = 10; private static final long serialVersionUID = -1369660067587938365L; private final LinearObjectiveFunction f; private final List<LinearConstraint> constraints; private final boolean restrictToNonNegative; private final List<String> columnLabels = new ArrayList<String>(); private transient RealMatrix tableau; private final int numDecisionVariables; private final int numSlackVariables; private int numArtificialVariables; private final double epsilon; private final int maxUlps; SimplexTableau(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative, final double epsilon) {\n        this(f, constraints, goalType, restrictToNonNegative, epsilon, DEFAULT_ULPS);\n    }\n\n    \n    SimplexTableau(final LinearObjectiveFunction f,\n                   final Collection<LinearConstraint> constraints,\n                   final GoalType goalType, final boolean restrictToNonNegative,\n                   final double epsilon,\n                   final int maxUlps) {\n        this.f                      = f;\n        this.constraints            = normalizeConstraints(constraints);\n        this.restrictToNonNegative  = restrictToNonNegative;\n        this.epsilon                = epsilon;\n        this.maxUlps                = maxUlps;\n        this.numDecisionVariables   = f.getCoefficients().getDimension() +\n                                      (restrictToNonNegative ? 0 : 1);\n        this.numSlackVariables      = getConstraintTypeCounts(Relationship.LEQ) +\n                                      getConstraintTypeCounts(Relationship.GEQ);\n        this.numArtificialVariables = getConstraintTypeCounts(Relationship.EQ) +\n                                      getConstraintTypeCounts(Relationship.GEQ);\n        this.tableau = createTableau(goalType == GoalType.MAXIMIZE);\n        initializeColumnLabels();\n    }\n\n    \n    protected void initializeColumnLabels() {\n      if (getNumObjectiveFunctions() == 2) {\n        columnLabels.add(\"W\");\n      }\n      columnLabels.add(\"Z\");\n      for (int i = 0; i < getOriginalNumDecisionVariables(); i++) {\n        columnLabels.add(\"x\" + i);\n      }\n      if (!restrictToNonNegative) {\n        columnLabels.add(NEGATIVE_VAR_COLUMN_LABEL);\n      }\n      for (int i = 0; i < getNumSlackVariables(); i++) {\n        columnLabels.add(\"s\" + i);\n      }\n      for (int i = 0; i < getNumArtificialVariables(); i++) {\n        columnLabels.add(\"a\" + i);\n      }\n      columnLabels.add(\"RHS\");\n    }\n\n    \n    protected RealMatrix createTableau(final boolean maximize) {\n\n        \n        int width = numDecisionVariables + numSlackVariables +\n        numArtificialVariables + getNumObjectiveFunctions() + 1; \n        int height = constraints.size() + getNumObjectiveFunctions();\n        Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width);\n\n        \n        if (getNumObjectiveFunctions() == 2) {\n            matrix.setEntry(0, 0, -1);\n        }\n        int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;\n        matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1);\n        RealVector objectiveCoefficients =\n            maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();\n        copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]);\n        matrix.setEntry(zIndex, width - 1,\n            maximize ? f.getConstantTerm() : -1 * f.getConstantTerm());\n\n        if (!restrictToNonNegative) {\n            matrix.setEntry(zIndex, getSlackVariableOffset() - 1,\n                getInvertedCoefficientSum(objectiveCoefficients));\n        }\n\n        \n        int slackVar = 0;\n        int artificialVar = 0;\n        for (int i = 0; i < constraints.size(); i++) {\n            LinearConstraint constraint = constraints.get(i);\n            int row = getNumObjectiveFunctions() + i;\n\n            \n            copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]);\n\n            \n            if (!restrictToNonNegative) {\n                matrix.setEntry(row, getSlackVariableOffset() - 1,\n                    getInvertedCoefficientSum(constraint.getCoefficients()));\n            }\n\n            \n            matrix.setEntry(row, width - 1, constraint.getValue());\n\n            \n            if (constraint.getRelationship() == Relationship.LEQ) {\n                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1);  \n            } else if (constraint.getRelationship() == Relationship.GEQ) {\n                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); \n            }\n\n            \n            if ((constraint.getRelationship() == Relationship.EQ) ||\n                    (constraint.getRelationship() == Relationship.GEQ)) {\n                matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);\n                matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1);\n                matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row)));\n            }\n        }\n\n        return matrix;\n    }\n\n    \n    public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints) {\n        List<LinearConstraint> normalized = new ArrayList<LinearConstraint>();\n        for (LinearConstraint constraint : originalConstraints) {\n            normalized.add(normalize(constraint));\n        }\n        return normalized;\n    }\n\n    \n    private LinearConstraint normalize(final LinearConstraint constraint) {\n        if (constraint.getValue() < 0) {\n            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                                        constraint.getRelationship().oppositeRelationship(),\n                                        -1 * constraint.getValue());\n        }\n        return new LinearConstraint(constraint.getCoefficients(),\n                                    constraint.getRelationship(), constraint.getValue());\n    }\n\n    \n    protected final int getNumObjectiveFunctions() {\n        return this.numArtificialVariables > 0 ? 2 : 1;\n    }\n\n    \n    private int getConstraintTypeCounts(final Relationship relationship) {\n        int count = 0;\n        for (final LinearConstraint constraint : constraints) {\n            if (constraint.getRelationship() == relationship) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    \n    protected static double getInvertedCoefficientSum(final RealVector coefficients) {\n        double sum = 0;\n        for (double coefficient : coefficients.toArray()) {\n            sum -= coefficient;\n        }\n        return sum;\n    }\n\n    \n    protected Integer getBasicRow(final int col) {\n        Integer row = null;\n        for (int i = 0; i < getHeight(); i++) {\n            final double entry = getEntry(i, col);\n            if (Precision.equals(entry, 1d, maxUlps) && (row == null)) {\n                row = i;\n            } else if (!Precision.equals(entry, 0d, maxUlps)) {\n                return null;\n            }\n        }\n        return row;\n    }\n\n    \n    protected void dropPhase1Objective() {\n        if (getNumObjectiveFunctions() == 1) {\n            return;\n        }\n\n        List<Integer> columnsToDrop = new ArrayList<Integer>();\n        columnsToDrop.add(0);\n\n        \n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n            final double entry = tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }\n        }\n\n        \n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n          int col = i + getArtificialVariableOffset();\n          if (getBasicRow(col) == null) {\n            columnsToDrop.add(col);\n          }\n        }\n\n        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n        for (int i = 1; i < getHeight(); i++) {\n          int col = 0;\n          for (int j = 0; j < getWidth(); j++) {\n            if (!columnsToDrop.contains(j)) {\n              matrix[i - 1][col++] = tableau.getEntry(i, j);\n            }\n          }\n        }\n\n        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n          columnLabels.remove((int) columnsToDrop.get(i));\n        }\n\n        this.tableau = new Array2DRowRealMatrix(matrix);\n        this.numArtificialVariables = 0;\n    }\n\n    \n    private void copyArray(final double[] src, final double[] dest) {\n        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length);\n    }\n\n    \n    boolean isOptimal() {\n        for (int i = getNumObjectiveFunctions(); i < getWidth() - 1; i++) {\n            final double entry = tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, 0d, epsilon) < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    protected RealPointValuePair getSolution() {\n      int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n\n      Set<Integer> basicRows = new HashSet<Integer>();\n      double[] coefficients = new double[getOriginalNumDecisionVariables()];\n      for (int i = 0; i < coefficients.length; i++) {\n          int colIndex = columnLabels.indexOf(\"x\" + i);\n          if (colIndex < 0) {\n            coefficients[i] = 0;\n            continue;\n          }\n          Integer basicRow = getBasicRow(colIndex);\n          if (basicRow != null && basicRow == 0) {\n              \n              \n              \n              coefficients[i] = 0;\n          } else if (basicRows.contains(basicRow)) {\n              \n              \n              coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n          } else {\n              basicRows.add(basicRow);\n              coefficients[i] =\n                  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                  (restrictToNonNegative ? 0 : mostNegative);\n          }\n      }\n      return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }\n\n    \n    protected void divideRow(final int dividendRow, final double divisor) {\n        for (int j = 0; j < getWidth(); j++) {\n            tableau.setEntry(dividendRow, j, tableau.getEntry(dividendRow, j) / divisor);\n        }\n    }\n\n    \n    protected void subtractRow(final int minuendRow, final int subtrahendRow, final double multiple) {\n        tableau.setRowVector(minuendRow, tableau.getRowVector(minuendRow)\n            .subtract(tableau.getRowVector(subtrahendRow).mapMultiply(multiple)));\n    }\n\n    \n    protected final int getWidth() {\n        return tableau.getColumnDimension();\n    }\n\n    \n    protected final int getHeight() {\n        return tableau.getRowDimension();\n    }\n\n    \n    protected final double getEntry(final int row, final int column) {\n        return tableau.getEntry(row, column);\n    }\n\n    \n    protected final void setEntry(final int row, final int column, final double value) {\n        tableau.setEntry(row, column, value);\n    }\n\n    \n    protected final int getSlackVariableOffset() {\n        return getNumObjectiveFunctions() + numDecisionVariables;\n    }\n\n    \n    protected final int getArtificialVariableOffset() {\n        return getNumObjectiveFunctions() + numDecisionVariables + numSlackVariables;\n    }\n\n    \n    protected final int getRhsOffset() {\n        return getWidth() - 1;\n    }\n\n    \n    protected final int getNumDecisionVariables() {\n        return numDecisionVariables;\n    }\n\n    \n    protected final int getOriginalNumDecisionVariables() {\n        return f.getCoefficients().getDimension();\n    }\n\n    \n    protected final int getNumSlackVariables() {\n        return numSlackVariables;\n    }\n\n    \n    protected final int getNumArtificialVariables() {\n        return numArtificialVariables;\n    }\n\n    \n    protected final double[][] getData() {\n        return tableau.getData();\n    }\n\n    \n    @Override\n    public boolean equals(Object other) {\n\n      if (this == other) {\n        return true;\n      }\n\n      if (other instanceof SimplexTableau) {\n          SimplexTableau rhs = (SimplexTableau) other;\n          return (restrictToNonNegative  == rhs.restrictToNonNegative) &&\n                 (numDecisionVariables   == rhs.numDecisionVariables) &&\n                 (numSlackVariables      == rhs.numSlackVariables) &&\n                 (numArtificialVariables == rhs.numArtificialVariables) &&\n                 (epsilon                == rhs.epsilon) &&\n                 (maxUlps                == rhs.maxUlps) &&\n                 f.equals(rhs.f) &&\n                 constraints.equals(rhs.constraints) &&\n                 tableau.equals(rhs.tableau);\n      }\n      return false;\n    }\n\n    \n    @Override\n    public int hashCode() {\n        return Boolean.valueOf(restrictToNonNegative).hashCode() ^\n               numDecisionVariables ^\n               numSlackVariables ^\n               numArtificialVariables ^\n               Double.valueOf(epsilon).hashCode() ^\n               maxUlps ^\n               f.hashCode() ^\n               constraints.hashCode() ^\n               tableau.hashCode();\n    }\n\n    \n    private void writeObject(ObjectOutputStream oos) throws IOException {\n        oos.defaultWriteObject();\n        MatrixUtils.serializeRealMatrix(tableau, oos);\n    }\n\n    \n    private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException {\n        ois.defaultReadObject();\n        MatrixUtils.deserializeRealMatrix(this, \"tableau\", ois);\n    }\n}\n",
      "buggy_signatures": [
        "protected void initializeColumnLabels()",
        "protected RealMatrix createTableau(final boolean maximize)",
        "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)",
        "private LinearConstraint normalize(final LinearConstraint constraint)",
        "protected final int getNumObjectiveFunctions()",
        "private int getConstraintTypeCounts(final Relationship relationship)",
        "protected static double getInvertedCoefficientSum(final RealVector coefficients)",
        "protected Integer getBasicRow(final int col)",
        "protected void dropPhase1Objective()",
        "private void copyArray(final double[] src, final double[] dest)",
        "protected RealPointValuePair getSolution()",
        "protected void divideRow(final int dividendRow, final double divisor)",
        "protected void subtractRow(final int minuendRow, final int subtrahendRow, final double multiple)",
        "protected final int getWidth()",
        "protected final int getHeight()",
        "protected final double getEntry(final int row, final int column)",
        "protected final void setEntry(final int row, final int column, final double value)",
        "protected final int getSlackVariableOffset()",
        "protected final int getArtificialVariableOffset()",
        "protected final int getRhsOffset()",
        "protected final int getNumDecisionVariables()",
        "protected final int getOriginalNumDecisionVariables()",
        "protected final int getNumSlackVariables()",
        "protected final int getNumArtificialVariables()",
        "protected final double[][] getData()",
        "public boolean equals(Object other)",
        "public int hashCode()",
        "private void writeObject(ObjectOutputStream oos) throws IOException",
        "private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException"
      ],
      "fixed_signatures": [
        "protected void initializeColumnLabels()",
        "protected RealMatrix createTableau(final boolean maximize)",
        "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)",
        "private LinearConstraint normalize(final LinearConstraint constraint)",
        "protected final int getNumObjectiveFunctions()",
        "private int getConstraintTypeCounts(final Relationship relationship)",
        "protected static double getInvertedCoefficientSum(final RealVector coefficients)",
        "protected Integer getBasicRow(final int col)",
        "protected void dropPhase1Objective()",
        "private void copyArray(final double[] src, final double[] dest)",
        "protected RealPointValuePair getSolution()",
        "protected void divideRow(final int dividendRow, final double divisor)",
        "protected void subtractRow(final int minuendRow, final int subtrahendRow, final double multiple)",
        "protected final int getWidth()",
        "protected final int getHeight()",
        "protected final double getEntry(final int row, final int column)",
        "protected final void setEntry(final int row, final int column, final double value)",
        "protected final int getSlackVariableOffset()",
        "protected final int getArtificialVariableOffset()",
        "protected final int getRhsOffset()",
        "protected final int getNumDecisionVariables()",
        "protected final int getOriginalNumDecisionVariables()",
        "protected final int getNumSlackVariables()",
        "protected final int getNumArtificialVariables()",
        "protected final double[][] getData()",
        "public boolean equals(Object other)",
        "public int hashCode()",
        "private void writeObject(ObjectOutputStream oos) throws IOException",
        "private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException"
      ],
      "methods": [
        {
          "buggy_method": "  protected RealPointValuePair getSolution() {\n  int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n  Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n  double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n\n  Set<Integer> basicRows = new HashSet<Integer>();\n  double[] coefficients = new double[getOriginalNumDecisionVariables()];\n  for (int i = 0; i < coefficients.length; i++) {\n  int colIndex = columnLabels.indexOf(\"x\" + i);\n  if (colIndex < 0) {\n  coefficients[i] = 0;\n  continue;\n  }\n  Integer basicRow = getBasicRow(colIndex);\n  \n  \n  \n  if (basicRows.contains(basicRow)) {\n  \n  \n  coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n  } else {\n  basicRows.add(basicRow);\n  coefficients[i] =\n  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n  (restrictToNonNegative ? 0 : mostNegative);\n  }\n  }\n  return new RealPointValuePair(coefficients, f.getValue(coefficients));\n  }",
          "fixed_method": "  protected RealPointValuePair getSolution() {\n  int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n  Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n  double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n\n  Set<Integer> basicRows = new HashSet<Integer>();\n  double[] coefficients = new double[getOriginalNumDecisionVariables()];\n  for (int i = 0; i < coefficients.length; i++) {\n  int colIndex = columnLabels.indexOf(\"x\" + i);\n  if (colIndex < 0) {\n  coefficients[i] = 0;\n  continue;\n  }\n  Integer basicRow = getBasicRow(colIndex);\n  if (basicRow != null && basicRow == 0) {\n  \n  \n  \n  coefficients[i] = 0;\n  } else if (basicRows.contains(basicRow)) {\n  \n  \n  coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n  } else {\n  basicRows.add(basicRow);\n  coefficients[i] =\n  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n  (restrictToNonNegative ? 0 : mostNegative);\n  }\n  }\n  return new RealPointValuePair(coefficients, f.getValue(coefficients));\n  }",
          "diff": [
            "@@ -407,10 +407,12 @@",
            "             continue;\n",
            "           }\n",
            "           Integer basicRow = getBasicRow(colIndex);\n",
            "+          if (basicRow != null && basicRow == 0) {\n",
            "               // if the basic row is found to be the objective function row\n",
            "               // set the coefficient to 0 -> this case handles unconstrained \n",
            "               // variables that are still part of the objective function\n",
            "-          if (basicRows.contains(basicRow)) {\n",
            "+              coefficients[i] = 0;\n",
            "+          } else if (basicRows.contains(basicRow)) {\n",
            "               // if multiple variables can take a given value\n",
            "               // then we choose the first and set the rest equal to 0\n",
            "               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
