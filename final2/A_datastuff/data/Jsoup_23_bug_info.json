{
  "bug_id": "23",
  "failed_tests": {
    "org.jsoup.nodes.EntitiesTest": [
      {
        "methodName": "letterDigitEntities",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<[&sup1;&sup2;&sup3;&frac14;&frac12;&]frac34;> but was:<[⊃1;⊃2;⊃3;&amp;frac14;&amp;frac12;&amp;]frac34;>",
        "fail_line": "        assertEquals(\"&sup1;&sup2;&sup3;&frac14;&frac12;&frac34;\", p.html());",
        "test_source": "",
        "stack": [
          "EntitiesTest.letterDigitEntities line 60"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/parser/CharacterReader.java",
      "buggy_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\n\n\nclass CharacterReader {\n    static final char EOF = (char) -1; private final String input; private final int length; private int pos = 0; private int mark = 0; CharacterReader(String input) {\n        Validate.notNull(input);\n        input = input.replaceAll(\"\\r\\n?\", \"\\n\"); \n\n        this.input = input;\n        this.length = input.length();\n    }\n\n    int pos() {\n        return pos;\n    }\n\n    boolean isEmpty() {\n        return pos >= length;\n    }\n\n    char current() {\n        return isEmpty() ? EOF : input.charAt(pos);\n    }\n\n    char consume() {\n        char val = isEmpty() ? EOF : input.charAt(pos);\n        pos++;\n        return val;\n    }\n\n    void unconsume() {\n        pos--;\n    }\n\n    void advance() {\n        pos++;\n    }\n\n    void mark() {\n        mark = pos;\n    }\n\n    void rewindToMark() {\n        pos = mark;\n    }\n\n    String consumeAsString() {\n        return input.substring(pos, pos++);\n    }\n\n    String consumeTo(char c) {\n        int offset = input.indexOf(c, pos);\n        if (offset != -1) {\n            String consumed = input.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = input.indexOf(seq, pos);\n        if (offset != -1) {\n            String consumed = input.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeToAny(char... seq) {\n        int start = pos;\n\n        OUTER: while (!isEmpty()) {\n            char c = input.charAt(pos);\n            for (char seek : seq) {\n                if (seek == c)\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        return pos > start ? input.substring(start, pos) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = input.substring(pos, input.length());\n        pos = input.length();\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n\n        return input.substring(start, pos);\n    }\n\n\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return input.substring(start, pos);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return input.substring(start, pos);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input.charAt(pos) == c;\n\n    }\n\n    boolean matches(String seq) {\n        return input.startsWith(seq, pos);\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        return input.regionMatches(true, pos, seq, 0, seq.length());\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input.charAt(pos);\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input.charAt(pos);\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input.charAt(pos);\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        \n        String loScan = seq.toLowerCase();\n        String hiScan = seq.toUpperCase();\n        return (input.indexOf(loScan, pos) > -1) || (input.indexOf(hiScan, pos) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return input.substring(pos);\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\n\n\nclass CharacterReader {\n    static final char EOF = (char) -1; private final String input; private final int length; private int pos = 0; private int mark = 0; CharacterReader(String input) {\n        Validate.notNull(input);\n        input = input.replaceAll(\"\\r\\n?\", \"\\n\"); \n\n        this.input = input;\n        this.length = input.length();\n    }\n\n    int pos() {\n        return pos;\n    }\n\n    boolean isEmpty() {\n        return pos >= length;\n    }\n\n    char current() {\n        return isEmpty() ? EOF : input.charAt(pos);\n    }\n\n    char consume() {\n        char val = isEmpty() ? EOF : input.charAt(pos);\n        pos++;\n        return val;\n    }\n\n    void unconsume() {\n        pos--;\n    }\n\n    void advance() {\n        pos++;\n    }\n\n    void mark() {\n        mark = pos;\n    }\n\n    void rewindToMark() {\n        pos = mark;\n    }\n\n    String consumeAsString() {\n        return input.substring(pos, pos++);\n    }\n\n    String consumeTo(char c) {\n        int offset = input.indexOf(c, pos);\n        if (offset != -1) {\n            String consumed = input.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = input.indexOf(seq, pos);\n        if (offset != -1) {\n            String consumed = input.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeToAny(char... seq) {\n        int start = pos;\n\n        OUTER: while (!isEmpty()) {\n            char c = input.charAt(pos);\n            for (char seek : seq) {\n                if (seek == c)\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        return pos > start ? input.substring(start, pos) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = input.substring(pos, input.length());\n        pos = input.length();\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n\n        return input.substring(start, pos);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n\n        return input.substring(start, pos);\n    }\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return input.substring(start, pos);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return input.substring(start, pos);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input.charAt(pos) == c;\n\n    }\n\n    boolean matches(String seq) {\n        return input.startsWith(seq, pos);\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        return input.regionMatches(true, pos, seq, 0, seq.length());\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input.charAt(pos);\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input.charAt(pos);\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input.charAt(pos);\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        \n        String loScan = seq.toLowerCase();\n        String hiScan = seq.toUpperCase();\n        return (input.indexOf(loScan, pos) > -1) || (input.indexOf(hiScan, pos) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return input.substring(pos);\n    }\n}\n",
      "buggy_signatures": [
        "public String toString()"
      ],
      "fixed_signatures": [
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "  static final char EOF = (char) -1; private final String input; private final int length; private int pos = 0; private int mark = 0; CharacterReader(String input) {\n  Validate.notNull(input);\n  input = input.replaceAll(\"\\r\\n?\", \"\\n\"); \n\n  this.input = input;\n  this.length = input.length();\n  }",
          "fixed_method": "  static final char EOF = (char) -1; private final String input; private final int length; private int pos = 0; private int mark = 0; CharacterReader(String input) {\n  Validate.notNull(input);\n  input = input.replaceAll(\"\\r\\n?\", \"\\n\"); \n\n  this.input = input;\n  this.length = input.length();\n  }",
          "diff": [
            "@@ -115,7 +115,25 @@",
            "         return input.substring(start, pos);\n",
            "     }\n",
            " \n",
            "-\n",
            "+    String consumeLetterThenDigitSequence() {\n",
            "+        int start = pos;\n",
            "+        while (!isEmpty()) {\n",
            "+            char c = input.charAt(pos);\n",
            "+            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n",
            "+                pos++;\n",
            "+            else\n",
            "+                break;\n",
            "+        }\n",
            "+        while (!isEmpty()) {\n",
            "+            char c = input.charAt(pos);\n",
            "+            if (c >= '0' && c <= '9')\n",
            "+                pos++;\n",
            "+            else\n",
            "+                break;\n",
            "+        }\n",
            "+\n",
            "+        return input.substring(start, pos);\n",
            "+    }\n",
            " \n",
            "     String consumeHexSequence() {\n",
            "         int start = pos;\n"
          ],
          "changed_lines": 20
        }
      ]
    },
    {
      "name": "org/jsoup/parser/Tokeniser.java",
      "buggy_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Entities;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\nclass Tokeniser {\n    static final char replacementChar = '\\uFFFD'; private CharacterReader reader; private ParseErrorList errors; private TokeniserState state = TokeniserState.Data; private Token emitPending; private boolean isEmitPending = false; private StringBuilder charBuffer = new StringBuilder(); StringBuilder dataBuffer; Token.Tag tagPending; Token.Doctype doctypePending; Token.Comment commentPending; private Token.StartTag lastStartTag; private boolean selfClosingFlagAcknowledged = true; Tokeniser(CharacterReader reader, ParseErrorList errors) {\n        this.reader = reader;\n        this.errors = errors;\n    }\n\n    Token read() {\n        if (!selfClosingFlagAcknowledged) {\n            error(\"Self closing flag not acknowledged\");\n            selfClosingFlagAcknowledged = true;\n        }\n\n        while (!isEmitPending)\n            state.read(this, reader);\n\n        \n        if (charBuffer.length() > 0) {\n            String str = charBuffer.toString();\n            charBuffer.delete(0, charBuffer.length());\n            return new Token.Character(str);\n        } else {\n            isEmitPending = false;\n            return emitPending;\n        }\n    }\n\n    void emit(Token token) {\n        Validate.isFalse(isEmitPending, \"There is an unread token pending!\");\n\n        emitPending = token;\n        isEmitPending = true;\n\n        if (token.type == Token.TokenType.StartTag) {\n            Token.StartTag startTag = (Token.StartTag) token;\n            lastStartTag = startTag;\n            if (startTag.selfClosing)\n                selfClosingFlagAcknowledged = false;\n        } else if (token.type == Token.TokenType.EndTag) {\n            Token.EndTag endTag = (Token.EndTag) token;\n            if (endTag.attributes.size() > 0)\n                error(\"Attributes incorrectly present on end tag\");\n        }\n    }\n\n    void emit(String str) {\n        \n        \n        charBuffer.append(str);\n    }\n\n    void emit(char c) {\n        charBuffer.append(c);\n    }\n\n    TokeniserState getState() {\n        return state;\n    }\n\n    void transition(TokeniserState state) {\n        this.state = state;\n    }\n\n    void advanceTransition(TokeniserState state) {\n        reader.advance();\n        this.state = state;\n    }\n\n    void acknowledgeSelfClosingFlag() {\n        selfClosingFlagAcknowledged = true;\n    }\n\n    Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n        if (reader.isEmpty())\n            return null;\n        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n            return null;\n        if (reader.matchesAny('\\t', '\\n', '\\f', ' ', '<', '&'))\n            return null;\n\n        reader.mark();\n        if (reader.matchConsume(\"#\")) { \n            boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n            if (numRef.length() == 0) { \n                characterReferenceError(\"numeric reference with no numerals\");\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(\"missing semicolon\"); \n            int charval = -1;\n            try {\n                int base = isHexMode ? 16 : 10;\n                charval = Integer.valueOf(numRef, base);\n            } catch (NumberFormatException e) {\n            } \n            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                characterReferenceError(\"character outside of valid range\");\n                return replacementChar;\n            } else {\n                \n                \n                return (char) charval;\n            }\n        } else { \n            \n            String nameRef = reader.consumeLetterSequence();\n            String origNameRef = new String(nameRef); \n            boolean looksLegit = reader.matches(';');\n            boolean found = false;\n            while (nameRef.length() > 0 && !found) {\n                if (Entities.isNamedEntity(nameRef))\n                    found = true;\n                else {\n                    nameRef = nameRef.substring(0, nameRef.length()-1);\n                    reader.unconsume();\n                }\n            }\n            if (!found) {\n                if (looksLegit) \n                    characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n                reader.rewindToMark();\n                return null;\n            }\n            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n                \n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(\"missing semicolon\"); \n            return Entities.getCharacterByName(nameRef);\n        }\n    }\n\n    Token.Tag createTagPending(boolean start) {\n        tagPending = start ? new Token.StartTag() : new Token.EndTag();\n        return tagPending;\n    }\n\n    void emitTagPending() {\n        tagPending.finaliseTag();\n        emit(tagPending);\n    }\n\n    void createCommentPending() {\n        commentPending = new Token.Comment();\n    }\n\n    void emitCommentPending() {\n        emit(commentPending);\n    }\n\n    void createDoctypePending() {\n        doctypePending = new Token.Doctype();\n    }\n\n    void emitDoctypePending() {\n        emit(doctypePending);\n    }\n\n    void createTempBuffer() {\n        dataBuffer = new StringBuilder();\n    }\n\n    boolean isAppropriateEndTagToken() {\n        return tagPending.tagName.equals(lastStartTag.tagName);\n    }\n\n    String appropriateEndTagName() {\n        return lastStartTag.tagName;\n    }\n\n    void error(TokeniserState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected character '%s' in input state [%s]\", reader.current(), state));\n    }\n\n    void eofError(TokeniserState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpectedly reached end of file (EOF) in input state [%s]\", state));\n    }\n\n    private void characterReferenceError(String message) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Invalid character reference: %s\", message));\n    }\n\n    private void error(String errorMsg) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), errorMsg));\n    }\n\n    boolean currentNodeInHtmlNS() {\n        \n        return true;\n        \n        \n    }\n}\n",
      "fixed_full_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Entities;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\nclass Tokeniser {\n    static final char replacementChar = '\\uFFFD'; private CharacterReader reader; private ParseErrorList errors; private TokeniserState state = TokeniserState.Data; private Token emitPending; private boolean isEmitPending = false; private StringBuilder charBuffer = new StringBuilder(); StringBuilder dataBuffer; Token.Tag tagPending; Token.Doctype doctypePending; Token.Comment commentPending; private Token.StartTag lastStartTag; private boolean selfClosingFlagAcknowledged = true; Tokeniser(CharacterReader reader, ParseErrorList errors) {\n        this.reader = reader;\n        this.errors = errors;\n    }\n\n    Token read() {\n        if (!selfClosingFlagAcknowledged) {\n            error(\"Self closing flag not acknowledged\");\n            selfClosingFlagAcknowledged = true;\n        }\n\n        while (!isEmitPending)\n            state.read(this, reader);\n\n        \n        if (charBuffer.length() > 0) {\n            String str = charBuffer.toString();\n            charBuffer.delete(0, charBuffer.length());\n            return new Token.Character(str);\n        } else {\n            isEmitPending = false;\n            return emitPending;\n        }\n    }\n\n    void emit(Token token) {\n        Validate.isFalse(isEmitPending, \"There is an unread token pending!\");\n\n        emitPending = token;\n        isEmitPending = true;\n\n        if (token.type == Token.TokenType.StartTag) {\n            Token.StartTag startTag = (Token.StartTag) token;\n            lastStartTag = startTag;\n            if (startTag.selfClosing)\n                selfClosingFlagAcknowledged = false;\n        } else if (token.type == Token.TokenType.EndTag) {\n            Token.EndTag endTag = (Token.EndTag) token;\n            if (endTag.attributes.size() > 0)\n                error(\"Attributes incorrectly present on end tag\");\n        }\n    }\n\n    void emit(String str) {\n        \n        \n        charBuffer.append(str);\n    }\n\n    void emit(char c) {\n        charBuffer.append(c);\n    }\n\n    TokeniserState getState() {\n        return state;\n    }\n\n    void transition(TokeniserState state) {\n        this.state = state;\n    }\n\n    void advanceTransition(TokeniserState state) {\n        reader.advance();\n        this.state = state;\n    }\n\n    void acknowledgeSelfClosingFlag() {\n        selfClosingFlagAcknowledged = true;\n    }\n\n    Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n        if (reader.isEmpty())\n            return null;\n        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n            return null;\n        if (reader.matchesAny('\\t', '\\n', '\\f', ' ', '<', '&'))\n            return null;\n\n        reader.mark();\n        if (reader.matchConsume(\"#\")) { \n            boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n            if (numRef.length() == 0) { \n                characterReferenceError(\"numeric reference with no numerals\");\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(\"missing semicolon\"); \n            int charval = -1;\n            try {\n                int base = isHexMode ? 16 : 10;\n                charval = Integer.valueOf(numRef, base);\n            } catch (NumberFormatException e) {\n            } \n            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                characterReferenceError(\"character outside of valid range\");\n                return replacementChar;\n            } else {\n                \n                \n                return (char) charval;\n            }\n        } else { \n            \n            String nameRef = reader.consumeLetterThenDigitSequence();\n            String origNameRef = new String(nameRef); \n            boolean looksLegit = reader.matches(';');\n            boolean found = false;\n            while (nameRef.length() > 0 && !found) {\n                if (Entities.isNamedEntity(nameRef))\n                    found = true;\n                else {\n                    nameRef = nameRef.substring(0, nameRef.length()-1);\n                    reader.unconsume();\n                }\n            }\n            if (!found) {\n                if (looksLegit) \n                    characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n                reader.rewindToMark();\n                return null;\n            }\n            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n                \n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(\"missing semicolon\"); \n            return Entities.getCharacterByName(nameRef);\n        }\n    }\n\n    Token.Tag createTagPending(boolean start) {\n        tagPending = start ? new Token.StartTag() : new Token.EndTag();\n        return tagPending;\n    }\n\n    void emitTagPending() {\n        tagPending.finaliseTag();\n        emit(tagPending);\n    }\n\n    void createCommentPending() {\n        commentPending = new Token.Comment();\n    }\n\n    void emitCommentPending() {\n        emit(commentPending);\n    }\n\n    void createDoctypePending() {\n        doctypePending = new Token.Doctype();\n    }\n\n    void emitDoctypePending() {\n        emit(doctypePending);\n    }\n\n    void createTempBuffer() {\n        dataBuffer = new StringBuilder();\n    }\n\n    boolean isAppropriateEndTagToken() {\n        return tagPending.tagName.equals(lastStartTag.tagName);\n    }\n\n    String appropriateEndTagName() {\n        return lastStartTag.tagName;\n    }\n\n    void error(TokeniserState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected character '%s' in input state [%s]\", reader.current(), state));\n    }\n\n    void eofError(TokeniserState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpectedly reached end of file (EOF) in input state [%s]\", state));\n    }\n\n    private void characterReferenceError(String message) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Invalid character reference: %s\", message));\n    }\n\n    private void error(String errorMsg) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), errorMsg));\n    }\n\n    boolean currentNodeInHtmlNS() {\n        \n        return true;\n        \n        \n    }\n}\n",
      "buggy_signatures": [
        "private void characterReferenceError(String message)",
        "private void error(String errorMsg)"
      ],
      "fixed_signatures": [
        "private void characterReferenceError(String message)",
        "private void error(String errorMsg)"
      ],
      "methods": [
        {
          "buggy_method": "  private StringBuilder charBuffer = new StringBuilder(); StringBuilder dataBuffer; Token.Tag tagPending; Token.Doctype doctypePending; Token.Comment commentPending; private Token.StartTag lastStartTag; private boolean selfClosingFlagAcknowledged = true; Tokeniser(CharacterReader reader, ParseErrorList errors) {\n  this.reader = reader;\n  this.errors = errors;\n  }",
          "fixed_method": "  private StringBuilder charBuffer = new StringBuilder(); StringBuilder dataBuffer; Token.Tag tagPending; Token.Doctype doctypePending; Token.Comment commentPending; private Token.StartTag lastStartTag; private boolean selfClosingFlagAcknowledged = true; Tokeniser(CharacterReader reader, ParseErrorList errors) {\n  this.reader = reader;\n  this.errors = errors;\n  }",
          "diff": [
            "@@ -132,7 +132,7 @@",
            "             }\n",
            "         } else { // named\n",
            "             // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n",
            "-            String nameRef = reader.consumeLetterSequence();\n",
            "+            String nameRef = reader.consumeLetterThenDigitSequence();\n",
            "             String origNameRef = new String(nameRef); // for error reporting. nameRef gets chomped looking for matches\n",
            "             boolean looksLegit = reader.matches(';');\n",
            "             boolean found = false;\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
