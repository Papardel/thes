{
  "bug_id": "22",
  "failed_tests": {
    "com.fasterxml.jackson.databind.ser.TestJsonValue": [
      {
        "methodName": "testJsonValueWithCustomOverride",
        "error": "junit.framework.ComparisonFailure",
        "message": "expected:<[42]> but was:<[\"value\"]>",
        "fail_line": "        assertEquals(\"42\", mapper.writeValueAsString(INPUT));",
        "test_source": "  public void testJsonValueWithCustomOverride() throws Exception {\n  final Bean838 INPUT = new Bean838();\n\n  // by default, @JsonValue should be used\n  assertEquals(quote(\"value\"), MAPPER.writeValueAsString(INPUT));\n\n  // but custom serializer should override it\n  ObjectMapper mapper = new ObjectMapper();\n  mapper.registerModule(new SimpleModule()\n  .addSerializer(Bean838.class, new Bean838Serializer())\n  );\n  assertEquals(\"42\", mapper.writeValueAsString(INPUT));\n  }",
        "stack": [
          "TestJsonValue.testJsonValueWithCustomOverride line 282"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.ser;\n\nimport java.lang.reflect.Method;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig;\nimport com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.ser.impl.*;\nimport com.fasterxml.jackson.databind.ser.std.*;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.*;\n\n\n@SuppressWarnings(\"serial\")\npublic abstract class BasicSerializerFactory extends SerializerFactory implements java.io.Serializable { protected final static HashMap<String, JsonSerializer<?>> _concrete = new HashMap<String, JsonSerializer<?>>(); protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy = new HashMap<String, Class<? extends JsonSerializer<?>>>(); static {\n        \n        _concrete.put(String.class.getName(), new StringSerializer());\n        final ToStringSerializer sls = ToStringSerializer.instance;\n        _concrete.put(StringBuffer.class.getName(), sls);\n        _concrete.put(StringBuilder.class.getName(), sls);\n        _concrete.put(Character.class.getName(), sls);\n        _concrete.put(Character.TYPE.getName(), sls);\n\n        \n        NumberSerializers.addAll(_concrete);\n        _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true));\n        _concrete.put(Boolean.class.getName(), new BooleanSerializer(false));\n\n        \n        _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class));\n        _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class));\n\n        \n        \n        _concrete.put(Calendar.class.getName(), CalendarSerializer.instance);\n        DateSerializer dateSer = DateSerializer.instance;\n        _concrete.put(java.util.Date.class.getName(), dateSer);\n        \n        _concrete.put(java.sql.Timestamp.class.getName(), dateSer);\n        \n        \n        _concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class);\n        _concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class);\n\n        \n        for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) {\n            Object value = en.getValue();\n            if (value instanceof JsonSerializer<?>) {\n                _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value);\n            } else if (value instanceof Class<?>) {\n                @SuppressWarnings(\"unchecked\")\n                Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value;\n                _concreteLazy.put(en.getKey().getName(), cls);\n            } else { \n                throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName());\n            }\n        }\n\n        \n        \n        _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class);\n    }\n\n    \n    \n    \n    protected final SerializerFactoryConfig _factoryConfig; protected BasicSerializerFactory(SerializerFactoryConfig config) {\n        _factoryConfig = (config == null) ? new SerializerFactoryConfig() : config;\n    }\n    \n    \n    public SerializerFactoryConfig getFactoryConfig() {\n        return _factoryConfig;\n    }\n\n    \n    public abstract SerializerFactory withConfig(SerializerFactoryConfig config); @Override public final SerializerFactory withAdditionalSerializers(Serializers additional) {\n        return withConfig(_factoryConfig.withAdditionalSerializers(additional));\n    }\n\n    \n    @Override\n    public final SerializerFactory withAdditionalKeySerializers(Serializers additional) {\n        return withConfig(_factoryConfig.withAdditionalKeySerializers(additional));\n    }\n    \n    \n    @Override\n    public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) {\n        return withConfig(_factoryConfig.withSerializerModifier(modifier));\n    }\n\n    \n    \n    \n    @Override\n    public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException; @Override @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) {\n        \n        \n        BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass());\n        JsonSerializer<?> ser = null;\n        \n        if (_factoryConfig.hasKeySerializers()) {\n            \n            for (Serializers serializers : _factoryConfig.keySerializers()) {\n                ser = serializers.findSerializer(config, keyType, beanDesc);\n                if (ser != null) {\n                    break;\n                }\n            }\n        }\n        if (ser == null) {\n            ser = defaultImpl;\n            if (ser == null) {\n                ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false);\n                \n                if (ser == null) {\n                    beanDesc = config.introspect(keyType);\n                    AnnotatedMethod am = beanDesc.findJsonValueMethod();\n                    if (am != null) {\n                        final Class<?> rawType = am.getRawReturnType();\n                        JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config,\n                                rawType, true);\n                        Method m = am.getAnnotated();\n                        if (config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(m);\n                        }\n                        ser = new JsonValueSerializer(m, delegate);\n                    } else {\n                        ser = StdKeySerializers.getDefault();\n                    }\n                }\n            }\n        }\n        \n        \n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser);\n            }\n        }\n        return (JsonSerializer<Object>) ser;\n    }\n\n    \n    @Override\n    public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) {\n        BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n        AnnotatedClass ac = bean.getClassInfo();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n        \n        Collection<NamedType> subtypes = null;\n        if (b == null) {\n            b = config.getDefaultTyper(baseType);\n        } else {\n            subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, ac);\n        }\n        if (b == null) {\n            return null;\n        }\n        \n        \n        return b.buildTypeSerializer(config, baseType, subtypes);\n    }\n\n    \n\n    protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping) {\n        Class<?> raw = type.getRawClass();\n        String clsName = raw.getName();\n        if (type.isReferenceType()) {\n            if (type.isTypeOrSubTypeOf(AtomicReference.class)) {\n                return new AtomicReferenceSerializer((ReferenceType) type);\n            }\n        }\n        JsonSerializer<?> ser = _concrete.get(clsName);\n        if (ser == null) {\n            Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName);\n            if (serClass != null) {\n                try {\n                    return serClass.newInstance();\n                } catch (Exception e) {\n                    throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \"\n                            +e.getMessage(), e);\n                }\n            }\n        }\n        return ser;\n    }\n\n    \n    protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        Class<?> raw = type.getRawClass();\n        \n        if (JsonSerializable.class.isAssignableFrom(raw)) {\n            return SerializableSerializer.instance;\n        }\n        \n        AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod();\n        if (valueMethod != null) {\n            Method m = valueMethod.getAnnotated();\n            if (prov.canOverrideAccessModifiers()) {\n                ClassUtil.checkAndFixAccess(m);\n            }\n            JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod);\n            return new JsonValueSerializer(m, ser);\n        }\n        \n        return null;\n    }\n    \n    \n    protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {\n        Class<?> raw = type.getRawClass();\n        \n        \n        JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping);\n        if (ser != null) {\n            return ser;\n        }\n        \n        if (Calendar.class.isAssignableFrom(raw)) {\n            return CalendarSerializer.instance;\n        }\n        if (java.util.Date.class.isAssignableFrom(raw)) {\n            return DateSerializer.instance;\n        }\n        if (Map.Entry.class.isAssignableFrom(raw)) {\n            \n            JavaType kt = type.containedType(0);\n            if (kt == null) {\n                kt = TypeFactory.unknownType();\n            }\n            JavaType vt = type.containedType(1);\n            if (vt == null) {\n                vt = TypeFactory.unknownType();\n            }\n            return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt);\n        }\n        if (ByteBuffer.class.isAssignableFrom(raw)) {\n            return new ByteBufferSerializer();\n        }\n        if (InetAddress.class.isAssignableFrom(raw)) {\n            return new InetAddressSerializer();\n        }\n        if (InetSocketAddress.class.isAssignableFrom(raw)) {\n            return new InetSocketAddressSerializer();\n        }\n        if (TimeZone.class.isAssignableFrom(raw)) {\n            return new TimeZoneSerializer();\n        }\n        if (java.nio.charset.Charset.class.isAssignableFrom(raw)) {\n            return ToStringSerializer.instance;\n        }\n        if (Number.class.isAssignableFrom(raw)) {\n            \n            JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n            if (format != null) {\n                switch (format.getShape()) {\n                case STRING:\n                    return ToStringSerializer.instance;\n                case OBJECT: \n                case ARRAY: \n                    return null;\n                default:\n                }\n            }\n            return NumberSerializer.instance;\n        }\n        if (Enum.class.isAssignableFrom(raw)) {\n            return buildEnumSerializer(prov.getConfig(), type, beanDesc);\n        }\n        return null;\n    }\n\n    \n    protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {\n        return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc);\n    }\n        \n    \n    protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {\n        Class<?> type = javaType.getRawClass();\n\n        if (Iterator.class.isAssignableFrom(type)) {\n            JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class);\n            JavaType vt = (params == null || params.length != 1) ?\n                    TypeFactory.unknownType() : params[0];\n            return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt);\n        }\n        if (Iterable.class.isAssignableFrom(type)) {\n            JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class);\n            JavaType vt = (params == null || params.length != 1) ?\n                    TypeFactory.unknownType() : params[0];\n            return buildIterableSerializer(config, javaType, beanDesc,  staticTyping, vt);\n        }\n        if (CharSequence.class.isAssignableFrom(type)) {\n            return ToStringSerializer.instance;\n        }\n        return null;\n    }\n    \n    \n    @SuppressWarnings(\"unchecked\")\n    protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException {\n        Object serDef = prov.getAnnotationIntrospector().findSerializer(a);\n        if (serDef == null) {\n            return null;\n        }\n        JsonSerializer<Object> ser = prov.serializerInstance(a, serDef);\n        \n        return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser);\n    }\n\n    \n    protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException {\n        Converter<Object,Object> conv = findConverter(prov, a);\n        if (conv == null) {\n            return ser;\n        }\n        JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n        return new StdDelegatingSerializer(conv, delegateType, ser);\n    }\n\n    protected Converter<Object,Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException {\n        Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a);\n        if (convDef == null) {\n            return null;\n        }\n        return prov.converterInstance(a, convDef);\n    }\n    \n    \n\n    \n    protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {\n        final SerializationConfig config = prov.getConfig();\n\n        \n        if (!staticTyping && type.useStaticType()) {\n            if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) {\n                staticTyping = true;\n            }\n        }\n        \n        \n        JavaType elementType = type.getContentType();\n        TypeSerializer elementTypeSerializer = createTypeSerializer(config,\n                elementType);\n\n        \n        if (elementTypeSerializer != null) {\n            staticTyping = false;\n        }\n        JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov,\n                beanDesc.getClassInfo());\n        if (type.isMapLikeType()) { \n            MapLikeType mlt = (MapLikeType) type;\n            \n            JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo());\n            if (mlt.isTrueMapType()) {\n                return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping,\n                        keySerializer, elementTypeSerializer, elementValueSerializer);\n            }\n            \n            JsonSerializer<?> ser = null;\n            for (Serializers serializers : customSerializers()) { \n                MapLikeType mlType = (MapLikeType) type;\n                ser = serializers.findMapLikeSerializer(config,\n                        mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer);\n            if (ser != null) {\n                if (_factoryConfig.hasSerializerModifiers()) {\n                    for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                        ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser);\n                    }\n                    }\n                    return ser;\n                }\n            }\n            return null;\n        }\n        if (type.isCollectionLikeType()) {\n            CollectionLikeType clt = (CollectionLikeType) type;\n            if (clt.isTrueCollectionType()) {\n                return buildCollectionSerializer(config,  (CollectionType) clt, beanDesc, staticTyping,\n                        elementTypeSerializer, elementValueSerializer);\n            }\n            \n            JsonSerializer<?> ser = null;\n            CollectionLikeType clType = (CollectionLikeType) type;\n            for (Serializers serializers : customSerializers()) { \n                ser = serializers.findCollectionLikeSerializer(config,\n                        clType, beanDesc, elementTypeSerializer, elementValueSerializer);\n            if (ser != null) {\n                if (_factoryConfig.hasSerializerModifiers()) {\n                    for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                        ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser);\n                        }\n                    }\n                    return ser;\n                }\n            }\n            return null;\n        }\n        if (type.isArrayType()) {\n            return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping,\n                    elementTypeSerializer, elementValueSerializer);\n        }\n        return null;\n    }\n\n    \n    protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException {\n        JsonSerializer<?> ser = null;\n        \n        \n        \n        \n        for (Serializers serializers : customSerializers()) { \n            ser = serializers.findCollectionSerializer(config,\n                    type, beanDesc, elementTypeSerializer, elementValueSerializer);\n            if (ser != null) {\n                break;\n            }\n        }\n\n        if (ser == null) {\n                \n                \n                JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n                if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {\n                    return null;\n                }\n                Class<?> raw = type.getRawClass();\n                if (EnumSet.class.isAssignableFrom(raw)) {\n                    \n                    JavaType enumType = type.getContentType();\n                    \n                    if (!enumType.isEnumType()) {\n                        enumType = null;\n                    }\n                    ser = buildEnumSetSerializer(enumType);\n                } else {\n                    Class<?> elementRaw = type.getContentType().getRawClass();\n                    if (isIndexedList(raw)) {\n                        if (elementRaw == String.class) {\n                            \n                            if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n                                ser = IndexedStringListSerializer.instance;\n                            }\n                        } else {\n                            ser = buildIndexedListSerializer(type.getContentType(), staticTyping,\n                                elementTypeSerializer, elementValueSerializer);\n                        }\n                    } else if (elementRaw == String.class) {\n                        \n                        if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n                            ser = StringCollectionSerializer.instance;\n                        }\n                    }\n                    if (ser == null) {\n                        ser = buildCollectionSerializer(type.getContentType(), staticTyping,\n                                elementTypeSerializer, elementValueSerializer);\n                }\n            }\n        }\n        \n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser);\n            }\n        }\n        return ser;\n    }\n\n    \n\n    protected boolean isIndexedList(Class<?> cls) {\n        return RandomAccess.class.isAssignableFrom(cls);\n    }\n\n    public ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) {\n        return new IndexedListSerializer(elemType, staticTyping, vts, valueSerializer);\n    }\n    public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) {\n        return new CollectionSerializer(elemType, staticTyping, vts, valueSerializer);\n    }\n\n    public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) {\n        return new EnumSetSerializer(enumType);\n    }\n\n    \n    \n    \n    protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException {\n        JsonSerializer<?> ser = null;\n\n        \n        \n        \n        \n        \n        for (Serializers serializers : customSerializers()) { \n            ser = serializers.findMapSerializer(config, type, beanDesc,\n                    keySerializer, elementTypeSerializer, elementValueSerializer);\n            if (ser != null) { break; }\n        }\n        if (ser == null) {\n                \n                \n                Object filterId = findFilterId(config, beanDesc);\n                AnnotationIntrospector ai = config.getAnnotationIntrospector();\n                MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true),\n                        type, staticTyping, elementTypeSerializer,\n                        keySerializer, elementValueSerializer, filterId);\n                Object suppressableValue = findSuppressableContentValue(config,\n                        type.getContentType(), beanDesc);\n                if (suppressableValue != null) {\n                    mapSer = mapSer.withContentInclusion(suppressableValue);\n                }\n                ser = mapSer;\n            }\n        \n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                ser = mod.modifyMapSerializer(config, type, beanDesc, ser);\n            }\n        }\n        return ser;\n    }\n\n    \n    protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc) throws JsonMappingException {\n        JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null);\n\n        if (incl != null) {\n            switch (incl) {\n            case NON_DEFAULT:\n                \n                incl = JsonInclude.Include.NON_EMPTY;\n                break;\n            default:\n                \n                break;\n            }\n            return incl;\n        }\n        return null;\n    }\n    \n    \n    \n    \n    protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException {\n        \n        \n        \n        \n        JsonSerializer<?> ser = null;\n\n        for (Serializers serializers : customSerializers()) { \n             ser = serializers.findArraySerializer(config,\n                     type, beanDesc, elementTypeSerializer, elementValueSerializer);\n             if (ser != null) {\n                 break;\n             }\n        }\n        \n        if (ser == null) {\n             Class<?> raw = type.getRawClass();\n             \n             if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n                 if (String[].class == raw) {\n                     ser = StringArraySerializer.instance;\n                 } else {\n                     \n                     ser = StdArraySerializers.findStandardImpl(raw);\n                 }\n             }\n             if (ser == null) {\n                 ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer,\n                         elementValueSerializer);\n             }\n         }\n         \n         if (_factoryConfig.hasSerializerModifiers()) {\n             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                 ser = mod.modifyArraySerializer(config, type, beanDesc, ser);\n             }\n         }\n         return ser;\n    }\n\n    \n\n    \n    protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException {\n        return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType));\n    }\n\n    @Deprecated \n    protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {\n        JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class);\n        JavaType vt = (params == null || params.length != 1) ?\n                TypeFactory.unknownType() : params[0];\n        return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt); \n    }\n\n    \n    protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException {\n        return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType));\n    }\n\n    @Deprecated \n    protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {\n        JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class);\n        JavaType vt = (params == null || params.length != 1) ?\n                TypeFactory.unknownType() : params[0];\n        return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); \n    }\n    \n    \n    protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType) throws JsonMappingException {\n        return new MapEntrySerializer(valueType, keyType, valueType,\n                staticTyping, createTypeSerializer(config, valueType), null);\n    }\n\n    protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        \n        JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n        if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {\n            \n            ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\");\n            \n            return null;\n        }\n        @SuppressWarnings(\"unchecked\")\n        Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass();\n        JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format);\n        \n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                ser = mod.modifyEnumSerializer(config, type, beanDesc, ser);\n            }\n        }\n        return ser;\n    }\n\n    \n    \n    \n    @SuppressWarnings(\"unchecked\")\n    protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type) {\n        \n        Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a);\n        if (superclass != null) {\n            try {\n                type = (T) type.widenBy(superclass);\n            } catch (IllegalArgumentException iae) {\n                throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage());\n            }\n        }\n        return modifySecondaryTypesByAnnotation(config, a, type);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) {\n        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n        \n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                \n                if (!(type instanceof MapType)) {\n                    throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\");\n                }\n                try {\n                    type = (T) ((MapType) type).widenKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage());\n                }\n            }\n            \n            \n            Class<?> cc = intr.findSerializationContentType(a, type.getContentType());\n            if (cc != null) {\n                try {\n                    type = (T) type.widenContentsBy(cc);\n                } catch (IllegalArgumentException iae) {\n                    throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage());\n                }\n            }\n        }\n        return type;\n    }\n\n    \n    protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException {\n        AnnotationIntrospector intr = prov.getAnnotationIntrospector();\n        Object serDef = intr.findKeySerializer(a);\n        if (serDef != null) {\n            return prov.serializerInstance(a, serDef);\n        }\n        return null;\n    }\n\n    \n    protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException {\n        AnnotationIntrospector intr = prov.getAnnotationIntrospector();\n        Object serDef = intr.findContentSerializer(a);\n        if (serDef != null) {\n            return prov.serializerInstance(a, serDef);\n        }\n        return null;\n    }\n\n    \n    protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) {\n        return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo());\n    }\n\n    \n    protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) {\n        \n        if (typeSer != null) {\n            return false;\n        }\n        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n        JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo());\n        if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) {\n            return (t == JsonSerialize.Typing.STATIC);\n        }\n        return config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n    }\n\n    protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) {\n        if (src == null) {\n            return null;\n        }\n        if (!(src instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\");\n        }\n        Class<?> cls = (Class<?>) src;\n        if (cls == noneClass || ClassUtil.isBogusClass(cls)) {\n            return null;\n        }\n        return cls;\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.ser;\n\nimport java.lang.reflect.Method;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig;\nimport com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.ser.impl.*;\nimport com.fasterxml.jackson.databind.ser.std.*;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.*;\n\n\n@SuppressWarnings(\"serial\")\npublic abstract class BasicSerializerFactory extends SerializerFactory implements java.io.Serializable { protected final static HashMap<String, JsonSerializer<?>> _concrete = new HashMap<String, JsonSerializer<?>>(); protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy = new HashMap<String, Class<? extends JsonSerializer<?>>>(); static {\n        \n        _concrete.put(String.class.getName(), new StringSerializer());\n        final ToStringSerializer sls = ToStringSerializer.instance;\n        _concrete.put(StringBuffer.class.getName(), sls);\n        _concrete.put(StringBuilder.class.getName(), sls);\n        _concrete.put(Character.class.getName(), sls);\n        _concrete.put(Character.TYPE.getName(), sls);\n\n        \n        NumberSerializers.addAll(_concrete);\n        _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true));\n        _concrete.put(Boolean.class.getName(), new BooleanSerializer(false));\n\n        \n        _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class));\n        _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class));\n\n        \n        \n        _concrete.put(Calendar.class.getName(), CalendarSerializer.instance);\n        DateSerializer dateSer = DateSerializer.instance;\n        _concrete.put(java.util.Date.class.getName(), dateSer);\n        \n        _concrete.put(java.sql.Timestamp.class.getName(), dateSer);\n        \n        \n        _concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class);\n        _concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class);\n\n        \n        for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) {\n            Object value = en.getValue();\n            if (value instanceof JsonSerializer<?>) {\n                _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value);\n            } else if (value instanceof Class<?>) {\n                @SuppressWarnings(\"unchecked\")\n                Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value;\n                _concreteLazy.put(en.getKey().getName(), cls);\n            } else { \n                throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName());\n            }\n        }\n\n        \n        \n        _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class);\n    }\n\n    \n    \n    \n    protected final SerializerFactoryConfig _factoryConfig; protected BasicSerializerFactory(SerializerFactoryConfig config) {\n        _factoryConfig = (config == null) ? new SerializerFactoryConfig() : config;\n    }\n    \n    \n    public SerializerFactoryConfig getFactoryConfig() {\n        return _factoryConfig;\n    }\n\n    \n    public abstract SerializerFactory withConfig(SerializerFactoryConfig config); @Override public final SerializerFactory withAdditionalSerializers(Serializers additional) {\n        return withConfig(_factoryConfig.withAdditionalSerializers(additional));\n    }\n\n    \n    @Override\n    public final SerializerFactory withAdditionalKeySerializers(Serializers additional) {\n        return withConfig(_factoryConfig.withAdditionalKeySerializers(additional));\n    }\n    \n    \n    @Override\n    public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) {\n        return withConfig(_factoryConfig.withSerializerModifier(modifier));\n    }\n\n    \n    \n    \n    @Override\n    public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException; @Override @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) {\n        \n        \n        BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass());\n        JsonSerializer<?> ser = null;\n        \n        if (_factoryConfig.hasKeySerializers()) {\n            \n            for (Serializers serializers : _factoryConfig.keySerializers()) {\n                ser = serializers.findSerializer(config, keyType, beanDesc);\n                if (ser != null) {\n                    break;\n                }\n            }\n        }\n        if (ser == null) {\n            ser = defaultImpl;\n            if (ser == null) {\n                ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false);\n                \n                if (ser == null) {\n                    beanDesc = config.introspect(keyType);\n                    AnnotatedMethod am = beanDesc.findJsonValueMethod();\n                    if (am != null) {\n                        final Class<?> rawType = am.getRawReturnType();\n                        JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config,\n                                rawType, true);\n                        Method m = am.getAnnotated();\n                        if (config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(m);\n                        }\n                        ser = new JsonValueSerializer(m, delegate);\n                    } else {\n                        ser = StdKeySerializers.getDefault();\n                    }\n                }\n            }\n        }\n        \n        \n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser);\n            }\n        }\n        return (JsonSerializer<Object>) ser;\n    }\n\n    \n    @Override\n    public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) {\n        BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n        AnnotatedClass ac = bean.getClassInfo();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n        \n        Collection<NamedType> subtypes = null;\n        if (b == null) {\n            b = config.getDefaultTyper(baseType);\n        } else {\n            subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, ac);\n        }\n        if (b == null) {\n            return null;\n        }\n        \n        \n        return b.buildTypeSerializer(config, baseType, subtypes);\n    }\n\n    \n\n    protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping) {\n        Class<?> raw = type.getRawClass();\n        String clsName = raw.getName();\n        if (type.isReferenceType()) {\n            if (type.isTypeOrSubTypeOf(AtomicReference.class)) {\n                return new AtomicReferenceSerializer((ReferenceType) type);\n            }\n        }\n        JsonSerializer<?> ser = _concrete.get(clsName);\n        if (ser == null) {\n            Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName);\n            if (serClass != null) {\n                try {\n                    return serClass.newInstance();\n                } catch (Exception e) {\n                    throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \"\n                            +e.getMessage(), e);\n                }\n            }\n        }\n        return ser;\n    }\n\n    \n    protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        Class<?> raw = type.getRawClass();\n        \n        if (JsonSerializable.class.isAssignableFrom(raw)) {\n            return SerializableSerializer.instance;\n        }\n        \n        AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod();\n        if (valueMethod != null) {\n            Method m = valueMethod.getAnnotated();\n            if (prov.canOverrideAccessModifiers()) {\n                ClassUtil.checkAndFixAccess(m);\n            }\n            JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod);\n            return new JsonValueSerializer(m, ser);\n        }\n        \n        return null;\n    }\n    \n    \n    protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {\n        Class<?> raw = type.getRawClass();\n        \n        \n        JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping);\n        if (ser != null) {\n            return ser;\n        }\n        \n        if (Calendar.class.isAssignableFrom(raw)) {\n            return CalendarSerializer.instance;\n        }\n        if (java.util.Date.class.isAssignableFrom(raw)) {\n            return DateSerializer.instance;\n        }\n        if (Map.Entry.class.isAssignableFrom(raw)) {\n            \n            JavaType kt = type.containedType(0);\n            if (kt == null) {\n                kt = TypeFactory.unknownType();\n            }\n            JavaType vt = type.containedType(1);\n            if (vt == null) {\n                vt = TypeFactory.unknownType();\n            }\n            return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt);\n        }\n        if (ByteBuffer.class.isAssignableFrom(raw)) {\n            return new ByteBufferSerializer();\n        }\n        if (InetAddress.class.isAssignableFrom(raw)) {\n            return new InetAddressSerializer();\n        }\n        if (InetSocketAddress.class.isAssignableFrom(raw)) {\n            return new InetSocketAddressSerializer();\n        }\n        if (TimeZone.class.isAssignableFrom(raw)) {\n            return new TimeZoneSerializer();\n        }\n        if (java.nio.charset.Charset.class.isAssignableFrom(raw)) {\n            return ToStringSerializer.instance;\n        }\n        if (Number.class.isAssignableFrom(raw)) {\n            \n            JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n            if (format != null) {\n                switch (format.getShape()) {\n                case STRING:\n                    return ToStringSerializer.instance;\n                case OBJECT: \n                case ARRAY: \n                    return null;\n                default:\n                }\n            }\n            return NumberSerializer.instance;\n        }\n        if (Enum.class.isAssignableFrom(raw)) {\n            return buildEnumSerializer(prov.getConfig(), type, beanDesc);\n        }\n        return null;\n    }\n\n    \n    protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {\n        return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc);\n    }\n        \n    \n    protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {\n        Class<?> type = javaType.getRawClass();\n\n        if (Iterator.class.isAssignableFrom(type)) {\n            JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class);\n            JavaType vt = (params == null || params.length != 1) ?\n                    TypeFactory.unknownType() : params[0];\n            return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt);\n        }\n        if (Iterable.class.isAssignableFrom(type)) {\n            JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class);\n            JavaType vt = (params == null || params.length != 1) ?\n                    TypeFactory.unknownType() : params[0];\n            return buildIterableSerializer(config, javaType, beanDesc,  staticTyping, vt);\n        }\n        if (CharSequence.class.isAssignableFrom(type)) {\n            return ToStringSerializer.instance;\n        }\n        return null;\n    }\n    \n    \n    @SuppressWarnings(\"unchecked\")\n    protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException {\n        Object serDef = prov.getAnnotationIntrospector().findSerializer(a);\n        if (serDef == null) {\n            return null;\n        }\n        JsonSerializer<Object> ser = prov.serializerInstance(a, serDef);\n        \n        return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser);\n    }\n\n    \n    protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException {\n        Converter<Object,Object> conv = findConverter(prov, a);\n        if (conv == null) {\n            return ser;\n        }\n        JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n        return new StdDelegatingSerializer(conv, delegateType, ser);\n    }\n\n    protected Converter<Object,Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException {\n        Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a);\n        if (convDef == null) {\n            return null;\n        }\n        return prov.converterInstance(a, convDef);\n    }\n    \n    \n\n    \n    protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {\n        final SerializationConfig config = prov.getConfig();\n\n        \n        if (!staticTyping && type.useStaticType()) {\n            if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) {\n                staticTyping = true;\n            }\n        }\n        \n        \n        JavaType elementType = type.getContentType();\n        TypeSerializer elementTypeSerializer = createTypeSerializer(config,\n                elementType);\n\n        \n        if (elementTypeSerializer != null) {\n            staticTyping = false;\n        }\n        JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov,\n                beanDesc.getClassInfo());\n        if (type.isMapLikeType()) { \n            MapLikeType mlt = (MapLikeType) type;\n            \n            JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo());\n            if (mlt.isTrueMapType()) {\n                return buildMapSerializer(prov, (MapType) mlt, beanDesc, staticTyping,\n                        keySerializer, elementTypeSerializer, elementValueSerializer);\n            }\n            \n            JsonSerializer<?> ser = null;\n            MapLikeType mlType = (MapLikeType) type;\n            for (Serializers serializers : customSerializers()) { \n                ser = serializers.findMapLikeSerializer(config,\n                        mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer);\n                if (ser != null) {\n                    break;\n                }\n            }\n            if (ser == null) { \n                ser = findSerializerByAnnotations(prov, type, beanDesc);\n            }\n            if (ser != null) {\n                if (_factoryConfig.hasSerializerModifiers()) {\n                    for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                        ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser);\n                    }\n                }\n            }\n            return ser;\n        }\n        if (type.isCollectionLikeType()) {\n            CollectionLikeType clt = (CollectionLikeType) type;\n            if (clt.isTrueCollectionType()) {\n                return buildCollectionSerializer(prov,  (CollectionType) clt, beanDesc, staticTyping,\n                        elementTypeSerializer, elementValueSerializer);\n            }\n            \n            JsonSerializer<?> ser = null;\n            CollectionLikeType clType = (CollectionLikeType) type;\n            for (Serializers serializers : customSerializers()) { \n                ser = serializers.findCollectionLikeSerializer(config,\n                        clType, beanDesc, elementTypeSerializer, elementValueSerializer);\n                if (ser != null) {\n                    break;\n                }\n            }\n            if (ser == null) { \n                ser = findSerializerByAnnotations(prov, type, beanDesc);\n            }\n            if (ser != null) {\n                if (_factoryConfig.hasSerializerModifiers()) {\n                    for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                        ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser);\n                    }\n                }\n            }\n            return ser;\n        }\n        if (type.isArrayType()) {\n            return buildArraySerializer(prov, (ArrayType) type, beanDesc, staticTyping,\n                    elementTypeSerializer, elementValueSerializer);\n        }\n        return null;\n    }\n\n    \n    protected JsonSerializer<?> buildCollectionSerializer(SerializerProvider prov, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException {\n        SerializationConfig config = prov.getConfig();\n        JsonSerializer<?> ser = null;\n        \n        \n        \n        \n        for (Serializers serializers : customSerializers()) { \n            ser = serializers.findCollectionSerializer(config,\n                    type, beanDesc, elementTypeSerializer, elementValueSerializer);\n            if (ser != null) {\n                break;\n            }\n        }\n\n        if (ser == null) {\n            ser = findSerializerByAnnotations(prov, type, beanDesc); \n            if (ser == null) {\n                \n                \n                JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n                if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {\n                    return null;\n                }\n                Class<?> raw = type.getRawClass();\n                if (EnumSet.class.isAssignableFrom(raw)) {\n                    \n                    JavaType enumType = type.getContentType();\n                    \n                    if (!enumType.isEnumType()) {\n                        enumType = null;\n                    }\n                    ser = buildEnumSetSerializer(enumType);\n                } else {\n                    Class<?> elementRaw = type.getContentType().getRawClass();\n                    if (isIndexedList(raw)) {\n                        if (elementRaw == String.class) {\n                            \n                            if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n                                ser = IndexedStringListSerializer.instance;\n                            }\n                        } else {\n                            ser = buildIndexedListSerializer(type.getContentType(), staticTyping,\n                                elementTypeSerializer, elementValueSerializer);\n                        }\n                    } else if (elementRaw == String.class) {\n                        \n                        if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n                            ser = StringCollectionSerializer.instance;\n                        }\n                    }\n                    if (ser == null) {\n                        ser = buildCollectionSerializer(type.getContentType(), staticTyping,\n                                elementTypeSerializer, elementValueSerializer);\n                    }\n                }\n            }\n        }\n        \n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser);\n            }\n        }\n        return ser;\n    }\n\n    \n\n    protected boolean isIndexedList(Class<?> cls) {\n        return RandomAccess.class.isAssignableFrom(cls);\n    }\n\n    public ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) {\n        return new IndexedListSerializer(elemType, staticTyping, vts, valueSerializer);\n    }\n    public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) {\n        return new CollectionSerializer(elemType, staticTyping, vts, valueSerializer);\n    }\n\n    public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) {\n        return new EnumSetSerializer(enumType);\n    }\n\n    \n    \n    \n    protected JsonSerializer<?> buildMapSerializer(SerializerProvider prov, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException {\n        final SerializationConfig config = prov.getConfig();\n        JsonSerializer<?> ser = null;\n\n        \n        \n        \n        \n        \n        for (Serializers serializers : customSerializers()) { \n            ser = serializers.findMapSerializer(config, type, beanDesc,\n                    keySerializer, elementTypeSerializer, elementValueSerializer);\n            if (ser != null) { break; }\n        }\n        if (ser == null) {\n            ser = findSerializerByAnnotations(prov, type, beanDesc); \n            if (ser == null) {\n                \n                \n                Object filterId = findFilterId(config, beanDesc);\n                AnnotationIntrospector ai = config.getAnnotationIntrospector();\n                MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true),\n                        type, staticTyping, elementTypeSerializer,\n                        keySerializer, elementValueSerializer, filterId);\n                Object suppressableValue = findSuppressableContentValue(config,\n                        type.getContentType(), beanDesc);\n                if (suppressableValue != null) {\n                    mapSer = mapSer.withContentInclusion(suppressableValue);\n                }\n                ser = mapSer;\n            }\n        }\n        \n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                ser = mod.modifyMapSerializer(config, type, beanDesc, ser);\n            }\n        }\n        return ser;\n    }\n\n    \n    protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc) throws JsonMappingException {\n        JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null);\n\n        if (incl != null) {\n            switch (incl) {\n            case NON_DEFAULT:\n                \n                incl = JsonInclude.Include.NON_EMPTY;\n                break;\n            default:\n                \n                break;\n            }\n            return incl;\n        }\n        return null;\n    }\n    \n    \n    \n    \n    protected JsonSerializer<?> buildArraySerializer(SerializerProvider prov, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException {\n        \n        \n        \n        \n        SerializationConfig config = prov.getConfig();\n        JsonSerializer<?> ser = null;\n\n        for (Serializers serializers : customSerializers()) { \n             ser = serializers.findArraySerializer(config,\n                     type, beanDesc, elementTypeSerializer, elementValueSerializer);\n             if (ser != null) {\n                 break;\n             }\n        }\n        \n        if (ser == null) {\n             Class<?> raw = type.getRawClass();\n             \n             if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n                 if (String[].class == raw) {\n                     ser = StringArraySerializer.instance;\n                 } else {\n                     \n                     ser = StdArraySerializers.findStandardImpl(raw);\n                 }\n             }\n             if (ser == null) {\n                 ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer,\n                         elementValueSerializer);\n             }\n         }\n         \n         if (_factoryConfig.hasSerializerModifiers()) {\n             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                 ser = mod.modifyArraySerializer(config, type, beanDesc, ser);\n             }\n         }\n         return ser;\n    }\n\n    \n\n    \n    protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException {\n        return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType));\n    }\n\n    @Deprecated \n    protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {\n        JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class);\n        JavaType vt = (params == null || params.length != 1) ?\n                TypeFactory.unknownType() : params[0];\n        return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt); \n    }\n\n    \n    protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException {\n        return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType));\n    }\n\n    @Deprecated \n    protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {\n        JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class);\n        JavaType vt = (params == null || params.length != 1) ?\n                TypeFactory.unknownType() : params[0];\n        return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); \n    }\n    \n    \n    protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType) throws JsonMappingException {\n        return new MapEntrySerializer(valueType, keyType, valueType,\n                staticTyping, createTypeSerializer(config, valueType), null);\n    }\n\n    protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        \n        JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n        if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {\n            \n            ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\");\n            \n            return null;\n        }\n        @SuppressWarnings(\"unchecked\")\n        Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass();\n        JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format);\n        \n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                ser = mod.modifyEnumSerializer(config, type, beanDesc, ser);\n            }\n        }\n        return ser;\n    }\n\n    \n    \n    \n    @SuppressWarnings(\"unchecked\")\n    protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type) {\n        \n        Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a);\n        if (superclass != null) {\n            try {\n                type = (T) type.widenBy(superclass);\n            } catch (IllegalArgumentException iae) {\n                throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage());\n            }\n        }\n        return modifySecondaryTypesByAnnotation(config, a, type);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) {\n        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n        \n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                \n                if (!(type instanceof MapType)) {\n                    throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\");\n                }\n                try {\n                    type = (T) ((MapType) type).widenKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage());\n                }\n            }\n            \n            \n            Class<?> cc = intr.findSerializationContentType(a, type.getContentType());\n            if (cc != null) {\n                try {\n                    type = (T) type.widenContentsBy(cc);\n                } catch (IllegalArgumentException iae) {\n                    throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage());\n                }\n            }\n        }\n        return type;\n    }\n\n    \n    protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException {\n        AnnotationIntrospector intr = prov.getAnnotationIntrospector();\n        Object serDef = intr.findKeySerializer(a);\n        if (serDef != null) {\n            return prov.serializerInstance(a, serDef);\n        }\n        return null;\n    }\n\n    \n    protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException {\n        AnnotationIntrospector intr = prov.getAnnotationIntrospector();\n        Object serDef = intr.findContentSerializer(a);\n        if (serDef != null) {\n            return prov.serializerInstance(a, serDef);\n        }\n        return null;\n    }\n\n    \n    protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) {\n        return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo());\n    }\n\n    \n    protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) {\n        \n        if (typeSer != null) {\n            return false;\n        }\n        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n        JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo());\n        if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) {\n            return (t == JsonSerialize.Typing.STATIC);\n        }\n        return config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n    }\n\n    protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) {\n        if (src == null) {\n            return null;\n        }\n        if (!(src instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\");\n        }\n        Class<?> cls = (Class<?>) src;\n        if (cls == noneClass || ClassUtil.isBogusClass(cls)) {\n            return null;\n        }\n        return cls;\n    }\n}\n",
      "buggy_signatures": [
        "protected final SerializerFactoryConfig _factoryConfig; protected BasicSerializerFactory(SerializerFactoryConfig config)",
        "public SerializerFactoryConfig getFactoryConfig()",
        "public abstract SerializerFactory withConfig(SerializerFactoryConfig config); @Override public final SerializerFactory withAdditionalSerializers(Serializers additional)",
        "public final SerializerFactory withAdditionalKeySerializers(Serializers additional)",
        "public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier)",
        "public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException; @Override @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl)",
        "public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType)",
        "protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping)",
        "protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException",
        "protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException",
        "protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException",
        "protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException",
        "protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException",
        "protected Converter<Object,Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException",
        "protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException",
        "protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException",
        "protected boolean isIndexedList(Class<?> cls)",
        "public ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer)",
        "public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer)",
        "public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType)",
        "protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException",
        "protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException",
        "protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException",
        "protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException",
        "protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException",
        "protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException",
        "protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType) throws JsonMappingException",
        "protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type)",
        "protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type)",
        "protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException",
        "protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException",
        "protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc)",
        "protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer)",
        "protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass)"
      ],
      "fixed_signatures": [
        "protected final SerializerFactoryConfig _factoryConfig; protected BasicSerializerFactory(SerializerFactoryConfig config)",
        "public SerializerFactoryConfig getFactoryConfig()",
        "public abstract SerializerFactory withConfig(SerializerFactoryConfig config); @Override public final SerializerFactory withAdditionalSerializers(Serializers additional)",
        "public final SerializerFactory withAdditionalKeySerializers(Serializers additional)",
        "public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier)",
        "public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException; @Override @SuppressWarnings(\"unchecked\") public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl)",
        "public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType)",
        "protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping)",
        "protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException",
        "protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException",
        "protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException",
        "protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException",
        "protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException",
        "protected Converter<Object,Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException",
        "protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException",
        "protected JsonSerializer<?> buildCollectionSerializer(SerializerProvider prov, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException",
        "protected boolean isIndexedList(Class<?> cls)",
        "public ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer)",
        "public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer)",
        "public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType)",
        "protected JsonSerializer<?> buildMapSerializer(SerializerProvider prov, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException",
        "protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonSerializer<?> buildArraySerializer(SerializerProvider prov, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException",
        "protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException",
        "protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException",
        "protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException",
        "protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException",
        "protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType) throws JsonMappingException",
        "protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type)",
        "protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type)",
        "protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException",
        "protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException",
        "protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc)",
        "protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer)",
        "protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass)"
      ],
      "methods": [
        {
          "buggy_method": "  protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {\n  final SerializationConfig config = prov.getConfig();\n\n  \n  if (!staticTyping && type.useStaticType()) {\n  if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) {\n  staticTyping = true;\n  }\n  }\n  \n  \n  JavaType elementType = type.getContentType();\n  TypeSerializer elementTypeSerializer = createTypeSerializer(config,\n  elementType);\n\n  \n  if (elementTypeSerializer != null) {\n  staticTyping = false;\n  }\n  JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov,\n  beanDesc.getClassInfo());\n  if (type.isMapLikeType()) { \n  MapLikeType mlt = (MapLikeType) type;\n  \n  JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo());\n  if (mlt.isTrueMapType()) {\n  return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping,\n  keySerializer, elementTypeSerializer, elementValueSerializer);\n  }\n  \n  JsonSerializer<?> ser = null;\n  for (Serializers serializers : customSerializers()) { \n  MapLikeType mlType = (MapLikeType) type;\n  ser = serializers.findMapLikeSerializer(config,\n  mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer);\n  if (ser != null) {\n  if (_factoryConfig.hasSerializerModifiers()) {\n  for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n  ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser);\n  }\n  }\n  return ser;\n  }\n  }\n  return null;\n  }\n  if (type.isCollectionLikeType()) {\n  CollectionLikeType clt = (CollectionLikeType) type;\n  if (clt.isTrueCollectionType()) {\n  return buildCollectionSerializer(config,  (CollectionType) clt, beanDesc, staticTyping,\n  elementTypeSerializer, elementValueSerializer);\n  }\n  \n  JsonSerializer<?> ser = null;\n  CollectionLikeType clType = (CollectionLikeType) type;\n  for (Serializers serializers : customSerializers()) { \n  ser = serializers.findCollectionLikeSerializer(config,\n  clType, beanDesc, elementTypeSerializer, elementValueSerializer);\n  if (ser != null) {\n  if (_factoryConfig.hasSerializerModifiers()) {\n  for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n  ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser);\n  }\n  }\n  return ser;\n  }\n  }\n  return null;\n  }\n  if (type.isArrayType()) {\n  return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping,\n  elementTypeSerializer, elementValueSerializer);\n  }\n  return null;\n  }",
          "fixed_method": "  protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {\n  final SerializationConfig config = prov.getConfig();\n\n  \n  if (!staticTyping && type.useStaticType()) {\n  if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) {\n  staticTyping = true;\n  }\n  }\n  \n  \n  JavaType elementType = type.getContentType();\n  TypeSerializer elementTypeSerializer = createTypeSerializer(config,\n  elementType);\n\n  \n  if (elementTypeSerializer != null) {\n  staticTyping = false;\n  }\n  JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov,\n  beanDesc.getClassInfo());\n  if (type.isMapLikeType()) { \n  MapLikeType mlt = (MapLikeType) type;\n  \n  JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo());\n  if (mlt.isTrueMapType()) {\n  return buildMapSerializer(prov, (MapType) mlt, beanDesc, staticTyping,\n  keySerializer, elementTypeSerializer, elementValueSerializer);\n  }\n  \n  JsonSerializer<?> ser = null;\n  MapLikeType mlType = (MapLikeType) type;\n  for (Serializers serializers : customSerializers()) { \n  ser = serializers.findMapLikeSerializer(config,\n  mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer);\n  if (ser != null) {\n  break;\n  }\n  }\n  if (ser == null) { \n  ser = findSerializerByAnnotations(prov, type, beanDesc);\n  }\n  if (ser != null) {\n  if (_factoryConfig.hasSerializerModifiers()) {\n  for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n  ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser);\n  }\n  }\n  }\n  return ser;\n  }\n  if (type.isCollectionLikeType()) {\n  CollectionLikeType clt = (CollectionLikeType) type;\n  if (clt.isTrueCollectionType()) {\n  return buildCollectionSerializer(prov,  (CollectionType) clt, beanDesc, staticTyping,\n  elementTypeSerializer, elementValueSerializer);\n  }\n  \n  JsonSerializer<?> ser = null;\n  CollectionLikeType clType = (CollectionLikeType) type;\n  for (Serializers serializers : customSerializers()) { \n  ser = serializers.findCollectionLikeSerializer(config,\n  clType, beanDesc, elementTypeSerializer, elementValueSerializer);\n  if (ser != null) {\n  break;\n  }\n  }\n  if (ser == null) { \n  ser = findSerializerByAnnotations(prov, type, beanDesc);\n  }\n  if (ser != null) {\n  if (_factoryConfig.hasSerializerModifiers()) {\n  for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n  ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser);\n  }\n  }\n  }\n  return ser;\n  }\n  if (type.isArrayType()) {\n  return buildArraySerializer(prov, (ArrayType) type, beanDesc, staticTyping,\n  elementTypeSerializer, elementValueSerializer);\n  }\n  return null;\n  }",
          "diff": [
            "@@ -577,30 +577,35 @@",
            "              */\n",
            "             JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo());\n",
            "             if (mlt.isTrueMapType()) {\n",
            "-                return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping,\n",
            "+                return buildMapSerializer(prov, (MapType) mlt, beanDesc, staticTyping,\n",
            "                         keySerializer, elementTypeSerializer, elementValueSerializer);\n",
            "             }\n",
            "             // With Map-like, just 2 options: (1) Custom, (2) Annotations\n",
            "             JsonSerializer<?> ser = null;\n",
            "+            MapLikeType mlType = (MapLikeType) type;\n",
            "             for (Serializers serializers : customSerializers()) { // (1) Custom\n",
            "-                MapLikeType mlType = (MapLikeType) type;\n",
            "                 ser = serializers.findMapLikeSerializer(config,\n",
            "                         mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer);\n",
            "+                if (ser != null) {\n",
            "+                    break;\n",
            "+                }\n",
            "+            }\n",
            "+            if (ser == null) { // (2) Annotations-based ones:\n",
            "+                ser = findSerializerByAnnotations(prov, type, beanDesc);\n",
            "+            }\n",
            "             if (ser != null) {\n",
            "                 if (_factoryConfig.hasSerializerModifiers()) {\n",
            "                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n",
            "                         ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser);\n",
            "                     }\n",
            "-                    }\n",
            "-                    return ser;\n",
            "-                }\n",
            "-            }\n",
            "-            return null;\n",
            "+                }\n",
            "+            }\n",
            "+            return ser;\n",
            "         }\n",
            "         if (type.isCollectionLikeType()) {\n",
            "             CollectionLikeType clt = (CollectionLikeType) type;\n",
            "             if (clt.isTrueCollectionType()) {\n",
            "-                return buildCollectionSerializer(config,  (CollectionType) clt, beanDesc, staticTyping,\n",
            "+                return buildCollectionSerializer(prov,  (CollectionType) clt, beanDesc, staticTyping,\n",
            "                         elementTypeSerializer, elementValueSerializer);\n",
            "             }\n",
            "             // With Map-like, just 2 options: (1) Custom, (2) Annotations\n",
            "@@ -609,19 +614,24 @@",
            "             for (Serializers serializers : customSerializers()) { // (1) Custom\n",
            "                 ser = serializers.findCollectionLikeSerializer(config,\n",
            "                         clType, beanDesc, elementTypeSerializer, elementValueSerializer);\n",
            "+                if (ser != null) {\n",
            "+                    break;\n",
            "+                }\n",
            "+            }\n",
            "+            if (ser == null) { // (2) Annotations-based ones:\n",
            "+                ser = findSerializerByAnnotations(prov, type, beanDesc);\n",
            "+            }\n",
            "             if (ser != null) {\n",
            "                 if (_factoryConfig.hasSerializerModifiers()) {\n",
            "                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n",
            "                         ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser);\n",
            "-                        }\n",
            "                     }\n",
            "-                    return ser;\n",
            "-                }\n",
            "-            }\n",
            "-            return null;\n",
            "+                }\n",
            "+            }\n",
            "+            return ser;\n",
            "         }\n",
            "         if (type.isArrayType()) {\n",
            "-            return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping,\n",
            "+            return buildArraySerializer(prov, (ArrayType) type, beanDesc, staticTyping,\n",
            "                     elementTypeSerializer, elementValueSerializer);\n",
            "         }\n",
            "         return null;\n"
          ],
          "changed_lines": 38
        },
        {
          "buggy_method": "  protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException {\n  JsonSerializer<?> ser = null;\n  \n  \n  \n  \n  for (Serializers serializers : customSerializers()) { \n  ser = serializers.findCollectionSerializer(config,\n  type, beanDesc, elementTypeSerializer, elementValueSerializer);\n  if (ser != null) {\n  break;\n  }\n  }\n\n  if (ser == null) {\n  \n  \n  JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n  if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {\n  return null;\n  }\n  Class<?> raw = type.getRawClass();\n  if (EnumSet.class.isAssignableFrom(raw)) {\n  \n  JavaType enumType = type.getContentType();\n  \n  if (!enumType.isEnumType()) {\n  enumType = null;\n  }\n  ser = buildEnumSetSerializer(enumType);\n  } else {\n  Class<?> elementRaw = type.getContentType().getRawClass();\n  if (isIndexedList(raw)) {\n  if (elementRaw == String.class) {\n  \n  if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n  ser = IndexedStringListSerializer.instance;\n  }\n  } else {\n  ser = buildIndexedListSerializer(type.getContentType(), staticTyping,\n  elementTypeSerializer, elementValueSerializer);\n  }\n  } else if (elementRaw == String.class) {\n  \n  if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n  ser = StringCollectionSerializer.instance;\n  }\n  }\n  if (ser == null) {\n  ser = buildCollectionSerializer(type.getContentType(), staticTyping,\n  elementTypeSerializer, elementValueSerializer);\n  }\n  }\n  }\n  \n  if (_factoryConfig.hasSerializerModifiers()) {\n  for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n  ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser);\n  }\n  }\n  return ser;\n  }",
          "fixed_method": "  protected JsonSerializer<?> buildCollectionSerializer(SerializerProvider prov, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException {\n  SerializationConfig config = prov.getConfig();\n  JsonSerializer<?> ser = null;\n  \n  \n  \n  \n  for (Serializers serializers : customSerializers()) { \n  ser = serializers.findCollectionSerializer(config,\n  type, beanDesc, elementTypeSerializer, elementValueSerializer);\n  if (ser != null) {\n  break;\n  }\n  }\n\n  if (ser == null) {\n  ser = findSerializerByAnnotations(prov, type, beanDesc); \n  if (ser == null) {\n  \n  \n  JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n  if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {\n  return null;\n  }\n  Class<?> raw = type.getRawClass();\n  if (EnumSet.class.isAssignableFrom(raw)) {\n  \n  JavaType enumType = type.getContentType();\n  \n  if (!enumType.isEnumType()) {\n  enumType = null;\n  }\n  ser = buildEnumSetSerializer(enumType);\n  } else {\n  Class<?> elementRaw = type.getContentType().getRawClass();\n  if (isIndexedList(raw)) {\n  if (elementRaw == String.class) {\n  \n  if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n  ser = IndexedStringListSerializer.instance;\n  }\n  } else {\n  ser = buildIndexedListSerializer(type.getContentType(), staticTyping,\n  elementTypeSerializer, elementValueSerializer);\n  }\n  } else if (elementRaw == String.class) {\n  \n  if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n  ser = StringCollectionSerializer.instance;\n  }\n  }\n  if (ser == null) {\n  ser = buildCollectionSerializer(type.getContentType(), staticTyping,\n  elementTypeSerializer, elementValueSerializer);\n  }\n  }\n  }\n  }\n  \n  if (_factoryConfig.hasSerializerModifiers()) {\n  for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n  ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser);\n  }\n  }\n  return ser;\n  }",
          "diff": [
            "@@ -633,11 +643,12 @@",
            "      * \n",
            "      * @since 2.1\n",
            "      */\n",
            "-    protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config,\n",
            "+    protected JsonSerializer<?> buildCollectionSerializer(SerializerProvider prov,\n",
            "             CollectionType type, BeanDescription beanDesc, boolean staticTyping,\n",
            "             TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) \n",
            "         throws JsonMappingException\n",
            "     {\n",
            "+        SerializationConfig config = prov.getConfig();\n",
            "         JsonSerializer<?> ser = null;\n",
            "         // Order of lookups:\n",
            "         // 1. Custom serializers\n",
            "@@ -652,6 +663,8 @@",
            "         }\n",
            " \n",
            "         if (ser == null) {\n",
            "+            ser = findSerializerByAnnotations(prov, type, beanDesc); // (2) Annotations\n",
            "+            if (ser == null) {\n",
            "                 // We may also want to use serialize Collections \"as beans\", if (and only if)\n",
            "                 // this is specified with `@JsonFormat(shape=Object)`\n",
            "                 JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n",
            "@@ -688,6 +701,7 @@",
            "                     if (ser == null) {\n",
            "                         ser = buildCollectionSerializer(type.getContentType(), staticTyping,\n",
            "                                 elementTypeSerializer, elementValueSerializer);\n",
            "+                    }\n",
            "                 }\n",
            "             }\n",
            "         }\n"
          ],
          "changed_lines": 6
        },
        {
          "buggy_method": "  protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException {\n  JsonSerializer<?> ser = null;\n\n  \n  \n  \n  \n  \n  for (Serializers serializers : customSerializers()) { \n  ser = serializers.findMapSerializer(config, type, beanDesc,\n  keySerializer, elementTypeSerializer, elementValueSerializer);\n  if (ser != null) { break; }\n  }\n  if (ser == null) {\n  \n  \n  Object filterId = findFilterId(config, beanDesc);\n  AnnotationIntrospector ai = config.getAnnotationIntrospector();\n  MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true),\n  type, staticTyping, elementTypeSerializer,\n  keySerializer, elementValueSerializer, filterId);\n  Object suppressableValue = findSuppressableContentValue(config,\n  type.getContentType(), beanDesc);\n  if (suppressableValue != null) {\n  mapSer = mapSer.withContentInclusion(suppressableValue);\n  }\n  ser = mapSer;\n  }\n  \n  if (_factoryConfig.hasSerializerModifiers()) {\n  for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n  ser = mod.modifyMapSerializer(config, type, beanDesc, ser);\n  }\n  }\n  return ser;\n  }\n\n  \n  protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc) throws JsonMappingException {\n  JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null);\n\n  if (incl != null) {\n  switch (incl) {\n  case NON_DEFAULT:\n  \n  incl = JsonInclude.Include.NON_EMPTY;\n  break;\n  default:\n  \n  break;\n  }\n  return incl;\n  }\n  return null;\n  }\n  \n  \n  \n  \n  protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException {\n  \n  \n  \n  \n  JsonSerializer<?> ser = null;\n\n  for (Serializers serializers : customSerializers()) { \n  ser = serializers.findArraySerializer(config,\n  type, beanDesc, elementTypeSerializer, elementValueSerializer);\n  if (ser != null) {\n  break;\n  }\n  }\n  \n  if (ser == null) {\n  Class<?> raw = type.getRawClass();\n  \n  if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n  if (String[].class == raw) {\n  ser = StringArraySerializer.instance;\n  } else {\n  \n  ser = StdArraySerializers.findStandardImpl(raw);\n  }\n  }\n  if (ser == null) {\n  ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer,\n  elementValueSerializer);\n  }\n  }\n  \n  if (_factoryConfig.hasSerializerModifiers()) {\n  for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n  ser = mod.modifyArraySerializer(config, type, beanDesc, ser);\n  }\n  }\n  return ser;\n  }\n\n  \n\n  \n  protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException {\n  return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType));\n  }\n\n  @Deprecated \n  protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {\n  JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class);\n  JavaType vt = (params == null || params.length != 1) ?\n  TypeFactory.unknownType() : params[0];\n  return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt); \n  }\n\n  \n  protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException {\n  return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType));\n  }\n\n  @Deprecated \n  protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {\n  JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class);\n  JavaType vt = (params == null || params.length != 1) ?\n  TypeFactory.unknownType() : params[0];\n  return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); \n  }\n  \n  \n  protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType) throws JsonMappingException {\n  return new MapEntrySerializer(valueType, keyType, valueType,\n  staticTyping, createTypeSerializer(config, valueType), null);\n  }\n\n  protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n  \n  JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n  if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {\n  \n  ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\");\n  \n  return null;\n  }\n  @SuppressWarnings(\"unchecked\")\n  Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass();\n  JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format);\n  \n  if (_factoryConfig.hasSerializerModifiers()) {\n  for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n  ser = mod.modifyEnumSerializer(config, type, beanDesc, ser);\n  }\n  }\n  return ser;\n  }\n\n  \n  \n  \n  @SuppressWarnings(\"unchecked\")\n  protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type) {\n  \n  Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a);\n  if (superclass != null) {\n  try {\n  type = (T) type.widenBy(superclass);\n  } catch (IllegalArgumentException iae) {\n  throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage());\n  }\n  }\n  return modifySecondaryTypesByAnnotation(config, a, type);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) {\n  AnnotationIntrospector intr = config.getAnnotationIntrospector();\n  \n  if (type.isContainerType()) {\n  Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType());\n  if (keyClass != null) {\n  \n  if (!(type instanceof MapType)) {\n  throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\");\n  }\n  try {\n  type = (T) ((MapType) type).widenKey(keyClass);\n  } catch (IllegalArgumentException iae) {\n  throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage());\n  }\n  }\n  \n  \n  Class<?> cc = intr.findSerializationContentType(a, type.getContentType());\n  if (cc != null) {\n  try {\n  type = (T) type.widenContentsBy(cc);\n  } catch (IllegalArgumentException iae) {\n  throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage());\n  }\n  }\n  }\n  return type;\n  }\n\n  \n  protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException {\n  AnnotationIntrospector intr = prov.getAnnotationIntrospector();\n  Object serDef = intr.findKeySerializer(a);\n  if (serDef != null) {\n  return prov.serializerInstance(a, serDef);\n  }\n  return null;\n  }\n\n  \n  protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException {\n  AnnotationIntrospector intr = prov.getAnnotationIntrospector();\n  Object serDef = intr.findContentSerializer(a);\n  if (serDef != null) {\n  return prov.serializerInstance(a, serDef);\n  }\n  return null;\n  }\n\n  \n  protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) {\n  return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo());\n  }\n\n  \n  protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) {\n  \n  if (typeSer != null) {\n  return false;\n  }\n  AnnotationIntrospector intr = config.getAnnotationIntrospector();\n  JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo());\n  if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) {\n  return (t == JsonSerialize.Typing.STATIC);\n  }\n  return config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n  }\n\n  protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) {\n  if (src == null) {\n  return null;\n  }\n  if (!(src instanceof Class)) {\n  throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\");\n  }\n  Class<?> cls = (Class<?>) src;\n  if (cls == noneClass || ClassUtil.isBogusClass(cls)) {\n  return null;\n  }\n  return cls;\n  }\n}",
          "fixed_method": "  protected JsonSerializer<?> buildMapSerializer(SerializerProvider prov, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException {\n  final SerializationConfig config = prov.getConfig();\n  JsonSerializer<?> ser = null;\n\n  \n  \n  \n  \n  \n  for (Serializers serializers : customSerializers()) { \n  ser = serializers.findMapSerializer(config, type, beanDesc,\n  keySerializer, elementTypeSerializer, elementValueSerializer);\n  if (ser != null) { break; }\n  }\n  if (ser == null) {\n  ser = findSerializerByAnnotations(prov, type, beanDesc); \n  if (ser == null) {\n  \n  \n  Object filterId = findFilterId(config, beanDesc);\n  AnnotationIntrospector ai = config.getAnnotationIntrospector();\n  MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true),\n  type, staticTyping, elementTypeSerializer,\n  keySerializer, elementValueSerializer, filterId);\n  Object suppressableValue = findSuppressableContentValue(config,\n  type.getContentType(), beanDesc);\n  if (suppressableValue != null) {\n  mapSer = mapSer.withContentInclusion(suppressableValue);\n  }\n  ser = mapSer;\n  }\n  }\n  \n  if (_factoryConfig.hasSerializerModifiers()) {\n  for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n  ser = mod.modifyMapSerializer(config, type, beanDesc, ser);\n  }\n  }\n  return ser;\n  }\n\n  \n  protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc) throws JsonMappingException {\n  JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null);\n\n  if (incl != null) {\n  switch (incl) {\n  case NON_DEFAULT:\n  \n  incl = JsonInclude.Include.NON_EMPTY;\n  break;\n  default:\n  \n  break;\n  }\n  return incl;\n  }\n  return null;\n  }\n  \n  \n  \n  \n  protected JsonSerializer<?> buildArraySerializer(SerializerProvider prov, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException {\n  \n  \n  \n  \n  SerializationConfig config = prov.getConfig();\n  JsonSerializer<?> ser = null;\n\n  for (Serializers serializers : customSerializers()) { \n  ser = serializers.findArraySerializer(config,\n  type, beanDesc, elementTypeSerializer, elementValueSerializer);\n  if (ser != null) {\n  break;\n  }\n  }\n  \n  if (ser == null) {\n  Class<?> raw = type.getRawClass();\n  \n  if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n  if (String[].class == raw) {\n  ser = StringArraySerializer.instance;\n  } else {\n  \n  ser = StdArraySerializers.findStandardImpl(raw);\n  }\n  }\n  if (ser == null) {\n  ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer,\n  elementValueSerializer);\n  }\n  }\n  \n  if (_factoryConfig.hasSerializerModifiers()) {\n  for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n  ser = mod.modifyArraySerializer(config, type, beanDesc, ser);\n  }\n  }\n  return ser;\n  }\n\n  \n\n  \n  protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException {\n  return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType));\n  }\n\n  @Deprecated \n  protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {\n  JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class);\n  JavaType vt = (params == null || params.length != 1) ?\n  TypeFactory.unknownType() : params[0];\n  return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt); \n  }\n\n  \n  protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException {\n  return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType));\n  }\n\n  @Deprecated \n  protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {\n  JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class);\n  JavaType vt = (params == null || params.length != 1) ?\n  TypeFactory.unknownType() : params[0];\n  return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); \n  }\n  \n  \n  protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType) throws JsonMappingException {\n  return new MapEntrySerializer(valueType, keyType, valueType,\n  staticTyping, createTypeSerializer(config, valueType), null);\n  }\n\n  protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n  \n  JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n  if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {\n  \n  ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\");\n  \n  return null;\n  }\n  @SuppressWarnings(\"unchecked\")\n  Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass();\n  JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format);\n  \n  if (_factoryConfig.hasSerializerModifiers()) {\n  for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n  ser = mod.modifyEnumSerializer(config, type, beanDesc, ser);\n  }\n  }\n  return ser;\n  }\n\n  \n  \n  \n  @SuppressWarnings(\"unchecked\")\n  protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type) {\n  \n  Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a);\n  if (superclass != null) {\n  try {\n  type = (T) type.widenBy(superclass);\n  } catch (IllegalArgumentException iae) {\n  throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage());\n  }\n  }\n  return modifySecondaryTypesByAnnotation(config, a, type);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) {\n  AnnotationIntrospector intr = config.getAnnotationIntrospector();\n  \n  if (type.isContainerType()) {\n  Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType());\n  if (keyClass != null) {\n  \n  if (!(type instanceof MapType)) {\n  throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\");\n  }\n  try {\n  type = (T) ((MapType) type).widenKey(keyClass);\n  } catch (IllegalArgumentException iae) {\n  throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage());\n  }\n  }\n  \n  \n  Class<?> cc = intr.findSerializationContentType(a, type.getContentType());\n  if (cc != null) {\n  try {\n  type = (T) type.widenContentsBy(cc);\n  } catch (IllegalArgumentException iae) {\n  throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage());\n  }\n  }\n  }\n  return type;\n  }\n\n  \n  protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException {\n  AnnotationIntrospector intr = prov.getAnnotationIntrospector();\n  Object serDef = intr.findKeySerializer(a);\n  if (serDef != null) {\n  return prov.serializerInstance(a, serDef);\n  }\n  return null;\n  }\n\n  \n  protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException {\n  AnnotationIntrospector intr = prov.getAnnotationIntrospector();\n  Object serDef = intr.findContentSerializer(a);\n  if (serDef != null) {\n  return prov.serializerInstance(a, serDef);\n  }\n  return null;\n  }\n\n  \n  protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) {\n  return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo());\n  }\n\n  \n  protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) {\n  \n  if (typeSer != null) {\n  return false;\n  }\n  AnnotationIntrospector intr = config.getAnnotationIntrospector();\n  JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo());\n  if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) {\n  return (t == JsonSerialize.Typing.STATIC);\n  }\n  return config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n  }\n\n  protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) {\n  if (src == null) {\n  return null;\n  }\n  if (!(src instanceof Class)) {\n  throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\");\n  }\n  Class<?> cls = (Class<?>) src;\n  if (cls == noneClass || ClassUtil.isBogusClass(cls)) {\n  return null;\n  }\n  return cls;\n  }\n}",
          "diff": [
            "@@ -734,12 +748,13 @@",
            "      * Helper method that handles configuration details when constructing serializers for\n",
            "      * {@link java.util.Map} types.\n",
            "      */\n",
            "-    protected JsonSerializer<?> buildMapSerializer(SerializationConfig config,\n",
            "+    protected JsonSerializer<?> buildMapSerializer(SerializerProvider prov,\n",
            "             MapType type, BeanDescription beanDesc,\n",
            "             boolean staticTyping, JsonSerializer<Object> keySerializer,\n",
            "             TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n",
            "         throws JsonMappingException\n",
            "     {\n",
            "+        final SerializationConfig config = prov.getConfig();\n",
            "         JsonSerializer<?> ser = null;\n",
            " \n",
            "         // Order of lookups:\n",
            "@@ -753,6 +768,8 @@",
            "             if (ser != null) { break; }\n",
            "         }\n",
            "         if (ser == null) {\n",
            "+            ser = findSerializerByAnnotations(prov, type, beanDesc); // (2) Annotations\n",
            "+            if (ser == null) {\n",
            "                 // 08-Nov-2014, tatu: As per [databind#601], better just use default Map serializer\n",
            "                 /*\n",
            "                 if (EnumMap.class.isAssignableFrom(type.getRawClass())\n",
            "@@ -781,6 +798,7 @@",
            "                 }\n",
            "                 ser = mapSer;\n",
            "             }\n",
            "+        }\n",
            "         // [databind#120]: Allow post-processing\n",
            "         if (_factoryConfig.hasSerializerModifiers()) {\n",
            "             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n"
          ],
          "changed_lines": 6
        },
        {
          "buggy_method": "  protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException {\n  \n  \n  \n  \n  JsonSerializer<?> ser = null;\n\n  for (Serializers serializers : customSerializers()) { \n  ser = serializers.findArraySerializer(config,\n  type, beanDesc, elementTypeSerializer, elementValueSerializer);\n  if (ser != null) {\n  break;\n  }\n  }\n  \n  if (ser == null) {\n  Class<?> raw = type.getRawClass();\n  \n  if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n  if (String[].class == raw) {\n  ser = StringArraySerializer.instance;\n  } else {\n  \n  ser = StdArraySerializers.findStandardImpl(raw);\n  }\n  }\n  if (ser == null) {\n  ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer,\n  elementValueSerializer);\n  }\n  }\n  \n  if (_factoryConfig.hasSerializerModifiers()) {\n  for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n  ser = mod.modifyArraySerializer(config, type, beanDesc, ser);\n  }\n  }\n  return ser;\n  }",
          "fixed_method": "  protected JsonSerializer<?> buildArraySerializer(SerializerProvider prov, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException {\n  \n  \n  \n  \n  SerializationConfig config = prov.getConfig();\n  JsonSerializer<?> ser = null;\n\n  for (Serializers serializers : customSerializers()) { \n  ser = serializers.findArraySerializer(config,\n  type, beanDesc, elementTypeSerializer, elementValueSerializer);\n  if (ser != null) {\n  break;\n  }\n  }\n  \n  if (ser == null) {\n  Class<?> raw = type.getRawClass();\n  \n  if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n  if (String[].class == raw) {\n  ser = StringArraySerializer.instance;\n  } else {\n  \n  ser = StdArraySerializers.findStandardImpl(raw);\n  }\n  }\n  if (ser == null) {\n  ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer,\n  elementValueSerializer);\n  }\n  }\n  \n  if (_factoryConfig.hasSerializerModifiers()) {\n  for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n  ser = mod.modifyArraySerializer(config, type, beanDesc, ser);\n  }\n  }\n  return ser;\n  }",
          "diff": [
            "@@ -828,7 +846,7 @@",
            "      * Helper method that handles configuration details when constructing serializers for\n",
            "      * <code>Object[]</code> (and subtypes, except for String).\n",
            "      */\n",
            "-    protected JsonSerializer<?> buildArraySerializer(SerializationConfig config,\n",
            "+    protected JsonSerializer<?> buildArraySerializer(SerializerProvider prov,\n",
            "             ArrayType type, BeanDescription beanDesc,\n",
            "             boolean staticTyping,\n",
            "             TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n",
            "@@ -838,6 +856,7 @@",
            "         //   types can not be annotated (in theory I guess we could have mix-ins but... ?)\n",
            "         //   so we need not do primary annotation lookup here.\n",
            "         //   So all we need is (1) Custom, (2) Default array serializers\n",
            "+        SerializationConfig config = prov.getConfig();\n",
            "         JsonSerializer<?> ser = null;\n",
            " \n",
            "         for (Serializers serializers : customSerializers()) { // (1) Custom\n"
          ],
          "changed_lines": 3
        }
      ]
    },
    {
      "name": "com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.ser;\n\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerators;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo.As;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.ser.impl.FilteredBeanPropertyWriter;\nimport com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\nimport com.fasterxml.jackson.databind.ser.impl.PropertyBasedObjectIdGenerator;\nimport com.fasterxml.jackson.databind.ser.std.MapSerializer;\nimport com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.Converter;\n\n\npublic class BeanSerializerFactory extends BasicSerializerFactory implements java.io.Serializable { private static final long serialVersionUID = 1; public final static BeanSerializerFactory instance = new BeanSerializerFactory(null); protected BeanSerializerFactory(SerializerFactoryConfig config) {\n        super(config);\n    }\n    \n    \n    @Override\n    public SerializerFactory withConfig(SerializerFactoryConfig config) {\n        if (_factoryConfig == config) {\n            return this;\n        }\n        \n        if (getClass() != BeanSerializerFactory.class) {\n            throw new IllegalStateException(\"Subtype of BeanSerializerFactory (\"+getClass().getName()\n                    +\") has not properly overridden method 'withAdditionalSerializers': can not instantiate subtype with \"\n                    +\"additional serializer definitions\");\n        }\n        return new BeanSerializerFactory(config);\n    }\n\n    @Override\n    protected Iterable<Serializers> customSerializers() {\n        return _factoryConfig.serializers();\n    }\n    \n    \n\n    \n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n        \n        final SerializationConfig config = prov.getConfig();\n        BeanDescription beanDesc = config.introspect(origType);\n        JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        if (ser != null) {\n            return (JsonSerializer<Object>) ser;\n        }\n        boolean staticTyping;\n        \n        JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n        if (type == origType) { \n            staticTyping = false;\n        } else { \n            staticTyping = true;\n            if (!type.hasRawClass(origType.getRawClass())) {\n                beanDesc = config.introspect(type);\n            }\n        }\n        \n        Converter<Object,Object> conv = beanDesc.findSerializationConverter();\n        if (conv == null) { \n            return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n        }\n        JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n        \n        \n        if (!delegateType.hasRawClass(type.getRawClass())) {\n            beanDesc = config.introspect(delegateType);\n            \n            ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        }\n        \n        if (ser == null && !delegateType.isJavaLangObject()) {\n            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n        }\n        return new StdDelegatingSerializer(conv, delegateType, ser);\n    }\n\n    protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {\n        JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc);\n        if (ser != null) {\n            return ser;\n        }\n        final SerializationConfig config = prov.getConfig();\n        \n        \n        \n        if (type.isContainerType()) {\n            if (!staticTyping) {\n                staticTyping = usesStaticTyping(config, beanDesc, null);\n                \n                \n                \n            }\n            \n            ser =  buildContainerSerializer(prov, type, beanDesc, staticTyping);\n            \n            if (ser != null) {\n                return ser;\n            }\n        } else {\n            \n            for (Serializers serializers : customSerializers()) {\n                ser = serializers.findSerializer(config, type, beanDesc);\n                if (ser != null) {\n                    break;\n                }\n            }\n            \n            \n        }\n        \n        if (ser == null) {\n            \n            \n            \n            ser = findSerializerByLookup(type, config, beanDesc, staticTyping);\n            if (ser == null) {\n                ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n                if (ser == null) {\n                    \n                    \n                    \n                    ser = findBeanSerializer(prov, type, beanDesc);\n                    \n                    if (ser == null) {\n                        ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);\n                        \n                        \n                        \n                        if (ser == null) {\n                            ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass());\n                        }\n                    }\n                }\n            }\n        }\n        if (ser != null) {\n            \n            if (_factoryConfig.hasSerializerModifiers()) {\n                for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                    ser = mod.modifySerializer(config, beanDesc, ser);\n                }\n            }\n        }\n        return ser;\n    }\n    \n    \n\n    \n    public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        \n        if (!isPotentialBeanType(type.getRawClass())) {\n            \n            \n            if (!type.isEnumType()) {\n                return null;\n            }\n        }\n        return constructBeanSerializer(prov, beanDesc);\n    }\n\n    \n    public TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, accessor, baseType);        \n        TypeSerializer typeSer;\n\n        \n        if (b == null) {\n            typeSer = createTypeSerializer(config, baseType);\n        } else {\n            Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(\n                    config, accessor, baseType);\n            typeSer = b.buildTypeSerializer(config, baseType, subtypes);\n        }\n        return typeSer;\n    }\n\n        \n    public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException {\n        JavaType contentType = containerType.getContentType();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, accessor, containerType);        \n        TypeSerializer typeSer;\n\n        \n        if (b == null) {\n            typeSer = createTypeSerializer(config, contentType);\n        } else {\n            Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config,\n                    accessor, contentType);\n            typeSer = b.buildTypeSerializer(config, contentType, subtypes);\n        }\n        return typeSer;\n    }\n\n    \n\n    \n    @SuppressWarnings(\"unchecked\")\n    protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n        \n        \n        if (beanDesc.getBeanClass() == Object.class) {\n            return prov.getUnknownTypeSerializer(Object.class);\n\n        }\n        final SerializationConfig config = prov.getConfig();\n        BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n        builder.setConfig(config);\n\n        \n        List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n        if (props == null) {\n            props = new ArrayList<BeanPropertyWriter>();\n        } else {\n            props = removeOverlappingTypeIds(prov, beanDesc, builder, props);\n        }\n        \n        \n        prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n\n        \n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                props = mod.changeProperties(config, beanDesc, props);\n            }\n        }\n\n        \n        props = filterBeanProperties(config, beanDesc, props);\n\n        \n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                props = mod.orderProperties(config, beanDesc, props);\n            }\n        }\n\n        \n        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n        \n        builder.setProperties(props);\n        builder.setFilterId(findFilterId(config, beanDesc));\n        \n        AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n        if (anyGetter != null) {\n            if (config.canOverrideAccessModifiers()) {\n                anyGetter.fixAccess();\n            }\n            JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n            \n            boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n            JavaType valueType = type.getContentType();\n            TypeSerializer typeSer = createTypeSerializer(config, valueType);\n            \n            \n            JsonSerializer<?> anySer = findSerializerFromAnnotation(prov, anyGetter);\n            if (anySer == null) {\n                \n                anySer = MapSerializer.construct( null, type, staticTyping,\n                        typeSer, null, null,  null);\n            }\n            \n            PropertyName name = PropertyName.construct(anyGetter.getName());\n            BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null,\n                    beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n            builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n        }\n        \n        processViews(config, builder);\n\n        \n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        \n        JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n        \n        if (ser == null) {\n            \n            \n            \n            if (beanDesc.hasKnownClassAnnotations()) {\n                return builder.createDummy();\n            }\n        }\n        return ser;\n    }\n\n    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props) throws JsonMappingException {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        \n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { \n            String propName = objectIdInfo.getPropertyName().getSimpleName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    \n                    if (i > 0) {\n                        props.remove(i);\n                        props.add(0, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            \n            return ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        \n        JavaType type = prov.constructType(implClass);\n        \n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }\n\n    \n    protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer, Class<?>[] inViews) {\n        return FilteredBeanPropertyWriter.constructViewBased(writer, inViews);\n    }\n    \n    protected PropertyBuilder constructPropertyBuilder(SerializationConfig config, BeanDescription beanDesc) {\n        return new PropertyBuilder(config, beanDesc);\n    }\n\n    protected BeanSerializerBuilder constructBeanSerializerBuilder(BeanDescription beanDesc) {\n        return new BeanSerializerBuilder(beanDesc);\n    }\n    \n    \n    \n    \n    protected boolean isPotentialBeanType(Class<?> type) {\n        return (ClassUtil.canBeABeanType(type) == null) && !ClassUtil.isProxyType(type);\n    }\n\n    \n    protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException {\n        List<BeanPropertyDefinition> properties = beanDesc.findProperties();\n        final SerializationConfig config = prov.getConfig();\n\n        \n        removeIgnorableTypes(config, beanDesc, properties);\n        \n        \n        if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) {\n            removeSetterlessGetters(config, beanDesc, properties);\n        }\n        \n        \n        if (properties.isEmpty()) {\n            return null;\n        }\n        \n        boolean staticTyping = usesStaticTyping(config, beanDesc, null);\n        PropertyBuilder pb = constructPropertyBuilder(config, beanDesc);\n        \n        ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size());\n        TypeBindings typeBind = beanDesc.bindingsForBeanType();\n        for (BeanPropertyDefinition property : properties) {\n            final AnnotatedMember accessor = property.getAccessor();\n            \n            if (property.isTypeId()) {\n                if (accessor != null) { \n                    if (config.canOverrideAccessModifiers()) {\n                        accessor.fixAccess();\n                    }\n                    builder.setTypeId(accessor);\n                }\n                continue;\n            }\n            \n            AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType();\n            if (refType != null && refType.isBackReference()) {\n                continue;\n            }\n            if (accessor instanceof AnnotatedMethod) {\n                result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor));\n            } else {\n                result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor));\n            }\n        }\n        return result;\n    }\n\n    \n    \n    \n    protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> props) {\n        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n        AnnotatedClass ac = beanDesc.getClassInfo();\n        String[] ignored = intr.findPropertiesToIgnore(ac, true);\n        if (ignored != null && ignored.length > 0) {\n            HashSet<String> ignoredSet = ArrayBuilders.arrayToSet(ignored);\n            Iterator<BeanPropertyWriter> it = props.iterator();\n            while (it.hasNext()) {\n                if (ignoredSet.contains(it.next().getName())) {\n                    it.remove();\n                }\n            }\n        }\n        return props;\n    }\n\n    \n    protected void processViews(SerializationConfig config, BeanSerializerBuilder builder) {\n        \n        List<BeanPropertyWriter> props = builder.getProperties();\n        boolean includeByDefault = config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION);\n        final int propCount = props.size();\n        int viewsFound = 0;\n        BeanPropertyWriter[] filtered = new BeanPropertyWriter[propCount];\n        \n        for (int i = 0; i < propCount; ++i) {\n            BeanPropertyWriter bpw = props.get(i);\n            Class<?>[] views = bpw.getViews();\n            if (views == null) { \n                if (includeByDefault) {\n                    filtered[i] = bpw;\n                }\n            } else {\n                ++viewsFound;\n                filtered[i] = constructFilteredBeanWriter(bpw, views);\n            }\n        }\n        \n        if (includeByDefault && viewsFound == 0) {\n            return;\n        }\n        builder.setFilteredProperties(filtered);\n    }\n\n    \n    protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties) {\n        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n        HashMap<Class<?>,Boolean> ignores = new HashMap<Class<?>,Boolean>();\n        Iterator<BeanPropertyDefinition> it = properties.iterator();\n        while (it.hasNext()) {\n            BeanPropertyDefinition property = it.next();\n            AnnotatedMember accessor = property.getAccessor();\n            if (accessor == null) {\n                it.remove();\n                continue;\n            }\n            Class<?> type = accessor.getRawType();\n            Boolean result = ignores.get(type);\n            if (result == null) {\n                BeanDescription desc = config.introspectClassAnnotations(type);\n                AnnotatedClass ac = desc.getClassInfo();\n                result = intr.isIgnorableType(ac);\n                \n                if (result == null) {\n                    result = Boolean.FALSE;\n                }\n                ignores.put(type, result);\n            }\n            \n            if (result.booleanValue()) {\n                it.remove();\n            }\n        }\n    }\n\n    \n    protected void removeSetterlessGetters(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties) {\n        Iterator<BeanPropertyDefinition> it = properties.iterator();\n        while (it.hasNext()) {\n            BeanPropertyDefinition property = it.next();\n            \n            \n            if (!property.couldDeserialize() && !property.isExplicitlyIncluded()) {\n                it.remove();\n            }\n        }\n    }\n\n    \n    protected List<BeanPropertyWriter> removeOverlappingTypeIds(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder, List<BeanPropertyWriter> props) {\n        for (int i = 0, end = props.size(); i < end; ++i) {\n            BeanPropertyWriter bpw = props.get(i);\n            TypeSerializer td = bpw.getTypeSerializer();\n            if ((td == null) || (td.getTypeInclusion() != As.EXTERNAL_PROPERTY)) {\n                continue;\n            }\n            String n = td.getPropertyName();\n            PropertyName typePropName = PropertyName.construct(n);\n\n            for (BeanPropertyWriter w2 : props) {\n                if ((w2 != bpw) && w2.wouldConflictWithName(typePropName)) {\n                    bpw.assignTypeSerializer(null);\n                    break;\n                }\n            }\n        }\n        return props;\n    }\n    \n    \n\n    \n    protected BeanPropertyWriter _constructWriter(SerializerProvider prov, BeanPropertyDefinition propDef, TypeBindings typeContext, PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor) throws JsonMappingException {\n        final PropertyName name = propDef.getFullName();\n        if (prov.canOverrideAccessModifiers()) {\n            accessor.fixAccess();\n        }\n        JavaType type = accessor.getType(typeContext);\n        BeanProperty.Std property = new BeanProperty.Std(name, type, propDef.getWrapperName(),\n                pb.getClassAnnotations(), accessor, propDef.getMetadata());\n\n        \n        JsonSerializer<?> annotatedSerializer = findSerializerFromAnnotation(prov,\n                accessor);\n        \n        if (annotatedSerializer instanceof ResolvableSerializer) {\n            ((ResolvableSerializer) annotatedSerializer).resolve(prov);\n        }\n        \n        annotatedSerializer = prov.handlePrimaryContextualization(annotatedSerializer, property);\n        \n        TypeSerializer contentTypeSer = null;\n        \n        if (ClassUtil.isCollectionMapOrArray(type.getRawClass())\n                || type.isCollectionLikeType() || type.isMapLikeType()) {\n            contentTypeSer = findPropertyContentTypeSerializer(type, prov.getConfig(), accessor);\n        }\n        \n        TypeSerializer typeSer = findPropertyTypeSerializer(type, prov.getConfig(), accessor);\n        BeanPropertyWriter pbw = pb.buildWriter(prov, propDef, type, annotatedSerializer,\n                        typeSer, contentTypeSer, accessor, staticTyping);\n        return pbw;\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.ser;\n\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerators;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo.As;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.ser.impl.FilteredBeanPropertyWriter;\nimport com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\nimport com.fasterxml.jackson.databind.ser.impl.PropertyBasedObjectIdGenerator;\nimport com.fasterxml.jackson.databind.ser.std.MapSerializer;\nimport com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.Converter;\n\n\npublic class BeanSerializerFactory extends BasicSerializerFactory implements java.io.Serializable { private static final long serialVersionUID = 1; public final static BeanSerializerFactory instance = new BeanSerializerFactory(null); protected BeanSerializerFactory(SerializerFactoryConfig config) {\n        super(config);\n    }\n    \n    \n    @Override\n    public SerializerFactory withConfig(SerializerFactoryConfig config) {\n        if (_factoryConfig == config) {\n            return this;\n        }\n        \n        if (getClass() != BeanSerializerFactory.class) {\n            throw new IllegalStateException(\"Subtype of BeanSerializerFactory (\"+getClass().getName()\n                    +\") has not properly overridden method 'withAdditionalSerializers': can not instantiate subtype with \"\n                    +\"additional serializer definitions\");\n        }\n        return new BeanSerializerFactory(config);\n    }\n\n    @Override\n    protected Iterable<Serializers> customSerializers() {\n        return _factoryConfig.serializers();\n    }\n    \n    \n\n    \n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n        \n        final SerializationConfig config = prov.getConfig();\n        BeanDescription beanDesc = config.introspect(origType);\n        JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        if (ser != null) {\n            return (JsonSerializer<Object>) ser;\n        }\n        boolean staticTyping;\n        \n        JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n        if (type == origType) { \n            staticTyping = false;\n        } else { \n            staticTyping = true;\n            if (!type.hasRawClass(origType.getRawClass())) {\n                beanDesc = config.introspect(type);\n            }\n        }\n        \n        Converter<Object,Object> conv = beanDesc.findSerializationConverter();\n        if (conv == null) { \n            return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n        }\n        JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n        \n        \n        if (!delegateType.hasRawClass(type.getRawClass())) {\n            beanDesc = config.introspect(delegateType);\n            \n            ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        }\n        \n        if (ser == null && !delegateType.isJavaLangObject()) {\n            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n        }\n        return new StdDelegatingSerializer(conv, delegateType, ser);\n    }\n\n    protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {\n        JsonSerializer<?> ser = null;\n        final SerializationConfig config = prov.getConfig();\n        \n        \n        \n        if (type.isContainerType()) {\n            if (!staticTyping) {\n                staticTyping = usesStaticTyping(config, beanDesc, null);\n                \n                \n                \n            }\n            \n            ser =  buildContainerSerializer(prov, type, beanDesc, staticTyping);\n            \n            if (ser != null) {\n                return ser;\n            }\n        } else {\n            \n            for (Serializers serializers : customSerializers()) {\n                ser = serializers.findSerializer(config, type, beanDesc);\n                if (ser != null) {\n                    break;\n                }\n            }\n            \n            \n            if (ser == null) {\n                ser = findSerializerByAnnotations(prov, type, beanDesc);\n            }\n        }\n        \n        if (ser == null) {\n            \n            \n            \n            ser = findSerializerByLookup(type, config, beanDesc, staticTyping);\n            if (ser == null) {\n                ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n                if (ser == null) {\n                    \n                    \n                    \n                    ser = findBeanSerializer(prov, type, beanDesc);\n                    \n                    if (ser == null) {\n                        ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);\n                        \n                        \n                        \n                        if (ser == null) {\n                            ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass());\n                        }\n                    }\n                }\n            }\n        }\n        if (ser != null) {\n            \n            if (_factoryConfig.hasSerializerModifiers()) {\n                for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                    ser = mod.modifySerializer(config, beanDesc, ser);\n                }\n            }\n        }\n        return ser;\n    }\n    \n    \n\n    \n    public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        \n        if (!isPotentialBeanType(type.getRawClass())) {\n            \n            \n            if (!type.isEnumType()) {\n                return null;\n            }\n        }\n        return constructBeanSerializer(prov, beanDesc);\n    }\n\n    \n    public TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, accessor, baseType);        \n        TypeSerializer typeSer;\n\n        \n        if (b == null) {\n            typeSer = createTypeSerializer(config, baseType);\n        } else {\n            Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(\n                    config, accessor, baseType);\n            typeSer = b.buildTypeSerializer(config, baseType, subtypes);\n        }\n        return typeSer;\n    }\n\n        \n    public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException {\n        JavaType contentType = containerType.getContentType();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, accessor, containerType);        \n        TypeSerializer typeSer;\n\n        \n        if (b == null) {\n            typeSer = createTypeSerializer(config, contentType);\n        } else {\n            Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config,\n                    accessor, contentType);\n            typeSer = b.buildTypeSerializer(config, contentType, subtypes);\n        }\n        return typeSer;\n    }\n\n    \n\n    \n    @SuppressWarnings(\"unchecked\")\n    protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n        \n        \n        if (beanDesc.getBeanClass() == Object.class) {\n            return prov.getUnknownTypeSerializer(Object.class);\n\n        }\n        final SerializationConfig config = prov.getConfig();\n        BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n        builder.setConfig(config);\n\n        \n        List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n        if (props == null) {\n            props = new ArrayList<BeanPropertyWriter>();\n        } else {\n            props = removeOverlappingTypeIds(prov, beanDesc, builder, props);\n        }\n        \n        \n        prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n\n        \n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                props = mod.changeProperties(config, beanDesc, props);\n            }\n        }\n\n        \n        props = filterBeanProperties(config, beanDesc, props);\n\n        \n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                props = mod.orderProperties(config, beanDesc, props);\n            }\n        }\n\n        \n        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n        \n        builder.setProperties(props);\n        builder.setFilterId(findFilterId(config, beanDesc));\n        \n        AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n        if (anyGetter != null) {\n            if (config.canOverrideAccessModifiers()) {\n                anyGetter.fixAccess();\n            }\n            JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n            \n            boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n            JavaType valueType = type.getContentType();\n            TypeSerializer typeSer = createTypeSerializer(config, valueType);\n            \n            \n            JsonSerializer<?> anySer = findSerializerFromAnnotation(prov, anyGetter);\n            if (anySer == null) {\n                \n                anySer = MapSerializer.construct( null, type, staticTyping,\n                        typeSer, null, null,  null);\n            }\n            \n            PropertyName name = PropertyName.construct(anyGetter.getName());\n            BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null,\n                    beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n            builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n        }\n        \n        processViews(config, builder);\n\n        \n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        \n        JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n        \n        if (ser == null) {\n            \n            \n            \n            if (beanDesc.hasKnownClassAnnotations()) {\n                return builder.createDummy();\n            }\n        }\n        return ser;\n    }\n\n    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props) throws JsonMappingException {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        \n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { \n            String propName = objectIdInfo.getPropertyName().getSimpleName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    \n                    if (i > 0) {\n                        props.remove(i);\n                        props.add(0, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            \n            return ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        \n        JavaType type = prov.constructType(implClass);\n        \n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }\n\n    \n    protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer, Class<?>[] inViews) {\n        return FilteredBeanPropertyWriter.constructViewBased(writer, inViews);\n    }\n    \n    protected PropertyBuilder constructPropertyBuilder(SerializationConfig config, BeanDescription beanDesc) {\n        return new PropertyBuilder(config, beanDesc);\n    }\n\n    protected BeanSerializerBuilder constructBeanSerializerBuilder(BeanDescription beanDesc) {\n        return new BeanSerializerBuilder(beanDesc);\n    }\n    \n    \n    \n    \n    protected boolean isPotentialBeanType(Class<?> type) {\n        return (ClassUtil.canBeABeanType(type) == null) && !ClassUtil.isProxyType(type);\n    }\n\n    \n    protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException {\n        List<BeanPropertyDefinition> properties = beanDesc.findProperties();\n        final SerializationConfig config = prov.getConfig();\n\n        \n        removeIgnorableTypes(config, beanDesc, properties);\n        \n        \n        if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) {\n            removeSetterlessGetters(config, beanDesc, properties);\n        }\n        \n        \n        if (properties.isEmpty()) {\n            return null;\n        }\n        \n        boolean staticTyping = usesStaticTyping(config, beanDesc, null);\n        PropertyBuilder pb = constructPropertyBuilder(config, beanDesc);\n        \n        ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size());\n        TypeBindings typeBind = beanDesc.bindingsForBeanType();\n        for (BeanPropertyDefinition property : properties) {\n            final AnnotatedMember accessor = property.getAccessor();\n            \n            if (property.isTypeId()) {\n                if (accessor != null) { \n                    if (config.canOverrideAccessModifiers()) {\n                        accessor.fixAccess();\n                    }\n                    builder.setTypeId(accessor);\n                }\n                continue;\n            }\n            \n            AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType();\n            if (refType != null && refType.isBackReference()) {\n                continue;\n            }\n            if (accessor instanceof AnnotatedMethod) {\n                result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor));\n            } else {\n                result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor));\n            }\n        }\n        return result;\n    }\n\n    \n    \n    \n    protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> props) {\n        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n        AnnotatedClass ac = beanDesc.getClassInfo();\n        String[] ignored = intr.findPropertiesToIgnore(ac, true);\n        if (ignored != null && ignored.length > 0) {\n            HashSet<String> ignoredSet = ArrayBuilders.arrayToSet(ignored);\n            Iterator<BeanPropertyWriter> it = props.iterator();\n            while (it.hasNext()) {\n                if (ignoredSet.contains(it.next().getName())) {\n                    it.remove();\n                }\n            }\n        }\n        return props;\n    }\n\n    \n    protected void processViews(SerializationConfig config, BeanSerializerBuilder builder) {\n        \n        List<BeanPropertyWriter> props = builder.getProperties();\n        boolean includeByDefault = config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION);\n        final int propCount = props.size();\n        int viewsFound = 0;\n        BeanPropertyWriter[] filtered = new BeanPropertyWriter[propCount];\n        \n        for (int i = 0; i < propCount; ++i) {\n            BeanPropertyWriter bpw = props.get(i);\n            Class<?>[] views = bpw.getViews();\n            if (views == null) { \n                if (includeByDefault) {\n                    filtered[i] = bpw;\n                }\n            } else {\n                ++viewsFound;\n                filtered[i] = constructFilteredBeanWriter(bpw, views);\n            }\n        }\n        \n        if (includeByDefault && viewsFound == 0) {\n            return;\n        }\n        builder.setFilteredProperties(filtered);\n    }\n\n    \n    protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties) {\n        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n        HashMap<Class<?>,Boolean> ignores = new HashMap<Class<?>,Boolean>();\n        Iterator<BeanPropertyDefinition> it = properties.iterator();\n        while (it.hasNext()) {\n            BeanPropertyDefinition property = it.next();\n            AnnotatedMember accessor = property.getAccessor();\n            if (accessor == null) {\n                it.remove();\n                continue;\n            }\n            Class<?> type = accessor.getRawType();\n            Boolean result = ignores.get(type);\n            if (result == null) {\n                BeanDescription desc = config.introspectClassAnnotations(type);\n                AnnotatedClass ac = desc.getClassInfo();\n                result = intr.isIgnorableType(ac);\n                \n                if (result == null) {\n                    result = Boolean.FALSE;\n                }\n                ignores.put(type, result);\n            }\n            \n            if (result.booleanValue()) {\n                it.remove();\n            }\n        }\n    }\n\n    \n    protected void removeSetterlessGetters(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties) {\n        Iterator<BeanPropertyDefinition> it = properties.iterator();\n        while (it.hasNext()) {\n            BeanPropertyDefinition property = it.next();\n            \n            \n            if (!property.couldDeserialize() && !property.isExplicitlyIncluded()) {\n                it.remove();\n            }\n        }\n    }\n\n    \n    protected List<BeanPropertyWriter> removeOverlappingTypeIds(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder, List<BeanPropertyWriter> props) {\n        for (int i = 0, end = props.size(); i < end; ++i) {\n            BeanPropertyWriter bpw = props.get(i);\n            TypeSerializer td = bpw.getTypeSerializer();\n            if ((td == null) || (td.getTypeInclusion() != As.EXTERNAL_PROPERTY)) {\n                continue;\n            }\n            String n = td.getPropertyName();\n            PropertyName typePropName = PropertyName.construct(n);\n\n            for (BeanPropertyWriter w2 : props) {\n                if ((w2 != bpw) && w2.wouldConflictWithName(typePropName)) {\n                    bpw.assignTypeSerializer(null);\n                    break;\n                }\n            }\n        }\n        return props;\n    }\n    \n    \n\n    \n    protected BeanPropertyWriter _constructWriter(SerializerProvider prov, BeanPropertyDefinition propDef, TypeBindings typeContext, PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor) throws JsonMappingException {\n        final PropertyName name = propDef.getFullName();\n        if (prov.canOverrideAccessModifiers()) {\n            accessor.fixAccess();\n        }\n        JavaType type = accessor.getType(typeContext);\n        BeanProperty.Std property = new BeanProperty.Std(name, type, propDef.getWrapperName(),\n                pb.getClassAnnotations(), accessor, propDef.getMetadata());\n\n        \n        JsonSerializer<?> annotatedSerializer = findSerializerFromAnnotation(prov,\n                accessor);\n        \n        if (annotatedSerializer instanceof ResolvableSerializer) {\n            ((ResolvableSerializer) annotatedSerializer).resolve(prov);\n        }\n        \n        annotatedSerializer = prov.handlePrimaryContextualization(annotatedSerializer, property);\n        \n        TypeSerializer contentTypeSer = null;\n        \n        if (ClassUtil.isCollectionMapOrArray(type.getRawClass())\n                || type.isCollectionLikeType() || type.isMapLikeType()) {\n            contentTypeSer = findPropertyContentTypeSerializer(type, prov.getConfig(), accessor);\n        }\n        \n        TypeSerializer typeSer = findPropertyTypeSerializer(type, prov.getConfig(), accessor);\n        BeanPropertyWriter pbw = pb.buildWriter(prov, propDef, type, annotatedSerializer,\n                        typeSer, contentTypeSer, accessor, staticTyping);\n        return pbw;\n    }\n}\n",
      "buggy_signatures": [
        "public SerializerFactory withConfig(SerializerFactoryConfig config)",
        "protected Iterable<Serializers> customSerializers()",
        "public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException",
        "protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException",
        "public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "public TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException",
        "public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException",
        "protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException",
        "protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props) throws JsonMappingException",
        "protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer, Class<?>[] inViews)",
        "protected PropertyBuilder constructPropertyBuilder(SerializationConfig config, BeanDescription beanDesc)",
        "protected BeanSerializerBuilder constructBeanSerializerBuilder(BeanDescription beanDesc)",
        "protected boolean isPotentialBeanType(Class<?> type)",
        "protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException",
        "protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> props)",
        "protected void processViews(SerializationConfig config, BeanSerializerBuilder builder)",
        "protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties)",
        "protected void removeSetterlessGetters(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties)",
        "protected List<BeanPropertyWriter> removeOverlappingTypeIds(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder, List<BeanPropertyWriter> props)",
        "protected BeanPropertyWriter _constructWriter(SerializerProvider prov, BeanPropertyDefinition propDef, TypeBindings typeContext, PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor) throws JsonMappingException"
      ],
      "fixed_signatures": [
        "public SerializerFactory withConfig(SerializerFactoryConfig config)",
        "protected Iterable<Serializers> customSerializers()",
        "public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException",
        "protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException",
        "public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "public TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException",
        "public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException",
        "protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException",
        "protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props) throws JsonMappingException",
        "protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer, Class<?>[] inViews)",
        "protected PropertyBuilder constructPropertyBuilder(SerializationConfig config, BeanDescription beanDesc)",
        "protected BeanSerializerBuilder constructBeanSerializerBuilder(BeanDescription beanDesc)",
        "protected boolean isPotentialBeanType(Class<?> type)",
        "protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException",
        "protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> props)",
        "protected void processViews(SerializationConfig config, BeanSerializerBuilder builder)",
        "protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties)",
        "protected void removeSetterlessGetters(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties)",
        "protected List<BeanPropertyWriter> removeOverlappingTypeIds(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder, List<BeanPropertyWriter> props)",
        "protected BeanPropertyWriter _constructWriter(SerializerProvider prov, BeanPropertyDefinition propDef, TypeBindings typeContext, PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor) throws JsonMappingException"
      ],
      "methods": [
        {
          "buggy_method": "  protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {\n  JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc);\n  if (ser != null) {\n  return ser;\n  }\n  final SerializationConfig config = prov.getConfig();\n  \n  \n  \n  if (type.isContainerType()) {\n  if (!staticTyping) {\n  staticTyping = usesStaticTyping(config, beanDesc, null);\n  \n  \n  \n  }\n  \n  ser =  buildContainerSerializer(prov, type, beanDesc, staticTyping);\n  \n  if (ser != null) {\n  return ser;\n  }\n  } else {\n  \n  for (Serializers serializers : customSerializers()) {\n  ser = serializers.findSerializer(config, type, beanDesc);\n  if (ser != null) {\n  break;\n  }\n  }\n  \n  \n  }\n  \n  if (ser == null) {\n  \n  \n  \n  ser = findSerializerByLookup(type, config, beanDesc, staticTyping);\n  if (ser == null) {\n  ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n  if (ser == null) {\n  \n  \n  \n  ser = findBeanSerializer(prov, type, beanDesc);\n  \n  if (ser == null) {\n  ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);\n  \n  \n  \n  if (ser == null) {\n  ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass());\n  }\n  }\n  }\n  }\n  }\n  if (ser != null) {\n  \n  if (_factoryConfig.hasSerializerModifiers()) {\n  for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n  ser = mod.modifySerializer(config, beanDesc, ser);\n  }\n  }\n  }\n  return ser;\n  }",
          "fixed_method": "  protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {\n  JsonSerializer<?> ser = null;\n  final SerializationConfig config = prov.getConfig();\n  \n  \n  \n  if (type.isContainerType()) {\n  if (!staticTyping) {\n  staticTyping = usesStaticTyping(config, beanDesc, null);\n  \n  \n  \n  }\n  \n  ser =  buildContainerSerializer(prov, type, beanDesc, staticTyping);\n  \n  if (ser != null) {\n  return ser;\n  }\n  } else {\n  \n  for (Serializers serializers : customSerializers()) {\n  ser = serializers.findSerializer(config, type, beanDesc);\n  if (ser != null) {\n  break;\n  }\n  }\n  \n  \n  if (ser == null) {\n  ser = findSerializerByAnnotations(prov, type, beanDesc);\n  }\n  }\n  \n  if (ser == null) {\n  \n  \n  \n  ser = findSerializerByLookup(type, config, beanDesc, staticTyping);\n  if (ser == null) {\n  ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n  if (ser == null) {\n  \n  \n  \n  ser = findBeanSerializer(prov, type, beanDesc);\n  \n  if (ser == null) {\n  ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);\n  \n  \n  \n  if (ser == null) {\n  ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass());\n  }\n  }\n  }\n  }\n  }\n  if (ser != null) {\n  \n  if (_factoryConfig.hasSerializerModifiers()) {\n  for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n  ser = mod.modifySerializer(config, beanDesc, ser);\n  }\n  }\n  }\n  return ser;\n  }",
          "diff": [
            "@@ -171,10 +171,7 @@",
            "             JavaType type, BeanDescription beanDesc, boolean staticTyping)\n",
            "         throws JsonMappingException\n",
            "     {\n",
            "-        JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc);\n",
            "-        if (ser != null) {\n",
            "-            return ser;\n",
            "-        }\n",
            "+        JsonSerializer<?> ser = null;\n",
            "         final SerializationConfig config = prov.getConfig();\n",
            "         \n",
            "         // Container types differ from non-container types\n",
            "@@ -209,6 +206,9 @@",
            "             }\n",
            "             // 25-Jun-2015, tatu: Then JsonSerializable, @JsonValue etc. NOTE! Prior to 2.6,\n",
            "             //    this call was BEFORE custom serializer lookup, which was wrong.\n",
            "+            if (ser == null) {\n",
            "+                ser = findSerializerByAnnotations(prov, type, beanDesc);\n",
            "+            }\n",
            "         }\n",
            "         \n",
            "         if (ser == null) {\n"
          ],
          "changed_lines": 8
        }
      ]
    }
  ]
}
