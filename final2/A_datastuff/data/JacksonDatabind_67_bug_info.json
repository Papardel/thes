{
  "bug_id": "67",
  "failed_tests": {
    "com.fasterxml.jackson.databind.module.TestCustomEnumKeyDeserializer": [
      {
        "methodName": "testCustomEnumValueAndKeyViaModifier",
        "error": "com.fasterxml.jackson.databind.exc.InvalidFormatException",
        "message": "Can not deserialize Map key of type com.fasterxml.jackson.databind.module.TestCustomEnumKeyDeserializer$KeyEnum from String \"REPlaceMENTS\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Can not deserialize Map key of type com.fasterxml.jackson.databind.module.TestCustomEnumKeyDeserializer$KeyEnum from String \"REPlaceMENTS\": not one of values excepted for Enum class: [rootDirectory, replacements, licenseString]",
        "fail_line": "        EnumMap<KeyEnum,String> map = mapper.readValue(",
        "test_source": "  public void testCustomEnumValueAndKeyViaModifier() throws IOException {\n  SimpleModule module = new SimpleModule();\n  module.setDeserializerModifier(new BeanDeserializerModifier() {  \n  @Override\n  public JsonDeserializer<Enum> modifyEnumDeserializer(DeserializationConfig config, final JavaType type, BeanDescription beanDesc, final JsonDeserializer<?> deserializer) {\n  return new JsonDeserializer<Enum>() {\n  @Override\n  public Enum deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n  Class<? extends Enum> rawClass = (Class<Enum<?>>) type.getRawClass();\n  final String str = p.getValueAsString().toLowerCase();\n  return KeyEnum.valueOf(rawClass, str);\n  }\n  };\n  }\n\n  @Override\n  public KeyDeserializer modifyKeyDeserializer(DeserializationConfig config, final JavaType type, KeyDeserializer deserializer) {\n  if (!type.isEnumType()) {\n  return deserializer;\n  }\n  return new KeyDeserializer() {\n  @Override\n  public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n  Class<? extends Enum> rawClass = (Class<Enum<?>>) type.getRawClass();\n  return Enum.valueOf(rawClass, key.toLowerCase());\n  }\n  };\n  }\n  });\n  ObjectMapper mapper = new ObjectMapper()\n  .registerModule(module);\n\n  // First, enum value as is\n  KeyEnum key = mapper.readValue(quote(KeyEnum.replacements.name().toUpperCase()),\n  KeyEnum.class);\n  assertSame(KeyEnum.replacements, key);\n\n  // and then as key\n  EnumMap<KeyEnum,String> map = mapper.readValue(\n  aposToQuotes(\"{'REPlaceMENTS':'foobar'}\"),\n  new TypeReference<EnumMap<KeyEnum,String>>() { });\n  assertEquals(1, map.size());\n  assertSame(KeyEnum.replacements, map.keySet().iterator().next());\n  }",
        "stack": [
          "InvalidFormatException.from line 74, DeserializationContext.weirdKeyException line 1389, DeserializationContext.handleWeirdKey line 880, StdKeyDeserializer.deserializeKey line 130, EnumMapDeserializer.deserialize line 139, EnumMapDeserializer.deserialize line 17, ObjectMapper._readMapAndClose line 3798, ObjectMapper.readValue line 2861, TestCustomEnumKeyDeserializer.testCustomEnumValueAndKeyViaModifier line 275"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.deser;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.core.JsonLocation;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.deser.impl.CreatorCollector;\nimport com.fasterxml.jackson.databind.deser.std.*;\nimport com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.*;\n\n\n@SuppressWarnings(\"serial\")\npublic abstract class BasicDeserializerFactory extends DeserializerFactory implements java.io.Serializable { private final static Class<?> CLASS_OBJECT = Object.class; private final static Class<?> CLASS_STRING = String.class; private final static Class<?> CLASS_CHAR_BUFFER = CharSequence.class; private final static Class<?> CLASS_ITERABLE = Iterable.class; private final static Class<?> CLASS_MAP_ENTRY = Map.Entry.class; protected final static PropertyName UNWRAPPED_CREATOR_PARAM_NAME = new PropertyName(\"@JsonUnwrapped\"); @SuppressWarnings(\"rawtypes\") final static HashMap<String, Class<? extends Map>> _mapFallbacks = new HashMap<String, Class<? extends Map>>(); static {\n        _mapFallbacks.put(Map.class.getName(), LinkedHashMap.class);\n        _mapFallbacks.put(ConcurrentMap.class.getName(), ConcurrentHashMap.class);\n        _mapFallbacks.put(SortedMap.class.getName(), TreeMap.class);\n\n        _mapFallbacks.put(java.util.NavigableMap.class.getName(), TreeMap.class);\n        _mapFallbacks.put(java.util.concurrent.ConcurrentNavigableMap.class.getName(),\n                java.util.concurrent.ConcurrentSkipListMap.class);\n    }\n\n    \n    @SuppressWarnings(\"rawtypes\")\n    final static HashMap<String, Class<? extends Collection>> _collectionFallbacks = new HashMap<String, Class<? extends Collection>>(); static {\n        _collectionFallbacks.put(Collection.class.getName(), ArrayList.class);\n        _collectionFallbacks.put(List.class.getName(), ArrayList.class);\n        _collectionFallbacks.put(Set.class.getName(), HashSet.class);\n        _collectionFallbacks.put(SortedSet.class.getName(), TreeSet.class);\n        _collectionFallbacks.put(Queue.class.getName(), LinkedList.class);\n\n        \n        \n        _collectionFallbacks.put(\"java.util.Deque\", LinkedList.class);\n        _collectionFallbacks.put(\"java.util.NavigableSet\", TreeSet.class);\n    }\n\n    \n    \n    \n    protected final DeserializerFactoryConfig _factoryConfig; protected BasicDeserializerFactory(DeserializerFactoryConfig config) {\n        _factoryConfig = config;\n    }\n    \n    \n    public DeserializerFactoryConfig getFactoryConfig() {\n        return _factoryConfig;\n    }\n\n    protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); @Override public final DeserializerFactory withAdditionalDeserializers(Deserializers additional) {\n        return withConfig(_factoryConfig.withAdditionalDeserializers(additional));\n    }\n\n    \n    @Override\n    public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional) {\n        return withConfig(_factoryConfig.withAdditionalKeyDeserializers(additional));\n    }\n    \n    \n    @Override\n    public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier) {\n        return withConfig(_factoryConfig.withDeserializerModifier(modifier));\n    }\n\n    \n    @Override\n    public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver) {\n        return withConfig(_factoryConfig.withAbstractTypeResolver(resolver));\n    }\n\n    \n    @Override\n    public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators) {\n        return withConfig(_factoryConfig.withValueInstantiators(instantiators));\n    }\n\n    \n\n    @Override\n    public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException {\n        \n        while (true) {\n            JavaType next = _mapAbstractType2(config, type);\n            if (next == null) {\n                return type;\n            }\n            \n            \n            Class<?> prevCls = type.getRawClass();\n            Class<?> nextCls = next.getRawClass();\n            if ((prevCls == nextCls) || !prevCls.isAssignableFrom(nextCls)) {\n                throw new IllegalArgumentException(\"Invalid abstract type resolution from \"+type+\" to \"+next+\": latter is not a subtype of former\"); } type = next; } } private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) throws JsonMappingException {\n        Class<?> currClass = type.getRawClass();\n        if (_factoryConfig.hasAbstractTypeResolvers()) {\n            for (AbstractTypeResolver resolver : _factoryConfig.abstractTypeResolvers()) {\n                JavaType concrete = resolver.findTypeMapping(config, type);\n                if (concrete != null && concrete.getRawClass() != currClass) {\n                    return concrete;\n                }\n            }\n        }\n        return null;\n    }\n    \n    \n\n    \n    @Override\n    public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n\n        ValueInstantiator instantiator = null;\n        \n        AnnotatedClass ac = beanDesc.getClassInfo();\n        Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac);\n        if (instDef != null) {\n            instantiator = _valueInstantiatorInstance(config, ac, instDef);\n        }\n        if (instantiator == null) {\n            \n            instantiator = _findStdValueInstantiator(config, beanDesc);\n            if (instantiator == null) {\n                instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc);\n            }\n        }\n        \n        \n        if (_factoryConfig.hasValueInstantiators()) {\n            for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) {\n                instantiator = insts.findValueInstantiator(config, beanDesc, instantiator);\n                \n                if (instantiator == null) {\n\t\t    ctxt.reportMappingException(\n\t\t\t\t\t\t\"Broken registered ValueInstantiators (of type %s): returned null ValueInstantiator\",\n\t\t\t\t\t\tinsts.getClass().getName());\n                }\n            }\n        }\n\n        \n        if (instantiator.getIncompleteParameter() != null) {\n            final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter();\n            final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner();\n            throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()+\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n        }\n\n        return instantiator;\n    }\n\n    private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        if (beanDesc.getBeanClass() == JsonLocation.class) {\n            return new JsonLocationInstantiator();\n        }\n        return null;\n    }\n\n    \n    protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException {\n        CreatorCollector creators =  new CreatorCollector(beanDesc, ctxt.getConfig());\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        \n        \n        final DeserializationConfig config = ctxt.getConfig();\n        VisibilityChecker<?> vchecker = config.getDefaultVisibilityChecker();\n        vchecker = intr.findAutoDetectVisibility(beanDesc.getClassInfo(), vchecker);\n\n        \n        \n        Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorDefs = _findCreatorsFromProperties(ctxt,\n                beanDesc);\n\n        \n        _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n        \n        if (beanDesc.getType().isConcrete()) {\n            _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n        }\n        return creators.constructValueInstantiator(config);\n    }\n\n    protected Map<AnnotatedWithParams,BeanPropertyDefinition[]> _findCreatorsFromProperties(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException {\n        Map<AnnotatedWithParams,BeanPropertyDefinition[]> result = Collections.emptyMap();\n        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {\n            Iterator<AnnotatedParameter> it = propDef.getConstructorParameters();\n            while (it.hasNext()) {\n                AnnotatedParameter param = it.next();\n                AnnotatedWithParams owner = param.getOwner();\n                BeanPropertyDefinition[] defs = result.get(owner);\n                final int index = param.getIndex();\n                \n                if (defs == null) {\n                    if (result.isEmpty()) { \n                        result = new LinkedHashMap<AnnotatedWithParams,BeanPropertyDefinition[]>();\n                    }\n                    defs = new BeanPropertyDefinition[owner.getParameterCount()];\n                    result.put(owner, defs);\n                } else {\n                    if (defs[index] != null) {\n                        throw new IllegalStateException(\"Conflict: parameter #\"+index+\" of \"+owner\n                                +\" bound to more than one property; \"+defs[index]+\" vs \"+propDef);\n                    }\n                }\n                defs[index] = propDef;\n            }\n        }\n        return result;\n    }\n    \n    public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException {\n        if (instDef == null) {\n            return null;\n        }\n\n        ValueInstantiator inst;\n        \n        if (instDef instanceof ValueInstantiator) {\n            return (ValueInstantiator) instDef;\n        }\n        if (!(instDef instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned key deserializer definition of type \"\n                    +instDef.getClass().getName()\n                    +\"; expected type KeyDeserializer or Class<KeyDeserializer> instead\");\n        }\n        Class<?> instClass = (Class<?>)instDef;\n        if (ClassUtil.isBogusClass(instClass)) {\n            return null;\n        }\n        if (!ValueInstantiator.class.isAssignableFrom(instClass)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+instClass.getName()\n                    +\"; expected Class<ValueInstantiator>\");\n        }\n        HandlerInstantiator hi = config.getHandlerInstantiator();\n        if (hi != null) {\n            inst = hi.valueInstantiatorInstance(config, annotated, instClass);\n            if (inst != null) {\n                return inst;\n            }\n        }\n        return (ValueInstantiator) ClassUtil.createInstance(instClass,\n                config.canOverrideAccessModifiers());\n    }\n\n    protected void _addDeserializerConstructors (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException {\n        \n        \n        \n        AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor();\n        if (defaultCtor != null) {\n            if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) {\n                creators.setDefaultCreator(defaultCtor);\n            }\n        }\n\n        \n        List<AnnotatedConstructor> implicitCtors = null;\n        for (AnnotatedConstructor ctor : beanDesc.getConstructors()) {\n            final boolean isCreator = intr.hasCreatorAnnotation(ctor);\n            BeanPropertyDefinition[] propDefs = creatorParams.get(ctor);\n            final int argCount = ctor.getParameterCount();\n\n            \n            if (argCount == 1) {\n                BeanPropertyDefinition argDef = (propDefs == null) ? null : propDefs[0];\n                boolean useProps = _checkIfCreatorPropertyBased(intr, ctor, argDef);\n\n                if (useProps) {\n                    SettableBeanProperty[] properties = new SettableBeanProperty[1];\n                    PropertyName name = (argDef == null) ? null : argDef.getFullName();\n                    AnnotatedParameter arg = ctor.getParameter(0);\n                    properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, arg,\n                            intr.findInjectableValueId(arg));\n                    creators.addPropertyCreator(ctor, isCreator, properties);\n                } else {\n                     _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators,\n                            ctor, isCreator,\n                            vchecker.isCreatorVisible(ctor));\n                    \n                    \n                    if (argDef != null) {\n                        ((POJOPropertyBuilder) argDef).removeConstructors();\n                    }\n                }\n                \n                continue;\n            }\n\n            \n            \n            \n\n            AnnotatedParameter nonAnnotatedParam = null;\n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            int explicitNameCount = 0;\n            int implicitWithCreatorCount = 0;\n            int injectCount = 0;\n\n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = ctor.getParameter(i);\n                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i];\n                Object injectId = intr.findInjectableValueId(param);\n                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n\n                if (propDef != null && propDef.isExplicitlyNamed()) {\n                    ++explicitNameCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                if (injectId != null) {\n                    ++injectCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n                    ++explicitNameCount;\n                    continue;\n                }\n                \n                if (isCreator && (name != null && !name.isEmpty())) {\n                    ++implicitWithCreatorCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                if (nonAnnotatedParam == null) {\n                    nonAnnotatedParam = param;\n                }\n            }\n\n            final int namedCount = explicitNameCount + implicitWithCreatorCount;\n            \n            if (isCreator || (explicitNameCount > 0) || (injectCount > 0)) {\n                \n                if ((namedCount + injectCount) == argCount) {\n                    creators.addPropertyCreator(ctor, isCreator, properties);\n                    continue;\n                }\n                if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                    \n                    creators.addDelegatingCreator(ctor, isCreator, properties);\n                    continue;\n                }\n                \n                \n                \n                PropertyName impl = _findImplicitParamName(nonAnnotatedParam, intr);\n                if (impl == null || impl.isEmpty()) {\n                    \n                    int ix = nonAnnotatedParam.getIndex();\n                    if ((ix == 0) && ClassUtil.isNonStaticInnerClass(ctor.getDeclaringClass())) {\n                        throw new IllegalArgumentException(\"Non-static inner classes like \" +ctor.getDeclaringClass().getName()+\" can not use @JsonCreator for constructors\"); } throw new IllegalArgumentException(\"Argument #\"+ix +\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\"); } } if (!creators.hasDefaultCreator()) {\n                if (implicitCtors == null) {\n                    implicitCtors = new LinkedList<AnnotatedConstructor>();\n                }\n                implicitCtors.add(ctor);\n            }\n        }\n        \n        \n        if ((implicitCtors != null) && !creators.hasDelegatingCreator()\n                && !creators.hasPropertyBasedCreator()) {\n            _checkImplicitlyNamedConstructors(ctxt, beanDesc, vchecker, intr,\n                    creators, implicitCtors);\n        }\n    }\n\n    protected void _checkImplicitlyNamedConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, List<AnnotatedConstructor> implicitCtors) throws JsonMappingException {\n        AnnotatedConstructor found = null;\n        SettableBeanProperty[] foundProps = null;\n\n        \n        \n        \n\n        main_loop:\n        for (AnnotatedConstructor ctor : implicitCtors) {\n            if (!vchecker.isCreatorVisible(ctor)) {\n                continue;\n            }\n            \n            final int argCount = ctor.getParameterCount();\n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = ctor.getParameter(i);\n                final PropertyName name = _findParamName(param, intr);\n\n                \n                if (name == null || name.isEmpty()) {\n                    continue main_loop;\n                }\n                properties[i] = constructCreatorProperty(ctxt, beanDesc, name, param.getIndex(),\n                        param,  null);\n            }\n            if (found != null) { \n                found = null;\n                break;\n            }\n            found = ctor;\n            foundProps = properties;\n        }\n        \n        if (found != null) {\n            creators.addPropertyCreator(found,  false, foundProps);\n            BasicBeanDescription bbd = (BasicBeanDescription) beanDesc;\n            \n            for (SettableBeanProperty prop : foundProps) {\n                PropertyName pn = prop.getFullName();\n                if (!bbd.hasProperty(pn)) {\n                    BeanPropertyDefinition newDef = SimpleBeanPropertyDefinition.construct(\n                            ctxt.getConfig(), prop.getMember(), pn);\n                    bbd.addProperty(newDef);\n                }\n            }\n        }\n    }\n\n    protected boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr, AnnotatedWithParams creator, BeanPropertyDefinition propDef) {\n        JsonCreator.Mode mode = intr.findCreatorBinding(creator);\n\n        if (mode == JsonCreator.Mode.PROPERTIES) {\n            return true;\n        }\n        if (mode == JsonCreator.Mode.DELEGATING) {\n            return false;\n        }\n        \n        if (((propDef != null) && propDef.isExplicitlyNamed())\n                || (intr.findInjectableValueId(creator.getParameter(0)) != null)) {\n            return true;\n        }\n        if (propDef != null) {\n            \n            \n            String implName = propDef.getName();\n            if (implName != null && !implName.isEmpty()) {\n                if (propDef.couldSerialize()) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible) throws JsonMappingException {\n        \n        Class<?> type = ctor.getRawParameterType(0);\n        if (type == String.class || type == CharSequence.class) {\n            if (isCreator || isVisible) {\n                creators.addStringCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == int.class || type == Integer.class) {\n            if (isCreator || isVisible) {\n                creators.addIntCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == long.class || type == Long.class) {\n            if (isCreator || isVisible) {\n                creators.addLongCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == double.class || type == Double.class) {\n            if (isCreator || isVisible) {\n                creators.addDoubleCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == boolean.class || type == Boolean.class) {\n            if (isCreator || isVisible) {\n                creators.addBooleanCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        \n        if (isCreator) {\n            creators.addDelegatingCreator(ctor, isCreator, null);\n            return true;\n        }\n        return false;\n    }\n\n    protected void _addDeserializerFactoryMethods (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            final boolean isCreator = intr.hasCreatorAnnotation(factory);\n            final int argCount = factory.getParameterCount();\n            \n            if (argCount == 0) {\n                if (isCreator) {\n                    creators.setDefaultCreator(factory);\n                }\n                continue;\n            }\n\n            final BeanPropertyDefinition[] propDefs = creatorParams.get(factory);\n            \n            if (argCount == 1) {\n                BeanPropertyDefinition argDef = (propDefs == null) ? null : propDefs[0];\n                boolean useProps = _checkIfCreatorPropertyBased(intr, factory, argDef);\n                if (!useProps) { \n                     _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators,\n                            factory, isCreator);\n                    \n                    \n                    if (argDef != null) {\n                        ((POJOPropertyBuilder) argDef).removeConstructors();\n                    }\n                    continue;\n                }\n                \n            } else {\n                \n                if (!isCreator) {\n                    continue;\n                }\n            }\n            \n            AnnotatedParameter nonAnnotatedParam = null;            \n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            int implicitNameCount = 0;\n            int explicitNameCount = 0;\n            int injectCount = 0;\n            \n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = factory.getParameter(i);\n                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i];\n                Object injectId = intr.findInjectableValueId(param);\n                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n\n                if (propDef != null && propDef.isExplicitlyNamed()) {\n                    ++explicitNameCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                if (injectId != null) {\n                    ++injectCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n                    ++implicitNameCount;\n                    continue;\n                }\n                \n                if (isCreator) {\n                    if (name != null && !name.isEmpty()) {\n                        ++implicitNameCount;\n                        properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                        continue;\n                    }\n                }\n                \n                \n                if (nonAnnotatedParam == null) {\n                    nonAnnotatedParam = param;\n                }\n            }\n            final int namedCount = explicitNameCount + implicitNameCount;\n            \n            \n            if (isCreator || explicitNameCount > 0 || injectCount > 0) {\n                \n                if ((namedCount + injectCount) == argCount) {\n                    creators.addPropertyCreator(factory, isCreator, properties);\n                } else if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                    \n                    creators.addDelegatingCreator(factory, isCreator, properties);\n                } else { \n                    throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()\n                            +\" of factory method \"+factory+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n                }\n            }\n        }\n    }\n\n    protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException {\n        Class<?> type = factory.getRawParameterType(0);\n        \n        if (type == String.class || type == CharSequence.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addStringCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == int.class || type == Integer.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addIntCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == long.class || type == Long.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addLongCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == double.class || type == Double.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addDoubleCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == boolean.class || type == Boolean.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addBooleanCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (isCreator) {\n            creators.addDelegatingCreator(factory, isCreator, null);\n            return true;\n        }\n        return false;\n    }\n\n    \n    protected SettableBeanProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, PropertyName name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        PropertyMetadata metadata;\n        {\n            if (intr == null) {\n                metadata = PropertyMetadata.STD_REQUIRED_OR_OPTIONAL;\n            } else {\n                Boolean b = intr.hasRequiredMarker(param);\n                boolean req = (b != null && b.booleanValue());\n                String desc = intr.findPropertyDescription(param);\n                Integer idx = intr.findPropertyIndex(param);\n                String def = intr.findPropertyDefaultValue(param);\n                metadata = PropertyMetadata.construct(req, desc, idx, def);\n            }\n        }\n        JavaType type = resolveMemberAndTypeAnnotations(ctxt, param, param.getType());\n        BeanProperty.Std property = new BeanProperty.Std(name, type,\n                intr.findWrapperName(param),\n                beanDesc.getClassAnnotations(), param, metadata);\n        \n        TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler();\n        \n        if (typeDeser == null) {\n            typeDeser = findTypeDeserializer(config, type);\n        }\n        \n        \n        SettableBeanProperty prop = new CreatorProperty(name, type, property.getWrapperName(),\n                typeDeser, beanDesc.getClassAnnotations(), param, index, injectableValueId,\n                metadata);\n        JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, param);\n        if (deser == null) {\n            deser = type.getValueHandler();\n        }\n        if (deser != null) {\n            \n            deser = ctxt.handlePrimaryContextualization(deser, prop, type);\n            prop = prop.withValueDeserializer(deser);\n        }\n        return prop;\n    }\n\n    protected PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr) {\n        if (param != null && intr != null) {\n            PropertyName name = intr.findNameForDeserialization(param);\n            if (name != null) {\n                return name;\n            }\n            \n            \n\n            String str = intr.findImplicitPropertyName(param);\n            if (str != null && !str.isEmpty()) {\n                return PropertyName.construct(str);\n            }\n        }\n        return null;\n    }\n\n    protected PropertyName _findImplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr) {\n        String str = intr.findImplicitPropertyName(param);\n        if (str != null && !str.isEmpty()) {\n            return PropertyName.construct(str);\n        }\n        return null;\n    }\n\n    @Deprecated \n    protected PropertyName _findExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr) {\n        if (param != null && intr != null) {\n            return intr.findNameForDeserialization(param);\n        }\n        return null;\n    }\n\n    @Deprecated \n    protected boolean _hasExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr) {\n        if (param != null && intr != null) {\n            PropertyName n = intr.findNameForDeserialization(param);\n            return (n != null) && n.hasSimpleName();\n        }\n        return false;\n    }\n\n    \n        \n    @Override\n    public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        JavaType elemType = type.getContentType();\n        \n        \n        JsonDeserializer<Object> contentDeser = elemType.getValueHandler();\n        \n        TypeDeserializer elemTypeDeser = elemType.getTypeHandler();\n        \n        if (elemTypeDeser == null) {\n            elemTypeDeser = findTypeDeserializer(config, elemType);\n        }\n        \n        JsonDeserializer<?>  deser = _findCustomArrayDeserializer(type,\n                config, beanDesc, elemTypeDeser, contentDeser);\n        if (deser == null) {\n            if (contentDeser == null) {\n                Class<?> raw = elemType.getRawClass();\n                if (elemType.isPrimitive()) {\n                    return PrimitiveArrayDeserializers.forType(raw);\n                } else if (raw == String.class) {\n                    return StringArrayDeserializer.instance;\n                }\n            }\n            deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser);\n        }\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    \n\n    @Override\n    public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException {\n        JavaType contentType = type.getContentType();\n        \n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        \n        JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type,\n                config, beanDesc, contentTypeDeser, contentDeser);\n        if (deser == null) {\n            Class<?> collectionClass = type.getRawClass();\n            if (contentDeser == null) { \n                \n                if (EnumSet.class.isAssignableFrom(collectionClass)) {\n                    deser = new EnumSetDeserializer(contentType, null);\n                }\n            }\n        }\n\n        \n        if (deser == null) {\n            if (type.isInterface() || type.isAbstract()) {\n                CollectionType implType = _mapAbstractCollectionType(type, config);\n                if (implType == null) {\n                    \n                    if (type.getTypeHandler() == null) {\n                        throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Collection type \"+type);\n                    }\n                    deser = AbstractDeserializer.constructForNonPOJO(beanDesc);\n                } else {\n                    type = implType;\n                    \n                    beanDesc = config.introspectForCreation(type);\n                }\n            }\n            if (deser == null) {\n                ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n                if (!inst.canCreateUsingDefault()) {\n                    \n                    if (type.getRawClass() == ArrayBlockingQueue.class) {\n                        return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst);\n                    }\n                }\n                \n                if (contentType.getRawClass() == String.class) {\n                    \n                    deser = new StringCollectionDeserializer(type, contentDeser, inst);\n                } else {\n                    deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst);\n                }\n            }\n        }\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config) {\n        Class<?> collectionClass = type.getRawClass();\n        collectionClass = _collectionFallbacks.get(collectionClass.getName());\n        if (collectionClass == null) {\n            return null;\n        }\n        return (CollectionType) config.constructSpecializedType(type, collectionClass);\n    }\n    \n    \n    @Override\n    public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException {\n        JavaType contentType = type.getContentType();\n        \n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomCollectionLikeDeserializer(type, config, beanDesc,\n                contentTypeDeser, contentDeser);\n        if (deser != null) {\n            \n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyCollectionLikeDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    \n\n    @Override\n    public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        JavaType keyType = type.getKeyType();\n        JavaType contentType = type.getContentType();\n        \n        \n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();\n\n        \n        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n\n        \n        JsonDeserializer<?> deser = _findCustomMapDeserializer(type, config, beanDesc,\n                keyDes, contentTypeDeser, contentDeser);\n\n        if (deser == null) {\n            \n            Class<?> mapClass = type.getRawClass();\n            if (EnumMap.class.isAssignableFrom(mapClass)) {\n                Class<?> kt = keyType.getRawClass();\n                if (kt == null || !kt.isEnum()) {\n                    throw new IllegalArgumentException(\"Can not construct EnumMap; generic (key) type not available\");\n                }\n                deser = new EnumMapDeserializer(type, null, contentDeser, contentTypeDeser);\n            }\n\n            \n    \n            \n            if (deser == null) {\n                if (type.isInterface() || type.isAbstract()) {\n                    @SuppressWarnings(\"rawtypes\")\n                    Class<? extends Map> fallback = _mapFallbacks.get(mapClass.getName());\n                    if (fallback != null) {\n                        mapClass = fallback;\n                        type = (MapType) config.constructSpecializedType(type, mapClass);\n                        \n                        beanDesc = config.introspectForCreation(type);\n                    } else {\n                        \n                        if (type.getTypeHandler() == null) {\n                            throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Map type \"+type);\n                        }\n                        deser = AbstractDeserializer.constructForNonPOJO(beanDesc);\n                    }\n                }\n                if (deser == null) {\n                    ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n                    \n                    \n                    \n                    \n                    MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser);\n                    JsonIgnoreProperties.Value ignorals = config.getDefaultPropertyIgnorals(Map.class,\n                            beanDesc.getClassInfo());\n                    Set<String> ignored = (ignorals == null) ? null\n                            : ignorals.findIgnoredForDeserialization();\n                    md.setIgnorableProperties(ignored);\n                    deser = md;\n                }\n            }\n        }\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyMapDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    \n    @Override\n    public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException {\n        JavaType keyType = type.getKeyType();\n        JavaType contentType = type.getContentType();\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        \n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();\n        \n        \n        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n        \n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomMapLikeDeserializer(type, config,\n                beanDesc, keyDes, contentTypeDeser, contentDeser);\n        if (deser != null) {\n            \n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyMapLikeDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    \n    \n    \n    @Override\n    public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        final Class<?> enumClass = type.getRawClass();\n        \n        JsonDeserializer<?> deser = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n\n        if (deser == null) {\n            ValueInstantiator valueInstantiator = _constructDefaultValueInstantiator(ctxt, beanDesc);\n            SettableBeanProperty[] creatorProps = (valueInstantiator == null) ? null\n                    : valueInstantiator.getFromObjectArguments(ctxt.getConfig());\n            \n            for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n                if (ctxt.getAnnotationIntrospector().hasCreatorAnnotation(factory)) {\n                    if (factory.getParameterCount() == 0) { \n                        deser = EnumDeserializer.deserializerForNoArgsCreator(config, enumClass, factory);\n                        break;\n                    }\n                    Class<?> returnType = factory.getRawReturnType();\n                    \n                    if (returnType.isAssignableFrom(enumClass)) {\n                        deser = EnumDeserializer.deserializerForCreator(config, enumClass, factory, valueInstantiator, creatorProps);\n                        break;\n                    }\n                }\n            }\n           \n            \n            if (deser == null) {\n                deser = new EnumDeserializer(constructEnumResolver(enumClass,\n                        config, beanDesc.findJsonValueMethod()));\n            }\n        }\n\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyEnumDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    @Override\n    public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException {\n        @SuppressWarnings(\"unchecked\")\n        Class<? extends JsonNode> nodeClass = (Class<? extends JsonNode>) nodeType.getRawClass();\n        \n        JsonDeserializer<?> custom = _findCustomTreeNodeDeserializer(nodeClass, config,\n                beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        return JsonNodeDeserializer.getDeserializer(nodeClass);\n    }\n\n    @Override\n    public JsonDeserializer<?> createReferenceDeserializer(DeserializationContext ctxt, ReferenceType type, BeanDescription beanDesc) throws JsonMappingException {\n        JavaType contentType = type.getContentType();\n        \n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        if (contentTypeDeser == null) { \n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomReferenceDeserializer(type, config, beanDesc,\n                contentTypeDeser, contentDeser);\n\n        if (deser == null) {\n            \n            if (AtomicReference.class.isAssignableFrom(type.getRawClass())) {\n                return new AtomicReferenceDeserializer(type, contentTypeDeser, contentDeser);\n            }\n        }\n        if (deser != null) {\n            \n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyReferenceDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    \n\n    @Override\n    public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n        BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n        AnnotatedClass ac = bean.getClassInfo();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n\n        \n        Collection<NamedType> subtypes = null;\n        if (b == null) {\n            b = config.getDefaultTyper(baseType);\n            if (b == null) {\n                return null;\n            }\n        } else {\n            subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n        }\n        \n        \n        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n            JavaType defaultType = mapAbstractType(config, baseType);\n            if (defaultType != null && defaultType.getRawClass() != baseType.getRawClass()) {\n                b = b.defaultImpl(defaultType.getRawClass());\n            }\n        }\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    }\n\n    \n    protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        return OptionalHandlerFactory.instance.findDeserializer(type, ctxt.getConfig(), beanDesc);\n    }\n    \n    \n    \n    @Override\n    public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        KeyDeserializer deser = null;\n        if (_factoryConfig.hasKeyDeserializers()) {\n            BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n            for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n                deser = d.findKeyDeserializer(type, config, beanDesc);\n                if (deser != null) {\n                    break;\n                }\n            }\n        }\n        \n        if (deser == null) {\n            if (type.isEnumType()) {\n                return _createEnumKeyDeserializer(ctxt, type);\n            }\n            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n        }\n        \n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyKeyDeserializer(config, type, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        Class<?> enumClass = type.getRawClass();\n\n        BeanDescription beanDesc = config.introspect(type);\n        \n        KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n            return des;\n        } else {\n            \n            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n            if (custom != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n            }\n            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n            if (valueDesForKey != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);\n            }\n        }\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n        \n        final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (ai.hasCreatorAnnotation(factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n                    Class<?> returnType = factory.getRawReturnType();\n                    \n                    if (returnType.isAssignableFrom(enumClass)) {\n                        \n                        if (factory.getRawParameterType(0) != String.class) {\n                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n                        }\n                        if (config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(factory.getMember(),\n                                    ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                        }\n                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                    }\n                }\n                throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n                        +enumClass.getName()+\")\");\n            }\n        }\n        \n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }\n\n    \n\n    \n    public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, annotated, baseType);        \n        \n        if (b == null) {\n            return findTypeDeserializer(config, baseType);\n        }\n        \n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(\n                config, annotated, baseType);\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    }\n    \n        \n    public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, propertyEntity, containerType);        \n        JavaType contentType = containerType.getContentType();\n        \n        if (b == null) {\n            return findTypeDeserializer(config, contentType);\n        }\n        \n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(\n                config, propertyEntity, contentType);\n        return b.buildTypeDeserializer(config, contentType, subtypes);\n    }\n\n    \n    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        Class<?> rawType = type.getRawClass();\n        \n        if (rawType == CLASS_OBJECT) {\n            \n            DeserializationConfig config = ctxt.getConfig();\n            JavaType lt, mt;\n            \n            if (_factoryConfig.hasAbstractTypeResolvers()) {\n                lt = _findRemappedType(config, List.class);\n                mt = _findRemappedType(config, Map.class);\n            } else {\n                lt = mt = null;\n            }\n            return new UntypedObjectDeserializer(lt, mt);\n        }\n        if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n            return StringDeserializer.instance;\n        }\n        if (rawType == CLASS_ITERABLE) {\n            \n            TypeFactory tf = ctxt.getTypeFactory();\n            JavaType[] tps = tf.findTypeParameters(type, CLASS_ITERABLE);\n            JavaType elemType = (tps == null || tps.length != 1) ? TypeFactory.unknownType() : tps[0];\n            CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n            \n            return createCollectionDeserializer(ctxt, ct, beanDesc);\n        }\n        if (rawType == CLASS_MAP_ENTRY) {\n            \n            JavaType kt = type.containedType(0);\n            if (kt == null) {\n                kt = TypeFactory.unknownType();\n            }\n            JavaType vt = type.containedType(1);\n            if (vt == null) {\n                vt = TypeFactory.unknownType();\n            }\n            TypeDeserializer vts = (TypeDeserializer) vt.getTypeHandler();\n            if (vts == null) {\n                vts = findTypeDeserializer(ctxt.getConfig(), vt);\n            }\n            JsonDeserializer<Object> valueDeser = vt.getValueHandler();\n            KeyDeserializer keyDes = (KeyDeserializer) kt.getValueHandler();\n            return new MapEntryDeserializer(type, keyDes, valueDeser, vts);\n        }\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            \n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n            }\n            if (deser != null) {\n                return deser;\n            }\n        }\n        \n        if (rawType == TokenBuffer.class) {\n            return new TokenBufferDeserializer();\n        }\n        JsonDeserializer<?> deser = findOptionalStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n        return JdkDeserializers.find(rawType, clsName);\n    }\n\n    protected JavaType _findRemappedType(DeserializationConfig config, Class<?> rawType) throws JsonMappingException {\n        JavaType type = mapAbstractType(config, config.constructType(rawType));\n        return (type == null || type.hasRawClass(rawType)) ? null : type;\n    }\n\n    \n\n    protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomReferenceDeserializer(ReferenceType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer contentTypeDeserializer, JsonDeserializer<?> contentDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findReferenceDeserializer(type, config, beanDesc,\n                    contentTypeDeserializer, contentDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findBeanDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return (JsonDeserializer<Object>) deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findArrayDeserializer(type, config,\n                    beanDesc, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findCollectionDeserializer(type, config, beanDesc,\n                    elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findCollectionLikeDeserializer(type, config, beanDesc,\n                    elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findMapDeserializer(type, config, beanDesc,\n                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findMapLikeDeserializer(type, config, beanDesc,\n                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    \n    \n    \n    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n            Object deserDef = intr.findDeserializer(ann);\n            if (deserDef != null) {\n                return ctxt.deserializerInstance(ann, deserDef);\n            }\n        }\n        return null;\n    }\n\n    \n    protected KeyDeserializer findKeyDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n            Object deserDef = intr.findKeyDeserializer(ann);\n            if (deserDef != null) {\n                return ctxt.keyDeserializerInstance(ann, deserDef);\n            }\n        }\n        return null;\n    }\n\n    \n    protected JavaType resolveMemberAndTypeAnnotations(DeserializationContext ctxt, AnnotatedMember member, JavaType type) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr == null) {\n            return type;\n        }\n\n        \n        \n\n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            if (keyType != null) {\n                Object kdDef = intr.findKeyDeserializer(member);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); \n                }\n            }\n        }\n\n        if (type.hasContentType()) { \n            Object cdDef = intr.findContentDeserializer(member);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef);\n            if (cd != null) {\n                type = type.withContentValueHandler(cd);\n            }\n            TypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(\n                    ctxt.getConfig(), type, (AnnotatedMember) member);            \t\n            if (contentTypeDeser != null) {\n                type = type.withContentTypeHandler(contentTypeDeser);\n            }\n        }\n        TypeDeserializer valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(),\n                    type, (AnnotatedMember) member);\n        if (valueTypeDeser != null) {\n            type = type.withTypeHandler(valueTypeDeser);\n        }\n\n        \n\n        \n        \n        \n        type = intr.refineDeserializationType(ctxt.getConfig(), member, type);\n        return type;\n    }\n\n    protected EnumResolver constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMethod jsonValueMethod) {\n        if (jsonValueMethod != null) {\n            Method accessor = jsonValueMethod.getAnnotated();\n            if (config.canOverrideAccessModifiers()) {\n                ClassUtil.checkAndFixAccess(accessor, config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n            return EnumResolver.constructUnsafeUsingMethod(enumClass, accessor, config.getAnnotationIntrospector());\n        }\n        \n        \n        return EnumResolver.constructUnsafe(enumClass, config.getAnnotationIntrospector());\n    }\n\n    \n    \n    \n    @Deprecated\n    protected JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr == null) {\n            return type;\n        }\n\n        \n        \n        \n        return intr.refineDeserializationType(ctxt.getConfig(), a, type);\n    }\n\n    \n    @Deprecated \n    protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException {\n        return resolveMemberAndTypeAnnotations(ctxt, member, type);\n    }\n\n    \n    @Deprecated \n    protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType) {\n        if (enumType == null) {\n            return null;\n        }\n        BeanDescription beanDesc = config.introspect(enumType);\n        return beanDesc.findJsonValueMethod();\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.deser;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.core.JsonLocation;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.deser.impl.CreatorCollector;\nimport com.fasterxml.jackson.databind.deser.std.*;\nimport com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.*;\n\n\n@SuppressWarnings(\"serial\")\npublic abstract class BasicDeserializerFactory extends DeserializerFactory implements java.io.Serializable { private final static Class<?> CLASS_OBJECT = Object.class; private final static Class<?> CLASS_STRING = String.class; private final static Class<?> CLASS_CHAR_BUFFER = CharSequence.class; private final static Class<?> CLASS_ITERABLE = Iterable.class; private final static Class<?> CLASS_MAP_ENTRY = Map.Entry.class; protected final static PropertyName UNWRAPPED_CREATOR_PARAM_NAME = new PropertyName(\"@JsonUnwrapped\"); @SuppressWarnings(\"rawtypes\") final static HashMap<String, Class<? extends Map>> _mapFallbacks = new HashMap<String, Class<? extends Map>>(); static {\n        _mapFallbacks.put(Map.class.getName(), LinkedHashMap.class);\n        _mapFallbacks.put(ConcurrentMap.class.getName(), ConcurrentHashMap.class);\n        _mapFallbacks.put(SortedMap.class.getName(), TreeMap.class);\n\n        _mapFallbacks.put(java.util.NavigableMap.class.getName(), TreeMap.class);\n        _mapFallbacks.put(java.util.concurrent.ConcurrentNavigableMap.class.getName(),\n                java.util.concurrent.ConcurrentSkipListMap.class);\n    }\n\n    \n    @SuppressWarnings(\"rawtypes\")\n    final static HashMap<String, Class<? extends Collection>> _collectionFallbacks = new HashMap<String, Class<? extends Collection>>(); static {\n        _collectionFallbacks.put(Collection.class.getName(), ArrayList.class);\n        _collectionFallbacks.put(List.class.getName(), ArrayList.class);\n        _collectionFallbacks.put(Set.class.getName(), HashSet.class);\n        _collectionFallbacks.put(SortedSet.class.getName(), TreeSet.class);\n        _collectionFallbacks.put(Queue.class.getName(), LinkedList.class);\n\n        \n        \n        _collectionFallbacks.put(\"java.util.Deque\", LinkedList.class);\n        _collectionFallbacks.put(\"java.util.NavigableSet\", TreeSet.class);\n    }\n\n    \n    \n    \n    protected final DeserializerFactoryConfig _factoryConfig; protected BasicDeserializerFactory(DeserializerFactoryConfig config) {\n        _factoryConfig = config;\n    }\n    \n    \n    public DeserializerFactoryConfig getFactoryConfig() {\n        return _factoryConfig;\n    }\n\n    protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); @Override public final DeserializerFactory withAdditionalDeserializers(Deserializers additional) {\n        return withConfig(_factoryConfig.withAdditionalDeserializers(additional));\n    }\n\n    \n    @Override\n    public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional) {\n        return withConfig(_factoryConfig.withAdditionalKeyDeserializers(additional));\n    }\n    \n    \n    @Override\n    public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier) {\n        return withConfig(_factoryConfig.withDeserializerModifier(modifier));\n    }\n\n    \n    @Override\n    public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver) {\n        return withConfig(_factoryConfig.withAbstractTypeResolver(resolver));\n    }\n\n    \n    @Override\n    public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators) {\n        return withConfig(_factoryConfig.withValueInstantiators(instantiators));\n    }\n\n    \n\n    @Override\n    public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException {\n        \n        while (true) {\n            JavaType next = _mapAbstractType2(config, type);\n            if (next == null) {\n                return type;\n            }\n            \n            \n            Class<?> prevCls = type.getRawClass();\n            Class<?> nextCls = next.getRawClass();\n            if ((prevCls == nextCls) || !prevCls.isAssignableFrom(nextCls)) {\n                throw new IllegalArgumentException(\"Invalid abstract type resolution from \"+type+\" to \"+next+\": latter is not a subtype of former\"); } type = next; } } private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) throws JsonMappingException {\n        Class<?> currClass = type.getRawClass();\n        if (_factoryConfig.hasAbstractTypeResolvers()) {\n            for (AbstractTypeResolver resolver : _factoryConfig.abstractTypeResolvers()) {\n                JavaType concrete = resolver.findTypeMapping(config, type);\n                if (concrete != null && concrete.getRawClass() != currClass) {\n                    return concrete;\n                }\n            }\n        }\n        return null;\n    }\n    \n    \n\n    \n    @Override\n    public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n\n        ValueInstantiator instantiator = null;\n        \n        AnnotatedClass ac = beanDesc.getClassInfo();\n        Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac);\n        if (instDef != null) {\n            instantiator = _valueInstantiatorInstance(config, ac, instDef);\n        }\n        if (instantiator == null) {\n            \n            instantiator = _findStdValueInstantiator(config, beanDesc);\n            if (instantiator == null) {\n                instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc);\n            }\n        }\n        \n        \n        if (_factoryConfig.hasValueInstantiators()) {\n            for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) {\n                instantiator = insts.findValueInstantiator(config, beanDesc, instantiator);\n                \n                if (instantiator == null) {\n\t\t    ctxt.reportMappingException(\n\t\t\t\t\t\t\"Broken registered ValueInstantiators (of type %s): returned null ValueInstantiator\",\n\t\t\t\t\t\tinsts.getClass().getName());\n                }\n            }\n        }\n\n        \n        if (instantiator.getIncompleteParameter() != null) {\n            final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter();\n            final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner();\n            throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()+\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n        }\n\n        return instantiator;\n    }\n\n    private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        if (beanDesc.getBeanClass() == JsonLocation.class) {\n            return new JsonLocationInstantiator();\n        }\n        return null;\n    }\n\n    \n    protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException {\n        CreatorCollector creators =  new CreatorCollector(beanDesc, ctxt.getConfig());\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        \n        \n        final DeserializationConfig config = ctxt.getConfig();\n        VisibilityChecker<?> vchecker = config.getDefaultVisibilityChecker();\n        vchecker = intr.findAutoDetectVisibility(beanDesc.getClassInfo(), vchecker);\n\n        \n        \n        Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorDefs = _findCreatorsFromProperties(ctxt,\n                beanDesc);\n\n        \n        _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n        \n        if (beanDesc.getType().isConcrete()) {\n            _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n        }\n        return creators.constructValueInstantiator(config);\n    }\n\n    protected Map<AnnotatedWithParams,BeanPropertyDefinition[]> _findCreatorsFromProperties(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException {\n        Map<AnnotatedWithParams,BeanPropertyDefinition[]> result = Collections.emptyMap();\n        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {\n            Iterator<AnnotatedParameter> it = propDef.getConstructorParameters();\n            while (it.hasNext()) {\n                AnnotatedParameter param = it.next();\n                AnnotatedWithParams owner = param.getOwner();\n                BeanPropertyDefinition[] defs = result.get(owner);\n                final int index = param.getIndex();\n                \n                if (defs == null) {\n                    if (result.isEmpty()) { \n                        result = new LinkedHashMap<AnnotatedWithParams,BeanPropertyDefinition[]>();\n                    }\n                    defs = new BeanPropertyDefinition[owner.getParameterCount()];\n                    result.put(owner, defs);\n                } else {\n                    if (defs[index] != null) {\n                        throw new IllegalStateException(\"Conflict: parameter #\"+index+\" of \"+owner\n                                +\" bound to more than one property; \"+defs[index]+\" vs \"+propDef);\n                    }\n                }\n                defs[index] = propDef;\n            }\n        }\n        return result;\n    }\n    \n    public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException {\n        if (instDef == null) {\n            return null;\n        }\n\n        ValueInstantiator inst;\n        \n        if (instDef instanceof ValueInstantiator) {\n            return (ValueInstantiator) instDef;\n        }\n        if (!(instDef instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned key deserializer definition of type \"\n                    +instDef.getClass().getName()\n                    +\"; expected type KeyDeserializer or Class<KeyDeserializer> instead\");\n        }\n        Class<?> instClass = (Class<?>)instDef;\n        if (ClassUtil.isBogusClass(instClass)) {\n            return null;\n        }\n        if (!ValueInstantiator.class.isAssignableFrom(instClass)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+instClass.getName()\n                    +\"; expected Class<ValueInstantiator>\");\n        }\n        HandlerInstantiator hi = config.getHandlerInstantiator();\n        if (hi != null) {\n            inst = hi.valueInstantiatorInstance(config, annotated, instClass);\n            if (inst != null) {\n                return inst;\n            }\n        }\n        return (ValueInstantiator) ClassUtil.createInstance(instClass,\n                config.canOverrideAccessModifiers());\n    }\n\n    protected void _addDeserializerConstructors (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException {\n        \n        \n        \n        AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor();\n        if (defaultCtor != null) {\n            if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) {\n                creators.setDefaultCreator(defaultCtor);\n            }\n        }\n\n        \n        List<AnnotatedConstructor> implicitCtors = null;\n        for (AnnotatedConstructor ctor : beanDesc.getConstructors()) {\n            final boolean isCreator = intr.hasCreatorAnnotation(ctor);\n            BeanPropertyDefinition[] propDefs = creatorParams.get(ctor);\n            final int argCount = ctor.getParameterCount();\n\n            \n            if (argCount == 1) {\n                BeanPropertyDefinition argDef = (propDefs == null) ? null : propDefs[0];\n                boolean useProps = _checkIfCreatorPropertyBased(intr, ctor, argDef);\n\n                if (useProps) {\n                    SettableBeanProperty[] properties = new SettableBeanProperty[1];\n                    PropertyName name = (argDef == null) ? null : argDef.getFullName();\n                    AnnotatedParameter arg = ctor.getParameter(0);\n                    properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, arg,\n                            intr.findInjectableValueId(arg));\n                    creators.addPropertyCreator(ctor, isCreator, properties);\n                } else {\n                     _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators,\n                            ctor, isCreator,\n                            vchecker.isCreatorVisible(ctor));\n                    \n                    \n                    if (argDef != null) {\n                        ((POJOPropertyBuilder) argDef).removeConstructors();\n                    }\n                }\n                \n                continue;\n            }\n\n            \n            \n            \n\n            AnnotatedParameter nonAnnotatedParam = null;\n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            int explicitNameCount = 0;\n            int implicitWithCreatorCount = 0;\n            int injectCount = 0;\n\n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = ctor.getParameter(i);\n                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i];\n                Object injectId = intr.findInjectableValueId(param);\n                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n\n                if (propDef != null && propDef.isExplicitlyNamed()) {\n                    ++explicitNameCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                if (injectId != null) {\n                    ++injectCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n                    ++explicitNameCount;\n                    continue;\n                }\n                \n                if (isCreator && (name != null && !name.isEmpty())) {\n                    ++implicitWithCreatorCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                if (nonAnnotatedParam == null) {\n                    nonAnnotatedParam = param;\n                }\n            }\n\n            final int namedCount = explicitNameCount + implicitWithCreatorCount;\n            \n            if (isCreator || (explicitNameCount > 0) || (injectCount > 0)) {\n                \n                if ((namedCount + injectCount) == argCount) {\n                    creators.addPropertyCreator(ctor, isCreator, properties);\n                    continue;\n                }\n                if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                    \n                    creators.addDelegatingCreator(ctor, isCreator, properties);\n                    continue;\n                }\n                \n                \n                \n                PropertyName impl = _findImplicitParamName(nonAnnotatedParam, intr);\n                if (impl == null || impl.isEmpty()) {\n                    \n                    int ix = nonAnnotatedParam.getIndex();\n                    if ((ix == 0) && ClassUtil.isNonStaticInnerClass(ctor.getDeclaringClass())) {\n                        throw new IllegalArgumentException(\"Non-static inner classes like \" +ctor.getDeclaringClass().getName()+\" can not use @JsonCreator for constructors\"); } throw new IllegalArgumentException(\"Argument #\"+ix +\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\"); } } if (!creators.hasDefaultCreator()) {\n                if (implicitCtors == null) {\n                    implicitCtors = new LinkedList<AnnotatedConstructor>();\n                }\n                implicitCtors.add(ctor);\n            }\n        }\n        \n        \n        if ((implicitCtors != null) && !creators.hasDelegatingCreator()\n                && !creators.hasPropertyBasedCreator()) {\n            _checkImplicitlyNamedConstructors(ctxt, beanDesc, vchecker, intr,\n                    creators, implicitCtors);\n        }\n    }\n\n    protected void _checkImplicitlyNamedConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, List<AnnotatedConstructor> implicitCtors) throws JsonMappingException {\n        AnnotatedConstructor found = null;\n        SettableBeanProperty[] foundProps = null;\n\n        \n        \n        \n\n        main_loop:\n        for (AnnotatedConstructor ctor : implicitCtors) {\n            if (!vchecker.isCreatorVisible(ctor)) {\n                continue;\n            }\n            \n            final int argCount = ctor.getParameterCount();\n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = ctor.getParameter(i);\n                final PropertyName name = _findParamName(param, intr);\n\n                \n                if (name == null || name.isEmpty()) {\n                    continue main_loop;\n                }\n                properties[i] = constructCreatorProperty(ctxt, beanDesc, name, param.getIndex(),\n                        param,  null);\n            }\n            if (found != null) { \n                found = null;\n                break;\n            }\n            found = ctor;\n            foundProps = properties;\n        }\n        \n        if (found != null) {\n            creators.addPropertyCreator(found,  false, foundProps);\n            BasicBeanDescription bbd = (BasicBeanDescription) beanDesc;\n            \n            for (SettableBeanProperty prop : foundProps) {\n                PropertyName pn = prop.getFullName();\n                if (!bbd.hasProperty(pn)) {\n                    BeanPropertyDefinition newDef = SimpleBeanPropertyDefinition.construct(\n                            ctxt.getConfig(), prop.getMember(), pn);\n                    bbd.addProperty(newDef);\n                }\n            }\n        }\n    }\n\n    protected boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr, AnnotatedWithParams creator, BeanPropertyDefinition propDef) {\n        JsonCreator.Mode mode = intr.findCreatorBinding(creator);\n\n        if (mode == JsonCreator.Mode.PROPERTIES) {\n            return true;\n        }\n        if (mode == JsonCreator.Mode.DELEGATING) {\n            return false;\n        }\n        \n        if (((propDef != null) && propDef.isExplicitlyNamed())\n                || (intr.findInjectableValueId(creator.getParameter(0)) != null)) {\n            return true;\n        }\n        if (propDef != null) {\n            \n            \n            String implName = propDef.getName();\n            if (implName != null && !implName.isEmpty()) {\n                if (propDef.couldSerialize()) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible) throws JsonMappingException {\n        \n        Class<?> type = ctor.getRawParameterType(0);\n        if (type == String.class || type == CharSequence.class) {\n            if (isCreator || isVisible) {\n                creators.addStringCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == int.class || type == Integer.class) {\n            if (isCreator || isVisible) {\n                creators.addIntCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == long.class || type == Long.class) {\n            if (isCreator || isVisible) {\n                creators.addLongCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == double.class || type == Double.class) {\n            if (isCreator || isVisible) {\n                creators.addDoubleCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == boolean.class || type == Boolean.class) {\n            if (isCreator || isVisible) {\n                creators.addBooleanCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        \n        if (isCreator) {\n            creators.addDelegatingCreator(ctor, isCreator, null);\n            return true;\n        }\n        return false;\n    }\n\n    protected void _addDeserializerFactoryMethods (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            final boolean isCreator = intr.hasCreatorAnnotation(factory);\n            final int argCount = factory.getParameterCount();\n            \n            if (argCount == 0) {\n                if (isCreator) {\n                    creators.setDefaultCreator(factory);\n                }\n                continue;\n            }\n\n            final BeanPropertyDefinition[] propDefs = creatorParams.get(factory);\n            \n            if (argCount == 1) {\n                BeanPropertyDefinition argDef = (propDefs == null) ? null : propDefs[0];\n                boolean useProps = _checkIfCreatorPropertyBased(intr, factory, argDef);\n                if (!useProps) { \n                     _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators,\n                            factory, isCreator);\n                    \n                    \n                    if (argDef != null) {\n                        ((POJOPropertyBuilder) argDef).removeConstructors();\n                    }\n                    continue;\n                }\n                \n            } else {\n                \n                if (!isCreator) {\n                    continue;\n                }\n            }\n            \n            AnnotatedParameter nonAnnotatedParam = null;            \n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            int implicitNameCount = 0;\n            int explicitNameCount = 0;\n            int injectCount = 0;\n            \n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = factory.getParameter(i);\n                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i];\n                Object injectId = intr.findInjectableValueId(param);\n                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n\n                if (propDef != null && propDef.isExplicitlyNamed()) {\n                    ++explicitNameCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                if (injectId != null) {\n                    ++injectCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n                    ++implicitNameCount;\n                    continue;\n                }\n                \n                if (isCreator) {\n                    if (name != null && !name.isEmpty()) {\n                        ++implicitNameCount;\n                        properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                        continue;\n                    }\n                }\n                \n                \n                if (nonAnnotatedParam == null) {\n                    nonAnnotatedParam = param;\n                }\n            }\n            final int namedCount = explicitNameCount + implicitNameCount;\n            \n            \n            if (isCreator || explicitNameCount > 0 || injectCount > 0) {\n                \n                if ((namedCount + injectCount) == argCount) {\n                    creators.addPropertyCreator(factory, isCreator, properties);\n                } else if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                    \n                    creators.addDelegatingCreator(factory, isCreator, properties);\n                } else { \n                    throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()\n                            +\" of factory method \"+factory+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n                }\n            }\n        }\n    }\n\n    protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException {\n        Class<?> type = factory.getRawParameterType(0);\n        \n        if (type == String.class || type == CharSequence.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addStringCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == int.class || type == Integer.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addIntCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == long.class || type == Long.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addLongCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == double.class || type == Double.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addDoubleCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == boolean.class || type == Boolean.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addBooleanCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (isCreator) {\n            creators.addDelegatingCreator(factory, isCreator, null);\n            return true;\n        }\n        return false;\n    }\n\n    \n    protected SettableBeanProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, PropertyName name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        PropertyMetadata metadata;\n        {\n            if (intr == null) {\n                metadata = PropertyMetadata.STD_REQUIRED_OR_OPTIONAL;\n            } else {\n                Boolean b = intr.hasRequiredMarker(param);\n                boolean req = (b != null && b.booleanValue());\n                String desc = intr.findPropertyDescription(param);\n                Integer idx = intr.findPropertyIndex(param);\n                String def = intr.findPropertyDefaultValue(param);\n                metadata = PropertyMetadata.construct(req, desc, idx, def);\n            }\n        }\n        JavaType type = resolveMemberAndTypeAnnotations(ctxt, param, param.getType());\n        BeanProperty.Std property = new BeanProperty.Std(name, type,\n                intr.findWrapperName(param),\n                beanDesc.getClassAnnotations(), param, metadata);\n        \n        TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler();\n        \n        if (typeDeser == null) {\n            typeDeser = findTypeDeserializer(config, type);\n        }\n        \n        \n        SettableBeanProperty prop = new CreatorProperty(name, type, property.getWrapperName(),\n                typeDeser, beanDesc.getClassAnnotations(), param, index, injectableValueId,\n                metadata);\n        JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, param);\n        if (deser == null) {\n            deser = type.getValueHandler();\n        }\n        if (deser != null) {\n            \n            deser = ctxt.handlePrimaryContextualization(deser, prop, type);\n            prop = prop.withValueDeserializer(deser);\n        }\n        return prop;\n    }\n\n    protected PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr) {\n        if (param != null && intr != null) {\n            PropertyName name = intr.findNameForDeserialization(param);\n            if (name != null) {\n                return name;\n            }\n            \n            \n\n            String str = intr.findImplicitPropertyName(param);\n            if (str != null && !str.isEmpty()) {\n                return PropertyName.construct(str);\n            }\n        }\n        return null;\n    }\n\n    protected PropertyName _findImplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr) {\n        String str = intr.findImplicitPropertyName(param);\n        if (str != null && !str.isEmpty()) {\n            return PropertyName.construct(str);\n        }\n        return null;\n    }\n\n    @Deprecated \n    protected PropertyName _findExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr) {\n        if (param != null && intr != null) {\n            return intr.findNameForDeserialization(param);\n        }\n        return null;\n    }\n\n    @Deprecated \n    protected boolean _hasExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr) {\n        if (param != null && intr != null) {\n            PropertyName n = intr.findNameForDeserialization(param);\n            return (n != null) && n.hasSimpleName();\n        }\n        return false;\n    }\n\n    \n        \n    @Override\n    public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        JavaType elemType = type.getContentType();\n        \n        \n        JsonDeserializer<Object> contentDeser = elemType.getValueHandler();\n        \n        TypeDeserializer elemTypeDeser = elemType.getTypeHandler();\n        \n        if (elemTypeDeser == null) {\n            elemTypeDeser = findTypeDeserializer(config, elemType);\n        }\n        \n        JsonDeserializer<?>  deser = _findCustomArrayDeserializer(type,\n                config, beanDesc, elemTypeDeser, contentDeser);\n        if (deser == null) {\n            if (contentDeser == null) {\n                Class<?> raw = elemType.getRawClass();\n                if (elemType.isPrimitive()) {\n                    return PrimitiveArrayDeserializers.forType(raw);\n                } else if (raw == String.class) {\n                    return StringArrayDeserializer.instance;\n                }\n            }\n            deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser);\n        }\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    \n\n    @Override\n    public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException {\n        JavaType contentType = type.getContentType();\n        \n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        \n        JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type,\n                config, beanDesc, contentTypeDeser, contentDeser);\n        if (deser == null) {\n            Class<?> collectionClass = type.getRawClass();\n            if (contentDeser == null) { \n                \n                if (EnumSet.class.isAssignableFrom(collectionClass)) {\n                    deser = new EnumSetDeserializer(contentType, null);\n                }\n            }\n        }\n\n        \n        if (deser == null) {\n            if (type.isInterface() || type.isAbstract()) {\n                CollectionType implType = _mapAbstractCollectionType(type, config);\n                if (implType == null) {\n                    \n                    if (type.getTypeHandler() == null) {\n                        throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Collection type \"+type);\n                    }\n                    deser = AbstractDeserializer.constructForNonPOJO(beanDesc);\n                } else {\n                    type = implType;\n                    \n                    beanDesc = config.introspectForCreation(type);\n                }\n            }\n            if (deser == null) {\n                ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n                if (!inst.canCreateUsingDefault()) {\n                    \n                    if (type.getRawClass() == ArrayBlockingQueue.class) {\n                        return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst);\n                    }\n                }\n                \n                if (contentType.getRawClass() == String.class) {\n                    \n                    deser = new StringCollectionDeserializer(type, contentDeser, inst);\n                } else {\n                    deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst);\n                }\n            }\n        }\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config) {\n        Class<?> collectionClass = type.getRawClass();\n        collectionClass = _collectionFallbacks.get(collectionClass.getName());\n        if (collectionClass == null) {\n            return null;\n        }\n        return (CollectionType) config.constructSpecializedType(type, collectionClass);\n    }\n    \n    \n    @Override\n    public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException {\n        JavaType contentType = type.getContentType();\n        \n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomCollectionLikeDeserializer(type, config, beanDesc,\n                contentTypeDeser, contentDeser);\n        if (deser != null) {\n            \n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyCollectionLikeDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    \n\n    @Override\n    public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        JavaType keyType = type.getKeyType();\n        JavaType contentType = type.getContentType();\n        \n        \n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();\n\n        \n        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n\n        \n        JsonDeserializer<?> deser = _findCustomMapDeserializer(type, config, beanDesc,\n                keyDes, contentTypeDeser, contentDeser);\n\n        if (deser == null) {\n            \n            Class<?> mapClass = type.getRawClass();\n            if (EnumMap.class.isAssignableFrom(mapClass)) {\n                Class<?> kt = keyType.getRawClass();\n                if (kt == null || !kt.isEnum()) {\n                    throw new IllegalArgumentException(\"Can not construct EnumMap; generic (key) type not available\");\n                }\n                deser = new EnumMapDeserializer(type, null, contentDeser, contentTypeDeser);\n            }\n\n            \n    \n            \n            if (deser == null) {\n                if (type.isInterface() || type.isAbstract()) {\n                    @SuppressWarnings(\"rawtypes\")\n                    Class<? extends Map> fallback = _mapFallbacks.get(mapClass.getName());\n                    if (fallback != null) {\n                        mapClass = fallback;\n                        type = (MapType) config.constructSpecializedType(type, mapClass);\n                        \n                        beanDesc = config.introspectForCreation(type);\n                    } else {\n                        \n                        if (type.getTypeHandler() == null) {\n                            throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Map type \"+type);\n                        }\n                        deser = AbstractDeserializer.constructForNonPOJO(beanDesc);\n                    }\n                }\n                if (deser == null) {\n                    ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n                    \n                    \n                    \n                    \n                    MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser);\n                    JsonIgnoreProperties.Value ignorals = config.getDefaultPropertyIgnorals(Map.class,\n                            beanDesc.getClassInfo());\n                    Set<String> ignored = (ignorals == null) ? null\n                            : ignorals.findIgnoredForDeserialization();\n                    md.setIgnorableProperties(ignored);\n                    deser = md;\n                }\n            }\n        }\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyMapDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    \n    @Override\n    public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException {\n        JavaType keyType = type.getKeyType();\n        JavaType contentType = type.getContentType();\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        \n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();\n        \n        \n        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n        \n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        \n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomMapLikeDeserializer(type, config,\n                beanDesc, keyDes, contentTypeDeser, contentDeser);\n        if (deser != null) {\n            \n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyMapLikeDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    \n    \n    \n    @Override\n    public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        final Class<?> enumClass = type.getRawClass();\n        \n        JsonDeserializer<?> deser = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n\n        if (deser == null) {\n            ValueInstantiator valueInstantiator = _constructDefaultValueInstantiator(ctxt, beanDesc);\n            SettableBeanProperty[] creatorProps = (valueInstantiator == null) ? null\n                    : valueInstantiator.getFromObjectArguments(ctxt.getConfig());\n            \n            for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n                if (ctxt.getAnnotationIntrospector().hasCreatorAnnotation(factory)) {\n                    if (factory.getParameterCount() == 0) { \n                        deser = EnumDeserializer.deserializerForNoArgsCreator(config, enumClass, factory);\n                        break;\n                    }\n                    Class<?> returnType = factory.getRawReturnType();\n                    \n                    if (returnType.isAssignableFrom(enumClass)) {\n                        deser = EnumDeserializer.deserializerForCreator(config, enumClass, factory, valueInstantiator, creatorProps);\n                        break;\n                    }\n                }\n            }\n           \n            \n            if (deser == null) {\n                deser = new EnumDeserializer(constructEnumResolver(enumClass,\n                        config, beanDesc.findJsonValueMethod()));\n            }\n        }\n\n        \n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyEnumDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    @Override\n    public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException {\n        @SuppressWarnings(\"unchecked\")\n        Class<? extends JsonNode> nodeClass = (Class<? extends JsonNode>) nodeType.getRawClass();\n        \n        JsonDeserializer<?> custom = _findCustomTreeNodeDeserializer(nodeClass, config,\n                beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        return JsonNodeDeserializer.getDeserializer(nodeClass);\n    }\n\n    @Override\n    public JsonDeserializer<?> createReferenceDeserializer(DeserializationContext ctxt, ReferenceType type, BeanDescription beanDesc) throws JsonMappingException {\n        JavaType contentType = type.getContentType();\n        \n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        if (contentTypeDeser == null) { \n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomReferenceDeserializer(type, config, beanDesc,\n                contentTypeDeser, contentDeser);\n\n        if (deser == null) {\n            \n            if (AtomicReference.class.isAssignableFrom(type.getRawClass())) {\n                return new AtomicReferenceDeserializer(type, contentTypeDeser, contentDeser);\n            }\n        }\n        if (deser != null) {\n            \n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyReferenceDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    \n\n    @Override\n    public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n        BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n        AnnotatedClass ac = bean.getClassInfo();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n\n        \n        Collection<NamedType> subtypes = null;\n        if (b == null) {\n            b = config.getDefaultTyper(baseType);\n            if (b == null) {\n                return null;\n            }\n        } else {\n            subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n        }\n        \n        \n        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n            JavaType defaultType = mapAbstractType(config, baseType);\n            if (defaultType != null && defaultType.getRawClass() != baseType.getRawClass()) {\n                b = b.defaultImpl(defaultType.getRawClass());\n            }\n        }\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    }\n\n    \n    protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        return OptionalHandlerFactory.instance.findDeserializer(type, ctxt.getConfig(), beanDesc);\n    }\n    \n    \n    \n    @Override\n    public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        KeyDeserializer deser = null;\n        if (_factoryConfig.hasKeyDeserializers()) {\n            BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n            for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n                deser = d.findKeyDeserializer(type, config, beanDesc);\n                if (deser != null) {\n                    break;\n                }\n            }\n        }\n        \n        if (deser == null) {\n            if (type.isEnumType()) {\n                deser = _createEnumKeyDeserializer(ctxt, type);\n            } else {\n                deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n            }\n        }\n        \n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyKeyDeserializer(config, type, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        Class<?> enumClass = type.getRawClass();\n\n        BeanDescription beanDesc = config.introspect(type);\n        \n        KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n            return des;\n        } else {\n            \n            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n            if (custom != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n            }\n            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n            if (valueDesForKey != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);\n            }\n        }\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n        \n        final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (ai.hasCreatorAnnotation(factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n                    Class<?> returnType = factory.getRawReturnType();\n                    \n                    if (returnType.isAssignableFrom(enumClass)) {\n                        \n                        if (factory.getRawParameterType(0) != String.class) {\n                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n                        }\n                        if (config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(factory.getMember(),\n                                    ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                        }\n                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                    }\n                }\n                throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n                        +enumClass.getName()+\")\");\n            }\n        }\n        \n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }\n\n    \n\n    \n    public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, annotated, baseType);        \n        \n        if (b == null) {\n            return findTypeDeserializer(config, baseType);\n        }\n        \n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(\n                config, annotated, baseType);\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    }\n    \n        \n    public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, propertyEntity, containerType);        \n        JavaType contentType = containerType.getContentType();\n        \n        if (b == null) {\n            return findTypeDeserializer(config, contentType);\n        }\n        \n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(\n                config, propertyEntity, contentType);\n        return b.buildTypeDeserializer(config, contentType, subtypes);\n    }\n\n    \n    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n        Class<?> rawType = type.getRawClass();\n        \n        if (rawType == CLASS_OBJECT) {\n            \n            DeserializationConfig config = ctxt.getConfig();\n            JavaType lt, mt;\n            \n            if (_factoryConfig.hasAbstractTypeResolvers()) {\n                lt = _findRemappedType(config, List.class);\n                mt = _findRemappedType(config, Map.class);\n            } else {\n                lt = mt = null;\n            }\n            return new UntypedObjectDeserializer(lt, mt);\n        }\n        if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n            return StringDeserializer.instance;\n        }\n        if (rawType == CLASS_ITERABLE) {\n            \n            TypeFactory tf = ctxt.getTypeFactory();\n            JavaType[] tps = tf.findTypeParameters(type, CLASS_ITERABLE);\n            JavaType elemType = (tps == null || tps.length != 1) ? TypeFactory.unknownType() : tps[0];\n            CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n            \n            return createCollectionDeserializer(ctxt, ct, beanDesc);\n        }\n        if (rawType == CLASS_MAP_ENTRY) {\n            \n            JavaType kt = type.containedType(0);\n            if (kt == null) {\n                kt = TypeFactory.unknownType();\n            }\n            JavaType vt = type.containedType(1);\n            if (vt == null) {\n                vt = TypeFactory.unknownType();\n            }\n            TypeDeserializer vts = (TypeDeserializer) vt.getTypeHandler();\n            if (vts == null) {\n                vts = findTypeDeserializer(ctxt.getConfig(), vt);\n            }\n            JsonDeserializer<Object> valueDeser = vt.getValueHandler();\n            KeyDeserializer keyDes = (KeyDeserializer) kt.getValueHandler();\n            return new MapEntryDeserializer(type, keyDes, valueDeser, vts);\n        }\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            \n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n            }\n            if (deser != null) {\n                return deser;\n            }\n        }\n        \n        if (rawType == TokenBuffer.class) {\n            return new TokenBufferDeserializer();\n        }\n        JsonDeserializer<?> deser = findOptionalStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n        return JdkDeserializers.find(rawType, clsName);\n    }\n\n    protected JavaType _findRemappedType(DeserializationConfig config, Class<?> rawType) throws JsonMappingException {\n        JavaType type = mapAbstractType(config, config.constructType(rawType));\n        return (type == null || type.hasRawClass(rawType)) ? null : type;\n    }\n\n    \n\n    protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomReferenceDeserializer(ReferenceType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer contentTypeDeserializer, JsonDeserializer<?> contentDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findReferenceDeserializer(type, config, beanDesc,\n                    contentTypeDeserializer, contentDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findBeanDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return (JsonDeserializer<Object>) deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findArrayDeserializer(type, config,\n                    beanDesc, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findCollectionDeserializer(type, config, beanDesc,\n                    elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findCollectionLikeDeserializer(type, config, beanDesc,\n                    elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findMapDeserializer(type, config, beanDesc,\n                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findMapLikeDeserializer(type, config, beanDesc,\n                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    \n    \n    \n    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n            Object deserDef = intr.findDeserializer(ann);\n            if (deserDef != null) {\n                return ctxt.deserializerInstance(ann, deserDef);\n            }\n        }\n        return null;\n    }\n\n    \n    protected KeyDeserializer findKeyDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n            Object deserDef = intr.findKeyDeserializer(ann);\n            if (deserDef != null) {\n                return ctxt.keyDeserializerInstance(ann, deserDef);\n            }\n        }\n        return null;\n    }\n\n    \n    protected JavaType resolveMemberAndTypeAnnotations(DeserializationContext ctxt, AnnotatedMember member, JavaType type) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr == null) {\n            return type;\n        }\n\n        \n        \n\n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            if (keyType != null) {\n                Object kdDef = intr.findKeyDeserializer(member);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); \n                }\n            }\n        }\n\n        if (type.hasContentType()) { \n            Object cdDef = intr.findContentDeserializer(member);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef);\n            if (cd != null) {\n                type = type.withContentValueHandler(cd);\n            }\n            TypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(\n                    ctxt.getConfig(), type, (AnnotatedMember) member);            \t\n            if (contentTypeDeser != null) {\n                type = type.withContentTypeHandler(contentTypeDeser);\n            }\n        }\n        TypeDeserializer valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(),\n                    type, (AnnotatedMember) member);\n        if (valueTypeDeser != null) {\n            type = type.withTypeHandler(valueTypeDeser);\n        }\n\n        \n\n        \n        \n        \n        type = intr.refineDeserializationType(ctxt.getConfig(), member, type);\n        return type;\n    }\n\n    protected EnumResolver constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMethod jsonValueMethod) {\n        if (jsonValueMethod != null) {\n            Method accessor = jsonValueMethod.getAnnotated();\n            if (config.canOverrideAccessModifiers()) {\n                ClassUtil.checkAndFixAccess(accessor, config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n            return EnumResolver.constructUnsafeUsingMethod(enumClass, accessor, config.getAnnotationIntrospector());\n        }\n        \n        \n        return EnumResolver.constructUnsafe(enumClass, config.getAnnotationIntrospector());\n    }\n\n    \n    \n    \n    @Deprecated\n    protected JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr == null) {\n            return type;\n        }\n\n        \n        \n        \n        return intr.refineDeserializationType(ctxt.getConfig(), a, type);\n    }\n\n    \n    @Deprecated \n    protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException {\n        return resolveMemberAndTypeAnnotations(ctxt, member, type);\n    }\n\n    \n    @Deprecated \n    protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType) {\n        if (enumType == null) {\n            return null;\n        }\n        BeanDescription beanDesc = config.introspect(enumType);\n        return beanDesc.findJsonValueMethod();\n    }\n}\n",
      "buggy_signatures": [
        "protected final DeserializerFactoryConfig _factoryConfig; protected BasicDeserializerFactory(DeserializerFactoryConfig config)",
        "public DeserializerFactoryConfig getFactoryConfig()",
        "protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); @Override public final DeserializerFactory withAdditionalDeserializers(Deserializers additional)",
        "public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional)",
        "public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier)",
        "public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver)",
        "public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators)",
        "public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException",
        "public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException",
        "private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException",
        "protected Map<AnnotatedWithParams,BeanPropertyDefinition[]> _findCreatorsFromProperties(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException",
        "public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException",
        "protected void _addDeserializerConstructors (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException",
        "static inner classes like \" +ctor.getDeclaringClass().getName()+\" can not use @JsonCreator for constructors\"); } throw new IllegalArgumentException(\"Argument #\"+ix +\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\"); } } if (!creators.hasDefaultCreator())",
        "protected void _checkImplicitlyNamedConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, List<AnnotatedConstructor> implicitCtors) throws JsonMappingException",
        "protected boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr, AnnotatedWithParams creator, BeanPropertyDefinition propDef)",
        "protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible) throws JsonMappingException",
        "protected void _addDeserializerFactoryMethods (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException",
        "protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException",
        "protected SettableBeanProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, PropertyName name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException",
        "protected PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr)",
        "protected PropertyName _findImplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)",
        "protected PropertyName _findExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)",
        "protected boolean _hasExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)",
        "public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config)",
        "public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createReferenceDeserializer(DeserializationContext ctxt, ReferenceType type, BeanDescription beanDesc) throws JsonMappingException",
        "public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException",
        "protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException",
        "private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException",
        "public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException",
        "public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException",
        "public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected JavaType _findRemappedType(DeserializationConfig config, Class<?> rawType) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomReferenceDeserializer(ReferenceType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer contentTypeDeserializer, JsonDeserializer<?> contentDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException",
        "protected KeyDeserializer findKeyDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException",
        "protected JavaType resolveMemberAndTypeAnnotations(DeserializationContext ctxt, AnnotatedMember member, JavaType type) throws JsonMappingException",
        "protected EnumResolver constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMethod jsonValueMethod)",
        "protected JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException",
        "protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException",
        "protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType)"
      ],
      "fixed_signatures": [
        "protected final DeserializerFactoryConfig _factoryConfig; protected BasicDeserializerFactory(DeserializerFactoryConfig config)",
        "public DeserializerFactoryConfig getFactoryConfig()",
        "protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); @Override public final DeserializerFactory withAdditionalDeserializers(Deserializers additional)",
        "public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional)",
        "public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier)",
        "public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver)",
        "public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators)",
        "public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException",
        "public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException",
        "private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException",
        "protected Map<AnnotatedWithParams,BeanPropertyDefinition[]> _findCreatorsFromProperties(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException",
        "public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException",
        "protected void _addDeserializerConstructors (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException",
        "static inner classes like \" +ctor.getDeclaringClass().getName()+\" can not use @JsonCreator for constructors\"); } throw new IllegalArgumentException(\"Argument #\"+ix +\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\"); } } if (!creators.hasDefaultCreator())",
        "protected void _checkImplicitlyNamedConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, List<AnnotatedConstructor> implicitCtors) throws JsonMappingException",
        "protected boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr, AnnotatedWithParams creator, BeanPropertyDefinition propDef)",
        "protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible) throws JsonMappingException",
        "protected void _addDeserializerFactoryMethods (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams) throws JsonMappingException",
        "protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException",
        "protected SettableBeanProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, PropertyName name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException",
        "protected PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr)",
        "protected PropertyName _findImplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)",
        "protected PropertyName _findExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)",
        "protected boolean _hasExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)",
        "public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config)",
        "public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException",
        "public JsonDeserializer<?> createReferenceDeserializer(DeserializationContext ctxt, ReferenceType type, BeanDescription beanDesc) throws JsonMappingException",
        "public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException",
        "protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException",
        "private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException",
        "public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException",
        "public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException",
        "public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException",
        "protected JavaType _findRemappedType(DeserializationConfig config, Class<?> rawType) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomReferenceDeserializer(ReferenceType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer contentTypeDeserializer, JsonDeserializer<?> contentDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException",
        "protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException",
        "protected KeyDeserializer findKeyDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException",
        "protected JavaType resolveMemberAndTypeAnnotations(DeserializationContext ctxt, AnnotatedMember member, JavaType type) throws JsonMappingException",
        "protected EnumResolver constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMethod jsonValueMethod)",
        "protected JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException",
        "protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException",
        "protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType)"
      ],
      "methods": [
        {
          "buggy_method": "  public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n  final DeserializationConfig config = ctxt.getConfig();\n  KeyDeserializer deser = null;\n  if (_factoryConfig.hasKeyDeserializers()) {\n  BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n  for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n  deser = d.findKeyDeserializer(type, config, beanDesc);\n  if (deser != null) {\n  break;\n  }\n  }\n  }\n  \n  if (deser == null) {\n  if (type.isEnumType()) {\n  return _createEnumKeyDeserializer(ctxt, type);\n  }\n  deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n  }\n  \n  if (deser != null) {\n  if (_factoryConfig.hasDeserializerModifiers()) {\n  for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n  deser = mod.modifyKeyDeserializer(config, type, deser);\n  }\n  }\n  }\n  return deser;\n  }",
          "fixed_method": "  public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n  final DeserializationConfig config = ctxt.getConfig();\n  KeyDeserializer deser = null;\n  if (_factoryConfig.hasKeyDeserializers()) {\n  BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n  for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n  deser = d.findKeyDeserializer(type, config, beanDesc);\n  if (deser != null) {\n  break;\n  }\n  }\n  }\n  \n  if (deser == null) {\n  if (type.isEnumType()) {\n  deser = _createEnumKeyDeserializer(ctxt, type);\n  } else {\n  deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n  }\n  }\n  \n  if (deser != null) {\n  if (_factoryConfig.hasDeserializerModifiers()) {\n  for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n  deser = mod.modifyKeyDeserializer(config, type, deser);\n  }\n  }\n  }\n  return deser;\n  }",
          "diff": [
            "@@ -1400,9 +1400,10 @@",
            "         // the only non-standard thing is this:\n",
            "         if (deser == null) {\n",
            "             if (type.isEnumType()) {\n",
            "-                return _createEnumKeyDeserializer(ctxt, type);\n",
            "-            }\n",
            "-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n",
            "+                deser = _createEnumKeyDeserializer(ctxt, type);\n",
            "+            } else {\n",
            "+                deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n",
            "+            }\n",
            "         }\n",
            "         // and then post-processing\n",
            "         if (deser != null) {\n"
          ],
          "changed_lines": 7
        }
      ]
    }
  ]
}
