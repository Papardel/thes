{
  "bug_id": "67",
  "failed_tests": {
    "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest": [
      {
        "methodName": "testQuinticMin",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<-0.27195612846834> but was:<-0.27194301946870036>",
        "fail_line": "        assertEquals(-0.27195612846834, minimizer.getResult(), 1.0e-13);",
        "test_source": "  public void testQuinticMin() throws MathException {\n  // The quintic function has zeros at 0, +-0.5 and +-1.\n  // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n  UnivariateRealFunction f = new QuinticFunction();\n  UnivariateRealOptimizer underlying = new BrentOptimizer();\n  JDKRandomGenerator g = new JDKRandomGenerator();\n  g.setSeed(4312000053l);\n  MultiStartUnivariateRealOptimizer minimizer =\n  new MultiStartUnivariateRealOptimizer(underlying, 5, g);\n  minimizer.setAbsoluteAccuracy(10 * minimizer.getAbsoluteAccuracy());\n  minimizer.setRelativeAccuracy(10 * minimizer.getRelativeAccuracy());\n\n  try {\n  minimizer.getOptima();\n  fail(\"an exception should have been thrown\");\n  } catch (IllegalStateException ise) {\n  // expected\n  } catch (Exception e) {\n  fail(\"wrong exception caught\");\n  }\n  try {\n  minimizer.getOptimaValues();\n  fail(\"an exception should have been thrown\");\n  } catch (IllegalStateException ise) {\n  // expected\n  } catch (Exception e) {\n  fail(\"wrong exception caught\");\n  }\n\n  assertEquals(-0.27195612846834, minimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2), 1.0e-13);\n  assertEquals(-0.27195612846834, minimizer.getResult(), 1.0e-13);\n  assertEquals(-0.04433426954946, minimizer.getFunctionValue(), 1.0e-13);\n\n  double[] optima = minimizer.getOptima();\n  double[] optimaValues = minimizer.getOptimaValues();\n  for (int i = 0; i < optima.length; ++i) {\n  assertEquals(f.value(optima[i]), optimaValues[i], 1.0e-10);\n  }\n\n  assertTrue(minimizer.getEvaluations()  >= 510);\n  assertTrue(minimizer.getEvaluations()  <= 530);\n  assertTrue(minimizer.getIterationCount() >= 150);\n  assertTrue(minimizer.getIterationCount() <= 170);\n\n  }",
        "stack": [
          "MultiStartUnivariateRealOptimizerTest.testQuinticMin line 86"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java",
      "buggy_full_code": "\n\npackage org.apache.commons.math.optimization;\n\nimport org.apache.commons.math.ConvergenceException;\nimport org.apache.commons.math.FunctionEvaluationException;\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.analysis.UnivariateRealFunction;\nimport org.apache.commons.math.random.RandomGenerator;\nimport org.apache.commons.math.util.LocalizedFormats;\n\n\npublic class MultiStartUnivariateRealOptimizer implements UnivariateRealOptimizer { private static final long serialVersionUID = 5983375963110961019L; private final UnivariateRealOptimizer optimizer; private int maxIterations; private int maxEvaluations; private int totalIterations; private int totalEvaluations; private int starts; private RandomGenerator generator; private double[] optima; private double[] optimaValues; public MultiStartUnivariateRealOptimizer(final UnivariateRealOptimizer optimizer, final int starts, final RandomGenerator generator) {\n        this.optimizer        = optimizer;\n        this.totalIterations  = 0;\n        this.starts           = starts;\n        this.generator        = generator;\n        this.optima           = null;\n        setMaximalIterationCount(Integer.MAX_VALUE);\n        setMaxEvaluations(Integer.MAX_VALUE);\n    }\n\n    \n    public double getFunctionValue() {\n        return optimizer.getFunctionValue();\n    }\n\n    \n    public double getResult() {\n        return optimizer.getResult();\n    }\n\n    \n    public double getAbsoluteAccuracy() {\n        return optimizer.getAbsoluteAccuracy();\n    }\n\n    \n    public int getIterationCount() {\n        return totalIterations;\n    }\n\n    \n    public int getMaximalIterationCount() {\n        return maxIterations;\n    }\n\n    \n    public int getMaxEvaluations() {\n        return maxEvaluations;\n    }\n\n    \n    public int getEvaluations() {\n        return totalEvaluations;\n    }\n\n    \n    public double getRelativeAccuracy() {\n        return optimizer.getRelativeAccuracy();\n    }\n\n    \n    public void resetAbsoluteAccuracy() {\n        optimizer.resetAbsoluteAccuracy();\n    }\n\n    \n    public void resetMaximalIterationCount() {\n        optimizer.resetMaximalIterationCount();\n    }\n\n    \n    public void resetRelativeAccuracy() {\n        optimizer.resetRelativeAccuracy();\n    }\n\n    \n    public void setAbsoluteAccuracy(double accuracy) {\n        optimizer.setAbsoluteAccuracy(accuracy);\n    }\n\n    \n    public void setMaximalIterationCount(int count) {\n        this.maxIterations = count;\n    }\n\n    \n    public void setMaxEvaluations(int maxEvaluations) {\n        this.maxEvaluations = maxEvaluations;\n    }\n\n    \n    public void setRelativeAccuracy(double accuracy) {\n        optimizer.setRelativeAccuracy(accuracy);\n    }\n\n    \n    public double[] getOptima() throws IllegalStateException {\n        if (optima == null) {\n            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n        }\n        return optima.clone();\n    }\n\n    \n    public double[] getOptimaValues() throws IllegalStateException {\n        if (optimaValues == null) {\n            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n        }\n        return optimaValues.clone();\n    }\n\n    \n    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws ConvergenceException, FunctionEvaluationException {\n\n        optima           = new double[starts];\n        optimaValues     = new double[starts];\n        totalIterations  = 0;\n        totalEvaluations = 0;\n\n        \n        for (int i = 0; i < starts; ++i) {\n\n            try {\n                optimizer.setMaximalIterationCount(maxIterations - totalIterations);\n                optimizer.setMaxEvaluations(maxEvaluations - totalEvaluations);\n                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n                optima[i]       = optimizer.optimize(f, goalType,\n                                                     Math.min(bound1, bound2),\n                                                     Math.max(bound1, bound2));\n                optimaValues[i] = optimizer.getFunctionValue();\n            } catch (FunctionEvaluationException fee) {\n                optima[i]       = Double.NaN;\n                optimaValues[i] = Double.NaN;\n            } catch (ConvergenceException ce) {\n                optima[i]       = Double.NaN;\n                optimaValues[i] = Double.NaN;\n            }\n\n            totalIterations  += optimizer.getIterationCount();\n            totalEvaluations += optimizer.getEvaluations();\n\n        }\n\n        \n        int lastNaN = optima.length;\n        for (int i = 0; i < lastNaN; ++i) {\n            if (Double.isNaN(optima[i])) {\n                optima[i] = optima[--lastNaN];\n                optima[lastNaN + 1] = Double.NaN;\n                optimaValues[i] = optimaValues[--lastNaN];\n                optimaValues[lastNaN + 1] = Double.NaN;\n            }\n        }\n\n        double currX = optima[0];\n        double currY = optimaValues[0];\n        for (int j = 1; j < lastNaN; ++j) {\n            final double prevY = currY;\n            currX = optima[j];\n            currY = optimaValues[j];\n            if ((goalType == GoalType.MAXIMIZE) ^ (currY < prevY)) {\n                \n                int i = j - 1;\n                double mIX = optima[i];\n                double mIY = optimaValues[i];\n                while ((i >= 0) && ((goalType == GoalType.MAXIMIZE) ^ (currY < mIY))) {\n                    optima[i + 1]       = mIX;\n                    optimaValues[i + 1] = mIY;\n                    if (i-- != 0) {\n                        mIX = optima[i];\n                        mIY = optimaValues[i];\n                    } else {\n                        mIX = Double.NaN;\n                        mIY = Double.NaN;\n                    }\n                }\n                optima[i + 1]       = currX;\n                optimaValues[i + 1] = currY;\n                currX = optima[j];\n                currY = optimaValues[j];\n            }\n        }\n\n        if (Double.isNaN(optima[0])) {\n            throw new OptimizationException(\n                    LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n                    starts);\n        }\n\n        \n        return optima[0];\n\n    }\n\n    \n    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws ConvergenceException, FunctionEvaluationException {\n        return optimize(f, goalType, min, max);\n    }\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.math.optimization;\n\nimport org.apache.commons.math.ConvergenceException;\nimport org.apache.commons.math.FunctionEvaluationException;\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.analysis.UnivariateRealFunction;\nimport org.apache.commons.math.random.RandomGenerator;\nimport org.apache.commons.math.util.LocalizedFormats;\n\n\npublic class MultiStartUnivariateRealOptimizer implements UnivariateRealOptimizer { private static final long serialVersionUID = 5983375963110961019L; private final UnivariateRealOptimizer optimizer; private int maxIterations; private int maxEvaluations; private int totalIterations; private int totalEvaluations; private int starts; private RandomGenerator generator; private double[] optima; private double[] optimaValues; public MultiStartUnivariateRealOptimizer(final UnivariateRealOptimizer optimizer, final int starts, final RandomGenerator generator) {\n        this.optimizer        = optimizer;\n        this.totalIterations  = 0;\n        this.starts           = starts;\n        this.generator        = generator;\n        this.optima           = null;\n        setMaximalIterationCount(Integer.MAX_VALUE);\n        setMaxEvaluations(Integer.MAX_VALUE);\n    }\n\n    \n    public double getFunctionValue() {\n        return optimaValues[0];\n    }\n\n    \n    public double getResult() {\n        return optima[0];\n    }\n\n    \n    public double getAbsoluteAccuracy() {\n        return optimizer.getAbsoluteAccuracy();\n    }\n\n    \n    public int getIterationCount() {\n        return totalIterations;\n    }\n\n    \n    public int getMaximalIterationCount() {\n        return maxIterations;\n    }\n\n    \n    public int getMaxEvaluations() {\n        return maxEvaluations;\n    }\n\n    \n    public int getEvaluations() {\n        return totalEvaluations;\n    }\n\n    \n    public double getRelativeAccuracy() {\n        return optimizer.getRelativeAccuracy();\n    }\n\n    \n    public void resetAbsoluteAccuracy() {\n        optimizer.resetAbsoluteAccuracy();\n    }\n\n    \n    public void resetMaximalIterationCount() {\n        optimizer.resetMaximalIterationCount();\n    }\n\n    \n    public void resetRelativeAccuracy() {\n        optimizer.resetRelativeAccuracy();\n    }\n\n    \n    public void setAbsoluteAccuracy(double accuracy) {\n        optimizer.setAbsoluteAccuracy(accuracy);\n    }\n\n    \n    public void setMaximalIterationCount(int count) {\n        this.maxIterations = count;\n    }\n\n    \n    public void setMaxEvaluations(int maxEvaluations) {\n        this.maxEvaluations = maxEvaluations;\n    }\n\n    \n    public void setRelativeAccuracy(double accuracy) {\n        optimizer.setRelativeAccuracy(accuracy);\n    }\n\n    \n    public double[] getOptima() throws IllegalStateException {\n        if (optima == null) {\n            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n        }\n        return optima.clone();\n    }\n\n    \n    public double[] getOptimaValues() throws IllegalStateException {\n        if (optimaValues == null) {\n            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n        }\n        return optimaValues.clone();\n    }\n\n    \n    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws ConvergenceException, FunctionEvaluationException {\n\n        optima           = new double[starts];\n        optimaValues     = new double[starts];\n        totalIterations  = 0;\n        totalEvaluations = 0;\n\n        \n        for (int i = 0; i < starts; ++i) {\n\n            try {\n                optimizer.setMaximalIterationCount(maxIterations - totalIterations);\n                optimizer.setMaxEvaluations(maxEvaluations - totalEvaluations);\n                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n                optima[i]       = optimizer.optimize(f, goalType,\n                                                     Math.min(bound1, bound2),\n                                                     Math.max(bound1, bound2));\n                optimaValues[i] = optimizer.getFunctionValue();\n            } catch (FunctionEvaluationException fee) {\n                optima[i]       = Double.NaN;\n                optimaValues[i] = Double.NaN;\n            } catch (ConvergenceException ce) {\n                optima[i]       = Double.NaN;\n                optimaValues[i] = Double.NaN;\n            }\n\n            totalIterations  += optimizer.getIterationCount();\n            totalEvaluations += optimizer.getEvaluations();\n\n        }\n\n        \n        int lastNaN = optima.length;\n        for (int i = 0; i < lastNaN; ++i) {\n            if (Double.isNaN(optima[i])) {\n                optima[i] = optima[--lastNaN];\n                optima[lastNaN + 1] = Double.NaN;\n                optimaValues[i] = optimaValues[--lastNaN];\n                optimaValues[lastNaN + 1] = Double.NaN;\n            }\n        }\n\n        double currX = optima[0];\n        double currY = optimaValues[0];\n        for (int j = 1; j < lastNaN; ++j) {\n            final double prevY = currY;\n            currX = optima[j];\n            currY = optimaValues[j];\n            if ((goalType == GoalType.MAXIMIZE) ^ (currY < prevY)) {\n                \n                int i = j - 1;\n                double mIX = optima[i];\n                double mIY = optimaValues[i];\n                while ((i >= 0) && ((goalType == GoalType.MAXIMIZE) ^ (currY < mIY))) {\n                    optima[i + 1]       = mIX;\n                    optimaValues[i + 1] = mIY;\n                    if (i-- != 0) {\n                        mIX = optima[i];\n                        mIY = optimaValues[i];\n                    } else {\n                        mIX = Double.NaN;\n                        mIY = Double.NaN;\n                    }\n                }\n                optima[i + 1]       = currX;\n                optimaValues[i + 1] = currY;\n                currX = optima[j];\n                currY = optimaValues[j];\n            }\n        }\n\n        if (Double.isNaN(optima[0])) {\n            throw new OptimizationException(\n                    LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n                    starts);\n        }\n\n        \n        return optima[0];\n\n    }\n\n    \n    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws ConvergenceException, FunctionEvaluationException {\n        return optimize(f, goalType, min, max);\n    }\n}\n",
      "buggy_signatures": [
        "public double getFunctionValue()",
        "public double getResult()",
        "public double getAbsoluteAccuracy()",
        "public int getIterationCount()",
        "public int getMaximalIterationCount()",
        "public int getMaxEvaluations()",
        "public int getEvaluations()",
        "public double getRelativeAccuracy()",
        "public void resetAbsoluteAccuracy()",
        "public void resetMaximalIterationCount()",
        "public void resetRelativeAccuracy()",
        "public void setAbsoluteAccuracy(double accuracy)",
        "public void setMaximalIterationCount(int count)",
        "public void setMaxEvaluations(int maxEvaluations)",
        "public void setRelativeAccuracy(double accuracy)",
        "public double[] getOptima() throws IllegalStateException",
        "public double[] getOptimaValues() throws IllegalStateException",
        "public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws ConvergenceException, FunctionEvaluationException",
        "public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws ConvergenceException, FunctionEvaluationException"
      ],
      "fixed_signatures": [
        "public double getFunctionValue()",
        "public double getResult()",
        "public double getAbsoluteAccuracy()",
        "public int getIterationCount()",
        "public int getMaximalIterationCount()",
        "public int getMaxEvaluations()",
        "public int getEvaluations()",
        "public double getRelativeAccuracy()",
        "public void resetAbsoluteAccuracy()",
        "public void resetMaximalIterationCount()",
        "public void resetRelativeAccuracy()",
        "public void setAbsoluteAccuracy(double accuracy)",
        "public void setMaximalIterationCount(int count)",
        "public void setMaxEvaluations(int maxEvaluations)",
        "public void setRelativeAccuracy(double accuracy)",
        "public double[] getOptima() throws IllegalStateException",
        "public double[] getOptimaValues() throws IllegalStateException",
        "public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws ConvergenceException, FunctionEvaluationException",
        "public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws ConvergenceException, FunctionEvaluationException"
      ],
      "methods": [
        {
          "buggy_method": "  public double getResult() {\n  return optimizer.getResult();\n  }",
          "fixed_method": "  public double getResult() {\n  return optima[0];\n  }",
          "diff": [
            "@@ -89,12 +89,12 @@",
            " \n",
            "     /** {@inheritDoc} */\n",
            "     public double getFunctionValue() {\n",
            "-        return optimizer.getFunctionValue();\n",
            "+        return optimaValues[0];\n",
            "     }\n",
            " \n",
            "     /** {@inheritDoc} */\n",
            "     public double getResult() {\n",
            "-        return optimizer.getResult();\n",
            "+        return optima[0];\n",
            "     }\n",
            " \n",
            "     /** {@inheritDoc} */\n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
