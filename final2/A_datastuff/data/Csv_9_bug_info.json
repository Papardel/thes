{
  "bug_id": "9",
  "failed_tests": {
    "org.apache.commons.csv.CSVRecordTest": [
      {
        "methodName": "testToMapWithNoHeader",
        "error": "java.lang.NullPointerException",
        "message": "",
        "fail_line": "       Map<String, String> map = shortRec.toMap();",
        "test_source": "  public void testToMapWithNoHeader() throws Exception {\n  final CSVParser parser =  CSVParser.parse(\"a,b\", CSVFormat.newFormat(','));\n  final CSVRecord shortRec = parser.iterator().next();\n  Map<String, String> map = shortRec.toMap();\n  assertNotNull(\"Map is not null.\", map);\n  assertTrue(\"Map is empty.\", map.isEmpty());\n  }",
        "stack": [
          "CSVRecord.putIn line 180, CSVRecord.toMap line 214, CSVRecordTest.testToMapWithNoHeader line 175"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/csv/CSVRecord.java",
      "buggy_full_code": "\n\npackage org.apache.commons.csv;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\n\npublic final class CSVRecord implements Serializable, Iterable<String> { private static final String[] EMPTY_STRING_ARRAY = new String[0]; private static final long serialVersionUID = 1L; private final String comment; private final Map<String, Integer> mapping; private final long recordNumber; private final String[] values; CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber) {\n        this.recordNumber = recordNumber;\n        this.values = values != null ? values : EMPTY_STRING_ARRAY;\n        this.mapping = mapping;\n        this.comment = comment;\n    }\n\n    \n    public String get(final Enum<?> e) {\n        return get(e.toString());\n    }\n\n    \n    public String get(final int i) {\n        return values[i];\n    }\n\n    \n    public String get(final String name) {\n        if (mapping == null) {\n            throw new IllegalStateException(\n                    \"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = mapping.get(name);\n        if (index == null) {\n            throw new IllegalArgumentException(String.format(\"Mapping for %s not found, expected one of %s\", name,\n                    mapping.keySet()));\n        }\n        try {\n            return values[index.intValue()];\n        } catch (final ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(String.format(\n                    \"Index for header '%s' is %d but CSVRecord only has %d values!\", name, index,\n                    Integer.valueOf(values.length)));\n        }\n    }\n\n    \n    public String getComment() {\n        return comment;\n    }\n\n    \n    public long getRecordNumber() {\n        return recordNumber;\n    }\n\n    \n    public boolean isConsistent() {\n        return mapping == null || mapping.size() == values.length;\n    }\n\n    \n    public boolean isMapped(final String name) {\n        return mapping != null && mapping.containsKey(name);\n    }\n\n    \n    public boolean isSet(final String name) {\n        return isMapped(name) && mapping.get(name).intValue() < values.length;\n    }\n\n    \n    public Iterator<String> iterator() {\n        return toList().iterator();\n    }\n\n    \n    <M extends Map<String, String>> M putIn(final M map) {\n        for (final Entry<String, Integer> entry : mapping.entrySet()) {\n            final int col = entry.getValue().intValue();\n            if (col < values.length) {\n                map.put(entry.getKey(), values[col]);\n            }\n        }\n        return map;\n    }\n\n    \n    public int size() {\n        return values.length;\n    }\n\n    \n    private List<String> toList() {\n        return Arrays.asList(values);\n    }\n\n    \n    public Map<String, String> toMap() {\n        return putIn(new HashMap<String, String>(values.length));\n    }\n\n    @Override\n    public String toString() {\n        return Arrays.toString(values);\n    }\n\n    String[] values() {\n        return values;\n    }\n\n\n}\n",
      "fixed_full_code": "\n\npackage org.apache.commons.csv;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\n\npublic final class CSVRecord implements Serializable, Iterable<String> { private static final String[] EMPTY_STRING_ARRAY = new String[0]; private static final long serialVersionUID = 1L; private final String comment; private final Map<String, Integer> mapping; private final long recordNumber; private final String[] values; CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber) {\n        this.recordNumber = recordNumber;\n        this.values = values != null ? values : EMPTY_STRING_ARRAY;\n        this.mapping = mapping;\n        this.comment = comment;\n    }\n\n    \n    public String get(final Enum<?> e) {\n        return get(e.toString());\n    }\n\n    \n    public String get(final int i) {\n        return values[i];\n    }\n\n    \n    public String get(final String name) {\n        if (mapping == null) {\n            throw new IllegalStateException(\n                    \"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = mapping.get(name);\n        if (index == null) {\n            throw new IllegalArgumentException(String.format(\"Mapping for %s not found, expected one of %s\", name,\n                    mapping.keySet()));\n        }\n        try {\n            return values[index.intValue()];\n        } catch (final ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(String.format(\n                    \"Index for header '%s' is %d but CSVRecord only has %d values!\", name, index,\n                    Integer.valueOf(values.length)));\n        }\n    }\n\n    \n    public String getComment() {\n        return comment;\n    }\n\n    \n    public long getRecordNumber() {\n        return recordNumber;\n    }\n\n    \n    public boolean isConsistent() {\n        return mapping == null || mapping.size() == values.length;\n    }\n\n    \n    public boolean isMapped(final String name) {\n        return mapping != null && mapping.containsKey(name);\n    }\n\n    \n    public boolean isSet(final String name) {\n        return isMapped(name) && mapping.get(name).intValue() < values.length;\n    }\n\n    \n    public Iterator<String> iterator() {\n        return toList().iterator();\n    }\n\n    \n    <M extends Map<String, String>> M putIn(final M map) {\n        if (mapping == null) {\n            return map;\n        }\n        for (final Entry<String, Integer> entry : mapping.entrySet()) {\n            final int col = entry.getValue().intValue();\n            if (col < values.length) {\n                map.put(entry.getKey(), values[col]);\n            }\n        }\n        return map;\n    }\n\n    \n    public int size() {\n        return values.length;\n    }\n\n    \n    private List<String> toList() {\n        return Arrays.asList(values);\n    }\n\n    \n    public Map<String, String> toMap() {\n        return putIn(new HashMap<String, String>(values.length));\n    }\n\n    @Override\n    public String toString() {\n        return Arrays.toString(values);\n    }\n\n    String[] values() {\n        return values;\n    }\n\n\n}\n",
      "buggy_signatures": [
        "public String get(final Enum<?> e)",
        "public String get(final int i)",
        "public String get(final String name)",
        "public String getComment()",
        "public long getRecordNumber()",
        "public boolean isConsistent()",
        "public boolean isMapped(final String name)",
        "public boolean isSet(final String name)",
        "public Iterator<String> iterator()",
        "public int size()",
        "private List<String> toList()",
        "public Map<String, String> toMap()",
        "public String toString()"
      ],
      "fixed_signatures": [
        "public String get(final Enum<?> e)",
        "public String get(final int i)",
        "public String get(final String name)",
        "public String getComment()",
        "public long getRecordNumber()",
        "public boolean isConsistent()",
        "public boolean isMapped(final String name)",
        "public boolean isSet(final String name)",
        "public Iterator<String> iterator()",
        "public int size()",
        "private List<String> toList()",
        "public Map<String, String> toMap()",
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "  public Iterator<String> iterator() {\n  return toList().iterator();\n  }",
          "fixed_method": "  public Iterator<String> iterator() {\n  return toList().iterator();\n  }",
          "diff": [
            "@@ -177,6 +177,9 @@",
            "      * @return the given map.\n",
            "      */\n",
            "     <M extends Map<String, String>> M putIn(final M map) {\n",
            "+        if (mapping == null) {\n",
            "+            return map;\n",
            "+        }\n",
            "         for (final Entry<String, Integer> entry : mapping.entrySet()) {\n",
            "             final int col = entry.getValue().intValue();\n",
            "             if (col < values.length) {\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
