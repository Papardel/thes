{
  "bug_id": "40",
  "failed_tests": {
    "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest": [
      {
        "methodName": "testIssue716",
        "error": "org.apache.commons.math.exception.TooManyEvaluationsException",
        "message": "illegal state: maximal count (100) exceeded: evaluations",
        "fail_line": "        double result = solver.solve(100, sharpTurn, -0.9999999, 30, 15, AllowedSolution.RIGHT_SIDE);",
        "test_source": "  public void testIssue716() {\n  BracketingNthOrderBrentSolver solver =\n  new BracketingNthOrderBrentSolver(1.0e-12, 1.0e-10, 1.0e-22, 5);\n  UnivariateFunction sharpTurn = new UnivariateFunction() {\n  public double value(double x) {\n  return (2 * x + 1) / (1.0e9 * (x + 1));\n  }\n  };\n  double result = solver.solve(100, sharpTurn, -0.9999999, 30, 15, AllowedSolution.RIGHT_SIDE);\n  Assert.assertEquals(0, sharpTurn.value(result), solver.getFunctionValueAccuracy());\n  Assert.assertTrue(sharpTurn.value(result) >= 0);\n  Assert.assertEquals(-0.5, result, 1.0e-10);\n  }",
        "stack": [
          "BaseAbstractUnivariateRealSolver.incrementEvaluationCount line 296, BaseAbstractUnivariateRealSolver.computeObjectiveValue line 153, BracketingNthOrderBrentSolver.doSolve line 283, BaseAbstractUnivariateRealSolver.solve line 190, BracketingNthOrderBrentSolver.solve line 394, BracketingNthOrderBrentSolverTest.testIssue716 line 93"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java",
      "buggy_full_code": "\npackage org.apache.commons.math.analysis.solvers;\n\n\nimport org.apache.commons.math.analysis.UnivariateFunction;\nimport org.apache.commons.math.exception.MathInternalError;\nimport org.apache.commons.math.exception.NoBracketingException;\nimport org.apache.commons.math.exception.NumberIsTooSmallException;\nimport org.apache.commons.math.util.FastMath;\nimport org.apache.commons.math.util.Precision;\n\n\npublic class BracketingNthOrderBrentSolver extends AbstractUnivariateRealSolver implements BracketedUnivariateRealSolver<UnivariateFunction> { private static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6; private static final int DEFAULT_MAXIMAL_ORDER = 5; private static final int MAXIMAL_AGING = 2; private static final double REDUCTION_FACTOR = 1.0 / 16.0; private final int maximalOrder; private AllowedSolution allowed; public BracketingNthOrderBrentSolver() {\n        this(DEFAULT_ABSOLUTE_ACCURACY, DEFAULT_MAXIMAL_ORDER);\n    }\n\n    \n    public BracketingNthOrderBrentSolver(final double absoluteAccuracy, final int maximalOrder) throws NumberIsTooSmallException {\n        super(absoluteAccuracy);\n        if (maximalOrder < 2) {\n            throw new NumberIsTooSmallException(maximalOrder, 2, true);\n        }\n        this.maximalOrder = maximalOrder;\n        this.allowed = AllowedSolution.ANY_SIDE;\n    }\n\n    \n    public BracketingNthOrderBrentSolver(final double relativeAccuracy, final double absoluteAccuracy, final int maximalOrder) throws NumberIsTooSmallException {\n        super(relativeAccuracy, absoluteAccuracy);\n        if (maximalOrder < 2) {\n            throw new NumberIsTooSmallException(maximalOrder, 2, true);\n        }\n        this.maximalOrder = maximalOrder;\n        this.allowed = AllowedSolution.ANY_SIDE;\n    }\n\n    \n    public BracketingNthOrderBrentSolver(final double relativeAccuracy, final double absoluteAccuracy, final double functionValueAccuracy, final int maximalOrder) throws NumberIsTooSmallException {\n        super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);\n        if (maximalOrder < 2) {\n            throw new NumberIsTooSmallException(maximalOrder, 2, true);\n        }\n        this.maximalOrder = maximalOrder;\n        this.allowed = AllowedSolution.ANY_SIDE;\n    }\n\n    \n    public int getMaximalOrder() {\n        return maximalOrder;\n    }\n\n    \n    @Override\n    protected double doSolve() {\n\n        \n        final double[] x = new double[maximalOrder + 1];\n        final double[] y = new double[maximalOrder + 1];\n        x[0] = getMin();\n        x[1] = getStartValue();\n        x[2] = getMax();\n        verifySequence(x[0], x[1], x[2]);\n\n        \n        y[1] = computeObjectiveValue(x[1]);\n        if (Precision.equals(y[1], 0.0, 1)) {\n            \n            return x[1];\n        }\n\n        \n        y[0] = computeObjectiveValue(x[0]);\n        if (Precision.equals(y[0], 0.0, 1)) {\n            \n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0] * y[1] < 0) {\n\n            \n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            \n            y[2] = computeObjectiveValue(x[2]);\n            if (Precision.equals(y[2], 0.0, 1)) {\n                \n                return x[2];\n            }\n\n            if (y[1] * y[2] < 0) {\n                \n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n            }\n\n        }\n\n        \n        final double[] tmpX = new double[x.length];\n\n        \n        double xA    = x[signChangeIndex - 1];\n        double yA    = y[signChangeIndex - 1];\n        double absYA = FastMath.abs(yA);\n        int agingA   = 0;\n        double xB    = x[signChangeIndex];\n        double yB    = y[signChangeIndex];\n        double absYB = FastMath.abs(yB);\n        int agingB   = 0;\n\n        \n        while (true) {\n\n            \n            final double xTol = getAbsoluteAccuracy() +\n                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n                switch (allowed) {\n                case ANY_SIDE :\n                    return absYA < absYB ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return (yA <= 0) ? xA : xB;\n                case ABOVE_SIDE :\n                    return (yA <  0) ? xB : xA;\n                default :\n                    \n                    throw new MathInternalError(null);\n                }\n            }\n\n            \n            double targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                \n                targetY = -REDUCTION_FACTOR * yB;\n            } else if (agingB >= MAXIMAL_AGING) {\n                \n                targetY = -REDUCTION_FACTOR * yA;\n            } else {\n                \n                targetY = 0;\n            }\n\n            \n            double nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                \n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!((nextX > xA) && (nextX < xB))) {\n                    \n\n                    \n                    \n                    \n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        \n                        ++start;\n                    } else {\n                        \n                        --end;\n                    }\n\n                    \n                    nextX = Double.NaN;\n\n                }\n\n            } while (Double.isNaN(nextX) && (end - start > 1));\n\n            if (Double.isNaN(nextX)) {\n                \n                nextX = xA + 0.5 * (xB - xA);\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            \n            final double nextY = computeObjectiveValue(nextX);\n            if (Precision.equals(nextY, 0.0, 1)) {\n                \n                \n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                \n                \n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                \n                nbPoints--;\n\n                \n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    \n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            \n            \n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            \n            if (nextY * yA <= 0) {\n                \n                xB = nextX;\n                yB = nextY;\n                absYB = FastMath.abs(yB);\n                ++agingA;\n                agingB = 0;\n            } else {\n                \n                xA = nextX;\n                yA = nextY;\n                absYA = FastMath.abs(yA);\n                agingA = 0;\n                ++agingB;\n\n                \n                signChangeIndex++;\n\n            }\n\n        }\n\n    }\n\n    \n    private double guessX(final double targetY, final double[] x, final double[] y, final int start, final int end) {\n\n        \n        for (int i = start; i < end - 1; ++i) {\n            final int delta = i + 1 - start;\n            for (int j = end - 1; j > i; --j) {\n                x[j] = (x[j] - x[j-1]) / (y[j] - y[j - delta]);\n            }\n        }\n\n        \n        double x0 = 0;\n        for (int j = end - 1; j >= start; --j) {\n            x0 = x[j] + x0 * (targetY - y[j]);\n        }\n\n        return x0;\n\n    }\n\n    \n    public double solve(int maxEval, UnivariateFunction f, double min, double max, AllowedSolution allowedSolution) {\n        this.allowed = allowedSolution;\n        return super.solve(maxEval, f, min, max);\n    }\n\n    \n    public double solve(int maxEval, UnivariateFunction f, double min, double max, double startValue, AllowedSolution allowedSolution) {\n        this.allowed = allowedSolution;\n        return super.solve(maxEval, f, min, max, startValue);\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.math.analysis.solvers;\n\n\nimport org.apache.commons.math.analysis.UnivariateFunction;\nimport org.apache.commons.math.exception.MathInternalError;\nimport org.apache.commons.math.exception.NoBracketingException;\nimport org.apache.commons.math.exception.NumberIsTooSmallException;\nimport org.apache.commons.math.util.FastMath;\nimport org.apache.commons.math.util.Precision;\n\n\npublic class BracketingNthOrderBrentSolver extends AbstractUnivariateRealSolver implements BracketedUnivariateRealSolver<UnivariateFunction> { private static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6; private static final int DEFAULT_MAXIMAL_ORDER = 5; private static final int MAXIMAL_AGING = 2; private static final double REDUCTION_FACTOR = 1.0 / 16.0; private final int maximalOrder; private AllowedSolution allowed; public BracketingNthOrderBrentSolver() {\n        this(DEFAULT_ABSOLUTE_ACCURACY, DEFAULT_MAXIMAL_ORDER);\n    }\n\n    \n    public BracketingNthOrderBrentSolver(final double absoluteAccuracy, final int maximalOrder) throws NumberIsTooSmallException {\n        super(absoluteAccuracy);\n        if (maximalOrder < 2) {\n            throw new NumberIsTooSmallException(maximalOrder, 2, true);\n        }\n        this.maximalOrder = maximalOrder;\n        this.allowed = AllowedSolution.ANY_SIDE;\n    }\n\n    \n    public BracketingNthOrderBrentSolver(final double relativeAccuracy, final double absoluteAccuracy, final int maximalOrder) throws NumberIsTooSmallException {\n        super(relativeAccuracy, absoluteAccuracy);\n        if (maximalOrder < 2) {\n            throw new NumberIsTooSmallException(maximalOrder, 2, true);\n        }\n        this.maximalOrder = maximalOrder;\n        this.allowed = AllowedSolution.ANY_SIDE;\n    }\n\n    \n    public BracketingNthOrderBrentSolver(final double relativeAccuracy, final double absoluteAccuracy, final double functionValueAccuracy, final int maximalOrder) throws NumberIsTooSmallException {\n        super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);\n        if (maximalOrder < 2) {\n            throw new NumberIsTooSmallException(maximalOrder, 2, true);\n        }\n        this.maximalOrder = maximalOrder;\n        this.allowed = AllowedSolution.ANY_SIDE;\n    }\n\n    \n    public int getMaximalOrder() {\n        return maximalOrder;\n    }\n\n    \n    @Override\n    protected double doSolve() {\n\n        \n        final double[] x = new double[maximalOrder + 1];\n        final double[] y = new double[maximalOrder + 1];\n        x[0] = getMin();\n        x[1] = getStartValue();\n        x[2] = getMax();\n        verifySequence(x[0], x[1], x[2]);\n\n        \n        y[1] = computeObjectiveValue(x[1]);\n        if (Precision.equals(y[1], 0.0, 1)) {\n            \n            return x[1];\n        }\n\n        \n        y[0] = computeObjectiveValue(x[0]);\n        if (Precision.equals(y[0], 0.0, 1)) {\n            \n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0] * y[1] < 0) {\n\n            \n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            \n            y[2] = computeObjectiveValue(x[2]);\n            if (Precision.equals(y[2], 0.0, 1)) {\n                \n                return x[2];\n            }\n\n            if (y[1] * y[2] < 0) {\n                \n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n            }\n\n        }\n\n        \n        final double[] tmpX = new double[x.length];\n\n        \n        double xA    = x[signChangeIndex - 1];\n        double yA    = y[signChangeIndex - 1];\n        double absYA = FastMath.abs(yA);\n        int agingA   = 0;\n        double xB    = x[signChangeIndex];\n        double yB    = y[signChangeIndex];\n        double absYB = FastMath.abs(yB);\n        int agingB   = 0;\n\n        \n        while (true) {\n\n            \n            final double xTol = getAbsoluteAccuracy() +\n                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n                switch (allowed) {\n                case ANY_SIDE :\n                    return absYA < absYB ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return (yA <= 0) ? xA : xB;\n                case ABOVE_SIDE :\n                    return (yA <  0) ? xB : xA;\n                default :\n                    \n                    throw new MathInternalError(null);\n                }\n            }\n\n            \n            double targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                \n                final int p = agingA - MAXIMAL_AGING;\n                final double weightA = (1 << p) - 1;\n                final double weightB = p + 1;\n                targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);\n            } else if (agingB >= MAXIMAL_AGING) {\n                \n                final int p = agingB - MAXIMAL_AGING;\n                final double weightA = p + 1;\n                final double weightB = (1 << p) - 1;\n                targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);\n            } else {\n                \n                targetY = 0;\n            }\n\n            \n            double nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                \n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!((nextX > xA) && (nextX < xB))) {\n                    \n\n                    \n                    \n                    \n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        \n                        ++start;\n                    } else {\n                        \n                        --end;\n                    }\n\n                    \n                    nextX = Double.NaN;\n\n                }\n\n            } while (Double.isNaN(nextX) && (end - start > 1));\n\n            if (Double.isNaN(nextX)) {\n                \n                nextX = xA + 0.5 * (xB - xA);\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            \n            final double nextY = computeObjectiveValue(nextX);\n            if (Precision.equals(nextY, 0.0, 1)) {\n                \n                \n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                \n                \n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                \n                nbPoints--;\n\n                \n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    \n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            \n            \n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            \n            if (nextY * yA <= 0) {\n                \n                xB = nextX;\n                yB = nextY;\n                absYB = FastMath.abs(yB);\n                ++agingA;\n                agingB = 0;\n            } else {\n                \n                xA = nextX;\n                yA = nextY;\n                absYA = FastMath.abs(yA);\n                agingA = 0;\n                ++agingB;\n\n                \n                signChangeIndex++;\n\n            }\n\n        }\n\n    }\n\n    \n    private double guessX(final double targetY, final double[] x, final double[] y, final int start, final int end) {\n\n        \n        for (int i = start; i < end - 1; ++i) {\n            final int delta = i + 1 - start;\n            for (int j = end - 1; j > i; --j) {\n                x[j] = (x[j] - x[j-1]) / (y[j] - y[j - delta]);\n            }\n        }\n\n        \n        double x0 = 0;\n        for (int j = end - 1; j >= start; --j) {\n            x0 = x[j] + x0 * (targetY - y[j]);\n        }\n\n        return x0;\n\n    }\n\n    \n    public double solve(int maxEval, UnivariateFunction f, double min, double max, AllowedSolution allowedSolution) {\n        this.allowed = allowedSolution;\n        return super.solve(maxEval, f, min, max);\n    }\n\n    \n    public double solve(int maxEval, UnivariateFunction f, double min, double max, double startValue, AllowedSolution allowedSolution) {\n        this.allowed = allowedSolution;\n        return super.solve(maxEval, f, min, max, startValue);\n    }\n\n}\n",
      "buggy_signatures": [
        "public BracketingNthOrderBrentSolver(final double absoluteAccuracy, final int maximalOrder) throws NumberIsTooSmallException",
        "public BracketingNthOrderBrentSolver(final double relativeAccuracy, final double absoluteAccuracy, final int maximalOrder) throws NumberIsTooSmallException",
        "public BracketingNthOrderBrentSolver(final double relativeAccuracy, final double absoluteAccuracy, final double functionValueAccuracy, final int maximalOrder) throws NumberIsTooSmallException",
        "public int getMaximalOrder()",
        "protected double doSolve()",
        "private double guessX(final double targetY, final double[] x, final double[] y, final int start, final int end)",
        "public double solve(int maxEval, UnivariateFunction f, double min, double max, AllowedSolution allowedSolution)",
        "public double solve(int maxEval, UnivariateFunction f, double min, double max, double startValue, AllowedSolution allowedSolution)"
      ],
      "fixed_signatures": [
        "public BracketingNthOrderBrentSolver(final double absoluteAccuracy, final int maximalOrder) throws NumberIsTooSmallException",
        "public BracketingNthOrderBrentSolver(final double relativeAccuracy, final double absoluteAccuracy, final int maximalOrder) throws NumberIsTooSmallException",
        "public BracketingNthOrderBrentSolver(final double relativeAccuracy, final double absoluteAccuracy, final double functionValueAccuracy, final int maximalOrder) throws NumberIsTooSmallException",
        "public int getMaximalOrder()",
        "protected double doSolve()",
        "private double guessX(final double targetY, final double[] x, final double[] y, final int start, final int end)",
        "public double solve(int maxEval, UnivariateFunction f, double min, double max, AllowedSolution allowedSolution)",
        "public double solve(int maxEval, UnivariateFunction f, double min, double max, double startValue, AllowedSolution allowedSolution)"
      ],
      "methods": [
        {
          "buggy_method": "  protected double doSolve() {\n\n  \n  final double[] x = new double[maximalOrder + 1];\n  final double[] y = new double[maximalOrder + 1];\n  x[0] = getMin();\n  x[1] = getStartValue();\n  x[2] = getMax();\n  verifySequence(x[0], x[1], x[2]);\n\n  \n  y[1] = computeObjectiveValue(x[1]);\n  if (Precision.equals(y[1], 0.0, 1)) {\n  \n  return x[1];\n  }\n\n  \n  y[0] = computeObjectiveValue(x[0]);\n  if (Precision.equals(y[0], 0.0, 1)) {\n  \n  return x[0];\n  }\n\n  int nbPoints;\n  int signChangeIndex;\n  if (y[0] * y[1] < 0) {\n\n  \n  nbPoints  = 2;\n  signChangeIndex = 1;\n\n  } else {\n\n  \n  y[2] = computeObjectiveValue(x[2]);\n  if (Precision.equals(y[2], 0.0, 1)) {\n  \n  return x[2];\n  }\n\n  if (y[1] * y[2] < 0) {\n  \n  nbPoints  = 3;\n  signChangeIndex = 2;\n  } else {\n  throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n  }\n\n  }\n\n  \n  final double[] tmpX = new double[x.length];\n\n  \n  double xA  = x[signChangeIndex - 1];\n  double yA  = y[signChangeIndex - 1];\n  double absYA = FastMath.abs(yA);\n  int agingA  = 0;\n  double xB  = x[signChangeIndex];\n  double yB  = y[signChangeIndex];\n  double absYB = FastMath.abs(yB);\n  int agingB  = 0;\n\n  \n  while (true) {\n\n  \n  final double xTol = getAbsoluteAccuracy() +\n  getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n  if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n  switch (allowed) {\n  case ANY_SIDE :\n  return absYA < absYB ? xA : xB;\n  case LEFT_SIDE :\n  return xA;\n  case RIGHT_SIDE :\n  return xB;\n  case BELOW_SIDE :\n  return (yA <= 0) ? xA : xB;\n  case ABOVE_SIDE :\n  return (yA <  0) ? xB : xA;\n  default :\n  \n  throw new MathInternalError(null);\n  }\n  }\n\n  \n  double targetY;\n  if (agingA >= MAXIMAL_AGING) {\n  \n  targetY = -REDUCTION_FACTOR * yB;\n  } else if (agingB >= MAXIMAL_AGING) {\n  \n  targetY = -REDUCTION_FACTOR * yA;\n  } else {\n  \n  targetY = 0;\n  }\n\n  \n  double nextX;\n  int start = 0;\n  int end  = nbPoints;\n  do {\n\n  \n  System.arraycopy(x, start, tmpX, start, end - start);\n  nextX = guessX(targetY, tmpX, y, start, end);\n\n  if (!((nextX > xA) && (nextX < xB))) {\n  \n\n  \n  \n  \n  if (signChangeIndex - start >= end - signChangeIndex) {\n  \n  ++start;\n  } else {\n  \n  --end;\n  }\n\n  \n  nextX = Double.NaN;\n\n  }\n\n  } while (Double.isNaN(nextX) && (end - start > 1));\n\n  if (Double.isNaN(nextX)) {\n  \n  nextX = xA + 0.5 * (xB - xA);\n  start = signChangeIndex - 1;\n  end  = signChangeIndex;\n  }\n\n  \n  final double nextY = computeObjectiveValue(nextX);\n  if (Precision.equals(nextY, 0.0, 1)) {\n  \n  \n  return nextX;\n  }\n\n  if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n  \n  \n  nbPoints = end - start;\n  System.arraycopy(x, start, x, 0, nbPoints);\n  System.arraycopy(y, start, y, 0, nbPoints);\n  signChangeIndex -= start;\n\n  } else  if (nbPoints == x.length) {\n\n  \n  nbPoints--;\n\n  \n  if (signChangeIndex >= (x.length + 1) / 2) {\n  \n  System.arraycopy(x, 1, x, 0, nbPoints);\n  System.arraycopy(y, 1, y, 0, nbPoints);\n  --signChangeIndex;\n  }\n\n  }\n\n  \n  \n  System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n  x[signChangeIndex] = nextX;\n  System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n  y[signChangeIndex] = nextY;\n  ++nbPoints;\n\n  \n  if (nextY * yA <= 0) {\n  \n  xB = nextX;\n  yB = nextY;\n  absYB = FastMath.abs(yB);\n  ++agingA;\n  agingB = 0;\n  } else {\n  \n  xA = nextX;\n  yA = nextY;\n  absYA = FastMath.abs(yA);\n  agingA = 0;\n  ++agingB;\n\n  \n  signChangeIndex++;\n\n  }\n\n  }\n\n  }",
          "fixed_method": "  protected double doSolve() {\n\n  \n  final double[] x = new double[maximalOrder + 1];\n  final double[] y = new double[maximalOrder + 1];\n  x[0] = getMin();\n  x[1] = getStartValue();\n  x[2] = getMax();\n  verifySequence(x[0], x[1], x[2]);\n\n  \n  y[1] = computeObjectiveValue(x[1]);\n  if (Precision.equals(y[1], 0.0, 1)) {\n  \n  return x[1];\n  }\n\n  \n  y[0] = computeObjectiveValue(x[0]);\n  if (Precision.equals(y[0], 0.0, 1)) {\n  \n  return x[0];\n  }\n\n  int nbPoints;\n  int signChangeIndex;\n  if (y[0] * y[1] < 0) {\n\n  \n  nbPoints  = 2;\n  signChangeIndex = 1;\n\n  } else {\n\n  \n  y[2] = computeObjectiveValue(x[2]);\n  if (Precision.equals(y[2], 0.0, 1)) {\n  \n  return x[2];\n  }\n\n  if (y[1] * y[2] < 0) {\n  \n  nbPoints  = 3;\n  signChangeIndex = 2;\n  } else {\n  throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n  }\n\n  }\n\n  \n  final double[] tmpX = new double[x.length];\n\n  \n  double xA  = x[signChangeIndex - 1];\n  double yA  = y[signChangeIndex - 1];\n  double absYA = FastMath.abs(yA);\n  int agingA  = 0;\n  double xB  = x[signChangeIndex];\n  double yB  = y[signChangeIndex];\n  double absYB = FastMath.abs(yB);\n  int agingB  = 0;\n\n  \n  while (true) {\n\n  \n  final double xTol = getAbsoluteAccuracy() +\n  getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n  if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n  switch (allowed) {\n  case ANY_SIDE :\n  return absYA < absYB ? xA : xB;\n  case LEFT_SIDE :\n  return xA;\n  case RIGHT_SIDE :\n  return xB;\n  case BELOW_SIDE :\n  return (yA <= 0) ? xA : xB;\n  case ABOVE_SIDE :\n  return (yA <  0) ? xB : xA;\n  default :\n  \n  throw new MathInternalError(null);\n  }\n  }\n\n  \n  double targetY;\n  if (agingA >= MAXIMAL_AGING) {\n  \n  final int p = agingA - MAXIMAL_AGING;\n  final double weightA = (1 << p) - 1;\n  final double weightB = p + 1;\n  targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);\n  } else if (agingB >= MAXIMAL_AGING) {\n  \n  final int p = agingB - MAXIMAL_AGING;\n  final double weightA = p + 1;\n  final double weightB = (1 << p) - 1;\n  targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);\n  } else {\n  \n  targetY = 0;\n  }\n\n  \n  double nextX;\n  int start = 0;\n  int end  = nbPoints;\n  do {\n\n  \n  System.arraycopy(x, start, tmpX, start, end - start);\n  nextX = guessX(targetY, tmpX, y, start, end);\n\n  if (!((nextX > xA) && (nextX < xB))) {\n  \n\n  \n  \n  \n  if (signChangeIndex - start >= end - signChangeIndex) {\n  \n  ++start;\n  } else {\n  \n  --end;\n  }\n\n  \n  nextX = Double.NaN;\n\n  }\n\n  } while (Double.isNaN(nextX) && (end - start > 1));\n\n  if (Double.isNaN(nextX)) {\n  \n  nextX = xA + 0.5 * (xB - xA);\n  start = signChangeIndex - 1;\n  end  = signChangeIndex;\n  }\n\n  \n  final double nextY = computeObjectiveValue(nextX);\n  if (Precision.equals(nextY, 0.0, 1)) {\n  \n  \n  return nextX;\n  }\n\n  if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n  \n  \n  nbPoints = end - start;\n  System.arraycopy(x, start, x, 0, nbPoints);\n  System.arraycopy(y, start, y, 0, nbPoints);\n  signChangeIndex -= start;\n\n  } else  if (nbPoints == x.length) {\n\n  \n  nbPoints--;\n\n  \n  if (signChangeIndex >= (x.length + 1) / 2) {\n  \n  System.arraycopy(x, 1, x, 0, nbPoints);\n  System.arraycopy(y, 1, y, 0, nbPoints);\n  --signChangeIndex;\n  }\n\n  }\n\n  \n  \n  System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n  x[signChangeIndex] = nextX;\n  System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n  y[signChangeIndex] = nextY;\n  ++nbPoints;\n\n  \n  if (nextY * yA <= 0) {\n  \n  xB = nextX;\n  yB = nextY;\n  absYB = FastMath.abs(yB);\n  ++agingA;\n  agingB = 0;\n  } else {\n  \n  xA = nextX;\n  yA = nextY;\n  absYA = FastMath.abs(yA);\n  agingA = 0;\n  ++agingB;\n\n  \n  signChangeIndex++;\n\n  }\n\n  }\n\n  }",
          "diff": [
            "@@ -232,10 +232,16 @@",
            "             double targetY;\n",
            "             if (agingA >= MAXIMAL_AGING) {\n",
            "                 // we keep updating the high bracket, try to compensate this\n",
            "-                targetY = -REDUCTION_FACTOR * yB;\n",
            "+                final int p = agingA - MAXIMAL_AGING;\n",
            "+                final double weightA = (1 << p) - 1;\n",
            "+                final double weightB = p + 1;\n",
            "+                targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);\n",
            "             } else if (agingB >= MAXIMAL_AGING) {\n",
            "                 // we keep updating the low bracket, try to compensate this\n",
            "-                targetY = -REDUCTION_FACTOR * yA;\n",
            "+                final int p = agingB - MAXIMAL_AGING;\n",
            "+                final double weightA = p + 1;\n",
            "+                final double weightB = (1 << p) - 1;\n",
            "+                targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);\n",
            "             } else {\n",
            "                 // bracketing is balanced, try to find the root itself\n",
            "                 targetY = 0;\n"
          ],
          "changed_lines": 10
        }
      ]
    }
  ]
}
