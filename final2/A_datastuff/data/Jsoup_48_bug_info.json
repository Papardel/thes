{
  "bug_id": "48",
  "failed_tests": {
    "org.jsoup.helper.HttpConnectionTest": [
      {
        "methodName": "sameHeadersCombineWithComma",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<no-cache[, no-store]> but was:<no-cache[]>",
        "fail_line": "        assertEquals(\"no-cache, no-store\", res.header(\"Cache-Control\"));",
        "test_source": "",
        "stack": [
          "HttpConnectionTest.sameHeadersCombineWithComma line 63"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/jsoup/helper/HttpConnection.java",
      "buggy_full_code": "package org.jsoup.helper;\n\nimport org.jsoup.Connection;\nimport org.jsoup.HttpStatusException;\nimport org.jsoup.UnsupportedMimeTypeException;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.parser.TokenQueue;\n\nimport javax.net.ssl.*;\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.X509Certificate;\nimport java.util.*;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\n\n\npublic class HttpConnection implements Connection { public static final String CONTENT_ENCODING = \"Content-Encoding\"; private static final String CONTENT_TYPE = \"Content-Type\"; private static final String MULTIPART_FORM_DATA = \"multipart/form-data\"; private static final String FORM_URL_ENCODED = \"application/x-www-form-urlencoded\"; public static Connection connect(String url) {\n        Connection con = new HttpConnection();\n        con.url(url);\n        return con;\n    }\n\n    public static Connection connect(URL url) {\n        Connection con = new HttpConnection();\n        con.url(url);\n        return con;\n    }\n\n\tprivate static String encodeUrl(String url) {\n\t\tif(url == null)\n\t\t\treturn null;\n    \treturn url.replaceAll(\" \", \"%20\");\n\t}\n\n    private static String encodeMimeName(String val) {\n        if (val == null)\n            return null;\n        return val.replaceAll(\"\\\"\", \"%22\");\n    }\n\n    private Connection.Request req; private Connection.Response res; private HttpConnection() {\n        req = new Request();\n        res = new Response();\n    }\n\n    public Connection url(URL url) {\n        req.url(url);\n        return this;\n    }\n\n    public Connection url(String url) {\n        Validate.notEmpty(url, \"Must supply a valid URL\");\n        try {\n            req.url(new URL(encodeUrl(url)));\n        } catch (MalformedURLException e) {\n            throw new IllegalArgumentException(\"Malformed URL: \" + url, e);\n        }\n        return this;\n    }\n\n    public Connection userAgent(String userAgent) {\n        Validate.notNull(userAgent, \"User agent must not be null\");\n        req.header(\"User-Agent\", userAgent);\n        return this;\n    }\n\n    public Connection timeout(int millis) {\n        req.timeout(millis);\n        return this;\n    }\n\n    public Connection maxBodySize(int bytes) {\n        req.maxBodySize(bytes);\n        return this;\n    }\n\n    public Connection followRedirects(boolean followRedirects) {\n        req.followRedirects(followRedirects);\n        return this;\n    }\n\n    public Connection referrer(String referrer) {\n        Validate.notNull(referrer, \"Referrer must not be null\");\n        req.header(\"Referer\", referrer);\n        return this;\n    }\n\n    public Connection method(Method method) {\n        req.method(method);\n        return this;\n    }\n\n    public Connection ignoreHttpErrors(boolean ignoreHttpErrors) {\n\t\treq.ignoreHttpErrors(ignoreHttpErrors);\n\t\treturn this;\n\t}\n\n    public Connection ignoreContentType(boolean ignoreContentType) {\n        req.ignoreContentType(ignoreContentType);\n        return this;\n    }\n\n    public Connection validateTLSCertificates(boolean value) {\n        req.validateTLSCertificates(value);\n        return this;\n    }\n\n    public Connection data(String key, String value) {\n        req.data(KeyVal.create(key, value));\n        return this;\n    }\n\n    public Connection data(String key, String filename, InputStream inputStream) {\n        req.data(KeyVal.create(key, filename, inputStream));\n        return this;\n    }\n\n    public Connection data(Map<String, String> data) {\n        Validate.notNull(data, \"Data map must not be null\");\n        for (Map.Entry<String, String> entry : data.entrySet()) {\n            req.data(KeyVal.create(entry.getKey(), entry.getValue()));\n        }\n        return this;\n    }\n\n    public Connection data(String... keyvals) {\n        Validate.notNull(keyvals, \"Data key value pairs must not be null\");\n        Validate.isTrue(keyvals.length %2 == 0, \"Must supply an even number of key value pairs\");\n        for (int i = 0; i < keyvals.length; i += 2) {\n            String key = keyvals[i];\n            String value = keyvals[i+1];\n            Validate.notEmpty(key, \"Data key must not be empty\");\n            Validate.notNull(value, \"Data value must not be null\");\n            req.data(KeyVal.create(key, value));\n        }\n        return this;\n    }\n\n    public Connection data(Collection<Connection.KeyVal> data) {\n        Validate.notNull(data, \"Data collection must not be null\");\n        for (Connection.KeyVal entry: data) {\n            req.data(entry);\n        }\n        return this;\n    }\n\n    public Connection header(String name, String value) {\n        req.header(name, value);\n        return this;\n    }\n\n    public Connection cookie(String name, String value) {\n        req.cookie(name, value);\n        return this;\n    }\n\n    public Connection cookies(Map<String, String> cookies) {\n        Validate.notNull(cookies, \"Cookie map must not be null\");\n        for (Map.Entry<String, String> entry : cookies.entrySet()) {\n            req.cookie(entry.getKey(), entry.getValue());\n        }\n        return this;\n    }\n\n    public Connection parser(Parser parser) {\n        req.parser(parser);\n        return this;\n    }\n\n    public Document get() throws IOException {\n        req.method(Method.GET);\n        execute();\n        return res.parse();\n    }\n\n    public Document post() throws IOException {\n        req.method(Method.POST);\n        execute();\n        return res.parse();\n    }\n\n    public Connection.Response execute() throws IOException {\n        res = Response.execute(req);\n        return res;\n    }\n\n    public Connection.Request request() {\n        return req;\n    }\n\n    public Connection request(Connection.Request request) {\n        req = request;\n        return this;\n    }\n\n    public Connection.Response response() {\n        return res;\n    }\n\n    public Connection response(Connection.Response response) {\n        res = response;\n        return this;\n    }\n\n    public Connection postDataCharset(String charset) {\n        req.postDataCharset(charset);\n        return this;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    private static abstract class Base<T extends Connection.Base> implements Connection.Base<T> { URL url; Method method; Map<String, String> headers; Map<String, String> cookies; private Base() {\n            headers = new LinkedHashMap<String, String>();\n            cookies = new LinkedHashMap<String, String>();\n        }\n\n        public URL url() {\n            return url;\n        }\n\n        public T url(URL url) {\n            Validate.notNull(url, \"URL must not be null\");\n            this.url = url;\n            return (T) this;\n        }\n\n        public Method method() {\n            return method;\n        }\n\n        public T method(Method method) {\n            Validate.notNull(method, \"Method must not be null\");\n            this.method = method;\n            return (T) this;\n        }\n\n        public String header(String name) {\n            Validate.notNull(name, \"Header name must not be null\");\n            return getHeaderCaseInsensitive(name);\n        }\n\n        public T header(String name, String value) {\n            Validate.notEmpty(name, \"Header name must not be empty\");\n            Validate.notNull(value, \"Header value must not be null\");\n            removeHeader(name); \n            headers.put(name, value);\n            return (T) this;\n        }\n\n        public boolean hasHeader(String name) {\n            Validate.notEmpty(name, \"Header name must not be empty\");\n            return getHeaderCaseInsensitive(name) != null;\n        }\n\n        \n        public boolean hasHeaderWithValue(String name, String value) {\n            return hasHeader(name) && header(name).equalsIgnoreCase(value);\n        }\n\n        public T removeHeader(String name) {\n            Validate.notEmpty(name, \"Header name must not be empty\");\n            Map.Entry<String, String> entry = scanHeaders(name); \n            if (entry != null)\n                headers.remove(entry.getKey()); \n            return (T) this;\n        }\n\n        public Map<String, String> headers() {\n            return headers;\n        }\n\n        private String getHeaderCaseInsensitive(String name) {\n            Validate.notNull(name, \"Header name must not be null\");\n            \n            String value = headers.get(name);\n            if (value == null)\n                value = headers.get(name.toLowerCase());\n            if (value == null) {\n                Map.Entry<String, String> entry = scanHeaders(name);\n                if (entry != null)\n                    value = entry.getValue();\n            }\n            return value;\n        }\n\n        private Map.Entry<String, String> scanHeaders(String name) {\n            String lc = name.toLowerCase();\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                if (entry.getKey().toLowerCase().equals(lc))\n                    return entry;\n            }\n            return null;\n        }\n\n        public String cookie(String name) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            return cookies.get(name);\n        }\n\n        public T cookie(String name, String value) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            Validate.notNull(value, \"Cookie value must not be null\");\n            cookies.put(name, value);\n            return (T) this;\n        }\n\n        public boolean hasCookie(String name) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            return cookies.containsKey(name);\n        }\n\n        public T removeCookie(String name) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            cookies.remove(name);\n            return (T) this;\n        }\n\n        public Map<String, String> cookies() {\n            return cookies;\n        }\n    }\n\n    public static class Request extends HttpConnection.Base<Connection.Request> implements Connection.Request { private int timeoutMilliseconds; private int maxBodySizeBytes; private boolean followRedirects; private Collection<Connection.KeyVal> data; private boolean ignoreHttpErrors = false; private boolean ignoreContentType = false; private Parser parser; private boolean parserDefined = false; private boolean validateTSLCertificates = true; private String postDataCharset = DataUtil.defaultCharset; private Request() {\n            timeoutMilliseconds = 3000;\n            maxBodySizeBytes = 1024 * 1024; \n            followRedirects = true;\n            data = new ArrayList<Connection.KeyVal>();\n            method = Method.GET;\n            headers.put(\"Accept-Encoding\", \"gzip\");\n            parser = Parser.htmlParser();\n        }\n\n        public int timeout() {\n            return timeoutMilliseconds;\n        }\n\n        public Request timeout(int millis) {\n            Validate.isTrue(millis >= 0, \"Timeout milliseconds must be 0 (infinite) or greater\");\n            timeoutMilliseconds = millis;\n            return this;\n        }\n\n        public int maxBodySize() {\n            return maxBodySizeBytes;\n        }\n\n        public Connection.Request maxBodySize(int bytes) {\n            Validate.isTrue(bytes >= 0, \"maxSize must be 0 (unlimited) or larger\");\n            maxBodySizeBytes = bytes;\n            return this;\n        }\n\n        public boolean followRedirects() {\n            return followRedirects;\n        }\n\n        public Connection.Request followRedirects(boolean followRedirects) {\n            this.followRedirects = followRedirects;\n            return this;\n        }\n\n        public boolean ignoreHttpErrors() {\n            return ignoreHttpErrors;\n        }\n\n        public boolean validateTLSCertificates() {\n            return validateTSLCertificates;\n        }\n\n        public void validateTLSCertificates(boolean value) {\n            validateTSLCertificates = value;\n        }\n\n        public Connection.Request ignoreHttpErrors(boolean ignoreHttpErrors) {\n            this.ignoreHttpErrors = ignoreHttpErrors;\n            return this;\n        }\n\n        public boolean ignoreContentType() {\n            return ignoreContentType;\n        }\n\n        public Connection.Request ignoreContentType(boolean ignoreContentType) {\n            this.ignoreContentType = ignoreContentType;\n            return this;\n        }\n\n        public Request data(Connection.KeyVal keyval) {\n            Validate.notNull(keyval, \"Key val must not be null\");\n            data.add(keyval);\n            return this;\n        }\n\n        public Collection<Connection.KeyVal> data() {\n            return data;\n        }\n\n        public Request parser(Parser parser) {\n            this.parser = parser;\n            parserDefined = true;\n            return this;\n        }\n\n        public Parser parser() {\n            return parser;\n        }\n\n        public Connection.Request postDataCharset(String charset) {\n            Validate.notNull(charset, \"Charset must not be null\");\n            if (!Charset.isSupported(charset)) throw new IllegalCharsetNameException(charset);\n            this.postDataCharset = charset;\n            return this;\n        }\n\n        public String postDataCharset() {\n            return postDataCharset;\n        }\n    }\n\n    public static class Response extends HttpConnection.Base<Connection.Response> implements Connection.Response { private static final int MAX_REDIRECTS = 20; private static SSLSocketFactory sslSocketFactory; private static final String LOCATION = \"Location\"; private int statusCode; private String statusMessage; private ByteBuffer byteData; private String charset; private String contentType; private boolean executed = false; private int numRedirects = 0; private Connection.Request req; private static final Pattern xmlContentTypeRxp = Pattern.compile(\"(application|text)/\\\\w*\\\\+?xml.*\"); Response() {\n            super();\n        }\n\n        private Response(Response previousResponse) throws IOException {\n            super();\n            if (previousResponse != null) {\n                numRedirects = previousResponse.numRedirects + 1;\n                if (numRedirects >= MAX_REDIRECTS)\n                    throw new IOException(String.format(\"Too many redirects occurred trying to load URL %s\", previousResponse.url()));\n            }\n        }\n\n        static Response execute(Connection.Request req) throws IOException {\n            return execute(req, null);\n        }\n\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n\n            \n            String mimeBoundary = null;\n            if (!req.method().hasBody() && req.data().size() > 0) {\n                serialiseRequestUrl(req); \n            } else if (req.method().hasBody()) {\n                mimeBoundary = setOutputContentType(req);\n            }\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                \n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    req.method(Method.GET); \n                    req.data().clear();\n\n                    String location = res.header(LOCATION);\n                    if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') \n                        location = location.substring(6);\n                    req.url(StringUtil.resolve(req.url(), encodeUrl(location)));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { \n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                \n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text\n        private static HostnameVerifier getInsecureVerifier() {\n            return new HostnameVerifier() {\n                public boolean verify(String urlHostName, SSLSession session) {\n                    return true;\n                }\n            };\n        }\n\n        \n        private static synchronized void initUnSecureTSL() throws IOException {\n            if (sslSocketFactory == null) {\n                \n                final TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {\n\n                    public void checkClientTrusted(final X509Certificate[] chain, final String authType) {\n                    }\n\n                    public void checkServerTrusted(final X509Certificate[] chain, final String authType) {\n                    }\n\n                    public X509Certificate[] getAcceptedIssuers() {\n                        return null;\n                    }\n                }};\n\n                \n                final SSLContext sslContext;\n                try {\n                    sslContext = SSLContext.getInstance(\"SSL\");\n                    sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n                    \n                    sslSocketFactory = sslContext.getSocketFactory();\n                } catch (NoSuchAlgorithmException e) {\n                    throw new IOException(\"Can't create unsecure trust manager\");\n                } catch (KeyManagementException e) {\n                    throw new IOException(\"Can't create unsecure trust manager\");\n                }\n            }\n\n        }\n\n        \n        private void setupFromConnection(HttpURLConnection conn, Connection.Response previousResponse) throws IOException {\n            method = Method.valueOf(conn.getRequestMethod());\n            url = conn.getURL();\n            statusCode = conn.getResponseCode();\n            statusMessage = conn.getResponseMessage();\n            contentType = conn.getContentType();\n\n            Map<String, List<String>> resHeaders = createHeaderMap(conn);\n            processResponseHeaders(resHeaders);\n\n            \n            if (previousResponse != null) {\n                for (Map.Entry<String, String> prevCookie : previousResponse.cookies().entrySet()) {\n                    if (!hasCookie(prevCookie.getKey()))\n                        cookie(prevCookie.getKey(), prevCookie.getValue());\n                }\n            }\n        }\n\n        private static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn) {\n            \n            final LinkedHashMap<String, List<String>> headers = new LinkedHashMap<String, List<String>>();\n            int i = 0;\n            while (true) {\n                final String key = conn.getHeaderFieldKey(i);\n                final String val = conn.getHeaderField(i);\n                if (key == null && val == null)\n                    break;\n                i++;\n                if (key == null || val == null)\n                    continue; \n\n                if (headers.containsKey(key))\n                    headers.get(key).add(val);\n                else {\n                    final ArrayList<String> vals = new ArrayList<String>();\n                    vals.add(val);\n                    headers.put(key, vals);\n                }\n            }\n            return headers;\n        }\n\n        void processResponseHeaders(Map<String, List<String>> resHeaders) {\n            for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n                String name = entry.getKey();\n                if (name == null)\n                    continue; \n\n                List<String> values = entry.getValue();\n                if (name.equalsIgnoreCase(\"Set-Cookie\")) {\n                    for (String value : values) {\n                        if (value == null)\n                            continue;\n                        TokenQueue cd = new TokenQueue(value);\n                        String cookieName = cd.chompTo(\"=\").trim();\n                        String cookieVal = cd.consumeTo(\";\").trim();\n                        \n                        \n                        if (cookieName.length() > 0)\n                            cookie(cookieName, cookieVal);\n                    }\n                } else { \n                    if (!values.isEmpty())\n                        header(name, values.get(0));\n                }\n            }\n        }\n\n        private static String setOutputContentType(final Connection.Request req) {\n            \n            boolean needsMulti = false;\n            for (Connection.KeyVal keyVal : req.data()) {\n                if (keyVal.hasInputStream()) {\n                    needsMulti = true;\n                    break;\n                }\n            }\n            String bound = null;\n            if (needsMulti) {\n                bound = DataUtil.mimeBoundary();\n                req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n            } else {\n                req.header(CONTENT_TYPE, FORM_URL_ENCODED + \"; charset=\" + req.postDataCharset());\n            }\n            return bound;\n        }\n\n        private static void writePost(final Connection.Request req, final OutputStream outputStream, final String bound) throws IOException {\n            final Collection<Connection.KeyVal> data = req.data();\n            final BufferedWriter w = new BufferedWriter(new OutputStreamWriter(outputStream, DataUtil.defaultCharset));\n\n            if (bound != null) {\n                \n                for (Connection.KeyVal keyVal : data) {\n                    w.write(\"--\");\n                    w.write(bound);\n                    w.write(\"\\r\\n\");\n                    w.write(\"Content-Disposition: form-data; name=\\\"\");\n                    w.write(encodeMimeName(keyVal.key())); \n                    w.write(\"\\\"\");\n                    if (keyVal.hasInputStream()) {\n                        w.write(\"; filename=\\\"\");\n                        w.write(encodeMimeName(keyVal.value()));\n                        w.write(\"\\\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n\");\n                        w.flush(); \n                        DataUtil.crossStreams(keyVal.inputStream(), outputStream);\n                        outputStream.flush();\n                    } else {\n                        w.write(\"\\r\\n\\r\\n\");\n                        w.write(keyVal.value());\n                    }\n                    w.write(\"\\r\\n\");\n                }\n                w.write(\"--\");\n                w.write(bound);\n                w.write(\"--\");\n            } else {\n                \n                boolean first = true;\n                for (Connection.KeyVal keyVal : data) {\n                    if (!first)\n                        w.append('&');\n                    else\n                        first = false;\n\n                    w.write(URLEncoder.encode(keyVal.key(), req.postDataCharset()));\n                    w.write('=');\n                    w.write(URLEncoder.encode(keyVal.value(), req.postDataCharset()));\n                }\n            }\n            w.close();\n        }\n\n        private static String getRequestCookieString(Connection.Request req) {\n            StringBuilder sb = new StringBuilder();\n            boolean first = true;\n            for (Map.Entry<String, String> cookie : req.cookies().entrySet()) {\n                if (!first)\n                    sb.append(\"; \");\n                else\n                    first = false;\n                sb.append(cookie.getKey()).append('=').append(cookie.getValue());\n                \n            }\n            return sb.toString();\n        }\n\n        \n        private static void serialiseRequestUrl(Connection.Request req) throws IOException {\n            URL in = req.url();\n            StringBuilder url = new StringBuilder();\n            boolean first = true;\n            \n            url\n                .append(in.getProtocol())\n                .append(\":\n                .append(in.getAuthority()) \n                .append(in.getPath())\n                .append(\"?\");\n            if (in.getQuery() != null) {\n                url.append(in.getQuery());\n                first = false;\n            }\n            for (Connection.KeyVal keyVal : req.data()) {\n                if (!first)\n                    url.append('&');\n                else\n                    first = false;\n                url\n                    .append(URLEncoder.encode(keyVal.key(), DataUtil.defaultCharset))\n                    .append('=')\n                    .append(URLEncoder.encode(keyVal.value(), DataUtil.defaultCharset));\n            }\n            req.url(new URL(url.toString()));\n            req.data().clear(); \n        }\n    }\n\n    public static class KeyVal implements Connection.KeyVal { private String key; private String value; private InputStream stream; public static KeyVal create(String key, String value) {\n            return new KeyVal().key(key).value(value);\n        }\n\n        public static KeyVal create(String key, String filename, InputStream stream) {\n            return new KeyVal().key(key).value(filename).inputStream(stream);\n        }\n\n        private KeyVal() {}\n\n        public KeyVal key(String key) {\n            Validate.notEmpty(key, \"Data key must not be empty\");\n            this.key = key;\n            return this;\n        }\n\n        public String key() {\n            return key;\n        }\n\n        public KeyVal value(String value) {\n            Validate.notNull(value, \"Data value must not be null\");\n            this.value = value;\n            return this;\n        }\n\n        public String value() {\n            return value;\n        }\n\n        public KeyVal inputStream(InputStream inputStream) {\n            Validate.notNull(value, \"Data input stream must not be null\");\n            this.stream = inputStream;\n            return this;\n        }\n\n        public InputStream inputStream() {\n            return stream;\n        }\n\n        public boolean hasInputStream() {\n            return stream != null;\n        }\n\n        @Override\n        public String toString() {\n            return key + \"=\" + value;\n        }\n    }\n}\n",
      "fixed_full_code": "package org.jsoup.helper;\n\nimport org.jsoup.Connection;\nimport org.jsoup.HttpStatusException;\nimport org.jsoup.UnsupportedMimeTypeException;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.parser.TokenQueue;\n\nimport javax.net.ssl.*;\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.X509Certificate;\nimport java.util.*;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\n\n\npublic class HttpConnection implements Connection { public static final String CONTENT_ENCODING = \"Content-Encoding\"; private static final String CONTENT_TYPE = \"Content-Type\"; private static final String MULTIPART_FORM_DATA = \"multipart/form-data\"; private static final String FORM_URL_ENCODED = \"application/x-www-form-urlencoded\"; public static Connection connect(String url) {\n        Connection con = new HttpConnection();\n        con.url(url);\n        return con;\n    }\n\n    public static Connection connect(URL url) {\n        Connection con = new HttpConnection();\n        con.url(url);\n        return con;\n    }\n\n\tprivate static String encodeUrl(String url) {\n\t\tif(url == null)\n\t\t\treturn null;\n    \treturn url.replaceAll(\" \", \"%20\");\n\t}\n\n    private static String encodeMimeName(String val) {\n        if (val == null)\n            return null;\n        return val.replaceAll(\"\\\"\", \"%22\");\n    }\n\n    private Connection.Request req; private Connection.Response res; private HttpConnection() {\n        req = new Request();\n        res = new Response();\n    }\n\n    public Connection url(URL url) {\n        req.url(url);\n        return this;\n    }\n\n    public Connection url(String url) {\n        Validate.notEmpty(url, \"Must supply a valid URL\");\n        try {\n            req.url(new URL(encodeUrl(url)));\n        } catch (MalformedURLException e) {\n            throw new IllegalArgumentException(\"Malformed URL: \" + url, e);\n        }\n        return this;\n    }\n\n    public Connection userAgent(String userAgent) {\n        Validate.notNull(userAgent, \"User agent must not be null\");\n        req.header(\"User-Agent\", userAgent);\n        return this;\n    }\n\n    public Connection timeout(int millis) {\n        req.timeout(millis);\n        return this;\n    }\n\n    public Connection maxBodySize(int bytes) {\n        req.maxBodySize(bytes);\n        return this;\n    }\n\n    public Connection followRedirects(boolean followRedirects) {\n        req.followRedirects(followRedirects);\n        return this;\n    }\n\n    public Connection referrer(String referrer) {\n        Validate.notNull(referrer, \"Referrer must not be null\");\n        req.header(\"Referer\", referrer);\n        return this;\n    }\n\n    public Connection method(Method method) {\n        req.method(method);\n        return this;\n    }\n\n    public Connection ignoreHttpErrors(boolean ignoreHttpErrors) {\n\t\treq.ignoreHttpErrors(ignoreHttpErrors);\n\t\treturn this;\n\t}\n\n    public Connection ignoreContentType(boolean ignoreContentType) {\n        req.ignoreContentType(ignoreContentType);\n        return this;\n    }\n\n    public Connection validateTLSCertificates(boolean value) {\n        req.validateTLSCertificates(value);\n        return this;\n    }\n\n    public Connection data(String key, String value) {\n        req.data(KeyVal.create(key, value));\n        return this;\n    }\n\n    public Connection data(String key, String filename, InputStream inputStream) {\n        req.data(KeyVal.create(key, filename, inputStream));\n        return this;\n    }\n\n    public Connection data(Map<String, String> data) {\n        Validate.notNull(data, \"Data map must not be null\");\n        for (Map.Entry<String, String> entry : data.entrySet()) {\n            req.data(KeyVal.create(entry.getKey(), entry.getValue()));\n        }\n        return this;\n    }\n\n    public Connection data(String... keyvals) {\n        Validate.notNull(keyvals, \"Data key value pairs must not be null\");\n        Validate.isTrue(keyvals.length %2 == 0, \"Must supply an even number of key value pairs\");\n        for (int i = 0; i < keyvals.length; i += 2) {\n            String key = keyvals[i];\n            String value = keyvals[i+1];\n            Validate.notEmpty(key, \"Data key must not be empty\");\n            Validate.notNull(value, \"Data value must not be null\");\n            req.data(KeyVal.create(key, value));\n        }\n        return this;\n    }\n\n    public Connection data(Collection<Connection.KeyVal> data) {\n        Validate.notNull(data, \"Data collection must not be null\");\n        for (Connection.KeyVal entry: data) {\n            req.data(entry);\n        }\n        return this;\n    }\n\n    public Connection header(String name, String value) {\n        req.header(name, value);\n        return this;\n    }\n\n    public Connection cookie(String name, String value) {\n        req.cookie(name, value);\n        return this;\n    }\n\n    public Connection cookies(Map<String, String> cookies) {\n        Validate.notNull(cookies, \"Cookie map must not be null\");\n        for (Map.Entry<String, String> entry : cookies.entrySet()) {\n            req.cookie(entry.getKey(), entry.getValue());\n        }\n        return this;\n    }\n\n    public Connection parser(Parser parser) {\n        req.parser(parser);\n        return this;\n    }\n\n    public Document get() throws IOException {\n        req.method(Method.GET);\n        execute();\n        return res.parse();\n    }\n\n    public Document post() throws IOException {\n        req.method(Method.POST);\n        execute();\n        return res.parse();\n    }\n\n    public Connection.Response execute() throws IOException {\n        res = Response.execute(req);\n        return res;\n    }\n\n    public Connection.Request request() {\n        return req;\n    }\n\n    public Connection request(Connection.Request request) {\n        req = request;\n        return this;\n    }\n\n    public Connection.Response response() {\n        return res;\n    }\n\n    public Connection response(Connection.Response response) {\n        res = response;\n        return this;\n    }\n\n    public Connection postDataCharset(String charset) {\n        req.postDataCharset(charset);\n        return this;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    private static abstract class Base<T extends Connection.Base> implements Connection.Base<T> { URL url; Method method; Map<String, String> headers; Map<String, String> cookies; private Base() {\n            headers = new LinkedHashMap<String, String>();\n            cookies = new LinkedHashMap<String, String>();\n        }\n\n        public URL url() {\n            return url;\n        }\n\n        public T url(URL url) {\n            Validate.notNull(url, \"URL must not be null\");\n            this.url = url;\n            return (T) this;\n        }\n\n        public Method method() {\n            return method;\n        }\n\n        public T method(Method method) {\n            Validate.notNull(method, \"Method must not be null\");\n            this.method = method;\n            return (T) this;\n        }\n\n        public String header(String name) {\n            Validate.notNull(name, \"Header name must not be null\");\n            return getHeaderCaseInsensitive(name);\n        }\n\n        public T header(String name, String value) {\n            Validate.notEmpty(name, \"Header name must not be empty\");\n            Validate.notNull(value, \"Header value must not be null\");\n            removeHeader(name); \n            headers.put(name, value);\n            return (T) this;\n        }\n\n        public boolean hasHeader(String name) {\n            Validate.notEmpty(name, \"Header name must not be empty\");\n            return getHeaderCaseInsensitive(name) != null;\n        }\n\n        \n        public boolean hasHeaderWithValue(String name, String value) {\n            return hasHeader(name) && header(name).equalsIgnoreCase(value);\n        }\n\n        public T removeHeader(String name) {\n            Validate.notEmpty(name, \"Header name must not be empty\");\n            Map.Entry<String, String> entry = scanHeaders(name); \n            if (entry != null)\n                headers.remove(entry.getKey()); \n            return (T) this;\n        }\n\n        public Map<String, String> headers() {\n            return headers;\n        }\n\n        private String getHeaderCaseInsensitive(String name) {\n            Validate.notNull(name, \"Header name must not be null\");\n            \n            String value = headers.get(name);\n            if (value == null)\n                value = headers.get(name.toLowerCase());\n            if (value == null) {\n                Map.Entry<String, String> entry = scanHeaders(name);\n                if (entry != null)\n                    value = entry.getValue();\n            }\n            return value;\n        }\n\n        private Map.Entry<String, String> scanHeaders(String name) {\n            String lc = name.toLowerCase();\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                if (entry.getKey().toLowerCase().equals(lc))\n                    return entry;\n            }\n            return null;\n        }\n\n        public String cookie(String name) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            return cookies.get(name);\n        }\n\n        public T cookie(String name, String value) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            Validate.notNull(value, \"Cookie value must not be null\");\n            cookies.put(name, value);\n            return (T) this;\n        }\n\n        public boolean hasCookie(String name) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            return cookies.containsKey(name);\n        }\n\n        public T removeCookie(String name) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            cookies.remove(name);\n            return (T) this;\n        }\n\n        public Map<String, String> cookies() {\n            return cookies;\n        }\n    }\n\n    public static class Request extends HttpConnection.Base<Connection.Request> implements Connection.Request { private int timeoutMilliseconds; private int maxBodySizeBytes; private boolean followRedirects; private Collection<Connection.KeyVal> data; private boolean ignoreHttpErrors = false; private boolean ignoreContentType = false; private Parser parser; private boolean parserDefined = false; private boolean validateTSLCertificates = true; private String postDataCharset = DataUtil.defaultCharset; private Request() {\n            timeoutMilliseconds = 3000;\n            maxBodySizeBytes = 1024 * 1024; \n            followRedirects = true;\n            data = new ArrayList<Connection.KeyVal>();\n            method = Method.GET;\n            headers.put(\"Accept-Encoding\", \"gzip\");\n            parser = Parser.htmlParser();\n        }\n\n        public int timeout() {\n            return timeoutMilliseconds;\n        }\n\n        public Request timeout(int millis) {\n            Validate.isTrue(millis >= 0, \"Timeout milliseconds must be 0 (infinite) or greater\");\n            timeoutMilliseconds = millis;\n            return this;\n        }\n\n        public int maxBodySize() {\n            return maxBodySizeBytes;\n        }\n\n        public Connection.Request maxBodySize(int bytes) {\n            Validate.isTrue(bytes >= 0, \"maxSize must be 0 (unlimited) or larger\");\n            maxBodySizeBytes = bytes;\n            return this;\n        }\n\n        public boolean followRedirects() {\n            return followRedirects;\n        }\n\n        public Connection.Request followRedirects(boolean followRedirects) {\n            this.followRedirects = followRedirects;\n            return this;\n        }\n\n        public boolean ignoreHttpErrors() {\n            return ignoreHttpErrors;\n        }\n\n        public boolean validateTLSCertificates() {\n            return validateTSLCertificates;\n        }\n\n        public void validateTLSCertificates(boolean value) {\n            validateTSLCertificates = value;\n        }\n\n        public Connection.Request ignoreHttpErrors(boolean ignoreHttpErrors) {\n            this.ignoreHttpErrors = ignoreHttpErrors;\n            return this;\n        }\n\n        public boolean ignoreContentType() {\n            return ignoreContentType;\n        }\n\n        public Connection.Request ignoreContentType(boolean ignoreContentType) {\n            this.ignoreContentType = ignoreContentType;\n            return this;\n        }\n\n        public Request data(Connection.KeyVal keyval) {\n            Validate.notNull(keyval, \"Key val must not be null\");\n            data.add(keyval);\n            return this;\n        }\n\n        public Collection<Connection.KeyVal> data() {\n            return data;\n        }\n\n        public Request parser(Parser parser) {\n            this.parser = parser;\n            parserDefined = true;\n            return this;\n        }\n\n        public Parser parser() {\n            return parser;\n        }\n\n        public Connection.Request postDataCharset(String charset) {\n            Validate.notNull(charset, \"Charset must not be null\");\n            if (!Charset.isSupported(charset)) throw new IllegalCharsetNameException(charset);\n            this.postDataCharset = charset;\n            return this;\n        }\n\n        public String postDataCharset() {\n            return postDataCharset;\n        }\n    }\n\n    public static class Response extends HttpConnection.Base<Connection.Response> implements Connection.Response { private static final int MAX_REDIRECTS = 20; private static SSLSocketFactory sslSocketFactory; private static final String LOCATION = \"Location\"; private int statusCode; private String statusMessage; private ByteBuffer byteData; private String charset; private String contentType; private boolean executed = false; private int numRedirects = 0; private Connection.Request req; private static final Pattern xmlContentTypeRxp = Pattern.compile(\"(application|text)/\\\\w*\\\\+?xml.*\"); Response() {\n            super();\n        }\n\n        private Response(Response previousResponse) throws IOException {\n            super();\n            if (previousResponse != null) {\n                numRedirects = previousResponse.numRedirects + 1;\n                if (numRedirects >= MAX_REDIRECTS)\n                    throw new IOException(String.format(\"Too many redirects occurred trying to load URL %s\", previousResponse.url()));\n            }\n        }\n\n        static Response execute(Connection.Request req) throws IOException {\n            return execute(req, null);\n        }\n\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n\n            \n            String mimeBoundary = null;\n            if (!req.method().hasBody() && req.data().size() > 0) {\n                serialiseRequestUrl(req); \n            } else if (req.method().hasBody()) {\n                mimeBoundary = setOutputContentType(req);\n            }\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                \n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    req.method(Method.GET); \n                    req.data().clear();\n\n                    String location = res.header(LOCATION);\n                    if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') \n                        location = location.substring(6);\n                    req.url(StringUtil.resolve(req.url(), encodeUrl(location)));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { \n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                \n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text\n        private static HostnameVerifier getInsecureVerifier() {\n            return new HostnameVerifier() {\n                public boolean verify(String urlHostName, SSLSession session) {\n                    return true;\n                }\n            };\n        }\n\n        \n        private static synchronized void initUnSecureTSL() throws IOException {\n            if (sslSocketFactory == null) {\n                \n                final TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {\n\n                    public void checkClientTrusted(final X509Certificate[] chain, final String authType) {\n                    }\n\n                    public void checkServerTrusted(final X509Certificate[] chain, final String authType) {\n                    }\n\n                    public X509Certificate[] getAcceptedIssuers() {\n                        return null;\n                    }\n                }};\n\n                \n                final SSLContext sslContext;\n                try {\n                    sslContext = SSLContext.getInstance(\"SSL\");\n                    sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n                    \n                    sslSocketFactory = sslContext.getSocketFactory();\n                } catch (NoSuchAlgorithmException e) {\n                    throw new IOException(\"Can't create unsecure trust manager\");\n                } catch (KeyManagementException e) {\n                    throw new IOException(\"Can't create unsecure trust manager\");\n                }\n            }\n\n        }\n\n        \n        private void setupFromConnection(HttpURLConnection conn, Connection.Response previousResponse) throws IOException {\n            method = Method.valueOf(conn.getRequestMethod());\n            url = conn.getURL();\n            statusCode = conn.getResponseCode();\n            statusMessage = conn.getResponseMessage();\n            contentType = conn.getContentType();\n\n            Map<String, List<String>> resHeaders = createHeaderMap(conn);\n            processResponseHeaders(resHeaders);\n\n            \n            if (previousResponse != null) {\n                for (Map.Entry<String, String> prevCookie : previousResponse.cookies().entrySet()) {\n                    if (!hasCookie(prevCookie.getKey()))\n                        cookie(prevCookie.getKey(), prevCookie.getValue());\n                }\n            }\n        }\n\n        private static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn) {\n            \n            final LinkedHashMap<String, List<String>> headers = new LinkedHashMap<String, List<String>>();\n            int i = 0;\n            while (true) {\n                final String key = conn.getHeaderFieldKey(i);\n                final String val = conn.getHeaderField(i);\n                if (key == null && val == null)\n                    break;\n                i++;\n                if (key == null || val == null)\n                    continue; \n\n                if (headers.containsKey(key))\n                    headers.get(key).add(val);\n                else {\n                    final ArrayList<String> vals = new ArrayList<String>();\n                    vals.add(val);\n                    headers.put(key, vals);\n                }\n            }\n            return headers;\n        }\n\n        void processResponseHeaders(Map<String, List<String>> resHeaders) {\n            for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n                String name = entry.getKey();\n                if (name == null)\n                    continue; \n\n                List<String> values = entry.getValue();\n                if (name.equalsIgnoreCase(\"Set-Cookie\")) {\n                    for (String value : values) {\n                        if (value == null)\n                            continue;\n                        TokenQueue cd = new TokenQueue(value);\n                        String cookieName = cd.chompTo(\"=\").trim();\n                        String cookieVal = cd.consumeTo(\";\").trim();\n                        \n                        \n                        if (cookieName.length() > 0)\n                            cookie(cookieName, cookieVal);\n                    }\n                } else { \n                    if (values.size() == 1)\n                        header(name, values.get(0));\n                    else if (values.size() > 1) {\n                        StringBuilder accum = new StringBuilder();\n                        for (int i = 0; i < values.size(); i++) {\n                            final String val = values.get(i);\n                            if (i != 0)\n                                accum.append(\", \");\n                            accum.append(val);\n                        }\n                        header(name, accum.toString());\n                    }\n                }\n            }\n        }\n\n        private static String setOutputContentType(final Connection.Request req) {\n            \n            boolean needsMulti = false;\n            for (Connection.KeyVal keyVal : req.data()) {\n                if (keyVal.hasInputStream()) {\n                    needsMulti = true;\n                    break;\n                }\n            }\n            String bound = null;\n            if (needsMulti) {\n                bound = DataUtil.mimeBoundary();\n                req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n            } else {\n                req.header(CONTENT_TYPE, FORM_URL_ENCODED + \"; charset=\" + req.postDataCharset());\n            }\n            return bound;\n        }\n\n        private static void writePost(final Connection.Request req, final OutputStream outputStream, final String bound) throws IOException {\n            final Collection<Connection.KeyVal> data = req.data();\n            final BufferedWriter w = new BufferedWriter(new OutputStreamWriter(outputStream, DataUtil.defaultCharset));\n\n            if (bound != null) {\n                \n                for (Connection.KeyVal keyVal : data) {\n                    w.write(\"--\");\n                    w.write(bound);\n                    w.write(\"\\r\\n\");\n                    w.write(\"Content-Disposition: form-data; name=\\\"\");\n                    w.write(encodeMimeName(keyVal.key())); \n                    w.write(\"\\\"\");\n                    if (keyVal.hasInputStream()) {\n                        w.write(\"; filename=\\\"\");\n                        w.write(encodeMimeName(keyVal.value()));\n                        w.write(\"\\\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n\");\n                        w.flush(); \n                        DataUtil.crossStreams(keyVal.inputStream(), outputStream);\n                        outputStream.flush();\n                    } else {\n                        w.write(\"\\r\\n\\r\\n\");\n                        w.write(keyVal.value());\n                    }\n                    w.write(\"\\r\\n\");\n                }\n                w.write(\"--\");\n                w.write(bound);\n                w.write(\"--\");\n            } else {\n                \n                boolean first = true;\n                for (Connection.KeyVal keyVal : data) {\n                    if (!first)\n                        w.append('&');\n                    else\n                        first = false;\n\n                    w.write(URLEncoder.encode(keyVal.key(), req.postDataCharset()));\n                    w.write('=');\n                    w.write(URLEncoder.encode(keyVal.value(), req.postDataCharset()));\n                }\n            }\n            w.close();\n        }\n\n        private static String getRequestCookieString(Connection.Request req) {\n            StringBuilder sb = new StringBuilder();\n            boolean first = true;\n            for (Map.Entry<String, String> cookie : req.cookies().entrySet()) {\n                if (!first)\n                    sb.append(\"; \");\n                else\n                    first = false;\n                sb.append(cookie.getKey()).append('=').append(cookie.getValue());\n                \n            }\n            return sb.toString();\n        }\n\n        \n        private static void serialiseRequestUrl(Connection.Request req) throws IOException {\n            URL in = req.url();\n            StringBuilder url = new StringBuilder();\n            boolean first = true;\n            \n            url\n                .append(in.getProtocol())\n                .append(\":\n                .append(in.getAuthority()) \n                .append(in.getPath())\n                .append(\"?\");\n            if (in.getQuery() != null) {\n                url.append(in.getQuery());\n                first = false;\n            }\n            for (Connection.KeyVal keyVal : req.data()) {\n                if (!first)\n                    url.append('&');\n                else\n                    first = false;\n                url\n                    .append(URLEncoder.encode(keyVal.key(), DataUtil.defaultCharset))\n                    .append('=')\n                    .append(URLEncoder.encode(keyVal.value(), DataUtil.defaultCharset));\n            }\n            req.url(new URL(url.toString()));\n            req.data().clear(); \n        }\n    }\n\n    public static class KeyVal implements Connection.KeyVal { private String key; private String value; private InputStream stream; public static KeyVal create(String key, String value) {\n            return new KeyVal().key(key).value(value);\n        }\n\n        public static KeyVal create(String key, String filename, InputStream stream) {\n            return new KeyVal().key(key).value(filename).inputStream(stream);\n        }\n\n        private KeyVal() {}\n\n        public KeyVal key(String key) {\n            Validate.notEmpty(key, \"Data key must not be empty\");\n            this.key = key;\n            return this;\n        }\n\n        public String key() {\n            return key;\n        }\n\n        public KeyVal value(String value) {\n            Validate.notNull(value, \"Data value must not be null\");\n            this.value = value;\n            return this;\n        }\n\n        public String value() {\n            return value;\n        }\n\n        public KeyVal inputStream(InputStream inputStream) {\n            Validate.notNull(value, \"Data input stream must not be null\");\n            this.stream = inputStream;\n            return this;\n        }\n\n        public InputStream inputStream() {\n            return stream;\n        }\n\n        public boolean hasInputStream() {\n            return stream != null;\n        }\n\n        @Override\n        public String toString() {\n            return key + \"=\" + value;\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public static Connection connect(URL url)",
        "private static String encodeUrl(String url)",
        "private static String encodeMimeName(String val)",
        "private Connection.Request req; private Connection.Response res; private HttpConnection()",
        "public Connection url(URL url)",
        "public Connection url(String url)",
        "public Connection userAgent(String userAgent)",
        "public Connection timeout(int millis)",
        "public Connection maxBodySize(int bytes)",
        "public Connection followRedirects(boolean followRedirects)",
        "public Connection referrer(String referrer)",
        "public Connection method(Method method)",
        "public Connection ignoreHttpErrors(boolean ignoreHttpErrors)",
        "public Connection ignoreContentType(boolean ignoreContentType)",
        "public Connection validateTLSCertificates(boolean value)",
        "public Connection data(String key, String value)",
        "public Connection data(String key, String filename, InputStream inputStream)",
        "public Connection data(Map<String, String> data)",
        "public Connection data(String... keyvals)",
        "public Connection data(Collection<Connection.KeyVal> data)",
        "public Connection header(String name, String value)",
        "public Connection cookie(String name, String value)",
        "public Connection cookies(Map<String, String> cookies)",
        "public Connection parser(Parser parser)",
        "public Document get() throws IOException",
        "public Document post() throws IOException",
        "public Connection.Response execute() throws IOException",
        "public Connection.Request request()",
        "public Connection request(Connection.Request request)",
        "public Connection.Response response()",
        "public Connection response(Connection.Response response)",
        "public Connection postDataCharset(String charset)",
        "private static abstract class Base<T extends Connection.Base> implements Connection.Base<T> { URL url; Method method; Map<String, String> headers; Map<String, String> cookies; private Base()",
        "public URL url()",
        "public T url(URL url)",
        "public Method method()",
        "public T method(Method method)",
        "public String header(String name)",
        "public T header(String name, String value)",
        "public boolean hasHeader(String name)",
        "public boolean hasHeaderWithValue(String name, String value)",
        "public T removeHeader(String name)",
        "public Map<String, String> headers()",
        "private String getHeaderCaseInsensitive(String name)",
        "private Map.Entry<String, String> scanHeaders(String name)",
        "public String cookie(String name)",
        "public T cookie(String name, String value)",
        "public boolean hasCookie(String name)",
        "public T removeCookie(String name)",
        "public Map<String, String> cookies()",
        "public int timeout()",
        "public Request timeout(int millis)",
        "public int maxBodySize()",
        "public Connection.Request maxBodySize(int bytes)",
        "public boolean followRedirects()",
        "public Connection.Request followRedirects(boolean followRedirects)",
        "public boolean ignoreHttpErrors()",
        "public boolean validateTLSCertificates()",
        "public void validateTLSCertificates(boolean value)",
        "public Connection.Request ignoreHttpErrors(boolean ignoreHttpErrors)",
        "public boolean ignoreContentType()",
        "public Connection.Request ignoreContentType(boolean ignoreContentType)",
        "public Request data(Connection.KeyVal keyval)",
        "public Collection<Connection.KeyVal> data()",
        "public Request parser(Parser parser)",
        "public Parser parser()",
        "public Connection.Request postDataCharset(String charset)",
        "public String postDataCharset()",
        "private Response(Response previousResponse) throws IOException",
        "static Response execute(Connection.Request req) throws IOException",
        "static Response execute(Connection.Request req, Response previousResponse) throws IOException",
        "private static HostnameVerifier getInsecureVerifier()",
        "public boolean verify(String urlHostName, SSLSession session)",
        "private static synchronized void initUnSecureTSL() throws IOException",
        "public void checkClientTrusted(final X509Certificate[] chain, final String authType)",
        "public void checkServerTrusted(final X509Certificate[] chain, final String authType)",
        "public X509Certificate[] getAcceptedIssuers()",
        "private void setupFromConnection(HttpURLConnection conn, Connection.Response previousResponse) throws IOException",
        "private static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn)",
        "private static String setOutputContentType(final Connection.Request req)",
        "private static void writePost(final Connection.Request req, final OutputStream outputStream, final String bound) throws IOException",
        "private static String getRequestCookieString(Connection.Request req)",
        "private static void serialiseRequestUrl(Connection.Request req) throws IOException",
        "public static class KeyVal implements Connection.KeyVal { private String key; private String value; private InputStream stream; public static KeyVal create(String key, String value)",
        "public static KeyVal create(String key, String filename, InputStream stream)",
        "private KeyVal()",
        "public KeyVal key(String key)",
        "public String key()",
        "public KeyVal value(String value)",
        "public String value()",
        "public KeyVal inputStream(InputStream inputStream)",
        "public InputStream inputStream()",
        "public boolean hasInputStream()",
        "public String toString()"
      ],
      "fixed_signatures": [
        "public static Connection connect(URL url)",
        "private static String encodeUrl(String url)",
        "private static String encodeMimeName(String val)",
        "private Connection.Request req; private Connection.Response res; private HttpConnection()",
        "public Connection url(URL url)",
        "public Connection url(String url)",
        "public Connection userAgent(String userAgent)",
        "public Connection timeout(int millis)",
        "public Connection maxBodySize(int bytes)",
        "public Connection followRedirects(boolean followRedirects)",
        "public Connection referrer(String referrer)",
        "public Connection method(Method method)",
        "public Connection ignoreHttpErrors(boolean ignoreHttpErrors)",
        "public Connection ignoreContentType(boolean ignoreContentType)",
        "public Connection validateTLSCertificates(boolean value)",
        "public Connection data(String key, String value)",
        "public Connection data(String key, String filename, InputStream inputStream)",
        "public Connection data(Map<String, String> data)",
        "public Connection data(String... keyvals)",
        "public Connection data(Collection<Connection.KeyVal> data)",
        "public Connection header(String name, String value)",
        "public Connection cookie(String name, String value)",
        "public Connection cookies(Map<String, String> cookies)",
        "public Connection parser(Parser parser)",
        "public Document get() throws IOException",
        "public Document post() throws IOException",
        "public Connection.Response execute() throws IOException",
        "public Connection.Request request()",
        "public Connection request(Connection.Request request)",
        "public Connection.Response response()",
        "public Connection response(Connection.Response response)",
        "public Connection postDataCharset(String charset)",
        "private static abstract class Base<T extends Connection.Base> implements Connection.Base<T> { URL url; Method method; Map<String, String> headers; Map<String, String> cookies; private Base()",
        "public URL url()",
        "public T url(URL url)",
        "public Method method()",
        "public T method(Method method)",
        "public String header(String name)",
        "public T header(String name, String value)",
        "public boolean hasHeader(String name)",
        "public boolean hasHeaderWithValue(String name, String value)",
        "public T removeHeader(String name)",
        "public Map<String, String> headers()",
        "private String getHeaderCaseInsensitive(String name)",
        "private Map.Entry<String, String> scanHeaders(String name)",
        "public String cookie(String name)",
        "public T cookie(String name, String value)",
        "public boolean hasCookie(String name)",
        "public T removeCookie(String name)",
        "public Map<String, String> cookies()",
        "public int timeout()",
        "public Request timeout(int millis)",
        "public int maxBodySize()",
        "public Connection.Request maxBodySize(int bytes)",
        "public boolean followRedirects()",
        "public Connection.Request followRedirects(boolean followRedirects)",
        "public boolean ignoreHttpErrors()",
        "public boolean validateTLSCertificates()",
        "public void validateTLSCertificates(boolean value)",
        "public Connection.Request ignoreHttpErrors(boolean ignoreHttpErrors)",
        "public boolean ignoreContentType()",
        "public Connection.Request ignoreContentType(boolean ignoreContentType)",
        "public Request data(Connection.KeyVal keyval)",
        "public Collection<Connection.KeyVal> data()",
        "public Request parser(Parser parser)",
        "public Parser parser()",
        "public Connection.Request postDataCharset(String charset)",
        "public String postDataCharset()",
        "private Response(Response previousResponse) throws IOException",
        "static Response execute(Connection.Request req) throws IOException",
        "static Response execute(Connection.Request req, Response previousResponse) throws IOException",
        "private static HostnameVerifier getInsecureVerifier()",
        "public boolean verify(String urlHostName, SSLSession session)",
        "private static synchronized void initUnSecureTSL() throws IOException",
        "public void checkClientTrusted(final X509Certificate[] chain, final String authType)",
        "public void checkServerTrusted(final X509Certificate[] chain, final String authType)",
        "public X509Certificate[] getAcceptedIssuers()",
        "private void setupFromConnection(HttpURLConnection conn, Connection.Response previousResponse) throws IOException",
        "private static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn)",
        "private static String setOutputContentType(final Connection.Request req)",
        "private static void writePost(final Connection.Request req, final OutputStream outputStream, final String bound) throws IOException",
        "private static String getRequestCookieString(Connection.Request req)",
        "private static void serialiseRequestUrl(Connection.Request req) throws IOException",
        "public static class KeyVal implements Connection.KeyVal { private String key; private String value; private InputStream stream; public static KeyVal create(String key, String value)",
        "public static KeyVal create(String key, String filename, InputStream stream)",
        "private KeyVal()",
        "public KeyVal key(String key)",
        "public String key()",
        "public KeyVal value(String value)",
        "public String value()",
        "public KeyVal inputStream(InputStream inputStream)",
        "public InputStream inputStream()",
        "public boolean hasInputStream()",
        "public String toString()"
      ],
      "methods": [
        {
          "buggy_method": "  private static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn) {\n  \n  final LinkedHashMap<String, List<String>> headers = new LinkedHashMap<String, List<String>>();\n  int i = 0;\n  while (true) {\n  final String key = conn.getHeaderFieldKey(i);\n  final String val = conn.getHeaderField(i);\n  if (key == null && val == null)\n  break;\n  i++;\n  if (key == null || val == null)\n  continue; \n\n  if (headers.containsKey(key))\n  headers.get(key).add(val);\n  else {\n  final ArrayList<String> vals = new ArrayList<String>();\n  vals.add(val);\n  headers.put(key, vals);\n  }\n  }\n  return headers;\n  }",
          "fixed_method": "  private static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn) {\n  \n  final LinkedHashMap<String, List<String>> headers = new LinkedHashMap<String, List<String>>();\n  int i = 0;\n  while (true) {\n  final String key = conn.getHeaderFieldKey(i);\n  final String val = conn.getHeaderField(i);\n  if (key == null && val == null)\n  break;\n  i++;\n  if (key == null || val == null)\n  continue; \n\n  if (headers.containsKey(key))\n  headers.get(key).add(val);\n  else {\n  final ArrayList<String> vals = new ArrayList<String>();\n  vals.add(val);\n  headers.put(key, vals);\n  }\n  }\n  return headers;\n  }",
          "diff": [
            "@@ -770,8 +770,18 @@",
            "                             cookie(cookieName, cookieVal);\n",
            "                     }\n",
            "                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n",
            "-                    if (!values.isEmpty())\n",
            "+                    if (values.size() == 1)\n",
            "                         header(name, values.get(0));\n",
            "+                    else if (values.size() > 1) {\n",
            "+                        StringBuilder accum = new StringBuilder();\n",
            "+                        for (int i = 0; i < values.size(); i++) {\n",
            "+                            final String val = values.get(i);\n",
            "+                            if (i != 0)\n",
            "+                                accum.append(\", \");\n",
            "+                            accum.append(val);\n",
            "+                        }\n",
            "+                        header(name, accum.toString());\n",
            "+                    }\n",
            "                 }\n",
            "             }\n",
            "         }\n"
          ],
          "changed_lines": 12
        }
      ]
    }
  ]
}
