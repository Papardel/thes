{
  "bug_id": "20",
  "failed_tests": {
    "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStreamTest": [
      {
        "methodName": "testCpioUnarchiveCreatedByRedlineRpm",
        "error": "java.lang.IllegalArgumentException",
        "message": "Unknown mode. Full: 1a4 Masked: 0",
        "fail_line": "        while ((entry = (CpioArchiveEntry) in.getNextEntry()) != null) {",
        "test_source": "  public void testCpioUnarchiveCreatedByRedlineRpm() throws Exception {\n  CpioArchiveInputStream in =\n  new CpioArchiveInputStream(new FileInputStream(getFile(\"redline.cpio\")));\n  CpioArchiveEntry entry= null;\n\n  int count = 0;\n  while ((entry = (CpioArchiveEntry) in.getNextEntry()) != null) {\n  count++;\n  }\n  in.close();\n\n  assertEquals(count, 1);\n  }",
        "stack": [
          "CpioArchiveEntry.setMode line 769, CpioArchiveInputStream.readNewEntry line 332, CpioArchiveInputStream.getNextCPIOEntry line 204, CpioArchiveInputStream.getNextEntry line 450, CpioArchiveInputStreamTest.testCpioUnarchiveCreatedByRedlineRpm line 55"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.cpio;\n\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.utils.ArchiveUtils;\n\n\n\npublic class CpioArchiveInputStream extends ArchiveInputStream implements CpioConstants { private boolean closed = false; private CpioArchiveEntry entry; private long entryBytesRead = 0; private boolean entryEOF = false; private final byte tmpbuf[] = new byte[4096]; private long crc = 0; private final InputStream in; private final byte[] TWO_BYTES_BUF = new byte[2]; private final byte[] FOUR_BYTES_BUF = new byte[4]; private final byte[] SIX_BYTES_BUF = new byte[6]; private final int blockSize; public CpioArchiveInputStream(final InputStream in) {\n        this(in, BLOCK_SIZE);\n    }\n\n    \n    public CpioArchiveInputStream(final InputStream in, int blockSize) {\n        this.in = in;\n        this.blockSize = blockSize;\n    }\n\n    \n    @Override\n    public int available() throws IOException {\n        ensureOpen();\n        if (this.entryEOF) {\n            return 0;\n        }\n        return 1;\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        if (!this.closed) {\n            in.close();\n            this.closed = true;\n        }\n    }\n\n    \n    private void closeEntry() throws IOException {\n        ensureOpen();\n        while (read(this.tmpbuf, 0, this.tmpbuf.length) != -1) { \n            \n        }\n\n        this.entryEOF = true;\n    }\n\n    \n    private void ensureOpen() throws IOException {\n        if (this.closed) {\n            throw new IOException(\"Stream closed\");\n        }\n    }\n\n    \n    public CpioArchiveEntry getNextCPIOEntry() throws IOException {\n        ensureOpen();\n        if (this.entry != null) {\n            closeEntry();\n        }\n        readFully(TWO_BYTES_BUF, 0, TWO_BYTES_BUF.length);\n        if (CpioUtil.byteArray2long(TWO_BYTES_BUF, false) == MAGIC_OLD_BINARY) {\n            this.entry = readOldBinaryEntry(false);\n        } else if (CpioUtil.byteArray2long(TWO_BYTES_BUF, true)\n                   == MAGIC_OLD_BINARY) {\n            this.entry = readOldBinaryEntry(true);\n        } else {\n            System.arraycopy(TWO_BYTES_BUF, 0, SIX_BYTES_BUF, 0,\n                             TWO_BYTES_BUF.length);\n            readFully(SIX_BYTES_BUF, TWO_BYTES_BUF.length,\n                      FOUR_BYTES_BUF.length);\n            String magicString = ArchiveUtils.toAsciiString(SIX_BYTES_BUF);\n            if (magicString.equals(MAGIC_NEW)) {\n                this.entry = readNewEntry(false);\n            } else if (magicString.equals(MAGIC_NEW_CRC)) {\n                this.entry = readNewEntry(true);\n            } else if (magicString.equals(MAGIC_OLD_ASCII)) {\n                this.entry = readOldAsciiEntry();\n            } else {\n                throw new IOException(\"Unknown magic [\" + magicString + \"]. Occured at byte: \" + getBytesRead());\n            }\n        }\n\n        this.entryBytesRead = 0;\n        this.entryEOF = false;\n        this.crc = 0;\n\n        if (this.entry.getName().equals(CPIO_TRAILER)) {\n            this.entryEOF = true;\n            skipRemainderOfLastBlock();\n            return null;\n        }\n        return this.entry;\n    }\n\n    private void skip(int bytes) throws IOException {\n        \n        if (bytes > 0) {\n            readFully(FOUR_BYTES_BUF, 0, bytes);\n        }\n    }\n\n    \n    @Override\n    public int read(final byte[] b, final int off, final int len) throws IOException {\n        ensureOpen();\n        if (off < 0 || len < 0 || off > b.length - len) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        }\n\n        if (this.entry == null || this.entryEOF) {\n            return -1;\n        }\n        if (this.entryBytesRead == this.entry.getSize()) {\n            skip(entry.getDataPadCount());\n            this.entryEOF = true;\n            if (this.entry.getFormat() == FORMAT_NEW_CRC\n                && this.crc != this.entry.getChksum()) {\n                throw new IOException(\"CRC Error. Occured at byte: \"\n                                      + getBytesRead());\n            }\n            return -1; \n        }\n        int tmplength = (int) Math.min(len, this.entry.getSize()\n                - this.entryBytesRead);\n        if (tmplength < 0) {\n            return -1;\n        }\n\n        int tmpread = readFully(b, off, tmplength);\n        if (this.entry.getFormat() == FORMAT_NEW_CRC) {\n            for (int pos = 0; pos < tmpread; pos++) {\n                this.crc += b[pos] & 0xFF;\n            }\n        }\n        this.entryBytesRead += tmpread;\n\n        return tmpread;\n    }\n\n    private final int readFully(final byte[] b, final int off, final int len) throws IOException {\n        if (len < 0) {\n            throw new IndexOutOfBoundsException();\n        }\n        int n = 0;\n        while (n < len) {\n            int count = this.in.read(b, off + n, len - n);\n            count(count);\n            if (count < 0) {\n                throw new EOFException();\n            }\n            n += count;\n        }\n        return n;\n    }\n\n    private long readBinaryLong(final int length, final boolean swapHalfWord) throws IOException {\n        byte tmp[] = new byte[length];\n        readFully(tmp, 0, tmp.length);\n        return CpioUtil.byteArray2long(tmp, swapHalfWord);\n    }\n\n    private long readAsciiLong(final int length, final int radix) throws IOException {\n        byte tmpBuffer[] = new byte[length];\n        readFully(tmpBuffer, 0, tmpBuffer.length);\n        return Long.parseLong(ArchiveUtils.toAsciiString(tmpBuffer), radix);\n    }\n\n    private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException {\n        CpioArchiveEntry ret;\n        if (hasCrc) {\n            ret = new CpioArchiveEntry(FORMAT_NEW_CRC);\n        } else {\n            ret = new CpioArchiveEntry(FORMAT_NEW);\n        }\n\n        ret.setInode(readAsciiLong(8, 16));\n        long mode = readAsciiLong(8, 16);\n        if (mode != 0){\n            ret.setMode(mode);\n        }\n        ret.setUID(readAsciiLong(8, 16));\n        ret.setGID(readAsciiLong(8, 16));\n        ret.setNumberOfLinks(readAsciiLong(8, 16));\n        ret.setTime(readAsciiLong(8, 16));\n        ret.setSize(readAsciiLong(8, 16));\n        ret.setDeviceMaj(readAsciiLong(8, 16));\n        ret.setDeviceMin(readAsciiLong(8, 16));\n        ret.setRemoteDeviceMaj(readAsciiLong(8, 16));\n        ret.setRemoteDeviceMin(readAsciiLong(8, 16));\n        long namesize = readAsciiLong(8, 16);\n        ret.setChksum(readAsciiLong(8, 16));\n        String name = readCString((int) namesize);\n        ret.setName(name);\n        if (mode == 0 && !name.equals(CPIO_TRAILER)){\n            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \"+name + \" Occured at byte: \" + getBytesRead());\n        }\n        skip(ret.getHeaderPadCount());\n\n        return ret;\n    }\n\n    private CpioArchiveEntry readOldAsciiEntry() throws IOException {\n        CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_ASCII);\n\n        ret.setDevice(readAsciiLong(6, 8));\n        ret.setInode(readAsciiLong(6, 8));\n        final long mode = readAsciiLong(6, 8);\n        if (mode != 0) {\n            ret.setMode(mode);\n        }\n        ret.setUID(readAsciiLong(6, 8));\n        ret.setGID(readAsciiLong(6, 8));\n        ret.setNumberOfLinks(readAsciiLong(6, 8));\n        ret.setRemoteDevice(readAsciiLong(6, 8));\n        ret.setTime(readAsciiLong(11, 8));\n        long namesize = readAsciiLong(6, 8);\n        ret.setSize(readAsciiLong(11, 8));\n        final String name = readCString((int) namesize);\n        ret.setName(name);\n        if (mode == 0 && !name.equals(CPIO_TRAILER)){\n            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+ name + \" Occured at byte: \" + getBytesRead());\n        }\n\n        return ret;\n    }\n\n    private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord) throws IOException {\n        CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY);\n\n        ret.setDevice(readBinaryLong(2, swapHalfWord));\n        ret.setInode(readBinaryLong(2, swapHalfWord));\n        final long mode = readBinaryLong(2, swapHalfWord);\n        if (mode != 0){\n            ret.setMode(mode);\n        }\n        ret.setUID(readBinaryLong(2, swapHalfWord));\n        ret.setGID(readBinaryLong(2, swapHalfWord));\n        ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord));\n        ret.setRemoteDevice(readBinaryLong(2, swapHalfWord));\n        ret.setTime(readBinaryLong(4, swapHalfWord));\n        long namesize = readBinaryLong(2, swapHalfWord);\n        ret.setSize(readBinaryLong(4, swapHalfWord));\n        final String name = readCString((int) namesize);\n        ret.setName(name);\n        if (mode == 0 && !name.equals(CPIO_TRAILER)){\n            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+name + \"Occured at byte: \" + getBytesRead());\n        }\n        skip(ret.getHeaderPadCount());\n\n        return ret;\n    }\n\n    private String readCString(final int length) throws IOException {\n        byte tmpBuffer[] = new byte[length];\n        readFully(tmpBuffer, 0, tmpBuffer.length);\n        return new String(tmpBuffer, 0, tmpBuffer.length - 1); \n    }\n\n    \n    @Override\n    public long skip(final long n) throws IOException {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"negative skip length\");\n        }\n        ensureOpen();\n        int max = (int) Math.min(n, Integer.MAX_VALUE);\n        int total = 0;\n\n        while (total < max) {\n            int len = max - total;\n            if (len > this.tmpbuf.length) {\n                len = this.tmpbuf.length;\n            }\n            len = read(this.tmpbuf, 0, len);\n            if (len == -1) {\n                this.entryEOF = true;\n                break;\n            }\n            total += len;\n        }\n        return total;\n    }\n\n    @Override\n    public CpioArchiveEntry getNextEntry() throws IOException {\n        return getNextCPIOEntry();\n    }\n\n    \n    private void skipRemainderOfLastBlock() throws IOException {\n        long readFromLastBlock = getBytesRead() % blockSize;\n        long remainingBytes = readFromLastBlock == 0 ? 0\n            : blockSize - readFromLastBlock;\n        while (remainingBytes > 0) {\n            long skipped = skip(blockSize - readFromLastBlock);\n            if (skipped <= 0) {\n                break;\n            }\n            remainingBytes -= skipped;\n        }\n    }\n\n    \n    public static boolean matches(byte[] signature, int length) {\n        if (length < 6) {\n            return false;\n        }\n\n        \n        if (signature[0] == 0x71 && (signature[1] & 0xFF) == 0xc7) {\n            return true;\n        }\n        if (signature[1] == 0x71 && (signature[0] & 0xFF) == 0xc7) {\n            return true;\n        }\n\n        \n        \n        if (signature[0] != 0x30) {\n            return false;\n        }\n        if (signature[1] != 0x37) {\n            return false;\n        }\n        if (signature[2] != 0x30) {\n            return false;\n        }\n        if (signature[3] != 0x37) {\n            return false;\n        }\n        if (signature[4] != 0x30) {\n            return false;\n        }\n        \n        if (signature[5] == 0x31) {\n            return true;\n        }\n        if (signature[5] == 0x32) {\n            return true;\n        }\n        if (signature[5] == 0x37) {\n            return true;\n        }\n\n        return false;\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.cpio;\n\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.utils.ArchiveUtils;\n\n\n\npublic class CpioArchiveInputStream extends ArchiveInputStream implements CpioConstants { private boolean closed = false; private CpioArchiveEntry entry; private long entryBytesRead = 0; private boolean entryEOF = false; private final byte tmpbuf[] = new byte[4096]; private long crc = 0; private final InputStream in; private final byte[] TWO_BYTES_BUF = new byte[2]; private final byte[] FOUR_BYTES_BUF = new byte[4]; private final byte[] SIX_BYTES_BUF = new byte[6]; private final int blockSize; public CpioArchiveInputStream(final InputStream in) {\n        this(in, BLOCK_SIZE);\n    }\n\n    \n    public CpioArchiveInputStream(final InputStream in, int blockSize) {\n        this.in = in;\n        this.blockSize = blockSize;\n    }\n\n    \n    @Override\n    public int available() throws IOException {\n        ensureOpen();\n        if (this.entryEOF) {\n            return 0;\n        }\n        return 1;\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        if (!this.closed) {\n            in.close();\n            this.closed = true;\n        }\n    }\n\n    \n    private void closeEntry() throws IOException {\n        ensureOpen();\n        while (read(this.tmpbuf, 0, this.tmpbuf.length) != -1) { \n            \n        }\n\n        this.entryEOF = true;\n    }\n\n    \n    private void ensureOpen() throws IOException {\n        if (this.closed) {\n            throw new IOException(\"Stream closed\");\n        }\n    }\n\n    \n    public CpioArchiveEntry getNextCPIOEntry() throws IOException {\n        ensureOpen();\n        if (this.entry != null) {\n            closeEntry();\n        }\n        readFully(TWO_BYTES_BUF, 0, TWO_BYTES_BUF.length);\n        if (CpioUtil.byteArray2long(TWO_BYTES_BUF, false) == MAGIC_OLD_BINARY) {\n            this.entry = readOldBinaryEntry(false);\n        } else if (CpioUtil.byteArray2long(TWO_BYTES_BUF, true)\n                   == MAGIC_OLD_BINARY) {\n            this.entry = readOldBinaryEntry(true);\n        } else {\n            System.arraycopy(TWO_BYTES_BUF, 0, SIX_BYTES_BUF, 0,\n                             TWO_BYTES_BUF.length);\n            readFully(SIX_BYTES_BUF, TWO_BYTES_BUF.length,\n                      FOUR_BYTES_BUF.length);\n            String magicString = ArchiveUtils.toAsciiString(SIX_BYTES_BUF);\n            if (magicString.equals(MAGIC_NEW)) {\n                this.entry = readNewEntry(false);\n            } else if (magicString.equals(MAGIC_NEW_CRC)) {\n                this.entry = readNewEntry(true);\n            } else if (magicString.equals(MAGIC_OLD_ASCII)) {\n                this.entry = readOldAsciiEntry();\n            } else {\n                throw new IOException(\"Unknown magic [\" + magicString + \"]. Occured at byte: \" + getBytesRead());\n            }\n        }\n\n        this.entryBytesRead = 0;\n        this.entryEOF = false;\n        this.crc = 0;\n\n        if (this.entry.getName().equals(CPIO_TRAILER)) {\n            this.entryEOF = true;\n            skipRemainderOfLastBlock();\n            return null;\n        }\n        return this.entry;\n    }\n\n    private void skip(int bytes) throws IOException {\n        \n        if (bytes > 0) {\n            readFully(FOUR_BYTES_BUF, 0, bytes);\n        }\n    }\n\n    \n    @Override\n    public int read(final byte[] b, final int off, final int len) throws IOException {\n        ensureOpen();\n        if (off < 0 || len < 0 || off > b.length - len) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        }\n\n        if (this.entry == null || this.entryEOF) {\n            return -1;\n        }\n        if (this.entryBytesRead == this.entry.getSize()) {\n            skip(entry.getDataPadCount());\n            this.entryEOF = true;\n            if (this.entry.getFormat() == FORMAT_NEW_CRC\n                && this.crc != this.entry.getChksum()) {\n                throw new IOException(\"CRC Error. Occured at byte: \"\n                                      + getBytesRead());\n            }\n            return -1; \n        }\n        int tmplength = (int) Math.min(len, this.entry.getSize()\n                - this.entryBytesRead);\n        if (tmplength < 0) {\n            return -1;\n        }\n\n        int tmpread = readFully(b, off, tmplength);\n        if (this.entry.getFormat() == FORMAT_NEW_CRC) {\n            for (int pos = 0; pos < tmpread; pos++) {\n                this.crc += b[pos] & 0xFF;\n            }\n        }\n        this.entryBytesRead += tmpread;\n\n        return tmpread;\n    }\n\n    private final int readFully(final byte[] b, final int off, final int len) throws IOException {\n        if (len < 0) {\n            throw new IndexOutOfBoundsException();\n        }\n        int n = 0;\n        while (n < len) {\n            int count = this.in.read(b, off + n, len - n);\n            count(count);\n            if (count < 0) {\n                throw new EOFException();\n            }\n            n += count;\n        }\n        return n;\n    }\n\n    private long readBinaryLong(final int length, final boolean swapHalfWord) throws IOException {\n        byte tmp[] = new byte[length];\n        readFully(tmp, 0, tmp.length);\n        return CpioUtil.byteArray2long(tmp, swapHalfWord);\n    }\n\n    private long readAsciiLong(final int length, final int radix) throws IOException {\n        byte tmpBuffer[] = new byte[length];\n        readFully(tmpBuffer, 0, tmpBuffer.length);\n        return Long.parseLong(ArchiveUtils.toAsciiString(tmpBuffer), radix);\n    }\n\n    private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException {\n        CpioArchiveEntry ret;\n        if (hasCrc) {\n            ret = new CpioArchiveEntry(FORMAT_NEW_CRC);\n        } else {\n            ret = new CpioArchiveEntry(FORMAT_NEW);\n        }\n\n        ret.setInode(readAsciiLong(8, 16));\n        long mode = readAsciiLong(8, 16);\n        if (CpioUtil.fileType(mode) != 0){ \n            ret.setMode(mode);\n        }\n        ret.setUID(readAsciiLong(8, 16));\n        ret.setGID(readAsciiLong(8, 16));\n        ret.setNumberOfLinks(readAsciiLong(8, 16));\n        ret.setTime(readAsciiLong(8, 16));\n        ret.setSize(readAsciiLong(8, 16));\n        ret.setDeviceMaj(readAsciiLong(8, 16));\n        ret.setDeviceMin(readAsciiLong(8, 16));\n        ret.setRemoteDeviceMaj(readAsciiLong(8, 16));\n        ret.setRemoteDeviceMin(readAsciiLong(8, 16));\n        long namesize = readAsciiLong(8, 16);\n        ret.setChksum(readAsciiLong(8, 16));\n        String name = readCString((int) namesize);\n        ret.setName(name);\n        if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){\n            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \"+name + \" Occured at byte: \" + getBytesRead());\n        }\n        skip(ret.getHeaderPadCount());\n\n        return ret;\n    }\n\n    private CpioArchiveEntry readOldAsciiEntry() throws IOException {\n        CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_ASCII);\n\n        ret.setDevice(readAsciiLong(6, 8));\n        ret.setInode(readAsciiLong(6, 8));\n        final long mode = readAsciiLong(6, 8);\n        if (CpioUtil.fileType(mode) != 0) {\n            ret.setMode(mode);\n        }\n        ret.setUID(readAsciiLong(6, 8));\n        ret.setGID(readAsciiLong(6, 8));\n        ret.setNumberOfLinks(readAsciiLong(6, 8));\n        ret.setRemoteDevice(readAsciiLong(6, 8));\n        ret.setTime(readAsciiLong(11, 8));\n        long namesize = readAsciiLong(6, 8);\n        ret.setSize(readAsciiLong(11, 8));\n        final String name = readCString((int) namesize);\n        ret.setName(name);\n        if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){\n            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+ name + \" Occured at byte: \" + getBytesRead());\n        }\n\n        return ret;\n    }\n\n    private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord) throws IOException {\n        CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY);\n\n        ret.setDevice(readBinaryLong(2, swapHalfWord));\n        ret.setInode(readBinaryLong(2, swapHalfWord));\n        final long mode = readBinaryLong(2, swapHalfWord);\n        if (CpioUtil.fileType(mode) != 0){\n            ret.setMode(mode);\n        }\n        ret.setUID(readBinaryLong(2, swapHalfWord));\n        ret.setGID(readBinaryLong(2, swapHalfWord));\n        ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord));\n        ret.setRemoteDevice(readBinaryLong(2, swapHalfWord));\n        ret.setTime(readBinaryLong(4, swapHalfWord));\n        long namesize = readBinaryLong(2, swapHalfWord);\n        ret.setSize(readBinaryLong(4, swapHalfWord));\n        final String name = readCString((int) namesize);\n        ret.setName(name);\n        if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){\n            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+name + \"Occured at byte: \" + getBytesRead());\n        }\n        skip(ret.getHeaderPadCount());\n\n        return ret;\n    }\n\n    private String readCString(final int length) throws IOException {\n        byte tmpBuffer[] = new byte[length];\n        readFully(tmpBuffer, 0, tmpBuffer.length);\n        return new String(tmpBuffer, 0, tmpBuffer.length - 1); \n    }\n\n    \n    @Override\n    public long skip(final long n) throws IOException {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"negative skip length\");\n        }\n        ensureOpen();\n        int max = (int) Math.min(n, Integer.MAX_VALUE);\n        int total = 0;\n\n        while (total < max) {\n            int len = max - total;\n            if (len > this.tmpbuf.length) {\n                len = this.tmpbuf.length;\n            }\n            len = read(this.tmpbuf, 0, len);\n            if (len == -1) {\n                this.entryEOF = true;\n                break;\n            }\n            total += len;\n        }\n        return total;\n    }\n\n    @Override\n    public CpioArchiveEntry getNextEntry() throws IOException {\n        return getNextCPIOEntry();\n    }\n\n    \n    private void skipRemainderOfLastBlock() throws IOException {\n        long readFromLastBlock = getBytesRead() % blockSize;\n        long remainingBytes = readFromLastBlock == 0 ? 0\n            : blockSize - readFromLastBlock;\n        while (remainingBytes > 0) {\n            long skipped = skip(blockSize - readFromLastBlock);\n            if (skipped <= 0) {\n                break;\n            }\n            remainingBytes -= skipped;\n        }\n    }\n\n    \n    public static boolean matches(byte[] signature, int length) {\n        if (length < 6) {\n            return false;\n        }\n\n        \n        if (signature[0] == 0x71 && (signature[1] & 0xFF) == 0xc7) {\n            return true;\n        }\n        if (signature[1] == 0x71 && (signature[0] & 0xFF) == 0xc7) {\n            return true;\n        }\n\n        \n        \n        if (signature[0] != 0x30) {\n            return false;\n        }\n        if (signature[1] != 0x37) {\n            return false;\n        }\n        if (signature[2] != 0x30) {\n            return false;\n        }\n        if (signature[3] != 0x37) {\n            return false;\n        }\n        if (signature[4] != 0x30) {\n            return false;\n        }\n        \n        if (signature[5] == 0x31) {\n            return true;\n        }\n        if (signature[5] == 0x32) {\n            return true;\n        }\n        if (signature[5] == 0x37) {\n            return true;\n        }\n\n        return false;\n    }\n}\n",
      "buggy_signatures": [
        "public CpioArchiveInputStream(final InputStream in, int blockSize)",
        "public int available() throws IOException",
        "public void close() throws IOException",
        "private void closeEntry() throws IOException",
        "private void ensureOpen() throws IOException",
        "public CpioArchiveEntry getNextCPIOEntry() throws IOException",
        "private void skip(int bytes) throws IOException",
        "public int read(final byte[] b, final int off, final int len) throws IOException",
        "private final int readFully(final byte[] b, final int off, final int len) throws IOException",
        "private long readBinaryLong(final int length, final boolean swapHalfWord) throws IOException",
        "private long readAsciiLong(final int length, final int radix) throws IOException",
        "private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException",
        "private CpioArchiveEntry readOldAsciiEntry() throws IOException",
        "private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord) throws IOException",
        "private String readCString(final int length) throws IOException",
        "public long skip(final long n) throws IOException",
        "public CpioArchiveEntry getNextEntry() throws IOException",
        "private void skipRemainderOfLastBlock() throws IOException",
        "public static boolean matches(byte[] signature, int length)"
      ],
      "fixed_signatures": [
        "public CpioArchiveInputStream(final InputStream in, int blockSize)",
        "public int available() throws IOException",
        "public void close() throws IOException",
        "private void closeEntry() throws IOException",
        "private void ensureOpen() throws IOException",
        "public CpioArchiveEntry getNextCPIOEntry() throws IOException",
        "private void skip(int bytes) throws IOException",
        "public int read(final byte[] b, final int off, final int len) throws IOException",
        "private final int readFully(final byte[] b, final int off, final int len) throws IOException",
        "private long readBinaryLong(final int length, final boolean swapHalfWord) throws IOException",
        "private long readAsciiLong(final int length, final int radix) throws IOException",
        "private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException",
        "private CpioArchiveEntry readOldAsciiEntry() throws IOException",
        "private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord) throws IOException",
        "private String readCString(final int length) throws IOException",
        "public long skip(final long n) throws IOException",
        "public CpioArchiveEntry getNextEntry() throws IOException",
        "private void skipRemainderOfLastBlock() throws IOException",
        "public static boolean matches(byte[] signature, int length)"
      ],
      "methods": [
        {
          "buggy_method": "  private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException {\n  CpioArchiveEntry ret;\n  if (hasCrc) {\n  ret = new CpioArchiveEntry(FORMAT_NEW_CRC);\n  } else {\n  ret = new CpioArchiveEntry(FORMAT_NEW);\n  }\n\n  ret.setInode(readAsciiLong(8, 16));\n  long mode = readAsciiLong(8, 16);\n  if (mode != 0){\n  ret.setMode(mode);\n  }\n  ret.setUID(readAsciiLong(8, 16));\n  ret.setGID(readAsciiLong(8, 16));\n  ret.setNumberOfLinks(readAsciiLong(8, 16));\n  ret.setTime(readAsciiLong(8, 16));\n  ret.setSize(readAsciiLong(8, 16));\n  ret.setDeviceMaj(readAsciiLong(8, 16));\n  ret.setDeviceMin(readAsciiLong(8, 16));\n  ret.setRemoteDeviceMaj(readAsciiLong(8, 16));\n  ret.setRemoteDeviceMin(readAsciiLong(8, 16));\n  long namesize = readAsciiLong(8, 16);\n  ret.setChksum(readAsciiLong(8, 16));\n  String name = readCString((int) namesize);\n  ret.setName(name);\n  if (mode == 0 && !name.equals(CPIO_TRAILER)){\n  throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \"+name + \" Occured at byte: \" + getBytesRead());\n  }\n  skip(ret.getHeaderPadCount());\n\n  return ret;\n  }",
          "fixed_method": "  private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException {\n  CpioArchiveEntry ret;\n  if (hasCrc) {\n  ret = new CpioArchiveEntry(FORMAT_NEW_CRC);\n  } else {\n  ret = new CpioArchiveEntry(FORMAT_NEW);\n  }\n\n  ret.setInode(readAsciiLong(8, 16));\n  long mode = readAsciiLong(8, 16);\n  if (CpioUtil.fileType(mode) != 0){ \n  ret.setMode(mode);\n  }\n  ret.setUID(readAsciiLong(8, 16));\n  ret.setGID(readAsciiLong(8, 16));\n  ret.setNumberOfLinks(readAsciiLong(8, 16));\n  ret.setTime(readAsciiLong(8, 16));\n  ret.setSize(readAsciiLong(8, 16));\n  ret.setDeviceMaj(readAsciiLong(8, 16));\n  ret.setDeviceMin(readAsciiLong(8, 16));\n  ret.setRemoteDeviceMaj(readAsciiLong(8, 16));\n  ret.setRemoteDeviceMin(readAsciiLong(8, 16));\n  long namesize = readAsciiLong(8, 16);\n  ret.setChksum(readAsciiLong(8, 16));\n  String name = readCString((int) namesize);\n  ret.setName(name);\n  if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){\n  throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \"+name + \" Occured at byte: \" + getBytesRead());\n  }\n  skip(ret.getHeaderPadCount());\n\n  return ret;\n  }",
          "diff": [
            "@@ -328,7 +328,7 @@",
            " \n",
            "         ret.setInode(readAsciiLong(8, 16));\n",
            "         long mode = readAsciiLong(8, 16);\n",
            "-        if (mode != 0){\n",
            "+        if (CpioUtil.fileType(mode) != 0){ // mode is initialised to 0\n",
            "             ret.setMode(mode);\n",
            "         }\n",
            "         ret.setUID(readAsciiLong(8, 16));\n",
            "@@ -344,7 +344,7 @@",
            "         ret.setChksum(readAsciiLong(8, 16));\n",
            "         String name = readCString((int) namesize);\n",
            "         ret.setName(name);\n",
            "-        if (mode == 0 && !name.equals(CPIO_TRAILER)){\n",
            "+        if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){\n",
            "             throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \"+name + \" Occured at byte: \" + getBytesRead());\n",
            "         }\n",
            "         skip(ret.getHeaderPadCount());\n"
          ],
          "changed_lines": 4
        },
        {
          "buggy_method": "  private CpioArchiveEntry readOldAsciiEntry() throws IOException {\n  CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_ASCII);\n\n  ret.setDevice(readAsciiLong(6, 8));\n  ret.setInode(readAsciiLong(6, 8));\n  final long mode = readAsciiLong(6, 8);\n  if (mode != 0) {\n  ret.setMode(mode);\n  }\n  ret.setUID(readAsciiLong(6, 8));\n  ret.setGID(readAsciiLong(6, 8));\n  ret.setNumberOfLinks(readAsciiLong(6, 8));\n  ret.setRemoteDevice(readAsciiLong(6, 8));\n  ret.setTime(readAsciiLong(11, 8));\n  long namesize = readAsciiLong(6, 8);\n  ret.setSize(readAsciiLong(11, 8));\n  final String name = readCString((int) namesize);\n  ret.setName(name);\n  if (mode == 0 && !name.equals(CPIO_TRAILER)){\n  throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+ name + \" Occured at byte: \" + getBytesRead());\n  }\n\n  return ret;\n  }",
          "fixed_method": "  private CpioArchiveEntry readOldAsciiEntry() throws IOException {\n  CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_ASCII);\n\n  ret.setDevice(readAsciiLong(6, 8));\n  ret.setInode(readAsciiLong(6, 8));\n  final long mode = readAsciiLong(6, 8);\n  if (CpioUtil.fileType(mode) != 0) {\n  ret.setMode(mode);\n  }\n  ret.setUID(readAsciiLong(6, 8));\n  ret.setGID(readAsciiLong(6, 8));\n  ret.setNumberOfLinks(readAsciiLong(6, 8));\n  ret.setRemoteDevice(readAsciiLong(6, 8));\n  ret.setTime(readAsciiLong(11, 8));\n  long namesize = readAsciiLong(6, 8);\n  ret.setSize(readAsciiLong(11, 8));\n  final String name = readCString((int) namesize);\n  ret.setName(name);\n  if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){\n  throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+ name + \" Occured at byte: \" + getBytesRead());\n  }\n\n  return ret;\n  }",
          "diff": [
            "@@ -358,7 +358,7 @@",
            "         ret.setDevice(readAsciiLong(6, 8));\n",
            "         ret.setInode(readAsciiLong(6, 8));\n",
            "         final long mode = readAsciiLong(6, 8);\n",
            "-        if (mode != 0) {\n",
            "+        if (CpioUtil.fileType(mode) != 0) {\n",
            "             ret.setMode(mode);\n",
            "         }\n",
            "         ret.setUID(readAsciiLong(6, 8));\n",
            "@@ -370,7 +370,7 @@",
            "         ret.setSize(readAsciiLong(11, 8));\n",
            "         final String name = readCString((int) namesize);\n",
            "         ret.setName(name);\n",
            "-        if (mode == 0 && !name.equals(CPIO_TRAILER)){\n",
            "+        if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){\n",
            "             throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+ name + \" Occured at byte: \" + getBytesRead());\n",
            "         }\n",
            " \n"
          ],
          "changed_lines": 4
        },
        {
          "buggy_method": "  private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord) throws IOException {\n  CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY);\n\n  ret.setDevice(readBinaryLong(2, swapHalfWord));\n  ret.setInode(readBinaryLong(2, swapHalfWord));\n  final long mode = readBinaryLong(2, swapHalfWord);\n  if (mode != 0){\n  ret.setMode(mode);\n  }\n  ret.setUID(readBinaryLong(2, swapHalfWord));\n  ret.setGID(readBinaryLong(2, swapHalfWord));\n  ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord));\n  ret.setRemoteDevice(readBinaryLong(2, swapHalfWord));\n  ret.setTime(readBinaryLong(4, swapHalfWord));\n  long namesize = readBinaryLong(2, swapHalfWord);\n  ret.setSize(readBinaryLong(4, swapHalfWord));\n  final String name = readCString((int) namesize);\n  ret.setName(name);\n  if (mode == 0 && !name.equals(CPIO_TRAILER)){\n  throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+name + \"Occured at byte: \" + getBytesRead());\n  }\n  skip(ret.getHeaderPadCount());\n\n  return ret;\n  }",
          "fixed_method": "  private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord) throws IOException {\n  CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY);\n\n  ret.setDevice(readBinaryLong(2, swapHalfWord));\n  ret.setInode(readBinaryLong(2, swapHalfWord));\n  final long mode = readBinaryLong(2, swapHalfWord);\n  if (CpioUtil.fileType(mode) != 0){\n  ret.setMode(mode);\n  }\n  ret.setUID(readBinaryLong(2, swapHalfWord));\n  ret.setGID(readBinaryLong(2, swapHalfWord));\n  ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord));\n  ret.setRemoteDevice(readBinaryLong(2, swapHalfWord));\n  ret.setTime(readBinaryLong(4, swapHalfWord));\n  long namesize = readBinaryLong(2, swapHalfWord);\n  ret.setSize(readBinaryLong(4, swapHalfWord));\n  final String name = readCString((int) namesize);\n  ret.setName(name);\n  if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){\n  throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+name + \"Occured at byte: \" + getBytesRead());\n  }\n  skip(ret.getHeaderPadCount());\n\n  return ret;\n  }",
          "diff": [
            "@@ -384,7 +384,7 @@",
            "         ret.setDevice(readBinaryLong(2, swapHalfWord));\n",
            "         ret.setInode(readBinaryLong(2, swapHalfWord));\n",
            "         final long mode = readBinaryLong(2, swapHalfWord);\n",
            "-        if (mode != 0){\n",
            "+        if (CpioUtil.fileType(mode) != 0){\n",
            "             ret.setMode(mode);\n",
            "         }\n",
            "         ret.setUID(readBinaryLong(2, swapHalfWord));\n",
            "@@ -396,7 +396,7 @@",
            "         ret.setSize(readBinaryLong(4, swapHalfWord));\n",
            "         final String name = readCString((int) namesize);\n",
            "         ret.setName(name);\n",
            "-        if (mode == 0 && !name.equals(CPIO_TRAILER)){\n",
            "+        if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){\n",
            "             throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+name + \"Occured at byte: \" + getBytesRead());\n",
            "         }\n",
            "         skip(ret.getHeaderPadCount());\n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
