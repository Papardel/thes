{
  "bug_id": "23",
  "failed_tests": {
    "org.apache.commons.lang3.text.ExtendedMessageFormatTest": [
      {
        "methodName": "testEqualsHashcode",
        "error": "junit.framework.AssertionFailedError",
        "message": "registry, hashcode()",
        "fail_line": "        assertFalse(\"registry, hashcode()\", emf.hashCode() == other.hashCode());",
        "test_source": "  public void testEqualsHashcode() {\n  Map<String, ? extends FormatFactory> registry = Collections.singletonMap(\"testfmt\", new LowerCaseFormatFactory());\n  Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap(\"testfmt\", new UpperCaseFormatFactory());\n\n  String pattern = \"Pattern: {0,testfmt}\";\n  ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry);\n\n  ExtendedMessageFormat other = null;\n\n  // Same object\n  assertTrue(\"same, equals()\",  emf.equals(emf));\n  assertTrue(\"same, hashcode()\", emf.hashCode() == emf.hashCode());\n\n  // Equal Object\n  other = new ExtendedMessageFormat(pattern, Locale.US, registry);\n  assertTrue(\"equal, equals()\",  emf.equals(other));\n  assertTrue(\"equal, hashcode()\", emf.hashCode() == other.hashCode());\n\n  // Different Class\n  other = new OtherExtendedMessageFormat(pattern, Locale.US, registry);\n  assertFalse(\"class, equals()\",  emf.equals(other));\n  assertTrue(\"class, hashcode()\", emf.hashCode() == other.hashCode()); // same hashcode\n  \n  // Different pattern\n  other = new ExtendedMessageFormat(\"X\" + pattern, Locale.US, registry);\n  assertFalse(\"pattern, equals()\",  emf.equals(other));\n  assertFalse(\"pattern, hashcode()\", emf.hashCode() == other.hashCode());\n\n  // Different registry\n  other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry);\n  assertFalse(\"registry, equals()\",  emf.equals(other));\n  assertFalse(\"registry, hashcode()\", emf.hashCode() == other.hashCode());\n\n  // Different Locale\n  other = new ExtendedMessageFormat(pattern, Locale.FRANCE, registry);\n  assertFalse(\"locale, equals()\",  emf.equals(other));\n  assertTrue(\"locale, hashcode()\", emf.hashCode() == other.hashCode()); // same hashcode\n  }",
        "stack": [
          "ExtendedMessageFormatTest.testEqualsHashcode line 301"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/lang3/text/ExtendedMessageFormat.java",
      "buggy_full_code": "\npackage org.apache.commons.lang3.text;\n\nimport java.text.Format;\nimport java.text.MessageFormat;\nimport java.text.ParsePosition;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.apache.commons.lang3.ObjectUtils;\nimport org.apache.commons.lang3.Validate;\n\n\npublic class ExtendedMessageFormat extends MessageFormat { private static final long serialVersionUID = -2362048321261811743L; private static final String DUMMY_PATTERN = \"\"; private static final String ESCAPED_QUOTE = \"''\"; private static final char START_FMT = ','; private static final char END_FE = '}'; private static final char START_FE = '{'; private static final char QUOTE = '\\''; private String toPattern; private final Map<String, ? extends FormatFactory> registry; public ExtendedMessageFormat(String pattern) {\n        this(pattern, Locale.getDefault());\n    }\n\n    \n    public ExtendedMessageFormat(String pattern, Locale locale) {\n        this(pattern, locale, null);\n    }\n\n    \n    public ExtendedMessageFormat(String pattern, Map<String, ? extends FormatFactory> registry) {\n        this(pattern, Locale.getDefault(), registry);\n    }\n\n    \n    public ExtendedMessageFormat(String pattern, Locale locale, Map<String, ? extends FormatFactory> registry) {\n        super(DUMMY_PATTERN);\n        setLocale(locale);\n        this.registry = registry;\n        applyPattern(pattern);\n    }\n\n    \n    @Override\n    public String toPattern() {\n        return toPattern;\n    }\n\n    \n    @Override\n    public final void applyPattern(String pattern) {\n        if (registry == null) {\n            super.applyPattern(pattern);\n            toPattern = super.toPattern();\n            return;\n        }\n        ArrayList<Format> foundFormats = new ArrayList<Format>();\n        ArrayList<String> foundDescriptions = new ArrayList<String>();\n        StringBuilder stripCustom = new StringBuilder(pattern.length());\n\n        ParsePosition pos = new ParsePosition(0);\n        char[] c = pattern.toCharArray();\n        int fmtCount = 0;\n        while (pos.getIndex() < pattern.length()) {\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                appendQuotedString(pattern, pos, stripCustom, true);\n                break;\n            case START_FE:\n                fmtCount++;\n                seekNonWs(pattern, pos);\n                int start = pos.getIndex();\n                int index = readArgumentIndex(pattern, next(pos));\n                stripCustom.append(START_FE).append(index);\n                seekNonWs(pattern, pos);\n                Format format = null;\n                String formatDescription = null;\n                if (c[pos.getIndex()] == START_FMT) {\n                    formatDescription = parseFormatDescription(pattern,\n                            next(pos));\n                    format = getFormat(formatDescription);\n                    if (format == null) {\n                        stripCustom.append(START_FMT).append(formatDescription);\n                    }\n                }\n                foundFormats.add(format);\n                foundDescriptions.add(format == null ? null : formatDescription);\n                Validate.isTrue(foundFormats.size() == fmtCount);\n                Validate.isTrue(foundDescriptions.size() == fmtCount);\n                if (c[pos.getIndex()] != END_FE) {\n                    throw new IllegalArgumentException(\n                            \"Unreadable format element at position \" + start);\n                }\n                \n            default:\n                stripCustom.append(c[pos.getIndex()]);\n                next(pos);\n            }\n        }\n        super.applyPattern(stripCustom.toString());\n        toPattern = insertFormats(super.toPattern(), foundDescriptions);\n        if (containsElements(foundFormats)) {\n            Format[] origFormats = getFormats();\n            \n            \n            int i = 0;\n            for (Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) {\n                Format f = it.next();\n                if (f != null) {\n                    origFormats[i] = f;\n                }\n            }\n            super.setFormats(origFormats);\n        }\n    }\n\n    \n    @Override\n    public void setFormat(int formatElementIndex, Format newFormat) {\n        throw new UnsupportedOperationException();\n    }\n\n    \n    @Override\n    public void setFormatByArgumentIndex(int argumentIndex, Format newFormat) {\n        throw new UnsupportedOperationException();\n    }\n\n    \n    @Override\n    public void setFormats(Format[] newFormats) {\n        throw new UnsupportedOperationException();\n    }\n\n    \n    @Override\n    public void setFormatsByArgumentIndex(Format[] newFormats) {\n        throw new UnsupportedOperationException();\n    }\n\n    \n\n    \n\n    \n    private Format getFormat(String desc) {\n        if (registry != null) {\n            String name = desc;\n            String args = null;\n            int i = desc.indexOf(START_FMT);\n            if (i > 0) {\n                name = desc.substring(0, i).trim();\n                args = desc.substring(i + 1).trim();\n            }\n            FormatFactory factory = registry.get(name);\n            if (factory != null) {\n                return factory.getFormat(name, args, getLocale());\n            }\n        }\n        return null;\n    }\n\n    \n    private int readArgumentIndex(String pattern, ParsePosition pos) {\n        int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        StringBuffer result = new StringBuffer();\n        boolean error = false;\n        for (; !error && pos.getIndex() < pattern.length(); next(pos)) {\n            char c = pattern.charAt(pos.getIndex());\n            if (Character.isWhitespace(c)) {\n                seekNonWs(pattern, pos);\n                c = pattern.charAt(pos.getIndex());\n                if (c != START_FMT && c != END_FE) {\n                    error = true;\n                    continue;\n                }\n            }\n            if ((c == START_FMT || c == END_FE) && result.length() > 0) {\n                try {\n                    return Integer.parseInt(result.toString());\n                } catch (NumberFormatException e) {\n                    \n                    \n                }\n            }\n            error = !Character.isDigit(c);\n            result.append(c);\n        }\n        if (error) {\n            throw new IllegalArgumentException(\n                    \"Invalid format argument index at position \" + start + \": \"\n                            + pattern.substring(start, pos.getIndex()));\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated format element at position \" + start);\n    }\n\n    \n    private String parseFormatDescription(String pattern, ParsePosition pos) {\n        int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        int text = pos.getIndex();\n        int depth = 1;\n        for (; pos.getIndex() < pattern.length(); next(pos)) {\n            switch (pattern.charAt(pos.getIndex())) {\n            case START_FE:\n                depth++;\n                break;\n            case END_FE:\n                depth--;\n                if (depth == 0) {\n                    return pattern.substring(text, pos.getIndex());\n                }\n                break;\n            case QUOTE:\n                getQuotedString(pattern, pos, false);\n                break;\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated format element at position \" + start);\n    }\n\n    \n    private String insertFormats(String pattern, ArrayList<String> customPatterns) {\n        if (!containsElements(customPatterns)) {\n            return pattern;\n        }\n        StringBuilder sb = new StringBuilder(pattern.length() * 2);\n        ParsePosition pos = new ParsePosition(0);\n        int fe = -1;\n        int depth = 0;\n        while (pos.getIndex() < pattern.length()) {\n            char c = pattern.charAt(pos.getIndex());\n            switch (c) {\n            case QUOTE:\n                appendQuotedString(pattern, pos, sb, false);\n                break;\n            case START_FE:\n                depth++;\n                if (depth == 1) {\n                    fe++;\n                    sb.append(START_FE).append(\n                            readArgumentIndex(pattern, next(pos)));\n                    String customPattern = customPatterns.get(fe);\n                    if (customPattern != null) {\n                        sb.append(START_FMT).append(customPattern);\n                    }\n                }\n                break;\n            case END_FE:\n                depth--;\n                \n            default:\n                sb.append(c);\n                next(pos);\n            }\n        }\n        return sb.toString();\n    }\n\n    \n    private void seekNonWs(String pattern, ParsePosition pos) {\n        int len = 0;\n        char[] buffer = pattern.toCharArray();\n        do {\n            len = StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex());\n            pos.setIndex(pos.getIndex() + len);\n        } while (len > 0 && pos.getIndex() < pattern.length());\n    }\n\n    \n    private ParsePosition next(ParsePosition pos) {\n        pos.setIndex(pos.getIndex() + 1);\n        return pos;\n    }\n\n    \n    private StringBuilder appendQuotedString(String pattern, ParsePosition pos, StringBuilder appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == QUOTE) {\n            next(pos);\n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                        QUOTE);\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }\n\n    \n    private void getQuotedString(String pattern, ParsePosition pos, boolean escapingOn) {\n        appendQuotedString(pattern, pos, null, escapingOn);\n    }\n\n    \n    private boolean containsElements(Collection<?> coll) {\n        if (coll == null || coll.size() == 0) {\n            return false;\n        }\n        for (Iterator<?> iter = coll.iterator(); iter.hasNext();) {\n            if (iter.next() != null) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.lang3.text;\n\nimport java.text.Format;\nimport java.text.MessageFormat;\nimport java.text.ParsePosition;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.apache.commons.lang3.ObjectUtils;\nimport org.apache.commons.lang3.Validate;\n\n\npublic class ExtendedMessageFormat extends MessageFormat { private static final long serialVersionUID = -2362048321261811743L; private static final int HASH_SEED = 31; private static final String DUMMY_PATTERN = \"\"; private static final String ESCAPED_QUOTE = \"''\"; private static final char START_FMT = ','; private static final char END_FE = '}'; private static final char START_FE = '{'; private static final char QUOTE = '\\''; private String toPattern; private final Map<String, ? extends FormatFactory> registry; public ExtendedMessageFormat(String pattern) {\n        this(pattern, Locale.getDefault());\n    }\n\n    \n    public ExtendedMessageFormat(String pattern, Locale locale) {\n        this(pattern, locale, null);\n    }\n\n    \n    public ExtendedMessageFormat(String pattern, Map<String, ? extends FormatFactory> registry) {\n        this(pattern, Locale.getDefault(), registry);\n    }\n\n    \n    public ExtendedMessageFormat(String pattern, Locale locale, Map<String, ? extends FormatFactory> registry) {\n        super(DUMMY_PATTERN);\n        setLocale(locale);\n        this.registry = registry;\n        applyPattern(pattern);\n    }\n\n    \n    @Override\n    public String toPattern() {\n        return toPattern;\n    }\n\n    \n    @Override\n    public final void applyPattern(String pattern) {\n        if (registry == null) {\n            super.applyPattern(pattern);\n            toPattern = super.toPattern();\n            return;\n        }\n        ArrayList<Format> foundFormats = new ArrayList<Format>();\n        ArrayList<String> foundDescriptions = new ArrayList<String>();\n        StringBuilder stripCustom = new StringBuilder(pattern.length());\n\n        ParsePosition pos = new ParsePosition(0);\n        char[] c = pattern.toCharArray();\n        int fmtCount = 0;\n        while (pos.getIndex() < pattern.length()) {\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                appendQuotedString(pattern, pos, stripCustom, true);\n                break;\n            case START_FE:\n                fmtCount++;\n                seekNonWs(pattern, pos);\n                int start = pos.getIndex();\n                int index = readArgumentIndex(pattern, next(pos));\n                stripCustom.append(START_FE).append(index);\n                seekNonWs(pattern, pos);\n                Format format = null;\n                String formatDescription = null;\n                if (c[pos.getIndex()] == START_FMT) {\n                    formatDescription = parseFormatDescription(pattern,\n                            next(pos));\n                    format = getFormat(formatDescription);\n                    if (format == null) {\n                        stripCustom.append(START_FMT).append(formatDescription);\n                    }\n                }\n                foundFormats.add(format);\n                foundDescriptions.add(format == null ? null : formatDescription);\n                Validate.isTrue(foundFormats.size() == fmtCount);\n                Validate.isTrue(foundDescriptions.size() == fmtCount);\n                if (c[pos.getIndex()] != END_FE) {\n                    throw new IllegalArgumentException(\n                            \"Unreadable format element at position \" + start);\n                }\n                \n            default:\n                stripCustom.append(c[pos.getIndex()]);\n                next(pos);\n            }\n        }\n        super.applyPattern(stripCustom.toString());\n        toPattern = insertFormats(super.toPattern(), foundDescriptions);\n        if (containsElements(foundFormats)) {\n            Format[] origFormats = getFormats();\n            \n            \n            int i = 0;\n            for (Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) {\n                Format f = it.next();\n                if (f != null) {\n                    origFormats[i] = f;\n                }\n            }\n            super.setFormats(origFormats);\n        }\n    }\n\n    \n    @Override\n    public void setFormat(int formatElementIndex, Format newFormat) {\n        throw new UnsupportedOperationException();\n    }\n\n    \n    @Override\n    public void setFormatByArgumentIndex(int argumentIndex, Format newFormat) {\n        throw new UnsupportedOperationException();\n    }\n\n    \n    @Override\n    public void setFormats(Format[] newFormats) {\n        throw new UnsupportedOperationException();\n    }\n\n    \n    @Override\n    public void setFormatsByArgumentIndex(Format[] newFormats) {\n        throw new UnsupportedOperationException();\n    }\n\n    \n    @Override\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        if (ObjectUtils.notEqual(getClass(), obj.getClass())) {\n          return false;\n        }\n        ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj;\n        if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) {\n            return false;\n        }\n        if (ObjectUtils.notEqual(registry, rhs.registry)) {\n            return false;\n        }\n        return true;\n    }\n\n    \n    @Override\n    public int hashCode() {\n        int result = super.hashCode();\n        result = HASH_SEED * result + ObjectUtils.hashCode(registry);\n        result = HASH_SEED * result + ObjectUtils.hashCode(toPattern);\n        return result;\n    }\n\n    \n    private Format getFormat(String desc) {\n        if (registry != null) {\n            String name = desc;\n            String args = null;\n            int i = desc.indexOf(START_FMT);\n            if (i > 0) {\n                name = desc.substring(0, i).trim();\n                args = desc.substring(i + 1).trim();\n            }\n            FormatFactory factory = registry.get(name);\n            if (factory != null) {\n                return factory.getFormat(name, args, getLocale());\n            }\n        }\n        return null;\n    }\n\n    \n    private int readArgumentIndex(String pattern, ParsePosition pos) {\n        int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        StringBuffer result = new StringBuffer();\n        boolean error = false;\n        for (; !error && pos.getIndex() < pattern.length(); next(pos)) {\n            char c = pattern.charAt(pos.getIndex());\n            if (Character.isWhitespace(c)) {\n                seekNonWs(pattern, pos);\n                c = pattern.charAt(pos.getIndex());\n                if (c != START_FMT && c != END_FE) {\n                    error = true;\n                    continue;\n                }\n            }\n            if ((c == START_FMT || c == END_FE) && result.length() > 0) {\n                try {\n                    return Integer.parseInt(result.toString());\n                } catch (NumberFormatException e) {\n                    \n                    \n                }\n            }\n            error = !Character.isDigit(c);\n            result.append(c);\n        }\n        if (error) {\n            throw new IllegalArgumentException(\n                    \"Invalid format argument index at position \" + start + \": \"\n                            + pattern.substring(start, pos.getIndex()));\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated format element at position \" + start);\n    }\n\n    \n    private String parseFormatDescription(String pattern, ParsePosition pos) {\n        int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        int text = pos.getIndex();\n        int depth = 1;\n        for (; pos.getIndex() < pattern.length(); next(pos)) {\n            switch (pattern.charAt(pos.getIndex())) {\n            case START_FE:\n                depth++;\n                break;\n            case END_FE:\n                depth--;\n                if (depth == 0) {\n                    return pattern.substring(text, pos.getIndex());\n                }\n                break;\n            case QUOTE:\n                getQuotedString(pattern, pos, false);\n                break;\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated format element at position \" + start);\n    }\n\n    \n    private String insertFormats(String pattern, ArrayList<String> customPatterns) {\n        if (!containsElements(customPatterns)) {\n            return pattern;\n        }\n        StringBuilder sb = new StringBuilder(pattern.length() * 2);\n        ParsePosition pos = new ParsePosition(0);\n        int fe = -1;\n        int depth = 0;\n        while (pos.getIndex() < pattern.length()) {\n            char c = pattern.charAt(pos.getIndex());\n            switch (c) {\n            case QUOTE:\n                appendQuotedString(pattern, pos, sb, false);\n                break;\n            case START_FE:\n                depth++;\n                if (depth == 1) {\n                    fe++;\n                    sb.append(START_FE).append(\n                            readArgumentIndex(pattern, next(pos)));\n                    String customPattern = customPatterns.get(fe);\n                    if (customPattern != null) {\n                        sb.append(START_FMT).append(customPattern);\n                    }\n                }\n                break;\n            case END_FE:\n                depth--;\n                \n            default:\n                sb.append(c);\n                next(pos);\n            }\n        }\n        return sb.toString();\n    }\n\n    \n    private void seekNonWs(String pattern, ParsePosition pos) {\n        int len = 0;\n        char[] buffer = pattern.toCharArray();\n        do {\n            len = StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex());\n            pos.setIndex(pos.getIndex() + len);\n        } while (len > 0 && pos.getIndex() < pattern.length());\n    }\n\n    \n    private ParsePosition next(ParsePosition pos) {\n        pos.setIndex(pos.getIndex() + 1);\n        return pos;\n    }\n\n    \n    private StringBuilder appendQuotedString(String pattern, ParsePosition pos, StringBuilder appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == QUOTE) {\n            next(pos);\n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                        QUOTE);\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }\n\n    \n    private void getQuotedString(String pattern, ParsePosition pos, boolean escapingOn) {\n        appendQuotedString(pattern, pos, null, escapingOn);\n    }\n\n    \n    private boolean containsElements(Collection<?> coll) {\n        if (coll == null || coll.size() == 0) {\n            return false;\n        }\n        for (Iterator<?> iter = coll.iterator(); iter.hasNext();) {\n            if (iter.next() != null) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n",
      "buggy_signatures": [
        "public ExtendedMessageFormat(String pattern, Locale locale)",
        "public ExtendedMessageFormat(String pattern, Map<String, ? extends FormatFactory> registry)",
        "public ExtendedMessageFormat(String pattern, Locale locale, Map<String, ? extends FormatFactory> registry)",
        "public String toPattern()",
        "public final void applyPattern(String pattern)",
        "public void setFormat(int formatElementIndex, Format newFormat)",
        "public void setFormatByArgumentIndex(int argumentIndex, Format newFormat)",
        "public void setFormats(Format[] newFormats)",
        "public void setFormatsByArgumentIndex(Format[] newFormats)",
        "private Format getFormat(String desc)",
        "private int readArgumentIndex(String pattern, ParsePosition pos)",
        "private String parseFormatDescription(String pattern, ParsePosition pos)",
        "private String insertFormats(String pattern, ArrayList<String> customPatterns)",
        "private void seekNonWs(String pattern, ParsePosition pos)",
        "private ParsePosition next(ParsePosition pos)",
        "private StringBuilder appendQuotedString(String pattern, ParsePosition pos, StringBuilder appendTo, boolean escapingOn)",
        "private void getQuotedString(String pattern, ParsePosition pos, boolean escapingOn)",
        "private boolean containsElements(Collection<?> coll)"
      ],
      "fixed_signatures": [
        "public ExtendedMessageFormat(String pattern, Locale locale)",
        "public ExtendedMessageFormat(String pattern, Map<String, ? extends FormatFactory> registry)",
        "public ExtendedMessageFormat(String pattern, Locale locale, Map<String, ? extends FormatFactory> registry)",
        "public String toPattern()",
        "public final void applyPattern(String pattern)",
        "public void setFormat(int formatElementIndex, Format newFormat)",
        "public void setFormatByArgumentIndex(int argumentIndex, Format newFormat)",
        "public void setFormats(Format[] newFormats)",
        "public void setFormatsByArgumentIndex(Format[] newFormats)",
        "public boolean equals(Object obj)",
        "public int hashCode()",
        "private Format getFormat(String desc)",
        "private int readArgumentIndex(String pattern, ParsePosition pos)",
        "private String parseFormatDescription(String pattern, ParsePosition pos)",
        "private String insertFormats(String pattern, ArrayList<String> customPatterns)",
        "private void seekNonWs(String pattern, ParsePosition pos)",
        "private ParsePosition next(ParsePosition pos)",
        "private StringBuilder appendQuotedString(String pattern, ParsePosition pos, StringBuilder appendTo, boolean escapingOn)",
        "private void getQuotedString(String pattern, ParsePosition pos, boolean escapingOn)",
        "private boolean containsElements(Collection<?> coll)"
      ],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -70,6 +70,7 @@",
            "  */\n",
            " public class ExtendedMessageFormat extends MessageFormat {\n",
            "     private static final long serialVersionUID = -2362048321261811743L;\n",
            "+    private static final int HASH_SEED = 31;\n",
            " \n",
            "     private static final String DUMMY_PATTERN = \"\";\n",
            "     private static final String ESCAPED_QUOTE = \"''\";\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  public void setFormatsByArgumentIndex(Format[] newFormats) {\n  throw new UnsupportedOperationException();\n  }",
          "fixed_method": "  public boolean equals(Object obj) {\n  if (obj == this) {\n  return true;\n  }\n  if (obj == null) {\n  return false;\n  }\n  if (!super.equals(obj)) {\n  return false;\n  }\n  if (ObjectUtils.notEqual(getClass(), obj.getClass())) {\n  return false;\n  }\n  ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj;\n  if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) {\n  return false;\n  }\n  if (ObjectUtils.notEqual(registry, rhs.registry)) {\n  return false;\n  }\n  return true;\n  }",
          "diff": [
            "@@ -260,12 +261,42 @@",
            "      * @param obj the object to compare to\n",
            "      * @return true if this object equals the other, otherwise false\n",
            "      */\n",
            "+    @Override\n",
            "+    public boolean equals(Object obj) {\n",
            "+        if (obj == this) {\n",
            "+            return true;\n",
            "+        }\n",
            "+        if (obj == null) {\n",
            "+            return false;\n",
            "+        }\n",
            "+        if (!super.equals(obj)) {\n",
            "+            return false;\n",
            "+        }\n",
            "+        if (ObjectUtils.notEqual(getClass(), obj.getClass())) {\n",
            "+          return false;\n",
            "+        }\n",
            "+        ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj;\n",
            "+        if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) {\n",
            "+            return false;\n",
            "+        }\n",
            "+        if (ObjectUtils.notEqual(registry, rhs.registry)) {\n",
            "+            return false;\n",
            "+        }\n",
            "+        return true;\n",
            "+    }\n",
            " \n",
            "     /**\n",
            "      * Return the hashcode.\n",
            "      *\n",
            "      * @return the hashcode\n",
            "      */\n",
            "+    @Override\n",
            "+    public int hashCode() {\n",
            "+        int result = super.hashCode();\n",
            "+        result = HASH_SEED * result + ObjectUtils.hashCode(registry);\n",
            "+        result = HASH_SEED * result + ObjectUtils.hashCode(toPattern);\n",
            "+        return result;\n",
            "+    }\n",
            " \n",
            "     /**\n",
            "      * Get a custom format from a format description.\n"
          ],
          "changed_lines": 30
        }
      ]
    }
  ]
}
