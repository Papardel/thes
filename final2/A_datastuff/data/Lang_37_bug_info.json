{
  "bug_id": "37",
  "failed_tests": {
    "org.apache.commons.lang3.ArrayUtilsAddTest": [
      {
        "methodName": "testJira567",
        "error": "java.lang.ArrayStoreException",
        "message": "arraycopy: type mismatch: can not copy java.lang.Long[] into java.lang.Integer[]",
        "fail_line": "               n = ArrayUtils.addAll(new Integer[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)});",
        "test_source": "  public void testJira567() {\n  Number[] n;\n  // Valid array construction\n  n = ArrayUtils.addAll(new Number[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)});\n  assertEquals(2,n.length);\n  assertEquals(Number.class,n.getClass().getComponentType());\n  try {\n  // Invalid - can't store Long in Integer array\n  n = ArrayUtils.addAll(new Integer[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)});\n  fail(\"Should have generated IllegalArgumentException\");\n  } catch (IllegalArgumentException expected) {\n  }\n  }",
        "stack": [
          "ArrayUtils.addAll line 2962, ArrayUtilsAddTest.testJira567 line 40"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/lang3/ArrayUtils.java",
      "buggy_full_code": "\npackage org.apache.commons.lang3;\n\nimport java.lang.reflect.Array;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.commons.lang3.builder.EqualsBuilder;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\n\npublic class ArrayUtils { public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0]; public static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0]; public static final String[] EMPTY_STRING_ARRAY = new String[0]; public static final long[] EMPTY_LONG_ARRAY = new long[0]; public static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0]; public static final int[] EMPTY_INT_ARRAY = new int[0]; public static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0]; public static final short[] EMPTY_SHORT_ARRAY = new short[0]; public static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0]; public static final byte[] EMPTY_BYTE_ARRAY = new byte[0]; public static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0]; public static final double[] EMPTY_DOUBLE_ARRAY = new double[0]; public static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0]; public static final float[] EMPTY_FLOAT_ARRAY = new float[0]; public static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0]; public static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0]; public static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0]; public static final char[] EMPTY_CHAR_ARRAY = new char[0]; public static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0]; public static final int INDEX_NOT_FOUND = -1; public ArrayUtils() {\n      super();\n    }\n\n    \n    \n    \n    public static String toString(Object array) {\n        return toString(array, \"{}\");\n    }\n\n    \n    public static String toString(Object array, String stringIfNull) {\n        if (array == null) {\n            return stringIfNull;\n        }\n        return new ToStringBuilder(array, ToStringStyle.SIMPLE_STYLE).append(array).toString();\n    }\n\n    \n    public static boolean isEquals(Object array1, Object array2) {\n        return new EqualsBuilder().append(array1, array2).isEquals();\n    }\n\n    \n    \n    \n    public static Map<Object, Object> toMap(Object[] array) {\n        if (array == null) {\n            return null;\n        }\n        final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5));\n        for (int i = 0; i < array.length; i++) {\n            Object object = array[i];\n            if (object instanceof Map.Entry<?, ?>) {\n                Map.Entry<?,?> entry = (Map.Entry<?,?>) object;\n                map.put(entry.getKey(), entry.getValue());\n            } else if (object instanceof Object[]) {\n                Object[] entry = (Object[]) object;\n                if (entry.length < 2) {\n                    throw new IllegalArgumentException(\"Array element \" + i + \", '\"\n                        + object\n                        + \"', has a length less than 2\");\n                }\n                map.put(entry[0], entry[1]);\n            } else {\n                throw new IllegalArgumentException(\"Array element \" + i + \", '\"\n                        + object\n                        + \"', is neither of type Map.Entry nor an Array\");\n            }\n        }\n        return map;\n    }\n\n    \n    \n    \n    public static <T> T[] clone(T[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    \n    public static long[] clone(long[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    \n    public static int[] clone(int[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    \n    public static short[] clone(short[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    \n    public static char[] clone(char[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    \n    public static byte[] clone(byte[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    \n    public static double[] clone(double[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    \n    public static float[] clone(float[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    \n    public static boolean[] clone(boolean[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    \n    \n    \n    @SuppressWarnings(\"unchecked\")\n    public static <T> T[] subarray(T[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        Class<?> type = array.getClass().getComponentType();\n        if (newSize <= 0) {\n            return (T[]) Array.newInstance(type, 0);\n        }\n        T[] subarray = (T[]) Array.newInstance(type, newSize);\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    \n    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return EMPTY_LONG_ARRAY;\n        }\n\n        long[] subarray = new long[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    \n    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return EMPTY_INT_ARRAY;\n        }\n\n        int[] subarray = new int[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    \n    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return EMPTY_SHORT_ARRAY;\n        }\n\n        short[] subarray = new short[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    \n    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return EMPTY_CHAR_ARRAY;\n        }\n\n        char[] subarray = new char[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    \n    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n\n        byte[] subarray = new byte[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    \n    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return EMPTY_DOUBLE_ARRAY;\n        }\n\n        double[] subarray = new double[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    \n    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return EMPTY_FLOAT_ARRAY;\n        }\n\n        float[] subarray = new float[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    \n    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return EMPTY_BOOLEAN_ARRAY;\n        }\n\n        boolean[] subarray = new boolean[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    \n    \n    \n    public static boolean isSameLength(Object[] array1, Object[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    \n    public static boolean isSameLength(long[] array1, long[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    \n    public static boolean isSameLength(int[] array1, int[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    \n    public static boolean isSameLength(short[] array1, short[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    \n    public static boolean isSameLength(char[] array1, char[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    \n    public static boolean isSameLength(byte[] array1, byte[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    \n    public static boolean isSameLength(double[] array1, double[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    \n    public static boolean isSameLength(float[] array1, float[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    \n    public static boolean isSameLength(boolean[] array1, boolean[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    \n    \n    public static int getLength(Object array) {\n        if (array == null) {\n            return 0;\n        }\n        return Array.getLength(array);\n    }\n\n    \n    public static boolean isSameType(Object array1, Object array2) {\n        if (array1 == null || array2 == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        return array1.getClass().getName().equals(array2.getClass().getName());\n    }\n\n    \n    \n    \n    public static void reverse(Object[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        Object tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    \n    public static void reverse(long[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        long tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    \n    public static void reverse(int[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        int tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    \n    public static void reverse(short[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        short tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    \n    public static void reverse(char[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        char tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    \n    public static void reverse(byte[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        byte tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    \n    public static void reverse(double[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        double tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    \n    public static void reverse(float[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        float tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    \n    public static void reverse(boolean[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        boolean tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    \n    \n\n    \n    \n    \n    public static int indexOf(Object[] array, Object objectToFind) {\n        return indexOf(array, objectToFind, 0);\n    }\n\n    \n    public static int indexOf(Object[] array, Object objectToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        if (objectToFind == null) {\n            for (int i = startIndex; i < array.length; i++) {\n                if (array[i] == null) {\n                    return i;\n                }\n            }\n        } else if (array.getClass().getComponentType().isInstance(objectToFind)) {\n            for (int i = startIndex; i < array.length; i++) {\n                if (objectToFind.equals(array[i])) {\n                    return i;\n                }\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int lastIndexOf(Object[] array, Object objectToFind) {\n        return lastIndexOf(array, objectToFind, Integer.MAX_VALUE);\n    }\n\n    \n    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        if (objectToFind == null) {\n            for (int i = startIndex; i >= 0; i--) {\n                if (array[i] == null) {\n                    return i;\n                }\n            }\n        } else if (array.getClass().getComponentType().isInstance(objectToFind)) {\n            for (int i = startIndex; i >= 0; i--) {\n                if (objectToFind.equals(array[i])) {\n                    return i;\n                }\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static boolean contains(Object[] array, Object objectToFind) {\n        return indexOf(array, objectToFind) != INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static int indexOf(long[] array, long valueToFind) {\n        return indexOf(array, valueToFind, 0);\n    }\n\n    \n    public static int indexOf(long[] array, long valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int lastIndexOf(long[] array, long valueToFind) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    \n    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static boolean contains(long[] array, long valueToFind) {\n        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static int indexOf(int[] array, int valueToFind) {\n        return indexOf(array, valueToFind, 0);\n    }\n\n    \n    public static int indexOf(int[] array, int valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int lastIndexOf(int[] array, int valueToFind) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    \n    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static boolean contains(int[] array, int valueToFind) {\n        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static int indexOf(short[] array, short valueToFind) {\n        return indexOf(array, valueToFind, 0);\n    }\n\n    \n    public static int indexOf(short[] array, short valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int lastIndexOf(short[] array, short valueToFind) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    \n    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static boolean contains(short[] array, short valueToFind) {\n        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static int indexOf(char[] array, char valueToFind) {\n        return indexOf(array, valueToFind, 0);\n    }\n\n    \n    public static int indexOf(char[] array, char valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int lastIndexOf(char[] array, char valueToFind) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    \n    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static boolean contains(char[] array, char valueToFind) {\n        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static int indexOf(byte[] array, byte valueToFind) {\n        return indexOf(array, valueToFind, 0);\n    }\n\n    \n    public static int indexOf(byte[] array, byte valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int lastIndexOf(byte[] array, byte valueToFind) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    \n    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static boolean contains(byte[] array, byte valueToFind) {\n        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static int indexOf(double[] array, double valueToFind) {\n        return indexOf(array, valueToFind, 0);\n    }\n\n    \n    public static int indexOf(double[] array, double valueToFind, double tolerance) {\n        return indexOf(array, valueToFind, 0, tolerance);\n    }\n\n    \n    public static int indexOf(double[] array, double valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int indexOf(double[] array, double valueToFind, int startIndex, double tolerance) {\n        if (ArrayUtils.isEmpty(array)) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        double min = valueToFind - tolerance;\n        double max = valueToFind + tolerance;\n        for (int i = startIndex; i < array.length; i++) {\n            if (array[i] >= min && array[i] <= max) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int lastIndexOf(double[] array, double valueToFind) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    \n    public static int lastIndexOf(double[] array, double valueToFind, double tolerance) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE, tolerance);\n    }\n\n    \n    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {\n        if (ArrayUtils.isEmpty(array)) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        double min = valueToFind - tolerance;\n        double max = valueToFind + tolerance;\n        for (int i = startIndex; i >= 0; i--) {\n            if (array[i] >= min && array[i] <= max) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static boolean contains(double[] array, double valueToFind) {\n        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n    }\n\n    \n    public static boolean contains(double[] array, double valueToFind, double tolerance) {\n        return indexOf(array, valueToFind, 0, tolerance) != INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static int indexOf(float[] array, float valueToFind) {\n        return indexOf(array, valueToFind, 0);\n    }\n\n    \n    public static int indexOf(float[] array, float valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int lastIndexOf(float[] array, float valueToFind) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    \n    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static boolean contains(float[] array, float valueToFind) {\n        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static int indexOf(boolean[] array, boolean valueToFind) {\n        return indexOf(array, valueToFind, 0);\n    }\n\n    \n    public static int indexOf(boolean[] array, boolean valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int lastIndexOf(boolean[] array, boolean valueToFind) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    \n    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static boolean contains(boolean[] array, boolean valueToFind) {\n        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n    }\n\n    \n    \n\n    \n    \n    \n    public static char[] toPrimitive(Character[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_CHAR_ARRAY;\n        }\n        final char[] result = new char[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].charValue();\n        }\n        return result;\n    }\n\n    \n    public static char[] toPrimitive(Character[] array, char valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_CHAR_ARRAY;\n        }\n        final char[] result = new char[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Character b = array[i];\n            result[i] = (b == null ? valueForNull : b.charValue());\n        }\n        return result;\n    }\n\n    \n    public static Character[] toObject(char[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_CHARACTER_OBJECT_ARRAY;\n        }\n        final Character[] result = new Character[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = Character.valueOf(array[i]);\n        }\n        return result;\n     }\n\n    \n    \n    \n    public static long[] toPrimitive(Long[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_LONG_ARRAY;\n        }\n        final long[] result = new long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].longValue();\n        }\n        return result;\n    }\n\n    \n    public static long[] toPrimitive(Long[] array, long valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_LONG_ARRAY;\n        }\n        final long[] result = new long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Long b = array[i];\n            result[i] = (b == null ? valueForNull : b.longValue());\n        }\n        return result;\n    }\n\n    \n    public static Long[] toObject(long[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_LONG_OBJECT_ARRAY;\n        }\n        final Long[] result = new Long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = Long.valueOf(array[i]);\n        }\n        return result;\n    }\n\n    \n    \n    \n    public static int[] toPrimitive(Integer[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].intValue();\n        }\n        return result;\n    }\n\n    \n    public static int[] toPrimitive(Integer[] array, int valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Integer b = array[i];\n            result[i] = (b == null ? valueForNull : b.intValue());\n        }\n        return result;\n    }\n\n    \n    public static Integer[] toObject(int[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_INTEGER_OBJECT_ARRAY;\n        }\n        final Integer[] result = new Integer[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = Integer.valueOf(array[i]);\n        }\n        return result;\n    }\n\n    \n    \n    \n    public static short[] toPrimitive(Short[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_SHORT_ARRAY;\n        }\n        final short[] result = new short[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].shortValue();\n        }\n        return result;\n    }\n\n    \n    public static short[] toPrimitive(Short[] array, short valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_SHORT_ARRAY;\n        }\n        final short[] result = new short[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Short b = array[i];\n            result[i] = (b == null ? valueForNull : b.shortValue());\n        }\n        return result;\n    }\n\n    \n    public static Short[] toObject(short[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_SHORT_OBJECT_ARRAY;\n        }\n        final Short[] result = new Short[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = Short.valueOf(array[i]);\n        }\n        return result;\n    }\n\n    \n    \n    \n    public static byte[] toPrimitive(Byte[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        final byte[] result = new byte[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].byteValue();\n        }\n        return result;\n    }\n\n    \n    public static byte[] toPrimitive(Byte[] array, byte valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        final byte[] result = new byte[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Byte b = array[i];\n            result[i] = (b == null ? valueForNull : b.byteValue());\n        }\n        return result;\n    }\n\n    \n    public static Byte[] toObject(byte[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_BYTE_OBJECT_ARRAY;\n        }\n        final Byte[] result = new Byte[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = Byte.valueOf(array[i]);\n        }\n        return result;\n    }\n\n    \n    \n    \n    public static double[] toPrimitive(Double[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_DOUBLE_ARRAY;\n        }\n        final double[] result = new double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].doubleValue();\n        }\n        return result;\n    }\n\n    \n    public static double[] toPrimitive(Double[] array, double valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_DOUBLE_ARRAY;\n        }\n        final double[] result = new double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Double b = array[i];\n            result[i] = (b == null ? valueForNull : b.doubleValue());\n        }\n        return result;\n    }\n\n    \n    public static Double[] toObject(double[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_DOUBLE_OBJECT_ARRAY;\n        }\n        final Double[] result = new Double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = Double.valueOf(array[i]);\n        }\n        return result;\n    }\n\n    \n    \n    \n    public static float[] toPrimitive(Float[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_FLOAT_ARRAY;\n        }\n        final float[] result = new float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].floatValue();\n        }\n        return result;\n    }\n\n    \n    public static float[] toPrimitive(Float[] array, float valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_FLOAT_ARRAY;\n        }\n        final float[] result = new float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Float b = array[i];\n            result[i] = (b == null ? valueForNull : b.floatValue());\n        }\n        return result;\n    }\n\n    \n    public static Float[] toObject(float[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_FLOAT_OBJECT_ARRAY;\n        }\n        final Float[] result = new Float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = Float.valueOf(array[i]);\n        }\n        return result;\n    }\n\n    \n    \n    \n    public static boolean[] toPrimitive(Boolean[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_BOOLEAN_ARRAY;\n        }\n        final boolean[] result = new boolean[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].booleanValue();\n        }\n        return result;\n    }\n\n    \n    public static boolean[] toPrimitive(Boolean[] array, boolean valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_BOOLEAN_ARRAY;\n        }\n        final boolean[] result = new boolean[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Boolean b = array[i];\n            result[i] = (b == null ? valueForNull : b.booleanValue());\n        }\n        return result;\n    }\n\n    \n    public static Boolean[] toObject(boolean[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_BOOLEAN_OBJECT_ARRAY;\n        }\n        final Boolean[] result = new Boolean[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);\n        }\n        return result;\n    }\n\n    \n    \n    public static <T> boolean isEmpty(T[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    \n    public static boolean isEmpty(long[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    \n    public static boolean isEmpty(int[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    \n    public static boolean isEmpty(short[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    \n    public static boolean isEmpty(char[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    \n    public static boolean isEmpty(byte[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    \n    public static boolean isEmpty(double[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    \n    public static boolean isEmpty(float[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    \n    public static boolean isEmpty(boolean[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public static <T> T[] addAll(T[] array1, T... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        final Class<?> type1 = array1.getClass().getComponentType();\n        T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n            System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n            \n        return joinedArray;\n    }\n\n    \n    public static boolean[] addAll(boolean[] array1, boolean... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        boolean[] joinedArray = new boolean[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    \n    public static char[] addAll(char[] array1, char... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        char[] joinedArray = new char[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    \n    public static byte[] addAll(byte[] array1, byte... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        byte[] joinedArray = new byte[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    \n    public static short[] addAll(short[] array1, short... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        short[] joinedArray = new short[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    \n    public static int[] addAll(int[] array1, int... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        int[] joinedArray = new int[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    \n    public static long[] addAll(long[] array1, long... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        long[] joinedArray = new long[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    \n    public static float[] addAll(float[] array1, float... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        float[] joinedArray = new float[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    \n    public static double[] addAll(double[] array1, double... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        double[] joinedArray = new double[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public static <T> T[] add(T[] array, T element) {\n        Class<?> type = array != null ? array.getClass() : (element != null ? element.getClass() : Object.class);\n        T[] newArray = (T[]) copyArrayGrow1(array, type);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    \n    public static boolean[] add(boolean[] array, boolean element) {\n        boolean[] newArray = (boolean[])copyArrayGrow1(array, Boolean.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    \n    public static byte[] add(byte[] array, byte element) {\n        byte[] newArray = (byte[])copyArrayGrow1(array, Byte.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    \n    public static char[] add(char[] array, char element) {\n        char[] newArray = (char[])copyArrayGrow1(array, Character.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    \n    public static double[] add(double[] array, double element) {\n        double[] newArray = (double[])copyArrayGrow1(array, Double.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    \n    public static float[] add(float[] array, float element) {\n        float[] newArray = (float[])copyArrayGrow1(array, Float.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    \n    public static int[] add(int[] array, int element) {\n        int[] newArray = (int[])copyArrayGrow1(array, Integer.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    \n    public static long[] add(long[] array, long element) {\n        long[] newArray = (long[])copyArrayGrow1(array, Long.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    \n    public static short[] add(short[] array, short element) {\n        short[] newArray = (short[])copyArrayGrow1(array, Short.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    \n    private static Object copyArrayGrow1(Object array, Class<?> newArrayComponentType) {\n        if (array != null) {\n            int arrayLength = Array.getLength(array);\n            Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1);\n            System.arraycopy(array, 0, newArray, 0, arrayLength);\n            return newArray;\n        }\n        return Array.newInstance(newArrayComponentType, 1);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public static <T> T[] add(T[] array, int index, T element) {\n        Class<?> clss = null;\n        if (array != null) {\n            clss = array.getClass().getComponentType();\n        } else if (element != null) {\n            clss = element.getClass();\n        } else {\n            return (T[]) new Object[] { null };\n        }\n        return (T[]) add(array, index, element, clss);\n    }\n\n    \n    public static boolean[] add(boolean[] array, int index, boolean element) {\n        return (boolean[]) add(array, index, Boolean.valueOf(element), Boolean.TYPE);\n    }\n\n    \n    public static char[] add(char[] array, int index, char element) {\n        return (char[]) add(array, index, Character.valueOf(element), Character.TYPE);\n    }\n\n    \n    public static byte[] add(byte[] array, int index, byte element) {\n        return (byte[]) add(array, index, Byte.valueOf(element), Byte.TYPE);\n    }\n\n    \n    public static short[] add(short[] array, int index, short element) {\n        return (short[]) add(array, index, Short.valueOf(element), Short.TYPE);\n    }\n\n    \n    public static int[] add(int[] array, int index, int element) {\n        return (int[]) add(array, index, Integer.valueOf(element), Integer.TYPE);\n    }\n\n    \n    public static long[] add(long[] array, int index, long element) {\n        return (long[]) add(array, index, Long.valueOf(element), Long.TYPE);\n    }\n\n    \n    public static float[] add(float[] array, int index, float element) {\n        return (float[]) add(array, index, Float.valueOf(element), Float.TYPE);\n    }\n\n    \n    public static double[] add(double[] array, int index, double element) {\n        return (double[]) add(array, index, Double.valueOf(element), Double.TYPE);\n    }\n\n    \n    private static Object add(Object array, int index, Object element, Class<?> clss) {\n        if (array == null) {\n            if (index != 0) {\n                throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: 0\");\n            }\n            Object joinedArray = Array.newInstance(clss, 1);\n            Array.set(joinedArray, 0, element);\n            return joinedArray;\n        }\n        int length = Array.getLength(array);\n        if (index > length || index < 0) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n        }\n        Object result = Array.newInstance(clss, length + 1);\n        System.arraycopy(array, 0, result, 0, index);\n        Array.set(result, index, element);\n        if (index < length) {\n            System.arraycopy(array, index, result, index + 1, length - index);\n        }\n        return result;\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public static <T> T[] remove(T[] array, int index) {\n        return (T[]) remove((Object) array, index);\n    }\n\n    \n    public static <T> T[] removeElement(T[] array, Object element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    \n    public static boolean[] remove(boolean[] array, int index) {\n        return (boolean[]) remove((Object) array, index);\n    }\n\n    \n    public static boolean[] removeElement(boolean[] array, boolean element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    \n    public static byte[] remove(byte[] array, int index) {\n        return (byte[]) remove((Object) array, index);\n    }\n\n    \n    public static byte[] removeElement(byte[] array, byte element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    \n    public static char[] remove(char[] array, int index) {\n        return (char[]) remove((Object) array, index);\n    }\n\n    \n    public static char[] removeElement(char[] array, char element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    \n    public static double[] remove(double[] array, int index) {\n        return (double[]) remove((Object) array, index);\n    }\n\n    \n    public static double[] removeElement(double[] array, double element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    \n    public static float[] remove(float[] array, int index) {\n        return (float[]) remove((Object) array, index);\n    }\n\n    \n    public static float[] removeElement(float[] array, float element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    \n    public static int[] remove(int[] array, int index) {\n        return (int[]) remove((Object) array, index);\n    }\n\n    \n    public static int[] removeElement(int[] array, int element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    \n    public static long[] remove(long[] array, int index) {\n        return (long[]) remove((Object) array, index);\n    }\n\n    \n    public static long[] removeElement(long[] array, long element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    \n    public static short[] remove(short[] array, int index) {\n        return (short[]) remove((Object) array, index);\n    }\n\n    \n    public static short[] removeElement(short[] array, short element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    \n    private static Object remove(Object array, int index) {\n        int length = getLength(array);\n        if (index < 0 || index >= length) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n        }\n\n        Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);\n        System.arraycopy(array, 0, result, 0, index);\n        if (index < length - 1) {\n            System.arraycopy(array, index + 1, result, index, length - index - 1);\n        }\n\n        return result;\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.lang3;\n\nimport java.lang.reflect.Array;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.commons.lang3.builder.EqualsBuilder;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\n\npublic class ArrayUtils { public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0]; public static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0]; public static final String[] EMPTY_STRING_ARRAY = new String[0]; public static final long[] EMPTY_LONG_ARRAY = new long[0]; public static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0]; public static final int[] EMPTY_INT_ARRAY = new int[0]; public static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0]; public static final short[] EMPTY_SHORT_ARRAY = new short[0]; public static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0]; public static final byte[] EMPTY_BYTE_ARRAY = new byte[0]; public static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0]; public static final double[] EMPTY_DOUBLE_ARRAY = new double[0]; public static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0]; public static final float[] EMPTY_FLOAT_ARRAY = new float[0]; public static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0]; public static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0]; public static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0]; public static final char[] EMPTY_CHAR_ARRAY = new char[0]; public static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0]; public static final int INDEX_NOT_FOUND = -1; public ArrayUtils() {\n      super();\n    }\n\n    \n    \n    \n    public static String toString(Object array) {\n        return toString(array, \"{}\");\n    }\n\n    \n    public static String toString(Object array, String stringIfNull) {\n        if (array == null) {\n            return stringIfNull;\n        }\n        return new ToStringBuilder(array, ToStringStyle.SIMPLE_STYLE).append(array).toString();\n    }\n\n    \n    public static boolean isEquals(Object array1, Object array2) {\n        return new EqualsBuilder().append(array1, array2).isEquals();\n    }\n\n    \n    \n    \n    public static Map<Object, Object> toMap(Object[] array) {\n        if (array == null) {\n            return null;\n        }\n        final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5));\n        for (int i = 0; i < array.length; i++) {\n            Object object = array[i];\n            if (object instanceof Map.Entry<?, ?>) {\n                Map.Entry<?,?> entry = (Map.Entry<?,?>) object;\n                map.put(entry.getKey(), entry.getValue());\n            } else if (object instanceof Object[]) {\n                Object[] entry = (Object[]) object;\n                if (entry.length < 2) {\n                    throw new IllegalArgumentException(\"Array element \" + i + \", '\"\n                        + object\n                        + \"', has a length less than 2\");\n                }\n                map.put(entry[0], entry[1]);\n            } else {\n                throw new IllegalArgumentException(\"Array element \" + i + \", '\"\n                        + object\n                        + \"', is neither of type Map.Entry nor an Array\");\n            }\n        }\n        return map;\n    }\n\n    \n    \n    \n    public static <T> T[] clone(T[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    \n    public static long[] clone(long[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    \n    public static int[] clone(int[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    \n    public static short[] clone(short[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    \n    public static char[] clone(char[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    \n    public static byte[] clone(byte[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    \n    public static double[] clone(double[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    \n    public static float[] clone(float[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    \n    public static boolean[] clone(boolean[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    \n    \n    \n    @SuppressWarnings(\"unchecked\")\n    public static <T> T[] subarray(T[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        Class<?> type = array.getClass().getComponentType();\n        if (newSize <= 0) {\n            return (T[]) Array.newInstance(type, 0);\n        }\n        T[] subarray = (T[]) Array.newInstance(type, newSize);\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    \n    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return EMPTY_LONG_ARRAY;\n        }\n\n        long[] subarray = new long[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    \n    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return EMPTY_INT_ARRAY;\n        }\n\n        int[] subarray = new int[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    \n    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return EMPTY_SHORT_ARRAY;\n        }\n\n        short[] subarray = new short[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    \n    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return EMPTY_CHAR_ARRAY;\n        }\n\n        char[] subarray = new char[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    \n    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n\n        byte[] subarray = new byte[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    \n    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return EMPTY_DOUBLE_ARRAY;\n        }\n\n        double[] subarray = new double[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    \n    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return EMPTY_FLOAT_ARRAY;\n        }\n\n        float[] subarray = new float[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    \n    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return EMPTY_BOOLEAN_ARRAY;\n        }\n\n        boolean[] subarray = new boolean[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    \n    \n    \n    public static boolean isSameLength(Object[] array1, Object[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    \n    public static boolean isSameLength(long[] array1, long[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    \n    public static boolean isSameLength(int[] array1, int[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    \n    public static boolean isSameLength(short[] array1, short[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    \n    public static boolean isSameLength(char[] array1, char[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    \n    public static boolean isSameLength(byte[] array1, byte[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    \n    public static boolean isSameLength(double[] array1, double[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    \n    public static boolean isSameLength(float[] array1, float[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    \n    public static boolean isSameLength(boolean[] array1, boolean[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    \n    \n    public static int getLength(Object array) {\n        if (array == null) {\n            return 0;\n        }\n        return Array.getLength(array);\n    }\n\n    \n    public static boolean isSameType(Object array1, Object array2) {\n        if (array1 == null || array2 == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        return array1.getClass().getName().equals(array2.getClass().getName());\n    }\n\n    \n    \n    \n    public static void reverse(Object[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        Object tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    \n    public static void reverse(long[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        long tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    \n    public static void reverse(int[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        int tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    \n    public static void reverse(short[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        short tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    \n    public static void reverse(char[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        char tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    \n    public static void reverse(byte[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        byte tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    \n    public static void reverse(double[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        double tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    \n    public static void reverse(float[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        float tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    \n    public static void reverse(boolean[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        boolean tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    \n    \n\n    \n    \n    \n    public static int indexOf(Object[] array, Object objectToFind) {\n        return indexOf(array, objectToFind, 0);\n    }\n\n    \n    public static int indexOf(Object[] array, Object objectToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        if (objectToFind == null) {\n            for (int i = startIndex; i < array.length; i++) {\n                if (array[i] == null) {\n                    return i;\n                }\n            }\n        } else if (array.getClass().getComponentType().isInstance(objectToFind)) {\n            for (int i = startIndex; i < array.length; i++) {\n                if (objectToFind.equals(array[i])) {\n                    return i;\n                }\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int lastIndexOf(Object[] array, Object objectToFind) {\n        return lastIndexOf(array, objectToFind, Integer.MAX_VALUE);\n    }\n\n    \n    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        if (objectToFind == null) {\n            for (int i = startIndex; i >= 0; i--) {\n                if (array[i] == null) {\n                    return i;\n                }\n            }\n        } else if (array.getClass().getComponentType().isInstance(objectToFind)) {\n            for (int i = startIndex; i >= 0; i--) {\n                if (objectToFind.equals(array[i])) {\n                    return i;\n                }\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static boolean contains(Object[] array, Object objectToFind) {\n        return indexOf(array, objectToFind) != INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static int indexOf(long[] array, long valueToFind) {\n        return indexOf(array, valueToFind, 0);\n    }\n\n    \n    public static int indexOf(long[] array, long valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int lastIndexOf(long[] array, long valueToFind) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    \n    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static boolean contains(long[] array, long valueToFind) {\n        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static int indexOf(int[] array, int valueToFind) {\n        return indexOf(array, valueToFind, 0);\n    }\n\n    \n    public static int indexOf(int[] array, int valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int lastIndexOf(int[] array, int valueToFind) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    \n    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static boolean contains(int[] array, int valueToFind) {\n        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static int indexOf(short[] array, short valueToFind) {\n        return indexOf(array, valueToFind, 0);\n    }\n\n    \n    public static int indexOf(short[] array, short valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int lastIndexOf(short[] array, short valueToFind) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    \n    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static boolean contains(short[] array, short valueToFind) {\n        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static int indexOf(char[] array, char valueToFind) {\n        return indexOf(array, valueToFind, 0);\n    }\n\n    \n    public static int indexOf(char[] array, char valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int lastIndexOf(char[] array, char valueToFind) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    \n    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static boolean contains(char[] array, char valueToFind) {\n        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static int indexOf(byte[] array, byte valueToFind) {\n        return indexOf(array, valueToFind, 0);\n    }\n\n    \n    public static int indexOf(byte[] array, byte valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int lastIndexOf(byte[] array, byte valueToFind) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    \n    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static boolean contains(byte[] array, byte valueToFind) {\n        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static int indexOf(double[] array, double valueToFind) {\n        return indexOf(array, valueToFind, 0);\n    }\n\n    \n    public static int indexOf(double[] array, double valueToFind, double tolerance) {\n        return indexOf(array, valueToFind, 0, tolerance);\n    }\n\n    \n    public static int indexOf(double[] array, double valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int indexOf(double[] array, double valueToFind, int startIndex, double tolerance) {\n        if (ArrayUtils.isEmpty(array)) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        double min = valueToFind - tolerance;\n        double max = valueToFind + tolerance;\n        for (int i = startIndex; i < array.length; i++) {\n            if (array[i] >= min && array[i] <= max) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int lastIndexOf(double[] array, double valueToFind) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    \n    public static int lastIndexOf(double[] array, double valueToFind, double tolerance) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE, tolerance);\n    }\n\n    \n    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {\n        if (ArrayUtils.isEmpty(array)) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        double min = valueToFind - tolerance;\n        double max = valueToFind + tolerance;\n        for (int i = startIndex; i >= 0; i--) {\n            if (array[i] >= min && array[i] <= max) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static boolean contains(double[] array, double valueToFind) {\n        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n    }\n\n    \n    public static boolean contains(double[] array, double valueToFind, double tolerance) {\n        return indexOf(array, valueToFind, 0, tolerance) != INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static int indexOf(float[] array, float valueToFind) {\n        return indexOf(array, valueToFind, 0);\n    }\n\n    \n    public static int indexOf(float[] array, float valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int lastIndexOf(float[] array, float valueToFind) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    \n    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static boolean contains(float[] array, float valueToFind) {\n        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n    }\n\n    \n    \n    \n    public static int indexOf(boolean[] array, boolean valueToFind) {\n        return indexOf(array, valueToFind, 0);\n    }\n\n    \n    public static int indexOf(boolean[] array, boolean valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static int lastIndexOf(boolean[] array, boolean valueToFind) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    \n    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    \n    public static boolean contains(boolean[] array, boolean valueToFind) {\n        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n    }\n\n    \n    \n\n    \n    \n    \n    public static char[] toPrimitive(Character[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_CHAR_ARRAY;\n        }\n        final char[] result = new char[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].charValue();\n        }\n        return result;\n    }\n\n    \n    public static char[] toPrimitive(Character[] array, char valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_CHAR_ARRAY;\n        }\n        final char[] result = new char[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Character b = array[i];\n            result[i] = (b == null ? valueForNull : b.charValue());\n        }\n        return result;\n    }\n\n    \n    public static Character[] toObject(char[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_CHARACTER_OBJECT_ARRAY;\n        }\n        final Character[] result = new Character[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = Character.valueOf(array[i]);\n        }\n        return result;\n     }\n\n    \n    \n    \n    public static long[] toPrimitive(Long[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_LONG_ARRAY;\n        }\n        final long[] result = new long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].longValue();\n        }\n        return result;\n    }\n\n    \n    public static long[] toPrimitive(Long[] array, long valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_LONG_ARRAY;\n        }\n        final long[] result = new long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Long b = array[i];\n            result[i] = (b == null ? valueForNull : b.longValue());\n        }\n        return result;\n    }\n\n    \n    public static Long[] toObject(long[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_LONG_OBJECT_ARRAY;\n        }\n        final Long[] result = new Long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = Long.valueOf(array[i]);\n        }\n        return result;\n    }\n\n    \n    \n    \n    public static int[] toPrimitive(Integer[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].intValue();\n        }\n        return result;\n    }\n\n    \n    public static int[] toPrimitive(Integer[] array, int valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Integer b = array[i];\n            result[i] = (b == null ? valueForNull : b.intValue());\n        }\n        return result;\n    }\n\n    \n    public static Integer[] toObject(int[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_INTEGER_OBJECT_ARRAY;\n        }\n        final Integer[] result = new Integer[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = Integer.valueOf(array[i]);\n        }\n        return result;\n    }\n\n    \n    \n    \n    public static short[] toPrimitive(Short[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_SHORT_ARRAY;\n        }\n        final short[] result = new short[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].shortValue();\n        }\n        return result;\n    }\n\n    \n    public static short[] toPrimitive(Short[] array, short valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_SHORT_ARRAY;\n        }\n        final short[] result = new short[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Short b = array[i];\n            result[i] = (b == null ? valueForNull : b.shortValue());\n        }\n        return result;\n    }\n\n    \n    public static Short[] toObject(short[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_SHORT_OBJECT_ARRAY;\n        }\n        final Short[] result = new Short[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = Short.valueOf(array[i]);\n        }\n        return result;\n    }\n\n    \n    \n    \n    public static byte[] toPrimitive(Byte[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        final byte[] result = new byte[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].byteValue();\n        }\n        return result;\n    }\n\n    \n    public static byte[] toPrimitive(Byte[] array, byte valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        final byte[] result = new byte[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Byte b = array[i];\n            result[i] = (b == null ? valueForNull : b.byteValue());\n        }\n        return result;\n    }\n\n    \n    public static Byte[] toObject(byte[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_BYTE_OBJECT_ARRAY;\n        }\n        final Byte[] result = new Byte[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = Byte.valueOf(array[i]);\n        }\n        return result;\n    }\n\n    \n    \n    \n    public static double[] toPrimitive(Double[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_DOUBLE_ARRAY;\n        }\n        final double[] result = new double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].doubleValue();\n        }\n        return result;\n    }\n\n    \n    public static double[] toPrimitive(Double[] array, double valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_DOUBLE_ARRAY;\n        }\n        final double[] result = new double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Double b = array[i];\n            result[i] = (b == null ? valueForNull : b.doubleValue());\n        }\n        return result;\n    }\n\n    \n    public static Double[] toObject(double[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_DOUBLE_OBJECT_ARRAY;\n        }\n        final Double[] result = new Double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = Double.valueOf(array[i]);\n        }\n        return result;\n    }\n\n    \n    \n    \n    public static float[] toPrimitive(Float[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_FLOAT_ARRAY;\n        }\n        final float[] result = new float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].floatValue();\n        }\n        return result;\n    }\n\n    \n    public static float[] toPrimitive(Float[] array, float valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_FLOAT_ARRAY;\n        }\n        final float[] result = new float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Float b = array[i];\n            result[i] = (b == null ? valueForNull : b.floatValue());\n        }\n        return result;\n    }\n\n    \n    public static Float[] toObject(float[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_FLOAT_OBJECT_ARRAY;\n        }\n        final Float[] result = new Float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = Float.valueOf(array[i]);\n        }\n        return result;\n    }\n\n    \n    \n    \n    public static boolean[] toPrimitive(Boolean[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_BOOLEAN_ARRAY;\n        }\n        final boolean[] result = new boolean[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].booleanValue();\n        }\n        return result;\n    }\n\n    \n    public static boolean[] toPrimitive(Boolean[] array, boolean valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_BOOLEAN_ARRAY;\n        }\n        final boolean[] result = new boolean[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Boolean b = array[i];\n            result[i] = (b == null ? valueForNull : b.booleanValue());\n        }\n        return result;\n    }\n\n    \n    public static Boolean[] toObject(boolean[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_BOOLEAN_OBJECT_ARRAY;\n        }\n        final Boolean[] result = new Boolean[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);\n        }\n        return result;\n    }\n\n    \n    \n    public static <T> boolean isEmpty(T[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    \n    public static boolean isEmpty(long[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    \n    public static boolean isEmpty(int[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    \n    public static boolean isEmpty(short[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    \n    public static boolean isEmpty(char[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    \n    public static boolean isEmpty(byte[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    \n    public static boolean isEmpty(double[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    \n    public static boolean isEmpty(float[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    \n    public static boolean isEmpty(boolean[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public static <T> T[] addAll(T[] array1, T... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        final Class<?> type1 = array1.getClass().getComponentType();\n        T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        try {\n            System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        } catch (ArrayStoreException ase) {\n            \n            final Class<?> type2 = array2.getClass().getComponentType();\n            if (!type1.isAssignableFrom(type2)){\n                throw new IllegalArgumentException(\"Cannot store \"+type2.getName()+\" in an array of \"+type1.getName());\n            }\n            throw ase; \n        }\n        return joinedArray;\n    }\n\n    \n    public static boolean[] addAll(boolean[] array1, boolean... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        boolean[] joinedArray = new boolean[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    \n    public static char[] addAll(char[] array1, char... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        char[] joinedArray = new char[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    \n    public static byte[] addAll(byte[] array1, byte... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        byte[] joinedArray = new byte[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    \n    public static short[] addAll(short[] array1, short... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        short[] joinedArray = new short[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    \n    public static int[] addAll(int[] array1, int... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        int[] joinedArray = new int[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    \n    public static long[] addAll(long[] array1, long... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        long[] joinedArray = new long[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    \n    public static float[] addAll(float[] array1, float... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        float[] joinedArray = new float[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    \n    public static double[] addAll(double[] array1, double... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        double[] joinedArray = new double[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public static <T> T[] add(T[] array, T element) {\n        Class<?> type = array != null ? array.getClass() : (element != null ? element.getClass() : Object.class);\n        T[] newArray = (T[]) copyArrayGrow1(array, type);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    \n    public static boolean[] add(boolean[] array, boolean element) {\n        boolean[] newArray = (boolean[])copyArrayGrow1(array, Boolean.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    \n    public static byte[] add(byte[] array, byte element) {\n        byte[] newArray = (byte[])copyArrayGrow1(array, Byte.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    \n    public static char[] add(char[] array, char element) {\n        char[] newArray = (char[])copyArrayGrow1(array, Character.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    \n    public static double[] add(double[] array, double element) {\n        double[] newArray = (double[])copyArrayGrow1(array, Double.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    \n    public static float[] add(float[] array, float element) {\n        float[] newArray = (float[])copyArrayGrow1(array, Float.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    \n    public static int[] add(int[] array, int element) {\n        int[] newArray = (int[])copyArrayGrow1(array, Integer.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    \n    public static long[] add(long[] array, long element) {\n        long[] newArray = (long[])copyArrayGrow1(array, Long.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    \n    public static short[] add(short[] array, short element) {\n        short[] newArray = (short[])copyArrayGrow1(array, Short.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    \n    private static Object copyArrayGrow1(Object array, Class<?> newArrayComponentType) {\n        if (array != null) {\n            int arrayLength = Array.getLength(array);\n            Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1);\n            System.arraycopy(array, 0, newArray, 0, arrayLength);\n            return newArray;\n        }\n        return Array.newInstance(newArrayComponentType, 1);\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public static <T> T[] add(T[] array, int index, T element) {\n        Class<?> clss = null;\n        if (array != null) {\n            clss = array.getClass().getComponentType();\n        } else if (element != null) {\n            clss = element.getClass();\n        } else {\n            return (T[]) new Object[] { null };\n        }\n        return (T[]) add(array, index, element, clss);\n    }\n\n    \n    public static boolean[] add(boolean[] array, int index, boolean element) {\n        return (boolean[]) add(array, index, Boolean.valueOf(element), Boolean.TYPE);\n    }\n\n    \n    public static char[] add(char[] array, int index, char element) {\n        return (char[]) add(array, index, Character.valueOf(element), Character.TYPE);\n    }\n\n    \n    public static byte[] add(byte[] array, int index, byte element) {\n        return (byte[]) add(array, index, Byte.valueOf(element), Byte.TYPE);\n    }\n\n    \n    public static short[] add(short[] array, int index, short element) {\n        return (short[]) add(array, index, Short.valueOf(element), Short.TYPE);\n    }\n\n    \n    public static int[] add(int[] array, int index, int element) {\n        return (int[]) add(array, index, Integer.valueOf(element), Integer.TYPE);\n    }\n\n    \n    public static long[] add(long[] array, int index, long element) {\n        return (long[]) add(array, index, Long.valueOf(element), Long.TYPE);\n    }\n\n    \n    public static float[] add(float[] array, int index, float element) {\n        return (float[]) add(array, index, Float.valueOf(element), Float.TYPE);\n    }\n\n    \n    public static double[] add(double[] array, int index, double element) {\n        return (double[]) add(array, index, Double.valueOf(element), Double.TYPE);\n    }\n\n    \n    private static Object add(Object array, int index, Object element, Class<?> clss) {\n        if (array == null) {\n            if (index != 0) {\n                throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: 0\");\n            }\n            Object joinedArray = Array.newInstance(clss, 1);\n            Array.set(joinedArray, 0, element);\n            return joinedArray;\n        }\n        int length = Array.getLength(array);\n        if (index > length || index < 0) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n        }\n        Object result = Array.newInstance(clss, length + 1);\n        System.arraycopy(array, 0, result, 0, index);\n        Array.set(result, index, element);\n        if (index < length) {\n            System.arraycopy(array, index, result, index + 1, length - index);\n        }\n        return result;\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    public static <T> T[] remove(T[] array, int index) {\n        return (T[]) remove((Object) array, index);\n    }\n\n    \n    public static <T> T[] removeElement(T[] array, Object element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    \n    public static boolean[] remove(boolean[] array, int index) {\n        return (boolean[]) remove((Object) array, index);\n    }\n\n    \n    public static boolean[] removeElement(boolean[] array, boolean element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    \n    public static byte[] remove(byte[] array, int index) {\n        return (byte[]) remove((Object) array, index);\n    }\n\n    \n    public static byte[] removeElement(byte[] array, byte element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    \n    public static char[] remove(char[] array, int index) {\n        return (char[]) remove((Object) array, index);\n    }\n\n    \n    public static char[] removeElement(char[] array, char element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    \n    public static double[] remove(double[] array, int index) {\n        return (double[]) remove((Object) array, index);\n    }\n\n    \n    public static double[] removeElement(double[] array, double element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    \n    public static float[] remove(float[] array, int index) {\n        return (float[]) remove((Object) array, index);\n    }\n\n    \n    public static float[] removeElement(float[] array, float element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    \n    public static int[] remove(int[] array, int index) {\n        return (int[]) remove((Object) array, index);\n    }\n\n    \n    public static int[] removeElement(int[] array, int element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    \n    public static long[] remove(long[] array, int index) {\n        return (long[]) remove((Object) array, index);\n    }\n\n    \n    public static long[] removeElement(long[] array, long element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    \n    public static short[] remove(short[] array, int index) {\n        return (short[]) remove((Object) array, index);\n    }\n\n    \n    public static short[] removeElement(short[] array, short element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    \n    private static Object remove(Object array, int index) {\n        int length = getLength(array);\n        if (index < 0 || index >= length) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n        }\n\n        Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);\n        System.arraycopy(array, 0, result, 0, index);\n        if (index < length - 1) {\n            System.arraycopy(array, index + 1, result, index, length - index - 1);\n        }\n\n        return result;\n    }\n\n}\n",
      "buggy_signatures": [
        "public static String toString(Object array)",
        "public static String toString(Object array, String stringIfNull)",
        "public static boolean isEquals(Object array1, Object array2)",
        "public static Map<Object, Object> toMap(Object[] array)",
        "public static <T> T[] clone(T[] array)",
        "public static long[] clone(long[] array)",
        "public static int[] clone(int[] array)",
        "public static short[] clone(short[] array)",
        "public static char[] clone(char[] array)",
        "public static byte[] clone(byte[] array)",
        "public static double[] clone(double[] array)",
        "public static float[] clone(float[] array)",
        "public static boolean[] clone(boolean[] array)",
        "public static <T> T[] subarray(T[] array, int startIndexInclusive, int endIndexExclusive)",
        "public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive)",
        "public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive)",
        "public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive)",
        "public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive)",
        "public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive)",
        "public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive)",
        "public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive)",
        "public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive)",
        "public static boolean isSameLength(Object[] array1, Object[] array2)",
        "public static boolean isSameLength(long[] array1, long[] array2)",
        "public static boolean isSameLength(int[] array1, int[] array2)",
        "public static boolean isSameLength(short[] array1, short[] array2)",
        "public static boolean isSameLength(char[] array1, char[] array2)",
        "public static boolean isSameLength(byte[] array1, byte[] array2)",
        "public static boolean isSameLength(double[] array1, double[] array2)",
        "public static boolean isSameLength(float[] array1, float[] array2)",
        "public static boolean isSameLength(boolean[] array1, boolean[] array2)",
        "public static int getLength(Object array)",
        "public static boolean isSameType(Object array1, Object array2)",
        "public static void reverse(Object[] array)",
        "public static void reverse(long[] array)",
        "public static void reverse(int[] array)",
        "public static void reverse(short[] array)",
        "public static void reverse(char[] array)",
        "public static void reverse(byte[] array)",
        "public static void reverse(double[] array)",
        "public static void reverse(float[] array)",
        "public static void reverse(boolean[] array)",
        "public static int indexOf(Object[] array, Object objectToFind)",
        "public static int indexOf(Object[] array, Object objectToFind, int startIndex)",
        "public static int lastIndexOf(Object[] array, Object objectToFind)",
        "public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex)",
        "public static boolean contains(Object[] array, Object objectToFind)",
        "public static int indexOf(long[] array, long valueToFind)",
        "public static int indexOf(long[] array, long valueToFind, int startIndex)",
        "public static int lastIndexOf(long[] array, long valueToFind)",
        "public static int lastIndexOf(long[] array, long valueToFind, int startIndex)",
        "public static boolean contains(long[] array, long valueToFind)",
        "public static int indexOf(int[] array, int valueToFind)",
        "public static int indexOf(int[] array, int valueToFind, int startIndex)",
        "public static int lastIndexOf(int[] array, int valueToFind)",
        "public static int lastIndexOf(int[] array, int valueToFind, int startIndex)",
        "public static boolean contains(int[] array, int valueToFind)",
        "public static int indexOf(short[] array, short valueToFind)",
        "public static int indexOf(short[] array, short valueToFind, int startIndex)",
        "public static int lastIndexOf(short[] array, short valueToFind)",
        "public static int lastIndexOf(short[] array, short valueToFind, int startIndex)",
        "public static boolean contains(short[] array, short valueToFind)",
        "public static int indexOf(char[] array, char valueToFind)",
        "public static int indexOf(char[] array, char valueToFind, int startIndex)",
        "public static int lastIndexOf(char[] array, char valueToFind)",
        "public static int lastIndexOf(char[] array, char valueToFind, int startIndex)",
        "public static boolean contains(char[] array, char valueToFind)",
        "public static int indexOf(byte[] array, byte valueToFind)",
        "public static int indexOf(byte[] array, byte valueToFind, int startIndex)",
        "public static int lastIndexOf(byte[] array, byte valueToFind)",
        "public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex)",
        "public static boolean contains(byte[] array, byte valueToFind)",
        "public static int indexOf(double[] array, double valueToFind)",
        "public static int indexOf(double[] array, double valueToFind, double tolerance)",
        "public static int indexOf(double[] array, double valueToFind, int startIndex)",
        "public static int indexOf(double[] array, double valueToFind, int startIndex, double tolerance)",
        "public static int lastIndexOf(double[] array, double valueToFind)",
        "public static int lastIndexOf(double[] array, double valueToFind, double tolerance)",
        "public static int lastIndexOf(double[] array, double valueToFind, int startIndex)",
        "public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance)",
        "public static boolean contains(double[] array, double valueToFind)",
        "public static boolean contains(double[] array, double valueToFind, double tolerance)",
        "public static int indexOf(float[] array, float valueToFind)",
        "public static int indexOf(float[] array, float valueToFind, int startIndex)",
        "public static int lastIndexOf(float[] array, float valueToFind)",
        "public static int lastIndexOf(float[] array, float valueToFind, int startIndex)",
        "public static boolean contains(float[] array, float valueToFind)",
        "public static int indexOf(boolean[] array, boolean valueToFind)",
        "public static int indexOf(boolean[] array, boolean valueToFind, int startIndex)",
        "public static int lastIndexOf(boolean[] array, boolean valueToFind)",
        "public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex)",
        "public static boolean contains(boolean[] array, boolean valueToFind)",
        "public static char[] toPrimitive(Character[] array)",
        "public static char[] toPrimitive(Character[] array, char valueForNull)",
        "public static Character[] toObject(char[] array)",
        "public static long[] toPrimitive(Long[] array)",
        "public static long[] toPrimitive(Long[] array, long valueForNull)",
        "public static Long[] toObject(long[] array)",
        "public static int[] toPrimitive(Integer[] array)",
        "public static int[] toPrimitive(Integer[] array, int valueForNull)",
        "public static Integer[] toObject(int[] array)",
        "public static short[] toPrimitive(Short[] array)",
        "public static short[] toPrimitive(Short[] array, short valueForNull)",
        "public static Short[] toObject(short[] array)",
        "public static byte[] toPrimitive(Byte[] array)",
        "public static byte[] toPrimitive(Byte[] array, byte valueForNull)",
        "public static Byte[] toObject(byte[] array)",
        "public static double[] toPrimitive(Double[] array)",
        "public static double[] toPrimitive(Double[] array, double valueForNull)",
        "public static Double[] toObject(double[] array)",
        "public static float[] toPrimitive(Float[] array)",
        "public static float[] toPrimitive(Float[] array, float valueForNull)",
        "public static Float[] toObject(float[] array)",
        "public static boolean[] toPrimitive(Boolean[] array)",
        "public static boolean[] toPrimitive(Boolean[] array, boolean valueForNull)",
        "public static Boolean[] toObject(boolean[] array)",
        "public static <T> boolean isEmpty(T[] array)",
        "public static boolean isEmpty(long[] array)",
        "public static boolean isEmpty(int[] array)",
        "public static boolean isEmpty(short[] array)",
        "public static boolean isEmpty(char[] array)",
        "public static boolean isEmpty(byte[] array)",
        "public static boolean isEmpty(double[] array)",
        "public static boolean isEmpty(float[] array)",
        "public static boolean isEmpty(boolean[] array)",
        "public static <T> T[] addAll(T[] array1, T... array2)",
        "public static boolean[] addAll(boolean[] array1, boolean... array2)",
        "public static char[] addAll(char[] array1, char... array2)",
        "public static byte[] addAll(byte[] array1, byte... array2)",
        "public static short[] addAll(short[] array1, short... array2)",
        "public static int[] addAll(int[] array1, int... array2)",
        "public static long[] addAll(long[] array1, long... array2)",
        "public static float[] addAll(float[] array1, float... array2)",
        "public static double[] addAll(double[] array1, double... array2)",
        "public static <T> T[] add(T[] array, T element)",
        "public static boolean[] add(boolean[] array, boolean element)",
        "public static byte[] add(byte[] array, byte element)",
        "public static char[] add(char[] array, char element)",
        "public static double[] add(double[] array, double element)",
        "public static float[] add(float[] array, float element)",
        "public static int[] add(int[] array, int element)",
        "public static long[] add(long[] array, long element)",
        "public static short[] add(short[] array, short element)",
        "private static Object copyArrayGrow1(Object array, Class<?> newArrayComponentType)",
        "public static <T> T[] add(T[] array, int index, T element)",
        "public static boolean[] add(boolean[] array, int index, boolean element)",
        "public static char[] add(char[] array, int index, char element)",
        "public static byte[] add(byte[] array, int index, byte element)",
        "public static short[] add(short[] array, int index, short element)",
        "public static int[] add(int[] array, int index, int element)",
        "public static long[] add(long[] array, int index, long element)",
        "public static float[] add(float[] array, int index, float element)",
        "public static double[] add(double[] array, int index, double element)",
        "private static Object add(Object array, int index, Object element, Class<?> clss)",
        "public static <T> T[] remove(T[] array, int index)",
        "public static <T> T[] removeElement(T[] array, Object element)",
        "public static boolean[] remove(boolean[] array, int index)",
        "public static boolean[] removeElement(boolean[] array, boolean element)",
        "public static byte[] remove(byte[] array, int index)",
        "public static byte[] removeElement(byte[] array, byte element)",
        "public static char[] remove(char[] array, int index)",
        "public static char[] removeElement(char[] array, char element)",
        "public static double[] remove(double[] array, int index)",
        "public static double[] removeElement(double[] array, double element)",
        "public static float[] remove(float[] array, int index)",
        "public static float[] removeElement(float[] array, float element)",
        "public static int[] remove(int[] array, int index)",
        "public static int[] removeElement(int[] array, int element)",
        "public static long[] remove(long[] array, int index)",
        "public static long[] removeElement(long[] array, long element)",
        "public static short[] remove(short[] array, int index)",
        "public static short[] removeElement(short[] array, short element)",
        "private static Object remove(Object array, int index)"
      ],
      "fixed_signatures": [
        "public static String toString(Object array)",
        "public static String toString(Object array, String stringIfNull)",
        "public static boolean isEquals(Object array1, Object array2)",
        "public static Map<Object, Object> toMap(Object[] array)",
        "public static <T> T[] clone(T[] array)",
        "public static long[] clone(long[] array)",
        "public static int[] clone(int[] array)",
        "public static short[] clone(short[] array)",
        "public static char[] clone(char[] array)",
        "public static byte[] clone(byte[] array)",
        "public static double[] clone(double[] array)",
        "public static float[] clone(float[] array)",
        "public static boolean[] clone(boolean[] array)",
        "public static <T> T[] subarray(T[] array, int startIndexInclusive, int endIndexExclusive)",
        "public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive)",
        "public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive)",
        "public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive)",
        "public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive)",
        "public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive)",
        "public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive)",
        "public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive)",
        "public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive)",
        "public static boolean isSameLength(Object[] array1, Object[] array2)",
        "public static boolean isSameLength(long[] array1, long[] array2)",
        "public static boolean isSameLength(int[] array1, int[] array2)",
        "public static boolean isSameLength(short[] array1, short[] array2)",
        "public static boolean isSameLength(char[] array1, char[] array2)",
        "public static boolean isSameLength(byte[] array1, byte[] array2)",
        "public static boolean isSameLength(double[] array1, double[] array2)",
        "public static boolean isSameLength(float[] array1, float[] array2)",
        "public static boolean isSameLength(boolean[] array1, boolean[] array2)",
        "public static int getLength(Object array)",
        "public static boolean isSameType(Object array1, Object array2)",
        "public static void reverse(Object[] array)",
        "public static void reverse(long[] array)",
        "public static void reverse(int[] array)",
        "public static void reverse(short[] array)",
        "public static void reverse(char[] array)",
        "public static void reverse(byte[] array)",
        "public static void reverse(double[] array)",
        "public static void reverse(float[] array)",
        "public static void reverse(boolean[] array)",
        "public static int indexOf(Object[] array, Object objectToFind)",
        "public static int indexOf(Object[] array, Object objectToFind, int startIndex)",
        "public static int lastIndexOf(Object[] array, Object objectToFind)",
        "public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex)",
        "public static boolean contains(Object[] array, Object objectToFind)",
        "public static int indexOf(long[] array, long valueToFind)",
        "public static int indexOf(long[] array, long valueToFind, int startIndex)",
        "public static int lastIndexOf(long[] array, long valueToFind)",
        "public static int lastIndexOf(long[] array, long valueToFind, int startIndex)",
        "public static boolean contains(long[] array, long valueToFind)",
        "public static int indexOf(int[] array, int valueToFind)",
        "public static int indexOf(int[] array, int valueToFind, int startIndex)",
        "public static int lastIndexOf(int[] array, int valueToFind)",
        "public static int lastIndexOf(int[] array, int valueToFind, int startIndex)",
        "public static boolean contains(int[] array, int valueToFind)",
        "public static int indexOf(short[] array, short valueToFind)",
        "public static int indexOf(short[] array, short valueToFind, int startIndex)",
        "public static int lastIndexOf(short[] array, short valueToFind)",
        "public static int lastIndexOf(short[] array, short valueToFind, int startIndex)",
        "public static boolean contains(short[] array, short valueToFind)",
        "public static int indexOf(char[] array, char valueToFind)",
        "public static int indexOf(char[] array, char valueToFind, int startIndex)",
        "public static int lastIndexOf(char[] array, char valueToFind)",
        "public static int lastIndexOf(char[] array, char valueToFind, int startIndex)",
        "public static boolean contains(char[] array, char valueToFind)",
        "public static int indexOf(byte[] array, byte valueToFind)",
        "public static int indexOf(byte[] array, byte valueToFind, int startIndex)",
        "public static int lastIndexOf(byte[] array, byte valueToFind)",
        "public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex)",
        "public static boolean contains(byte[] array, byte valueToFind)",
        "public static int indexOf(double[] array, double valueToFind)",
        "public static int indexOf(double[] array, double valueToFind, double tolerance)",
        "public static int indexOf(double[] array, double valueToFind, int startIndex)",
        "public static int indexOf(double[] array, double valueToFind, int startIndex, double tolerance)",
        "public static int lastIndexOf(double[] array, double valueToFind)",
        "public static int lastIndexOf(double[] array, double valueToFind, double tolerance)",
        "public static int lastIndexOf(double[] array, double valueToFind, int startIndex)",
        "public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance)",
        "public static boolean contains(double[] array, double valueToFind)",
        "public static boolean contains(double[] array, double valueToFind, double tolerance)",
        "public static int indexOf(float[] array, float valueToFind)",
        "public static int indexOf(float[] array, float valueToFind, int startIndex)",
        "public static int lastIndexOf(float[] array, float valueToFind)",
        "public static int lastIndexOf(float[] array, float valueToFind, int startIndex)",
        "public static boolean contains(float[] array, float valueToFind)",
        "public static int indexOf(boolean[] array, boolean valueToFind)",
        "public static int indexOf(boolean[] array, boolean valueToFind, int startIndex)",
        "public static int lastIndexOf(boolean[] array, boolean valueToFind)",
        "public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex)",
        "public static boolean contains(boolean[] array, boolean valueToFind)",
        "public static char[] toPrimitive(Character[] array)",
        "public static char[] toPrimitive(Character[] array, char valueForNull)",
        "public static Character[] toObject(char[] array)",
        "public static long[] toPrimitive(Long[] array)",
        "public static long[] toPrimitive(Long[] array, long valueForNull)",
        "public static Long[] toObject(long[] array)",
        "public static int[] toPrimitive(Integer[] array)",
        "public static int[] toPrimitive(Integer[] array, int valueForNull)",
        "public static Integer[] toObject(int[] array)",
        "public static short[] toPrimitive(Short[] array)",
        "public static short[] toPrimitive(Short[] array, short valueForNull)",
        "public static Short[] toObject(short[] array)",
        "public static byte[] toPrimitive(Byte[] array)",
        "public static byte[] toPrimitive(Byte[] array, byte valueForNull)",
        "public static Byte[] toObject(byte[] array)",
        "public static double[] toPrimitive(Double[] array)",
        "public static double[] toPrimitive(Double[] array, double valueForNull)",
        "public static Double[] toObject(double[] array)",
        "public static float[] toPrimitive(Float[] array)",
        "public static float[] toPrimitive(Float[] array, float valueForNull)",
        "public static Float[] toObject(float[] array)",
        "public static boolean[] toPrimitive(Boolean[] array)",
        "public static boolean[] toPrimitive(Boolean[] array, boolean valueForNull)",
        "public static Boolean[] toObject(boolean[] array)",
        "public static <T> boolean isEmpty(T[] array)",
        "public static boolean isEmpty(long[] array)",
        "public static boolean isEmpty(int[] array)",
        "public static boolean isEmpty(short[] array)",
        "public static boolean isEmpty(char[] array)",
        "public static boolean isEmpty(byte[] array)",
        "public static boolean isEmpty(double[] array)",
        "public static boolean isEmpty(float[] array)",
        "public static boolean isEmpty(boolean[] array)",
        "public static <T> T[] addAll(T[] array1, T... array2)",
        "public static boolean[] addAll(boolean[] array1, boolean... array2)",
        "public static char[] addAll(char[] array1, char... array2)",
        "public static byte[] addAll(byte[] array1, byte... array2)",
        "public static short[] addAll(short[] array1, short... array2)",
        "public static int[] addAll(int[] array1, int... array2)",
        "public static long[] addAll(long[] array1, long... array2)",
        "public static float[] addAll(float[] array1, float... array2)",
        "public static double[] addAll(double[] array1, double... array2)",
        "public static <T> T[] add(T[] array, T element)",
        "public static boolean[] add(boolean[] array, boolean element)",
        "public static byte[] add(byte[] array, byte element)",
        "public static char[] add(char[] array, char element)",
        "public static double[] add(double[] array, double element)",
        "public static float[] add(float[] array, float element)",
        "public static int[] add(int[] array, int element)",
        "public static long[] add(long[] array, long element)",
        "public static short[] add(short[] array, short element)",
        "private static Object copyArrayGrow1(Object array, Class<?> newArrayComponentType)",
        "public static <T> T[] add(T[] array, int index, T element)",
        "public static boolean[] add(boolean[] array, int index, boolean element)",
        "public static char[] add(char[] array, int index, char element)",
        "public static byte[] add(byte[] array, int index, byte element)",
        "public static short[] add(short[] array, int index, short element)",
        "public static int[] add(int[] array, int index, int element)",
        "public static long[] add(long[] array, int index, long element)",
        "public static float[] add(float[] array, int index, float element)",
        "public static double[] add(double[] array, int index, double element)",
        "private static Object add(Object array, int index, Object element, Class<?> clss)",
        "public static <T> T[] remove(T[] array, int index)",
        "public static <T> T[] removeElement(T[] array, Object element)",
        "public static boolean[] remove(boolean[] array, int index)",
        "public static boolean[] removeElement(boolean[] array, boolean element)",
        "public static byte[] remove(byte[] array, int index)",
        "public static byte[] removeElement(byte[] array, byte element)",
        "public static char[] remove(char[] array, int index)",
        "public static char[] removeElement(char[] array, char element)",
        "public static double[] remove(double[] array, int index)",
        "public static double[] removeElement(double[] array, double element)",
        "public static float[] remove(float[] array, int index)",
        "public static float[] removeElement(float[] array, float element)",
        "public static int[] remove(int[] array, int index)",
        "public static int[] removeElement(int[] array, int element)",
        "public static long[] remove(long[] array, int index)",
        "public static long[] removeElement(long[] array, long element)",
        "public static short[] remove(short[] array, int index)",
        "public static short[] removeElement(short[] array, short element)",
        "private static Object remove(Object array, int index)"
      ],
      "methods": [
        {
          "buggy_method": "  public static <T> T[] addAll(T[] array1, T... array2) {\n  if (array1 == null) {\n  return clone(array2);\n  } else if (array2 == null) {\n  return clone(array1);\n  }\n  final Class<?> type1 = array1.getClass().getComponentType();\n  T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n  System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n  System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n  \n  return joinedArray;\n  }",
          "fixed_method": "  public static <T> T[] addAll(T[] array1, T... array2) {\n  if (array1 == null) {\n  return clone(array2);\n  } else if (array2 == null) {\n  return clone(array1);\n  }\n  final Class<?> type1 = array1.getClass().getComponentType();\n  T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n  System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n  try {\n  System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n  } catch (ArrayStoreException ase) {\n  \n  final Class<?> type2 = array2.getClass().getComponentType();\n  if (!type1.isAssignableFrom(type2)){\n  throw new IllegalArgumentException(\"Cannot store \"+type2.getName()+\" in an array of \"+type1.getName());\n  }\n  throw ase; \n  }\n  return joinedArray;\n  }",
          "diff": [
            "@@ -2959,8 +2959,16 @@",
            "         final Class<?> type1 = array1.getClass().getComponentType();\n",
            "         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n",
            "         System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n",
            "+        try {\n",
            "             System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n",
            "+        } catch (ArrayStoreException ase) {\n",
            "             // Check if problem is incompatible types\n",
            "+            final Class<?> type2 = array2.getClass().getComponentType();\n",
            "+            if (!type1.isAssignableFrom(type2)){\n",
            "+                throw new IllegalArgumentException(\"Cannot store \"+type2.getName()+\" in an array of \"+type1.getName());\n",
            "+            }\n",
            "+            throw ase; // No, so rethrow original\n",
            "+        }\n",
            "         return joinedArray;\n",
            "     }\n",
            " \n"
          ],
          "changed_lines": 8
        }
      ]
    }
  ]
}
