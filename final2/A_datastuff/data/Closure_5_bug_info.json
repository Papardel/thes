{
  "bug_id": "5",
  "failed_tests": {
    "com.google.javascript.jscomp.InlineObjectLiteralsTest": [
      {
        "methodName": "testNoInlineDeletedProperties",
        "error": "junit.framework.AssertionFailedError:",
        "message": "",
        "fail_line": "    testSameLocal(",
        "test_source": "  public void testNoInlineDeletedProperties() {\n  testSameLocal(\n  \"var foo = {bar:1};\" +\n  \"delete foo.bar;\" +\n  \"return foo.bar;\");\n  }",
        "stack": [
          "CompilerTestCase.test line 903, CompilerTestCase.test line 445, CompilerTestCase.test line 371, CompilerTestCase.test line 340, CompilerTestCase.test line 328, InlineObjectLiteralsTest.testLocal line 362, InlineObjectLiteralsTest.testSameLocal line 367, InlineObjectLiteralsTest.testNoInlineDeletedProperties line 352"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/google/javascript/jscomp/InlineObjectLiterals.java",
      "buggy_full_code": "\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Supplier;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.ReferenceCollectingCallback.Behavior;\nimport com.google.javascript.jscomp.ReferenceCollectingCallback.Reference;\nimport com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\nimport com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMap;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n\n\nclass InlineObjectLiterals implements CompilerPass {\n\n  public static final String VAR_PREFIX = \"JSCompiler_object_inline_\"; private final AbstractCompiler compiler; private final Supplier<String> safeNameIdSupplier; InlineObjectLiterals( AbstractCompiler compiler, Supplier<String> safeNameIdSupplier) {\n    this.compiler = compiler;\n    this.safeNameIdSupplier = safeNameIdSupplier;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\n        compiler, new InliningBehavior());\n    callback.process(externs, root);\n  }\n\n  \n  private class InliningBehavior implements Behavior { private final Set<Var> staleVars = Sets.newHashSet(); @Override public void afterExitScope(NodeTraversal t, ReferenceMap referenceMap) {\n      for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n        Var v = it.next();\n\n        if (isVarInlineForbidden(v)) {\n          continue;\n        }\n\n        ReferenceCollection referenceInfo = referenceMap.getReferences(v);\n\n        if (isInlinableObject(referenceInfo.references)) {\n          \n          \n          staleVars.add(v);\n\n          Reference declaration = referenceInfo.references.get(0);\n          Reference init = referenceInfo.getInitializingReference();\n\n          \n          \n          splitObject(v, declaration, init, referenceInfo);\n        }\n      }\n    }\n\n    \n    private void blacklistVarReferencesInTree(Node root, final Scope scope) {\n      NodeUtil.visitPreOrder(root, new NodeUtil.Visitor() {\n        @Override\n        public void visit(Node node) {\n          if (node.isName()) {\n            staleVars.add(scope.getVar(node.getString()));\n          }\n        }\n      }, NodeUtil.MATCH_NOT_FUNCTION);\n    }\n\n    \n    private boolean isVarInlineForbidden(Var var) {\n      \n      \n      \n      \n      \n      \n      \n\n      \n\n      return var.isGlobal()\n          || var.isExtern()\n          || compiler.getCodingConvention().isExported(var.name)\n          || RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(var.name)\n          || staleVars.contains(var);\n    }\n\n    \n    private boolean isInlinableObject(List<Reference> refs) {\n      boolean ret = false;\n      Set<String> validProperties = Sets.newHashSet();\n      for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n\n        \n        \n        \n        if (parent.isGetProp()) {\n          Preconditions.checkState(parent.getFirstChild() == name);\n          \n          if (gramps.isCall()\n              && gramps.getFirstChild() == parent) {\n            return false;\n          }\n\n          \n          \n\n          \n          \n          \n          \n          \n          \n          \n          \n          String propName = parent.getLastChild().getString();\n          if (!validProperties.contains(propName)) {\n            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n              validProperties.add(propName);\n            } else {\n              return false;\n            }\n          }\n          continue;\n        }\n\n        \n        if (!isVarOrAssignExprLhs(name)) {\n           return false;\n        }\n\n        Node val = ref.getAssignedValue();\n        if (val == null) {\n          \n          continue;\n        }\n\n        \n        if (!val.isObjectLit()) {\n          return false;\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        \n        for (Node child = val.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (child.isGetterDef() ||\n              child.isSetterDef()) {\n            \n            return false;\n          }\n\n          validProperties.add(child.getString());\n\n          Node childVal = child.getFirstChild();\n          \n          \n          \n          for (Reference t : refs) {\n            Node refNode = t.getParent();\n            while (!NodeUtil.isStatementBlock(refNode)) {\n              if (refNode == childVal) {\n                \n                return false;\n              }\n              refNode = refNode.getParent();\n            }\n          }\n        }\n\n\n        \n        \n        \n        ret = true;\n      }\n      return ret;\n    }\n\n    private boolean isVarOrAssignExprLhs(Node n) {\n      Node parent = n.getParent();\n      return parent.isVar() ||\n          (parent.isAssign()\n              && parent.getFirstChild() == n\n              && parent.getParent().isExprResult());\n    }\n\n    \n    private Map<String, String> computeVarList( Var v, ReferenceCollection referenceInfo) {\n      Map<String, String> varmap = Maps.newLinkedHashMap();\n\n      for (Reference ref : referenceInfo.references) {\n        if (ref.isLvalue() || ref.isInitializingDeclaration()) {\n          Node val = ref.getAssignedValue();\n          if (val != null) {\n            Preconditions.checkState(val.isObjectLit());\n            for (Node child = val.getFirstChild(); child != null;\n                 child = child.getNext()) {\n              String varname = child.getString();\n              if (varmap.containsKey(varname)) {\n                continue;\n              }\n\n              String var = VAR_PREFIX + varname + \"_\" +\n                safeNameIdSupplier.get();\n              varmap.put(varname, var);\n            }\n          }\n        } else if (ref.getParent().isVar()) {\n          \n        } else {\n          Node getprop = ref.getParent();\n          Preconditions.checkState(getprop.isGetProp());\n\n          \n          String varname = getprop.getLastChild().getString();\n          if (varmap.containsKey(varname)) {\n            continue;\n          }\n\n          String var = VAR_PREFIX + varname + \"_\" + safeNameIdSupplier.get();\n          varmap.put(varname, var);\n        }\n      }\n\n      return varmap;\n    }\n\n    \n    private void fillInitialValues(Reference init, Map<String, Node> initvals) {\n      Node object = init.getAssignedValue();\n      Preconditions.checkState(object.isObjectLit());\n      for (Node key = object.getFirstChild(); key != null;\n           key = key.getNext()) {\n        initvals.put(key.getString(), key.removeFirstChild());\n      }\n    }\n\n    \n    private void replaceAssignmentExpression(Var v, Reference ref, Map<String, String> varmap) {\n      \n      List<Node> nodes = Lists.newArrayList();\n      Node val = ref.getAssignedValue();\n      blacklistVarReferencesInTree(val, v.scope);\n      Preconditions.checkState(val.isObjectLit());\n      Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n      for (Node key = val.getFirstChild(); key != null;\n           key = key.getNext()) {\n        String var = key.getString();\n        Node value = key.removeFirstChild();\n        \n        nodes.add(\n            IR.assign(\n                IR.name(varmap.get(var)),\n                value));\n        all.remove(var);\n      }\n\n      \n      for (String var : all) {\n        nodes.add(\n            IR.assign(\n                IR.name(varmap.get(var)),\n                NodeUtil.newUndefinedNode(null)));\n      }\n\n      Node replacement;\n      if (nodes.isEmpty()) {\n        replacement = IR.trueNode();\n      } else {\n        \n        \n        nodes.add(IR.trueNode());\n\n        \n        \n        \n        nodes = Lists.reverse(nodes);\n        replacement = new Node(Token.COMMA);\n        Node cur = replacement;\n        int i;\n        for (i = 0; i < nodes.size() - 2; i++) {\n          cur.addChildToFront(nodes.get(i));\n          Node t = new Node(Token.COMMA);\n          cur.addChildToFront(t);\n          cur = t;\n        }\n        cur.addChildToFront(nodes.get(i));\n        cur.addChildToFront(nodes.get(i + 1));\n      }\n\n      Node replace = ref.getParent();\n      replacement.copyInformationFromForTree(replace);\n\n      if (replace.isVar()) {\n        replace.getParent().replaceChild(\n            replace, NodeUtil.newExpr(replacement));\n      } else {\n        replace.getParent().replaceChild(replace, replacement);\n      }\n    }\n\n    \n    private void splitObject(Var v, Reference declaration, Reference init, ReferenceCollection referenceInfo) {\n      \n      \n      Map<String, String> varmap = computeVarList(v, referenceInfo);\n\n      Map<String, Node> initvals = Maps.newHashMap();\n      \n      \n      \n      Node vnode;\n      boolean defined = referenceInfo.isWellDefined() &&\n          init.getParent().isVar();\n      if (defined) {\n        vnode = init.getParent();\n        fillInitialValues(init, initvals);\n      } else {\n        \n        \n        vnode = v.getScope().getRootNode().getLastChild().getFirstChild();\n      }\n\n      for (Map.Entry<String, String> entry : varmap.entrySet()) {\n        Node val = initvals.get(entry.getKey());\n        Node varnode = NodeUtil.newVarNode(entry.getValue(), val);\n        if (val == null) {\n          \n          varnode.copyInformationFromForTree(vnode);\n        } else {\n          blacklistVarReferencesInTree(val, v.scope);\n        }\n        vnode.getParent().addChildBefore(varnode, vnode);\n      }\n\n      if (defined) {\n        vnode.getParent().removeChild(vnode);\n      }\n\n      for (Reference ref : referenceInfo.references) {\n        \n        if (defined && ref == init) continue;\n\n        if (ref.isLvalue()) {\n          \n          \n          replaceAssignmentExpression(v, ref, varmap);\n        } else if (ref.getParent().isVar()) {\n          \n          \n          ref.getGrandparent().removeChild(ref.getParent());\n        } else {\n          \n          Node getprop = ref.getParent();\n          Preconditions.checkState(getprop.isGetProp());\n\n          \n          String var = getprop.getChildAtIndex(1).getString();\n\n          \n          \n          Preconditions.checkState(varmap.containsKey(var));\n\n          \n          Node replacement = IR.name(varmap.get(var));\n          replacement.copyInformationFrom(getprop);\n          ref.getGrandparent().replaceChild(ref.getParent(), replacement);\n        }\n      }\n\n      compiler.reportCodeChange();\n    }\n  }\n}\n",
      "fixed_full_code": "\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Supplier;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.ReferenceCollectingCallback.Behavior;\nimport com.google.javascript.jscomp.ReferenceCollectingCallback.Reference;\nimport com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\nimport com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMap;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n\n\nclass InlineObjectLiterals implements CompilerPass {\n\n  public static final String VAR_PREFIX = \"JSCompiler_object_inline_\"; private final AbstractCompiler compiler; private final Supplier<String> safeNameIdSupplier; InlineObjectLiterals( AbstractCompiler compiler, Supplier<String> safeNameIdSupplier) {\n    this.compiler = compiler;\n    this.safeNameIdSupplier = safeNameIdSupplier;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\n        compiler, new InliningBehavior());\n    callback.process(externs, root);\n  }\n\n  \n  private class InliningBehavior implements Behavior { private final Set<Var> staleVars = Sets.newHashSet(); @Override public void afterExitScope(NodeTraversal t, ReferenceMap referenceMap) {\n      for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n        Var v = it.next();\n\n        if (isVarInlineForbidden(v)) {\n          continue;\n        }\n\n        ReferenceCollection referenceInfo = referenceMap.getReferences(v);\n\n        if (isInlinableObject(referenceInfo.references)) {\n          \n          \n          staleVars.add(v);\n\n          Reference declaration = referenceInfo.references.get(0);\n          Reference init = referenceInfo.getInitializingReference();\n\n          \n          \n          splitObject(v, declaration, init, referenceInfo);\n        }\n      }\n    }\n\n    \n    private void blacklistVarReferencesInTree(Node root, final Scope scope) {\n      NodeUtil.visitPreOrder(root, new NodeUtil.Visitor() {\n        @Override\n        public void visit(Node node) {\n          if (node.isName()) {\n            staleVars.add(scope.getVar(node.getString()));\n          }\n        }\n      }, NodeUtil.MATCH_NOT_FUNCTION);\n    }\n\n    \n    private boolean isVarInlineForbidden(Var var) {\n      \n      \n      \n      \n      \n      \n      \n\n      \n\n      return var.isGlobal()\n          || var.isExtern()\n          || compiler.getCodingConvention().isExported(var.name)\n          || RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(var.name)\n          || staleVars.contains(var);\n    }\n\n    \n    private boolean isInlinableObject(List<Reference> refs) {\n      boolean ret = false;\n      Set<String> validProperties = Sets.newHashSet();\n      for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n\n        \n        \n        \n        if (parent.isGetProp()) {\n          Preconditions.checkState(parent.getFirstChild() == name);\n          \n          if (gramps.isCall()\n              && gramps.getFirstChild() == parent) {\n            return false;\n          }\n\n          \n          \n          if (gramps.isDelProp()) {\n            return false;\n          }\n\n          \n          \n          \n          \n          \n          \n          \n          \n          String propName = parent.getLastChild().getString();\n          if (!validProperties.contains(propName)) {\n            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n              validProperties.add(propName);\n            } else {\n              return false;\n            }\n          }\n          continue;\n        }\n\n        \n        if (!isVarOrAssignExprLhs(name)) {\n           return false;\n        }\n\n        Node val = ref.getAssignedValue();\n        if (val == null) {\n          \n          continue;\n        }\n\n        \n        if (!val.isObjectLit()) {\n          return false;\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        \n        for (Node child = val.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (child.isGetterDef() ||\n              child.isSetterDef()) {\n            \n            return false;\n          }\n\n          validProperties.add(child.getString());\n\n          Node childVal = child.getFirstChild();\n          \n          \n          \n          for (Reference t : refs) {\n            Node refNode = t.getParent();\n            while (!NodeUtil.isStatementBlock(refNode)) {\n              if (refNode == childVal) {\n                \n                return false;\n              }\n              refNode = refNode.getParent();\n            }\n          }\n        }\n\n\n        \n        \n        \n        ret = true;\n      }\n      return ret;\n    }\n\n    private boolean isVarOrAssignExprLhs(Node n) {\n      Node parent = n.getParent();\n      return parent.isVar() ||\n          (parent.isAssign()\n              && parent.getFirstChild() == n\n              && parent.getParent().isExprResult());\n    }\n\n    \n    private Map<String, String> computeVarList( Var v, ReferenceCollection referenceInfo) {\n      Map<String, String> varmap = Maps.newLinkedHashMap();\n\n      for (Reference ref : referenceInfo.references) {\n        if (ref.isLvalue() || ref.isInitializingDeclaration()) {\n          Node val = ref.getAssignedValue();\n          if (val != null) {\n            Preconditions.checkState(val.isObjectLit());\n            for (Node child = val.getFirstChild(); child != null;\n                 child = child.getNext()) {\n              String varname = child.getString();\n              if (varmap.containsKey(varname)) {\n                continue;\n              }\n\n              String var = VAR_PREFIX + varname + \"_\" +\n                safeNameIdSupplier.get();\n              varmap.put(varname, var);\n            }\n          }\n        } else if (ref.getParent().isVar()) {\n          \n        } else {\n          Node getprop = ref.getParent();\n          Preconditions.checkState(getprop.isGetProp());\n\n          \n          String varname = getprop.getLastChild().getString();\n          if (varmap.containsKey(varname)) {\n            continue;\n          }\n\n          String var = VAR_PREFIX + varname + \"_\" + safeNameIdSupplier.get();\n          varmap.put(varname, var);\n        }\n      }\n\n      return varmap;\n    }\n\n    \n    private void fillInitialValues(Reference init, Map<String, Node> initvals) {\n      Node object = init.getAssignedValue();\n      Preconditions.checkState(object.isObjectLit());\n      for (Node key = object.getFirstChild(); key != null;\n           key = key.getNext()) {\n        initvals.put(key.getString(), key.removeFirstChild());\n      }\n    }\n\n    \n    private void replaceAssignmentExpression(Var v, Reference ref, Map<String, String> varmap) {\n      \n      List<Node> nodes = Lists.newArrayList();\n      Node val = ref.getAssignedValue();\n      blacklistVarReferencesInTree(val, v.scope);\n      Preconditions.checkState(val.isObjectLit());\n      Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n      for (Node key = val.getFirstChild(); key != null;\n           key = key.getNext()) {\n        String var = key.getString();\n        Node value = key.removeFirstChild();\n        \n        nodes.add(\n            IR.assign(\n                IR.name(varmap.get(var)),\n                value));\n        all.remove(var);\n      }\n\n      \n      for (String var : all) {\n        nodes.add(\n            IR.assign(\n                IR.name(varmap.get(var)),\n                NodeUtil.newUndefinedNode(null)));\n      }\n\n      Node replacement;\n      if (nodes.isEmpty()) {\n        replacement = IR.trueNode();\n      } else {\n        \n        \n        nodes.add(IR.trueNode());\n\n        \n        \n        \n        nodes = Lists.reverse(nodes);\n        replacement = new Node(Token.COMMA);\n        Node cur = replacement;\n        int i;\n        for (i = 0; i < nodes.size() - 2; i++) {\n          cur.addChildToFront(nodes.get(i));\n          Node t = new Node(Token.COMMA);\n          cur.addChildToFront(t);\n          cur = t;\n        }\n        cur.addChildToFront(nodes.get(i));\n        cur.addChildToFront(nodes.get(i + 1));\n      }\n\n      Node replace = ref.getParent();\n      replacement.copyInformationFromForTree(replace);\n\n      if (replace.isVar()) {\n        replace.getParent().replaceChild(\n            replace, NodeUtil.newExpr(replacement));\n      } else {\n        replace.getParent().replaceChild(replace, replacement);\n      }\n    }\n\n    \n    private void splitObject(Var v, Reference declaration, Reference init, ReferenceCollection referenceInfo) {\n      \n      \n      Map<String, String> varmap = computeVarList(v, referenceInfo);\n\n      Map<String, Node> initvals = Maps.newHashMap();\n      \n      \n      \n      Node vnode;\n      boolean defined = referenceInfo.isWellDefined() &&\n          init.getParent().isVar();\n      if (defined) {\n        vnode = init.getParent();\n        fillInitialValues(init, initvals);\n      } else {\n        \n        \n        vnode = v.getScope().getRootNode().getLastChild().getFirstChild();\n      }\n\n      for (Map.Entry<String, String> entry : varmap.entrySet()) {\n        Node val = initvals.get(entry.getKey());\n        Node varnode = NodeUtil.newVarNode(entry.getValue(), val);\n        if (val == null) {\n          \n          varnode.copyInformationFromForTree(vnode);\n        } else {\n          blacklistVarReferencesInTree(val, v.scope);\n        }\n        vnode.getParent().addChildBefore(varnode, vnode);\n      }\n\n      if (defined) {\n        vnode.getParent().removeChild(vnode);\n      }\n\n      for (Reference ref : referenceInfo.references) {\n        \n        if (defined && ref == init) continue;\n\n        if (ref.isLvalue()) {\n          \n          \n          replaceAssignmentExpression(v, ref, varmap);\n        } else if (ref.getParent().isVar()) {\n          \n          \n          ref.getGrandparent().removeChild(ref.getParent());\n        } else {\n          \n          Node getprop = ref.getParent();\n          Preconditions.checkState(getprop.isGetProp());\n\n          \n          String var = getprop.getChildAtIndex(1).getString();\n\n          \n          \n          Preconditions.checkState(varmap.containsKey(var));\n\n          \n          Node replacement = IR.name(varmap.get(var));\n          replacement.copyInformationFrom(getprop);\n          ref.getGrandparent().replaceChild(ref.getParent(), replacement);\n        }\n      }\n\n      compiler.reportCodeChange();\n    }\n  }\n}\n",
      "buggy_signatures": [
        "public void process(Node externs, Node root)",
        "private void blacklistVarReferencesInTree(Node root, final Scope scope)",
        "public void visit(Node node)",
        "private boolean isVarInlineForbidden(Var var)",
        "private boolean isInlinableObject(List<Reference> refs)",
        "private boolean isVarOrAssignExprLhs(Node n)",
        "private Map<String, String> computeVarList( Var v, ReferenceCollection referenceInfo)",
        "private void fillInitialValues(Reference init, Map<String, Node> initvals)",
        "private void replaceAssignmentExpression(Var v, Reference ref, Map<String, String> varmap)",
        "private void splitObject(Var v, Reference declaration, Reference init, ReferenceCollection referenceInfo)"
      ],
      "fixed_signatures": [
        "public void process(Node externs, Node root)",
        "private void blacklistVarReferencesInTree(Node root, final Scope scope)",
        "public void visit(Node node)",
        "private boolean isVarInlineForbidden(Var var)",
        "private boolean isInlinableObject(List<Reference> refs)",
        "private boolean isVarOrAssignExprLhs(Node n)",
        "private Map<String, String> computeVarList( Var v, ReferenceCollection referenceInfo)",
        "private void fillInitialValues(Reference init, Map<String, Node> initvals)",
        "private void replaceAssignmentExpression(Var v, Reference ref, Map<String, String> varmap)",
        "private void splitObject(Var v, Reference declaration, Reference init, ReferenceCollection referenceInfo)"
      ],
      "methods": [
        {
          "buggy_method": "  private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n  Node name = ref.getNode();\n  Node parent = ref.getParent();\n  Node gramps = ref.getGrandparent();\n\n  \n  \n  \n  if (parent.isGetProp()) {\n  Preconditions.checkState(parent.getFirstChild() == name);\n  \n  if (gramps.isCall()\n  && gramps.getFirstChild() == parent) {\n  return false;\n  }\n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  String propName = parent.getLastChild().getString();\n  if (!validProperties.contains(propName)) {\n  if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n  validProperties.add(propName);\n  } else {\n  return false;\n  }\n  }\n  continue;\n  }\n\n  \n  if (!isVarOrAssignExprLhs(name)) {\n  return false;\n  }\n\n  Node val = ref.getAssignedValue();\n  if (val == null) {\n  \n  continue;\n  }\n\n  \n  if (!val.isObjectLit()) {\n  return false;\n  }\n\n  \n  \n  \n  \n  \n  \n  \n  \n  for (Node child = val.getFirstChild(); child != null;\n  child = child.getNext()) {\n  if (child.isGetterDef() ||\n  child.isSetterDef()) {\n  \n  return false;\n  }\n\n  validProperties.add(child.getString());\n\n  Node childVal = child.getFirstChild();\n  \n  \n  \n  for (Reference t : refs) {\n  Node refNode = t.getParent();\n  while (!NodeUtil.isStatementBlock(refNode)) {\n  if (refNode == childVal) {\n  \n  return false;\n  }\n  refNode = refNode.getParent();\n  }\n  }\n  }\n\n\n  \n  \n  \n  ret = true;\n  }\n  return ret;\n  }",
          "fixed_method": "  private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n  Node name = ref.getNode();\n  Node parent = ref.getParent();\n  Node gramps = ref.getGrandparent();\n\n  \n  \n  \n  if (parent.isGetProp()) {\n  Preconditions.checkState(parent.getFirstChild() == name);\n  \n  if (gramps.isCall()\n  && gramps.getFirstChild() == parent) {\n  return false;\n  }\n\n  \n  \n  if (gramps.isDelProp()) {\n  return false;\n  }\n\n  \n  \n  \n  \n  \n  \n  \n  \n  String propName = parent.getLastChild().getString();\n  if (!validProperties.contains(propName)) {\n  if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n  validProperties.add(propName);\n  } else {\n  return false;\n  }\n  }\n  continue;\n  }\n\n  \n  if (!isVarOrAssignExprLhs(name)) {\n  return false;\n  }\n\n  Node val = ref.getAssignedValue();\n  if (val == null) {\n  \n  continue;\n  }\n\n  \n  if (!val.isObjectLit()) {\n  return false;\n  }\n\n  \n  \n  \n  \n  \n  \n  \n  \n  for (Node child = val.getFirstChild(); child != null;\n  child = child.getNext()) {\n  if (child.isGetterDef() ||\n  child.isSetterDef()) {\n  \n  return false;\n  }\n\n  validProperties.add(child.getString());\n\n  Node childVal = child.getFirstChild();\n  \n  \n  \n  for (Reference t : refs) {\n  Node refNode = t.getParent();\n  while (!NodeUtil.isStatementBlock(refNode)) {\n  if (refNode == childVal) {\n  \n  return false;\n  }\n  refNode = refNode.getParent();\n  }\n  }\n  }\n\n\n  \n  \n  \n  ret = true;\n  }\n  return ret;\n  }",
          "diff": [
            "@@ -173,6 +173,9 @@",
            " \n",
            "           // Deleting a property has different semantics from deleting\n",
            "           // a variable, so deleted properties should not be inlined.\n",
            "+          if (gramps.isDelProp()) {\n",
            "+            return false;\n",
            "+          }\n",
            " \n",
            "           // NOTE(nicksantos): This pass's object-splitting algorithm has\n",
            "           // a blind spot. It assumes that if a property isn't defined on an\n"
          ],
          "changed_lines": 3
        }
      ]
    }
  ]
}
