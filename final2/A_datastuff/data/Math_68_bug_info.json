{
  "bug_id": "68",
  "failed_tests": {
    "org.apache.commons.math.optimization.general.MinpackTest": [
      {
        "methodName": "testMinpackJennrichSampson",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<0.2578330049> but was:<0.25781992663680675>",
        "fail_line": "    minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },",
        "test_source": "  public void testMinpackJennrichSampson() {\n  minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },\n  64.5856498144943, 11.1517793413499,\n  new double[] {\n  0.2578330049, 0.257829976764542\n  }), false);\n  }",
        "stack": [
          "MinpackTest$MinpackFunction.checkTheoreticalMinParams line 575, MinpackTest.minpackTest line 503, MinpackTest.testMinpackJennrichSampson line 325"
        ]
      },
      {
        "methodName": "testMinpackFreudensteinRoth",
        "error": "junit.framework.AssertionFailedError",
        "message": "expected:<11.4121122022341> but was:<11.41300466147456>",
        "fail_line": "    minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 },",
        "test_source": "  public void testMinpackFreudensteinRoth() {\n  minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 },\n  20.0124960961895, 6.99887517584575,\n  new double[] {\n  11.4124844654993,\n  -0.896827913731509\n  }), false);\n  minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 },\n  12432.833948863, 6.9988751744895,\n  new double[] {\n  11.4121122022341,\n  -0.8968550851268697\n  }), false);\n  minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 },\n  11426454.595762, 6.99887517242903,\n  new double[] {\n  11.412069435091231,\n  -0.8968582807605691\n  }), false);\n  }",
        "stack": [
          "MinpackTest$MinpackFunction.checkTheoreticalMinParams line 575, MinpackTest.minpackTest line 503, MinpackTest.testMinpackFreudensteinRoth line 152"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
      "buggy_full_code": "\npackage org.apache.commons.math.optimization.general;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.math.FunctionEvaluationException;\nimport org.apache.commons.math.optimization.OptimizationException;\nimport org.apache.commons.math.optimization.VectorialPointValuePair;\n\n\n\npublic class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer { private int solvedCols; private double[] diagR; private double[] jacNorm; private double[] beta; private int[] permutation; private int rank; private double lmPar; private double[] lmDir; private double initialStepBoundFactor; private double costRelativeTolerance; private double parRelativeTolerance; private double orthoTolerance; public LevenbergMarquardtOptimizer() {\n\n        \n        setMaxIterations(1000);\n\n        \n        setInitialStepBoundFactor(100.0);\n        setCostRelativeTolerance(1.0e-10);\n        setParRelativeTolerance(1.0e-10);\n        setOrthoTolerance(1.0e-10);\n\n    }\n\n    \n    public void setInitialStepBoundFactor(double initialStepBoundFactor) {\n        this.initialStepBoundFactor = initialStepBoundFactor;\n    }\n\n    \n    public void setCostRelativeTolerance(double costRelativeTolerance) {\n        this.costRelativeTolerance = costRelativeTolerance;\n    }\n\n    \n    public void setParRelativeTolerance(double parRelativeTolerance) {\n        this.parRelativeTolerance = parRelativeTolerance;\n    }\n\n    \n    public void setOrthoTolerance(double orthoTolerance) {\n        this.orthoTolerance = orthoTolerance;\n    }\n\n    \n    @Override\n    protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        \n        solvedCols  = Math.min(rows, cols);\n        diagR       = new double[cols];\n        jacNorm     = new double[cols];\n        beta        = new double[cols];\n        permutation = new int[cols];\n        lmDir       = new double[cols];\n\n        \n        double   delta   = 0;\n        double   xNorm   = 0;\n        double[] diag    = new double[cols];\n        double[] oldX    = new double[cols];\n        double[] oldRes  = new double[rows];\n        double[] work1   = new double[cols];\n        double[] work2   = new double[cols];\n        double[] work3   = new double[cols];\n\n        \n        updateResidualsAndCost();\n\n        \n        lmPar = 0;\n        boolean firstIteration = true;\n        while (true) {\n\n            incrementIterationsCounter();\n\n            \n            updateJacobian();\n            qrDecomposition();\n\n            \n            qTy(residuals);\n\n            \n            \n            for (int k = 0; k < solvedCols; ++k) {\n                int pk = permutation[k];\n                jacobian[k][pk] = diagR[pk];\n            }\n\n            if (firstIteration) {\n\n                \n                \n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double dk = jacNorm[k];\n                    if (dk == 0) {\n                        dk = 1.0;\n                    }\n                    double xk = dk * point[k];\n                    xNorm  += xk * xk;\n                    diag[k] = dk;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                \n                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n            }\n\n            \n            double maxCosine = 0;\n            if (cost != 0) {\n                for (int j = 0; j < solvedCols; ++j) {\n                    int    pj = permutation[j];\n                    double s  = jacNorm[pj];\n                    if (s != 0) {\n                        double sum = 0;\n                        for (int i = 0; i <= j; ++i) {\n                            sum += jacobian[i][pj] * residuals[i];\n                        }\n                        maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                    }\n                }\n            }\n            if (maxCosine <= orthoTolerance) {\n                \n                return new VectorialPointValuePair(point, objective);\n            }\n\n            \n            for (int j = 0; j < cols; ++j) {\n                diag[j] = Math.max(diag[j], jacNorm[j]);\n            }\n\n            \n            for (double ratio = 0; ratio < 1.0e-4;) {\n\n                \n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    oldX[pj] = point[pj];\n                }\n                double previousCost = cost;\n                double[] tmpVec = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n\n                \n                determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n                \n                double lmNorm = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    lmDir[pj] = -lmDir[pj];\n                    point[pj] = oldX[pj] + lmDir[pj];\n                    double s = diag[pj] * lmDir[pj];\n                    lmNorm  += s * s;\n                }\n                lmNorm = Math.sqrt(lmNorm);\n\n                \n                if (firstIteration) {\n                    delta = Math.min(delta, lmNorm);\n                }\n\n                \n                updateResidualsAndCost();\n\n                \n                double actRed = -1.0;\n                if (0.1 * cost < previousCost) {\n                    double r = cost / previousCost;\n                    actRed = 1.0 - r * r;\n                }\n\n                \n                \n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    double dirJ = lmDir[pj];\n                    work1[j] = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        work1[i] += jacobian[i][pj] * dirJ;\n                    }\n                }\n                double coeff1 = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    coeff1 += work1[j] * work1[j];\n                }\n                double pc2 = previousCost * previousCost;\n                coeff1 = coeff1 / pc2;\n                double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n                double preRed = coeff1 + 2 * coeff2;\n                double dirDer = -(coeff1 + coeff2);\n\n                \n                ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n                \n                if (ratio <= 0.25) {\n                    double tmp =\n                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                        if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                            tmp = 0.1;\n                        }\n                        delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                        lmPar /= tmp;\n                } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                    delta = 2 * lmNorm;\n                    lmPar *= 0.5;\n                }\n\n                \n                if (ratio >= 1.0e-4) {\n                    \n                    firstIteration = false;\n                    xNorm = 0;\n                    for (int k = 0; k < cols; ++k) {\n                        double xK = diag[k] * point[k];\n                        xNorm    += xK * xK;\n                    }\n                    xNorm = Math.sqrt(xNorm);\n                } else {\n                    \n                    cost = previousCost;\n                    for (int j = 0; j < solvedCols; ++j) {\n                        int pj = permutation[j];\n                        point[pj] = oldX[pj];\n                    }\n                    tmpVec    = residuals;\n                    residuals = oldRes;\n                    oldRes    = tmpVec;\n                }\n\n                \n                    \n                    \n                    if (((Math.abs(actRed) <= costRelativeTolerance) &&\n                         (preRed <= costRelativeTolerance) &&\n                         (ratio <= 2.0)) ||\n                        (delta <= parRelativeTolerance * xNorm)) {\n                        return new VectorialPointValuePair(point, objective);\n                    }\n\n                \n                \n                if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                    throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" +\n                            \" no further reduction in the\" +\n                            \" sum of squares is possible\",\n                            costRelativeTolerance);\n                } else if (delta <= 2.2204e-16 * xNorm) {\n                    throw new OptimizationException(\"parameters relative tolerance is too small\" +\n                            \" ({0}), no further improvement in\" +\n                            \" the approximate solution is possible\",\n                            parRelativeTolerance);\n                } else if (maxCosine <= 2.2204e-16)  {\n                    throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" +\n                            \" solution is orthogonal to the jacobian\",\n                            orthoTolerance);\n                }\n\n            }\n\n        }\n\n    }\n\n    \n    private void determineLMParameter(double[] qy, double delta, double[] diag, double[] work1, double[] work2, double[] work3) {\n\n        \n        \n        for (int j = 0; j < rank; ++j) {\n            lmDir[permutation[j]] = qy[j];\n        }\n        for (int j = rank; j < cols; ++j) {\n            lmDir[permutation[j]] = 0;\n        }\n        for (int k = rank - 1; k >= 0; --k) {\n            int pk = permutation[k];\n            double ypk = lmDir[pk] / diagR[pk];\n            for (int i = 0; i < k; ++i) {\n                lmDir[permutation[i]] -= ypk * jacobian[i][pk];\n            }\n            lmDir[pk] = ypk;\n        }\n\n        \n        \n        double dxNorm = 0;\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            double s = diag[pj] * lmDir[pj];\n            work1[pj] = s;\n            dxNorm += s * s;\n        }\n        dxNorm = Math.sqrt(dxNorm);\n        double fp = dxNorm - delta;\n        if (fp <= 0.1 * delta) {\n            lmPar = 0;\n            return;\n        }\n\n        \n        \n        \n        double sum2;\n        double parl = 0;\n        if (rank == solvedCols) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] *= diag[pj] / dxNorm;\n            }\n            sum2 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double sum = 0;\n                for (int i = 0; i < j; ++i) {\n                    sum += jacobian[i][pj] * work1[permutation[i]];\n                }\n                double s = (work1[pj] - sum) / diagR[pj];\n                work1[pj] = s;\n                sum2 += s * s;\n            }\n            parl = fp / (delta * sum2);\n        }\n\n        \n        sum2 = 0;\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            double sum = 0;\n            for (int i = 0; i <= j; ++i) {\n                sum += jacobian[i][pj] * qy[i];\n            }\n            sum /= diag[pj];\n            sum2 += sum * sum;\n        }\n        double gNorm = Math.sqrt(sum2);\n        double paru = gNorm / delta;\n        if (paru == 0) {\n            \n            paru = 2.2251e-308 / Math.min(delta, 0.1);\n        }\n\n        \n        \n        lmPar = Math.min(paru, Math.max(lmPar, parl));\n        if (lmPar == 0) {\n            lmPar = gNorm / dxNorm;\n        }\n\n        for (int countdown = 10; countdown >= 0; --countdown) {\n\n            \n            if (lmPar == 0) {\n                lmPar = Math.max(2.2251e-308, 0.001 * paru);\n            }\n            double sPar = Math.sqrt(lmPar);\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] = sPar * diag[pj];\n            }\n            determineLMDirection(qy, work1, work2, work3);\n\n            dxNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double s = diag[pj] * lmDir[pj];\n                work3[pj] = s;\n                dxNorm += s * s;\n            }\n            dxNorm = Math.sqrt(dxNorm);\n            double previousFP = fp;\n            fp = dxNorm - delta;\n\n            \n            \n            if ((Math.abs(fp) <= 0.1 * delta) ||\n                    ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {\n                return;\n            }\n\n            \n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] = work3[pj] * diag[pj] / dxNorm;\n            }\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] /= work2[j];\n                double tmp = work1[pj];\n                for (int i = j + 1; i < solvedCols; ++i) {\n                    work1[permutation[i]] -= jacobian[i][pj] * tmp;\n                }\n            }\n            sum2 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                double s = work1[permutation[j]];\n                sum2 += s * s;\n            }\n            double correction = fp / (delta * sum2);\n\n            \n            if (fp > 0) {\n                parl = Math.max(parl, lmPar);\n            } else if (fp < 0) {\n                paru = Math.min(paru, lmPar);\n            }\n\n            \n            lmPar = Math.max(parl, lmPar + correction);\n\n        }\n    }\n\n    \n    private void determineLMDirection(double[] qy, double[] diag, double[] lmDiag, double[] work) {\n\n        \n        \n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            for (int i = j + 1; i < solvedCols; ++i) {\n                jacobian[i][pj] = jacobian[j][permutation[i]];\n            }\n            lmDir[j] = diagR[pj];\n            work[j]  = qy[j];\n        }\n\n        \n        for (int j = 0; j < solvedCols; ++j) {\n\n            \n            \n            int pj = permutation[j];\n            double dpj = diag[pj];\n            if (dpj != 0) {\n                Arrays.fill(lmDiag, j + 1, lmDiag.length, 0);\n            }\n            lmDiag[j] = dpj;\n\n            \n            \n            \n            double qtbpj = 0;\n            for (int k = j; k < solvedCols; ++k) {\n                int pk = permutation[k];\n\n                \n                \n                if (lmDiag[k] != 0) {\n\n                    final double sin;\n                    final double cos;\n                    double rkk = jacobian[k][pk];\n                    if (Math.abs(rkk) < Math.abs(lmDiag[k])) {\n                        final double cotan = rkk / lmDiag[k];\n                        sin   = 1.0 / Math.sqrt(1.0 + cotan * cotan);\n                        cos   = sin * cotan;\n                    } else {\n                        final double tan = lmDiag[k] / rkk;\n                        cos = 1.0 / Math.sqrt(1.0 + tan * tan);\n                        sin = cos * tan;\n                    }\n\n                    \n                    \n                    jacobian[k][pk] = cos * rkk + sin * lmDiag[k];\n                    final double temp = cos * work[k] + sin * qtbpj;\n                    qtbpj = -sin * work[k] + cos * qtbpj;\n                    work[k] = temp;\n\n                    \n                    for (int i = k + 1; i < solvedCols; ++i) {\n                        double rik = jacobian[i][pk];\n                        final double temp2 = cos * rik + sin * lmDiag[i];\n                        lmDiag[i] = -sin * rik + cos * lmDiag[i];\n                        jacobian[i][pk] = temp2;\n                    }\n\n                }\n            }\n\n            \n            \n            lmDiag[j] = jacobian[j][permutation[j]];\n            jacobian[j][permutation[j]] = lmDir[j];\n\n        }\n\n        \n        \n        int nSing = solvedCols;\n        for (int j = 0; j < solvedCols; ++j) {\n            if ((lmDiag[j] == 0) && (nSing == solvedCols)) {\n                nSing = j;\n            }\n            if (nSing < solvedCols) {\n                work[j] = 0;\n            }\n        }\n        if (nSing > 0) {\n            for (int j = nSing - 1; j >= 0; --j) {\n                int pj = permutation[j];\n                double sum = 0;\n                for (int i = j + 1; i < nSing; ++i) {\n                    sum += jacobian[i][pj] * work[i];\n                }\n                work[j] = (work[j] - sum) / lmDiag[j];\n            }\n        }\n\n        \n        for (int j = 0; j < lmDir.length; ++j) {\n            lmDir[permutation[j]] = work[j];\n        }\n\n    }\n\n    \n    private void qrDecomposition() throws OptimizationException {\n\n        \n        for (int k = 0; k < cols; ++k) {\n            permutation[k] = k;\n            double norm2 = 0;\n            for (int i = 0; i < jacobian.length; ++i) {\n                double akk = jacobian[i][k];\n                norm2 += akk * akk;\n            }\n            jacNorm[k] = Math.sqrt(norm2);\n        }\n\n        \n        for (int k = 0; k < cols; ++k) {\n\n            \n            int nextColumn = -1;\n            double ak2 = Double.NEGATIVE_INFINITY;\n            for (int i = k; i < cols; ++i) {\n                double norm2 = 0;\n                for (int j = k; j < jacobian.length; ++j) {\n                    double aki = jacobian[j][permutation[i]];\n                    norm2 += aki * aki;\n                }\n                if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                    throw new OptimizationException(\n                            \"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\",\n                            rows, cols);\n                }\n                if (norm2 > ak2) {\n                    nextColumn = i;\n                    ak2        = norm2;\n                }\n            }\n            if (ak2 == 0) {\n                rank = k;\n                return;\n            }\n            int pk                  = permutation[nextColumn];\n            permutation[nextColumn] = permutation[k];\n            permutation[k]          = pk;\n\n            \n            double akk   = jacobian[k][pk];\n            double alpha = (akk > 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n            double betak = 1.0 / (ak2 - akk * alpha);\n            beta[pk]     = betak;\n\n            \n            diagR[pk]        = alpha;\n            jacobian[k][pk] -= alpha;\n\n            \n            for (int dk = cols - 1 - k; dk > 0; --dk) {\n                double gamma = 0;\n                for (int j = k; j < jacobian.length; ++j) {\n                    gamma += jacobian[j][pk] * jacobian[j][permutation[k + dk]];\n                }\n                gamma *= betak;\n                for (int j = k; j < jacobian.length; ++j) {\n                    jacobian[j][permutation[k + dk]] -= gamma * jacobian[j][pk];\n                }\n            }\n\n        }\n\n        rank = solvedCols;\n\n    }\n\n    \n    private void qTy(double[] y) {\n        for (int k = 0; k < cols; ++k) {\n            int pk = permutation[k];\n            double gamma = 0;\n            for (int i = k; i < rows; ++i) {\n                gamma += jacobian[i][pk] * y[i];\n            }\n            gamma *= beta[pk];\n            for (int i = k; i < rows; ++i) {\n                y[i] -= gamma * jacobian[i][pk];\n            }\n        }\n    }\n\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.math.optimization.general;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.math.FunctionEvaluationException;\nimport org.apache.commons.math.optimization.OptimizationException;\nimport org.apache.commons.math.optimization.VectorialPointValuePair;\n\n\n\npublic class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer { private int solvedCols; private double[] diagR; private double[] jacNorm; private double[] beta; private int[] permutation; private int rank; private double lmPar; private double[] lmDir; private double initialStepBoundFactor; private double costRelativeTolerance; private double parRelativeTolerance; private double orthoTolerance; public LevenbergMarquardtOptimizer() {\n\n        \n        setMaxIterations(1000);\n\n        \n        setConvergenceChecker(null);\n        setInitialStepBoundFactor(100.0);\n        setCostRelativeTolerance(1.0e-10);\n        setParRelativeTolerance(1.0e-10);\n        setOrthoTolerance(1.0e-10);\n\n    }\n\n    \n    public void setInitialStepBoundFactor(double initialStepBoundFactor) {\n        this.initialStepBoundFactor = initialStepBoundFactor;\n    }\n\n    \n    public void setCostRelativeTolerance(double costRelativeTolerance) {\n        this.costRelativeTolerance = costRelativeTolerance;\n    }\n\n    \n    public void setParRelativeTolerance(double parRelativeTolerance) {\n        this.parRelativeTolerance = parRelativeTolerance;\n    }\n\n    \n    public void setOrthoTolerance(double orthoTolerance) {\n        this.orthoTolerance = orthoTolerance;\n    }\n\n    \n    @Override\n    protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        \n        solvedCols  = Math.min(rows, cols);\n        diagR       = new double[cols];\n        jacNorm     = new double[cols];\n        beta        = new double[cols];\n        permutation = new int[cols];\n        lmDir       = new double[cols];\n\n        \n        double   delta   = 0;\n        double   xNorm   = 0;\n        double[] diag    = new double[cols];\n        double[] oldX    = new double[cols];\n        double[] oldRes  = new double[rows];\n        double[] work1   = new double[cols];\n        double[] work2   = new double[cols];\n        double[] work3   = new double[cols];\n\n        \n        updateResidualsAndCost();\n\n        \n        lmPar = 0;\n        boolean firstIteration = true;\n        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n        while (true) {\n\n            incrementIterationsCounter();\n\n            \n            VectorialPointValuePair previous = current;\n            updateJacobian();\n            qrDecomposition();\n\n            \n            qTy(residuals);\n\n            \n            \n            for (int k = 0; k < solvedCols; ++k) {\n                int pk = permutation[k];\n                jacobian[k][pk] = diagR[pk];\n            }\n\n            if (firstIteration) {\n\n                \n                \n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double dk = jacNorm[k];\n                    if (dk == 0) {\n                        dk = 1.0;\n                    }\n                    double xk = dk * point[k];\n                    xNorm  += xk * xk;\n                    diag[k] = dk;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                \n                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n            }\n\n            \n            double maxCosine = 0;\n            if (cost != 0) {\n                for (int j = 0; j < solvedCols; ++j) {\n                    int    pj = permutation[j];\n                    double s  = jacNorm[pj];\n                    if (s != 0) {\n                        double sum = 0;\n                        for (int i = 0; i <= j; ++i) {\n                            sum += jacobian[i][pj] * residuals[i];\n                        }\n                        maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                    }\n                }\n            }\n            if (maxCosine <= orthoTolerance) {\n                \n                return current;\n            }\n\n            \n            for (int j = 0; j < cols; ++j) {\n                diag[j] = Math.max(diag[j], jacNorm[j]);\n            }\n\n            \n            for (double ratio = 0; ratio < 1.0e-4;) {\n\n                \n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    oldX[pj] = point[pj];\n                }\n                double previousCost = cost;\n                double[] tmpVec = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n\n                \n                determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n                \n                double lmNorm = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    lmDir[pj] = -lmDir[pj];\n                    point[pj] = oldX[pj] + lmDir[pj];\n                    double s = diag[pj] * lmDir[pj];\n                    lmNorm  += s * s;\n                }\n                lmNorm = Math.sqrt(lmNorm);\n\n                \n                if (firstIteration) {\n                    delta = Math.min(delta, lmNorm);\n                }\n\n                \n                updateResidualsAndCost();\n                current = new VectorialPointValuePair(point, objective);\n\n                \n                double actRed = -1.0;\n                if (0.1 * cost < previousCost) {\n                    double r = cost / previousCost;\n                    actRed = 1.0 - r * r;\n                }\n\n                \n                \n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    double dirJ = lmDir[pj];\n                    work1[j] = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        work1[i] += jacobian[i][pj] * dirJ;\n                    }\n                }\n                double coeff1 = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    coeff1 += work1[j] * work1[j];\n                }\n                double pc2 = previousCost * previousCost;\n                coeff1 = coeff1 / pc2;\n                double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n                double preRed = coeff1 + 2 * coeff2;\n                double dirDer = -(coeff1 + coeff2);\n\n                \n                ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n                \n                if (ratio <= 0.25) {\n                    double tmp =\n                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                        if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                            tmp = 0.1;\n                        }\n                        delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                        lmPar /= tmp;\n                } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                    delta = 2 * lmNorm;\n                    lmPar *= 0.5;\n                }\n\n                \n                if (ratio >= 1.0e-4) {\n                    \n                    firstIteration = false;\n                    xNorm = 0;\n                    for (int k = 0; k < cols; ++k) {\n                        double xK = diag[k] * point[k];\n                        xNorm    += xK * xK;\n                    }\n                    xNorm = Math.sqrt(xNorm);\n                } else {\n                    \n                    cost = previousCost;\n                    for (int j = 0; j < solvedCols; ++j) {\n                        int pj = permutation[j];\n                        point[pj] = oldX[pj];\n                    }\n                    tmpVec    = residuals;\n                    residuals = oldRes;\n                    oldRes    = tmpVec;\n                }\n\n                \n                if (checker != null) {\n                    \n                    if (checker.converged(getIterations(), previous, current)) {\n                        return current;                        \n                    }\n                } else {\n                    \n                    if (((Math.abs(actRed) <= costRelativeTolerance) &&\n                         (preRed <= costRelativeTolerance) &&\n                         (ratio <= 2.0)) ||\n                        (delta <= parRelativeTolerance * xNorm)) {\n                        return current;\n                    }\n                }\n\n                \n                \n                if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                    throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" +\n                            \" no further reduction in the\" +\n                            \" sum of squares is possible\",\n                            costRelativeTolerance);\n                } else if (delta <= 2.2204e-16 * xNorm) {\n                    throw new OptimizationException(\"parameters relative tolerance is too small\" +\n                            \" ({0}), no further improvement in\" +\n                            \" the approximate solution is possible\",\n                            parRelativeTolerance);\n                } else if (maxCosine <= 2.2204e-16)  {\n                    throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" +\n                            \" solution is orthogonal to the jacobian\",\n                            orthoTolerance);\n                }\n\n            }\n\n        }\n\n    }\n\n    \n    private void determineLMParameter(double[] qy, double delta, double[] diag, double[] work1, double[] work2, double[] work3) {\n\n        \n        \n        for (int j = 0; j < rank; ++j) {\n            lmDir[permutation[j]] = qy[j];\n        }\n        for (int j = rank; j < cols; ++j) {\n            lmDir[permutation[j]] = 0;\n        }\n        for (int k = rank - 1; k >= 0; --k) {\n            int pk = permutation[k];\n            double ypk = lmDir[pk] / diagR[pk];\n            for (int i = 0; i < k; ++i) {\n                lmDir[permutation[i]] -= ypk * jacobian[i][pk];\n            }\n            lmDir[pk] = ypk;\n        }\n\n        \n        \n        double dxNorm = 0;\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            double s = diag[pj] * lmDir[pj];\n            work1[pj] = s;\n            dxNorm += s * s;\n        }\n        dxNorm = Math.sqrt(dxNorm);\n        double fp = dxNorm - delta;\n        if (fp <= 0.1 * delta) {\n            lmPar = 0;\n            return;\n        }\n\n        \n        \n        \n        double sum2;\n        double parl = 0;\n        if (rank == solvedCols) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] *= diag[pj] / dxNorm;\n            }\n            sum2 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double sum = 0;\n                for (int i = 0; i < j; ++i) {\n                    sum += jacobian[i][pj] * work1[permutation[i]];\n                }\n                double s = (work1[pj] - sum) / diagR[pj];\n                work1[pj] = s;\n                sum2 += s * s;\n            }\n            parl = fp / (delta * sum2);\n        }\n\n        \n        sum2 = 0;\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            double sum = 0;\n            for (int i = 0; i <= j; ++i) {\n                sum += jacobian[i][pj] * qy[i];\n            }\n            sum /= diag[pj];\n            sum2 += sum * sum;\n        }\n        double gNorm = Math.sqrt(sum2);\n        double paru = gNorm / delta;\n        if (paru == 0) {\n            \n            paru = 2.2251e-308 / Math.min(delta, 0.1);\n        }\n\n        \n        \n        lmPar = Math.min(paru, Math.max(lmPar, parl));\n        if (lmPar == 0) {\n            lmPar = gNorm / dxNorm;\n        }\n\n        for (int countdown = 10; countdown >= 0; --countdown) {\n\n            \n            if (lmPar == 0) {\n                lmPar = Math.max(2.2251e-308, 0.001 * paru);\n            }\n            double sPar = Math.sqrt(lmPar);\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] = sPar * diag[pj];\n            }\n            determineLMDirection(qy, work1, work2, work3);\n\n            dxNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double s = diag[pj] * lmDir[pj];\n                work3[pj] = s;\n                dxNorm += s * s;\n            }\n            dxNorm = Math.sqrt(dxNorm);\n            double previousFP = fp;\n            fp = dxNorm - delta;\n\n            \n            \n            if ((Math.abs(fp) <= 0.1 * delta) ||\n                    ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {\n                return;\n            }\n\n            \n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] = work3[pj] * diag[pj] / dxNorm;\n            }\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] /= work2[j];\n                double tmp = work1[pj];\n                for (int i = j + 1; i < solvedCols; ++i) {\n                    work1[permutation[i]] -= jacobian[i][pj] * tmp;\n                }\n            }\n            sum2 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                double s = work1[permutation[j]];\n                sum2 += s * s;\n            }\n            double correction = fp / (delta * sum2);\n\n            \n            if (fp > 0) {\n                parl = Math.max(parl, lmPar);\n            } else if (fp < 0) {\n                paru = Math.min(paru, lmPar);\n            }\n\n            \n            lmPar = Math.max(parl, lmPar + correction);\n\n        }\n    }\n\n    \n    private void determineLMDirection(double[] qy, double[] diag, double[] lmDiag, double[] work) {\n\n        \n        \n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            for (int i = j + 1; i < solvedCols; ++i) {\n                jacobian[i][pj] = jacobian[j][permutation[i]];\n            }\n            lmDir[j] = diagR[pj];\n            work[j]  = qy[j];\n        }\n\n        \n        for (int j = 0; j < solvedCols; ++j) {\n\n            \n            \n            int pj = permutation[j];\n            double dpj = diag[pj];\n            if (dpj != 0) {\n                Arrays.fill(lmDiag, j + 1, lmDiag.length, 0);\n            }\n            lmDiag[j] = dpj;\n\n            \n            \n            \n            double qtbpj = 0;\n            for (int k = j; k < solvedCols; ++k) {\n                int pk = permutation[k];\n\n                \n                \n                if (lmDiag[k] != 0) {\n\n                    final double sin;\n                    final double cos;\n                    double rkk = jacobian[k][pk];\n                    if (Math.abs(rkk) < Math.abs(lmDiag[k])) {\n                        final double cotan = rkk / lmDiag[k];\n                        sin   = 1.0 / Math.sqrt(1.0 + cotan * cotan);\n                        cos   = sin * cotan;\n                    } else {\n                        final double tan = lmDiag[k] / rkk;\n                        cos = 1.0 / Math.sqrt(1.0 + tan * tan);\n                        sin = cos * tan;\n                    }\n\n                    \n                    \n                    jacobian[k][pk] = cos * rkk + sin * lmDiag[k];\n                    final double temp = cos * work[k] + sin * qtbpj;\n                    qtbpj = -sin * work[k] + cos * qtbpj;\n                    work[k] = temp;\n\n                    \n                    for (int i = k + 1; i < solvedCols; ++i) {\n                        double rik = jacobian[i][pk];\n                        final double temp2 = cos * rik + sin * lmDiag[i];\n                        lmDiag[i] = -sin * rik + cos * lmDiag[i];\n                        jacobian[i][pk] = temp2;\n                    }\n\n                }\n            }\n\n            \n            \n            lmDiag[j] = jacobian[j][permutation[j]];\n            jacobian[j][permutation[j]] = lmDir[j];\n\n        }\n\n        \n        \n        int nSing = solvedCols;\n        for (int j = 0; j < solvedCols; ++j) {\n            if ((lmDiag[j] == 0) && (nSing == solvedCols)) {\n                nSing = j;\n            }\n            if (nSing < solvedCols) {\n                work[j] = 0;\n            }\n        }\n        if (nSing > 0) {\n            for (int j = nSing - 1; j >= 0; --j) {\n                int pj = permutation[j];\n                double sum = 0;\n                for (int i = j + 1; i < nSing; ++i) {\n                    sum += jacobian[i][pj] * work[i];\n                }\n                work[j] = (work[j] - sum) / lmDiag[j];\n            }\n        }\n\n        \n        for (int j = 0; j < lmDir.length; ++j) {\n            lmDir[permutation[j]] = work[j];\n        }\n\n    }\n\n    \n    private void qrDecomposition() throws OptimizationException {\n\n        \n        for (int k = 0; k < cols; ++k) {\n            permutation[k] = k;\n            double norm2 = 0;\n            for (int i = 0; i < jacobian.length; ++i) {\n                double akk = jacobian[i][k];\n                norm2 += akk * akk;\n            }\n            jacNorm[k] = Math.sqrt(norm2);\n        }\n\n        \n        for (int k = 0; k < cols; ++k) {\n\n            \n            int nextColumn = -1;\n            double ak2 = Double.NEGATIVE_INFINITY;\n            for (int i = k; i < cols; ++i) {\n                double norm2 = 0;\n                for (int j = k; j < jacobian.length; ++j) {\n                    double aki = jacobian[j][permutation[i]];\n                    norm2 += aki * aki;\n                }\n                if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                    throw new OptimizationException(\n                            \"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\",\n                            rows, cols);\n                }\n                if (norm2 > ak2) {\n                    nextColumn = i;\n                    ak2        = norm2;\n                }\n            }\n            if (ak2 == 0) {\n                rank = k;\n                return;\n            }\n            int pk                  = permutation[nextColumn];\n            permutation[nextColumn] = permutation[k];\n            permutation[k]          = pk;\n\n            \n            double akk   = jacobian[k][pk];\n            double alpha = (akk > 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n            double betak = 1.0 / (ak2 - akk * alpha);\n            beta[pk]     = betak;\n\n            \n            diagR[pk]        = alpha;\n            jacobian[k][pk] -= alpha;\n\n            \n            for (int dk = cols - 1 - k; dk > 0; --dk) {\n                double gamma = 0;\n                for (int j = k; j < jacobian.length; ++j) {\n                    gamma += jacobian[j][pk] * jacobian[j][permutation[k + dk]];\n                }\n                gamma *= betak;\n                for (int j = k; j < jacobian.length; ++j) {\n                    jacobian[j][permutation[k + dk]] -= gamma * jacobian[j][pk];\n                }\n            }\n\n        }\n\n        rank = solvedCols;\n\n    }\n\n    \n    private void qTy(double[] y) {\n        for (int k = 0; k < cols; ++k) {\n            int pk = permutation[k];\n            double gamma = 0;\n            for (int i = k; i < rows; ++i) {\n                gamma += jacobian[i][pk] * y[i];\n            }\n            gamma *= beta[pk];\n            for (int i = k; i < rows; ++i) {\n                y[i] -= gamma * jacobian[i][pk];\n            }\n        }\n    }\n\n}\n",
      "buggy_signatures": [
        "public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer { private int solvedCols; private double[] diagR; private double[] jacNorm; private double[] beta; private int[] permutation; private int rank; private double lmPar; private double[] lmDir; private double initialStepBoundFactor; private double costRelativeTolerance; private double parRelativeTolerance; private double orthoTolerance; public LevenbergMarquardtOptimizer()",
        "public void setInitialStepBoundFactor(double initialStepBoundFactor)",
        "public void setCostRelativeTolerance(double costRelativeTolerance)",
        "public void setParRelativeTolerance(double parRelativeTolerance)",
        "public void setOrthoTolerance(double orthoTolerance)",
        "protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException",
        "private void determineLMParameter(double[] qy, double delta, double[] diag, double[] work1, double[] work2, double[] work3)",
        "private void determineLMDirection(double[] qy, double[] diag, double[] lmDiag, double[] work)",
        "private void qrDecomposition() throws OptimizationException",
        "private void qTy(double[] y)"
      ],
      "fixed_signatures": [
        "public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer { private int solvedCols; private double[] diagR; private double[] jacNorm; private double[] beta; private int[] permutation; private int rank; private double lmPar; private double[] lmDir; private double initialStepBoundFactor; private double costRelativeTolerance; private double parRelativeTolerance; private double orthoTolerance; public LevenbergMarquardtOptimizer()",
        "public void setInitialStepBoundFactor(double initialStepBoundFactor)",
        "public void setCostRelativeTolerance(double costRelativeTolerance)",
        "public void setParRelativeTolerance(double parRelativeTolerance)",
        "public void setOrthoTolerance(double orthoTolerance)",
        "protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException",
        "private void determineLMParameter(double[] qy, double delta, double[] diag, double[] work1, double[] work2, double[] work3)",
        "private void determineLMDirection(double[] qy, double[] diag, double[] lmDiag, double[] work)",
        "private void qrDecomposition() throws OptimizationException",
        "private void qTy(double[] y)"
      ],
      "methods": [
        {
          "buggy_method": "  public LevenbergMarquardtOptimizer() {\n\n  \n  setMaxIterations(1000);\n\n  \n  setInitialStepBoundFactor(100.0);\n  setCostRelativeTolerance(1.0e-10);\n  setParRelativeTolerance(1.0e-10);\n  setOrthoTolerance(1.0e-10);\n\n  }",
          "fixed_method": "  public LevenbergMarquardtOptimizer() {\n\n  \n  setMaxIterations(1000);\n\n  \n  setConvergenceChecker(null);\n  setInitialStepBoundFactor(100.0);\n  setCostRelativeTolerance(1.0e-10);\n  setParRelativeTolerance(1.0e-10);\n  setOrthoTolerance(1.0e-10);\n\n  }",
          "diff": [
            "@@ -163,6 +163,7 @@",
            "         setMaxIterations(1000);\n",
            " \n",
            "         // default values for the tuning parameters\n",
            "+        setConvergenceChecker(null);\n",
            "         setInitialStepBoundFactor(100.0);\n",
            "         setCostRelativeTolerance(1.0e-10);\n",
            "         setParRelativeTolerance(1.0e-10);\n"
          ],
          "changed_lines": 1
        },
        {
          "buggy_method": "  protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n  \n  solvedCols  = Math.min(rows, cols);\n  diagR  = new double[cols];\n  jacNorm  = new double[cols];\n  beta  = new double[cols];\n  permutation = new int[cols];\n  lmDir  = new double[cols];\n\n  \n  double  delta  = 0;\n  double  xNorm  = 0;\n  double[] diag  = new double[cols];\n  double[] oldX  = new double[cols];\n  double[] oldRes  = new double[rows];\n  double[] work1  = new double[cols];\n  double[] work2  = new double[cols];\n  double[] work3  = new double[cols];\n\n  \n  updateResidualsAndCost();\n\n  \n  lmPar = 0;\n  boolean firstIteration = true;\n  while (true) {\n\n  incrementIterationsCounter();\n\n  \n  updateJacobian();\n  qrDecomposition();\n\n  \n  qTy(residuals);\n\n  \n  \n  for (int k = 0; k < solvedCols; ++k) {\n  int pk = permutation[k];\n  jacobian[k][pk] = diagR[pk];\n  }\n\n  if (firstIteration) {\n\n  \n  \n  xNorm = 0;\n  for (int k = 0; k < cols; ++k) {\n  double dk = jacNorm[k];\n  if (dk == 0) {\n  dk = 1.0;\n  }\n  double xk = dk * point[k];\n  xNorm  += xk * xk;\n  diag[k] = dk;\n  }\n  xNorm = Math.sqrt(xNorm);\n\n  \n  delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n  }\n\n  \n  double maxCosine = 0;\n  if (cost != 0) {\n  for (int j = 0; j < solvedCols; ++j) {\n  int  pj = permutation[j];\n  double s  = jacNorm[pj];\n  if (s != 0) {\n  double sum = 0;\n  for (int i = 0; i <= j; ++i) {\n  sum += jacobian[i][pj] * residuals[i];\n  }\n  maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n  }\n  }\n  }\n  if (maxCosine <= orthoTolerance) {\n  \n  return new VectorialPointValuePair(point, objective);\n  }\n\n  \n  for (int j = 0; j < cols; ++j) {\n  diag[j] = Math.max(diag[j], jacNorm[j]);\n  }\n\n  \n  for (double ratio = 0; ratio < 1.0e-4;) {\n\n  \n  for (int j = 0; j < solvedCols; ++j) {\n  int pj = permutation[j];\n  oldX[pj] = point[pj];\n  }\n  double previousCost = cost;\n  double[] tmpVec = residuals;\n  residuals = oldRes;\n  oldRes  = tmpVec;\n\n  \n  determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n  \n  double lmNorm = 0;\n  for (int j = 0; j < solvedCols; ++j) {\n  int pj = permutation[j];\n  lmDir[pj] = -lmDir[pj];\n  point[pj] = oldX[pj] + lmDir[pj];\n  double s = diag[pj] * lmDir[pj];\n  lmNorm  += s * s;\n  }\n  lmNorm = Math.sqrt(lmNorm);\n\n  \n  if (firstIteration) {\n  delta = Math.min(delta, lmNorm);\n  }\n\n  \n  updateResidualsAndCost();\n\n  \n  double actRed = -1.0;\n  if (0.1 * cost < previousCost) {\n  double r = cost / previousCost;\n  actRed = 1.0 - r * r;\n  }\n\n  \n  \n  for (int j = 0; j < solvedCols; ++j) {\n  int pj = permutation[j];\n  double dirJ = lmDir[pj];\n  work1[j] = 0;\n  for (int i = 0; i <= j; ++i) {\n  work1[i] += jacobian[i][pj] * dirJ;\n  }\n  }\n  double coeff1 = 0;\n  for (int j = 0; j < solvedCols; ++j) {\n  coeff1 += work1[j] * work1[j];\n  }\n  double pc2 = previousCost * previousCost;\n  coeff1 = coeff1 / pc2;\n  double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n  double preRed = coeff1 + 2 * coeff2;\n  double dirDer = -(coeff1 + coeff2);\n\n  \n  ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n  \n  if (ratio <= 0.25) {\n  double tmp =\n  (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n  if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n  tmp = 0.1;\n  }\n  delta = tmp * Math.min(delta, 10.0 * lmNorm);\n  lmPar /= tmp;\n  } else if ((lmPar == 0) || (ratio >= 0.75)) {\n  delta = 2 * lmNorm;\n  lmPar *= 0.5;\n  }\n\n  \n  if (ratio >= 1.0e-4) {\n  \n  firstIteration = false;\n  xNorm = 0;\n  for (int k = 0; k < cols; ++k) {\n  double xK = diag[k] * point[k];\n  xNorm  += xK * xK;\n  }\n  xNorm = Math.sqrt(xNorm);\n  } else {\n  \n  cost = previousCost;\n  for (int j = 0; j < solvedCols; ++j) {\n  int pj = permutation[j];\n  point[pj] = oldX[pj];\n  }\n  tmpVec  = residuals;\n  residuals = oldRes;\n  oldRes  = tmpVec;\n  }\n\n  \n  \n  \n  if (((Math.abs(actRed) <= costRelativeTolerance) &&\n  (preRed <= costRelativeTolerance) &&\n  (ratio <= 2.0)) ||\n  (delta <= parRelativeTolerance * xNorm)) {\n  return new VectorialPointValuePair(point, objective);\n  }\n\n  \n  \n  if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n  throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" +\n  \" no further reduction in the\" +\n  \" sum of squares is possible\",\n  costRelativeTolerance);\n  } else if (delta <= 2.2204e-16 * xNorm) {\n  throw new OptimizationException(\"parameters relative tolerance is too small\" +\n  \" ({0}), no further improvement in\" +\n  \" the approximate solution is possible\",\n  parRelativeTolerance);\n  } else if (maxCosine <= 2.2204e-16)  {\n  throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" +\n  \" solution is orthogonal to the jacobian\",\n  orthoTolerance);\n  }\n\n  }\n\n  }\n\n  }",
          "fixed_method": "  protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n  \n  solvedCols  = Math.min(rows, cols);\n  diagR  = new double[cols];\n  jacNorm  = new double[cols];\n  beta  = new double[cols];\n  permutation = new int[cols];\n  lmDir  = new double[cols];\n\n  \n  double  delta  = 0;\n  double  xNorm  = 0;\n  double[] diag  = new double[cols];\n  double[] oldX  = new double[cols];\n  double[] oldRes  = new double[rows];\n  double[] work1  = new double[cols];\n  double[] work2  = new double[cols];\n  double[] work3  = new double[cols];\n\n  \n  updateResidualsAndCost();\n\n  \n  lmPar = 0;\n  boolean firstIteration = true;\n  VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n  while (true) {\n\n  incrementIterationsCounter();\n\n  \n  VectorialPointValuePair previous = current;\n  updateJacobian();\n  qrDecomposition();\n\n  \n  qTy(residuals);\n\n  \n  \n  for (int k = 0; k < solvedCols; ++k) {\n  int pk = permutation[k];\n  jacobian[k][pk] = diagR[pk];\n  }\n\n  if (firstIteration) {\n\n  \n  \n  xNorm = 0;\n  for (int k = 0; k < cols; ++k) {\n  double dk = jacNorm[k];\n  if (dk == 0) {\n  dk = 1.0;\n  }\n  double xk = dk * point[k];\n  xNorm  += xk * xk;\n  diag[k] = dk;\n  }\n  xNorm = Math.sqrt(xNorm);\n\n  \n  delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n  }\n\n  \n  double maxCosine = 0;\n  if (cost != 0) {\n  for (int j = 0; j < solvedCols; ++j) {\n  int  pj = permutation[j];\n  double s  = jacNorm[pj];\n  if (s != 0) {\n  double sum = 0;\n  for (int i = 0; i <= j; ++i) {\n  sum += jacobian[i][pj] * residuals[i];\n  }\n  maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n  }\n  }\n  }\n  if (maxCosine <= orthoTolerance) {\n  \n  return current;\n  }\n\n  \n  for (int j = 0; j < cols; ++j) {\n  diag[j] = Math.max(diag[j], jacNorm[j]);\n  }\n\n  \n  for (double ratio = 0; ratio < 1.0e-4;) {\n\n  \n  for (int j = 0; j < solvedCols; ++j) {\n  int pj = permutation[j];\n  oldX[pj] = point[pj];\n  }\n  double previousCost = cost;\n  double[] tmpVec = residuals;\n  residuals = oldRes;\n  oldRes  = tmpVec;\n\n  \n  determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n  \n  double lmNorm = 0;\n  for (int j = 0; j < solvedCols; ++j) {\n  int pj = permutation[j];\n  lmDir[pj] = -lmDir[pj];\n  point[pj] = oldX[pj] + lmDir[pj];\n  double s = diag[pj] * lmDir[pj];\n  lmNorm  += s * s;\n  }\n  lmNorm = Math.sqrt(lmNorm);\n\n  \n  if (firstIteration) {\n  delta = Math.min(delta, lmNorm);\n  }\n\n  \n  updateResidualsAndCost();\n  current = new VectorialPointValuePair(point, objective);\n\n  \n  double actRed = -1.0;\n  if (0.1 * cost < previousCost) {\n  double r = cost / previousCost;\n  actRed = 1.0 - r * r;\n  }\n\n  \n  \n  for (int j = 0; j < solvedCols; ++j) {\n  int pj = permutation[j];\n  double dirJ = lmDir[pj];\n  work1[j] = 0;\n  for (int i = 0; i <= j; ++i) {\n  work1[i] += jacobian[i][pj] * dirJ;\n  }\n  }\n  double coeff1 = 0;\n  for (int j = 0; j < solvedCols; ++j) {\n  coeff1 += work1[j] * work1[j];\n  }\n  double pc2 = previousCost * previousCost;\n  coeff1 = coeff1 / pc2;\n  double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n  double preRed = coeff1 + 2 * coeff2;\n  double dirDer = -(coeff1 + coeff2);\n\n  \n  ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n  \n  if (ratio <= 0.25) {\n  double tmp =\n  (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n  if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n  tmp = 0.1;\n  }\n  delta = tmp * Math.min(delta, 10.0 * lmNorm);\n  lmPar /= tmp;\n  } else if ((lmPar == 0) || (ratio >= 0.75)) {\n  delta = 2 * lmNorm;\n  lmPar *= 0.5;\n  }\n\n  \n  if (ratio >= 1.0e-4) {\n  \n  firstIteration = false;\n  xNorm = 0;\n  for (int k = 0; k < cols; ++k) {\n  double xK = diag[k] * point[k];\n  xNorm  += xK * xK;\n  }\n  xNorm = Math.sqrt(xNorm);\n  } else {\n  \n  cost = previousCost;\n  for (int j = 0; j < solvedCols; ++j) {\n  int pj = permutation[j];\n  point[pj] = oldX[pj];\n  }\n  tmpVec  = residuals;\n  residuals = oldRes;\n  oldRes  = tmpVec;\n  }\n\n  \n  if (checker != null) {\n  \n  if (checker.converged(getIterations(), previous, current)) {\n  return current;  \n  }\n  } else {\n  \n  if (((Math.abs(actRed) <= costRelativeTolerance) &&\n  (preRed <= costRelativeTolerance) &&\n  (ratio <= 2.0)) ||\n  (delta <= parRelativeTolerance * xNorm)) {\n  return current;\n  }\n  }\n\n  \n  \n  if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n  throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" +\n  \" no further reduction in the\" +\n  \" sum of squares is possible\",\n  costRelativeTolerance);\n  } else if (delta <= 2.2204e-16 * xNorm) {\n  throw new OptimizationException(\"parameters relative tolerance is too small\" +\n  \" ({0}), no further improvement in\" +\n  \" the approximate solution is possible\",\n  parRelativeTolerance);\n  } else if (maxCosine <= 2.2204e-16)  {\n  throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" +\n  \" solution is orthogonal to the jacobian\",\n  orthoTolerance);\n  }\n\n  }\n\n  }\n\n  }",
          "diff": [
            "@@ -244,11 +245,13 @@",
            "         // outer loop\n",
            "         lmPar = 0;\n",
            "         boolean firstIteration = true;\n",
            "+        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n",
            "         while (true) {\n",
            " \n",
            "             incrementIterationsCounter();\n",
            " \n",
            "             // compute the Q.R. decomposition of the jacobian matrix\n",
            "+            VectorialPointValuePair previous = current;\n",
            "             updateJacobian();\n",
            "             qrDecomposition();\n",
            " \n",
            "@@ -300,7 +303,7 @@",
            "             }\n",
            "             if (maxCosine <= orthoTolerance) {\n",
            "                 // convergence has been reached\n",
            "-                return new VectorialPointValuePair(point, objective);\n",
            "+                return current;\n",
            "             }\n",
            " \n",
            "             // rescale if necessary\n",
            "@@ -342,6 +345,7 @@",
            " \n",
            "                 // evaluate the function at x + p and calculate its norm\n",
            "                 updateResidualsAndCost();\n",
            "+                current = new VectorialPointValuePair(point, objective);\n",
            " \n",
            "                 // compute the scaled actual reduction\n",
            "                 double actRed = -1.0;\n",
            "@@ -410,14 +414,20 @@",
            "                 }\n",
            " \n",
            "                 // tests for convergence.\n",
            "+                if (checker != null) {\n",
            "                     // we use the vectorial convergence checker\n",
            "+                    if (checker.converged(getIterations(), previous, current)) {\n",
            "+                        return current;                        \n",
            "+                    }\n",
            "+                } else {\n",
            "                     // we use the Levenberg-Marquardt specific convergence parameters\n",
            "                     if (((Math.abs(actRed) <= costRelativeTolerance) &&\n",
            "                          (preRed <= costRelativeTolerance) &&\n",
            "                          (ratio <= 2.0)) ||\n",
            "                         (delta <= parRelativeTolerance * xNorm)) {\n",
            "-                        return new VectorialPointValuePair(point, objective);\n",
            "+                        return current;\n",
            "                     }\n",
            "+                }\n",
            " \n",
            "                 // tests for termination and stringent tolerances\n",
            "                 // (2.2204e-16 is the machine epsilon for IEEE754)\n"
          ],
          "changed_lines": 13
        }
      ]
    }
  ]
}
