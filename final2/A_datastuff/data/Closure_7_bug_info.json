{
  "bug_id": "7",
  "failed_tests": {
    "com.google.javascript.jscomp.ClosureReverseAbstractInterpreterTest": [
      {
        "methodName": "testGoogIsFunction2",
        "error": "junit.framework.AssertionFailedError",
        "message": "Expected: (Object|boolean|number|string)",
        "fail_line": "    testClosureFunction(\"goog.isFunction\",",
        "test_source": "  public void testGoogIsFunction2() throws Exception {\n  testClosureFunction(\"goog.isFunction\",\n  OBJECT_NUMBER_STRING_BOOLEAN,\n  U2U_CONSTRUCTOR_TYPE,\n  OBJECT_NUMBER_STRING_BOOLEAN);\n  }",
        "stack": [
          "Asserts.assertTypeEquals line 106, Asserts.assertTypeEquals line 96, ClosureReverseAbstractInterpreterTest.testClosureFunction line 187, ClosureReverseAbstractInterpreterTest.testGoogIsFunction2 line 121"
        ]
      }
    ],
    "com.google.javascript.jscomp.SemanticReverseAbstractInterpreterTest": [
      {
        "methodName": "testTypeof3",
        "error": "junit.framework.AssertionFailedError",
        "message": "Expected: (Object|boolean|number|string)",
        "fail_line": "    testBinop(blind,",
        "test_source": "  public void testTypeof3() {\n  FlowScope blind = newScope();\n  testBinop(blind,\n  Token.EQ,\n  new Node(Token.TYPEOF, createVar(\n  blind, \"a\", OBJECT_NUMBER_STRING_BOOLEAN)),\n  Node.newString(\"function\"),\n  Sets.newHashSet(\n  new TypedName(\"a\", U2U_CONSTRUCTOR_TYPE)),\n  Sets.newHashSet(\n  new TypedName(\"a\", OBJECT_NUMBER_STRING_BOOLEAN)));\n  }",
        "stack": [
          "Asserts.assertTypeEquals line 106, Asserts.assertTypeEquals line 96, BaseJSTypeTestCase.assertTypeEquals line 577, SemanticReverseAbstractInterpreterTest.testBinop line 568, SemanticReverseAbstractInterpreterTest.testTypeof3 line 465"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java",
      "buggy_full_code": "\n\npackage com.google.javascript.jscomp.type;\n\nimport static com.google.javascript.rhino.jstype.JSTypeNative.ALL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.CHECKED_UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Preconditions; import com.google.javascript.jscomp.CodingConvention; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.EnumElementType; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.ParameterizedType; import com.google.javascript.rhino.jstype.StaticSlot; import com.google.javascript.rhino.jstype.TemplateType; import com.google.javascript.rhino.jstype.UnionType; import com.google.javascript.rhino.jstype.Visitor; public abstract class ChainableReverseAbstractInterpreter implements ReverseAbstractInterpreter { protected final CodingConvention convention; final JSTypeRegistry typeRegistry; private ChainableReverseAbstractInterpreter firstLink; private ChainableReverseAbstractInterpreter nextLink; public ChainableReverseAbstractInterpreter(CodingConvention convention, JSTypeRegistry typeRegistry) {\n    Preconditions.checkNotNull(convention);\n    this.convention = convention;\n    this.typeRegistry = typeRegistry;\n    firstLink = this;\n    nextLink = null;\n  }\n\n  \n  public ChainableReverseAbstractInterpreter append( ChainableReverseAbstractInterpreter lastLink) {\n    Preconditions.checkArgument(lastLink.nextLink == null);\n    this.nextLink = lastLink;\n    lastLink.firstLink = this.firstLink;\n    return lastLink;\n  }\n\n  \n  public ChainableReverseAbstractInterpreter getFirst() {\n    return firstLink;\n  }\n\n  \n  protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {\n    return firstLink.getPreciserScopeKnowingConditionOutcome(\n        condition, blindScope, outcome);\n  }\n\n  \n  protected FlowScope nextPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {\n    return nextLink != null ? nextLink.getPreciserScopeKnowingConditionOutcome(\n        condition, blindScope, outcome) : blindScope;\n  }\n\n  \n  protected JSType getTypeIfRefinable(Node node, FlowScope scope) {\n    switch (node.getType()) {\n      case Token.NAME:\n        StaticSlot<JSType> nameVar = scope.getSlot(node.getString());\n        if (nameVar != null) {\n          JSType nameVarType = nameVar.getType();\n          if (nameVarType == null) {\n            nameVarType = node.getJSType();\n          }\n          return nameVarType;\n        }\n        return null;\n\n      case Token.GETPROP:\n        String qualifiedName = node.getQualifiedName();\n        if (qualifiedName == null) {\n          return null;\n        }\n        StaticSlot<JSType> propVar = scope.getSlot(qualifiedName);\n        JSType propVarType = null;\n        if (propVar != null) {\n          propVarType = propVar.getType();\n        }\n        if (propVarType == null) {\n          propVarType = node.getJSType();\n        }\n        if (propVarType == null) {\n          propVarType = getNativeType(UNKNOWN_TYPE);\n        }\n        return propVarType;\n    }\n    return null;\n  }\n\n  \n  protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n    switch (node.getType()) {\n      case Token.NAME:\n        scope.inferSlotType(node.getString(), type);\n        break;\n\n      case Token.GETPROP:\n        String qualifiedName = node.getQualifiedName();\n        Preconditions.checkNotNull(qualifiedName);\n\n        JSType origType = node.getJSType();\n        origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n        scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n        break;\n\n      case Token.THIS:\n        \n        break;\n\n      default:\n        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n            node.toStringTree());\n    }\n  }\n\n  \n  private final Visitor<JSType> restrictUndefinedVisitor = new Visitor<JSType>() {\n      @Override\n      public JSType caseEnumElementType(EnumElementType enumElementType) {\n        JSType type = enumElementType.getPrimitiveType().visit(this);\n        if (type != null && enumElementType.getPrimitiveType().isEquivalentTo(type)) {\n          return enumElementType;\n        } else {\n          return type;\n        }\n      }\n\n      @Override\n      public JSType caseAllType() {\n        return typeRegistry.createUnionType(OBJECT_TYPE, NUMBER_TYPE,\n            STRING_TYPE, BOOLEAN_TYPE, NULL_TYPE);\n      }\n\n      @Override\n      public JSType caseNoObjectType() {\n        return getNativeType(NO_OBJECT_TYPE);\n      }\n\n      @Override\n      public JSType caseNoType() {\n        return getNativeType(NO_TYPE);\n      }\n\n      @Override\n      public JSType caseBooleanType() {\n        return getNativeType(BOOLEAN_TYPE);\n      }\n\n      @Override\n      public JSType caseFunctionType(FunctionType type) {\n        return type;\n      }\n\n      @Override\n      public JSType caseNullType() {\n        return getNativeType(NULL_TYPE);\n      }\n\n      @Override\n      public JSType caseNumberType() {\n        return getNativeType(NUMBER_TYPE);\n      }\n\n      @Override\n      public JSType caseObjectType(ObjectType type) {\n        return type;\n      }\n\n      @Override\n      public JSType caseStringType() {\n        return getNativeType(STRING_TYPE);\n      }\n\n      @Override\n      public JSType caseUnionType(UnionType type) {\n        return type.getRestrictedUnion(getNativeType(VOID_TYPE));\n      }\n\n      @Override\n      public JSType caseUnknownType() {\n        return getNativeType(UNKNOWN_TYPE);\n      }\n\n      @Override\n      public JSType caseVoidType() {\n        return null;\n      }\n\n      @Override\n      public JSType caseParameterizedType(ParameterizedType type) {\n        return caseObjectType(type);\n      }\n\n      @Override\n      public JSType caseTemplateType(TemplateType templateType) {\n        return caseObjectType(templateType);\n      }\n    };\n\n\n  \n  private final Visitor<JSType> restrictNullVisitor = new Visitor<JSType>() {\n      @Override\n      public JSType caseEnumElementType(EnumElementType enumElementType) {\n        JSType type = enumElementType.getPrimitiveType().visit(this);\n        if (type != null &&\n            enumElementType.getPrimitiveType().isEquivalentTo(type)) {\n          return enumElementType;\n        } else {\n          return type;\n        }\n      }\n\n      @Override\n      public JSType caseAllType() {\n        return typeRegistry.createUnionType(OBJECT_TYPE, NUMBER_TYPE,\n            STRING_TYPE, BOOLEAN_TYPE, VOID_TYPE);\n      }\n\n      @Override\n      public JSType caseNoObjectType() {\n        return getNativeType(NO_OBJECT_TYPE);\n      }\n\n      @Override\n      public JSType caseNoType() {\n        return getNativeType(NO_TYPE);\n      }\n\n      @Override\n      public JSType caseBooleanType() {\n        return getNativeType(BOOLEAN_TYPE);\n      }\n\n      @Override\n      public JSType caseFunctionType(FunctionType type) {\n        return type;\n      }\n\n      @Override\n      public JSType caseNullType() {\n        return null;\n      }\n\n      @Override\n      public JSType caseNumberType() {\n        return getNativeType(NUMBER_TYPE);\n      }\n\n      @Override\n      public JSType caseObjectType(ObjectType type) {\n        return type;\n      }\n\n      @Override\n      public JSType caseStringType() {\n        return getNativeType(STRING_TYPE);\n      }\n\n      @Override\n      public JSType caseUnionType(UnionType type) {\n        return type.getRestrictedUnion(getNativeType(NULL_TYPE));\n      }\n\n      @Override\n      public JSType caseUnknownType() {\n        return getNativeType(UNKNOWN_TYPE);\n      }\n\n      @Override\n      public JSType caseVoidType() {\n        return getNativeType(VOID_TYPE);\n      }\n\n      @Override\n      public JSType caseParameterizedType(ParameterizedType type) {\n        return caseObjectType(type);\n      }\n\n      @Override\n      public JSType caseTemplateType(TemplateType templateType) {\n        return caseObjectType(templateType);\n      }\n    };\n\n  \n  abstract class RestrictByTypeOfResultVisitor implements Visitor<JSType> { protected abstract JSType caseTopType(JSType topType); @Override public JSType caseAllType() {\n      return caseTopType(getNativeType(ALL_TYPE));\n    }\n\n    @Override\n    public JSType caseUnknownType() {\n      return caseTopType(getNativeType(CHECKED_UNKNOWN_TYPE));\n    }\n\n    @Override\n    public JSType caseUnionType(UnionType type) {\n      JSType restricted = null;\n      for (JSType alternate : type.getAlternates()) {\n        JSType restrictedAlternate = alternate.visit(this);\n        if (restrictedAlternate != null) {\n          if (restricted == null) {\n            restricted = restrictedAlternate;\n          } else {\n            restricted = restrictedAlternate.getLeastSupertype(restricted);\n          }\n        }\n      }\n      return restricted;\n    }\n\n    @Override\n    public JSType caseNoType() {\n      return getNativeType(NO_TYPE);\n    }\n\n    @Override\n    public JSType caseEnumElementType(EnumElementType enumElementType) {\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      JSType type = enumElementType.getPrimitiveType().visit(this);\n      if (type != null &&\n          enumElementType.getPrimitiveType().isEquivalentTo(type)) {\n        return enumElementType;\n      } else {\n        return type;\n      }\n    }\n\n    @Override\n    public JSType caseParameterizedType(ParameterizedType type) {\n      return caseObjectType(type);\n    }\n\n    @Override\n    public JSType caseTemplateType(TemplateType templateType) {\n      return caseObjectType(templateType);\n    }\n  }\n\n  \n  abstract class RestrictByTrueTypeOfResultVisitor extends RestrictByTypeOfResultVisitor { @Override public JSType caseNoObjectType() {\n      return null;\n    }\n\n    @Override\n    public JSType caseBooleanType() {\n      return null;\n    }\n\n    @Override\n    public JSType caseFunctionType(FunctionType type) {\n      return null;\n    }\n\n    @Override\n    public JSType caseNullType() {\n      return null;\n    }\n\n    @Override\n    public JSType caseNumberType() {\n      return null;\n    }\n\n    @Override\n    public JSType caseObjectType(ObjectType type) {\n      return null;\n    }\n\n    @Override\n    public JSType caseStringType() {\n      return null;\n    }\n\n    @Override\n    public JSType caseVoidType() {\n      return null;\n    }\n  }\n\n  \n  abstract class RestrictByFalseTypeOfResultVisitor extends RestrictByTypeOfResultVisitor { @Override protected JSType caseTopType(JSType topType) {\n      return topType;\n    }\n\n    @Override\n    public JSType caseNoObjectType() {\n      return getNativeType(NO_OBJECT_TYPE);\n    }\n\n    @Override\n    public JSType caseBooleanType() {\n      return getNativeType(BOOLEAN_TYPE);\n    }\n\n    @Override\n    public JSType caseFunctionType(FunctionType type) {\n      return type;\n    }\n\n    @Override\n    public JSType caseNullType() {\n      return getNativeType(NULL_TYPE);\n    }\n\n    @Override\n    public JSType caseNumberType() {\n      return getNativeType(NUMBER_TYPE);\n    }\n\n    @Override\n    public JSType caseObjectType(ObjectType type) {\n      return type;\n    }\n\n    @Override\n    public JSType caseStringType() {\n      return getNativeType(STRING_TYPE);\n    }\n\n    @Override\n    public JSType caseVoidType() {\n      return getNativeType(VOID_TYPE);\n    }\n  }\n\n  \n  private class RestrictByOneTypeOfResultVisitor extends RestrictByTypeOfResultVisitor { private final String value; private final boolean resultEqualsValue; RestrictByOneTypeOfResultVisitor(String value, boolean resultEqualsValue) {\n      this.value = value;\n      this.resultEqualsValue = resultEqualsValue;\n    }\n\n    \n    private boolean matchesExpectation(String result) {\n      return result.equals(value) == resultEqualsValue;\n    }\n\n    @Override\n    protected JSType caseTopType(JSType topType) {\n      JSType result = topType;\n      if (resultEqualsValue) {\n        JSType typeByName = getNativeTypeForTypeOf(value);\n        if (typeByName != null) {\n          result = typeByName;\n        }\n      }\n      return result;\n    }\n\n    @Override\n    public JSType caseNoObjectType() {\n      return (value.equals(\"object\") || value.equals(\"function\")) ==\n          resultEqualsValue ? getNativeType(NO_OBJECT_TYPE) : null;\n    }\n\n    @Override\n    public JSType caseBooleanType() {\n      return matchesExpectation(\"boolean\") ? getNativeType(BOOLEAN_TYPE) : null;\n    }\n\n    @Override\n    public JSType caseFunctionType(FunctionType type) {\n      return matchesExpectation(\"function\") ? type : null;\n    }\n\n    @Override\n    public JSType caseNullType() {\n      return matchesExpectation(\"object\") ? getNativeType(NULL_TYPE) : null;\n    }\n\n    @Override\n    public JSType caseNumberType() {\n      return matchesExpectation(\"number\") ? getNativeType(NUMBER_TYPE) : null;\n    }\n\n    @Override\n    public JSType caseObjectType(ObjectType type) {\n      if (value.equals(\"function\")) {\n        JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n          \n          \n      }\n      return matchesExpectation(\"object\") ? type : null;\n    }\n\n    @Override\n    public JSType caseStringType() {\n      return matchesExpectation(\"string\") ? getNativeType(STRING_TYPE) : null;\n    }\n\n    @Override\n    public JSType caseVoidType() {\n      return matchesExpectation(\"undefined\") ? getNativeType(VOID_TYPE) : null;\n    }\n  }\n\n  \n  protected final JSType getRestrictedWithoutUndefined(JSType type) {\n    return type == null ? null : type.visit(restrictUndefinedVisitor);\n  }\n\n  \n  protected final JSType getRestrictedWithoutNull(JSType type) {\n    return type == null ? null : type.visit(restrictNullVisitor);\n  }\n\n  \n  JSType getRestrictedByTypeOfResult(JSType type, String value,\n                                     boolean resultEqualsValue) {\n    if (type == null) {\n      if (resultEqualsValue) {\n        JSType result = getNativeTypeForTypeOf(value);\n        return result == null ? getNativeType(CHECKED_UNKNOWN_TYPE) : result;\n      } else {\n        return null;\n      }\n    }\n    return type.visit(\n        new RestrictByOneTypeOfResultVisitor(value, resultEqualsValue));\n  }\n\n  JSType getNativeType(JSTypeNative typeId) {\n    return typeRegistry.getNativeType(typeId);\n  }\n\n  \n  private JSType getNativeTypeForTypeOf(String value) {\n    if (value.equals(\"number\")) {\n      return getNativeType(NUMBER_TYPE);\n    } else if (value.equals(\"boolean\")) {\n      return getNativeType(BOOLEAN_TYPE);\n    } else if (value.equals(\"string\")) {\n      return getNativeType(STRING_TYPE);\n    } else if (value.equals(\"undefined\")) {\n      return getNativeType(VOID_TYPE);\n    } else if (value.equals(\"function\")) {\n      return getNativeType(U2U_CONSTRUCTOR_TYPE);\n    } else {\n      return null;\n    }\n  }\n}\n",
      "fixed_full_code": "\n\npackage com.google.javascript.jscomp.type;\n\nimport static com.google.javascript.rhino.jstype.JSTypeNative.ALL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.CHECKED_UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Preconditions; import com.google.javascript.jscomp.CodingConvention; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.EnumElementType; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.ParameterizedType; import com.google.javascript.rhino.jstype.StaticSlot; import com.google.javascript.rhino.jstype.TemplateType; import com.google.javascript.rhino.jstype.UnionType; import com.google.javascript.rhino.jstype.Visitor; public abstract class ChainableReverseAbstractInterpreter implements ReverseAbstractInterpreter { protected final CodingConvention convention; final JSTypeRegistry typeRegistry; private ChainableReverseAbstractInterpreter firstLink; private ChainableReverseAbstractInterpreter nextLink; public ChainableReverseAbstractInterpreter(CodingConvention convention, JSTypeRegistry typeRegistry) {\n    Preconditions.checkNotNull(convention);\n    this.convention = convention;\n    this.typeRegistry = typeRegistry;\n    firstLink = this;\n    nextLink = null;\n  }\n\n  \n  public ChainableReverseAbstractInterpreter append( ChainableReverseAbstractInterpreter lastLink) {\n    Preconditions.checkArgument(lastLink.nextLink == null);\n    this.nextLink = lastLink;\n    lastLink.firstLink = this.firstLink;\n    return lastLink;\n  }\n\n  \n  public ChainableReverseAbstractInterpreter getFirst() {\n    return firstLink;\n  }\n\n  \n  protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {\n    return firstLink.getPreciserScopeKnowingConditionOutcome(\n        condition, blindScope, outcome);\n  }\n\n  \n  protected FlowScope nextPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {\n    return nextLink != null ? nextLink.getPreciserScopeKnowingConditionOutcome(\n        condition, blindScope, outcome) : blindScope;\n  }\n\n  \n  protected JSType getTypeIfRefinable(Node node, FlowScope scope) {\n    switch (node.getType()) {\n      case Token.NAME:\n        StaticSlot<JSType> nameVar = scope.getSlot(node.getString());\n        if (nameVar != null) {\n          JSType nameVarType = nameVar.getType();\n          if (nameVarType == null) {\n            nameVarType = node.getJSType();\n          }\n          return nameVarType;\n        }\n        return null;\n\n      case Token.GETPROP:\n        String qualifiedName = node.getQualifiedName();\n        if (qualifiedName == null) {\n          return null;\n        }\n        StaticSlot<JSType> propVar = scope.getSlot(qualifiedName);\n        JSType propVarType = null;\n        if (propVar != null) {\n          propVarType = propVar.getType();\n        }\n        if (propVarType == null) {\n          propVarType = node.getJSType();\n        }\n        if (propVarType == null) {\n          propVarType = getNativeType(UNKNOWN_TYPE);\n        }\n        return propVarType;\n    }\n    return null;\n  }\n\n  \n  protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n    switch (node.getType()) {\n      case Token.NAME:\n        scope.inferSlotType(node.getString(), type);\n        break;\n\n      case Token.GETPROP:\n        String qualifiedName = node.getQualifiedName();\n        Preconditions.checkNotNull(qualifiedName);\n\n        JSType origType = node.getJSType();\n        origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n        scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n        break;\n\n      case Token.THIS:\n        \n        break;\n\n      default:\n        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n            node.toStringTree());\n    }\n  }\n\n  \n  private final Visitor<JSType> restrictUndefinedVisitor = new Visitor<JSType>() {\n      @Override\n      public JSType caseEnumElementType(EnumElementType enumElementType) {\n        JSType type = enumElementType.getPrimitiveType().visit(this);\n        if (type != null && enumElementType.getPrimitiveType().isEquivalentTo(type)) {\n          return enumElementType;\n        } else {\n          return type;\n        }\n      }\n\n      @Override\n      public JSType caseAllType() {\n        return typeRegistry.createUnionType(OBJECT_TYPE, NUMBER_TYPE,\n            STRING_TYPE, BOOLEAN_TYPE, NULL_TYPE);\n      }\n\n      @Override\n      public JSType caseNoObjectType() {\n        return getNativeType(NO_OBJECT_TYPE);\n      }\n\n      @Override\n      public JSType caseNoType() {\n        return getNativeType(NO_TYPE);\n      }\n\n      @Override\n      public JSType caseBooleanType() {\n        return getNativeType(BOOLEAN_TYPE);\n      }\n\n      @Override\n      public JSType caseFunctionType(FunctionType type) {\n        return type;\n      }\n\n      @Override\n      public JSType caseNullType() {\n        return getNativeType(NULL_TYPE);\n      }\n\n      @Override\n      public JSType caseNumberType() {\n        return getNativeType(NUMBER_TYPE);\n      }\n\n      @Override\n      public JSType caseObjectType(ObjectType type) {\n        return type;\n      }\n\n      @Override\n      public JSType caseStringType() {\n        return getNativeType(STRING_TYPE);\n      }\n\n      @Override\n      public JSType caseUnionType(UnionType type) {\n        return type.getRestrictedUnion(getNativeType(VOID_TYPE));\n      }\n\n      @Override\n      public JSType caseUnknownType() {\n        return getNativeType(UNKNOWN_TYPE);\n      }\n\n      @Override\n      public JSType caseVoidType() {\n        return null;\n      }\n\n      @Override\n      public JSType caseParameterizedType(ParameterizedType type) {\n        return caseObjectType(type);\n      }\n\n      @Override\n      public JSType caseTemplateType(TemplateType templateType) {\n        return caseObjectType(templateType);\n      }\n    };\n\n\n  \n  private final Visitor<JSType> restrictNullVisitor = new Visitor<JSType>() {\n      @Override\n      public JSType caseEnumElementType(EnumElementType enumElementType) {\n        JSType type = enumElementType.getPrimitiveType().visit(this);\n        if (type != null &&\n            enumElementType.getPrimitiveType().isEquivalentTo(type)) {\n          return enumElementType;\n        } else {\n          return type;\n        }\n      }\n\n      @Override\n      public JSType caseAllType() {\n        return typeRegistry.createUnionType(OBJECT_TYPE, NUMBER_TYPE,\n            STRING_TYPE, BOOLEAN_TYPE, VOID_TYPE);\n      }\n\n      @Override\n      public JSType caseNoObjectType() {\n        return getNativeType(NO_OBJECT_TYPE);\n      }\n\n      @Override\n      public JSType caseNoType() {\n        return getNativeType(NO_TYPE);\n      }\n\n      @Override\n      public JSType caseBooleanType() {\n        return getNativeType(BOOLEAN_TYPE);\n      }\n\n      @Override\n      public JSType caseFunctionType(FunctionType type) {\n        return type;\n      }\n\n      @Override\n      public JSType caseNullType() {\n        return null;\n      }\n\n      @Override\n      public JSType caseNumberType() {\n        return getNativeType(NUMBER_TYPE);\n      }\n\n      @Override\n      public JSType caseObjectType(ObjectType type) {\n        return type;\n      }\n\n      @Override\n      public JSType caseStringType() {\n        return getNativeType(STRING_TYPE);\n      }\n\n      @Override\n      public JSType caseUnionType(UnionType type) {\n        return type.getRestrictedUnion(getNativeType(NULL_TYPE));\n      }\n\n      @Override\n      public JSType caseUnknownType() {\n        return getNativeType(UNKNOWN_TYPE);\n      }\n\n      @Override\n      public JSType caseVoidType() {\n        return getNativeType(VOID_TYPE);\n      }\n\n      @Override\n      public JSType caseParameterizedType(ParameterizedType type) {\n        return caseObjectType(type);\n      }\n\n      @Override\n      public JSType caseTemplateType(TemplateType templateType) {\n        return caseObjectType(templateType);\n      }\n    };\n\n  \n  abstract class RestrictByTypeOfResultVisitor implements Visitor<JSType> { protected abstract JSType caseTopType(JSType topType); @Override public JSType caseAllType() {\n      return caseTopType(getNativeType(ALL_TYPE));\n    }\n\n    @Override\n    public JSType caseUnknownType() {\n      return caseTopType(getNativeType(CHECKED_UNKNOWN_TYPE));\n    }\n\n    @Override\n    public JSType caseUnionType(UnionType type) {\n      JSType restricted = null;\n      for (JSType alternate : type.getAlternates()) {\n        JSType restrictedAlternate = alternate.visit(this);\n        if (restrictedAlternate != null) {\n          if (restricted == null) {\n            restricted = restrictedAlternate;\n          } else {\n            restricted = restrictedAlternate.getLeastSupertype(restricted);\n          }\n        }\n      }\n      return restricted;\n    }\n\n    @Override\n    public JSType caseNoType() {\n      return getNativeType(NO_TYPE);\n    }\n\n    @Override\n    public JSType caseEnumElementType(EnumElementType enumElementType) {\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      JSType type = enumElementType.getPrimitiveType().visit(this);\n      if (type != null &&\n          enumElementType.getPrimitiveType().isEquivalentTo(type)) {\n        return enumElementType;\n      } else {\n        return type;\n      }\n    }\n\n    @Override\n    public JSType caseParameterizedType(ParameterizedType type) {\n      return caseObjectType(type);\n    }\n\n    @Override\n    public JSType caseTemplateType(TemplateType templateType) {\n      return caseObjectType(templateType);\n    }\n  }\n\n  \n  abstract class RestrictByTrueTypeOfResultVisitor extends RestrictByTypeOfResultVisitor { @Override public JSType caseNoObjectType() {\n      return null;\n    }\n\n    @Override\n    public JSType caseBooleanType() {\n      return null;\n    }\n\n    @Override\n    public JSType caseFunctionType(FunctionType type) {\n      return null;\n    }\n\n    @Override\n    public JSType caseNullType() {\n      return null;\n    }\n\n    @Override\n    public JSType caseNumberType() {\n      return null;\n    }\n\n    @Override\n    public JSType caseObjectType(ObjectType type) {\n      return null;\n    }\n\n    @Override\n    public JSType caseStringType() {\n      return null;\n    }\n\n    @Override\n    public JSType caseVoidType() {\n      return null;\n    }\n  }\n\n  \n  abstract class RestrictByFalseTypeOfResultVisitor extends RestrictByTypeOfResultVisitor { @Override protected JSType caseTopType(JSType topType) {\n      return topType;\n    }\n\n    @Override\n    public JSType caseNoObjectType() {\n      return getNativeType(NO_OBJECT_TYPE);\n    }\n\n    @Override\n    public JSType caseBooleanType() {\n      return getNativeType(BOOLEAN_TYPE);\n    }\n\n    @Override\n    public JSType caseFunctionType(FunctionType type) {\n      return type;\n    }\n\n    @Override\n    public JSType caseNullType() {\n      return getNativeType(NULL_TYPE);\n    }\n\n    @Override\n    public JSType caseNumberType() {\n      return getNativeType(NUMBER_TYPE);\n    }\n\n    @Override\n    public JSType caseObjectType(ObjectType type) {\n      return type;\n    }\n\n    @Override\n    public JSType caseStringType() {\n      return getNativeType(STRING_TYPE);\n    }\n\n    @Override\n    public JSType caseVoidType() {\n      return getNativeType(VOID_TYPE);\n    }\n  }\n\n  \n  private class RestrictByOneTypeOfResultVisitor extends RestrictByTypeOfResultVisitor { private final String value; private final boolean resultEqualsValue; RestrictByOneTypeOfResultVisitor(String value, boolean resultEqualsValue) {\n      this.value = value;\n      this.resultEqualsValue = resultEqualsValue;\n    }\n\n    \n    private boolean matchesExpectation(String result) {\n      return result.equals(value) == resultEqualsValue;\n    }\n\n    @Override\n    protected JSType caseTopType(JSType topType) {\n      JSType result = topType;\n      if (resultEqualsValue) {\n        JSType typeByName = getNativeTypeForTypeOf(value);\n        if (typeByName != null) {\n          result = typeByName;\n        }\n      }\n      return result;\n    }\n\n    @Override\n    public JSType caseNoObjectType() {\n      return (value.equals(\"object\") || value.equals(\"function\")) ==\n          resultEqualsValue ? getNativeType(NO_OBJECT_TYPE) : null;\n    }\n\n    @Override\n    public JSType caseBooleanType() {\n      return matchesExpectation(\"boolean\") ? getNativeType(BOOLEAN_TYPE) : null;\n    }\n\n    @Override\n    public JSType caseFunctionType(FunctionType type) {\n      return matchesExpectation(\"function\") ? type : null;\n    }\n\n    @Override\n    public JSType caseNullType() {\n      return matchesExpectation(\"object\") ? getNativeType(NULL_TYPE) : null;\n    }\n\n    @Override\n    public JSType caseNumberType() {\n      return matchesExpectation(\"number\") ? getNativeType(NUMBER_TYPE) : null;\n    }\n\n    @Override\n    public JSType caseObjectType(ObjectType type) {\n      if (value.equals(\"function\")) {\n        JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n        if (resultEqualsValue) {\n          \n          return ctorType.getGreatestSubtype(type);\n        } else {\n          \n          return type.isSubtype(ctorType) ? null : type;\n        }\n      }\n      return matchesExpectation(\"object\") ? type : null;\n    }\n\n    @Override\n    public JSType caseStringType() {\n      return matchesExpectation(\"string\") ? getNativeType(STRING_TYPE) : null;\n    }\n\n    @Override\n    public JSType caseVoidType() {\n      return matchesExpectation(\"undefined\") ? getNativeType(VOID_TYPE) : null;\n    }\n  }\n\n  \n  protected final JSType getRestrictedWithoutUndefined(JSType type) {\n    return type == null ? null : type.visit(restrictUndefinedVisitor);\n  }\n\n  \n  protected final JSType getRestrictedWithoutNull(JSType type) {\n    return type == null ? null : type.visit(restrictNullVisitor);\n  }\n\n  \n  JSType getRestrictedByTypeOfResult(JSType type, String value,\n                                     boolean resultEqualsValue) {\n    if (type == null) {\n      if (resultEqualsValue) {\n        JSType result = getNativeTypeForTypeOf(value);\n        return result == null ? getNativeType(CHECKED_UNKNOWN_TYPE) : result;\n      } else {\n        return null;\n      }\n    }\n    return type.visit(\n        new RestrictByOneTypeOfResultVisitor(value, resultEqualsValue));\n  }\n\n  JSType getNativeType(JSTypeNative typeId) {\n    return typeRegistry.getNativeType(typeId);\n  }\n\n  \n  private JSType getNativeTypeForTypeOf(String value) {\n    if (value.equals(\"number\")) {\n      return getNativeType(NUMBER_TYPE);\n    } else if (value.equals(\"boolean\")) {\n      return getNativeType(BOOLEAN_TYPE);\n    } else if (value.equals(\"string\")) {\n      return getNativeType(STRING_TYPE);\n    } else if (value.equals(\"undefined\")) {\n      return getNativeType(VOID_TYPE);\n    } else if (value.equals(\"function\")) {\n      return getNativeType(U2U_CONSTRUCTOR_TYPE);\n    } else {\n      return null;\n    }\n  }\n}\n",
      "buggy_signatures": [
        "static com.google.javascript.rhino.jstype.JSTypeNative.ALL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.CHECKED_UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Preconditions; import com.google.javascript.jscomp.CodingConvention; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.EnumElementType; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.ParameterizedType; import com.google.javascript.rhino.jstype.StaticSlot; import com.google.javascript.rhino.jstype.TemplateType; import com.google.javascript.rhino.jstype.UnionType; import com.google.javascript.rhino.jstype.Visitor; public abstract class ChainableReverseAbstractInterpreter implements ReverseAbstractInterpreter { protected final CodingConvention convention; final JSTypeRegistry typeRegistry; private ChainableReverseAbstractInterpreter firstLink; private ChainableReverseAbstractInterpreter nextLink; public ChainableReverseAbstractInterpreter(CodingConvention convention, JSTypeRegistry typeRegistry)",
        "public ChainableReverseAbstractInterpreter append( ChainableReverseAbstractInterpreter lastLink)",
        "public ChainableReverseAbstractInterpreter getFirst()",
        "protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome)",
        "protected FlowScope nextPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome)",
        "protected JSType getTypeIfRefinable(Node node, FlowScope scope)",
        "protected void declareNameInScope(FlowScope scope, Node node, JSType type)",
        "public JSType caseEnumElementType(EnumElementType enumElementType)",
        "public JSType caseAllType()",
        "public JSType caseNoObjectType()",
        "public JSType caseNoType()",
        "public JSType caseBooleanType()",
        "public JSType caseFunctionType(FunctionType type)",
        "public JSType caseNullType()",
        "public JSType caseNumberType()",
        "public JSType caseObjectType(ObjectType type)",
        "public JSType caseStringType()",
        "public JSType caseUnionType(UnionType type)",
        "public JSType caseUnknownType()",
        "public JSType caseVoidType()",
        "public JSType caseParameterizedType(ParameterizedType type)",
        "public JSType caseTemplateType(TemplateType templateType)",
        "public JSType caseEnumElementType(EnumElementType enumElementType)",
        "public JSType caseAllType()",
        "public JSType caseNoObjectType()",
        "public JSType caseNoType()",
        "public JSType caseBooleanType()",
        "public JSType caseFunctionType(FunctionType type)",
        "public JSType caseNullType()",
        "public JSType caseNumberType()",
        "public JSType caseObjectType(ObjectType type)",
        "public JSType caseStringType()",
        "public JSType caseUnionType(UnionType type)",
        "public JSType caseUnknownType()",
        "public JSType caseVoidType()",
        "public JSType caseParameterizedType(ParameterizedType type)",
        "public JSType caseTemplateType(TemplateType templateType)",
        "abstract class RestrictByTypeOfResultVisitor implements Visitor<JSType> { protected abstract JSType caseTopType(JSType topType); @Override public JSType caseAllType()",
        "public JSType caseUnknownType()",
        "public JSType caseUnionType(UnionType type)",
        "public JSType caseNoType()",
        "public JSType caseEnumElementType(EnumElementType enumElementType)",
        "public JSType caseParameterizedType(ParameterizedType type)",
        "public JSType caseTemplateType(TemplateType templateType)",
        "abstract class RestrictByTrueTypeOfResultVisitor extends RestrictByTypeOfResultVisitor { @Override public JSType caseNoObjectType()",
        "public JSType caseBooleanType()",
        "public JSType caseFunctionType(FunctionType type)",
        "public JSType caseNullType()",
        "public JSType caseNumberType()",
        "public JSType caseObjectType(ObjectType type)",
        "public JSType caseStringType()",
        "public JSType caseVoidType()",
        "abstract class RestrictByFalseTypeOfResultVisitor extends RestrictByTypeOfResultVisitor { @Override protected JSType caseTopType(JSType topType)",
        "public JSType caseNoObjectType()",
        "public JSType caseBooleanType()",
        "public JSType caseFunctionType(FunctionType type)",
        "public JSType caseNullType()",
        "public JSType caseNumberType()",
        "public JSType caseObjectType(ObjectType type)",
        "public JSType caseStringType()",
        "public JSType caseVoidType()",
        "private class RestrictByOneTypeOfResultVisitor extends RestrictByTypeOfResultVisitor { private final String value; private final boolean resultEqualsValue; RestrictByOneTypeOfResultVisitor(String value, boolean resultEqualsValue)",
        "private boolean matchesExpectation(String result)",
        "protected JSType caseTopType(JSType topType)",
        "public JSType caseNoObjectType()",
        "public JSType caseBooleanType()",
        "public JSType caseFunctionType(FunctionType type)",
        "public JSType caseNullType()",
        "public JSType caseNumberType()",
        "public JSType caseObjectType(ObjectType type)",
        "public JSType caseStringType()",
        "public JSType caseVoidType()",
        "protected final JSType getRestrictedWithoutUndefined(JSType type)",
        "protected final JSType getRestrictedWithoutNull(JSType type)",
        "private JSType getNativeTypeForTypeOf(String value)"
      ],
      "fixed_signatures": [
        "static com.google.javascript.rhino.jstype.JSTypeNative.ALL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.CHECKED_UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Preconditions; import com.google.javascript.jscomp.CodingConvention; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.EnumElementType; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.ParameterizedType; import com.google.javascript.rhino.jstype.StaticSlot; import com.google.javascript.rhino.jstype.TemplateType; import com.google.javascript.rhino.jstype.UnionType; import com.google.javascript.rhino.jstype.Visitor; public abstract class ChainableReverseAbstractInterpreter implements ReverseAbstractInterpreter { protected final CodingConvention convention; final JSTypeRegistry typeRegistry; private ChainableReverseAbstractInterpreter firstLink; private ChainableReverseAbstractInterpreter nextLink; public ChainableReverseAbstractInterpreter(CodingConvention convention, JSTypeRegistry typeRegistry)",
        "public ChainableReverseAbstractInterpreter append( ChainableReverseAbstractInterpreter lastLink)",
        "public ChainableReverseAbstractInterpreter getFirst()",
        "protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome)",
        "protected FlowScope nextPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome)",
        "protected JSType getTypeIfRefinable(Node node, FlowScope scope)",
        "protected void declareNameInScope(FlowScope scope, Node node, JSType type)",
        "public JSType caseEnumElementType(EnumElementType enumElementType)",
        "public JSType caseAllType()",
        "public JSType caseNoObjectType()",
        "public JSType caseNoType()",
        "public JSType caseBooleanType()",
        "public JSType caseFunctionType(FunctionType type)",
        "public JSType caseNullType()",
        "public JSType caseNumberType()",
        "public JSType caseObjectType(ObjectType type)",
        "public JSType caseStringType()",
        "public JSType caseUnionType(UnionType type)",
        "public JSType caseUnknownType()",
        "public JSType caseVoidType()",
        "public JSType caseParameterizedType(ParameterizedType type)",
        "public JSType caseTemplateType(TemplateType templateType)",
        "public JSType caseEnumElementType(EnumElementType enumElementType)",
        "public JSType caseAllType()",
        "public JSType caseNoObjectType()",
        "public JSType caseNoType()",
        "public JSType caseBooleanType()",
        "public JSType caseFunctionType(FunctionType type)",
        "public JSType caseNullType()",
        "public JSType caseNumberType()",
        "public JSType caseObjectType(ObjectType type)",
        "public JSType caseStringType()",
        "public JSType caseUnionType(UnionType type)",
        "public JSType caseUnknownType()",
        "public JSType caseVoidType()",
        "public JSType caseParameterizedType(ParameterizedType type)",
        "public JSType caseTemplateType(TemplateType templateType)",
        "abstract class RestrictByTypeOfResultVisitor implements Visitor<JSType> { protected abstract JSType caseTopType(JSType topType); @Override public JSType caseAllType()",
        "public JSType caseUnknownType()",
        "public JSType caseUnionType(UnionType type)",
        "public JSType caseNoType()",
        "public JSType caseEnumElementType(EnumElementType enumElementType)",
        "public JSType caseParameterizedType(ParameterizedType type)",
        "public JSType caseTemplateType(TemplateType templateType)",
        "abstract class RestrictByTrueTypeOfResultVisitor extends RestrictByTypeOfResultVisitor { @Override public JSType caseNoObjectType()",
        "public JSType caseBooleanType()",
        "public JSType caseFunctionType(FunctionType type)",
        "public JSType caseNullType()",
        "public JSType caseNumberType()",
        "public JSType caseObjectType(ObjectType type)",
        "public JSType caseStringType()",
        "public JSType caseVoidType()",
        "abstract class RestrictByFalseTypeOfResultVisitor extends RestrictByTypeOfResultVisitor { @Override protected JSType caseTopType(JSType topType)",
        "public JSType caseNoObjectType()",
        "public JSType caseBooleanType()",
        "public JSType caseFunctionType(FunctionType type)",
        "public JSType caseNullType()",
        "public JSType caseNumberType()",
        "public JSType caseObjectType(ObjectType type)",
        "public JSType caseStringType()",
        "public JSType caseVoidType()",
        "private class RestrictByOneTypeOfResultVisitor extends RestrictByTypeOfResultVisitor { private final String value; private final boolean resultEqualsValue; RestrictByOneTypeOfResultVisitor(String value, boolean resultEqualsValue)",
        "private boolean matchesExpectation(String result)",
        "protected JSType caseTopType(JSType topType)",
        "public JSType caseNoObjectType()",
        "public JSType caseBooleanType()",
        "public JSType caseFunctionType(FunctionType type)",
        "public JSType caseNullType()",
        "public JSType caseNumberType()",
        "public JSType caseObjectType(ObjectType type)",
        "public JSType caseStringType()",
        "public JSType caseVoidType()",
        "protected final JSType getRestrictedWithoutUndefined(JSType type)",
        "protected final JSType getRestrictedWithoutNull(JSType type)",
        "private JSType getNativeTypeForTypeOf(String value)"
      ],
      "methods": [
        {
          "buggy_method": "  public JSType caseObjectType(ObjectType type) {\n  if (value.equals(\"function\")) {\n  JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n  return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n  \n  \n  }\n  return matchesExpectation(\"object\") ? type : null;\n  }",
          "fixed_method": "  public JSType caseObjectType(ObjectType type) {\n  if (value.equals(\"function\")) {\n  JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n  if (resultEqualsValue) {\n  \n  return ctorType.getGreatestSubtype(type);\n  } else {\n  \n  return type.isSubtype(ctorType) ? null : type;\n  }\n  }\n  return matchesExpectation(\"object\") ? type : null;\n  }",
          "diff": [
            "@@ -610,9 +610,13 @@",
            "     public JSType caseObjectType(ObjectType type) {\n",
            "       if (value.equals(\"function\")) {\n",
            "         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n",
            "-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n",
            "+        if (resultEqualsValue) {\n",
            "           // Objects are restricted to \"Function\", subtypes are left\n",
            "+          return ctorType.getGreatestSubtype(type);\n",
            "+        } else {\n",
            "           // Only filter out subtypes of \"function\"\n",
            "+          return type.isSubtype(ctorType) ? null : type;\n",
            "+        }\n",
            "       }\n",
            "       return matchesExpectation(\"object\") ? type : null;\n",
            "     }\n"
          ],
          "changed_lines": 6
        }
      ]
    }
  ]
}
