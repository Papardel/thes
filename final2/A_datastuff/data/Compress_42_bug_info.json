{
  "bug_id": "42",
  "failed_tests": {
    "org.apache.commons.compress.archivers.zip.ZipArchiveEntryTest": [
      {
        "methodName": "isUnixSymlinkIsFalseIfMoreThanOneFlagIsSet",
        "error": "junit.framework.AssertionFailedError",
        "message": "",
        "fail_line": "            assertFalse(ze.isUnixSymlink());",
        "test_source": "  public void isUnixSymlinkIsFalseIfMoreThanOneFlagIsSet() throws Exception {\n  try (ZipFile zf = new ZipFile(getFile(\"COMPRESS-379.jar\"))) {\n  ZipArchiveEntry ze = zf.getEntry(\"META-INF/maven/\");\n  assertFalse(ze.isUnixSymlink());\n  }\n  }",
        "stack": [
          "ZipArchiveEntryTest.isUnixSymlinkIsFalseIfMoreThanOneFlagIsSet line 280"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/compress/archivers/zip/UnixStat.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.zip;\n\n\n\npublic interface UnixStat {\n\n    \n    int PERM_MASK = 07777;\n    \n    \n    int LINK_FLAG = 0120000;\n    \n    int FILE_FLAG = 0100000;\n    \n    int DIR_FLAG = 040000;\n\n    \n    \n    \n    \n\n    \n    int DEFAULT_LINK_PERM = 0777;\n\n    \n    int DEFAULT_DIR_PERM = 0755;\n\n    \n    int DEFAULT_FILE_PERM = 0644;\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.zip;\n\n\n\npublic interface UnixStat {\n\n    \n    int PERM_MASK = 07777;\n    \n    int FILE_TYPE_FLAG = 0170000;\n    \n    int LINK_FLAG = 0120000;\n    \n    int FILE_FLAG = 0100000;\n    \n    int DIR_FLAG = 040000;\n\n    \n    \n    \n    \n\n    \n    int DEFAULT_LINK_PERM = 0777;\n\n    \n    int DEFAULT_DIR_PERM = 0755;\n\n    \n    int DEFAULT_FILE_PERM = 0644;\n}\n",
      "buggy_signatures": [],
      "fixed_signatures": [],
      "methods": [
        {
          "buggy_method": "",
          "fixed_method": "",
          "diff": [
            "@@ -32,6 +32,7 @@",
            "      * Bits used to indicate the filesystem object type.\n",
            "      * @since 1.14\n",
            "      */\n",
            "+    int FILE_TYPE_FLAG = 0170000;\n",
            "     /**\n",
            "      * Indicates symbolic links.\n",
            "      */\n"
          ],
          "changed_lines": 1
        }
      ]
    },
    {
      "name": "org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java",
      "buggy_full_code": "\npackage org.apache.commons.compress.archivers.zip;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.zip.ZipException;\n\n\npublic class ZipArchiveEntry extends java.util.zip.ZipEntry implements ArchiveEntry { public static final int PLATFORM_UNIX = 3; public static final int PLATFORM_FAT = 0; public static final int CRC_UNKNOWN = -1; private static final int SHORT_MASK = 0xFFFF; private static final int SHORT_SHIFT = 16; private static final byte[] EMPTY = new byte[0]; private int method = ZipMethod.UNKNOWN_CODE; private long size = SIZE_UNKNOWN; private int internalAttributes = 0; private int versionRequired; private int versionMadeBy; private int platform = PLATFORM_FAT; private int rawFlag; private long externalAttributes = 0; private ZipExtraField[] extraFields; private UnparseableExtraFieldData unparseableExtra = null; private String name = null; private byte[] rawName = null; private GeneralPurposeBit gpb = new GeneralPurposeBit(); private static final ZipExtraField[] noExtraFields = new ZipExtraField[0]; public ZipArchiveEntry(final String name) {\n        super(name);\n        setName(name);\n    }\n\n    \n    public ZipArchiveEntry(final java.util.zip.ZipEntry entry) throws ZipException {\n        super(entry);\n        setName(entry.getName());\n        final byte[] extra = entry.getExtra();\n        if (extra != null) {\n            setExtraFields(ExtraFieldUtils.parse(extra, true,\n                                                 ExtraFieldUtils\n                                                 .UnparseableExtraField.READ));\n        } else {\n            \n            setExtra();\n        }\n        setMethod(entry.getMethod());\n        this.size = entry.getSize();\n    }\n\n    \n    public ZipArchiveEntry(final ZipArchiveEntry entry) throws ZipException {\n        this((java.util.zip.ZipEntry) entry);\n        setInternalAttributes(entry.getInternalAttributes());\n        setExternalAttributes(entry.getExternalAttributes());\n        setExtraFields(getAllExtraFieldsNoCopy());\n        setPlatform(entry.getPlatform());\n        final GeneralPurposeBit other = entry.getGeneralPurposeBit();\n        setGeneralPurposeBit(other == null ? null :\n                             (GeneralPurposeBit) other.clone());\n    }\n\n    \n    protected ZipArchiveEntry() {\n        this(\"\");\n    }\n\n    \n    public ZipArchiveEntry(final File inputFile, final String entryName) {\n        this(inputFile.isDirectory() && !entryName.endsWith(\"/\") ? \n             entryName + \"/\" : entryName);\n        if (inputFile.isFile()){\n            setSize(inputFile.length());\n        }\n        setTime(inputFile.lastModified());\n        \n    }\n\n    \n    @Override\n    public Object clone() {\n        final ZipArchiveEntry e = (ZipArchiveEntry) super.clone();\n\n        e.setInternalAttributes(getInternalAttributes());\n        e.setExternalAttributes(getExternalAttributes());\n        e.setExtraFields(getAllExtraFieldsNoCopy());\n        return e;\n    }\n\n    \n    @Override\n    public int getMethod() {\n        return method;\n    }\n\n    \n    @Override\n    public void setMethod(final int method) {\n        if (method < 0) {\n            throw new IllegalArgumentException(\n                    \"ZIP compression method can not be negative: \" + method);\n        }\n        this.method = method;\n    }\n\n    \n    public int getInternalAttributes() {\n        return internalAttributes;\n    }\n\n    \n    public void setInternalAttributes(final int value) {\n        internalAttributes = value;\n    }\n\n    \n    public long getExternalAttributes() {\n        return externalAttributes;\n    }\n\n    \n    public void setExternalAttributes(final long value) {\n        externalAttributes = value;\n    }\n\n    \n    public void setUnixMode(final int mode) {\n        \n        setExternalAttributes((mode << SHORT_SHIFT)\n                              \n                              | ((mode & 0200) == 0 ? 1 : 0)\n                              \n                              | (isDirectory() ? 0x10 : 0));\n        \n        platform = PLATFORM_UNIX;\n    }\n\n    \n    public int getUnixMode() {\n        return platform != PLATFORM_UNIX ? 0 :\n            (int) ((getExternalAttributes() >> SHORT_SHIFT) & SHORT_MASK);\n    }\n\n    \n    public boolean isUnixSymlink() {\n        return (getUnixMode() & UnixStat.LINK_FLAG) == UnixStat.LINK_FLAG;\n    }\n\n    \n    public int getPlatform() {\n        return platform;\n    }\n\n    \n    protected void setPlatform(final int platform) {\n        this.platform = platform;\n    }\n\n    \n    public void setExtraFields(final ZipExtraField[] fields) {\n        final List<ZipExtraField> newFields = new ArrayList<>();\n        for (final ZipExtraField field : fields) {\n            if (field instanceof UnparseableExtraFieldData) {\n                unparseableExtra = (UnparseableExtraFieldData) field;\n            } else {\n                newFields.add( field);\n            }\n        }\n        extraFields = newFields.toArray(new ZipExtraField[newFields.size()]);\n        setExtra();\n    }\n\n    \n    public ZipExtraField[] getExtraFields() {\n        return getParseableExtraFields();\n    }\n\n    \n    public ZipExtraField[] getExtraFields(final boolean includeUnparseable) {\n        return includeUnparseable ?\n                getAllExtraFields() :\n                getParseableExtraFields();\n    }\n\n    private ZipExtraField[] getParseableExtraFieldsNoCopy() {\n        if (extraFields == null) {\n            return noExtraFields;\n        }\n        return extraFields;\n    }\n\n    private ZipExtraField[] getParseableExtraFields() {\n        final ZipExtraField[] parseableExtraFields = getParseableExtraFieldsNoCopy();\n        return (parseableExtraFields == extraFields) ? copyOf(parseableExtraFields) : parseableExtraFields;\n    }\n\n    \n    private ZipExtraField[] getAllExtraFieldsNoCopy() {\n        if (extraFields == null) {\n            return getUnparseableOnly();\n        }\n        return unparseableExtra != null ? getMergedFields() : extraFields;\n    }\n\n    private ZipExtraField[] copyOf(final ZipExtraField[] src) {\n        return copyOf(src, src.length);\n    }\n\n    private ZipExtraField[] copyOf(final ZipExtraField[] src, final int length) {\n        final ZipExtraField[] cpy = new ZipExtraField[length];\n        System.arraycopy(src, 0, cpy, 0, Math.min(src.length, length));\n        return cpy;\n    }\n\n    private ZipExtraField[] getMergedFields() {\n        final ZipExtraField[] zipExtraFields = copyOf(extraFields, extraFields.length + 1);\n        zipExtraFields[extraFields.length] = unparseableExtra;\n        return zipExtraFields;\n    }\n\n    private ZipExtraField[] getUnparseableOnly() {\n        return unparseableExtra == null ? noExtraFields : new ZipExtraField[] { unparseableExtra };\n    }\n\n    private ZipExtraField[] getAllExtraFields() {\n        final ZipExtraField[] allExtraFieldsNoCopy = getAllExtraFieldsNoCopy();\n        return (allExtraFieldsNoCopy == extraFields) ? copyOf( allExtraFieldsNoCopy) : allExtraFieldsNoCopy;\n    }\n    \n    public void addExtraField(final ZipExtraField ze) {\n        if (ze instanceof UnparseableExtraFieldData) {\n            unparseableExtra = (UnparseableExtraFieldData) ze;\n        } else {\n            if (extraFields == null) {\n                extraFields = new ZipExtraField[]{ ze};\n            } else {\n                if (getExtraField(ze.getHeaderId())!= null){\n                    removeExtraField(ze.getHeaderId());\n                }\n                final ZipExtraField[] zipExtraFields = copyOf(extraFields, extraFields.length + 1);\n                zipExtraFields[zipExtraFields.length -1] = ze;\n                extraFields = zipExtraFields;\n            }\n        }\n        setExtra();\n    }\n\n    \n    public void addAsFirstExtraField(final ZipExtraField ze) {\n        if (ze instanceof UnparseableExtraFieldData) {\n            unparseableExtra = (UnparseableExtraFieldData) ze;\n        } else {\n            if (getExtraField(ze.getHeaderId()) != null){\n                removeExtraField(ze.getHeaderId());\n            }\n            final ZipExtraField[] copy = extraFields;\n            final int newLen = extraFields != null ? extraFields.length + 1: 1;\n            extraFields = new ZipExtraField[newLen];\n            extraFields[0] = ze;\n            if (copy != null){\n                System.arraycopy(copy, 0, extraFields, 1, extraFields.length - 1);\n            }\n        }\n        setExtra();\n    }\n\n    \n    public void removeExtraField(final ZipShort type) {\n        if (extraFields == null) {\n            throw new java.util.NoSuchElementException();\n        }\n\n        final List<ZipExtraField> newResult = new ArrayList<>();\n        for (final ZipExtraField extraField : extraFields) {\n            if (!type.equals(extraField.getHeaderId())){\n                newResult.add( extraField);\n            }\n        }\n        if (extraFields.length == newResult.size()) {\n            throw new java.util.NoSuchElementException();\n        }\n        extraFields = newResult.toArray(new ZipExtraField[newResult.size()]);\n        setExtra();\n    }\n\n    \n    public void removeUnparseableExtraFieldData() {\n        if (unparseableExtra == null) {\n            throw new java.util.NoSuchElementException();\n        }\n        unparseableExtra = null;\n        setExtra();\n    }\n\n    \n    public ZipExtraField getExtraField(final ZipShort type) {\n        if (extraFields != null) {\n            for (final ZipExtraField extraField : extraFields) {\n                if (type.equals(extraField.getHeaderId())) {\n                    return extraField;\n                }\n            }\n        }\n        return null;\n    }\n\n    \n    public UnparseableExtraFieldData getUnparseableExtraFieldData() {\n        return unparseableExtra;\n    }\n\n    \n    @Override\n    public void setExtra(final byte[] extra) throws RuntimeException {\n        try {\n            final ZipExtraField[] local =\n                ExtraFieldUtils.parse(extra, true,\n                                      ExtraFieldUtils.UnparseableExtraField.READ);\n            mergeExtraFields(local, true);\n        } catch (final ZipException e) {\n            \n            throw new RuntimeException(\"Error parsing extra fields for entry: \" \n                                       + getName() + \" - \" + e.getMessage(), e);\n        }\n    }\n\n    \n    protected void setExtra() {\n        super.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getAllExtraFieldsNoCopy()));\n    }\n\n    \n    public void setCentralDirectoryExtra(final byte[] b) {\n        try {\n            final ZipExtraField[] central =\n                ExtraFieldUtils.parse(b, false,\n                                      ExtraFieldUtils.UnparseableExtraField.READ);\n            mergeExtraFields(central, false);\n        } catch (final ZipException e) {\n            throw new RuntimeException(e.getMessage(), e); \n        }\n    }\n\n    \n    public byte[] getLocalFileDataExtra() {\n        final byte[] extra = getExtra();\n        return extra != null ? extra : EMPTY;\n    }\n\n    \n    public byte[] getCentralDirectoryExtra() {\n        return ExtraFieldUtils.mergeCentralDirectoryData(getAllExtraFieldsNoCopy());\n    }\n\n    \n    @Override\n    public String getName() {\n        return name == null ? super.getName() : name;\n    }\n\n    \n    @Override\n    public boolean isDirectory() {\n        return getName().endsWith(\"/\");\n    }\n\n    \n    protected void setName(String name) {\n        if (name != null && getPlatform() == PLATFORM_FAT\n            && !name.contains(\"/\")) {\n            name = name.replace('\\\\', '/');\n        }\n        this.name = name;\n    }\n\n    \n    @Override\n    public long getSize() {\n        return size;\n    }\n\n    \n    @Override\n    public void setSize(final long size) {\n        if (size < 0) {\n            throw new IllegalArgumentException(\"invalid entry size\");\n        }\n        this.size = size;\n    }\n\n    \n    protected void setName(final String name, final byte[] rawName) {\n        setName(name);\n        this.rawName = rawName;\n    }\n\n    \n    public byte[] getRawName() {\n        if (rawName != null) {\n            final byte[] b = new byte[rawName.length];\n            System.arraycopy(rawName, 0, b, 0, rawName.length);\n            return b;\n        }\n        return null;\n    }\n\n    \n    @Override\n    public int hashCode() {\n        \n        \n        \n        \n        return getName().hashCode();\n    }\n\n    \n    public GeneralPurposeBit getGeneralPurposeBit() {\n        return gpb;\n    }\n\n    \n    public void setGeneralPurposeBit(final GeneralPurposeBit b) {\n        gpb = b;\n    }\n\n    \n    private void mergeExtraFields(final ZipExtraField[] f, final boolean local) throws ZipException {\n        if (extraFields == null) {\n            setExtraFields(f);\n        } else {\n            for (final ZipExtraField element : f) {\n                ZipExtraField existing;\n                if (element instanceof UnparseableExtraFieldData) {\n                    existing = unparseableExtra;\n                } else {\n                    existing = getExtraField(element.getHeaderId());\n                }\n                if (existing == null) {\n                    addExtraField(element);\n                } else {\n                    if (local) {\n                        final byte[] b = element.getLocalFileDataData();\n                        existing.parseFromLocalFileData(b, 0, b.length);\n                    } else {\n                        final byte[] b = element.getCentralDirectoryData();\n                        existing.parseFromCentralDirectoryData(b, 0, b.length);\n                    }\n                }\n            }\n            setExtra();\n        }\n    }\n\n    \n    @Override\n    public Date getLastModifiedDate() {\n        return new Date(getTime());\n    }\n\n    \n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null || getClass() != obj.getClass()) {\n            return false;\n        }\n        final ZipArchiveEntry other = (ZipArchiveEntry) obj;\n        final String myName = getName();\n        final String otherName = other.getName();\n        if (myName == null) {\n            if (otherName != null) {\n                return false;\n            }\n        } else if (!myName.equals(otherName)) {\n            return false;\n        }\n        String myComment = getComment();\n        String otherComment = other.getComment();\n        if (myComment == null) {\n            myComment = \"\";\n        }\n        if (otherComment == null) {\n            otherComment = \"\";\n        }\n        return getTime() == other.getTime()\n            && myComment.equals(otherComment)\n            && getInternalAttributes() == other.getInternalAttributes()\n            && getPlatform() == other.getPlatform()\n            && getExternalAttributes() == other.getExternalAttributes()\n            && getMethod() == other.getMethod()\n            && getSize() == other.getSize()\n            && getCrc() == other.getCrc()\n            && getCompressedSize() == other.getCompressedSize()\n            && Arrays.equals(getCentralDirectoryExtra(),\n                             other.getCentralDirectoryExtra())\n            && Arrays.equals(getLocalFileDataExtra(),\n                             other.getLocalFileDataExtra())\n            && gpb.equals(other.gpb);\n    }\n\n    \n    public void setVersionMadeBy(final int versionMadeBy) {\n        this.versionMadeBy = versionMadeBy;\n    }\n\n    \n    public void setVersionRequired(final int versionRequired) {\n        this.versionRequired = versionRequired;\n    }\n\n    \n    public int getVersionRequired() {\n        return versionRequired;\n    }\n\n    \n    public int getVersionMadeBy() {\n        return versionMadeBy;\n    }\n\n    \n    public int getRawFlag() {\n        return rawFlag;\n    }\n\n    \n    public void setRawFlag(final int rawFlag) {\n        this.rawFlag = rawFlag;\n    }\n}\n",
      "fixed_full_code": "\npackage org.apache.commons.compress.archivers.zip;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.zip.ZipException;\n\n\npublic class ZipArchiveEntry extends java.util.zip.ZipEntry implements ArchiveEntry { public static final int PLATFORM_UNIX = 3; public static final int PLATFORM_FAT = 0; public static final int CRC_UNKNOWN = -1; private static final int SHORT_MASK = 0xFFFF; private static final int SHORT_SHIFT = 16; private static final byte[] EMPTY = new byte[0]; private int method = ZipMethod.UNKNOWN_CODE; private long size = SIZE_UNKNOWN; private int internalAttributes = 0; private int versionRequired; private int versionMadeBy; private int platform = PLATFORM_FAT; private int rawFlag; private long externalAttributes = 0; private ZipExtraField[] extraFields; private UnparseableExtraFieldData unparseableExtra = null; private String name = null; private byte[] rawName = null; private GeneralPurposeBit gpb = new GeneralPurposeBit(); private static final ZipExtraField[] noExtraFields = new ZipExtraField[0]; public ZipArchiveEntry(final String name) {\n        super(name);\n        setName(name);\n    }\n\n    \n    public ZipArchiveEntry(final java.util.zip.ZipEntry entry) throws ZipException {\n        super(entry);\n        setName(entry.getName());\n        final byte[] extra = entry.getExtra();\n        if (extra != null) {\n            setExtraFields(ExtraFieldUtils.parse(extra, true,\n                                                 ExtraFieldUtils\n                                                 .UnparseableExtraField.READ));\n        } else {\n            \n            setExtra();\n        }\n        setMethod(entry.getMethod());\n        this.size = entry.getSize();\n    }\n\n    \n    public ZipArchiveEntry(final ZipArchiveEntry entry) throws ZipException {\n        this((java.util.zip.ZipEntry) entry);\n        setInternalAttributes(entry.getInternalAttributes());\n        setExternalAttributes(entry.getExternalAttributes());\n        setExtraFields(getAllExtraFieldsNoCopy());\n        setPlatform(entry.getPlatform());\n        final GeneralPurposeBit other = entry.getGeneralPurposeBit();\n        setGeneralPurposeBit(other == null ? null :\n                             (GeneralPurposeBit) other.clone());\n    }\n\n    \n    protected ZipArchiveEntry() {\n        this(\"\");\n    }\n\n    \n    public ZipArchiveEntry(final File inputFile, final String entryName) {\n        this(inputFile.isDirectory() && !entryName.endsWith(\"/\") ? \n             entryName + \"/\" : entryName);\n        if (inputFile.isFile()){\n            setSize(inputFile.length());\n        }\n        setTime(inputFile.lastModified());\n        \n    }\n\n    \n    @Override\n    public Object clone() {\n        final ZipArchiveEntry e = (ZipArchiveEntry) super.clone();\n\n        e.setInternalAttributes(getInternalAttributes());\n        e.setExternalAttributes(getExternalAttributes());\n        e.setExtraFields(getAllExtraFieldsNoCopy());\n        return e;\n    }\n\n    \n    @Override\n    public int getMethod() {\n        return method;\n    }\n\n    \n    @Override\n    public void setMethod(final int method) {\n        if (method < 0) {\n            throw new IllegalArgumentException(\n                    \"ZIP compression method can not be negative: \" + method);\n        }\n        this.method = method;\n    }\n\n    \n    public int getInternalAttributes() {\n        return internalAttributes;\n    }\n\n    \n    public void setInternalAttributes(final int value) {\n        internalAttributes = value;\n    }\n\n    \n    public long getExternalAttributes() {\n        return externalAttributes;\n    }\n\n    \n    public void setExternalAttributes(final long value) {\n        externalAttributes = value;\n    }\n\n    \n    public void setUnixMode(final int mode) {\n        \n        setExternalAttributes((mode << SHORT_SHIFT)\n                              \n                              | ((mode & 0200) == 0 ? 1 : 0)\n                              \n                              | (isDirectory() ? 0x10 : 0));\n        \n        platform = PLATFORM_UNIX;\n    }\n\n    \n    public int getUnixMode() {\n        return platform != PLATFORM_UNIX ? 0 :\n            (int) ((getExternalAttributes() >> SHORT_SHIFT) & SHORT_MASK);\n    }\n\n    \n    public boolean isUnixSymlink() {\n        return (getUnixMode() & UnixStat.FILE_TYPE_FLAG) == UnixStat.LINK_FLAG;\n    }\n\n    \n    public int getPlatform() {\n        return platform;\n    }\n\n    \n    protected void setPlatform(final int platform) {\n        this.platform = platform;\n    }\n\n    \n    public void setExtraFields(final ZipExtraField[] fields) {\n        final List<ZipExtraField> newFields = new ArrayList<>();\n        for (final ZipExtraField field : fields) {\n            if (field instanceof UnparseableExtraFieldData) {\n                unparseableExtra = (UnparseableExtraFieldData) field;\n            } else {\n                newFields.add( field);\n            }\n        }\n        extraFields = newFields.toArray(new ZipExtraField[newFields.size()]);\n        setExtra();\n    }\n\n    \n    public ZipExtraField[] getExtraFields() {\n        return getParseableExtraFields();\n    }\n\n    \n    public ZipExtraField[] getExtraFields(final boolean includeUnparseable) {\n        return includeUnparseable ?\n                getAllExtraFields() :\n                getParseableExtraFields();\n    }\n\n    private ZipExtraField[] getParseableExtraFieldsNoCopy() {\n        if (extraFields == null) {\n            return noExtraFields;\n        }\n        return extraFields;\n    }\n\n    private ZipExtraField[] getParseableExtraFields() {\n        final ZipExtraField[] parseableExtraFields = getParseableExtraFieldsNoCopy();\n        return (parseableExtraFields == extraFields) ? copyOf(parseableExtraFields) : parseableExtraFields;\n    }\n\n    \n    private ZipExtraField[] getAllExtraFieldsNoCopy() {\n        if (extraFields == null) {\n            return getUnparseableOnly();\n        }\n        return unparseableExtra != null ? getMergedFields() : extraFields;\n    }\n\n    private ZipExtraField[] copyOf(final ZipExtraField[] src) {\n        return copyOf(src, src.length);\n    }\n\n    private ZipExtraField[] copyOf(final ZipExtraField[] src, final int length) {\n        final ZipExtraField[] cpy = new ZipExtraField[length];\n        System.arraycopy(src, 0, cpy, 0, Math.min(src.length, length));\n        return cpy;\n    }\n\n    private ZipExtraField[] getMergedFields() {\n        final ZipExtraField[] zipExtraFields = copyOf(extraFields, extraFields.length + 1);\n        zipExtraFields[extraFields.length] = unparseableExtra;\n        return zipExtraFields;\n    }\n\n    private ZipExtraField[] getUnparseableOnly() {\n        return unparseableExtra == null ? noExtraFields : new ZipExtraField[] { unparseableExtra };\n    }\n\n    private ZipExtraField[] getAllExtraFields() {\n        final ZipExtraField[] allExtraFieldsNoCopy = getAllExtraFieldsNoCopy();\n        return (allExtraFieldsNoCopy == extraFields) ? copyOf( allExtraFieldsNoCopy) : allExtraFieldsNoCopy;\n    }\n    \n    public void addExtraField(final ZipExtraField ze) {\n        if (ze instanceof UnparseableExtraFieldData) {\n            unparseableExtra = (UnparseableExtraFieldData) ze;\n        } else {\n            if (extraFields == null) {\n                extraFields = new ZipExtraField[]{ ze};\n            } else {\n                if (getExtraField(ze.getHeaderId())!= null){\n                    removeExtraField(ze.getHeaderId());\n                }\n                final ZipExtraField[] zipExtraFields = copyOf(extraFields, extraFields.length + 1);\n                zipExtraFields[zipExtraFields.length -1] = ze;\n                extraFields = zipExtraFields;\n            }\n        }\n        setExtra();\n    }\n\n    \n    public void addAsFirstExtraField(final ZipExtraField ze) {\n        if (ze instanceof UnparseableExtraFieldData) {\n            unparseableExtra = (UnparseableExtraFieldData) ze;\n        } else {\n            if (getExtraField(ze.getHeaderId()) != null){\n                removeExtraField(ze.getHeaderId());\n            }\n            final ZipExtraField[] copy = extraFields;\n            final int newLen = extraFields != null ? extraFields.length + 1: 1;\n            extraFields = new ZipExtraField[newLen];\n            extraFields[0] = ze;\n            if (copy != null){\n                System.arraycopy(copy, 0, extraFields, 1, extraFields.length - 1);\n            }\n        }\n        setExtra();\n    }\n\n    \n    public void removeExtraField(final ZipShort type) {\n        if (extraFields == null) {\n            throw new java.util.NoSuchElementException();\n        }\n\n        final List<ZipExtraField> newResult = new ArrayList<>();\n        for (final ZipExtraField extraField : extraFields) {\n            if (!type.equals(extraField.getHeaderId())){\n                newResult.add( extraField);\n            }\n        }\n        if (extraFields.length == newResult.size()) {\n            throw new java.util.NoSuchElementException();\n        }\n        extraFields = newResult.toArray(new ZipExtraField[newResult.size()]);\n        setExtra();\n    }\n\n    \n    public void removeUnparseableExtraFieldData() {\n        if (unparseableExtra == null) {\n            throw new java.util.NoSuchElementException();\n        }\n        unparseableExtra = null;\n        setExtra();\n    }\n\n    \n    public ZipExtraField getExtraField(final ZipShort type) {\n        if (extraFields != null) {\n            for (final ZipExtraField extraField : extraFields) {\n                if (type.equals(extraField.getHeaderId())) {\n                    return extraField;\n                }\n            }\n        }\n        return null;\n    }\n\n    \n    public UnparseableExtraFieldData getUnparseableExtraFieldData() {\n        return unparseableExtra;\n    }\n\n    \n    @Override\n    public void setExtra(final byte[] extra) throws RuntimeException {\n        try {\n            final ZipExtraField[] local =\n                ExtraFieldUtils.parse(extra, true,\n                                      ExtraFieldUtils.UnparseableExtraField.READ);\n            mergeExtraFields(local, true);\n        } catch (final ZipException e) {\n            \n            throw new RuntimeException(\"Error parsing extra fields for entry: \" \n                                       + getName() + \" - \" + e.getMessage(), e);\n        }\n    }\n\n    \n    protected void setExtra() {\n        super.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getAllExtraFieldsNoCopy()));\n    }\n\n    \n    public void setCentralDirectoryExtra(final byte[] b) {\n        try {\n            final ZipExtraField[] central =\n                ExtraFieldUtils.parse(b, false,\n                                      ExtraFieldUtils.UnparseableExtraField.READ);\n            mergeExtraFields(central, false);\n        } catch (final ZipException e) {\n            throw new RuntimeException(e.getMessage(), e); \n        }\n    }\n\n    \n    public byte[] getLocalFileDataExtra() {\n        final byte[] extra = getExtra();\n        return extra != null ? extra : EMPTY;\n    }\n\n    \n    public byte[] getCentralDirectoryExtra() {\n        return ExtraFieldUtils.mergeCentralDirectoryData(getAllExtraFieldsNoCopy());\n    }\n\n    \n    @Override\n    public String getName() {\n        return name == null ? super.getName() : name;\n    }\n\n    \n    @Override\n    public boolean isDirectory() {\n        return getName().endsWith(\"/\");\n    }\n\n    \n    protected void setName(String name) {\n        if (name != null && getPlatform() == PLATFORM_FAT\n            && !name.contains(\"/\")) {\n            name = name.replace('\\\\', '/');\n        }\n        this.name = name;\n    }\n\n    \n    @Override\n    public long getSize() {\n        return size;\n    }\n\n    \n    @Override\n    public void setSize(final long size) {\n        if (size < 0) {\n            throw new IllegalArgumentException(\"invalid entry size\");\n        }\n        this.size = size;\n    }\n\n    \n    protected void setName(final String name, final byte[] rawName) {\n        setName(name);\n        this.rawName = rawName;\n    }\n\n    \n    public byte[] getRawName() {\n        if (rawName != null) {\n            final byte[] b = new byte[rawName.length];\n            System.arraycopy(rawName, 0, b, 0, rawName.length);\n            return b;\n        }\n        return null;\n    }\n\n    \n    @Override\n    public int hashCode() {\n        \n        \n        \n        \n        return getName().hashCode();\n    }\n\n    \n    public GeneralPurposeBit getGeneralPurposeBit() {\n        return gpb;\n    }\n\n    \n    public void setGeneralPurposeBit(final GeneralPurposeBit b) {\n        gpb = b;\n    }\n\n    \n    private void mergeExtraFields(final ZipExtraField[] f, final boolean local) throws ZipException {\n        if (extraFields == null) {\n            setExtraFields(f);\n        } else {\n            for (final ZipExtraField element : f) {\n                ZipExtraField existing;\n                if (element instanceof UnparseableExtraFieldData) {\n                    existing = unparseableExtra;\n                } else {\n                    existing = getExtraField(element.getHeaderId());\n                }\n                if (existing == null) {\n                    addExtraField(element);\n                } else {\n                    if (local) {\n                        final byte[] b = element.getLocalFileDataData();\n                        existing.parseFromLocalFileData(b, 0, b.length);\n                    } else {\n                        final byte[] b = element.getCentralDirectoryData();\n                        existing.parseFromCentralDirectoryData(b, 0, b.length);\n                    }\n                }\n            }\n            setExtra();\n        }\n    }\n\n    \n    @Override\n    public Date getLastModifiedDate() {\n        return new Date(getTime());\n    }\n\n    \n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null || getClass() != obj.getClass()) {\n            return false;\n        }\n        final ZipArchiveEntry other = (ZipArchiveEntry) obj;\n        final String myName = getName();\n        final String otherName = other.getName();\n        if (myName == null) {\n            if (otherName != null) {\n                return false;\n            }\n        } else if (!myName.equals(otherName)) {\n            return false;\n        }\n        String myComment = getComment();\n        String otherComment = other.getComment();\n        if (myComment == null) {\n            myComment = \"\";\n        }\n        if (otherComment == null) {\n            otherComment = \"\";\n        }\n        return getTime() == other.getTime()\n            && myComment.equals(otherComment)\n            && getInternalAttributes() == other.getInternalAttributes()\n            && getPlatform() == other.getPlatform()\n            && getExternalAttributes() == other.getExternalAttributes()\n            && getMethod() == other.getMethod()\n            && getSize() == other.getSize()\n            && getCrc() == other.getCrc()\n            && getCompressedSize() == other.getCompressedSize()\n            && Arrays.equals(getCentralDirectoryExtra(),\n                             other.getCentralDirectoryExtra())\n            && Arrays.equals(getLocalFileDataExtra(),\n                             other.getLocalFileDataExtra())\n            && gpb.equals(other.gpb);\n    }\n\n    \n    public void setVersionMadeBy(final int versionMadeBy) {\n        this.versionMadeBy = versionMadeBy;\n    }\n\n    \n    public void setVersionRequired(final int versionRequired) {\n        this.versionRequired = versionRequired;\n    }\n\n    \n    public int getVersionRequired() {\n        return versionRequired;\n    }\n\n    \n    public int getVersionMadeBy() {\n        return versionMadeBy;\n    }\n\n    \n    public int getRawFlag() {\n        return rawFlag;\n    }\n\n    \n    public void setRawFlag(final int rawFlag) {\n        this.rawFlag = rawFlag;\n    }\n}\n",
      "buggy_signatures": [
        "public ZipArchiveEntry(final java.util.zip.ZipEntry entry) throws ZipException",
        "public ZipArchiveEntry(final ZipArchiveEntry entry) throws ZipException",
        "protected ZipArchiveEntry()",
        "public ZipArchiveEntry(final File inputFile, final String entryName)",
        "public Object clone()",
        "public int getMethod()",
        "public void setMethod(final int method)",
        "public int getInternalAttributes()",
        "public void setInternalAttributes(final int value)",
        "public long getExternalAttributes()",
        "public void setExternalAttributes(final long value)",
        "public void setUnixMode(final int mode)",
        "public int getUnixMode()",
        "public boolean isUnixSymlink()",
        "public int getPlatform()",
        "protected void setPlatform(final int platform)",
        "public void setExtraFields(final ZipExtraField[] fields)",
        "public ZipExtraField[] getExtraFields()",
        "public ZipExtraField[] getExtraFields(final boolean includeUnparseable)",
        "private ZipExtraField[] getParseableExtraFieldsNoCopy()",
        "private ZipExtraField[] getParseableExtraFields()",
        "private ZipExtraField[] getAllExtraFieldsNoCopy()",
        "private ZipExtraField[] copyOf(final ZipExtraField[] src)",
        "private ZipExtraField[] copyOf(final ZipExtraField[] src, final int length)",
        "private ZipExtraField[] getMergedFields()",
        "private ZipExtraField[] getUnparseableOnly()",
        "private ZipExtraField[] getAllExtraFields()",
        "public void addExtraField(final ZipExtraField ze)",
        "public void addAsFirstExtraField(final ZipExtraField ze)",
        "public void removeExtraField(final ZipShort type)",
        "public void removeUnparseableExtraFieldData()",
        "public ZipExtraField getExtraField(final ZipShort type)",
        "public UnparseableExtraFieldData getUnparseableExtraFieldData()",
        "public void setExtra(final byte[] extra) throws RuntimeException",
        "protected void setExtra()",
        "public void setCentralDirectoryExtra(final byte[] b)",
        "public byte[] getLocalFileDataExtra()",
        "public byte[] getCentralDirectoryExtra()",
        "public String getName()",
        "public boolean isDirectory()",
        "protected void setName(String name)",
        "public long getSize()",
        "public void setSize(final long size)",
        "protected void setName(final String name, final byte[] rawName)",
        "public byte[] getRawName()",
        "public int hashCode()",
        "public GeneralPurposeBit getGeneralPurposeBit()",
        "public void setGeneralPurposeBit(final GeneralPurposeBit b)",
        "private void mergeExtraFields(final ZipExtraField[] f, final boolean local) throws ZipException",
        "public Date getLastModifiedDate()",
        "public boolean equals(final Object obj)",
        "public void setVersionMadeBy(final int versionMadeBy)",
        "public void setVersionRequired(final int versionRequired)",
        "public int getVersionRequired()",
        "public int getVersionMadeBy()",
        "public int getRawFlag()",
        "public void setRawFlag(final int rawFlag)"
      ],
      "fixed_signatures": [
        "public ZipArchiveEntry(final java.util.zip.ZipEntry entry) throws ZipException",
        "public ZipArchiveEntry(final ZipArchiveEntry entry) throws ZipException",
        "protected ZipArchiveEntry()",
        "public ZipArchiveEntry(final File inputFile, final String entryName)",
        "public Object clone()",
        "public int getMethod()",
        "public void setMethod(final int method)",
        "public int getInternalAttributes()",
        "public void setInternalAttributes(final int value)",
        "public long getExternalAttributes()",
        "public void setExternalAttributes(final long value)",
        "public void setUnixMode(final int mode)",
        "public int getUnixMode()",
        "public boolean isUnixSymlink()",
        "public int getPlatform()",
        "protected void setPlatform(final int platform)",
        "public void setExtraFields(final ZipExtraField[] fields)",
        "public ZipExtraField[] getExtraFields()",
        "public ZipExtraField[] getExtraFields(final boolean includeUnparseable)",
        "private ZipExtraField[] getParseableExtraFieldsNoCopy()",
        "private ZipExtraField[] getParseableExtraFields()",
        "private ZipExtraField[] getAllExtraFieldsNoCopy()",
        "private ZipExtraField[] copyOf(final ZipExtraField[] src)",
        "private ZipExtraField[] copyOf(final ZipExtraField[] src, final int length)",
        "private ZipExtraField[] getMergedFields()",
        "private ZipExtraField[] getUnparseableOnly()",
        "private ZipExtraField[] getAllExtraFields()",
        "public void addExtraField(final ZipExtraField ze)",
        "public void addAsFirstExtraField(final ZipExtraField ze)",
        "public void removeExtraField(final ZipShort type)",
        "public void removeUnparseableExtraFieldData()",
        "public ZipExtraField getExtraField(final ZipShort type)",
        "public UnparseableExtraFieldData getUnparseableExtraFieldData()",
        "public void setExtra(final byte[] extra) throws RuntimeException",
        "protected void setExtra()",
        "public void setCentralDirectoryExtra(final byte[] b)",
        "public byte[] getLocalFileDataExtra()",
        "public byte[] getCentralDirectoryExtra()",
        "public String getName()",
        "public boolean isDirectory()",
        "protected void setName(String name)",
        "public long getSize()",
        "public void setSize(final long size)",
        "protected void setName(final String name, final byte[] rawName)",
        "public byte[] getRawName()",
        "public int hashCode()",
        "public GeneralPurposeBit getGeneralPurposeBit()",
        "public void setGeneralPurposeBit(final GeneralPurposeBit b)",
        "private void mergeExtraFields(final ZipExtraField[] f, final boolean local) throws ZipException",
        "public Date getLastModifiedDate()",
        "public boolean equals(final Object obj)",
        "public void setVersionMadeBy(final int versionMadeBy)",
        "public void setVersionRequired(final int versionRequired)",
        "public int getVersionRequired()",
        "public int getVersionMadeBy()",
        "public int getRawFlag()",
        "public void setRawFlag(final int rawFlag)"
      ],
      "methods": [
        {
          "buggy_method": "  public boolean isUnixSymlink() {\n  return (getUnixMode() & UnixStat.LINK_FLAG) == UnixStat.LINK_FLAG;\n  }",
          "fixed_method": "  public boolean isUnixSymlink() {\n  return (getUnixMode() & UnixStat.FILE_TYPE_FLAG) == UnixStat.LINK_FLAG;\n  }",
          "diff": [
            "@@ -294,7 +294,7 @@",
            "      * @return true if the entry represents a unix symlink, false otherwise.\n",
            "      */\n",
            "     public boolean isUnixSymlink() {\n",
            "-        return (getUnixMode() & UnixStat.LINK_FLAG) == UnixStat.LINK_FLAG;\n",
            "+        return (getUnixMode() & UnixStat.FILE_TYPE_FLAG) == UnixStat.LINK_FLAG;\n",
            "     }\n",
            " \n",
            "     /**\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
