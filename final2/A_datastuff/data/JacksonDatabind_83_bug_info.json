{
  "bug_id": "83",
  "failed_tests": {
    "com.fasterxml.jackson.databind.filter.ProblemHandlerTest": [
      {
        "methodName": "testWeirdStringHandling",
        "error": "com.fasterxml.jackson.databind.exc.InvalidFormatException",
        "message": "Can not deserialize value of type java.util.UUID from String \"not a uuid!\": not a valid textual representation",
        "fail_line": "        UUID result2 = mapper.readValue(quote(\"not a uuid!\"), UUID.class);",
        "test_source": "  public void testWeirdStringHandling() throws Exception {\n  ObjectMapper mapper = new ObjectMapper()\n  .addHandler(new WeirdStringHandler(SingleValuedEnum.A))\n  ;\n  SingleValuedEnum result = mapper.readValue(\"\\\"B\\\"\", SingleValuedEnum.class);\n  assertEquals(SingleValuedEnum.A, result);\n\n  // also, write [databind#1629] try this\n  mapper = new ObjectMapper()\n  .addHandler(new WeirdStringHandler(null));\n  UUID result2 = mapper.readValue(quote(\"not a uuid!\"), UUID.class);\n  assertNull(result2);\n  }",
        "stack": [
          "InvalidFormatException.from line 74, DeserializationContext.weirdStringException line 1410, FromStringDeserializer.deserialize line 135, ObjectMapper._readMapAndClose line 3814, ObjectMapper.readValue line 2858, ProblemHandlerTest.testWeirdStringHandling line 247"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java",
      "buggy_full_code": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.Currency;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport java.util.regex.Pattern;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.util.VersionUtil;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.exc.InvalidFormatException;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\n@SuppressWarnings(\"serial\")\npublic abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T> { public static Class<?>[] types() {\n        return new Class<?>[] {\n            File.class,\n            URL.class,\n            URI.class,\n            Class.class,\n            JavaType.class,\n            Currency.class,\n            Pattern.class,\n            Locale.class,\n            Charset.class,\n            TimeZone.class,\n            InetAddress.class,\n            InetSocketAddress.class,\n            StringBuilder.class,\n        };\n    }\n    \n    \n    \n    protected FromStringDeserializer(Class<?> vc) {\n        super(vc);\n    }\n\n    \n    public static Std findDeserializer(Class<?> rawType) {\n        int kind = 0;\n        if (rawType == File.class) {\n            kind = Std.STD_FILE;\n        } else if (rawType == URL.class) {\n            kind = Std.STD_URL;\n        } else if (rawType == URI.class) {\n            kind = Std.STD_URI;\n        } else if (rawType == Class.class) {\n            kind = Std.STD_CLASS;\n        } else if (rawType == JavaType.class) {\n            kind = Std.STD_JAVA_TYPE;\n        } else if (rawType == Currency.class) {\n            kind = Std.STD_CURRENCY;\n        } else if (rawType == Pattern.class) {\n            kind = Std.STD_PATTERN;\n        } else if (rawType == Locale.class) {\n            kind = Std.STD_LOCALE;\n        } else if (rawType == Charset.class) {\n            kind = Std.STD_CHARSET;\n        } else if (rawType == TimeZone.class) {\n            kind = Std.STD_TIME_ZONE;\n        } else if (rawType == InetAddress.class) {\n            kind = Std.STD_INET_ADDRESS;\n        } else if (rawType == InetSocketAddress.class) {\n            kind = Std.STD_INET_SOCKET_ADDRESS;\n        } else if (rawType == StringBuilder.class) {\n            kind = Std.STD_STRING_BUILDER;\n        } else {\n            return null;\n        }\n        return new Std(rawType, kind);\n    }\n    \n    \n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n        \n        String text = p.getValueAsString();\n        if (text != null) { \n            if (text.length() == 0 || (text = text.trim()).length() == 0) {\n                \n                return _deserializeFromEmptyString();\n            }\n            Exception cause = null;\n            try {\n                \n                \n                \n                if (_deserialize(text, ctxt) != null) {\n                return _deserialize(text, ctxt);\n                }\n            } catch (IllegalArgumentException iae) {\n                cause = iae;\n            } catch (MalformedURLException me) {\n                cause = me;\n            }\n            String msg = \"not a valid textual representation\";\n            if (cause != null) {\n                String m2 = cause.getMessage();\n                if (m2 != null) {\n                    msg = msg + \", problem: \"+m2;\n                }\n            }\n            \n            JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n            if (cause != null) {\n                e.initCause(cause);\n            }\n            throw e;\n            \n        }\n        JsonToken t = p.getCurrentToken();\n        \n        if (t == JsonToken.START_ARRAY) {\n            return _deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            \n            Object ob = p.getEmbeddedObject();\n            if (ob == null) {\n                return null;\n            }\n            if (_valueClass.isAssignableFrom(ob.getClass())) {\n                return (T) ob;\n            }\n            return _deserializeEmbedded(ob, ctxt);\n        }\n        return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n    }\n        \n    protected abstract T _deserialize(String value, DeserializationContext ctxt) throws IOException; protected T _deserializeEmbedded(Object ob, DeserializationContext ctxt) throws IOException {\n        \n        ctxt.reportMappingException(\"Don't know how to convert embedded Object of type %s into %s\",\n                ob.getClass().getName(), _valueClass.getName());\n        return null;\n    }\n\n    protected T _deserializeFromEmptyString() throws IOException {\n        return null;\n    }\n\n    \n\n    \n    public static class Std extends FromStringDeserializer<Object> { private static final long serialVersionUID = 1; public final static int STD_FILE = 1; public final static int STD_URL = 2; public final static int STD_URI = 3; public final static int STD_CLASS = 4; public final static int STD_JAVA_TYPE = 5; public final static int STD_CURRENCY = 6; public final static int STD_PATTERN = 7; public final static int STD_LOCALE = 8; public final static int STD_CHARSET = 9; public final static int STD_TIME_ZONE = 10; public final static int STD_INET_ADDRESS = 11; public final static int STD_INET_SOCKET_ADDRESS = 12; public final static int STD_STRING_BUILDER = 13; protected final int _kind; protected Std(Class<?> valueType, int kind) {\n            super(valueType);\n            _kind = kind;\n        }\n\n        @Override\n        protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n            switch (_kind) {\n            case STD_FILE:\n                return new File(value);\n            case STD_URL:\n                return new URL(value);\n            case STD_URI:\n                return URI.create(value);\n            case STD_CLASS:\n                try {\n                    return ctxt.findClass(value);\n                } catch (Exception e) {\n                    return ctxt.handleInstantiationProblem(_valueClass, value,\n                            ClassUtil.getRootCause(e));\n                }\n            case STD_JAVA_TYPE:\n                return ctxt.getTypeFactory().constructFromCanonical(value);\n            case STD_CURRENCY:\n                \n                return Currency.getInstance(value);\n            case STD_PATTERN:\n                \n                return Pattern.compile(value);\n            case STD_LOCALE:\n                {\n                    int ix = _firstHyphenOrUnderscore(value);\n                    if (ix < 0) { \n                        return new Locale(value);\n                    }\n                    String first = value.substring(0, ix);\n                    value = value.substring(ix+1);\n                    ix = _firstHyphenOrUnderscore(value);\n                    if (ix < 0) { \n                        return new Locale(first, value);\n                    }\n                    String second = value.substring(0, ix);\n                    return new Locale(first, second, value.substring(ix+1));\n                }\n            case STD_CHARSET:\n                return Charset.forName(value);\n            case STD_TIME_ZONE:\n                return TimeZone.getTimeZone(value);\n            case STD_INET_ADDRESS:\n                return InetAddress.getByName(value);\n            case STD_INET_SOCKET_ADDRESS:\n                if (value.startsWith(\"[\")) {\n                    \n\n                    int i = value.lastIndexOf(']');\n                    if (i == -1) {\n                        throw new InvalidFormatException(ctxt.getParser(),\n                                \"Bracketed IPv6 address must contain closing bracket\",\n                                value, InetSocketAddress.class);\n                    }\n\n                    int j = value.indexOf(':', i);\n                    int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                    return new InetSocketAddress(value.substring(0, i + 1), port);\n                }\n                int ix = value.indexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    \n                    int port = Integer.parseInt(value.substring(ix+1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                \n                return new InetSocketAddress(value, 0);\n            case STD_STRING_BUILDER:\n                return new StringBuilder(value);\n            }\n            VersionUtil.throwInternal();\n            return null;\n        }\n\n        @Override\n        protected Object _deserializeFromEmptyString() throws IOException {\n            \n            if (_kind == STD_URI) {\n                return URI.create(\"\");\n            }\n            \n            if (_kind == STD_LOCALE) {\n                return Locale.ROOT;\n            }\n            if (_kind == STD_STRING_BUILDER) {\n                return new StringBuilder();\n            }\n            return super._deserializeFromEmptyString();\n        }\n\n        protected int _firstHyphenOrUnderscore(String str) {\n            for (int i = 0, end = str.length(); i < end; ++i) {\n                char c = str.charAt(i);\n                if (c == '_' || c == '-') {\n                    return i;\n                }\n            }\n            return -1;\n        }\n    }\n}\n",
      "fixed_full_code": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.Currency;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport java.util.regex.Pattern;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.util.VersionUtil;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.exc.InvalidFormatException;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n\n@SuppressWarnings(\"serial\")\npublic abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T> { public static Class<?>[] types() {\n        return new Class<?>[] {\n            File.class,\n            URL.class,\n            URI.class,\n            Class.class,\n            JavaType.class,\n            Currency.class,\n            Pattern.class,\n            Locale.class,\n            Charset.class,\n            TimeZone.class,\n            InetAddress.class,\n            InetSocketAddress.class,\n            StringBuilder.class,\n        };\n    }\n    \n    \n    \n    protected FromStringDeserializer(Class<?> vc) {\n        super(vc);\n    }\n\n    \n    public static Std findDeserializer(Class<?> rawType) {\n        int kind = 0;\n        if (rawType == File.class) {\n            kind = Std.STD_FILE;\n        } else if (rawType == URL.class) {\n            kind = Std.STD_URL;\n        } else if (rawType == URI.class) {\n            kind = Std.STD_URI;\n        } else if (rawType == Class.class) {\n            kind = Std.STD_CLASS;\n        } else if (rawType == JavaType.class) {\n            kind = Std.STD_JAVA_TYPE;\n        } else if (rawType == Currency.class) {\n            kind = Std.STD_CURRENCY;\n        } else if (rawType == Pattern.class) {\n            kind = Std.STD_PATTERN;\n        } else if (rawType == Locale.class) {\n            kind = Std.STD_LOCALE;\n        } else if (rawType == Charset.class) {\n            kind = Std.STD_CHARSET;\n        } else if (rawType == TimeZone.class) {\n            kind = Std.STD_TIME_ZONE;\n        } else if (rawType == InetAddress.class) {\n            kind = Std.STD_INET_ADDRESS;\n        } else if (rawType == InetSocketAddress.class) {\n            kind = Std.STD_INET_SOCKET_ADDRESS;\n        } else if (rawType == StringBuilder.class) {\n            kind = Std.STD_STRING_BUILDER;\n        } else {\n            return null;\n        }\n        return new Std(rawType, kind);\n    }\n    \n    \n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n        \n        String text = p.getValueAsString();\n        if (text != null) { \n            if (text.length() == 0 || (text = text.trim()).length() == 0) {\n                \n                return _deserializeFromEmptyString();\n            }\n            Exception cause = null;\n            try {\n                \n                \n                \n                return _deserialize(text, ctxt);\n            } catch (IllegalArgumentException iae) {\n                cause = iae;\n            } catch (MalformedURLException me) {\n                cause = me;\n            }\n            String msg = \"not a valid textual representation\";\n            if (cause != null) {\n                String m2 = cause.getMessage();\n                if (m2 != null) {\n                    msg = msg + \", problem: \"+m2;\n                }\n            }\n            \n            JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n            if (cause != null) {\n                e.initCause(cause);\n            }\n            throw e;\n            \n        }\n        JsonToken t = p.getCurrentToken();\n        \n        if (t == JsonToken.START_ARRAY) {\n            return _deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            \n            Object ob = p.getEmbeddedObject();\n            if (ob == null) {\n                return null;\n            }\n            if (_valueClass.isAssignableFrom(ob.getClass())) {\n                return (T) ob;\n            }\n            return _deserializeEmbedded(ob, ctxt);\n        }\n        return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n    }\n        \n    protected abstract T _deserialize(String value, DeserializationContext ctxt) throws IOException; protected T _deserializeEmbedded(Object ob, DeserializationContext ctxt) throws IOException {\n        \n        ctxt.reportMappingException(\"Don't know how to convert embedded Object of type %s into %s\",\n                ob.getClass().getName(), _valueClass.getName());\n        return null;\n    }\n\n    protected T _deserializeFromEmptyString() throws IOException {\n        return null;\n    }\n\n    \n\n    \n    public static class Std extends FromStringDeserializer<Object> { private static final long serialVersionUID = 1; public final static int STD_FILE = 1; public final static int STD_URL = 2; public final static int STD_URI = 3; public final static int STD_CLASS = 4; public final static int STD_JAVA_TYPE = 5; public final static int STD_CURRENCY = 6; public final static int STD_PATTERN = 7; public final static int STD_LOCALE = 8; public final static int STD_CHARSET = 9; public final static int STD_TIME_ZONE = 10; public final static int STD_INET_ADDRESS = 11; public final static int STD_INET_SOCKET_ADDRESS = 12; public final static int STD_STRING_BUILDER = 13; protected final int _kind; protected Std(Class<?> valueType, int kind) {\n            super(valueType);\n            _kind = kind;\n        }\n\n        @Override\n        protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n            switch (_kind) {\n            case STD_FILE:\n                return new File(value);\n            case STD_URL:\n                return new URL(value);\n            case STD_URI:\n                return URI.create(value);\n            case STD_CLASS:\n                try {\n                    return ctxt.findClass(value);\n                } catch (Exception e) {\n                    return ctxt.handleInstantiationProblem(_valueClass, value,\n                            ClassUtil.getRootCause(e));\n                }\n            case STD_JAVA_TYPE:\n                return ctxt.getTypeFactory().constructFromCanonical(value);\n            case STD_CURRENCY:\n                \n                return Currency.getInstance(value);\n            case STD_PATTERN:\n                \n                return Pattern.compile(value);\n            case STD_LOCALE:\n                {\n                    int ix = _firstHyphenOrUnderscore(value);\n                    if (ix < 0) { \n                        return new Locale(value);\n                    }\n                    String first = value.substring(0, ix);\n                    value = value.substring(ix+1);\n                    ix = _firstHyphenOrUnderscore(value);\n                    if (ix < 0) { \n                        return new Locale(first, value);\n                    }\n                    String second = value.substring(0, ix);\n                    return new Locale(first, second, value.substring(ix+1));\n                }\n            case STD_CHARSET:\n                return Charset.forName(value);\n            case STD_TIME_ZONE:\n                return TimeZone.getTimeZone(value);\n            case STD_INET_ADDRESS:\n                return InetAddress.getByName(value);\n            case STD_INET_SOCKET_ADDRESS:\n                if (value.startsWith(\"[\")) {\n                    \n\n                    int i = value.lastIndexOf(']');\n                    if (i == -1) {\n                        throw new InvalidFormatException(ctxt.getParser(),\n                                \"Bracketed IPv6 address must contain closing bracket\",\n                                value, InetSocketAddress.class);\n                    }\n\n                    int j = value.indexOf(':', i);\n                    int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                    return new InetSocketAddress(value.substring(0, i + 1), port);\n                }\n                int ix = value.indexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    \n                    int port = Integer.parseInt(value.substring(ix+1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                \n                return new InetSocketAddress(value, 0);\n            case STD_STRING_BUILDER:\n                return new StringBuilder(value);\n            }\n            VersionUtil.throwInternal();\n            return null;\n        }\n\n        @Override\n        protected Object _deserializeFromEmptyString() throws IOException {\n            \n            if (_kind == STD_URI) {\n                return URI.create(\"\");\n            }\n            \n            if (_kind == STD_LOCALE) {\n                return Locale.ROOT;\n            }\n            if (_kind == STD_STRING_BUILDER) {\n                return new StringBuilder();\n            }\n            return super._deserializeFromEmptyString();\n        }\n\n        protected int _firstHyphenOrUnderscore(String str) {\n            for (int i = 0, end = str.length(); i < end; ++i) {\n                char c = str.charAt(i);\n                if (c == '_' || c == '-') {\n                    return i;\n                }\n            }\n            return -1;\n        }\n    }\n}\n",
      "buggy_signatures": [
        "public abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T> { public static Class<?>[] types()",
        "protected FromStringDeserializer(Class<?> vc)",
        "public static Std findDeserializer(Class<?> rawType)",
        "public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected abstract T _deserialize(String value, DeserializationContext ctxt) throws IOException; protected T _deserializeEmbedded(Object ob, DeserializationContext ctxt) throws IOException",
        "protected T _deserializeFromEmptyString() throws IOException",
        "protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException",
        "protected Object _deserializeFromEmptyString() throws IOException",
        "protected int _firstHyphenOrUnderscore(String str)"
      ],
      "fixed_signatures": [
        "public abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T> { public static Class<?>[] types()",
        "protected FromStringDeserializer(Class<?> vc)",
        "public static Std findDeserializer(Class<?> rawType)",
        "public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException",
        "protected abstract T _deserialize(String value, DeserializationContext ctxt) throws IOException; protected T _deserializeEmbedded(Object ob, DeserializationContext ctxt) throws IOException",
        "protected T _deserializeFromEmptyString() throws IOException",
        "protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException",
        "protected Object _deserializeFromEmptyString() throws IOException",
        "protected int _firstHyphenOrUnderscore(String str)"
      ],
      "methods": [
        {
          "buggy_method": "  public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n  \n  String text = p.getValueAsString();\n  if (text != null) { \n  if (text.length() == 0 || (text = text.trim()).length() == 0) {\n  \n  return _deserializeFromEmptyString();\n  }\n  Exception cause = null;\n  try {\n  \n  \n  \n  if (_deserialize(text, ctxt) != null) {\n  return _deserialize(text, ctxt);\n  }\n  } catch (IllegalArgumentException iae) {\n  cause = iae;\n  } catch (MalformedURLException me) {\n  cause = me;\n  }\n  String msg = \"not a valid textual representation\";\n  if (cause != null) {\n  String m2 = cause.getMessage();\n  if (m2 != null) {\n  msg = msg + \", problem: \"+m2;\n  }\n  }\n  \n  JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n  if (cause != null) {\n  e.initCause(cause);\n  }\n  throw e;\n  \n  }\n  JsonToken t = p.getCurrentToken();\n  \n  if (t == JsonToken.START_ARRAY) {\n  return _deserializeFromArray(p, ctxt);\n  }\n  if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n  \n  Object ob = p.getEmbeddedObject();\n  if (ob == null) {\n  return null;\n  }\n  if (_valueClass.isAssignableFrom(ob.getClass())) {\n  return (T) ob;\n  }\n  return _deserializeEmbedded(ob, ctxt);\n  }\n  return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n  }",
          "fixed_method": "  public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n  \n  String text = p.getValueAsString();\n  if (text != null) { \n  if (text.length() == 0 || (text = text.trim()).length() == 0) {\n  \n  return _deserializeFromEmptyString();\n  }\n  Exception cause = null;\n  try {\n  \n  \n  \n  return _deserialize(text, ctxt);\n  } catch (IllegalArgumentException iae) {\n  cause = iae;\n  } catch (MalformedURLException me) {\n  cause = me;\n  }\n  String msg = \"not a valid textual representation\";\n  if (cause != null) {\n  String m2 = cause.getMessage();\n  if (m2 != null) {\n  msg = msg + \", problem: \"+m2;\n  }\n  }\n  \n  JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n  if (cause != null) {\n  e.initCause(cause);\n  }\n  throw e;\n  \n  }\n  JsonToken t = p.getCurrentToken();\n  \n  if (t == JsonToken.START_ARRAY) {\n  return _deserializeFromArray(p, ctxt);\n  }\n  if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n  \n  Object ob = p.getEmbeddedObject();\n  if (ob == null) {\n  return null;\n  }\n  if (_valueClass.isAssignableFrom(ob.getClass())) {\n  return (T) ob;\n  }\n  return _deserializeEmbedded(ob, ctxt);\n  }\n  return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n  }",
          "diff": [
            "@@ -116,9 +116,7 @@",
            "                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n",
            "                 //    indicated error; but that seems wrong. Should be able to return\n",
            "                 //    `null` as value.\n",
            "-                if (_deserialize(text, ctxt) != null) {\n",
            "                 return _deserialize(text, ctxt);\n",
            "-                }\n",
            "             } catch (IllegalArgumentException iae) {\n",
            "                 cause = iae;\n",
            "             } catch (MalformedURLException me) {\n"
          ],
          "changed_lines": 2
        }
      ]
    }
  ]
}
