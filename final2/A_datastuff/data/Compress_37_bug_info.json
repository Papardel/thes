{
  "bug_id": "37",
  "failed_tests": {
    "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest": [
      {
        "methodName": "survivesBlankLinesInPaxHeader",
        "error": "java.lang.NegativeArraySizeException",
        "message": "-3778",
        "fail_line": "            final TarArchiveEntry entry = is.getNextTarEntry();",
        "test_source": "  public void survivesBlankLinesInPaxHeader() throws Exception {\n  final TarArchiveInputStream is = getTestStream(\"/COMPRESS-355.tar\");\n  try {\n  final TarArchiveEntry entry = is.getNextTarEntry();\n  assertEquals(\"package/package.json\", entry.getName());\n  assertNull(is.getNextTarEntry());\n  } finally {\n  is.close();\n  }\n  }",
        "stack": [
          "TarArchiveInputStream.parsePaxHeaders line 474, TarArchiveInputStream.paxHeaders line 444, TarArchiveInputStream.getNextTarEntry line 319, TarArchiveInputStreamTest.survivesBlankLinesInPaxHeader line 308"
        ]
      }
    ]
  },
  "classes": [
    {
      "name": "org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java",
      "buggy_full_code": "\n\n\n\npackage org.apache.commons.compress.archivers.tar;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.archivers.zip.ZipEncoding;\nimport org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\nimport org.apache.commons.compress.utils.ArchiveUtils;\nimport org.apache.commons.compress.utils.CharsetNames;\nimport org.apache.commons.compress.utils.IOUtils;\n\n\npublic class TarArchiveInputStream extends ArchiveInputStream { private static final int SMALL_BUFFER_SIZE = 256; private final byte[] SMALL_BUF = new byte[SMALL_BUFFER_SIZE]; private final int recordSize; private final int blockSize; private boolean hasHitEOF; private long entrySize; private long entryOffset; private final InputStream is; private TarArchiveEntry currEntry; private final ZipEncoding zipEncoding; final String encoding; private Map<String, String> globalPaxHeaders = new HashMap<String, String>(); public TarArchiveInputStream(final InputStream is) {\n        this(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveInputStream(final InputStream is, final String encoding) {\n        this(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE,\n             encoding);\n    }\n\n    \n    public TarArchiveInputStream(final InputStream is, final int blockSize) {\n        this(is, blockSize, TarConstants.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveInputStream(final InputStream is, final int blockSize, final String encoding) {\n        this(is, blockSize, TarConstants.DEFAULT_RCDSIZE, encoding);\n    }\n\n    \n    public TarArchiveInputStream(final InputStream is, final int blockSize, final int recordSize) {\n        this(is, blockSize, recordSize, null);      \n    }\n\n    \n    public TarArchiveInputStream(final InputStream is, final int blockSize, final int recordSize, final String encoding) {\n        this.is = is;\n        this.hasHitEOF = false;\n        this.encoding = encoding;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.recordSize = recordSize;\n        this.blockSize = blockSize;\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        is.close();\n    }\n\n    \n    public int getRecordSize() {\n        return recordSize;\n    }\n\n    \n    @Override\n    public int available() throws IOException {\n        if (isDirectory()) {\n            return 0;\n        }\n        if (entrySize - entryOffset > Integer.MAX_VALUE) {\n            return Integer.MAX_VALUE;\n        }\n        return (int) (entrySize - entryOffset);\n    }\n\n    \n    \n    @Override\n    public long skip(final long n) throws IOException {\n        if (n <= 0 || isDirectory()) {\n            return 0;\n        }\n\n        final long available = entrySize - entryOffset;\n        final long skipped = is.skip(Math.min(n, available)); \n        count(skipped);\n        entryOffset += skipped;\n        return skipped;\n    }\n\n    \n    @Override\n    public boolean markSupported() {\n        return false;\n    }\n\n    \n    @Override\n    public void mark(final int markLimit) {\n    }\n\n    \n    @Override\n    public synchronized void reset() {\n    }\n\n    \n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            \n            IOUtils.skip(this, Long.MAX_VALUE);\n\n            \n            skipRecordPadding();\n        }\n\n        final byte[] headerBuf = getRecord();\n\n        if (headerBuf == null) {\n            \n            currEntry = null;\n            return null;\n        }\n\n        try {\n            currEntry = new TarArchiveEntry(headerBuf, zipEncoding);\n        } catch (final IllegalArgumentException e) {\n            throw new IOException(\"Error detected parsing the header\", e);\n        }\n\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongLinkEntry()) {\n            final byte[] longLinkData = getLongNameData();\n            if (longLinkData == null) {\n                \n                \n                \n                return null;\n            }\n            currEntry.setLinkName(zipEncoding.decode(longLinkData));\n        }\n\n        if (currEntry.isGNULongNameEntry()) {\n            final byte[] longNameData = getLongNameData();\n            if (longNameData == null) {\n                \n                \n                \n                return null;\n            }\n            currEntry.setName(zipEncoding.decode(longNameData));\n        }\n\n        if (currEntry.isGlobalPaxHeader()){ \n            readGlobalPaxHeaders();\n        }\n\n        if (currEntry.isPaxHeader()){ \n            paxHeaders();\n        } else if (!globalPaxHeaders.isEmpty()) {\n            applyPaxHeadersToCurrentEntry(globalPaxHeaders);\n        }\n\n        if (currEntry.isOldGNUSparse()){ \n            readOldGNUSparse();\n        }\n\n        \n        \n        \n        \n        entrySize = currEntry.getSize();\n\n        return currEntry;\n    }\n    \n    \n    private void skipRecordPadding() throws IOException {\n        if (!isDirectory() && this.entrySize > 0 && this.entrySize % this.recordSize != 0) {\n            final long numRecords = (this.entrySize / this.recordSize) + 1;\n            final long padding = (numRecords * this.recordSize) - this.entrySize;\n            final long skipped = IOUtils.skip(is, padding);\n            count(skipped);\n        }\n    }\n\n    \n    protected byte[] getLongNameData() throws IOException {\n        \n        final ByteArrayOutputStream longName = new ByteArrayOutputStream();\n        int length = 0;\n        while ((length = read(SMALL_BUF)) >= 0) {\n            longName.write(SMALL_BUF, 0, length);\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            \n            \n            return null;\n        }\n        byte[] longNameData = longName.toByteArray();\n        \n        length = longNameData.length;\n        while (length > 0 && longNameData[length - 1] == 0) {\n            --length;\n        }\n        if (length != longNameData.length) {\n            final byte[] l = new byte[length];\n            System.arraycopy(longNameData, 0, l, 0, length);\n            longNameData = l;\n        }\n        return longNameData;\n    }\n\n    \n    private byte[] getRecord() throws IOException {\n        byte[] headerBuf = readRecord();\n        hasHitEOF = isEOFRecord(headerBuf);\n        if (hasHitEOF && headerBuf != null) {\n            tryToConsumeSecondEOFRecord();\n            consumeRemainderOfLastBlock();\n            headerBuf = null;\n        }\n        return headerBuf;\n    }\n\n    \n    protected boolean isEOFRecord(final byte[] record) {\n        return record == null || ArchiveUtils.isArrayZero(record, recordSize);\n    }\n    \n    \n    protected byte[] readRecord() throws IOException {\n\n        final byte[] record = new byte[recordSize];\n\n        final int readNow = IOUtils.readFully(is, record);\n        count(readNow);\n        if (readNow != recordSize) {\n            return null;\n        }\n\n        return record;\n    }\n\n    private void readGlobalPaxHeaders() throws IOException {\n        globalPaxHeaders = parsePaxHeaders(this);\n        getNextEntry(); \n    }\n\n    private void paxHeaders() throws IOException {\n        final Map<String, String> headers = parsePaxHeaders(this);\n        getNextEntry(); \n        applyPaxHeadersToCurrentEntry(headers);\n    }\n\n    \n    \n    \n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n        final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n        \n        while(true){ \n            int ch;\n            int len = 0;\n            int read = 0;\n            while((ch = i.read()) != -1) {\n                read++;\n                if (ch == ' '){\n                    \n                    final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                    while((ch = i.read()) != -1) {\n                        read++;\n                        if (ch == '='){ \n                            final String keyword = coll.toString(CharsetNames.UTF_8);\n                            \n                            final int restLen = len - read;\n                            if (restLen == 1) { \n                                headers.remove(keyword);\n                            } else {\n                                final byte[] rest = new byte[restLen];\n                                final int got = IOUtils.readFully(i, rest);\n                                if (got != restLen) {\n                                    throw new IOException(\"Failed to read \"\n                                                          + \"Paxheader. Expected \"\n                                                          + restLen\n                                                          + \" bytes, read \"\n                                                          + got);\n                                }\n                                \n                                final String value = new String(rest, 0,\n                                                          restLen - 1, CharsetNames.UTF_8);\n                                headers.put(keyword, value);\n                            }\n                            break;\n                        }\n                        coll.write((byte) ch);\n                    }\n                    break; \n                }\n                len *= 10;\n                len += ch - '0';\n            }\n            if (ch == -1){ \n                break;\n            }\n        }\n        return headers;\n    }\n\n    private void applyPaxHeadersToCurrentEntry(final Map<String, String> headers) {\n        \n        for (final Entry<String, String> ent : headers.entrySet()){\n            final String key = ent.getKey();\n            final String val = ent.getValue();\n            if (\"path\".equals(key)){\n                currEntry.setName(val);\n            } else if (\"linkpath\".equals(key)){\n                currEntry.setLinkName(val);\n            } else if (\"gid\".equals(key)){\n                currEntry.setGroupId(Long.parseLong(val));\n            } else if (\"gname\".equals(key)){\n                currEntry.setGroupName(val);\n            } else if (\"uid\".equals(key)){\n                currEntry.setUserId(Long.parseLong(val));\n            } else if (\"uname\".equals(key)){\n                currEntry.setUserName(val);\n            } else if (\"size\".equals(key)){\n                currEntry.setSize(Long.parseLong(val));\n            } else if (\"mtime\".equals(key)){\n                currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n            } else if (\"SCHILY.devminor\".equals(key)){\n                currEntry.setDevMinor(Integer.parseInt(val));\n            } else if (\"SCHILY.devmajor\".equals(key)){\n                currEntry.setDevMajor(Integer.parseInt(val));\n            } else if (\"GNU.sparse.size\".equals(key)) {\n                currEntry.fillGNUSparse0xData(headers);\n            } else if (\"GNU.sparse.realsize\".equals(key)) {\n                currEntry.fillGNUSparse1xData(headers);\n            } else if (\"SCHILY.filetype\".equals(key) && \"sparse\".equals(val)) {\n                currEntry.fillStarSparseData(headers);\n            }\n        }\n    }\n\n    \n    private void readOldGNUSparse() throws IOException {\n        \n        if (currEntry.isExtended()) {\n            TarArchiveSparseEntry entry;\n            do {\n                final byte[] headerBuf = getRecord();\n                if (headerBuf == null) {\n                    currEntry = null;\n                    break;\n                }\n                entry = new TarArchiveSparseEntry(headerBuf);\n                \n            } while (entry.isExtended());\n        }\n    }\n\n    private boolean isDirectory() {\n        return currEntry != null && currEntry.isDirectory();\n    }\n\n    \n    @Override\n    public ArchiveEntry getNextEntry() throws IOException {\n        return getNextTarEntry();\n    }\n    \n    \n    private void tryToConsumeSecondEOFRecord() throws IOException {\n        boolean shouldReset = true;\n        final boolean marked = is.markSupported();\n        if (marked) {\n            is.mark(recordSize);\n        }\n        try {\n            shouldReset = !isEOFRecord(readRecord());\n        } finally {\n            if (shouldReset && marked) {\n                pushedBackBytes(recordSize);\n            \tis.reset();\n            }\n        }\n    }\n\n    \n    @Override\n    public int read(final byte[] buf, final int offset, int numToRead) throws IOException {\n    \tint totalRead = 0;\n\n        if (hasHitEOF || isDirectory() || entryOffset >= entrySize) {\n            return -1;\n        }\n\n        if (currEntry == null) {\n            throw new IllegalStateException(\"No current tar entry\");\n        }\n\n        numToRead = Math.min(numToRead, available());\n        \n        totalRead = is.read(buf, offset, numToRead);\n        \n        if (totalRead == -1) {\n            if (numToRead > 0) {\n                throw new IOException(\"Truncated TAR archive\");\n            }\n            hasHitEOF = true;\n        } else {\n            count(totalRead);\n            entryOffset += totalRead;\n        }\n\n        return totalRead;\n    }\n\n    \n    @Override\n    public boolean canReadEntryData(final ArchiveEntry ae) {\n        if (ae instanceof TarArchiveEntry) {\n            final TarArchiveEntry te = (TarArchiveEntry) ae;\n            return !te.isSparse();\n        }\n        return false;\n    }\n\n    \n    public TarArchiveEntry getCurrentEntry() {\n        return currEntry;\n    }\n\n    protected final void setCurrentEntry(final TarArchiveEntry e) {\n        currEntry = e;\n    }\n\n    protected final boolean isAtEOF() {\n        return hasHitEOF;\n    }\n\n    protected final void setAtEOF(final boolean b) {\n        hasHitEOF = b;\n    }\n\n    \n    private void consumeRemainderOfLastBlock() throws IOException {\n        final long bytesReadOfLastBlock = getBytesRead() % blockSize;\n        if (bytesReadOfLastBlock > 0) {\n            final long skipped = IOUtils.skip(is, blockSize - bytesReadOfLastBlock);\n            count(skipped);\n        }\n    }\n\n    \n    public static boolean matches(final byte[] signature, final int length) {\n        if (length < TarConstants.VERSION_OFFSET+TarConstants.VERSIONLEN) {\n            return false;\n        }\n\n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_POSIX,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_POSIX,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n                ){\n            return true;\n        }\n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_GNU,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            (\n             ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_SPACE,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n            ||\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_ZERO,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n            )\n                ){\n            return true;\n        }\n        \n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_ANT,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_ANT,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n                ){\n            return true;\n        }\n        return false;\n    }\n\n}\n",
      "fixed_full_code": "\n\n\n\npackage org.apache.commons.compress.archivers.tar;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.archivers.zip.ZipEncoding;\nimport org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\nimport org.apache.commons.compress.utils.ArchiveUtils;\nimport org.apache.commons.compress.utils.CharsetNames;\nimport org.apache.commons.compress.utils.IOUtils;\n\n\npublic class TarArchiveInputStream extends ArchiveInputStream { private static final int SMALL_BUFFER_SIZE = 256; private final byte[] SMALL_BUF = new byte[SMALL_BUFFER_SIZE]; private final int recordSize; private final int blockSize; private boolean hasHitEOF; private long entrySize; private long entryOffset; private final InputStream is; private TarArchiveEntry currEntry; private final ZipEncoding zipEncoding; final String encoding; private Map<String, String> globalPaxHeaders = new HashMap<String, String>(); public TarArchiveInputStream(final InputStream is) {\n        this(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveInputStream(final InputStream is, final String encoding) {\n        this(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE,\n             encoding);\n    }\n\n    \n    public TarArchiveInputStream(final InputStream is, final int blockSize) {\n        this(is, blockSize, TarConstants.DEFAULT_RCDSIZE);\n    }\n\n    \n    public TarArchiveInputStream(final InputStream is, final int blockSize, final String encoding) {\n        this(is, blockSize, TarConstants.DEFAULT_RCDSIZE, encoding);\n    }\n\n    \n    public TarArchiveInputStream(final InputStream is, final int blockSize, final int recordSize) {\n        this(is, blockSize, recordSize, null);      \n    }\n\n    \n    public TarArchiveInputStream(final InputStream is, final int blockSize, final int recordSize, final String encoding) {\n        this.is = is;\n        this.hasHitEOF = false;\n        this.encoding = encoding;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.recordSize = recordSize;\n        this.blockSize = blockSize;\n    }\n\n    \n    @Override\n    public void close() throws IOException {\n        is.close();\n    }\n\n    \n    public int getRecordSize() {\n        return recordSize;\n    }\n\n    \n    @Override\n    public int available() throws IOException {\n        if (isDirectory()) {\n            return 0;\n        }\n        if (entrySize - entryOffset > Integer.MAX_VALUE) {\n            return Integer.MAX_VALUE;\n        }\n        return (int) (entrySize - entryOffset);\n    }\n\n    \n    \n    @Override\n    public long skip(final long n) throws IOException {\n        if (n <= 0 || isDirectory()) {\n            return 0;\n        }\n\n        final long available = entrySize - entryOffset;\n        final long skipped = is.skip(Math.min(n, available)); \n        count(skipped);\n        entryOffset += skipped;\n        return skipped;\n    }\n\n    \n    @Override\n    public boolean markSupported() {\n        return false;\n    }\n\n    \n    @Override\n    public void mark(final int markLimit) {\n    }\n\n    \n    @Override\n    public synchronized void reset() {\n    }\n\n    \n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            \n            IOUtils.skip(this, Long.MAX_VALUE);\n\n            \n            skipRecordPadding();\n        }\n\n        final byte[] headerBuf = getRecord();\n\n        if (headerBuf == null) {\n            \n            currEntry = null;\n            return null;\n        }\n\n        try {\n            currEntry = new TarArchiveEntry(headerBuf, zipEncoding);\n        } catch (final IllegalArgumentException e) {\n            throw new IOException(\"Error detected parsing the header\", e);\n        }\n\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongLinkEntry()) {\n            final byte[] longLinkData = getLongNameData();\n            if (longLinkData == null) {\n                \n                \n                \n                return null;\n            }\n            currEntry.setLinkName(zipEncoding.decode(longLinkData));\n        }\n\n        if (currEntry.isGNULongNameEntry()) {\n            final byte[] longNameData = getLongNameData();\n            if (longNameData == null) {\n                \n                \n                \n                return null;\n            }\n            currEntry.setName(zipEncoding.decode(longNameData));\n        }\n\n        if (currEntry.isGlobalPaxHeader()){ \n            readGlobalPaxHeaders();\n        }\n\n        if (currEntry.isPaxHeader()){ \n            paxHeaders();\n        } else if (!globalPaxHeaders.isEmpty()) {\n            applyPaxHeadersToCurrentEntry(globalPaxHeaders);\n        }\n\n        if (currEntry.isOldGNUSparse()){ \n            readOldGNUSparse();\n        }\n\n        \n        \n        \n        \n        entrySize = currEntry.getSize();\n\n        return currEntry;\n    }\n    \n    \n    private void skipRecordPadding() throws IOException {\n        if (!isDirectory() && this.entrySize > 0 && this.entrySize % this.recordSize != 0) {\n            final long numRecords = (this.entrySize / this.recordSize) + 1;\n            final long padding = (numRecords * this.recordSize) - this.entrySize;\n            final long skipped = IOUtils.skip(is, padding);\n            count(skipped);\n        }\n    }\n\n    \n    protected byte[] getLongNameData() throws IOException {\n        \n        final ByteArrayOutputStream longName = new ByteArrayOutputStream();\n        int length = 0;\n        while ((length = read(SMALL_BUF)) >= 0) {\n            longName.write(SMALL_BUF, 0, length);\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            \n            \n            return null;\n        }\n        byte[] longNameData = longName.toByteArray();\n        \n        length = longNameData.length;\n        while (length > 0 && longNameData[length - 1] == 0) {\n            --length;\n        }\n        if (length != longNameData.length) {\n            final byte[] l = new byte[length];\n            System.arraycopy(longNameData, 0, l, 0, length);\n            longNameData = l;\n        }\n        return longNameData;\n    }\n\n    \n    private byte[] getRecord() throws IOException {\n        byte[] headerBuf = readRecord();\n        hasHitEOF = isEOFRecord(headerBuf);\n        if (hasHitEOF && headerBuf != null) {\n            tryToConsumeSecondEOFRecord();\n            consumeRemainderOfLastBlock();\n            headerBuf = null;\n        }\n        return headerBuf;\n    }\n\n    \n    protected boolean isEOFRecord(final byte[] record) {\n        return record == null || ArchiveUtils.isArrayZero(record, recordSize);\n    }\n    \n    \n    protected byte[] readRecord() throws IOException {\n\n        final byte[] record = new byte[recordSize];\n\n        final int readNow = IOUtils.readFully(is, record);\n        count(readNow);\n        if (readNow != recordSize) {\n            return null;\n        }\n\n        return record;\n    }\n\n    private void readGlobalPaxHeaders() throws IOException {\n        globalPaxHeaders = parsePaxHeaders(this);\n        getNextEntry(); \n    }\n\n    private void paxHeaders() throws IOException {\n        final Map<String, String> headers = parsePaxHeaders(this);\n        getNextEntry(); \n        applyPaxHeadersToCurrentEntry(headers);\n    }\n\n    \n    \n    \n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n        final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n        \n        while(true){ \n            int ch;\n            int len = 0;\n            int read = 0;\n            while((ch = i.read()) != -1) {\n                read++;\n                if (ch == '\\n') { \n                    break;\n                } else if (ch == ' '){ \n                    \n                    final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                    while((ch = i.read()) != -1) {\n                        read++;\n                        if (ch == '='){ \n                            final String keyword = coll.toString(CharsetNames.UTF_8);\n                            \n                            final int restLen = len - read;\n                            if (restLen == 1) { \n                                headers.remove(keyword);\n                            } else {\n                                final byte[] rest = new byte[restLen];\n                                final int got = IOUtils.readFully(i, rest);\n                                if (got != restLen) {\n                                    throw new IOException(\"Failed to read \"\n                                                          + \"Paxheader. Expected \"\n                                                          + restLen\n                                                          + \" bytes, read \"\n                                                          + got);\n                                }\n                                \n                                final String value = new String(rest, 0,\n                                                          restLen - 1, CharsetNames.UTF_8);\n                                headers.put(keyword, value);\n                            }\n                            break;\n                        }\n                        coll.write((byte) ch);\n                    }\n                    break; \n                }\n                len *= 10;\n                len += ch - '0';\n            }\n            if (ch == -1){ \n                break;\n            }\n        }\n        return headers;\n    }\n\n    private void applyPaxHeadersToCurrentEntry(final Map<String, String> headers) {\n        \n        for (final Entry<String, String> ent : headers.entrySet()){\n            final String key = ent.getKey();\n            final String val = ent.getValue();\n            if (\"path\".equals(key)){\n                currEntry.setName(val);\n            } else if (\"linkpath\".equals(key)){\n                currEntry.setLinkName(val);\n            } else if (\"gid\".equals(key)){\n                currEntry.setGroupId(Long.parseLong(val));\n            } else if (\"gname\".equals(key)){\n                currEntry.setGroupName(val);\n            } else if (\"uid\".equals(key)){\n                currEntry.setUserId(Long.parseLong(val));\n            } else if (\"uname\".equals(key)){\n                currEntry.setUserName(val);\n            } else if (\"size\".equals(key)){\n                currEntry.setSize(Long.parseLong(val));\n            } else if (\"mtime\".equals(key)){\n                currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n            } else if (\"SCHILY.devminor\".equals(key)){\n                currEntry.setDevMinor(Integer.parseInt(val));\n            } else if (\"SCHILY.devmajor\".equals(key)){\n                currEntry.setDevMajor(Integer.parseInt(val));\n            } else if (\"GNU.sparse.size\".equals(key)) {\n                currEntry.fillGNUSparse0xData(headers);\n            } else if (\"GNU.sparse.realsize\".equals(key)) {\n                currEntry.fillGNUSparse1xData(headers);\n            } else if (\"SCHILY.filetype\".equals(key) && \"sparse\".equals(val)) {\n                currEntry.fillStarSparseData(headers);\n            }\n        }\n    }\n\n    \n    private void readOldGNUSparse() throws IOException {\n        \n        if (currEntry.isExtended()) {\n            TarArchiveSparseEntry entry;\n            do {\n                final byte[] headerBuf = getRecord();\n                if (headerBuf == null) {\n                    currEntry = null;\n                    break;\n                }\n                entry = new TarArchiveSparseEntry(headerBuf);\n                \n            } while (entry.isExtended());\n        }\n    }\n\n    private boolean isDirectory() {\n        return currEntry != null && currEntry.isDirectory();\n    }\n\n    \n    @Override\n    public ArchiveEntry getNextEntry() throws IOException {\n        return getNextTarEntry();\n    }\n    \n    \n    private void tryToConsumeSecondEOFRecord() throws IOException {\n        boolean shouldReset = true;\n        final boolean marked = is.markSupported();\n        if (marked) {\n            is.mark(recordSize);\n        }\n        try {\n            shouldReset = !isEOFRecord(readRecord());\n        } finally {\n            if (shouldReset && marked) {\n                pushedBackBytes(recordSize);\n            \tis.reset();\n            }\n        }\n    }\n\n    \n    @Override\n    public int read(final byte[] buf, final int offset, int numToRead) throws IOException {\n    \tint totalRead = 0;\n\n        if (hasHitEOF || isDirectory() || entryOffset >= entrySize) {\n            return -1;\n        }\n\n        if (currEntry == null) {\n            throw new IllegalStateException(\"No current tar entry\");\n        }\n\n        numToRead = Math.min(numToRead, available());\n        \n        totalRead = is.read(buf, offset, numToRead);\n        \n        if (totalRead == -1) {\n            if (numToRead > 0) {\n                throw new IOException(\"Truncated TAR archive\");\n            }\n            hasHitEOF = true;\n        } else {\n            count(totalRead);\n            entryOffset += totalRead;\n        }\n\n        return totalRead;\n    }\n\n    \n    @Override\n    public boolean canReadEntryData(final ArchiveEntry ae) {\n        if (ae instanceof TarArchiveEntry) {\n            final TarArchiveEntry te = (TarArchiveEntry) ae;\n            return !te.isSparse();\n        }\n        return false;\n    }\n\n    \n    public TarArchiveEntry getCurrentEntry() {\n        return currEntry;\n    }\n\n    protected final void setCurrentEntry(final TarArchiveEntry e) {\n        currEntry = e;\n    }\n\n    protected final boolean isAtEOF() {\n        return hasHitEOF;\n    }\n\n    protected final void setAtEOF(final boolean b) {\n        hasHitEOF = b;\n    }\n\n    \n    private void consumeRemainderOfLastBlock() throws IOException {\n        final long bytesReadOfLastBlock = getBytesRead() % blockSize;\n        if (bytesReadOfLastBlock > 0) {\n            final long skipped = IOUtils.skip(is, blockSize - bytesReadOfLastBlock);\n            count(skipped);\n        }\n    }\n\n    \n    public static boolean matches(final byte[] signature, final int length) {\n        if (length < TarConstants.VERSION_OFFSET+TarConstants.VERSIONLEN) {\n            return false;\n        }\n\n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_POSIX,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_POSIX,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n                ){\n            return true;\n        }\n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_GNU,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            (\n             ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_SPACE,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n            ||\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_ZERO,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n            )\n                ){\n            return true;\n        }\n        \n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_ANT,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_ANT,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n                ){\n            return true;\n        }\n        return false;\n    }\n\n}\n",
      "buggy_signatures": [
        "public TarArchiveInputStream(final InputStream is, final String encoding)",
        "public TarArchiveInputStream(final InputStream is, final int blockSize)",
        "public TarArchiveInputStream(final InputStream is, final int blockSize, final String encoding)",
        "public TarArchiveInputStream(final InputStream is, final int blockSize, final int recordSize)",
        "public TarArchiveInputStream(final InputStream is, final int blockSize, final int recordSize, final String encoding)",
        "public void close() throws IOException",
        "public int getRecordSize()",
        "public int available() throws IOException",
        "public long skip(final long n) throws IOException",
        "public boolean markSupported()",
        "public void mark(final int markLimit)",
        "public synchronized void reset()",
        "public TarArchiveEntry getNextTarEntry() throws IOException",
        "private void skipRecordPadding() throws IOException",
        "protected byte[] getLongNameData() throws IOException",
        "private byte[] getRecord() throws IOException",
        "protected boolean isEOFRecord(final byte[] record)",
        "protected byte[] readRecord() throws IOException",
        "private void readGlobalPaxHeaders() throws IOException",
        "private void paxHeaders() throws IOException",
        "private void applyPaxHeadersToCurrentEntry(final Map<String, String> headers)",
        "private void readOldGNUSparse() throws IOException",
        "private boolean isDirectory()",
        "public ArchiveEntry getNextEntry() throws IOException",
        "private void tryToConsumeSecondEOFRecord() throws IOException",
        "public int read(final byte[] buf, final int offset, int numToRead) throws IOException",
        "public boolean canReadEntryData(final ArchiveEntry ae)",
        "public TarArchiveEntry getCurrentEntry()",
        "protected final void setCurrentEntry(final TarArchiveEntry e)",
        "protected final boolean isAtEOF()",
        "protected final void setAtEOF(final boolean b)",
        "private void consumeRemainderOfLastBlock() throws IOException",
        "public static boolean matches(final byte[] signature, final int length)"
      ],
      "fixed_signatures": [
        "public TarArchiveInputStream(final InputStream is, final String encoding)",
        "public TarArchiveInputStream(final InputStream is, final int blockSize)",
        "public TarArchiveInputStream(final InputStream is, final int blockSize, final String encoding)",
        "public TarArchiveInputStream(final InputStream is, final int blockSize, final int recordSize)",
        "public TarArchiveInputStream(final InputStream is, final int blockSize, final int recordSize, final String encoding)",
        "public void close() throws IOException",
        "public int getRecordSize()",
        "public int available() throws IOException",
        "public long skip(final long n) throws IOException",
        "public boolean markSupported()",
        "public void mark(final int markLimit)",
        "public synchronized void reset()",
        "public TarArchiveEntry getNextTarEntry() throws IOException",
        "private void skipRecordPadding() throws IOException",
        "protected byte[] getLongNameData() throws IOException",
        "private byte[] getRecord() throws IOException",
        "protected boolean isEOFRecord(final byte[] record)",
        "protected byte[] readRecord() throws IOException",
        "private void readGlobalPaxHeaders() throws IOException",
        "private void paxHeaders() throws IOException",
        "private void applyPaxHeadersToCurrentEntry(final Map<String, String> headers)",
        "private void readOldGNUSparse() throws IOException",
        "private boolean isDirectory()",
        "public ArchiveEntry getNextEntry() throws IOException",
        "private void tryToConsumeSecondEOFRecord() throws IOException",
        "public int read(final byte[] buf, final int offset, int numToRead) throws IOException",
        "public boolean canReadEntryData(final ArchiveEntry ae)",
        "public TarArchiveEntry getCurrentEntry()",
        "protected final void setCurrentEntry(final TarArchiveEntry e)",
        "protected final boolean isAtEOF()",
        "protected final void setAtEOF(final boolean b)",
        "private void consumeRemainderOfLastBlock() throws IOException",
        "public static boolean matches(final byte[] signature, final int length)"
      ],
      "methods": [
        {
          "buggy_method": "  private void paxHeaders() throws IOException {\n  final Map<String, String> headers = parsePaxHeaders(this);\n  getNextEntry(); \n  applyPaxHeadersToCurrentEntry(headers);\n  }",
          "fixed_method": "  private void paxHeaders() throws IOException {\n  final Map<String, String> headers = parsePaxHeaders(this);\n  getNextEntry(); \n  applyPaxHeadersToCurrentEntry(headers);\n  }",
          "diff": [
            "@@ -459,7 +459,9 @@",
            "             int read = 0;\n",
            "             while((ch = i.read()) != -1) {\n",
            "                 read++;\n",
            "-                if (ch == ' '){\n",
            "+                if (ch == '\\n') { // blank line in header\n",
            "+                    break;\n",
            "+                } else if (ch == ' '){ // End of length string\n",
            "                     // Get keyword\n",
            "                     final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n",
            "                     while((ch = i.read()) != -1) {\n"
          ],
          "changed_lines": 4
        }
      ]
    }
  ]
}
